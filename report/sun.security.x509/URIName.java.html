<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>URIName.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">URIName.java</span></div><h1>URIName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import sun.security.util.*;

/**
 * This class implements the URIName as required by the GeneralNames
 * ASN.1 object.
 * &lt;p&gt;
 * [RFC3280] When the subjectAltName extension contains a URI, the name MUST be
 * stored in the uniformResourceIdentifier (an IA5String). The name MUST
 * be a non-relative URL, and MUST follow the URL syntax and encoding
 * rules specified in [RFC 1738].  The name must include both a scheme
 * (e.g., &quot;http&quot; or &quot;ftp&quot;) and a scheme-specific-part.  The scheme-
 * specific-part must include a fully qualified domain name or IP
 * address as the host.
 * &lt;p&gt;
 * As specified in [RFC 1738], the scheme name is not case-sensitive
 * (e.g., &quot;http&quot; is equivalent to &quot;HTTP&quot;).  The host part is also not
 * case-sensitive, but other components of the scheme-specific-part may
 * be case-sensitive. When comparing URIs, conforming implementations
 * MUST compare the scheme and host without regard to case, but assume
 * the remainder of the scheme-specific-part is case sensitive.
 * &lt;p&gt;
 * [RFC1738] In general, URLs are written as follows:
 * &lt;pre&gt;
 * &lt;scheme&gt;:&lt;scheme-specific-part&gt;
 * &lt;/pre&gt;
 * A URL contains the name of the scheme being used (&lt;scheme&gt;) followed
 * by a colon and then a string (the &lt;scheme-specific-part&gt;) whose
 * interpretation depends on the scheme.
 * &lt;p&gt;
 * While the syntax for the rest of the URL may vary depending on the
 * particular scheme selected, URL schemes that involve the direct use
 * of an IP-based protocol to a specified host on the Internet use a
 * common syntax for the scheme-specific data:
 * &lt;pre&gt;
 * //&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;
 * &lt;/pre&gt;
 * [RFC2732] specifies that an IPv6 address contained inside a URL
 * must be enclosed in square brackets (to allow distinguishing the
 * colons that separate IPv6 components from the colons that separate
 * scheme-specific data.
 * &lt;p&gt;
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 * @author Sean Mullan
 * @author Steve Hanna
 * @see GeneralName
 * @see GeneralNames
 * @see GeneralNameInterface
 */
public class URIName implements GeneralNameInterface {

    // private attributes
    private URI uri;
    private String host;
    private DNSName hostDNS;
    private IPAddressName hostIP;

    /**
     * Create the URIName object from the passed encoded Der value.
     *
     * @param derValue the encoded DER URIName.
     * @exception IOException on error.
     */
    public URIName(DerValue derValue) throws IOException {
<span class="fc" id="L96">        this(derValue.getIA5String());</span>
<span class="fc" id="L97">    }</span>

    /**
     * Create the URIName object with the specified name.
     *
     * @param name the URIName.
     * @throws IOException if name is not a proper URIName
     */
<span class="fc" id="L105">    public URIName(String name) throws IOException {</span>
        try {
<span class="fc" id="L107">            uri = new URI(name);</span>
<span class="nc" id="L108">        } catch (URISyntaxException use) {</span>
<span class="nc" id="L109">            throw new IOException(&quot;invalid URI name:&quot; + name, use);</span>
<span class="fc" id="L110">        }</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (uri.getScheme() == null) {</span>
<span class="nc" id="L112">            throw new IOException(&quot;URI name must include scheme:&quot; + name);</span>
        }

<span class="fc" id="L115">        host = uri.getHost();</span>
        // RFC 3280 says that the host should be non-null, but we allow it to
        // be null because some widely deployed certificates contain CDP
        // extensions with URIs that have no hostname (see bugs 4802236 and
        // 5107944).
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (host != null) {</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">            if (host.charAt(0) == '[') {</span>
                // Verify host is a valid IPv6 address name
<span class="nc" id="L123">                String ipV6Host = host.substring(1, host.length()-1);</span>
                try {
<span class="nc" id="L125">                    hostIP = new IPAddressName(ipV6Host);</span>
<span class="nc" id="L126">                } catch (IOException ioe) {</span>
<span class="nc" id="L127">                    throw new IOException(&quot;invalid URI name (host &quot; +</span>
                        &quot;portion is not a valid IPv6 address):&quot; + name);
<span class="nc" id="L129">                }</span>
<span class="nc" id="L130">            } else {</span>
                try {
<span class="fc" id="L132">                    hostDNS = new DNSName(host);</span>
<span class="nc" id="L133">                } catch (IOException ioe) {</span>
                    // Not a valid DNS Name; see if it is a valid IPv4
                    // IPAddressName
                    try {
<span class="nc" id="L137">                        hostIP = new IPAddressName(host);</span>
<span class="nc" id="L138">                    } catch (Exception ioe2) {</span>
<span class="nc" id="L139">                        throw new IOException(&quot;invalid URI name (host &quot; +</span>
                            &quot;portion is not a valid DNS name, IPv4 address,&quot; +
                            &quot; or IPv6 address):&quot; + name);
<span class="nc" id="L142">                    }</span>
<span class="fc" id="L143">                }</span>
            }
        }
<span class="fc" id="L146">    }</span>

    /**
     * Create the URIName object with the specified name constraint. URI
     * name constraints syntax is different than SubjectAltNames, etc. See
     * 4.2.1.11 of RFC 3280.
     *
     * @param value the URI name constraint
     * @throws IOException if name is not a proper URI name constraint
     */
    public static URIName nameConstraint(DerValue value) throws IOException {
        URI uri;
<span class="nc" id="L158">        String name = value.getIA5String();</span>
        try {
<span class="nc" id="L160">            uri = new URI(name);</span>
<span class="nc" id="L161">        } catch (URISyntaxException use) {</span>
<span class="nc" id="L162">            throw new IOException(&quot;invalid URI name constraint:&quot; + name, use);</span>
<span class="nc" id="L163">        }</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (uri.getScheme() == null) {</span>
<span class="nc" id="L165">            String host = uri.getSchemeSpecificPart();</span>
            try {
                DNSName hostDNS;
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (host.charAt(0) == '.') {</span>
<span class="nc" id="L169">                    hostDNS = new DNSName(host.substring(1));</span>
                } else {
<span class="nc" id="L171">                    hostDNS = new DNSName(host);</span>
                }
<span class="nc" id="L173">                return new URIName(uri, host, hostDNS);</span>
<span class="nc" id="L174">            } catch (IOException ioe) {</span>
<span class="nc" id="L175">                throw new IOException(&quot;invalid URI name constraint:&quot; + name, ioe);</span>
            }
        } else {
<span class="nc" id="L178">            throw new IOException(&quot;invalid URI name constraint (should not &quot; +</span>
                &quot;include scheme):&quot; + name);
        }
    }

<span class="nc" id="L183">    URIName(URI uri, String host, DNSName hostDNS) {</span>
<span class="nc" id="L184">        this.uri = uri;</span>
<span class="nc" id="L185">        this.host = host;</span>
<span class="nc" id="L186">        this.hostDNS = hostDNS;</span>
<span class="nc" id="L187">    }</span>

    /**
     * Return the type of the GeneralName.
     */
    public int getType() {
<span class="nc" id="L193">        return GeneralNameInterface.NAME_URI;</span>
    }

    /**
     * Encode the URI name into the DerOutputStream.
     *
     * @param out the DER stream to encode the URIName to.
     * @exception IOException on encoding errors.
     */
    public void encode(DerOutputStream out) throws IOException {
<span class="nc" id="L203">        out.putIA5String(uri.toASCIIString());</span>
<span class="nc" id="L204">    }</span>

    /**
     * Convert the name into user readable string.
     */
    public String toString() {
<span class="nc" id="L210">        return &quot;URIName: &quot; + uri.toString();</span>
    }

    /**
     * Compares this name with another, for equality.
     *
     * @return true iff the names are equivalent according to RFC2459.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L220">            return true;</span>
        }

<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (!(obj instanceof URIName)) {</span>
<span class="nc" id="L224">            return false;</span>
        }

<span class="nc" id="L227">        URIName other = (URIName) obj;</span>

<span class="nc" id="L229">        return uri.equals(other.getURI());</span>
    }

    /**
     * Returns the URIName as a java.net.URI object
     */
    public URI getURI() {
<span class="nc" id="L236">        return uri;</span>
    }

    /**
     * Returns this URI name.
     */
    public String getName() {
<span class="nc" id="L243">        return uri.toString();</span>
    }

    /**
     * Return the scheme name portion of a URIName
     *
     * @returns scheme portion of full name
     */
    public String getScheme() {
<span class="nc" id="L252">        return uri.getScheme();</span>
    }

    /**
     * Return the host name or IP address portion of the URIName
     *
     * @returns host name or IP address portion of full name
     */
    public String getHost() {
<span class="nc" id="L261">        return host;</span>
    }

    /**
     * Return the host object type; if host name is a
     * DNSName, then this host object does not include any
     * initial &quot;.&quot; on the name.
     *
     * @returns host name as DNSName or IPAddressName
     */
    public Object getHostObject() {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (hostIP != null) {</span>
<span class="nc" id="L273">            return hostIP;</span>
        } else {
<span class="nc" id="L275">            return hostDNS;</span>
        }
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L285">        return uri.hashCode();</span>
    }

    /**
     * Return type of constraint inputName places on this name:&lt;ul&gt;
     *   &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from name
     *       (i.e. does not constrain).
     *   &lt;li&gt;NAME_MATCH = 0: input name matches name.
     *   &lt;li&gt;NAME_NARROWS = 1: input name narrows name (is lower in the naming
     *       subtree)
     *   &lt;li&gt;NAME_WIDENS = 2: input name widens name (is higher in the naming
     *       subtree)
     *   &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow name, but
     *       is same type.
     * &lt;/ul&gt;.
     * These results are used in checking NameConstraints during
     * certification path verification.
     * &lt;p&gt;
     * RFC3280: For URIs, the constraint applies to the host part of the name.
     * The constraint may specify a host or a domain.  Examples would be
     * &quot;foo.bar.com&quot;;  and &quot;.xyz.com&quot;.  When the the constraint begins with
     * a period, it may be expanded with one or more subdomains.  That is,
     * the constraint &quot;.xyz.com&quot; is satisfied by both abc.xyz.com and
     * abc.def.xyz.com.  However, the constraint &quot;.xyz.com&quot; is not satisfied
     * by &quot;xyz.com&quot;.  When the constraint does not begin with a period, it
     * specifies a host.
     * &lt;p&gt;
     * @param inputName to be checked for being constrained
     * @returns constraint type above
     * @throws UnsupportedOperationException if name is not exact match, but
     *  narrowing and widening are not supported for this name type.
     */
    public int constrains(GeneralNameInterface inputName)
        throws UnsupportedOperationException {
        int constraintType;
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (inputName == null) {</span>
<span class="nc" id="L321">            constraintType = NAME_DIFF_TYPE;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        } else if (inputName.getType() != NAME_URI) {</span>
<span class="nc" id="L323">            constraintType = NAME_DIFF_TYPE;</span>
        } else {
            // Assuming from here on that one or both of these is
            // actually a URI name constraint (not a URI), so we
            // only need to compare the host portion of the name

<span class="nc" id="L329">            String otherHost = ((URIName)inputName).getHost();</span>

            // Quick check for equality
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (otherHost.equalsIgnoreCase(host)) {</span>
<span class="nc" id="L333">                constraintType = NAME_MATCH;</span>
            } else {
<span class="nc" id="L335">                Object otherHostObject = ((URIName)inputName).getHostObject();</span>

<span class="nc bnc" id="L337" title="All 4 branches missed.">                if ((hostDNS == null) ||</span>
                    !(otherHostObject instanceof DNSName)) {
                    // If one (or both) is an IP address, only same type
<span class="nc" id="L340">                    constraintType = NAME_SAME_TYPE;</span>
                } else {
                    // Both host portions are DNS names. Are they domains?
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    boolean thisDomain = (host.charAt(0) == '.');</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                    boolean otherDomain = (otherHost.charAt(0) == '.');</span>
<span class="nc" id="L345">                    DNSName otherDNS = (DNSName) otherHostObject;</span>

                    // Run DNSName.constrains.
<span class="nc" id="L348">                    constraintType = hostDNS.constrains(otherDNS);</span>
                    // If neither one is a domain, then they can't
                    // widen or narrow. That's just SAME_TYPE.
<span class="nc bnc" id="L351" title="All 8 branches missed.">                    if ((!thisDomain &amp;&amp; !otherDomain) &amp;&amp;</span>
                        ((constraintType == NAME_WIDENS) ||
                         (constraintType == NAME_NARROWS))) {
<span class="nc" id="L354">                        constraintType = NAME_SAME_TYPE;</span>
                    }

                    // If one is a domain and the other isn't,
                    // then they can't match. The one that's a
                    // domain doesn't include the one that's
                    // not a domain.
<span class="nc bnc" id="L361" title="All 4 branches missed.">                    if ((thisDomain != otherDomain) &amp;&amp;</span>
                        (constraintType == NAME_MATCH)) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">                        if (thisDomain) {</span>
<span class="nc" id="L364">                            constraintType = NAME_WIDENS;</span>
                        } else {
<span class="nc" id="L366">                            constraintType = NAME_NARROWS;</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L372">        return constraintType;</span>
    }

    /**
     * Return subtree depth of this name for purposes of determining
     * NameConstraints minimum and maximum bounds and for calculating
     * path lengths in name subtrees.
     *
     * @returns distance of name from root
     * @throws UnsupportedOperationException if not supported for this name type
     */
    public int subtreeDepth() throws UnsupportedOperationException {
<span class="nc" id="L384">        DNSName dnsName = null;</span>
        try {
<span class="nc" id="L386">            dnsName = new DNSName(host);</span>
<span class="nc" id="L387">        } catch (IOException ioe) {</span>
<span class="nc" id="L388">            throw new UnsupportedOperationException(ioe.getMessage());</span>
<span class="nc" id="L389">        }</span>
<span class="nc" id="L390">        return dnsName.subtreeDepth();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>