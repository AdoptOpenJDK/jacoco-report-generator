<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RFC822Name.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">RFC822Name.java</span></div><h1>RFC822Name.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.IOException;
import java.util.Locale;

import sun.security.util.*;

/**
 * This class implements the RFC822Name as required by the GeneralNames
 * ASN.1 object.
 *
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 * @see GeneralName
 * @see GeneralNames
 * @see GeneralNameInterface
 */
public class RFC822Name implements GeneralNameInterface
{
    private String name;

    /**
     * Create the RFC822Name object from the passed encoded Der value.
     *
     * @param derValue the encoded DER RFC822Name.
     * @exception IOException on error.
     */
<span class="fc" id="L53">    public RFC822Name(DerValue derValue) throws IOException {</span>
<span class="fc" id="L54">        name = derValue.getIA5String();</span>
<span class="fc" id="L55">        parseName(name);</span>
<span class="fc" id="L56">    }</span>

    /**
     * Create the RFC822Name object with the specified name.
     *
     * @param name the RFC822Name.
     * @throws IOException on invalid input name
     */
<span class="nc" id="L64">    public RFC822Name(String name) throws IOException {</span>
<span class="nc" id="L65">        parseName(name);</span>
<span class="nc" id="L66">        this.name = name;</span>
<span class="nc" id="L67">    }</span>

    /**
     * Parse an RFC822Name string to see if it is a valid
     * addr-spec according to IETF RFC822 and RFC2459:
     * [local-part@]domain
     * &lt;p&gt;
     * local-part@ could be empty for an RFC822Name NameConstraint,
     * but the domain at least must be non-empty.  Case is not
     * significant.
     *
     * @param name the RFC822Name string
     * @throws IOException if name is not valid
     */
    public void parseName(String name) throws IOException {
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L83">            throw new IOException(&quot;RFC822Name may not be null or empty&quot;);</span>
        }
        // See if domain is a valid domain name
<span class="fc" id="L86">        String domain = name.substring(name.indexOf('@')+1);</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (domain.length() == 0) {</span>
<span class="nc" id="L88">            throw new IOException(&quot;RFC822Name may not end with @&quot;);</span>
        } else {
            //An RFC822 NameConstraint could start with a ., although
            //a DNSName may not
<span class="fc bfc" id="L92" title="All 2 branches covered.">            if (domain.startsWith(&quot;.&quot;)) {</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                if (domain.length() == 1)</span>
<span class="nc" id="L94">                    throw new IOException(&quot;RFC822Name domain may not be just .&quot;);</span>
            }
        }
<span class="fc" id="L97">    }</span>

    /**
     * Return the type of the GeneralName.
     */
    public int getType() {
<span class="fc" id="L103">        return (GeneralNameInterface.NAME_RFC822);</span>
    }

    /**
     * Return the actual name value of the GeneralName.
     */
    public String getName() {
<span class="fc" id="L110">        return name;</span>
    }

    /**
     * Encode the RFC822 name into the DerOutputStream.
     *
     * @param out the DER stream to encode the RFC822Name to.
     * @exception IOException on encoding errors.
     */
    public void encode(DerOutputStream out) throws IOException {
<span class="nc" id="L120">        out.putIA5String(name);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Convert the name into user readable string.
     */
    public String toString() {
<span class="nc" id="L127">        return (&quot;RFC822Name: &quot; + name);</span>
    }

    /**
     * Compares this name with another, for equality.
     *
     * @return true iff the names are equivalent
     * according to RFC2459.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (this == obj)</span>
<span class="nc" id="L138">            return true;</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (!(obj instanceof RFC822Name))</span>
<span class="nc" id="L141">            return false;</span>

<span class="nc" id="L143">        RFC822Name other = (RFC822Name)obj;</span>

        // RFC2459 mandates that these names are
        // not case-sensitive
<span class="nc" id="L147">        return name.equalsIgnoreCase(other.name);</span>
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L156">        return name.toUpperCase(Locale.ENGLISH).hashCode();</span>
    }

    /**
     * Return constraint type:&lt;ul&gt;
     *   &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from name (i.e. does not constrain)
     *   &lt;li&gt;NAME_MATCH = 0: input name matches name
     *   &lt;li&gt;NAME_NARROWS = 1: input name narrows name
     *   &lt;li&gt;NAME_WIDENS = 2: input name widens name
     *   &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow name, but is same type
     * &lt;/ul&gt;.  These results are used in checking NameConstraints during
     * certification path verification.
     * &lt;p&gt;
     * [RFC2459]    When the subjectAltName extension contains an Internet mail address,
     * the address MUST be included as an rfc822Name. The format of an
     * rfc822Name is an &quot;addr-spec&quot; as defined in RFC 822 [RFC 822]. An
     * addr-spec has the form &quot;local-part@domain&quot;. Note that an addr-spec
     * has no phrase (such as a common name) before it, has no comment (text
     * surrounded in parentheses) after it, and is not surrounded by &quot;&amp;lt;&quot; and
     * &quot;&amp;gt;&quot;. Note that while upper and lower case letters are allowed in an
     * RFC 822 addr-spec, no significance is attached to the case.
     * &lt;p&gt;
     * @param inputName to be checked for being constrained
     * @returns constraint type above
     * @throws UnsupportedOperationException if name is not exact match, but narrowing and widening are
     *          not supported for this name type.
     */
    public int constrains(GeneralNameInterface inputName) throws UnsupportedOperationException {
        int constraintType;
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (inputName == null)</span>
<span class="nc" id="L186">            constraintType = NAME_DIFF_TYPE;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        else if (inputName.getType() != (GeneralNameInterface.NAME_RFC822)) {</span>
<span class="nc" id="L188">            constraintType = NAME_DIFF_TYPE;</span>
        } else {
            //RFC2459 specifies that case is not significant in RFC822Names
<span class="nc" id="L191">            String inName =</span>
<span class="nc" id="L192">                (((RFC822Name)inputName).getName()).toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L193">            String thisName = name.toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (inName.equals(thisName)) {</span>
<span class="nc" id="L195">                constraintType = NAME_MATCH;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            } else if (thisName.endsWith(inName)) {</span>
                /* if both names contain @, then they had to match exactly */
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (inName.indexOf('@') != -1) {</span>
<span class="nc" id="L199">                    constraintType = NAME_SAME_TYPE;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                } else if (inName.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L201">                    constraintType = NAME_WIDENS;</span>
                } else {
<span class="nc" id="L203">                    int inNdx = thisName.lastIndexOf(inName);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                    if (thisName.charAt(inNdx-1) == '@' ) {</span>
<span class="nc" id="L205">                        constraintType = NAME_WIDENS;</span>
                    } else {
<span class="nc" id="L207">                        constraintType = NAME_SAME_TYPE;</span>
                    }
<span class="nc" id="L209">                }</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            } else if (inName.endsWith(thisName)) {</span>
                /* if thisName contains @, then they had to match exactly */
<span class="nc bnc" id="L212" title="All 2 branches missed.">                if (thisName.indexOf('@') != -1) {</span>
<span class="nc" id="L213">                    constraintType = NAME_SAME_TYPE;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                } else if (thisName.startsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L215">                    constraintType = NAME_NARROWS;</span>
                } else {
<span class="nc" id="L217">                    int ndx = inName.lastIndexOf(thisName);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    if (inName.charAt(ndx-1) == '@') {</span>
<span class="nc" id="L219">                        constraintType = NAME_NARROWS;</span>
                    } else {
<span class="nc" id="L221">                        constraintType = NAME_SAME_TYPE;</span>
                    }
<span class="nc" id="L223">                }</span>
            } else {
<span class="nc" id="L225">                constraintType = NAME_SAME_TYPE;</span>
            }
        }
<span class="nc" id="L228">        return constraintType;</span>
    }

    /**
     * Return subtree depth of this name for purposes of determining
     * NameConstraints minimum and maximum bounds.
     *
     * @returns distance of name from root
     * @throws UnsupportedOperationException if not supported for this name type
     */
    public int subtreeDepth() throws UnsupportedOperationException {
<span class="nc" id="L239">        String subtree=name;</span>
<span class="nc" id="L240">        int i=1;</span>

        /* strip off name@ portion */
<span class="nc" id="L243">        int atNdx = subtree.lastIndexOf('@');</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (atNdx &gt;= 0) {</span>
<span class="nc" id="L245">            i++;</span>
<span class="nc" id="L246">            subtree=subtree.substring(atNdx+1);</span>
        }

        /* count dots in dnsname, adding one if dnsname preceded by @ */
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (; subtree.lastIndexOf('.') &gt;= 0; i++) {</span>
<span class="nc" id="L251">            subtree=subtree.substring(0,subtree.lastIndexOf('.'));</span>
        }

<span class="nc" id="L254">        return i;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>