<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NameConstraintsExtension.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">NameConstraintsExtension.java</span></div><h1>NameConstraintsExtension.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.IOException;
import java.io.OutputStream;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.*;

import javax.security.auth.x500.X500Principal;

import sun.security.util.*;
import sun.security.pkcs.PKCS9Attribute;

/**
 * This class defines the Name Constraints Extension.
 * &lt;p&gt;
 * The name constraints extension provides permitted and excluded
 * subtrees that place restrictions on names that may be included within
 * a certificate issued by a given CA.  Restrictions may apply to the
 * subject distinguished name or subject alternative names.  Any name
 * matching a restriction in the excluded subtrees field is invalid
 * regardless of information appearing in the permitted subtrees.
 * &lt;p&gt;
 * The ASN.1 syntax for this is:
 * &lt;pre&gt;
 * NameConstraints ::= SEQUENCE {
 *    permittedSubtrees [0]  GeneralSubtrees OPTIONAL,
 *    excludedSubtrees  [1]  GeneralSubtrees OPTIONAL
 * }
 * GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
 * &lt;/pre&gt;
 *
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 * @see Extension
 * @see CertAttrSet
 */
public class NameConstraintsExtension extends Extension
implements CertAttrSet&lt;String&gt;, Cloneable {
    /**
     * Identifier for this attribute, to be used with the
     * get, set, delete methods of Certificate, x509 type.
     */
    public static final String IDENT = &quot;x509.info.extensions.NameConstraints&quot;;
    /**
     * Attribute names.
     */
    public static final String NAME = &quot;NameConstraints&quot;;
    public static final String PERMITTED_SUBTREES = &quot;permitted_subtrees&quot;;
    public static final String EXCLUDED_SUBTREES = &quot;excluded_subtrees&quot;;

    // Private data members
    private static final byte TAG_PERMITTED = 0;
    private static final byte TAG_EXCLUDED = 1;

<span class="pc" id="L81">    private GeneralSubtrees     permitted = null;</span>
<span class="pc" id="L82">    private GeneralSubtrees     excluded = null;</span>

    private boolean hasMin;
    private boolean hasMax;
<span class="pc" id="L86">    private boolean minMaxValid = false;</span>

    // Recalculate hasMin and hasMax flags.
    private void calcMinMax() throws IOException {
<span class="nc" id="L90">        hasMin = false;</span>
<span class="nc" id="L91">        hasMax = false;</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (excluded != null) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">            for (int i = 0; i &lt; excluded.size(); i++) {</span>
<span class="nc" id="L94">                GeneralSubtree subtree = excluded.get(i);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                if (subtree.getMinimum() != 0)</span>
<span class="nc" id="L96">                    hasMin = true;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                if (subtree.getMaximum() != -1)</span>
<span class="nc" id="L98">                    hasMax = true;</span>
            }
        }

<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (permitted != null) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            for (int i = 0; i &lt; permitted.size(); i++) {</span>
<span class="nc" id="L104">                GeneralSubtree subtree = permitted.get(i);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">                if (subtree.getMinimum() != 0)</span>
<span class="nc" id="L106">                    hasMin = true;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                if (subtree.getMaximum() != -1)</span>
<span class="nc" id="L108">                    hasMax = true;</span>
            }
        }
<span class="nc" id="L111">        minMaxValid = true;</span>
<span class="nc" id="L112">    }</span>

    // Encode this extension value.
    private void encodeThis() throws IOException {
<span class="nc" id="L116">        minMaxValid = false;</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (permitted == null &amp;&amp; excluded == null) {</span>
<span class="nc" id="L118">            this.extensionValue = null;</span>
<span class="nc" id="L119">            return;</span>
        }
<span class="nc" id="L121">        DerOutputStream seq = new DerOutputStream();</span>

<span class="nc" id="L123">        DerOutputStream tagged = new DerOutputStream();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (permitted != null) {</span>
<span class="nc" id="L125">            DerOutputStream tmp = new DerOutputStream();</span>
<span class="nc" id="L126">            permitted.encode(tmp);</span>
<span class="nc" id="L127">            tagged.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                 true, TAG_PERMITTED), tmp);
        }
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (excluded != null) {</span>
<span class="nc" id="L131">            DerOutputStream tmp = new DerOutputStream();</span>
<span class="nc" id="L132">            excluded.encode(tmp);</span>
<span class="nc" id="L133">            tagged.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,</span>
                                 true, TAG_EXCLUDED), tmp);
        }
<span class="nc" id="L136">        seq.write(DerValue.tag_Sequence, tagged);</span>
<span class="nc" id="L137">        this.extensionValue = seq.toByteArray();</span>
<span class="nc" id="L138">    }</span>

    /**
     * The default constructor for this class. Both parameters
     * are optional and can be set to null.  The extension criticality
     * is set to true.
     *
     * @param permitted the permitted GeneralSubtrees (null for optional).
     * @param excluded the excluded GeneralSubtrees (null for optional).
     */
    public NameConstraintsExtension(GeneralSubtrees permitted,
                                    GeneralSubtrees excluded)
<span class="nc" id="L150">    throws IOException {</span>
<span class="nc" id="L151">        this.permitted = permitted;</span>
<span class="nc" id="L152">        this.excluded = excluded;</span>

<span class="nc" id="L154">        this.extensionId = PKIXExtensions.NameConstraints_Id;</span>
<span class="nc" id="L155">        this.critical = true;</span>
<span class="nc" id="L156">        encodeThis();</span>
<span class="nc" id="L157">    }</span>

    /**
     * Create the extension from the passed DER encoded value.
     *
     * @param critical true if the extension is to be treated as critical.
     * @param value an array of DER encoded bytes of the actual value.
     * @exception ClassCastException if value is not an array of bytes
     * @exception IOException on error.
     */
    public NameConstraintsExtension(Boolean critical, Object value)
<span class="fc" id="L168">    throws IOException {</span>
<span class="fc" id="L169">        this.extensionId = PKIXExtensions.NameConstraints_Id;</span>
<span class="fc" id="L170">        this.critical = critical.booleanValue();</span>

<span class="fc" id="L172">        this.extensionValue = (byte[]) value;</span>
<span class="fc" id="L173">        DerValue val = new DerValue(this.extensionValue);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (val.tag != DerValue.tag_Sequence) {</span>
<span class="nc" id="L175">            throw new IOException(&quot;Invalid encoding for&quot; +</span>
                                  &quot; NameConstraintsExtension.&quot;);
        }

        // NB. this is always encoded with the IMPLICIT tag
        // The checks only make sense if we assume implicit tagging,
        // with explicit tagging the form is always constructed.
        // Note that all the fields in NameConstraints are defined as
        // being OPTIONAL, i.e., there could be an empty SEQUENCE, resulting
        // in val.data being null.
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (val.data == null)</span>
<span class="nc" id="L186">            return;</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        while (val.data.available() != 0) {</span>
<span class="fc" id="L188">            DerValue opt = val.data.getDerValue();</span>

<span class="pc bpc" id="L190" title="2 of 4 branches missed.">            if (opt.isContextSpecific(TAG_PERMITTED) &amp;&amp; opt.isConstructed()) {</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                if (permitted != null) {</span>
<span class="nc" id="L192">                    throw new IOException(&quot;Duplicate permitted &quot; +</span>
                         &quot;GeneralSubtrees in NameConstraintsExtension.&quot;);
                }
<span class="fc" id="L195">                opt.resetTag(DerValue.tag_Sequence);</span>
<span class="fc" id="L196">                permitted = new GeneralSubtrees(opt);</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">            } else if (opt.isContextSpecific(TAG_EXCLUDED) &amp;&amp;</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                       opt.isConstructed()) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (excluded != null) {</span>
<span class="nc" id="L201">                    throw new IOException(&quot;Duplicate excluded &quot; +</span>
                             &quot;GeneralSubtrees in NameConstraintsExtension.&quot;);
                }
<span class="nc" id="L204">                opt.resetTag(DerValue.tag_Sequence);</span>
<span class="nc" id="L205">                excluded = new GeneralSubtrees(opt);</span>
            } else
<span class="nc" id="L207">                throw new IOException(&quot;Invalid encoding of &quot; +</span>
                                      &quot;NameConstraintsExtension.&quot;);
<span class="fc" id="L209">        }</span>
<span class="fc" id="L210">        minMaxValid = false;</span>
<span class="fc" id="L211">    }</span>

    /**
     * Return the printable string.
     */
    public String toString() {
<span class="nc bnc" id="L217" title="All 2 branches missed.">        return (super.toString() + &quot;NameConstraints: [&quot; +</span>
                ((permitted == null) ? &quot;&quot; :
<span class="nc bnc" id="L219" title="All 2 branches missed.">                     (&quot;\n    Permitted:&quot; + permitted.toString())) +</span>
                ((excluded == null) ? &quot;&quot; :
<span class="nc" id="L221">                     (&quot;\n    Excluded:&quot; + excluded.toString()))</span>
                + &quot;   ]\n&quot;);
    }

    /**
     * Write the extension to the OutputStream.
     *
     * @param out the OutputStream to write the extension to.
     * @exception IOException on encoding errors.
     */
    public void encode(OutputStream out) throws IOException {
<span class="nc" id="L232">        DerOutputStream tmp = new DerOutputStream();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (this.extensionValue == null) {</span>
<span class="nc" id="L234">            this.extensionId = PKIXExtensions.NameConstraints_Id;</span>
<span class="nc" id="L235">            this.critical = true;</span>
<span class="nc" id="L236">            encodeThis();</span>
        }
<span class="nc" id="L238">        super.encode(tmp);</span>
<span class="nc" id="L239">        out.write(tmp.toByteArray());</span>
<span class="nc" id="L240">    }</span>

    /**
     * Set the attribute value.
     */
    public void set(String name, Object obj) throws IOException {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (name.equalsIgnoreCase(PERMITTED_SUBTREES)) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (!(obj instanceof GeneralSubtrees)) {</span>
<span class="nc" id="L248">                throw new IOException(&quot;Attribute value should be&quot;</span>
                                    + &quot; of type GeneralSubtrees.&quot;);
            }
<span class="nc" id="L251">            permitted = (GeneralSubtrees)obj;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        } else if (name.equalsIgnoreCase(EXCLUDED_SUBTREES)) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (!(obj instanceof GeneralSubtrees)) {</span>
<span class="nc" id="L254">                throw new IOException(&quot;Attribute value should be &quot;</span>
                                    + &quot;of type GeneralSubtrees.&quot;);
            }
<span class="nc" id="L257">            excluded = (GeneralSubtrees)obj;</span>
        } else {
<span class="nc" id="L259">          throw new IOException(&quot;Attribute name not recognized by &quot; +</span>
                        &quot;CertAttrSet:NameConstraintsExtension.&quot;);
        }
<span class="nc" id="L262">        encodeThis();</span>
<span class="nc" id="L263">    }</span>

    /**
     * Get the attribute value.
     */
    public GeneralSubtrees get(String name) throws IOException {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (name.equalsIgnoreCase(PERMITTED_SUBTREES)) {</span>
<span class="nc" id="L270">            return (permitted);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        } else if (name.equalsIgnoreCase(EXCLUDED_SUBTREES)) {</span>
<span class="nc" id="L272">            return (excluded);</span>
        } else {
<span class="nc" id="L274">          throw new IOException(&quot;Attribute name not recognized by &quot; +</span>
                        &quot;CertAttrSet:NameConstraintsExtension.&quot;);
        }
    }

    /**
     * Delete the attribute value.
     */
    public void delete(String name) throws IOException {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (name.equalsIgnoreCase(PERMITTED_SUBTREES)) {</span>
<span class="nc" id="L284">            permitted = null;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        } else if (name.equalsIgnoreCase(EXCLUDED_SUBTREES)) {</span>
<span class="nc" id="L286">            excluded = null;</span>
        } else {
<span class="nc" id="L288">          throw new IOException(&quot;Attribute name not recognized by &quot; +</span>
                        &quot;CertAttrSet:NameConstraintsExtension.&quot;);
        }
<span class="nc" id="L291">        encodeThis();</span>
<span class="nc" id="L292">    }</span>

    /**
     * Return an enumeration of names of attributes existing within this
     * attribute.
     */
    public Enumeration&lt;String&gt; getElements() {
<span class="nc" id="L299">        AttributeNameEnumeration elements = new AttributeNameEnumeration();</span>
<span class="nc" id="L300">        elements.addElement(PERMITTED_SUBTREES);</span>
<span class="nc" id="L301">        elements.addElement(EXCLUDED_SUBTREES);</span>

<span class="nc" id="L303">        return (elements.elements());</span>
    }

    /**
     * Return the name of this attribute.
     */
    public String getName() {
<span class="fc" id="L310">        return (NAME);</span>
    }

    /**
     * Merge additional name constraints with existing ones.
     * This function is used in certification path processing
     * to accumulate name constraints from successive certificates
     * in the path.  Note that NameConstraints can never be
     * expanded by a merge, just remain constant or become more
     * limiting.
     * &lt;p&gt;
     * IETF RFC2459 specifies the processing of Name Constraints as
     * follows:
     * &lt;p&gt;
     * (j)  If permittedSubtrees is present in the certificate, set the
     * constrained subtrees state variable to the intersection of its
     * previous value and the value indicated in the extension field.
     * &lt;p&gt;
     * (k)  If excludedSubtrees is present in the certificate, set the
     * excluded subtrees state variable to the union of its previous
     * value and the value indicated in the extension field.
     * &lt;p&gt;
     * @param newConstraints additional NameConstraints to be applied
     * @throws IOException on error
     */
    public void merge(NameConstraintsExtension newConstraints)
            throws IOException {

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (newConstraints == null) {</span>
            // absence of any explicit constraints implies unconstrained
<span class="nc" id="L340">            return;</span>
        }

        /*
         * If excludedSubtrees is present in the certificate, set the
         * excluded subtrees state variable to the union of its previous
         * value and the value indicated in the extension field.
         */

<span class="nc" id="L349">        GeneralSubtrees newExcluded = newConstraints.get(EXCLUDED_SUBTREES);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (excluded == null) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            excluded = (newExcluded != null) ?</span>
<span class="nc" id="L352">                        (GeneralSubtrees)newExcluded.clone() : null;</span>
        } else {
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (newExcluded != null) {</span>
                // Merge new excluded with current excluded (union)
<span class="nc" id="L356">                excluded.union(newExcluded);</span>
            }
        }

        /*
         * If permittedSubtrees is present in the certificate, set the
         * constrained subtrees state variable to the intersection of its
         * previous value and the value indicated in the extension field.
         */

<span class="nc" id="L366">        GeneralSubtrees newPermitted = newConstraints.get(PERMITTED_SUBTREES);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (permitted == null) {</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            permitted = (newPermitted != null) ?</span>
<span class="nc" id="L369">                        (GeneralSubtrees)newPermitted.clone() : null;</span>
        } else {
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (newPermitted != null) {</span>
                // Merge new permitted with current permitted (intersection)
<span class="nc" id="L373">                newExcluded = permitted.intersect(newPermitted);</span>

                // Merge new excluded subtrees to current excluded (union)
<span class="nc bnc" id="L376" title="All 2 branches missed.">                if (newExcluded != null) {</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">                    if (excluded != null) {</span>
<span class="nc" id="L378">                        excluded.union(newExcluded);</span>
                    } else {
<span class="nc" id="L380">                        excluded = (GeneralSubtrees)newExcluded.clone();</span>
                    }
                }
            }
        }

        // Optional optimization: remove permitted subtrees that are excluded.
        // This is not necessary for algorithm correctness, but it makes
        // subsequent operations on the NameConstraints faster and require
        // less space.
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (permitted != null) {</span>
<span class="nc" id="L391">            permitted.reduce(excluded);</span>
        }

        // The NameConstraints have been changed, so re-encode them.  Methods in
        // this class assume that the encodings have already been done.
<span class="nc" id="L396">        encodeThis();</span>

<span class="nc" id="L398">    }</span>

    /**
     * check whether a certificate conforms to these NameConstraints.
     * This involves verifying that the subject name and subjectAltName
     * extension (critical or noncritical) is consistent with the permitted
     * subtrees state variables.  Also verify that the subject name and
     * subjectAltName extension (critical or noncritical) is consistent with
     * the excluded subtrees state variables.
     *
     * @param cert X509Certificate to be verified
     * @returns true if certificate verifies successfully
     * @throws IOException on error
     */
    public boolean verify(X509Certificate cert) throws IOException {

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (cert == null) {</span>
<span class="nc" id="L415">            throw new IOException(&quot;Certificate is null&quot;);</span>
        }

        // Calculate hasMin and hasMax booleans (if necessary)
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (!minMaxValid) {</span>
<span class="nc" id="L420">            calcMinMax();</span>
        }

<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (hasMin) {</span>
<span class="nc" id="L424">            throw new IOException(&quot;Non-zero minimum BaseDistance in&quot;</span>
                                + &quot; name constraints not supported&quot;);
        }

<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (hasMax) {</span>
<span class="nc" id="L429">            throw new IOException(&quot;Maximum BaseDistance in&quot;</span>
                                + &quot; name constraints not supported&quot;);
        }

<span class="nc" id="L433">        X500Principal subjectPrincipal = cert.getSubjectX500Principal();</span>
<span class="nc" id="L434">        X500Name subject = X500Name.asX500Name(subjectPrincipal);</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (subject.isEmpty() == false) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            if (verify(subject) == false) {</span>
<span class="nc" id="L438">                return false;</span>
            }
        }

<span class="nc" id="L442">        GeneralNames altNames = null;</span>
        // extract altNames
        try {
            // extract extensions, if any, from certInfo
            // following returns null if certificate contains no extensions
<span class="nc" id="L447">            X509CertImpl certImpl = X509CertImpl.toImpl(cert);</span>
<span class="nc" id="L448">            SubjectAlternativeNameExtension altNameExt =</span>
<span class="nc" id="L449">                certImpl.getSubjectAlternativeNameExtension();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (altNameExt != null) {</span>
                // extract altNames from extension; this call does not
                // return an IOException on null altnames
<span class="nc" id="L453">                altNames = altNameExt.get(</span>
                        SubjectAlternativeNameExtension.SUBJECT_NAME);
            }
<span class="nc" id="L456">        } catch (CertificateException ce) {</span>
<span class="nc" id="L457">            throw new IOException(&quot;Unable to extract extensions from &quot; +</span>
<span class="nc" id="L458">                        &quot;certificate: &quot; + ce.getMessage());</span>
<span class="nc" id="L459">        }</span>

        // If there are no subjectAlternativeNames, perform the special-case
        // check where if the subjectName contains any EMAILADDRESS
        // attributes, they must be checked against RFC822 constraints.
        // If that passes, we're fine.
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (altNames == null) {</span>
<span class="nc" id="L466">            return verifyRFC822SpecialCase(subject);</span>
        }

        // verify each subjectAltName
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int i = 0; i &lt; altNames.size(); i++) {</span>
<span class="nc" id="L471">            GeneralNameInterface altGNI = altNames.get(i).getName();</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (!verify(altGNI)) {</span>
<span class="nc" id="L473">                return false;</span>
            }
        }

        // All tests passed.
<span class="nc" id="L478">        return true;</span>
    }

    /**
     * check whether a name conforms to these NameConstraints.
     * This involves verifying that the name is consistent with the
     * permitted and excluded subtrees variables.
     *
     * @param name GeneralNameInterface name to be verified
     * @returns true if certificate verifies successfully
     * @throws IOException on error
     */
    public boolean verify(GeneralNameInterface name) throws IOException {
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L492">            throw new IOException(&quot;name is null&quot;);</span>
        }

        // Verify that the name is consistent with the excluded subtrees
<span class="nc bnc" id="L496" title="All 4 branches missed.">        if (excluded != null &amp;&amp; excluded.size() &gt; 0) {</span>

<span class="nc bnc" id="L498" title="All 2 branches missed.">            for (int i = 0; i &lt; excluded.size(); i++) {</span>
<span class="nc" id="L499">                GeneralSubtree gs = excluded.get(i);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (gs == null)</span>
<span class="nc" id="L501">                    continue;</span>
<span class="nc" id="L502">                GeneralName gn = gs.getName();</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if (gn == null)</span>
<span class="nc" id="L504">                    continue;</span>
<span class="nc" id="L505">                GeneralNameInterface exName = gn.getName();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (exName == null)</span>
<span class="nc" id="L507">                    continue;</span>

                // if name matches or narrows any excluded subtree,
                // return false
<span class="nc bnc" id="L511" title="All 3 branches missed.">                switch (exName.constrains(name)) {</span>
                case GeneralNameInterface.NAME_DIFF_TYPE:
                case GeneralNameInterface.NAME_WIDENS: // name widens excluded
                case GeneralNameInterface.NAME_SAME_TYPE:
<span class="nc" id="L515">                    break;</span>
                case GeneralNameInterface.NAME_MATCH:
                case GeneralNameInterface.NAME_NARROWS: // subject name excluded
<span class="nc" id="L518">                    return false;</span>
                }
            }
        }

        // Verify that the name is consistent with the permitted subtrees
<span class="nc bnc" id="L524" title="All 4 branches missed.">        if (permitted != null &amp;&amp; permitted.size() &gt; 0) {</span>

<span class="nc" id="L526">            boolean sameType = false;</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">            for (int i = 0; i &lt; permitted.size(); i++) {</span>
<span class="nc" id="L529">                GeneralSubtree gs = permitted.get(i);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                if (gs == null)</span>
<span class="nc" id="L531">                    continue;</span>
<span class="nc" id="L532">                GeneralName gn = gs.getName();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (gn == null)</span>
<span class="nc" id="L534">                    continue;</span>
<span class="nc" id="L535">                GeneralNameInterface perName = gn.getName();</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                if (perName == null)</span>
<span class="nc" id="L537">                    continue;</span>

                // if Name matches any type in permitted,
                // and Name does not match or narrow some permitted subtree,
                // return false
<span class="nc bnc" id="L542" title="All 4 branches missed.">                switch (perName.constrains(name)) {</span>
                case GeneralNameInterface.NAME_DIFF_TYPE:
<span class="nc" id="L544">                    continue; // continue checking other permitted names</span>
                case GeneralNameInterface.NAME_WIDENS: // name widens permitted
                case GeneralNameInterface.NAME_SAME_TYPE:
<span class="nc" id="L547">                    sameType = true;</span>
<span class="nc" id="L548">                    continue; // continue to look for a match or narrow</span>
                case GeneralNameInterface.NAME_MATCH:
                case GeneralNameInterface.NAME_NARROWS:
                    // name narrows permitted
<span class="nc" id="L552">                    return true; // name is definitely OK, so break out of loop</span>
                }
            }
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (sameType) {</span>
<span class="nc" id="L556">                return false;</span>
            }
        }
<span class="nc" id="L559">        return true;</span>
    }

    /**
     * Perform the RFC 822 special case check. We have a certificate
     * that does not contain any subject alternative names. Check that
     * any EMAILADDRESS attributes in its subject name conform to these
     * NameConstraints.
     *
     * @param subject the certificate's subject name
     * @returns true if certificate verifies successfully
     * @throws IOException on error
     */
    public boolean verifyRFC822SpecialCase(X500Name subject) throws IOException {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        for (AVA ava : subject.allAvas()) {</span>
<span class="nc" id="L574">            ObjectIdentifier attrOID = ava.getObjectIdentifier();</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (attrOID.equals((Object)PKCS9Attribute.EMAIL_ADDRESS_OID)) {</span>
<span class="nc" id="L576">                String attrValue = ava.getValueString();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (attrValue != null) {</span>
                    RFC822Name emailName;
                    try {
<span class="nc" id="L580">                        emailName = new RFC822Name(attrValue);</span>
<span class="nc" id="L581">                    } catch (IOException ioe) {</span>
<span class="nc" id="L582">                        continue;</span>
<span class="nc" id="L583">                    }</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                    if (!verify(emailName)) {</span>
<span class="nc" id="L585">                        return(false);</span>
                    }
                }
             }
<span class="nc" id="L589">        }</span>
<span class="nc" id="L590">        return true;</span>
    }

    /**
     * Clone all objects that may be modified during certificate validation.
     */
    public Object clone() {
        try {
<span class="nc" id="L598">            NameConstraintsExtension newNCE =</span>
<span class="nc" id="L599">                (NameConstraintsExtension) super.clone();</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">            if (permitted != null) {</span>
<span class="nc" id="L602">                newNCE.permitted = (GeneralSubtrees) permitted.clone();</span>
            }
<span class="nc bnc" id="L604" title="All 2 branches missed.">            if (excluded != null) {</span>
<span class="nc" id="L605">                newNCE.excluded = (GeneralSubtrees) excluded.clone();</span>
            }
<span class="nc" id="L607">            return newNCE;</span>
<span class="nc" id="L608">        } catch (CloneNotSupportedException cnsee) {</span>
<span class="nc" id="L609">            throw new RuntimeException(&quot;CloneNotSupportedException while &quot; +</span>
                &quot;cloning NameConstraintsException. This should never happen.&quot;);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>