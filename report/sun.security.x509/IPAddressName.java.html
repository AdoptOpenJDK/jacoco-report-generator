<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>IPAddressName.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">IPAddressName.java</span></div><h1>IPAddressName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2002, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.IOException;
import java.lang.Integer;
import java.net.InetAddress;
import java.util.Arrays;
import sun.misc.HexDumpEncoder;
import sun.security.util.BitArray;
import sun.security.util.DerOutputStream;
import sun.security.util.DerValue;

/**
 * This class implements the IPAddressName as required by the GeneralNames
 * ASN.1 object.  Both IPv4 and IPv6 addresses are supported using the
 * formats specified in IETF PKIX RFC2459.
 * &lt;p&gt;
 * [RFC2459 4.2.1.7 Subject Alternative Name]
 * When the subjectAltName extension contains a iPAddress, the address
 * MUST be stored in the octet string in &quot;network byte order,&quot; as
 * specified in RFC 791. The least significant bit (LSB) of
 * each octet is the LSB of the corresponding byte in the network
 * address. For IP Version 4, as specified in RFC 791, the octet string
 * MUST contain exactly four octets.  For IP Version 6, as specified in
 * RFC 1883, the octet string MUST contain exactly sixteen octets.
 * &lt;p&gt;
 * [RFC2459 4.2.1.11 Name Constraints]
 * The syntax of iPAddress MUST be as described in section 4.2.1.7 with
 * the following additions specifically for Name Constraints.  For IPv4
 * addresses, the ipAddress field of generalName MUST contain eight (8)
 * octets, encoded in the style of RFC 1519 (CIDR) to represent an
 * address range.[RFC 1519]  For IPv6 addresses, the ipAddress field
 * MUST contain 32 octets similarly encoded.  For example, a name
 * constraint for &quot;class C&quot; subnet 10.9.8.0 shall be represented as the
 * octets 0A 09 08 00 FF FF FF 00, representing the CIDR notation
 * 10.9.8.0/255.255.255.0.
 * &lt;p&gt;
 * @see GeneralName
 * @see GeneralNameInterface
 * @see GeneralNames
 *
 *
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 */
public class IPAddressName implements GeneralNameInterface {
    private byte[] address;
    private boolean isIPv4;
    private String name;

    /**
     * Create the IPAddressName object from the passed encoded Der value.
     *
     * @params derValue the encoded DER IPAddressName.
     * @exception IOException on error.
     */
    public IPAddressName(DerValue derValue) throws IOException {
<span class="fc" id="L82">        this(derValue.getOctetString());</span>
<span class="fc" id="L83">    }</span>

    /**
     * Create the IPAddressName object with the specified octets.
     *
     * @params address the IP address
     * @throws IOException if address is not a valid IPv4 or IPv6 address
     */
<span class="fc" id="L91">    public IPAddressName(byte[] address) throws IOException {</span>
        /*
         * A valid address must consist of 4 bytes of address and
         * optional 4 bytes of 4 bytes of mask, or 16 bytes of address
         * and optional 16 bytes of mask.
         */
<span class="pc bpc" id="L97" title="3 of 4 branches missed.">        if (address.length == 4 || address.length == 8) {</span>
<span class="fc" id="L98">            isIPv4 = true;</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">        } else if (address.length == 16 || address.length == 32) {</span>
<span class="nc" id="L100">            isIPv4 = false;</span>
        } else {
<span class="nc" id="L102">            throw new IOException(&quot;Invalid IPAddressName&quot;);</span>
        }
<span class="fc" id="L104">        this.address = address;</span>
<span class="fc" id="L105">    }</span>

    /**
     * Create an IPAddressName from a String.
     * [IETF RFC1338 Supernetting &amp; IETF RFC1519 Classless Inter-Domain
     * Routing (CIDR)] For IPv4 addresses, the forms are
     * &quot;b1.b2.b3.b4&quot; or &quot;b1.b2.b3.b4/m1.m2.m3.m4&quot;, where b1 - b4 are decimal
     * byte values 0-255 and m1 - m4 are decimal mask values
     * 0 - 255.
     * &lt;p&gt;
     * [IETF RFC2373 IP Version 6 Addressing Architecture]
     * For IPv6 addresses, the forms are &quot;a1:a2:...:a8&quot; or &quot;a1:a2:...:a8/n&quot;,
     * where a1-a8 are hexadecimal values representing the eight 16-bit pieces
     * of the address. If /n is used, n is a decimal number indicating how many
     * of the leftmost contiguous bits of the address comprise the prefix for
     * this subnet. Internally, a mask value is created using the prefix length.
     * &lt;p&gt;
     * @param name String form of IPAddressName
     * @throws IOException if name can not be converted to a valid IPv4 or IPv6
     *     address
     */
<span class="nc" id="L126">    public IPAddressName(String name) throws IOException {</span>

<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L129">            throw new IOException(&quot;IPAddress cannot be null or empty&quot;);</span>
        }
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (name.charAt(name.length() - 1) == '/') {</span>
<span class="nc" id="L132">            throw new IOException(&quot;Invalid IPAddress: &quot; + name);</span>
        }

<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (name.indexOf(':') &gt;= 0) {</span>
            // name is IPv6: uses colons as value separators
            // Parse name into byte-value address components and optional
            // prefix
<span class="nc" id="L139">            parseIPv6(name);</span>
<span class="nc" id="L140">            isIPv4 = false;</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        } else if (name.indexOf('.') &gt;= 0) {</span>
            //name is IPv4: uses dots as value separators
<span class="nc" id="L143">            parseIPv4(name);</span>
<span class="nc" id="L144">            isIPv4 = true;</span>
        } else {
<span class="nc" id="L146">            throw new IOException(&quot;Invalid IPAddress: &quot; + name);</span>
        }
<span class="nc" id="L148">    }</span>

    /**
     * Parse an IPv4 address.
     *
     * @param name IPv4 address with optional mask values
     * @throws IOException on error
     */
    private void parseIPv4(String name) throws IOException {

        // Parse name into byte-value address components
<span class="nc" id="L159">        int slashNdx = name.indexOf('/');</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (slashNdx == -1) {</span>
<span class="nc" id="L161">            address = InetAddress.getByName(name).getAddress();</span>
        } else {
<span class="nc" id="L163">            address = new byte[8];</span>

            // parse mask
<span class="nc" id="L166">            byte[] mask = InetAddress.getByName</span>
<span class="nc" id="L167">                (name.substring(slashNdx+1)).getAddress();</span>

            // parse base address
<span class="nc" id="L170">            byte[] host = InetAddress.getByName</span>
<span class="nc" id="L171">                (name.substring(0, slashNdx)).getAddress();</span>

<span class="nc" id="L173">            System.arraycopy(host, 0, address, 0, 4);</span>
<span class="nc" id="L174">            System.arraycopy(mask, 0, address, 4, 4);</span>
        }
<span class="nc" id="L176">    }</span>

    /**
     * Parse an IPv6 address.
     *
     * @param name String IPv6 address with optional /&lt;prefix length&gt;
     *             If /&lt;prefix length&gt; is present, address[] array will
     *             be 32 bytes long, otherwise 16.
     * @throws IOException on error
     */
    private final static int MASKSIZE = 16;
    private void parseIPv6(String name) throws IOException {

<span class="nc" id="L189">        int slashNdx = name.indexOf('/');</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (slashNdx == -1) {</span>
<span class="nc" id="L191">            address = InetAddress.getByName(name).getAddress();</span>
        } else {
<span class="nc" id="L193">            address = new byte[32];</span>
<span class="nc" id="L194">            byte[] base = InetAddress.getByName</span>
<span class="nc" id="L195">                (name.substring(0, slashNdx)).getAddress();</span>
<span class="nc" id="L196">            System.arraycopy(base, 0, address, 0, 16);</span>

            // append a mask corresponding to the num of prefix bits specified
<span class="nc" id="L199">            int prefixLen = Integer.parseInt(name.substring(slashNdx+1));</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (prefixLen &gt; 128)</span>
<span class="nc" id="L201">                throw new IOException(&quot;IPv6Address prefix is longer than 128&quot;);</span>

            // create new bit array initialized to zeros
<span class="nc" id="L204">            BitArray bitArray = new BitArray(MASKSIZE * 8);</span>

            // set all most significant bits up to prefix length
<span class="nc bnc" id="L207" title="All 2 branches missed.">            for (int i = 0; i &lt; prefixLen; i++)</span>
<span class="nc" id="L208">                bitArray.set(i, true);</span>
<span class="nc" id="L209">            byte[] maskArray = bitArray.toByteArray();</span>

            // copy mask bytes into mask portion of address
<span class="nc bnc" id="L212" title="All 2 branches missed.">            for (int i = 0; i &lt; MASKSIZE; i++)</span>
<span class="nc" id="L213">                address[MASKSIZE+i] = maskArray[i];</span>
        }
<span class="nc" id="L215">    }</span>

    /**
     * Return the type of the GeneralName.
     */
    public int getType() {
<span class="fc" id="L221">        return NAME_IP;</span>
    }

    /**
     * Encode the IPAddress name into the DerOutputStream.
     *
     * @params out the DER stream to encode the IPAddressName to.
     * @exception IOException on encoding errors.
     */
    public void encode(DerOutputStream out) throws IOException {
<span class="nc" id="L231">        out.putOctetString(address);</span>
<span class="nc" id="L232">    }</span>

    /**
     * Return a printable string of IPaddress
     */
    public String toString() {
        try {
<span class="nc" id="L239">            return &quot;IPAddress: &quot; + getName();</span>
<span class="nc" id="L240">        } catch (IOException ioe) {</span>
            // dump out hex rep for debugging purposes
<span class="nc" id="L242">            HexDumpEncoder enc = new HexDumpEncoder();</span>
<span class="nc" id="L243">            return &quot;IPAddress: &quot; + enc.encodeBuffer(address);</span>
        }
    }

    /**
     * Return a standard String representation of IPAddress.
     * See IPAddressName(String) for the formats used for IPv4
     * and IPv6 addresses.
     *
     * @throws IOException if the IPAddress cannot be converted to a String
     */
    public String getName() throws IOException {
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (name != null)</span>
<span class="nc" id="L256">            return name;</span>

<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (isIPv4) {</span>
            //IPv4 address or subdomain
<span class="fc" id="L260">            byte[] host = new byte[4];</span>
<span class="fc" id="L261">            System.arraycopy(address, 0, host, 0, 4);</span>
<span class="fc" id="L262">            name = InetAddress.getByAddress(host).getHostAddress();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">            if (address.length == 8) {</span>
<span class="nc" id="L264">                byte[] mask = new byte[4];</span>
<span class="nc" id="L265">                System.arraycopy(address, 4, mask, 0, 4);</span>
<span class="nc" id="L266">                name = name + &quot;/&quot; +</span>
<span class="nc" id="L267">                       InetAddress.getByAddress(mask).getHostAddress();</span>
            }
<span class="fc" id="L269">        } else {</span>
            //IPv6 address or subdomain
<span class="nc" id="L271">            byte[] host = new byte[16];</span>
<span class="nc" id="L272">            System.arraycopy(address, 0, host, 0, 16);</span>
<span class="nc" id="L273">            name = InetAddress.getByAddress(host).getHostAddress();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (address.length == 32) {</span>
                // IPv6 subdomain: display prefix length

                // copy subdomain into new array and convert to BitArray
<span class="nc" id="L278">                byte[] maskBytes = new byte[16];</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                for (int i=16; i &lt; 32; i++)</span>
<span class="nc" id="L280">                    maskBytes[i-16] = address[i];</span>
<span class="nc" id="L281">                BitArray ba = new BitArray(16*8, maskBytes);</span>
                // Find first zero bit
<span class="nc" id="L283">                int i=0;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                for (; i &lt; 16*8; i++) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                    if (!ba.get(i))</span>
<span class="nc" id="L286">                        break;</span>
                }
<span class="nc" id="L288">                name = name + &quot;/&quot; + i;</span>
                // Verify remaining bits 0
<span class="nc bnc" id="L290" title="All 2 branches missed.">                for (; i &lt; 16*8; i++) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                    if (ba.get(i)) {</span>
<span class="nc" id="L292">                        throw new IOException(&quot;Invalid IPv6 subdomain - set &quot; +</span>
                            &quot;bit &quot; + i + &quot; not contiguous&quot;);
                    }
                }
            }
        }
<span class="fc" id="L298">        return name;</span>
    }

    /**
     * Returns this IPAddress name as a byte array.
     */
    public byte[] getBytes() {
<span class="nc" id="L305">        return address.clone();</span>
    }

    /**
     * Compares this name with another, for equality.
     *
     * @return true iff the names are identical.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (this == obj)</span>
<span class="nc" id="L315">            return true;</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (!(obj instanceof IPAddressName))</span>
<span class="nc" id="L318">            return false;</span>

<span class="nc" id="L320">        byte[] other = ((IPAddressName)obj).getBytes();</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (other.length != address.length)</span>
<span class="nc" id="L323">            return false;</span>

<span class="nc bnc" id="L325" title="All 4 branches missed.">        if (address.length == 8 || address.length == 32) {</span>
            // Two subnet addresses
            // Mask each and compare masked values
<span class="nc" id="L328">            int maskLen = address.length/2;</span>
<span class="nc" id="L329">            byte[] maskedThis = new byte[maskLen];</span>
<span class="nc" id="L330">            byte[] maskedOther = new byte[maskLen];</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">            for (int i=0; i &lt; maskLen; i++) {</span>
<span class="nc" id="L332">                maskedThis[i] = (byte)(address[i] &amp; address[i+maskLen]);</span>
<span class="nc" id="L333">                maskedOther[i] = (byte)(other[i] &amp; other[i+maskLen]);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (maskedThis[i] != maskedOther[i]) {</span>
<span class="nc" id="L335">                    return false;</span>
                }
            }
            // Now compare masks
<span class="nc bnc" id="L339" title="All 2 branches missed.">            for (int i=maskLen; i &lt; address.length; i++)</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                if (address[i] != other[i])</span>
<span class="nc" id="L341">                    return false;</span>
<span class="nc" id="L342">            return true;</span>
        } else {
            // Two IPv4 host addresses or two IPv6 host addresses
            // Compare bytes
<span class="nc" id="L346">            return Arrays.equals(other, address);</span>
        }
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L356">        int retval = 0;</span>

<span class="nc bnc" id="L358" title="All 2 branches missed.">        for (int i=0; i&lt;address.length; i++)</span>
<span class="nc" id="L359">            retval += address[i] * i;</span>

<span class="nc" id="L361">        return retval;</span>
    }

    /**
     * Return type of constraint inputName places on this name:&lt;ul&gt;
     *   &lt;li&gt;NAME_DIFF_TYPE = -1: input name is different type from name
     *       (i.e. does not constrain).
     *   &lt;li&gt;NAME_MATCH = 0: input name matches name.
     *   &lt;li&gt;NAME_NARROWS = 1: input name narrows name (is lower in the naming
     *       subtree)
     *   &lt;li&gt;NAME_WIDENS = 2: input name widens name (is higher in the naming
     *       subtree)
     *   &lt;li&gt;NAME_SAME_TYPE = 3: input name does not match or narrow name, but
     *       is same type.
     * &lt;/ul&gt;.  These results are used in checking NameConstraints during
     * certification path verification.
     * &lt;p&gt;
     * [RFC2459] The syntax of iPAddress MUST be as described in section
     * 4.2.1.7 with the following additions specifically for Name Constraints.
     * For IPv4 addresses, the ipAddress field of generalName MUST contain
     * eight (8) octets, encoded in the style of RFC 1519 (CIDR) to represent an
     * address range.[RFC 1519]  For IPv6 addresses, the ipAddress field
     * MUST contain 32 octets similarly encoded.  For example, a name
     * constraint for &quot;class C&quot; subnet 10.9.8.0 shall be represented as the
     * octets 0A 09 08 00 FF FF FF 00, representing the CIDR notation
     * 10.9.8.0/255.255.255.0.
     * &lt;p&gt;
     * @param inputName to be checked for being constrained
     * @returns constraint type above
     * @throws UnsupportedOperationException if name is not exact match, but
     * narrowing and widening are not supported for this name type.
     */
    public int constrains(GeneralNameInterface inputName)
    throws UnsupportedOperationException {
        int constraintType;
<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (inputName == null)</span>
<span class="nc" id="L397">            constraintType = NAME_DIFF_TYPE;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        else if (inputName.getType() != NAME_IP)</span>
<span class="nc" id="L399">            constraintType = NAME_DIFF_TYPE;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        else if (((IPAddressName)inputName).equals(this))</span>
<span class="nc" id="L401">            constraintType = NAME_MATCH;</span>
        else {
<span class="nc" id="L403">            byte[] otherAddress = ((IPAddressName)inputName).getBytes();</span>
<span class="nc bnc" id="L404" title="All 4 branches missed.">            if (otherAddress.length == 4 &amp;&amp; address.length == 4)</span>
                // Two host addresses
<span class="nc" id="L406">                constraintType = NAME_SAME_TYPE;</span>
<span class="nc bnc" id="L407" title="All 8 branches missed.">            else if ((otherAddress.length == 8 &amp;&amp; address.length == 8) ||</span>
                     (otherAddress.length == 32 &amp;&amp; address.length == 32)) {
                // Two subnet addresses
                // See if one address fully encloses the other address
<span class="nc" id="L411">                boolean otherSubsetOfThis = true;</span>
<span class="nc" id="L412">                boolean thisSubsetOfOther = true;</span>
<span class="nc" id="L413">                boolean thisEmpty = false;</span>
<span class="nc" id="L414">                boolean otherEmpty = false;</span>
<span class="nc" id="L415">                int maskOffset = address.length/2;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                for (int i=0; i &lt; maskOffset; i++) {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                    if ((byte)(address[i] &amp; address[i+maskOffset]) != address[i])</span>
<span class="nc" id="L418">                        thisEmpty=true;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                    if ((byte)(otherAddress[i] &amp; otherAddress[i+maskOffset]) != otherAddress[i])</span>
<span class="nc" id="L420">                        otherEmpty=true;</span>
<span class="nc bnc" id="L421" title="All 4 branches missed.">                    if (!(((byte)(address[i+maskOffset] &amp; otherAddress[i+maskOffset]) == address[i+maskOffset]) &amp;&amp;</span>
                          ((byte)(address[i]   &amp; address[i+maskOffset])      == (byte)(otherAddress[i] &amp; address[i+maskOffset])))) {
<span class="nc" id="L423">                        otherSubsetOfThis = false;</span>
                    }
<span class="nc bnc" id="L425" title="All 4 branches missed.">                    if (!(((byte)(otherAddress[i+maskOffset] &amp; address[i+maskOffset])      == otherAddress[i+maskOffset]) &amp;&amp;</span>
                          ((byte)(otherAddress[i]   &amp; otherAddress[i+maskOffset]) == (byte)(address[i] &amp; otherAddress[i+maskOffset])))) {
<span class="nc" id="L427">                        thisSubsetOfOther = false;</span>
                    }
                }
<span class="nc bnc" id="L430" title="All 4 branches missed.">                if (thisEmpty || otherEmpty) {</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">                    if (thisEmpty &amp;&amp; otherEmpty)</span>
<span class="nc" id="L432">                        constraintType = NAME_MATCH;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                    else if (thisEmpty)</span>
<span class="nc" id="L434">                        constraintType = NAME_WIDENS;</span>
                    else
<span class="nc" id="L436">                        constraintType = NAME_NARROWS;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                } else if (otherSubsetOfThis)</span>
<span class="nc" id="L438">                    constraintType = NAME_NARROWS;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                else if (thisSubsetOfOther)</span>
<span class="nc" id="L440">                    constraintType = NAME_WIDENS;</span>
                else
<span class="nc" id="L442">                    constraintType = NAME_SAME_TYPE;</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">            } else if (otherAddress.length == 8 || otherAddress.length == 32) {</span>
                //Other is a subnet, this is a host address
<span class="nc" id="L445">                int i = 0;</span>
<span class="nc" id="L446">                int maskOffset = otherAddress.length/2;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                for (; i &lt; maskOffset; i++) {</span>
                    // Mask this address by other address mask and compare to other address
                    // If all match, then this address is in other address subnet
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if ((address[i] &amp; otherAddress[i+maskOffset]) != otherAddress[i])</span>
<span class="nc" id="L451">                        break;</span>
                }
<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (i == maskOffset)</span>
<span class="nc" id="L454">                    constraintType = NAME_WIDENS;</span>
                else
<span class="nc" id="L456">                    constraintType = NAME_SAME_TYPE;</span>
<span class="nc bnc" id="L457" title="All 4 branches missed.">            } else if (address.length == 8 || address.length == 32) {</span>
                //This is a subnet, other is a host address
<span class="nc" id="L459">                int i = 0;</span>
<span class="nc" id="L460">                int maskOffset = address.length/2;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                for (; i &lt; maskOffset; i++) {</span>
                    // Mask other address by this address mask and compare to this address
<span class="nc bnc" id="L463" title="All 2 branches missed.">                    if ((otherAddress[i] &amp; address[i+maskOffset]) != address[i])</span>
<span class="nc" id="L464">                        break;</span>
                }
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (i == maskOffset)</span>
<span class="nc" id="L467">                    constraintType = NAME_NARROWS;</span>
                else
<span class="nc" id="L469">                    constraintType = NAME_SAME_TYPE;</span>
<span class="nc" id="L470">            } else {</span>
<span class="nc" id="L471">                constraintType = NAME_SAME_TYPE;</span>
            }
        }
<span class="nc" id="L474">        return constraintType;</span>
    }

    /**
     * Return subtree depth of this name for purposes of determining
     * NameConstraints minimum and maximum bounds and for calculating
     * path lengths in name subtrees.
     *
     * @returns distance of name from root
     * @throws UnsupportedOperationException if not supported for this name type
     */
    public int subtreeDepth() throws UnsupportedOperationException {
<span class="nc" id="L486">        throw new UnsupportedOperationException</span>
            (&quot;subtreeDepth() not defined for IPAddressName&quot;);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>