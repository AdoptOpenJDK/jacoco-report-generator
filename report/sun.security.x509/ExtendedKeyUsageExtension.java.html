<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ExtendedKeyUsageExtension.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">ExtendedKeyUsageExtension.java</span></div><h1>ExtendedKeyUsageExtension.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import sun.security.util.DerValue;
import sun.security.util.DerOutputStream;
import sun.security.util.ObjectIdentifier;

/**
 * This class defines the Extended Key Usage Extension, which
 * indicates one or more purposes for which the certified public key
 * may be used, in addition to or in place of the basic purposes
 * indicated in the key usage extension field.  This field is defined
 * as follows:&lt;p&gt;
 *
 * id-ce-extKeyUsage OBJECT IDENTIFIER ::= {id-ce 37}&lt;p&gt;
 *
 * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId&lt;p&gt;
 *
 * KeyPurposeId ::= OBJECT IDENTIFIER&lt;p&gt;
 *
 * Key purposes may be defined by any organization with a need. Object
 * identifiers used to identify key purposes shall be assigned in
 * accordance with IANA or ITU-T Rec. X.660 | ISO/IEC/ITU 9834-1.&lt;p&gt;
 *
 * This extension may, at the option of the certificate issuer, be
 * either critical or non-critical.&lt;p&gt;
 *
 * If the extension is flagged critical, then the certificate MUST be
 * used only for one of the purposes indicated.&lt;p&gt;
 *
 * If the extension is flagged non-critical, then it indicates the
 * intended purpose or purposes of the key, and may be used in finding
 * the correct key/certificate of an entity that has multiple
 * keys/certificates. It is an advisory field and does not imply that
 * usage of the key is restricted by the certification authority to
 * the purpose indicated. Certificate using applications may
 * nevertheless require that a particular purpose be indicated in
 * order for the certificate to be acceptable to that application.&lt;p&gt;

 * If a certificate contains both a critical key usage field and a
 * critical extended key usage field, then both fields MUST be
 * processed independently and the certificate MUST only be used for a
 * purpose consistent with both fields.  If there is no purpose
 * consistent with both fields, then the certificate MUST NOT be used
 * for any purpose.&lt;p&gt;
 *
 * @since       1.4
 */
public class ExtendedKeyUsageExtension extends Extension
implements CertAttrSet&lt;String&gt; {

    /**
     * Identifier for this attribute, to be used with the
     * get, set, delete methods of Certificate, x509 type.
     */
    public static final String IDENT = &quot;x509.info.extensions.ExtendedKeyUsage&quot;;

    /**
     * Attribute names.
     */
    public static final String NAME = &quot;ExtendedKeyUsage&quot;;
    public static final String USAGES = &quot;usages&quot;;

    // OID defined in RFC 3280 Sections 4.2.1.13
    // more from http://www.alvestrand.no/objectid/1.3.6.1.5.5.7.3.html
<span class="fc" id="L99">    private static final Map &lt;ObjectIdentifier, String&gt; map =</span>
            new HashMap &lt;ObjectIdentifier, String&gt; ();

<span class="fc" id="L102">    private static final int[] anyExtendedKeyUsageOidData = {2, 5, 29, 37, 0};</span>
<span class="fc" id="L103">    private static final int[] serverAuthOidData = {1, 3, 6, 1, 5, 5, 7, 3, 1};</span>
<span class="fc" id="L104">    private static final int[] clientAuthOidData = {1, 3, 6, 1, 5, 5, 7, 3, 2};</span>
<span class="fc" id="L105">    private static final int[] codeSigningOidData = {1, 3, 6, 1, 5, 5, 7, 3, 3};</span>
<span class="fc" id="L106">    private static final int[] emailProtectionOidData = {1, 3, 6, 1, 5, 5, 7, 3, 4};</span>
<span class="fc" id="L107">    private static final int[] ipsecEndSystemOidData = {1, 3, 6, 1, 5, 5, 7, 3, 5};</span>
<span class="fc" id="L108">    private static final int[] ipsecTunnelOidData = {1, 3, 6, 1, 5, 5, 7, 3, 6};</span>
<span class="fc" id="L109">    private static final int[] ipsecUserOidData = {1, 3, 6, 1, 5, 5, 7, 3, 7};</span>
<span class="fc" id="L110">    private static final int[] timeStampingOidData = {1, 3, 6, 1, 5, 5, 7, 3, 8};</span>
<span class="fc" id="L111">    private static final int[] OCSPSigningOidData = {1, 3, 6, 1, 5, 5, 7, 3, 9};</span>

    static {
<span class="fc" id="L114">        map.put(ObjectIdentifier.newInternal(anyExtendedKeyUsageOidData), &quot;anyExtendedKeyUsage&quot;);</span>
<span class="fc" id="L115">        map.put(ObjectIdentifier.newInternal(serverAuthOidData), &quot;serverAuth&quot;);</span>
<span class="fc" id="L116">        map.put(ObjectIdentifier.newInternal(clientAuthOidData), &quot;clientAuth&quot;);</span>
<span class="fc" id="L117">        map.put(ObjectIdentifier.newInternal(codeSigningOidData), &quot;codeSigning&quot;);</span>
<span class="fc" id="L118">        map.put(ObjectIdentifier.newInternal(emailProtectionOidData), &quot;emailProtection&quot;);</span>
<span class="fc" id="L119">        map.put(ObjectIdentifier.newInternal(ipsecEndSystemOidData), &quot;ipsecEndSystem&quot;);</span>
<span class="fc" id="L120">        map.put(ObjectIdentifier.newInternal(ipsecTunnelOidData), &quot;ipsecTunnel&quot;);</span>
<span class="fc" id="L121">        map.put(ObjectIdentifier.newInternal(ipsecUserOidData), &quot;ipsecUser&quot;);</span>
<span class="fc" id="L122">        map.put(ObjectIdentifier.newInternal(timeStampingOidData), &quot;timeStamping&quot;);</span>
<span class="fc" id="L123">        map.put(ObjectIdentifier.newInternal(OCSPSigningOidData), &quot;OCSPSigning&quot;);</span>
<span class="fc" id="L124">    };</span>

    /**
     * Vector of KeyUsages for this object.
     */
    private Vector&lt;ObjectIdentifier&gt; keyUsages;

    // Encode this extension value.
    private void encodeThis() throws IOException {
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if (keyUsages == null || keyUsages.isEmpty()) {</span>
<span class="nc" id="L134">            this.extensionValue = null;</span>
<span class="nc" id="L135">            return;</span>
        }
<span class="nc" id="L137">        DerOutputStream os = new DerOutputStream();</span>
<span class="nc" id="L138">        DerOutputStream tmp = new DerOutputStream();</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int i = 0; i &lt; keyUsages.size(); i++) {</span>
<span class="nc" id="L141">            tmp.putOID(keyUsages.elementAt(i));</span>
        }

<span class="nc" id="L144">        os.write(DerValue.tag_Sequence, tmp);</span>
<span class="nc" id="L145">        this.extensionValue = os.toByteArray();</span>
<span class="nc" id="L146">    }</span>

    /**
     * Create a ExtendedKeyUsageExtension object from
     * a Vector of Key Usages; the criticality is set to false.
     *
     * @param keyUsages the Vector of KeyUsages (ObjectIdentifiers)
     */
    public ExtendedKeyUsageExtension(Vector&lt;ObjectIdentifier&gt; keyUsages)
    throws IOException {
<span class="nc" id="L156">        this(Boolean.FALSE, keyUsages);</span>
<span class="nc" id="L157">    }</span>

    /**
     * Create a ExtendedKeyUsageExtension object from
     * a Vector of KeyUsages with specified criticality.
     *
     * @param critical true if the extension is to be treated as critical.
     * @param keyUsages the Vector of KeyUsages (ObjectIdentifiers)
     */
    public ExtendedKeyUsageExtension(Boolean critical, Vector&lt;ObjectIdentifier&gt; keyUsages)
<span class="nc" id="L167">    throws IOException {</span>
<span class="nc" id="L168">        this.keyUsages = keyUsages;</span>
<span class="nc" id="L169">        this.extensionId = PKIXExtensions.ExtendedKeyUsage_Id;</span>
<span class="nc" id="L170">        this.critical = critical.booleanValue();</span>
<span class="nc" id="L171">        encodeThis();</span>
<span class="nc" id="L172">    }</span>

    /**
     * Create the extension from its DER encoded value and criticality.
     *
     * @param critical true if the extension is to be treated as critical.
     * @param value an array of DER encoded bytes of the actual value.
     * @exception ClassCastException if value is not an array of bytes
     * @exception IOException on error.
     */
    public ExtendedKeyUsageExtension(Boolean critical, Object value)
<span class="fc" id="L183">    throws IOException {</span>
<span class="fc" id="L184">        this.extensionId = PKIXExtensions.ExtendedKeyUsage_Id;</span>
<span class="fc" id="L185">        this.critical = critical.booleanValue();</span>
<span class="fc" id="L186">        this.extensionValue = (byte[]) value;</span>
<span class="fc" id="L187">        DerValue val = new DerValue(this.extensionValue);</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (val.tag != DerValue.tag_Sequence) {</span>
<span class="nc" id="L189">            throw new IOException(&quot;Invalid encoding for &quot; +</span>
                                   &quot;ExtendedKeyUsageExtension.&quot;);
        }
<span class="fc" id="L192">        keyUsages = new Vector&lt;ObjectIdentifier&gt;();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        while (val.data.available() != 0) {</span>
<span class="fc" id="L194">            DerValue seq = val.data.getDerValue();</span>
<span class="fc" id="L195">            ObjectIdentifier usage = seq.getOID();</span>
<span class="fc" id="L196">            keyUsages.addElement(usage);</span>
<span class="fc" id="L197">        }</span>
<span class="fc" id="L198">    }</span>

    /**
     * Return the extension as user readable string.
     */
    public String toString() {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (keyUsages == null) return &quot;&quot;;</span>
<span class="nc" id="L205">        String usage = &quot;  &quot;;</span>
<span class="nc" id="L206">        boolean first = true;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        for (ObjectIdentifier oid: keyUsages) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if(!first) {</span>
<span class="nc" id="L209">                usage += &quot;\n  &quot;;</span>
            }

<span class="nc" id="L212">            String result = map.get(oid);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (result != null) {</span>
<span class="nc" id="L214">                usage += result;</span>
            } else {
<span class="nc" id="L216">                usage += oid.toString();</span>
            }
<span class="nc" id="L218">            first = false;</span>
<span class="nc" id="L219">        }</span>
<span class="nc" id="L220">        return super.toString() + &quot;ExtendedKeyUsages [\n&quot;</span>
               + usage + &quot;\n]\n&quot;;
    }

    /**
     * Write the extension to the DerOutputStream.
     *
     * @param out the DerOutputStream to write the extension to.
     * @exception IOException on encoding errors.
     */
    public void encode(OutputStream out) throws IOException {
<span class="nc" id="L231">        DerOutputStream tmp = new DerOutputStream();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (extensionValue == null) {</span>
<span class="nc" id="L233">          extensionId = PKIXExtensions.ExtendedKeyUsage_Id;</span>
<span class="nc" id="L234">          critical = false;</span>
<span class="nc" id="L235">          encodeThis();</span>
        }
<span class="nc" id="L237">        super.encode(tmp);</span>
<span class="nc" id="L238">        out.write(tmp.toByteArray());</span>
<span class="nc" id="L239">    }</span>

    /**
     * Set the attribute value.
     */
    @SuppressWarnings(&quot;unchecked&quot;) // Checked with instanceof
    public void set(String name, Object obj) throws IOException {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (name.equalsIgnoreCase(USAGES)) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (!(obj instanceof Vector)) {</span>
<span class="nc" id="L248">                throw new IOException(&quot;Attribute value should be of type Vector.&quot;);</span>
            }
<span class="nc" id="L250">            this.keyUsages = (Vector&lt;ObjectIdentifier&gt;)obj;</span>
        } else {
<span class="nc" id="L252">          throw new IOException(&quot;Attribute name [&quot; + name +</span>
                                &quot;] not recognized by &quot; +
                                &quot;CertAttrSet:ExtendedKeyUsageExtension.&quot;);
        }
<span class="nc" id="L256">        encodeThis();</span>
<span class="nc" id="L257">    }</span>

    /**
     * Get the attribute value.
     */
    public Vector&lt;ObjectIdentifier&gt; get(String name) throws IOException {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (name.equalsIgnoreCase(USAGES)) {</span>
            //XXXX May want to consider cloning this
<span class="nc" id="L265">            return keyUsages;</span>
        } else {
<span class="nc" id="L267">          throw new IOException(&quot;Attribute name [&quot; + name +</span>
                                &quot;] not recognized by &quot; +
                                &quot;CertAttrSet:ExtendedKeyUsageExtension.&quot;);
        }
    }

    /**
     * Delete the attribute value.
     */
    public void delete(String name) throws IOException {
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (name.equalsIgnoreCase(USAGES)) {</span>
<span class="nc" id="L278">            keyUsages = null;</span>
        } else {
<span class="nc" id="L280">          throw new IOException(&quot;Attribute name [&quot; + name +</span>
                                &quot;] not recognized by &quot; +
                                &quot;CertAttrSet:ExtendedKeyUsageExtension.&quot;);
        }
<span class="nc" id="L284">        encodeThis();</span>
<span class="nc" id="L285">    }</span>

    /**
     * Return an enumeration of names of attributes existing within this
     * attribute.
     */
    public Enumeration&lt;String&gt; getElements() {
<span class="nc" id="L292">        AttributeNameEnumeration elements = new AttributeNameEnumeration();</span>
<span class="nc" id="L293">        elements.addElement(USAGES);</span>

<span class="nc" id="L295">        return (elements.elements());</span>
    }

    /**
     * Return the name of this attribute.
     */
    public String getName() {
<span class="fc" id="L302">        return (NAME);</span>
    }

    public List&lt;String&gt; getExtendedKeyUsage() {
<span class="fc" id="L306">        List&lt;String&gt; al = new ArrayList&lt;String&gt;(keyUsages.size());</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (ObjectIdentifier oid : keyUsages) {</span>
<span class="fc" id="L308">            al.add(oid.toString());</span>
<span class="fc" id="L309">        }</span>
<span class="fc" id="L310">        return al;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>