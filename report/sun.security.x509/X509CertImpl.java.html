<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>X509CertImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.x509</a> &gt; <span class="el_source">X509CertImpl.java</span></div><h1>X509CertImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.x509;

import java.io.BufferedReader;
import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import javax.security.auth.x500.X500Principal;

import sun.misc.HexDumpEncoder;
import java.util.Base64;
import sun.security.util.*;
import sun.security.provider.X509Factory;

/**
 * The X509CertImpl class represents an X.509 certificate. These certificates
 * are widely used to support authentication and other functionality in
 * Internet security systems.  Common applications include Privacy Enhanced
 * Mail (PEM), Transport Layer Security (SSL), code signing for trusted
 * software distribution, and Secure Electronic Transactions (SET).  There
 * is a commercial infrastructure ready to manage large scale deployments
 * of X.509 identity certificates.
 *
 * &lt;P&gt;These certificates are managed and vouched for by &lt;em&gt;Certificate
 * Authorities&lt;/em&gt; (CAs).  CAs are services which create certificates by
 * placing data in the X.509 standard format and then digitally signing
 * that data.  Such signatures are quite difficult to forge.  CAs act as
 * trusted third parties, making introductions between agents who have no
 * direct knowledge of each other.  CA certificates are either signed by
 * themselves, or by some other CA such as a &quot;root&quot; CA.
 *
 * &lt;P&gt;RFC 1422 is very informative, though it does not describe much
 * of the recent work being done with X.509 certificates.  That includes
 * a 1996 version (X.509v3) and a variety of enhancements being made to
 * facilitate an explosion of personal certificates used as &quot;Internet
 * Drivers' Licences&quot;, or with SET for credit card transactions.
 *
 * &lt;P&gt;More recent work includes the IETF PKIX Working Group efforts,
 * especially RFC2459.
 *
 * @author Dave Brownell
 * @author Amit Kapoor
 * @author Hemma Prafullchandra
 * @see X509CertInfo
 */
public class X509CertImpl extends X509Certificate implements DerEncoder {

    private static final long serialVersionUID = -3457612960190864406L;

    private static final String DOT = &quot;.&quot;;
    /**
     * Public attribute names.
     */
    public static final String NAME = &quot;x509&quot;;
    public static final String INFO = X509CertInfo.NAME;
    public static final String ALG_ID = &quot;algorithm&quot;;
    public static final String SIGNATURE = &quot;signature&quot;;
    public static final String SIGNED_CERT = &quot;signed_cert&quot;;

    /**
     * The following are defined for ease-of-use. These
     * are the most frequently retrieved attributes.
     */
    // x509.info.subject.dname
    public static final String SUBJECT_DN = NAME + DOT + INFO + DOT +
                               X509CertInfo.SUBJECT + DOT + X509CertInfo.DN_NAME;
    // x509.info.issuer.dname
    public static final String ISSUER_DN = NAME + DOT + INFO + DOT +
                               X509CertInfo.ISSUER + DOT + X509CertInfo.DN_NAME;
    // x509.info.serialNumber.number
    public static final String SERIAL_ID = NAME + DOT + INFO + DOT +
                               X509CertInfo.SERIAL_NUMBER + DOT +
                               CertificateSerialNumber.NUMBER;
    // x509.info.key.value
    public static final String PUBLIC_KEY = NAME + DOT + INFO + DOT +
                               X509CertInfo.KEY + DOT +
                               CertificateX509Key.KEY;

    // x509.info.version.value
    public static final String VERSION = NAME + DOT + INFO + DOT +
                               X509CertInfo.VERSION + DOT +
                               CertificateVersion.VERSION;

    // x509.algorithm
    public static final String SIG_ALG = NAME + DOT + ALG_ID;

    // x509.signature
    public static final String SIG = NAME + DOT + SIGNATURE;

    // when we sign and decode we set this to true
    // this is our means to make certificates immutable
<span class="pc" id="L126">    private boolean readOnly = false;</span>

    // Certificate data, and its envelope
<span class="pc" id="L129">    private byte[]              signedCert = null;</span>
<span class="pc" id="L130">    protected X509CertInfo      info = null;</span>
<span class="pc" id="L131">    protected AlgorithmId       algId = null;</span>
<span class="pc" id="L132">    protected byte[]            signature = null;</span>

    // recognized extension OIDS
    private static final String KEY_USAGE_OID = &quot;2.5.29.15&quot;;
    private static final String EXTENDED_KEY_USAGE_OID = &quot;2.5.29.37&quot;;
    private static final String BASIC_CONSTRAINT_OID = &quot;2.5.29.19&quot;;
    private static final String SUBJECT_ALT_NAME_OID = &quot;2.5.29.17&quot;;
    private static final String ISSUER_ALT_NAME_OID = &quot;2.5.29.18&quot;;
    private static final String AUTH_INFO_ACCESS_OID = &quot;1.3.6.1.5.5.7.1.1&quot;;

    // number of standard key usage bits.
    private static final int NUM_STANDARD_KEY_USAGE = 9;

    // SubjectAlterntativeNames cache
    private Collection&lt;List&lt;?&gt;&gt; subjectAlternativeNames;

    // IssuerAlternativeNames cache
    private Collection&lt;List&lt;?&gt;&gt; issuerAlternativeNames;

    // ExtendedKeyUsage cache
    private List&lt;String&gt; extKeyUsage;

    // AuthorityInformationAccess cache
    private Set&lt;AccessDescription&gt; authInfoAccess;

    /**
     * PublicKey that has previously been used to verify
     * the signature of this certificate. Null if the certificate has not
     * yet been verified.
     */
    private PublicKey verifiedPublicKey;
    /**
     * If verifiedPublicKey is not null, name of the provider used to
     * successfully verify the signature of this certificate, or the
     * empty String if no provider was explicitly specified.
     */
    private String verifiedProvider;
    /**
     * If verifiedPublicKey is not null, result of the verification using
     * verifiedPublicKey and verifiedProvider. If true, verification was
     * successful, if false, it failed.
     */
    private boolean verificationResult;

    /**
     * Default constructor.
     */
<span class="nc" id="L179">    public X509CertImpl() { }</span>

    /**
     * Unmarshals a certificate from its encoded form, parsing the
     * encoded bytes.  This form of constructor is used by agents which
     * need to examine and use certificate contents.  That is, this is
     * one of the more commonly used constructors.  Note that the buffer
     * must include only a certificate, and no &quot;garbage&quot; may be left at
     * the end.  If you need to ignore data at the end of a certificate,
     * use another constructor.
     *
     * @param certData the encoded bytes, with no trailing padding.
     * @exception CertificateException on parsing and initialization errors.
     */
<span class="fc" id="L193">    public X509CertImpl(byte[] certData) throws CertificateException {</span>
        try {
<span class="fc" id="L195">            parse(new DerValue(certData));</span>
<span class="nc" id="L196">        } catch (IOException e) {</span>
<span class="nc" id="L197">            signedCert = null;</span>
<span class="nc" id="L198">            throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);</span>
<span class="fc" id="L199">        }</span>
<span class="fc" id="L200">    }</span>

    /**
     * unmarshals an X.509 certificate from an input stream.  If the
     * certificate is RFC1421 hex-encoded, then it must begin with
     * the line X509Factory.BEGIN_CERT and end with the line
     * X509Factory.END_CERT.
     *
     * @param in an input stream holding at least one certificate that may
     *        be either DER-encoded or RFC1421 hex-encoded version of the
     *        DER-encoded certificate.
     * @exception CertificateException on parsing and initialization errors.
     */
<span class="nc" id="L213">    public X509CertImpl(InputStream in) throws CertificateException {</span>

<span class="nc" id="L215">        DerValue der = null;</span>

<span class="nc" id="L217">        BufferedInputStream inBuffered = new BufferedInputStream(in);</span>

        // First try reading stream as HEX-encoded DER-encoded bytes,
        // since not mistakable for raw DER
        try {
<span class="nc" id="L222">            inBuffered.mark(Integer.MAX_VALUE);</span>
<span class="nc" id="L223">            der = readRFC1421Cert(inBuffered);</span>
<span class="nc" id="L224">        } catch (IOException ioe) {</span>
            try {
                // Next, try reading stream as raw DER-encoded bytes
<span class="nc" id="L227">                inBuffered.reset();</span>
<span class="nc" id="L228">                der = new DerValue(inBuffered);</span>
<span class="nc" id="L229">            } catch (IOException ioe1) {</span>
<span class="nc" id="L230">                throw new CertificateException(&quot;Input stream must be &quot; +</span>
                                               &quot;either DER-encoded bytes &quot; +
                                               &quot;or RFC1421 hex-encoded &quot; +
                                               &quot;DER-encoded bytes: &quot; +
<span class="nc" id="L234">                                               ioe1.getMessage(), ioe1);</span>
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        }</span>
        try {
<span class="nc" id="L238">            parse(der);</span>
<span class="nc" id="L239">        } catch (IOException ioe) {</span>
<span class="nc" id="L240">            signedCert = null;</span>
<span class="nc" id="L241">            throw new CertificateException(&quot;Unable to parse DER value of &quot; +</span>
                                           &quot;certificate, &quot; + ioe, ioe);
<span class="nc" id="L243">        }</span>
<span class="nc" id="L244">    }</span>

    /**
     * read input stream as HEX-encoded DER-encoded bytes
     *
     * @param in InputStream to read
     * @returns DerValue corresponding to decoded HEX-encoded bytes
     * @throws IOException if stream can not be interpreted as RFC1421
     *                     encoded bytes
     */
    private DerValue readRFC1421Cert(InputStream in) throws IOException {
<span class="nc" id="L255">        DerValue der = null;</span>
<span class="nc" id="L256">        String line = null;</span>
<span class="nc" id="L257">        BufferedReader certBufferedReader =</span>
            new BufferedReader(new InputStreamReader(in, &quot;ASCII&quot;));
        try {
<span class="nc" id="L260">            line = certBufferedReader.readLine();</span>
<span class="nc" id="L261">        } catch (IOException ioe1) {</span>
<span class="nc" id="L262">            throw new IOException(&quot;Unable to read InputStream: &quot; +</span>
<span class="nc" id="L263">                                  ioe1.getMessage());</span>
<span class="nc" id="L264">        }</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (line.equals(X509Factory.BEGIN_CERT)) {</span>
            /* stream appears to be hex-encoded bytes */
<span class="nc" id="L267">            ByteArrayOutputStream decstream = new ByteArrayOutputStream();</span>
            try {
<span class="nc bnc" id="L269" title="All 2 branches missed.">                while ((line = certBufferedReader.readLine()) != null) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if (line.equals(X509Factory.END_CERT)) {</span>
<span class="nc" id="L271">                        der = new DerValue(decstream.toByteArray());</span>
<span class="nc" id="L272">                        break;</span>
                    } else {
<span class="nc" id="L274">                        decstream.write(Base64.getMimeDecoder().decode(line));</span>
                    }
                }
<span class="nc" id="L277">            } catch (IOException ioe2) {</span>
<span class="nc" id="L278">                throw new IOException(&quot;Unable to read InputStream: &quot;</span>
<span class="nc" id="L279">                                      + ioe2.getMessage());</span>
<span class="nc" id="L280">            }</span>
<span class="nc" id="L281">        } else {</span>
<span class="nc" id="L282">            throw new IOException(&quot;InputStream is not RFC1421 hex-encoded &quot; +</span>
                                  &quot;DER bytes&quot;);
        }
<span class="nc" id="L285">        return der;</span>
    }

    /**
     * Construct an initialized X509 Certificate. The certificate is stored
     * in raw form and has to be signed to be useful.
     *
     * @params info the X509CertificateInfo which the Certificate is to be
     *              created from.
     */
<span class="nc" id="L295">    public X509CertImpl(X509CertInfo certInfo) {</span>
<span class="nc" id="L296">        this.info = certInfo;</span>
<span class="nc" id="L297">    }</span>

    /**
     * Unmarshal a certificate from its encoded form, parsing a DER value.
     * This form of constructor is used by agents which need to examine
     * and use certificate contents.
     *
     * @param derVal the der value containing the encoded cert.
     * @exception CertificateException on parsing and initialization errors.
     */
<span class="nc" id="L307">    public X509CertImpl(DerValue derVal) throws CertificateException {</span>
        try {
<span class="nc" id="L309">            parse(derVal);</span>
<span class="nc" id="L310">        } catch (IOException e) {</span>
<span class="nc" id="L311">            signedCert = null;</span>
<span class="nc" id="L312">            throw new CertificateException(&quot;Unable to initialize, &quot; + e, e);</span>
<span class="nc" id="L313">        }</span>
<span class="nc" id="L314">    }</span>

    /**
     * Appends the certificate to an output stream.
     *
     * @param out an input stream to which the certificate is appended.
     * @exception CertificateEncodingException on encoding errors.
     */
    public void encode(OutputStream out)
    throws CertificateEncodingException {
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (signedCert == null)</span>
<span class="nc" id="L325">            throw new CertificateEncodingException(</span>
                          &quot;Null certificate to encode&quot;);
        try {
<span class="nc" id="L328">            out.write(signedCert.clone());</span>
<span class="nc" id="L329">        } catch (IOException e) {</span>
<span class="nc" id="L330">            throw new CertificateEncodingException(e.toString());</span>
<span class="nc" id="L331">        }</span>
<span class="nc" id="L332">    }</span>

    /**
     * DER encode this object onto an output stream.
     * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
     *
     * @param out the output stream on which to write the DER encoding.
     *
     * @exception IOException on encoding error.
     */
    public void derEncode(OutputStream out) throws IOException {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (signedCert == null)</span>
<span class="nc" id="L344">            throw new IOException(&quot;Null certificate to encode&quot;);</span>
<span class="nc" id="L345">        out.write(signedCert.clone());</span>
<span class="nc" id="L346">    }</span>

    /**
     * Returns the encoded form of this certificate. It is
     * assumed that each certificate type would have only a single
     * form of encoding; for example, X.509 certificates would
     * be encoded as ASN.1 DER.
     *
     * @exception CertificateEncodingException if an encoding error occurs.
     */
    public byte[] getEncoded() throws CertificateEncodingException {
<span class="fc" id="L357">        return getEncodedInternal().clone();</span>
    }

    /**
     * Returned the encoding as an uncloned byte array. Callers must
     * guarantee that they neither modify it nor expose it to untrusted
     * code.
     */
    public byte[] getEncodedInternal() throws CertificateEncodingException {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (signedCert == null) {</span>
<span class="nc" id="L367">            throw new CertificateEncodingException(</span>
                          &quot;Null certificate to encode&quot;);
        }
<span class="fc" id="L370">        return signedCert;</span>
    }

    /**
     * Throws an exception if the certificate was not signed using the
     * verification key provided.  Successfully verifying a certificate
     * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
     * it represents.
     *
     * @param key the public key used for verification.
     *
     * @exception InvalidKeyException on incorrect key.
     * @exception NoSuchAlgorithmException on unsupported signature
     * algorithms.
     * @exception NoSuchProviderException if there's no default provider.
     * @exception SignatureException on signature errors.
     * @exception CertificateException on encoding errors.
     */
    public void verify(PublicKey key)
    throws CertificateException, NoSuchAlgorithmException,
        InvalidKeyException, NoSuchProviderException, SignatureException {

<span class="fc" id="L392">        verify(key, &quot;&quot;);</span>
<span class="fc" id="L393">    }</span>

    /**
     * Throws an exception if the certificate was not signed using the
     * verification key provided.  Successfully verifying a certificate
     * does &lt;em&gt;not&lt;/em&gt; indicate that one should trust the entity which
     * it represents.
     *
     * @param key the public key used for verification.
     * @param sigProvider the name of the provider.
     *
     * @exception NoSuchAlgorithmException on unsupported signature
     * algorithms.
     * @exception InvalidKeyException on incorrect key.
     * @exception NoSuchProviderException on incorrect provider.
     * @exception SignatureException on signature errors.
     * @exception CertificateException on encoding errors.
     */
    public synchronized void verify(PublicKey key, String sigProvider)
            throws CertificateException, NoSuchAlgorithmException,
            InvalidKeyException, NoSuchProviderException, SignatureException {
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (sigProvider == null) {</span>
<span class="fc" id="L415">            sigProvider = &quot;&quot;;</span>
        }
<span class="fc bfc" id="L417" title="All 4 branches covered.">        if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {</span>
            // this certificate has already been verified using
            // this public key. Make sure providers match, too.
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (sigProvider.equals(verifiedProvider)) {</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">                if (verificationResult) {</span>
<span class="fc" id="L422">                    return;</span>
                } else {
<span class="nc" id="L424">                    throw new SignatureException(&quot;Signature does not match.&quot;);</span>
                }
            }
        }
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (signedCert == null) {</span>
<span class="nc" id="L429">            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);</span>
        }
        // Verify the signature ...
<span class="fc" id="L432">        Signature sigVerf = null;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (sigProvider.length() == 0) {</span>
<span class="fc" id="L434">            sigVerf = Signature.getInstance(algId.getName());</span>
        } else {
<span class="fc" id="L436">            sigVerf = Signature.getInstance(algId.getName(), sigProvider);</span>
        }
<span class="fc" id="L438">        sigVerf.initVerify(key);</span>

<span class="fc" id="L440">        byte[] rawCert = info.getEncodedInfo();</span>
<span class="fc" id="L441">        sigVerf.update(rawCert, 0, rawCert.length);</span>

        // verify may throw SignatureException for invalid encodings, etc.
<span class="fc" id="L444">        verificationResult = sigVerf.verify(signature);</span>
<span class="fc" id="L445">        verifiedPublicKey = key;</span>
<span class="fc" id="L446">        verifiedProvider = sigProvider;</span>

<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (verificationResult == false) {</span>
<span class="fc" id="L449">            throw new SignatureException(&quot;Signature does not match.&quot;);</span>
        }
<span class="fc" id="L451">    }</span>

    /**
     * Throws an exception if the certificate was not signed using the
     * verification key provided.  This method uses the signature verification
     * engine supplied by the specified provider. Note that the specified
     * Provider object does not have to be registered in the provider list.
     * Successfully verifying a certificate does &lt;em&gt;not&lt;/em&gt; indicate that one
     * should trust the entity which it represents.
     *
     * @param key the public key used for verification.
     * @param sigProvider the provider.
     *
     * @exception NoSuchAlgorithmException on unsupported signature
     * algorithms.
     * @exception InvalidKeyException on incorrect key.
     * @exception SignatureException on signature errors.
     * @exception CertificateException on encoding errors.
     */
    public synchronized void verify(PublicKey key, Provider sigProvider)
            throws CertificateException, NoSuchAlgorithmException,
            InvalidKeyException, SignatureException {
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (signedCert == null) {</span>
<span class="nc" id="L474">            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);</span>
        }
        // Verify the signature ...
<span class="nc" id="L477">        Signature sigVerf = null;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (sigProvider == null) {</span>
<span class="nc" id="L479">            sigVerf = Signature.getInstance(algId.getName());</span>
        } else {
<span class="nc" id="L481">            sigVerf = Signature.getInstance(algId.getName(), sigProvider);</span>
        }
<span class="nc" id="L483">        sigVerf.initVerify(key);</span>

<span class="nc" id="L485">        byte[] rawCert = info.getEncodedInfo();</span>
<span class="nc" id="L486">        sigVerf.update(rawCert, 0, rawCert.length);</span>

        // verify may throw SignatureException for invalid encodings, etc.
<span class="nc" id="L489">        verificationResult = sigVerf.verify(signature);</span>
<span class="nc" id="L490">        verifiedPublicKey = key;</span>

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (verificationResult == false) {</span>
<span class="nc" id="L493">            throw new SignatureException(&quot;Signature does not match.&quot;);</span>
        }
<span class="nc" id="L495">    }</span>

     /**
     * This static method is the default implementation of the
     * verify(PublicKey key, Provider sigProvider) method in X509Certificate.
     * Called from java.security.cert.X509Certificate.verify(PublicKey key,
     * Provider sigProvider)
     */
    public static void verify(X509Certificate cert, PublicKey key,
            Provider sigProvider) throws CertificateException,
            NoSuchAlgorithmException, InvalidKeyException, SignatureException {
<span class="nc" id="L506">        cert.verify(key, sigProvider);</span>
<span class="nc" id="L507">    }</span>

    /**
     * Creates an X.509 certificate, and signs it using the given key
     * (associating a signature algorithm and an X.500 name).
     * This operation is used to implement the certificate generation
     * functionality of a certificate authority.
     *
     * @param key the private key used for signing.
     * @param algorithm the name of the signature algorithm used.
     *
     * @exception InvalidKeyException on incorrect key.
     * @exception NoSuchAlgorithmException on unsupported signature
     * algorithms.
     * @exception NoSuchProviderException if there's no default provider.
     * @exception SignatureException on signature errors.
     * @exception CertificateException on encoding errors.
     */
    public void sign(PrivateKey key, String algorithm)
    throws CertificateException, NoSuchAlgorithmException,
        InvalidKeyException, NoSuchProviderException, SignatureException {
<span class="nc" id="L528">        sign(key, algorithm, null);</span>
<span class="nc" id="L529">    }</span>

    /**
     * Creates an X.509 certificate, and signs it using the given key
     * (associating a signature algorithm and an X.500 name).
     * This operation is used to implement the certificate generation
     * functionality of a certificate authority.
     *
     * @param key the private key used for signing.
     * @param algorithm the name of the signature algorithm used.
     * @param provider the name of the provider.
     *
     * @exception NoSuchAlgorithmException on unsupported signature
     * algorithms.
     * @exception InvalidKeyException on incorrect key.
     * @exception NoSuchProviderException on incorrect provider.
     * @exception SignatureException on signature errors.
     * @exception CertificateException on encoding errors.
     */
    public void sign(PrivateKey key, String algorithm, String provider)
    throws CertificateException, NoSuchAlgorithmException,
        InvalidKeyException, NoSuchProviderException, SignatureException {
        try {
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (readOnly)</span>
<span class="nc" id="L553">                throw new CertificateEncodingException(</span>
                              &quot;cannot over-write existing certificate&quot;);
<span class="nc" id="L555">            Signature sigEngine = null;</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">            if ((provider == null) || (provider.length() == 0))</span>
<span class="nc" id="L557">                sigEngine = Signature.getInstance(algorithm);</span>
            else
<span class="nc" id="L559">                sigEngine = Signature.getInstance(algorithm, provider);</span>

<span class="nc" id="L561">            sigEngine.initSign(key);</span>

                                // in case the name is reset
<span class="nc" id="L564">            algId = AlgorithmId.get(sigEngine.getAlgorithm());</span>

<span class="nc" id="L566">            DerOutputStream out = new DerOutputStream();</span>
<span class="nc" id="L567">            DerOutputStream tmp = new DerOutputStream();</span>

            // encode certificate info
<span class="nc" id="L570">            info.encode(tmp);</span>
<span class="nc" id="L571">            byte[] rawCert = tmp.toByteArray();</span>

            // encode algorithm identifier
<span class="nc" id="L574">            algId.encode(tmp);</span>

            // Create and encode the signature itself.
<span class="nc" id="L577">            sigEngine.update(rawCert, 0, rawCert.length);</span>
<span class="nc" id="L578">            signature = sigEngine.sign();</span>
<span class="nc" id="L579">            tmp.putBitString(signature);</span>

            // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
<span class="nc" id="L582">            out.write(DerValue.tag_Sequence, tmp);</span>
<span class="nc" id="L583">            signedCert = out.toByteArray();</span>
<span class="nc" id="L584">            readOnly = true;</span>

<span class="nc" id="L586">        } catch (IOException e) {</span>
<span class="nc" id="L587">            throw new CertificateEncodingException(e.toString());</span>
<span class="nc" id="L588">      }</span>
<span class="nc" id="L589">    }</span>

    /**
     * Checks that the certificate is currently valid, i.e. the current
     * time is within the specified validity period.
     *
     * @exception CertificateExpiredException if the certificate has expired.
     * @exception CertificateNotYetValidException if the certificate is not
     * yet valid.
     */
    public void checkValidity()
    throws CertificateExpiredException, CertificateNotYetValidException {
<span class="nc" id="L601">        Date date = new Date();</span>
<span class="nc" id="L602">        checkValidity(date);</span>
<span class="nc" id="L603">    }</span>

    /**
     * Checks that the specified date is within the certificate's
     * validity period, or basically if the certificate would be
     * valid at the specified date/time.
     *
     * @param date the Date to check against to see if this certificate
     *        is valid at that date/time.
     *
     * @exception CertificateExpiredException if the certificate has expired
     * with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
     * @exception CertificateNotYetValidException if the certificate is not
     * yet valid with respect to the &lt;code&gt;date&lt;/code&gt; supplied.
     */
    public void checkValidity(Date date)
    throws CertificateExpiredException, CertificateNotYetValidException {

<span class="fc" id="L621">        CertificateValidity interval = null;</span>
        try {
<span class="fc" id="L623">            interval = (CertificateValidity)info.get(CertificateValidity.NAME);</span>
<span class="nc" id="L624">        } catch (Exception e) {</span>
<span class="nc" id="L625">            throw new CertificateNotYetValidException(&quot;Incorrect validity period&quot;);</span>
<span class="fc" id="L626">        }</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (interval == null)</span>
<span class="nc" id="L628">            throw new CertificateNotYetValidException(&quot;Null validity period&quot;);</span>
<span class="fc" id="L629">        interval.valid(date);</span>
<span class="fc" id="L630">    }</span>

    /**
     * Return the requested attribute from the certificate.
     *
     * Note that the X509CertInfo is not cloned for performance reasons.
     * Callers must ensure that they do not modify it. All other
     * attributes are cloned.
     *
     * @param name the name of the attribute.
     * @exception CertificateParsingException on invalid attribute identifier.
     */
    public Object get(String name)
    throws CertificateParsingException {
<span class="fc" id="L644">        X509AttributeName attr = new X509AttributeName(name);</span>
<span class="fc" id="L645">        String id = attr.getPrefix();</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (!(id.equalsIgnoreCase(NAME))) {</span>
<span class="nc" id="L647">            throw new CertificateParsingException(&quot;Invalid root of &quot;</span>
                          + &quot;attribute name, expected [&quot; + NAME +
                          &quot;], received &quot; + &quot;[&quot; + id + &quot;]&quot;);
        }
<span class="fc" id="L651">        attr = new X509AttributeName(attr.getSuffix());</span>
<span class="fc" id="L652">        id = attr.getPrefix();</span>

<span class="fc bfc" id="L654" title="All 2 branches covered.">        if (id.equalsIgnoreCase(INFO)) {</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">            if (info == null) {</span>
<span class="nc" id="L656">                return null;</span>
            }
<span class="fc bfc" id="L658" title="All 2 branches covered.">            if (attr.getSuffix() != null) {</span>
                try {
<span class="fc" id="L660">                    return info.get(attr.getSuffix());</span>
<span class="fc" id="L661">                } catch (IOException e) {</span>
<span class="fc" id="L662">                    throw new CertificateParsingException(e.toString());</span>
<span class="nc" id="L663">                } catch (CertificateException e) {</span>
<span class="nc" id="L664">                    throw new CertificateParsingException(e.toString());</span>
                }
            } else {
<span class="fc" id="L667">                return info;</span>
            }
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        } else if (id.equalsIgnoreCase(ALG_ID)) {</span>
<span class="fc" id="L670">            return(algId);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">        } else if (id.equalsIgnoreCase(SIGNATURE)) {</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            if (signature != null)</span>
<span class="nc" id="L673">                return signature.clone();</span>
            else
<span class="nc" id="L675">                return null;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        } else if (id.equalsIgnoreCase(SIGNED_CERT)) {</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">            if (signedCert != null)</span>
<span class="nc" id="L678">                return signedCert.clone();</span>
            else
<span class="nc" id="L680">                return null;</span>
        } else {
<span class="nc" id="L682">            throw new CertificateParsingException(&quot;Attribute name not &quot;</span>
                 + &quot;recognized or get() not allowed for the same: &quot; + id);
        }
    }

    /**
     * Set the requested attribute in the certificate.
     *
     * @param name the name of the attribute.
     * @param obj the value of the attribute.
     * @exception CertificateException on invalid attribute identifier.
     * @exception IOException on encoding error of attribute.
     */
    public void set(String name, Object obj)
    throws CertificateException, IOException {
        // check if immutable
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (readOnly)</span>
<span class="nc" id="L699">            throw new CertificateException(&quot;cannot over-write existing&quot;</span>
                                           + &quot; certificate&quot;);

<span class="nc" id="L702">        X509AttributeName attr = new X509AttributeName(name);</span>
<span class="nc" id="L703">        String id = attr.getPrefix();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (!(id.equalsIgnoreCase(NAME))) {</span>
<span class="nc" id="L705">            throw new CertificateException(&quot;Invalid root of attribute name,&quot;</span>
                           + &quot; expected [&quot; + NAME + &quot;], received &quot; + id);
        }
<span class="nc" id="L708">        attr = new X509AttributeName(attr.getSuffix());</span>
<span class="nc" id="L709">        id = attr.getPrefix();</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (id.equalsIgnoreCase(INFO)) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (attr.getSuffix() == null) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                if (!(obj instanceof X509CertInfo)) {</span>
<span class="nc" id="L714">                    throw new CertificateException(&quot;Attribute value should&quot;</span>
                                    + &quot; be of type X509CertInfo.&quot;);
                }
<span class="nc" id="L717">                info = (X509CertInfo)obj;</span>
<span class="nc" id="L718">                signedCert = null;  //reset this as certificate data has changed</span>
            } else {
<span class="nc" id="L720">                info.set(attr.getSuffix(), obj);</span>
<span class="nc" id="L721">                signedCert = null;  //reset this as certificate data has changed</span>
            }
        } else {
<span class="nc" id="L724">            throw new CertificateException(&quot;Attribute name not recognized or &quot; +</span>
                              &quot;set() not allowed for the same: &quot; + id);
        }
<span class="nc" id="L727">    }</span>

    /**
     * Delete the requested attribute from the certificate.
     *
     * @param name the name of the attribute.
     * @exception CertificateException on invalid attribute identifier.
     * @exception IOException on other errors.
     */
    public void delete(String name)
    throws CertificateException, IOException {
        // check if immutable
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (readOnly)</span>
<span class="nc" id="L740">            throw new CertificateException(&quot;cannot over-write existing&quot;</span>
                                           + &quot; certificate&quot;);

<span class="nc" id="L743">        X509AttributeName attr = new X509AttributeName(name);</span>
<span class="nc" id="L744">        String id = attr.getPrefix();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (!(id.equalsIgnoreCase(NAME))) {</span>
<span class="nc" id="L746">            throw new CertificateException(&quot;Invalid root of attribute name,&quot;</span>
                                   + &quot; expected [&quot;
                                   + NAME + &quot;], received &quot; + id);
        }
<span class="nc" id="L750">        attr = new X509AttributeName(attr.getSuffix());</span>
<span class="nc" id="L751">        id = attr.getPrefix();</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (id.equalsIgnoreCase(INFO)) {</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            if (attr.getSuffix() != null) {</span>
<span class="nc" id="L755">                info = null;</span>
            } else {
<span class="nc" id="L757">                info.delete(attr.getSuffix());</span>
            }
<span class="nc bnc" id="L759" title="All 2 branches missed.">        } else if (id.equalsIgnoreCase(ALG_ID)) {</span>
<span class="nc" id="L760">            algId = null;</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        } else if (id.equalsIgnoreCase(SIGNATURE)) {</span>
<span class="nc" id="L762">            signature = null;</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">        } else if (id.equalsIgnoreCase(SIGNED_CERT)) {</span>
<span class="nc" id="L764">            signedCert = null;</span>
        } else {
<span class="nc" id="L766">            throw new CertificateException(&quot;Attribute name not recognized or &quot; +</span>
                              &quot;delete() not allowed for the same: &quot; + id);
        }
<span class="nc" id="L769">    }</span>

    /**
     * Return an enumeration of names of attributes existing within this
     * attribute.
     */
    public Enumeration&lt;String&gt; getElements() {
<span class="nc" id="L776">        AttributeNameEnumeration elements = new AttributeNameEnumeration();</span>
<span class="nc" id="L777">        elements.addElement(NAME + DOT + INFO);</span>
<span class="nc" id="L778">        elements.addElement(NAME + DOT + ALG_ID);</span>
<span class="nc" id="L779">        elements.addElement(NAME + DOT + SIGNATURE);</span>
<span class="nc" id="L780">        elements.addElement(NAME + DOT + SIGNED_CERT);</span>

<span class="nc" id="L782">        return elements.elements();</span>
    }

    /**
     * Return the name of this attribute.
     */
    public String getName() {
<span class="nc" id="L789">        return(NAME);</span>
    }

    /**
     * Returns a printable representation of the certificate.  This does not
     * contain all the information available to distinguish this from any
     * other certificate.  The certificate must be fully constructed
     * before this function may be called.
     */
    public String toString() {
<span class="pc bpc" id="L799" title="3 of 6 branches missed.">        if (info == null || algId == null || signature == null)</span>
<span class="nc" id="L800">            return &quot;&quot;;</span>

<span class="fc" id="L802">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L804">        sb.append(&quot;[\n&quot;);</span>
<span class="fc" id="L805">        sb.append(info.toString() + &quot;\n&quot;);</span>
<span class="fc" id="L806">        sb.append(&quot;  Algorithm: [&quot; + algId.toString() + &quot;]\n&quot;);</span>

<span class="fc" id="L808">        HexDumpEncoder encoder = new HexDumpEncoder();</span>
<span class="fc" id="L809">        sb.append(&quot;  Signature:\n&quot; + encoder.encodeBuffer(signature));</span>
<span class="fc" id="L810">        sb.append(&quot;\n]&quot;);</span>

<span class="fc" id="L812">        return sb.toString();</span>
    }

    // the strongly typed gets, as per java.security.cert.X509Certificate

    /**
     * Gets the publickey from this certificate.
     *
     * @return the publickey.
     */
    public PublicKey getPublicKey() {
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L824">            return null;</span>
        try {
<span class="fc" id="L826">            PublicKey key = (PublicKey)info.get(CertificateX509Key.NAME</span>
                                + DOT + CertificateX509Key.KEY);
<span class="fc" id="L828">            return key;</span>
<span class="nc" id="L829">        } catch (Exception e) {</span>
<span class="nc" id="L830">            return null;</span>
        }
    }

    /**
     * Gets the version number from the certificate.
     *
     * @return the version number, i.e. 1, 2 or 3.
     */
    public int getVersion() {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L841">            return -1;</span>
        try {
<span class="fc" id="L843">            int vers = ((Integer)info.get(CertificateVersion.NAME</span>
<span class="fc" id="L844">                        + DOT + CertificateVersion.VERSION)).intValue();</span>
<span class="fc" id="L845">            return vers+1;</span>
<span class="nc" id="L846">        } catch (Exception e) {</span>
<span class="nc" id="L847">            return -1;</span>
        }
    }

    /**
     * Gets the serial number from the certificate.
     *
     * @return the serial number.
     */
    public BigInteger getSerialNumber() {
<span class="fc" id="L857">        SerialNumber ser = getSerialNumberObject();</span>

<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        return ser != null ? ser.getNumber() : null;</span>
    }

    /**
     * Gets the serial number from the certificate as
     * a SerialNumber object.
     *
     * @return the serial number.
     */
    public SerialNumber getSerialNumberObject() {
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L870">            return null;</span>
        try {
<span class="fc" id="L872">            SerialNumber ser = (SerialNumber)info.get(</span>
                              CertificateSerialNumber.NAME + DOT +
                              CertificateSerialNumber.NUMBER);
<span class="fc" id="L875">           return ser;</span>
<span class="nc" id="L876">        } catch (Exception e) {</span>
<span class="nc" id="L877">            return null;</span>
        }
    }


    /**
     * Gets the subject distinguished name from the certificate.
     *
     * @return the subject name.
     */
    public Principal getSubjectDN() {
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L889">            return null;</span>
        try {
<span class="fc" id="L891">            Principal subject = (Principal)info.get(X509CertInfo.SUBJECT + DOT +</span>
                                                    X509CertInfo.DN_NAME);
<span class="fc" id="L893">            return subject;</span>
<span class="nc" id="L894">        } catch (Exception e) {</span>
<span class="nc" id="L895">            return null;</span>
        }
    }

    /**
     * Get subject name as X500Principal. Overrides implementation in
     * X509Certificate with a slightly more efficient version that is
     * also aware of X509CertImpl mutability.
     */
    public X500Principal getSubjectX500Principal() {
<span class="pc bpc" id="L905" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L906">            return null;</span>
        }
        try {
<span class="fc" id="L909">            X500Principal subject = (X500Principal)info.get(</span>
                                            X509CertInfo.SUBJECT + DOT +
                                            &quot;x500principal&quot;);
<span class="fc" id="L912">            return subject;</span>
<span class="nc" id="L913">        } catch (Exception e) {</span>
<span class="nc" id="L914">            return null;</span>
        }
    }

    /**
     * Gets the issuer distinguished name from the certificate.
     *
     * @return the issuer name.
     */
    public Principal getIssuerDN() {
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L925">            return null;</span>
        try {
<span class="fc" id="L927">            Principal issuer = (Principal)info.get(X509CertInfo.ISSUER + DOT +</span>
                                                   X509CertInfo.DN_NAME);
<span class="fc" id="L929">            return issuer;</span>
<span class="nc" id="L930">        } catch (Exception e) {</span>
<span class="nc" id="L931">            return null;</span>
        }
    }

    /**
     * Get issuer name as X500Principal. Overrides implementation in
     * X509Certificate with a slightly more efficient version that is
     * also aware of X509CertImpl mutability.
     */
    public X500Principal getIssuerX500Principal() {
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L942">            return null;</span>
        }
        try {
<span class="fc" id="L945">            X500Principal issuer = (X500Principal)info.get(</span>
                                            X509CertInfo.ISSUER + DOT +
                                            &quot;x500principal&quot;);
<span class="fc" id="L948">            return issuer;</span>
<span class="nc" id="L949">        } catch (Exception e) {</span>
<span class="nc" id="L950">            return null;</span>
        }
    }

    /**
     * Gets the notBefore date from the validity period of the certificate.
     *
     * @return the start date of the validity period.
     */
    public Date getNotBefore() {
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L961">            return null;</span>
        try {
<span class="fc" id="L963">            Date d = (Date) info.get(CertificateValidity.NAME + DOT +</span>
                                        CertificateValidity.NOT_BEFORE);
<span class="fc" id="L965">            return d;</span>
<span class="nc" id="L966">        } catch (Exception e) {</span>
<span class="nc" id="L967">            return null;</span>
        }
    }

    /**
     * Gets the notAfter date from the validity period of the certificate.
     *
     * @return the end date of the validity period.
     */
    public Date getNotAfter() {
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L978">            return null;</span>
        try {
<span class="fc" id="L980">            Date d = (Date) info.get(CertificateValidity.NAME + DOT +</span>
                                     CertificateValidity.NOT_AFTER);
<span class="fc" id="L982">            return d;</span>
<span class="nc" id="L983">        } catch (Exception e) {</span>
<span class="nc" id="L984">            return null;</span>
        }
    }

    /**
     * Gets the DER encoded certificate informations, the
     * &lt;code&gt;tbsCertificate&lt;/code&gt; from this certificate.
     * This can be used to verify the signature independently.
     *
     * @return the DER encoded certificate information.
     * @exception CertificateEncodingException if an encoding error occurs.
     */
    public byte[] getTBSCertificate() throws CertificateEncodingException {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (info != null) {</span>
<span class="nc" id="L998">            return info.getEncodedInfo();</span>
        } else
<span class="nc" id="L1000">            throw new CertificateEncodingException(&quot;Uninitialized certificate&quot;);</span>
    }

    /**
     * Gets the raw Signature bits from the certificate.
     *
     * @return the signature.
     */
    public byte[] getSignature() {
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        if (signature == null)</span>
<span class="nc" id="L1010">            return null;</span>
<span class="nc" id="L1011">        byte[] dup = new byte[signature.length];</span>
<span class="nc" id="L1012">        System.arraycopy(signature, 0, dup, 0, dup.length);</span>
<span class="nc" id="L1013">        return dup;</span>
    }

    /**
     * Gets the signature algorithm name for the certificate
     * signature algorithm.
     * For example, the string &quot;SHA-1/DSA&quot; or &quot;DSS&quot;.
     *
     * @return the signature algorithm name.
     */
    public String getSigAlgName() {
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">        if (algId == null)</span>
<span class="nc" id="L1025">            return null;</span>
<span class="fc" id="L1026">        return (algId.getName());</span>
    }

    /**
     * Gets the signature algorithm OID string from the certificate.
     * For example, the string &quot;1.2.840.10040.4.3&quot;
     *
     * @return the signature algorithm oid string.
     */
    public String getSigAlgOID() {
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        if (algId == null)</span>
<span class="nc" id="L1037">            return null;</span>
<span class="fc" id="L1038">        ObjectIdentifier oid = algId.getOID();</span>
<span class="fc" id="L1039">        return (oid.toString());</span>
    }

    /**
     * Gets the DER encoded signature algorithm parameters from this
     * certificate's signature algorithm.
     *
     * @return the DER encoded signature algorithm parameters, or
     *         null if no parameters are present.
     */
    public byte[] getSigAlgParams() {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (algId == null)</span>
<span class="nc" id="L1051">            return null;</span>
        try {
<span class="nc" id="L1053">            return algId.getEncodedParams();</span>
<span class="nc" id="L1054">        } catch (IOException e) {</span>
<span class="nc" id="L1055">            return null;</span>
        }
    }

    /**
     * Gets the Issuer Unique Identity from the certificate.
     *
     * @return the Issuer Unique Identity.
     */
    public boolean[] getIssuerUniqueID() {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L1066">            return null;</span>
        try {
<span class="nc" id="L1068">            UniqueIdentity id = (UniqueIdentity)info.get(</span>
                                 X509CertInfo.ISSUER_ID);
<span class="nc bnc" id="L1070" title="All 2 branches missed.">            if (id == null)</span>
<span class="nc" id="L1071">                return null;</span>
            else
<span class="nc" id="L1073">                return (id.getId());</span>
<span class="nc" id="L1074">        } catch (Exception e) {</span>
<span class="nc" id="L1075">            return null;</span>
        }
    }

    /**
     * Gets the Subject Unique Identity from the certificate.
     *
     * @return the Subject Unique Identity.
     */
    public boolean[] getSubjectUniqueID() {
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L1086">            return null;</span>
        try {
<span class="nc" id="L1088">            UniqueIdentity id = (UniqueIdentity)info.get(</span>
                                 X509CertInfo.SUBJECT_ID);
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (id == null)</span>
<span class="nc" id="L1091">                return null;</span>
            else
<span class="nc" id="L1093">                return (id.getId());</span>
<span class="nc" id="L1094">        } catch (Exception e) {</span>
<span class="nc" id="L1095">            return null;</span>
        }
    }

    public KeyIdentifier getAuthKeyId() {
<span class="fc" id="L1100">        AuthorityKeyIdentifierExtension aki</span>
<span class="fc" id="L1101">            = getAuthorityKeyIdentifierExtension();</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        if (aki != null) {</span>
            try {
<span class="fc" id="L1104">                return (KeyIdentifier)aki.get(</span>
                    AuthorityKeyIdentifierExtension.KEY_ID);
<span class="nc" id="L1106">            } catch (IOException ioe) {} // not possible</span>
        }
<span class="nc" id="L1108">        return null;</span>
    }

    /**
     * Get AuthorityKeyIdentifier extension
     * @return AuthorityKeyIdentifier object or null (if no such object
     * in certificate)
     */
    public AuthorityKeyIdentifierExtension getAuthorityKeyIdentifierExtension()
    {
<span class="fc" id="L1118">        return (AuthorityKeyIdentifierExtension)</span>
<span class="fc" id="L1119">            getExtension(PKIXExtensions.AuthorityKey_Id);</span>
    }

    /**
     * Get BasicConstraints extension
     * @return BasicConstraints object or null (if no such object in
     * certificate)
     */
    public BasicConstraintsExtension getBasicConstraintsExtension() {
<span class="nc" id="L1128">        return (BasicConstraintsExtension)</span>
<span class="nc" id="L1129">            getExtension(PKIXExtensions.BasicConstraints_Id);</span>
    }

    /**
     * Get CertificatePoliciesExtension
     * @return CertificatePoliciesExtension or null (if no such object in
     * certificate)
     */
    public CertificatePoliciesExtension getCertificatePoliciesExtension() {
<span class="fc" id="L1138">        return (CertificatePoliciesExtension)</span>
<span class="fc" id="L1139">            getExtension(PKIXExtensions.CertificatePolicies_Id);</span>
    }

    /**
     * Get ExtendedKeyUsage extension
     * @return ExtendedKeyUsage extension object or null (if no such object
     * in certificate)
     */
    public ExtendedKeyUsageExtension getExtendedKeyUsageExtension() {
<span class="fc" id="L1148">        return (ExtendedKeyUsageExtension)</span>
<span class="fc" id="L1149">            getExtension(PKIXExtensions.ExtendedKeyUsage_Id);</span>
    }

    /**
     * Get IssuerAlternativeName extension
     * @return IssuerAlternativeName object or null (if no such object in
     * certificate)
     */
    public IssuerAlternativeNameExtension getIssuerAlternativeNameExtension() {
<span class="nc" id="L1158">        return (IssuerAlternativeNameExtension)</span>
<span class="nc" id="L1159">            getExtension(PKIXExtensions.IssuerAlternativeName_Id);</span>
    }

    /**
     * Get NameConstraints extension
     * @return NameConstraints object or null (if no such object in certificate)
     */
    public NameConstraintsExtension getNameConstraintsExtension() {
<span class="fc" id="L1167">        return (NameConstraintsExtension)</span>
<span class="fc" id="L1168">            getExtension(PKIXExtensions.NameConstraints_Id);</span>
    }

    /**
     * Get PolicyConstraints extension
     * @return PolicyConstraints object or null (if no such object in
     * certificate)
     */
    public PolicyConstraintsExtension getPolicyConstraintsExtension() {
<span class="fc" id="L1177">        return (PolicyConstraintsExtension)</span>
<span class="fc" id="L1178">            getExtension(PKIXExtensions.PolicyConstraints_Id);</span>
    }

    /**
     * Get PolicyMappingsExtension extension
     * @return PolicyMappingsExtension object or null (if no such object
     * in certificate)
     */
    public PolicyMappingsExtension getPolicyMappingsExtension() {
<span class="fc" id="L1187">        return (PolicyMappingsExtension)</span>
<span class="fc" id="L1188">            getExtension(PKIXExtensions.PolicyMappings_Id);</span>
    }

    /**
     * Get PrivateKeyUsage extension
     * @return PrivateKeyUsage object or null (if no such object in certificate)
     */
    public PrivateKeyUsageExtension getPrivateKeyUsageExtension() {
<span class="nc" id="L1196">        return (PrivateKeyUsageExtension)</span>
<span class="nc" id="L1197">            getExtension(PKIXExtensions.PrivateKeyUsage_Id);</span>
    }

    /**
     * Get SubjectAlternativeName extension
     * @return SubjectAlternativeName object or null (if no such object in
     * certificate)
     */
    public SubjectAlternativeNameExtension getSubjectAlternativeNameExtension()
    {
<span class="fc" id="L1207">        return (SubjectAlternativeNameExtension)</span>
<span class="fc" id="L1208">            getExtension(PKIXExtensions.SubjectAlternativeName_Id);</span>
    }

    /**
     * Get SubjectKeyIdentifier extension
     * @return SubjectKeyIdentifier object or null (if no such object in
     * certificate)
     */
    public SubjectKeyIdentifierExtension getSubjectKeyIdentifierExtension() {
<span class="nc" id="L1217">        return (SubjectKeyIdentifierExtension)</span>
<span class="nc" id="L1218">            getExtension(PKIXExtensions.SubjectKey_Id);</span>
    }

    /**
     * Get CRLDistributionPoints extension
     * @return CRLDistributionPoints object or null (if no such object in
     * certificate)
     */
    public CRLDistributionPointsExtension getCRLDistributionPointsExtension() {
<span class="fc" id="L1227">        return (CRLDistributionPointsExtension)</span>
<span class="fc" id="L1228">            getExtension(PKIXExtensions.CRLDistributionPoints_Id);</span>
    }

    /**
     * Return true if a critical extension is found that is
     * not supported, otherwise return false.
     */
    public boolean hasUnsupportedCriticalExtension() {
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">        if (info == null)</span>
<span class="nc" id="L1237">            return false;</span>
        try {
<span class="fc" id="L1239">            CertificateExtensions exts = (CertificateExtensions)info.get(</span>
                                         CertificateExtensions.NAME);
<span class="fc bfc" id="L1241" title="All 2 branches covered.">            if (exts == null)</span>
<span class="fc" id="L1242">                return false;</span>
<span class="fc" id="L1243">            return exts.hasUnsupportedCriticalExtension();</span>
<span class="nc" id="L1244">        } catch (Exception e) {</span>
<span class="nc" id="L1245">            return false;</span>
        }
    }

    /**
     * Gets a Set of the extension(s) marked CRITICAL in the
     * certificate. In the returned set, each extension is
     * represented by its OID string.
     *
     * @return a set of the extension oid strings in the
     * certificate that are marked critical.
     */
    public Set&lt;String&gt; getCriticalExtensionOIDs() {
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L1259">            return null;</span>
        }
        try {
<span class="fc" id="L1262">            CertificateExtensions exts = (CertificateExtensions)info.get(</span>
                                         CertificateExtensions.NAME);
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">            if (exts == null) {</span>
<span class="nc" id="L1265">                return null;</span>
            }
<span class="fc" id="L1267">            Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">            for (Extension ex : exts.getAllExtensions()) {</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">                if (ex.isCritical()) {</span>
<span class="fc" id="L1270">                    extSet.add(ex.getExtensionId().toString());</span>
                }
<span class="fc" id="L1272">            }</span>
<span class="fc" id="L1273">            return extSet;</span>
<span class="nc" id="L1274">        } catch (Exception e) {</span>
<span class="nc" id="L1275">            return null;</span>
        }
    }

    /**
     * Gets a Set of the extension(s) marked NON-CRITICAL in the
     * certificate. In the returned set, each extension is
     * represented by its OID string.
     *
     * @return a set of the extension oid strings in the
     * certificate that are NOT marked critical.
     */
    public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L1289">            return null;</span>
        }
        try {
<span class="nc" id="L1292">            CertificateExtensions exts = (CertificateExtensions)info.get(</span>
                                         CertificateExtensions.NAME);
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            if (exts == null) {</span>
<span class="nc" id="L1295">                return null;</span>
            }
<span class="nc" id="L1297">            Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">            for (Extension ex : exts.getAllExtensions()) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if (!ex.isCritical()) {</span>
<span class="nc" id="L1300">                    extSet.add(ex.getExtensionId().toString());</span>
                }
<span class="nc" id="L1302">            }</span>
<span class="nc" id="L1303">            extSet.addAll(exts.getUnparseableExtensions().keySet());</span>
<span class="nc" id="L1304">            return extSet;</span>
<span class="nc" id="L1305">        } catch (Exception e) {</span>
<span class="nc" id="L1306">            return null;</span>
        }
    }

    /**
     * Gets the extension identified by the given ObjectIdentifier
     *
     * @param oid the Object Identifier value for the extension.
     * @return Extension or null if certificate does not contain this
     *         extension
     */
    public Extension getExtension(ObjectIdentifier oid) {
<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L1319">            return null;</span>
        }
        try {
            CertificateExtensions extensions;
            try {
<span class="fc" id="L1324">                extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);</span>
<span class="nc" id="L1325">            } catch (CertificateException ce) {</span>
<span class="nc" id="L1326">                return null;</span>
<span class="fc" id="L1327">            }</span>
<span class="fc bfc" id="L1328" title="All 2 branches covered.">            if (extensions == null) {</span>
<span class="fc" id="L1329">                return null;</span>
            } else {
<span class="fc" id="L1331">                Extension ex = extensions.getExtension(oid.toString());</span>
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">                if (ex != null) {</span>
<span class="nc" id="L1333">                    return ex;</span>
                }
<span class="fc bfc" id="L1335" title="All 2 branches covered.">                for (Extension ex2: extensions.getAllExtensions()) {</span>
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                    if (ex2.getExtensionId().equals((Object)oid)) {</span>
                        //XXXX May want to consider cloning this
<span class="fc" id="L1338">                        return ex2;</span>
                    }
<span class="fc" id="L1340">                }</span>
                /* no such extension in this certificate */
<span class="fc" id="L1342">                return null;</span>
            }
<span class="nc" id="L1344">        } catch (IOException ioe) {</span>
<span class="nc" id="L1345">            return null;</span>
        }
    }

    public Extension getUnparseableExtension(ObjectIdentifier oid) {
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L1351">            return null;</span>
        }
        try {
            CertificateExtensions extensions;
            try {
<span class="nc" id="L1356">                extensions = (CertificateExtensions)info.get(CertificateExtensions.NAME);</span>
<span class="nc" id="L1357">            } catch (CertificateException ce) {</span>
<span class="nc" id="L1358">                return null;</span>
<span class="nc" id="L1359">            }</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">            if (extensions == null) {</span>
<span class="nc" id="L1361">                return null;</span>
            } else {
<span class="nc" id="L1363">                return extensions.getUnparseableExtensions().get(oid.toString());</span>
            }
<span class="nc" id="L1365">        } catch (IOException ioe) {</span>
<span class="nc" id="L1366">            return null;</span>
        }
    }

    /**
     * Gets the DER encoded extension identified by the given
     * oid String.
     *
     * @param oid the Object Identifier value for the extension.
     */
    public byte[] getExtensionValue(String oid) {
        try {
<span class="fc" id="L1378">            ObjectIdentifier findOID = new ObjectIdentifier(oid);</span>
<span class="fc" id="L1379">            String extAlias = OIDMap.getName(findOID);</span>
<span class="fc" id="L1380">            Extension certExt = null;</span>
<span class="fc" id="L1381">            CertificateExtensions exts = (CertificateExtensions)info.get(</span>
                                     CertificateExtensions.NAME);

<span class="pc bpc" id="L1384" title="1 of 2 branches missed.">            if (extAlias == null) { // may be unknown</span>
                // get the extensions, search thru' for this oid
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                if (exts == null) {</span>
<span class="nc" id="L1387">                    return null;</span>
                }

<span class="nc bnc" id="L1390" title="All 2 branches missed.">                for (Extension ex : exts.getAllExtensions()) {</span>
<span class="nc" id="L1391">                    ObjectIdentifier inCertOID = ex.getExtensionId();</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                    if (inCertOID.equals((Object)findOID)) {</span>
<span class="nc" id="L1393">                        certExt = ex;</span>
<span class="nc" id="L1394">                        break;</span>
                    }
<span class="nc" id="L1396">                }</span>
            } else { // there's sub-class that can handle this extension
                try {
<span class="fc" id="L1399">                    certExt = (Extension)this.get(extAlias);</span>
<span class="nc" id="L1400">                } catch (CertificateException e) {</span>
                    // get() throws an Exception instead of returning null, ignore
<span class="fc" id="L1402">                }</span>
            }
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">            if (certExt == null) {</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">                if (exts != null) {</span>
<span class="nc" id="L1406">                    certExt = exts.getUnparseableExtensions().get(oid);</span>
                }
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                if (certExt == null) {</span>
<span class="nc" id="L1409">                    return null;</span>
                }
            }
<span class="fc" id="L1412">            byte[] extData = certExt.getExtensionValue();</span>
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">            if (extData == null) {</span>
<span class="nc" id="L1414">                return null;</span>
            }
<span class="fc" id="L1416">            DerOutputStream out = new DerOutputStream();</span>
<span class="fc" id="L1417">            out.putOctetString(extData);</span>
<span class="fc" id="L1418">            return out.toByteArray();</span>
<span class="nc" id="L1419">        } catch (Exception e) {</span>
<span class="nc" id="L1420">            return null;</span>
        }
    }

    /**
     * Get a boolean array representing the bits of the KeyUsage extension,
     * (oid = 2.5.29.15).
     * @return the bit values of this extension as an array of booleans.
     */
    public boolean[] getKeyUsage() {
        try {
<span class="fc" id="L1431">            String extAlias = OIDMap.getName(PKIXExtensions.KeyUsage_Id);</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">            if (extAlias == null)</span>
<span class="nc" id="L1433">                return null;</span>

<span class="fc" id="L1435">            KeyUsageExtension certExt = (KeyUsageExtension)this.get(extAlias);</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (certExt == null)</span>
<span class="fc" id="L1437">                return null;</span>

<span class="fc" id="L1439">            boolean[] ret = certExt.getBits();</span>
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">            if (ret.length &lt; NUM_STANDARD_KEY_USAGE) {</span>
<span class="fc" id="L1441">                boolean[] usageBits = new boolean[NUM_STANDARD_KEY_USAGE];</span>
<span class="fc" id="L1442">                System.arraycopy(ret, 0, usageBits, 0, ret.length);</span>
<span class="fc" id="L1443">                ret = usageBits;</span>
            }
<span class="fc" id="L1445">            return ret;</span>
<span class="fc" id="L1446">        } catch (Exception e) {</span>
<span class="fc" id="L1447">            return null;</span>
        }
    }

    /**
     * This method are the overridden implementation of
     * getExtendedKeyUsage method in X509Certificate in the Sun
     * provider. It is better performance-wise since it returns cached
     * values.
     */
    public synchronized List&lt;String&gt; getExtendedKeyUsage()
        throws CertificateParsingException {
<span class="pc bpc" id="L1459" title="1 of 4 branches missed.">        if (readOnly &amp;&amp; extKeyUsage != null) {</span>
<span class="fc" id="L1460">            return extKeyUsage;</span>
        } else {
<span class="fc" id="L1462">            ExtendedKeyUsageExtension ext = getExtendedKeyUsageExtension();</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">            if (ext == null) {</span>
<span class="fc" id="L1464">                return null;</span>
            }
<span class="fc" id="L1466">            extKeyUsage =</span>
<span class="fc" id="L1467">                Collections.unmodifiableList(ext.getExtendedKeyUsage());</span>
<span class="fc" id="L1468">            return extKeyUsage;</span>
        }
    }

    /**
     * This static method is the default implementation of the
     * getExtendedKeyUsage method in X509Certificate. A
     * X509Certificate provider generally should overwrite this to
     * provide among other things caching for better performance.
     */
    public static List&lt;String&gt; getExtendedKeyUsage(X509Certificate cert)
        throws CertificateParsingException {
        try {
<span class="nc" id="L1481">            byte[] ext = cert.getExtensionValue(EXTENDED_KEY_USAGE_OID);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (ext == null)</span>
<span class="nc" id="L1483">                return null;</span>
<span class="nc" id="L1484">            DerValue val = new DerValue(ext);</span>
<span class="nc" id="L1485">            byte[] data = val.getOctetString();</span>

<span class="nc" id="L1487">            ExtendedKeyUsageExtension ekuExt =</span>
                new ExtendedKeyUsageExtension(Boolean.FALSE, data);
<span class="nc" id="L1489">            return Collections.unmodifiableList(ekuExt.getExtendedKeyUsage());</span>
<span class="nc" id="L1490">        } catch (IOException ioe) {</span>
<span class="nc" id="L1491">            throw new CertificateParsingException(ioe);</span>
        }
    }

    /**
     * Get the certificate constraints path length from the
     * the critical BasicConstraints extension, (oid = 2.5.29.19).
     * @return the length of the constraint.
     */
    public int getBasicConstraints() {
        try {
<span class="fc" id="L1502">            String extAlias = OIDMap.getName(PKIXExtensions.BasicConstraints_Id);</span>
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">            if (extAlias == null)</span>
<span class="nc" id="L1504">                return -1;</span>
<span class="fc" id="L1505">            BasicConstraintsExtension certExt =</span>
<span class="fc" id="L1506">                        (BasicConstraintsExtension)this.get(extAlias);</span>
<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">            if (certExt == null)</span>
<span class="nc" id="L1508">                return -1;</span>

<span class="fc" id="L1510">            if (((Boolean)certExt.get(BasicConstraintsExtension.IS_CA)</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">                 ).booleanValue() == true)</span>
<span class="fc" id="L1512">                return ((Integer)certExt.get(</span>
<span class="fc" id="L1513">                        BasicConstraintsExtension.PATH_LEN)).intValue();</span>
            else
<span class="nc" id="L1515">                return -1;</span>
<span class="fc" id="L1516">        } catch (Exception e) {</span>
<span class="fc" id="L1517">            return -1;</span>
        }
    }

    /**
     * Converts a GeneralNames structure into an immutable Collection of
     * alternative names (subject or issuer) in the form required by
     * {@link #getSubjectAlternativeNames} or
     * {@link #getIssuerAlternativeNames}.
     *
     * @param names the GeneralNames to be converted
     * @return an immutable Collection of alternative names
     */
    private static Collection&lt;List&lt;?&gt;&gt; makeAltNames(GeneralNames names) {
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">        if (names.isEmpty()) {</span>
<span class="nc" id="L1532">            return Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
        }
<span class="fc" id="L1534">        List&lt;List&lt;?&gt;&gt; newNames = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">        for (GeneralName gname : names.names()) {</span>
<span class="fc" id="L1536">            GeneralNameInterface name = gname.getName();</span>
<span class="fc" id="L1537">            List&lt;Object&gt; nameEntry = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L1538">            nameEntry.add(Integer.valueOf(name.getType()));</span>
<span class="pc bpc" id="L1539" title="3 of 7 branches missed.">            switch (name.getType()) {</span>
            case GeneralNameInterface.NAME_RFC822:
<span class="fc" id="L1541">                nameEntry.add(((RFC822Name) name).getName());</span>
<span class="fc" id="L1542">                break;</span>
            case GeneralNameInterface.NAME_DNS:
<span class="fc" id="L1544">                nameEntry.add(((DNSName) name).getName());</span>
<span class="fc" id="L1545">                break;</span>
            case GeneralNameInterface.NAME_DIRECTORY:
<span class="nc" id="L1547">                nameEntry.add(((X500Name) name).getRFC2253Name());</span>
<span class="nc" id="L1548">                break;</span>
            case GeneralNameInterface.NAME_URI:
<span class="nc" id="L1550">                nameEntry.add(((URIName) name).getName());</span>
<span class="nc" id="L1551">                break;</span>
            case GeneralNameInterface.NAME_IP:
                try {
<span class="fc" id="L1554">                    nameEntry.add(((IPAddressName) name).getName());</span>
<span class="nc" id="L1555">                } catch (IOException ioe) {</span>
                    // IPAddressName in cert is bogus
<span class="nc" id="L1557">                    throw new RuntimeException(&quot;IPAddress cannot be parsed&quot;,</span>
                        ioe);
<span class="fc" id="L1559">                }</span>
                break;
            case GeneralNameInterface.NAME_OID:
<span class="fc" id="L1562">                nameEntry.add(((OIDName) name).getOID().toString());</span>
<span class="fc" id="L1563">                break;</span>
            default:
                // add DER encoded form
<span class="nc" id="L1566">                DerOutputStream derOut = new DerOutputStream();</span>
                try {
<span class="nc" id="L1568">                    name.encode(derOut);</span>
<span class="nc" id="L1569">                } catch (IOException ioe) {</span>
                    // should not occur since name has already been decoded
                    // from cert (this would indicate a bug in our code)
<span class="nc" id="L1572">                    throw new RuntimeException(&quot;name cannot be encoded&quot;, ioe);</span>
<span class="nc" id="L1573">                }</span>
<span class="nc" id="L1574">                nameEntry.add(derOut.toByteArray());</span>
                break;
            }
<span class="fc" id="L1577">            newNames.add(Collections.unmodifiableList(nameEntry));</span>
<span class="fc" id="L1578">        }</span>
<span class="fc" id="L1579">        return Collections.unmodifiableCollection(newNames);</span>
    }

    /**
     * Checks a Collection of altNames and clones any name entries of type
     * byte [].
     */ // only partially generified due to javac bug
    private static Collection&lt;List&lt;?&gt;&gt; cloneAltNames(Collection&lt;List&lt;?&gt;&gt; altNames) {
<span class="nc" id="L1587">        boolean mustClone = false;</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        for (List&lt;?&gt; nameEntry : altNames) {</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">            if (nameEntry.get(1) instanceof byte[]) {</span>
                // must clone names
<span class="nc" id="L1591">                mustClone = true;</span>
            }
<span class="nc" id="L1593">        }</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        if (mustClone) {</span>
<span class="nc" id="L1595">            List&lt;List&lt;?&gt;&gt; namesCopy = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">            for (List&lt;?&gt; nameEntry : altNames) {</span>
<span class="nc" id="L1597">                Object nameObject = nameEntry.get(1);</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                if (nameObject instanceof byte[]) {</span>
<span class="nc" id="L1599">                    List&lt;Object&gt; nameEntryCopy =</span>
                                        new ArrayList&lt;&gt;(nameEntry);
<span class="nc" id="L1601">                    nameEntryCopy.set(1, ((byte[])nameObject).clone());</span>
<span class="nc" id="L1602">                    namesCopy.add(Collections.unmodifiableList(nameEntryCopy));</span>
<span class="nc" id="L1603">                } else {</span>
<span class="nc" id="L1604">                    namesCopy.add(nameEntry);</span>
                }
<span class="nc" id="L1606">            }</span>
<span class="nc" id="L1607">            return Collections.unmodifiableCollection(namesCopy);</span>
        } else {
<span class="nc" id="L1609">            return altNames;</span>
        }
    }

    /**
     * This method are the overridden implementation of
     * getSubjectAlternativeNames method in X509Certificate in the Sun
     * provider. It is better performance-wise since it returns cached
     * values.
     */
    public synchronized Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames()
        throws CertificateParsingException {
        // return cached value if we can
<span class="pc bpc" id="L1622" title="2 of 4 branches missed.">        if (readOnly &amp;&amp; subjectAlternativeNames != null)  {</span>
<span class="nc" id="L1623">            return cloneAltNames(subjectAlternativeNames);</span>
        }
<span class="fc" id="L1625">        SubjectAlternativeNameExtension subjectAltNameExt =</span>
<span class="fc" id="L1626">            getSubjectAlternativeNameExtension();</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">        if (subjectAltNameExt == null) {</span>
<span class="fc" id="L1628">            return null;</span>
        }
        GeneralNames names;
        try {
<span class="fc" id="L1632">            names = subjectAltNameExt.get(</span>
                    SubjectAlternativeNameExtension.SUBJECT_NAME);
<span class="nc" id="L1634">        } catch (IOException ioe) {</span>
            // should not occur
<span class="nc" id="L1636">            return Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
<span class="fc" id="L1637">        }</span>
<span class="fc" id="L1638">        subjectAlternativeNames = makeAltNames(names);</span>
<span class="fc" id="L1639">        return subjectAlternativeNames;</span>
    }

    /**
     * This static method is the default implementation of the
     * getSubjectAlternaitveNames method in X509Certificate. A
     * X509Certificate provider generally should overwrite this to
     * provide among other things caching for better performance.
     */
    public static Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames(X509Certificate cert)
        throws CertificateParsingException {
        try {
<span class="nc" id="L1651">            byte[] ext = cert.getExtensionValue(SUBJECT_ALT_NAME_OID);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">            if (ext == null) {</span>
<span class="nc" id="L1653">                return null;</span>
            }
<span class="nc" id="L1655">            DerValue val = new DerValue(ext);</span>
<span class="nc" id="L1656">            byte[] data = val.getOctetString();</span>

<span class="nc" id="L1658">            SubjectAlternativeNameExtension subjectAltNameExt =</span>
                new SubjectAlternativeNameExtension(Boolean.FALSE,
                                                    data);

            GeneralNames names;
            try {
<span class="nc" id="L1664">                names = subjectAltNameExt.get(</span>
                        SubjectAlternativeNameExtension.SUBJECT_NAME);
<span class="nc" id="L1666">            }  catch (IOException ioe) {</span>
                // should not occur
<span class="nc" id="L1668">                return Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
<span class="nc" id="L1669">            }</span>
<span class="nc" id="L1670">            return makeAltNames(names);</span>
<span class="nc" id="L1671">        } catch (IOException ioe) {</span>
<span class="nc" id="L1672">            throw new CertificateParsingException(ioe);</span>
        }
    }

    /**
     * This method are the overridden implementation of
     * getIssuerAlternativeNames method in X509Certificate in the Sun
     * provider. It is better performance-wise since it returns cached
     * values.
     */
    public synchronized Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames()
        throws CertificateParsingException {
        // return cached value if we can
<span class="nc bnc" id="L1685" title="All 4 branches missed.">        if (readOnly &amp;&amp; issuerAlternativeNames != null) {</span>
<span class="nc" id="L1686">            return cloneAltNames(issuerAlternativeNames);</span>
        }
<span class="nc" id="L1688">        IssuerAlternativeNameExtension issuerAltNameExt =</span>
<span class="nc" id="L1689">            getIssuerAlternativeNameExtension();</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">        if (issuerAltNameExt == null) {</span>
<span class="nc" id="L1691">            return null;</span>
        }
        GeneralNames names;
        try {
<span class="nc" id="L1695">            names = issuerAltNameExt.get(</span>
                    IssuerAlternativeNameExtension.ISSUER_NAME);
<span class="nc" id="L1697">        } catch (IOException ioe) {</span>
            // should not occur
<span class="nc" id="L1699">            return Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
<span class="nc" id="L1700">        }</span>
<span class="nc" id="L1701">        issuerAlternativeNames = makeAltNames(names);</span>
<span class="nc" id="L1702">        return issuerAlternativeNames;</span>
    }

    /**
     * This static method is the default implementation of the
     * getIssuerAlternaitveNames method in X509Certificate. A
     * X509Certificate provider generally should overwrite this to
     * provide among other things caching for better performance.
     */
    public static Collection&lt;List&lt;?&gt;&gt; getIssuerAlternativeNames(X509Certificate cert)
        throws CertificateParsingException {
        try {
<span class="nc" id="L1714">            byte[] ext = cert.getExtensionValue(ISSUER_ALT_NAME_OID);</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">            if (ext == null) {</span>
<span class="nc" id="L1716">                return null;</span>
            }

<span class="nc" id="L1719">            DerValue val = new DerValue(ext);</span>
<span class="nc" id="L1720">            byte[] data = val.getOctetString();</span>

<span class="nc" id="L1722">            IssuerAlternativeNameExtension issuerAltNameExt =</span>
                new IssuerAlternativeNameExtension(Boolean.FALSE,
                                                    data);
            GeneralNames names;
            try {
<span class="nc" id="L1727">                names = issuerAltNameExt.get(</span>
                        IssuerAlternativeNameExtension.ISSUER_NAME);
<span class="nc" id="L1729">            }  catch (IOException ioe) {</span>
                // should not occur
<span class="nc" id="L1731">                return Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
<span class="nc" id="L1732">            }</span>
<span class="nc" id="L1733">            return makeAltNames(names);</span>
<span class="nc" id="L1734">        } catch (IOException ioe) {</span>
<span class="nc" id="L1735">            throw new CertificateParsingException(ioe);</span>
        }
    }

    public AuthorityInfoAccessExtension getAuthorityInfoAccessExtension() {
<span class="nc" id="L1740">        return (AuthorityInfoAccessExtension)</span>
<span class="nc" id="L1741">            getExtension(PKIXExtensions.AuthInfoAccess_Id);</span>
    }

    /************************************************************/

    /*
     * Cert is a SIGNED ASN.1 macro, a three elment sequence:
     *
     *  - Data to be signed (ToBeSigned) -- the &quot;raw&quot; cert
     *  - Signature algorithm (SigAlgId)
     *  - The signature bits
     *
     * This routine unmarshals the certificate, saving the signature
     * parts away for later verification.
     */
    private void parse(DerValue val)
    throws CertificateException, IOException {
        // check if can over write the certificate
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">        if (readOnly)</span>
<span class="nc" id="L1760">            throw new CertificateParsingException(</span>
                      &quot;cannot over-write existing certificate&quot;);

<span class="pc bpc" id="L1763" title="2 of 4 branches missed.">        if (val.data == null || val.tag != DerValue.tag_Sequence)</span>
<span class="nc" id="L1764">            throw new CertificateParsingException(</span>
                      &quot;invalid DER-encoded certificate data&quot;);

<span class="fc" id="L1767">        signedCert = val.toByteArray();</span>
<span class="fc" id="L1768">        DerValue[] seq = new DerValue[3];</span>

<span class="fc" id="L1770">        seq[0] = val.data.getDerValue();</span>
<span class="fc" id="L1771">        seq[1] = val.data.getDerValue();</span>
<span class="fc" id="L1772">        seq[2] = val.data.getDerValue();</span>

<span class="pc bpc" id="L1774" title="1 of 2 branches missed.">        if (val.data.available() != 0) {</span>
<span class="nc" id="L1775">            throw new CertificateParsingException(&quot;signed overrun, bytes = &quot;</span>
<span class="nc" id="L1776">                                     + val.data.available());</span>
        }
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">        if (seq[0].tag != DerValue.tag_Sequence) {</span>
<span class="nc" id="L1779">            throw new CertificateParsingException(&quot;signed fields invalid&quot;);</span>
        }

<span class="fc" id="L1782">        algId = AlgorithmId.parse(seq[1]);</span>
<span class="fc" id="L1783">        signature = seq[2].getBitString();</span>

<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">        if (seq[1].data.available() != 0) {</span>
<span class="nc" id="L1786">            throw new CertificateParsingException(&quot;algid field overrun&quot;);</span>
        }
<span class="pc bpc" id="L1788" title="1 of 2 branches missed.">        if (seq[2].data.available() != 0)</span>
<span class="nc" id="L1789">            throw new CertificateParsingException(&quot;signed fields overrun&quot;);</span>

        // The CertificateInfo
<span class="fc" id="L1792">        info = new X509CertInfo(seq[0]);</span>

        // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
<span class="fc" id="L1795">        AlgorithmId infoSigAlg = (AlgorithmId)info.get(</span>
                                              CertificateAlgorithmId.NAME
                                              + DOT +
                                              CertificateAlgorithmId.ALGORITHM);
<span class="pc bpc" id="L1799" title="1 of 2 branches missed.">        if (! algId.equals(infoSigAlg))</span>
<span class="nc" id="L1800">            throw new CertificateException(&quot;Signature algorithm mismatch&quot;);</span>
<span class="fc" id="L1801">        readOnly = true;</span>
<span class="fc" id="L1802">    }</span>

    /**
     * Extract the subject or issuer X500Principal from an X509Certificate.
     * Parses the encoded form of the cert to preserve the principal's
     * ASN.1 encoding.
     */
    private static X500Principal getX500Principal(X509Certificate cert,
            boolean getIssuer) throws Exception {
<span class="nc" id="L1811">        byte[] encoded = cert.getEncoded();</span>
<span class="nc" id="L1812">        DerInputStream derIn = new DerInputStream(encoded);</span>
<span class="nc" id="L1813">        DerValue tbsCert = derIn.getSequence(3)[0];</span>
<span class="nc" id="L1814">        DerInputStream tbsIn = tbsCert.data;</span>
        DerValue tmp;
<span class="nc" id="L1816">        tmp = tbsIn.getDerValue();</span>
        // skip version number if present
<span class="nc bnc" id="L1818" title="All 2 branches missed.">        if (tmp.isContextSpecific((byte)0)) {</span>
<span class="nc" id="L1819">          tmp = tbsIn.getDerValue();</span>
        }
        // tmp always contains serial number now
<span class="nc" id="L1822">        tmp = tbsIn.getDerValue();              // skip signature</span>
<span class="nc" id="L1823">        tmp = tbsIn.getDerValue();              // issuer</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">        if (getIssuer == false) {</span>
<span class="nc" id="L1825">            tmp = tbsIn.getDerValue();          // skip validity</span>
<span class="nc" id="L1826">            tmp = tbsIn.getDerValue();          // subject</span>
        }
<span class="nc" id="L1828">        byte[] principalBytes = tmp.toByteArray();</span>
<span class="nc" id="L1829">        return new X500Principal(principalBytes);</span>
    }

    /**
     * Extract the subject X500Principal from an X509Certificate.
     * Called from java.security.cert.X509Certificate.getSubjectX500Principal().
     */
    public static X500Principal getSubjectX500Principal(X509Certificate cert) {
        try {
<span class="nc" id="L1838">            return getX500Principal(cert, false);</span>
<span class="nc" id="L1839">        } catch (Exception e) {</span>
<span class="nc" id="L1840">            throw new RuntimeException(&quot;Could not parse subject&quot;, e);</span>
        }
    }

    /**
     * Extract the issuer X500Principal from an X509Certificate.
     * Called from java.security.cert.X509Certificate.getIssuerX500Principal().
     */
    public static X500Principal getIssuerX500Principal(X509Certificate cert) {
        try {
<span class="nc" id="L1850">            return getX500Principal(cert, true);</span>
<span class="nc" id="L1851">        } catch (Exception e) {</span>
<span class="nc" id="L1852">            throw new RuntimeException(&quot;Could not parse issuer&quot;, e);</span>
        }
    }

    /**
     * Returned the encoding of the given certificate for internal use.
     * Callers must guarantee that they neither modify it nor expose it
     * to untrusted code. Uses getEncodedInternal() if the certificate
     * is instance of X509CertImpl, getEncoded() otherwise.
     */
    public static byte[] getEncodedInternal(Certificate cert)
            throws CertificateEncodingException {
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">        if (cert instanceof X509CertImpl) {</span>
<span class="fc" id="L1865">            return ((X509CertImpl)cert).getEncodedInternal();</span>
        } else {
<span class="nc" id="L1867">            return cert.getEncoded();</span>
        }
    }

    /**
     * Utility method to convert an arbitrary instance of X509Certificate
     * to a X509CertImpl. Does a cast if possible, otherwise reparses
     * the encoding.
     */
    public static X509CertImpl toImpl(X509Certificate cert)
            throws CertificateException {
<span class="pc bpc" id="L1878" title="1 of 2 branches missed.">        if (cert instanceof X509CertImpl) {</span>
<span class="fc" id="L1879">            return (X509CertImpl)cert;</span>
        } else {
<span class="nc" id="L1881">            return X509Factory.intern(cert);</span>
        }
    }

    /**
     * Utility method to test if a certificate is self-issued. This is
     * the case iff the subject and issuer X500Principals are equal.
     */
    public static boolean isSelfIssued(X509Certificate cert) {
<span class="fc" id="L1890">        X500Principal subject = cert.getSubjectX500Principal();</span>
<span class="fc" id="L1891">        X500Principal issuer = cert.getIssuerX500Principal();</span>
<span class="fc" id="L1892">        return subject.equals(issuer);</span>
    }

    /**
     * Utility method to test if a certificate is self-signed. This is
     * the case iff the subject and issuer X500Principals are equal
     * AND the certificate's subject public key can be used to verify
     * the certificate. In case of exception, returns false.
     */
    public static boolean isSelfSigned(X509Certificate cert,
        String sigProvider) {
<span class="fc bfc" id="L1903" title="All 2 branches covered.">        if (isSelfIssued(cert)) {</span>
            try {
<span class="pc bpc" id="L1905" title="1 of 2 branches missed.">                if (sigProvider == null) {</span>
<span class="fc" id="L1906">                    cert.verify(cert.getPublicKey());</span>
                } else {
<span class="nc" id="L1908">                    cert.verify(cert.getPublicKey(), sigProvider);</span>
                }
<span class="fc" id="L1910">                return true;</span>
<span class="fc" id="L1911">            } catch (Exception e) {</span>
                // In case of exception, return false
            }
        }
<span class="fc" id="L1915">        return false;</span>
    }

<span class="pc" id="L1918">    private ConcurrentHashMap&lt;String,String&gt; fingerprints =</span>
            new ConcurrentHashMap&lt;&gt;(2);

    public String getFingerprint(String algorithm) {
<span class="fc" id="L1922">        return fingerprints.computeIfAbsent(algorithm,</span>
                x -&gt; getCertificateFingerPrint(x));
    }

    /**
     * Gets the requested finger print of the certificate. The result
     * only contains 0-9 and A-F. No small case, no colon.
     */
    private String getCertificateFingerPrint(String mdAlg) {
<span class="fc" id="L1931">        String fingerPrint = &quot;&quot;;</span>
        try {
<span class="fc" id="L1933">            byte[] encCertInfo = getEncoded();</span>
<span class="fc" id="L1934">            MessageDigest md = MessageDigest.getInstance(mdAlg);</span>
<span class="fc" id="L1935">            byte[] digest = md.digest(encCertInfo);</span>
<span class="fc" id="L1936">            StringBuffer buf = new StringBuffer();</span>
<span class="fc bfc" id="L1937" title="All 2 branches covered.">            for (int i = 0; i &lt; digest.length; i++) {</span>
<span class="fc" id="L1938">                byte2hex(digest[i], buf);</span>
            }
<span class="fc" id="L1940">            fingerPrint = buf.toString();</span>
<span class="nc" id="L1941">        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {</span>
            // ignored
<span class="fc" id="L1943">        }</span>
<span class="fc" id="L1944">        return fingerPrint;</span>
    }

    /**
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private static void byte2hex(byte b, StringBuffer buf) {
<span class="fc" id="L1951">        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',</span>
                '9', 'A', 'B', 'C', 'D', 'E', 'F' };
<span class="fc" id="L1953">        int high = ((b &amp; 0xf0) &gt;&gt; 4);</span>
<span class="fc" id="L1954">        int low = (b &amp; 0x0f);</span>
<span class="fc" id="L1955">        buf.append(hexChars[high]);</span>
<span class="fc" id="L1956">        buf.append(hexChars[low]);</span>
<span class="fc" id="L1957">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>