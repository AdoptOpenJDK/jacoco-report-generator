<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DescriptorSupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.modelmbean</a> &gt; <span class="el_source">DescriptorSupport.java</span></div><h1>DescriptorSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 * @author    IBM Corp.
 *
 * Copyright IBM Corp. 1999-2000.  All rights reserved.
 */

package javax.management.modelmbean;

import static com.sun.jmx.defaults.JmxProperties.MODELMBEAN_LOGGER;
import static com.sun.jmx.mbeanserver.Util.cast;
import com.sun.jmx.mbeanserver.GetPropertyAction;
import com.sun.jmx.mbeanserver.Util;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamField;

import java.lang.reflect.Constructor;

import java.security.AccessController;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.logging.Level;

import javax.management.Descriptor;
import javax.management.ImmutableDescriptor;
import javax.management.MBeanException;
import javax.management.RuntimeOperationsException;

import sun.reflect.misc.ReflectUtil;

/**
 * This class represents the metadata set for a ModelMBean element.  A
 * descriptor is part of the ModelMBeanInfo,
 * ModelMBeanNotificationInfo, ModelMBeanAttributeInfo,
 * ModelMBeanConstructorInfo, and ModelMBeanParameterInfo.
 * &lt;P&gt;
 * A descriptor consists of a collection of fields.  Each field is in
 * fieldname=fieldvalue format.  Field names are not case sensitive,
 * case will be preserved on field values.
 * &lt;P&gt;
 * All field names and values are not predefined. New fields can be
 * defined and added by any program.  Some fields have been predefined
 * for consistency of implementation and support by the
 * ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo,
 * ModelMBeanNotificationInfo, ModelMBeanOperationInfo and ModelMBean
 * classes.
 *
 * &lt;p&gt;The &lt;b&gt;serialVersionUID&lt;/b&gt; of this class is &lt;code&gt;-6292969195866300415L&lt;/code&gt;.
 *
 * @since 1.5
 */
@SuppressWarnings(&quot;serial&quot;)  // serialVersionUID not constant
public class DescriptorSupport
         implements javax.management.Descriptor
{

    // Serialization compatibility stuff:
    // Two serial forms are supported in this class. The selected form depends
    // on system property &quot;jmx.serial.form&quot;:
    //  - &quot;1.0&quot; for JMX 1.0
    //  - any other value for JMX 1.1 and higher
    //
    // Serial version for old serial form
    private static final long oldSerialVersionUID = 8071560848919417985L;
    //
    // Serial version for new serial form
    private static final long newSerialVersionUID = -6292969195866300415L;
    //
    // Serializable fields in old serial form
<span class="nc" id="L101">    private static final ObjectStreamField[] oldSerialPersistentFields =</span>
    {
      new ObjectStreamField(&quot;descriptor&quot;, HashMap.class),
      new ObjectStreamField(&quot;currClass&quot;, String.class)
    };
    //
    // Serializable fields in new serial form
<span class="nc" id="L108">    private static final ObjectStreamField[] newSerialPersistentFields =</span>
    {
      new ObjectStreamField(&quot;descriptor&quot;, HashMap.class)
    };
    //
    // Actual serial version and serial form
    private static final long serialVersionUID;
    /**
     * @serialField descriptor HashMap The collection of fields representing this descriptor
     */
    private static final ObjectStreamField[] serialPersistentFields;
    private static final String serialForm;
    static {
<span class="nc" id="L121">        String form = null;</span>
<span class="nc" id="L122">        boolean compat = false;</span>
        try {
<span class="nc" id="L124">            GetPropertyAction act = new GetPropertyAction(&quot;jmx.serial.form&quot;);</span>
<span class="nc" id="L125">            form = AccessController.doPrivileged(act);</span>
<span class="nc" id="L126">            compat = &quot;1.0&quot;.equals(form);  // form may be null</span>
<span class="nc" id="L127">        } catch (Exception e) {</span>
            // OK: No compat with 1.0
<span class="nc" id="L129">        }</span>
<span class="nc" id="L130">        serialForm = form;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (compat) {</span>
<span class="nc" id="L132">            serialPersistentFields = oldSerialPersistentFields;</span>
<span class="nc" id="L133">            serialVersionUID = oldSerialVersionUID;</span>
        } else {
<span class="nc" id="L135">            serialPersistentFields = newSerialPersistentFields;</span>
<span class="nc" id="L136">            serialVersionUID = newSerialVersionUID;</span>
        }
    }
    //
    // END Serialization compatibility stuff

    /* Spec says that field names are case-insensitive, but that case
       is preserved.  This means that we need to be able to map from a
       name that may differ in case to the actual name that is used in
       the HashMap.  Thus, descriptorMap is a TreeMap with a Comparator
       that ignores case.

       Previous versions of this class had a field called &quot;descriptor&quot;
       of type HashMap where the keys were directly Strings.  This is
       hard to reconcile with the required semantics, so we fabricate
       that field virtually during serialization and deserialization
       but keep the real information in descriptorMap.
    */
    private transient SortedMap&lt;String, Object&gt; descriptorMap;

    private static final String currClass = &quot;DescriptorSupport&quot;;


    /**
     * Descriptor default constructor.
     * Default initial descriptor size is 20.  It will grow as needed.&lt;br&gt;
     * Note that the created empty descriptor is not a valid descriptor
     * (the method {@link #isValid isValid} returns &lt;CODE&gt;false&lt;/CODE&gt;)
     */
<span class="nc" id="L165">    public DescriptorSupport() {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L167">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L168">                    DescriptorSupport.class.getName(),</span>
                    &quot;DescriptorSupport()&quot; , &quot;Constructor&quot;);
        }
<span class="nc" id="L171">        init(null);</span>
<span class="nc" id="L172">    }</span>

    /**
     * Descriptor constructor.  Takes as parameter the initial
     * capacity of the Map that stores the descriptor fields.
     * Capacity will grow as needed.&lt;br&gt; Note that the created empty
     * descriptor is not a valid descriptor (the method {@link
     * #isValid isValid} returns &lt;CODE&gt;false&lt;/CODE&gt;).
     *
     * @param initNumFields The initial capacity of the Map that
     * stores the descriptor fields.
     *
     * @exception RuntimeOperationsException for illegal value for
     * initNumFields (&amp;lt;= 0)
     * @exception MBeanException Wraps a distributed communication Exception.
     */
    public DescriptorSupport(int initNumFields)
<span class="nc" id="L189">            throws MBeanException, RuntimeOperationsException {</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L191">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L192">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(initNumFields = &quot; + initNumFields + &quot;)&quot;,
                    &quot;Constructor&quot;);
        }
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (initNumFields &lt;= 0) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L198">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L199">                        DescriptorSupport.class.getName(),</span>
                        &quot;Descriptor(initNumFields)&quot;,
                        &quot;Illegal arguments: initNumFields &lt;= 0&quot;);
            }
<span class="nc" id="L203">            final String msg =</span>
                &quot;Descriptor field limit invalid: &quot; + initNumFields;
<span class="nc" id="L205">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L206">            throw new RuntimeOperationsException(iae, msg);</span>
        }
<span class="nc" id="L208">        init(null);</span>
<span class="nc" id="L209">    }</span>

    /**
     * Descriptor constructor taking a Descriptor as parameter.
     * Creates a new descriptor initialized to the values of the
     * descriptor passed in parameter.
     *
     * @param inDescr the descriptor to be used to initialize the
     * constructed descriptor. If it is null or contains no descriptor
     * fields, an empty Descriptor will be created.
     */
<span class="nc" id="L220">    public DescriptorSupport(DescriptorSupport inDescr) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L222">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L223">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(Descriptor)&quot;, &quot;Constructor&quot;);
        }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (inDescr == null)</span>
<span class="nc" id="L227">            init(null);</span>
        else
<span class="nc" id="L229">            init(inDescr.descriptorMap);</span>
<span class="nc" id="L230">    }</span>


    /**
     * &lt;p&gt;Descriptor constructor taking an XML String.&lt;/p&gt;
     *
     * &lt;p&gt;The format of the XML string is not defined, but an
     * implementation must ensure that the string returned by
     * {@link #toXMLString() toXMLString()} on an existing
     * descriptor can be used to instantiate an equivalent
     * descriptor using this constructor.&lt;/p&gt;
     *
     * &lt;p&gt;In this implementation, all field values will be created
     * as Strings.  If the field values are not Strings, the
     * programmer will have to reset or convert these fields
     * correctly.&lt;/p&gt;
     *
     * @param inStr An XML-formatted string used to populate this
     * Descriptor.  The format is not defined, but any
     * implementation must ensure that the string returned by
     * method {@link #toXMLString toXMLString} on an existing
     * descriptor can be used to instantiate an equivalent
     * descriptor when instantiated using this constructor.
     *
     * @exception RuntimeOperationsException If the String inStr
     * passed in parameter is null
     * @exception XMLParseException XML parsing problem while parsing
     * the input String
     * @exception MBeanException Wraps a distributed communication Exception.
     */
    /* At some stage we should rewrite this code to be cleverer.  Using
       a StringTokenizer as we do means, first, that we accept a lot of
       bogus strings without noticing they are bogus, and second, that we
       split the string being parsed at characters like &gt; even if they
       occur in the middle of a field value. */
    public DescriptorSupport(String inStr)
            throws MBeanException, RuntimeOperationsException,
<span class="nc" id="L267">                   XMLParseException {</span>
        /* parse an XML-formatted string and populate internal
         * structure with it */
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L271">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L272">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(String = '&quot; + inStr + &quot;')&quot;, &quot;Constructor&quot;);
        }
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (inStr == null) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L277">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L278">                        DescriptorSupport.class.getName(),</span>
                        &quot;Descriptor(String = null)&quot;, &quot;Illegal arguments&quot;);
            }
            final String msg = &quot;String in parameter is null&quot;;
<span class="nc" id="L282">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L283">            throw new RuntimeOperationsException(iae, msg);</span>
        }

<span class="nc" id="L286">        final String lowerInStr = inStr.toLowerCase();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (!lowerInStr.startsWith(&quot;&lt;descriptor&gt;&quot;)</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            || !lowerInStr.endsWith(&quot;&lt;/descriptor&gt;&quot;)) {</span>
<span class="nc" id="L289">            throw new XMLParseException(&quot;No &lt;descriptor&gt;, &lt;/descriptor&gt; pair&quot;);</span>
        }

        // parse xmlstring into structures
<span class="nc" id="L293">        init(null);</span>
        // create dummy descriptor: should have same size
        // as number of fields in xmlstring
        // loop through structures and put them in descriptor

<span class="nc" id="L298">        StringTokenizer st = new StringTokenizer(inStr, &quot;&lt;&gt; \t\n\r\f&quot;);</span>

<span class="nc" id="L300">        boolean inFld = false;</span>
<span class="nc" id="L301">        boolean inDesc = false;</span>
<span class="nc" id="L302">        String fieldName = null;</span>
<span class="nc" id="L303">        String fieldValue = null;</span>


<span class="nc bnc" id="L306" title="All 2 branches missed.">        while (st.hasMoreTokens()) {  // loop through tokens</span>
<span class="nc" id="L307">            String tok = st.nextToken();</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (tok.equalsIgnoreCase(&quot;FIELD&quot;)) {</span>
<span class="nc" id="L310">                inFld = true;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            } else if (tok.equalsIgnoreCase(&quot;/FIELD&quot;)) {</span>
<span class="nc bnc" id="L312" title="All 4 branches missed.">                if ((fieldName != null) &amp;&amp; (fieldValue != null)) {</span>
<span class="nc" id="L313">                    fieldName =</span>
<span class="nc" id="L314">                        fieldName.substring(fieldName.indexOf('&quot;') + 1,</span>
<span class="nc" id="L315">                                            fieldName.lastIndexOf('&quot;'));</span>
<span class="nc" id="L316">                    final Object fieldValueObject =</span>
<span class="nc" id="L317">                        parseQuotedFieldValue(fieldValue);</span>
<span class="nc" id="L318">                    setField(fieldName, fieldValueObject);</span>
                }
<span class="nc" id="L320">                fieldName = null;</span>
<span class="nc" id="L321">                fieldValue = null;</span>
<span class="nc" id="L322">                inFld = false;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            } else if (tok.equalsIgnoreCase(&quot;DESCRIPTOR&quot;)) {</span>
<span class="nc" id="L324">                inDesc = true;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            } else if (tok.equalsIgnoreCase(&quot;/DESCRIPTOR&quot;)) {</span>
<span class="nc" id="L326">                inDesc = false;</span>
<span class="nc" id="L327">                fieldName = null;</span>
<span class="nc" id="L328">                fieldValue = null;</span>
<span class="nc" id="L329">                inFld = false;</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">            } else if (inFld &amp;&amp; inDesc) {</span>
                // want kw=value, eg, name=&quot;myname&quot; value=&quot;myvalue&quot;
<span class="nc" id="L332">                int eq_separator = tok.indexOf(&quot;=&quot;);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (eq_separator &gt; 0) {</span>
<span class="nc" id="L334">                    String kwPart = tok.substring(0,eq_separator);</span>
<span class="nc" id="L335">                    String valPart = tok.substring(eq_separator+1);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (kwPart.equalsIgnoreCase(&quot;NAME&quot;))</span>
<span class="nc" id="L337">                        fieldName = valPart;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                    else if (kwPart.equalsIgnoreCase(&quot;VALUE&quot;))</span>
<span class="nc" id="L339">                        fieldValue = valPart;</span>
                    else {  // xml parse exception
<span class="nc" id="L341">                        final String msg =</span>
                            &quot;Expected `name' or `value', got `&quot; + tok + &quot;'&quot;;
<span class="nc" id="L343">                        throw new XMLParseException(msg);</span>
                    }
<span class="nc" id="L345">                } else { // xml parse exception</span>
<span class="nc" id="L346">                    final String msg =</span>
                        &quot;Expected `keyword=value', got `&quot; + tok + &quot;'&quot;;
<span class="nc" id="L348">                    throw new XMLParseException(msg);</span>
                }
            }
<span class="nc" id="L351">        }  // while tokens</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L353">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L354">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(XMLString)&quot;, &quot;Exit&quot;);
        }
<span class="nc" id="L357">    }</span>

    /**
     * Constructor taking field names and field values.  Neither array
     * can be null.
     *
     * @param fieldNames String array of field names.  No elements of
     * this array can be null.
     * @param fieldValues Object array of the corresponding field
     * values.  Elements of the array can be null. The
     * &lt;code&gt;fieldValue&lt;/code&gt; must be valid for the
     * &lt;code&gt;fieldName&lt;/code&gt; (as defined in method {@link #isValid
     * isValid})
     *
     * &lt;p&gt;Note: array sizes of parameters should match. If both arrays
     * are empty, then an empty descriptor is created.&lt;/p&gt;
     *
     * @exception RuntimeOperationsException for illegal value for
     * field Names or field Values.  The array lengths must be equal.
     * If the descriptor construction fails for any reason, this
     * exception will be thrown.
     *
     */
    public DescriptorSupport(String[] fieldNames, Object[] fieldValues)
<span class="nc" id="L381">            throws RuntimeOperationsException {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L383">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L384">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(fieldNames,fieldObjects)&quot;, &quot;Constructor&quot;);
        }

<span class="nc bnc" id="L388" title="All 6 branches missed.">        if ((fieldNames == null) || (fieldValues == null) ||</span>
            (fieldNames.length != fieldValues.length)) {
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L391">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L392">                        DescriptorSupport.class.getName(),</span>
                        &quot;Descriptor(fieldNames,fieldObjects)&quot;,
                        &quot;Illegal arguments&quot;);
            }

            final String msg =
                &quot;Null or invalid fieldNames or fieldValues&quot;;
<span class="nc" id="L399">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L400">            throw new RuntimeOperationsException(iae, msg);</span>
        }

        /* populate internal structure with fields */
<span class="nc" id="L404">        init(null);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int i=0; i &lt; fieldNames.length; i++) {</span>
            // setField will throw an exception if a fieldName is be null.
            // the fieldName and fieldValue will be validated in setField.
<span class="nc" id="L408">            setField(fieldNames[i], fieldValues[i]);</span>
        }
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L411">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L412">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(fieldNames,fieldObjects)&quot;, &quot;Exit&quot;);
        }
<span class="nc" id="L415">    }</span>

    /**
     * Constructor taking fields in the &lt;i&gt;fieldName=fieldValue&lt;/i&gt;
     * format.
     *
     * @param fields String array with each element containing a
     * field name and value.  If this array is null or empty, then the
     * default constructor will be executed. Null strings or empty
     * strings will be ignored.
     *
     * &lt;p&gt;All field values should be Strings.  If the field values are
     * not Strings, the programmer will have to reset or convert these
     * fields correctly.
     *
     * &lt;p&gt;Note: Each string should be of the form
     * &lt;i&gt;fieldName=fieldValue&lt;/i&gt;.  The field name
     * ends at the first {@code =} character; for example if the String
     * is {@code a=b=c} then the field name is {@code a} and its value
     * is {@code b=c}.
     *
     * @exception RuntimeOperationsException for illegal value for
     * field Names or field Values.  The field must contain an
     * &quot;=&quot;. &quot;=fieldValue&quot;, &quot;fieldName&quot;, and &quot;fieldValue&quot; are illegal.
     * FieldName cannot be null.  &quot;fieldName=&quot; will cause the value to
     * be null.  If the descriptor construction fails for any reason,
     * this exception will be thrown.
     *
     */
    public DescriptorSupport(String... fields)
<span class="nc" id="L445">    {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L447">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L448">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(String... fields)&quot;, &quot;Constructor&quot;);
        }
<span class="nc" id="L451">        init(null);</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">        if (( fields == null ) || ( fields.length == 0))</span>
<span class="nc" id="L453">            return;</span>

<span class="nc" id="L455">        init(null);</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">        for (int i=0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">            if ((fields[i] == null) || (fields[i].equals(&quot;&quot;))) {</span>
<span class="nc" id="L459">                continue;</span>
            }
<span class="nc" id="L461">            int eq_separator = fields[i].indexOf(&quot;=&quot;);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (eq_separator &lt; 0) {</span>
                // illegal if no = or is first character
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L465">                    MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L466">                            DescriptorSupport.class.getName(),</span>
                            &quot;Descriptor(String... fields)&quot;,
                            &quot;Illegal arguments: field does not have &quot; +
                            &quot;'=' as a name and value separator&quot;);
                }
                final String msg = &quot;Field in invalid format: no equals sign&quot;;
<span class="nc" id="L472">                final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L473">                throw new RuntimeOperationsException(iae, msg);</span>
            }

<span class="nc" id="L476">            String fieldName = fields[i].substring(0,eq_separator);</span>
<span class="nc" id="L477">            String fieldValue = null;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (eq_separator &lt; fields[i].length()) {</span>
                // = is not in last character
<span class="nc" id="L480">                fieldValue = fields[i].substring(eq_separator+1);</span>
            }

<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (fieldName.equals(&quot;&quot;)) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L485">                    MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L486">                            DescriptorSupport.class.getName(),</span>
                            &quot;Descriptor(String... fields)&quot;,
                            &quot;Illegal arguments: fieldName is empty&quot;);
                }

                final String msg = &quot;Field in invalid format: no fieldName&quot;;
<span class="nc" id="L492">                final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L493">                throw new RuntimeOperationsException(iae, msg);</span>
            }

<span class="nc" id="L496">            setField(fieldName,fieldValue);</span>
        }
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L499">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L500">                    DescriptorSupport.class.getName(),</span>
                    &quot;Descriptor(String... fields)&quot;, &quot;Exit&quot;);
        }
<span class="nc" id="L503">    }</span>

    private void init(Map&lt;String, ?&gt; initMap) {
<span class="nc" id="L506">        descriptorMap =</span>
                new TreeMap&lt;String, Object&gt;(String.CASE_INSENSITIVE_ORDER);
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (initMap != null)</span>
<span class="nc" id="L509">            descriptorMap.putAll(initMap);</span>
<span class="nc" id="L510">    }</span>

    // Implementation of the Descriptor interface


    public synchronized Object getFieldValue(String fieldName)
            throws RuntimeOperationsException {

<span class="nc bnc" id="L518" title="All 4 branches missed.">        if ((fieldName == null) || (fieldName.equals(&quot;&quot;))) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L520">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L521">                        DescriptorSupport.class.getName(),</span>
                        &quot;getFieldValue(String fieldName)&quot;,
                        &quot;Illegal arguments: null field name&quot;);
            }
            final String msg = &quot;Fieldname requested is null&quot;;
<span class="nc" id="L526">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L527">            throw new RuntimeOperationsException(iae, msg);</span>
        }
<span class="nc" id="L529">        Object retValue = descriptorMap.get(fieldName);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L531">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L532">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldValue(String fieldName = &quot; + fieldName + &quot;)&quot;,
                    &quot;Returns '&quot; + retValue + &quot;'&quot;);
        }
<span class="nc" id="L536">        return(retValue);</span>
    }

    public synchronized void setField(String fieldName, Object fieldValue)
            throws RuntimeOperationsException {

        // field name cannot be null or empty
<span class="nc bnc" id="L543" title="All 4 branches missed.">        if ((fieldName == null) || (fieldName.equals(&quot;&quot;))) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L545">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L546">                        DescriptorSupport.class.getName(),</span>
                        &quot;setField(fieldName,fieldValue)&quot;,
                        &quot;Illegal arguments: null or empty field name&quot;);
            }

            final String msg = &quot;Field name to be set is null or empty&quot;;
<span class="nc" id="L552">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L553">            throw new RuntimeOperationsException(iae, msg);</span>
        }

<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (!validateField(fieldName, fieldValue)) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L558">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L559">                        DescriptorSupport.class.getName(),</span>
                        &quot;setField(fieldName,fieldValue)&quot;,
                        &quot;Illegal arguments&quot;);
            }

<span class="nc" id="L564">            final String msg =</span>
                &quot;Field value invalid: &quot; + fieldName + &quot;=&quot; + fieldValue;
<span class="nc" id="L566">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L567">            throw new RuntimeOperationsException(iae, msg);</span>
        }

<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L571">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L572">                    DescriptorSupport.class.getName(),</span>
                    &quot;setField(fieldName,fieldValue)&quot;, &quot;Entry: setting '&quot;
                    + fieldName + &quot;' to '&quot; + fieldValue + &quot;'&quot;);
        }

        // Since we do not remove any existing entry with this name,
        // the field will preserve whatever case it had, ignoring
        // any difference there might be in fieldName.
<span class="nc" id="L580">        descriptorMap.put(fieldName, fieldValue);</span>
<span class="nc" id="L581">    }</span>

    public synchronized String[] getFields() {
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L585">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L586">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFields()&quot;, &quot;Entry&quot;);
        }
<span class="nc" id="L589">        int numberOfEntries = descriptorMap.size();</span>

<span class="nc" id="L591">        String[] responseFields = new String[numberOfEntries];</span>
<span class="nc" id="L592">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; returnedSet = descriptorMap.entrySet();</span>

<span class="nc" id="L594">        int i = 0;</span>

<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L597">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L598">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFields()&quot;, &quot;Returning &quot; + numberOfEntries + &quot; fields&quot;);
        }
<span class="nc" id="L601">        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iter = returnedSet.iterator();</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">             iter.hasNext(); i++) {</span>
<span class="nc" id="L603">            Map.Entry&lt;String, Object&gt; currElement = iter.next();</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">            if (currElement == null) {</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L607">                    MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L608">                            DescriptorSupport.class.getName(),</span>
                            &quot;getFields()&quot;, &quot;Element is null&quot;);
                }
            } else {
<span class="nc" id="L612">                Object currValue = currElement.getValue();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                if (currValue == null) {</span>
<span class="nc" id="L614">                    responseFields[i] = currElement.getKey() + &quot;=&quot;;</span>
                } else {
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    if (currValue instanceof java.lang.String) {</span>
<span class="nc" id="L617">                        responseFields[i] =</span>
<span class="nc" id="L618">                            currElement.getKey() + &quot;=&quot; + currValue.toString();</span>
                    } else {
<span class="nc" id="L620">                        responseFields[i] =</span>
<span class="nc" id="L621">                            currElement.getKey() + &quot;=(&quot; +</span>
<span class="nc" id="L622">                            currValue.toString() + &quot;)&quot;;</span>
                    }
                }
            }
        }

<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L629">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L630">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFields()&quot;, &quot;Exit&quot;);
        }

<span class="nc" id="L634">        return responseFields;</span>
    }

    public synchronized String[] getFieldNames() {
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L639">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L640">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldNames()&quot;, &quot;Entry&quot;);
        }
<span class="nc" id="L643">        int numberOfEntries = descriptorMap.size();</span>

<span class="nc" id="L645">        String[] responseFields = new String[numberOfEntries];</span>
<span class="nc" id="L646">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; returnedSet = descriptorMap.entrySet();</span>

<span class="nc" id="L648">        int i = 0;</span>

<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L651">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L652">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldNames()&quot;,
                    &quot;Returning &quot; + numberOfEntries + &quot; fields&quot;);
        }

<span class="nc" id="L657">        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iter = returnedSet.iterator();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">             iter.hasNext(); i++) {</span>
<span class="nc" id="L659">            Map.Entry&lt;String, Object&gt; currElement = iter.next();</span>

<span class="nc bnc" id="L661" title="All 4 branches missed.">            if (( currElement == null ) || (currElement.getKey() == null)) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L663">                    MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L664">                            DescriptorSupport.class.getName(),</span>
                            &quot;getFieldNames()&quot;, &quot;Field is null&quot;);
                }
            } else {
<span class="nc" id="L668">                responseFields[i] = currElement.getKey().toString();</span>
            }
        }

<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L673">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L674">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldNames()&quot;, &quot;Exit&quot;);
        }

<span class="nc" id="L678">        return responseFields;</span>
    }


    public synchronized Object[] getFieldValues(String... fieldNames) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L684">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L685">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldValues(String... fieldNames)&quot;, &quot;Entry&quot;);
        }
        // if fieldNames == null return all values
        // if fieldNames is String[0] return no values

<span class="nc bnc" id="L691" title="All 2 branches missed.">        final int numberOfEntries =</span>
<span class="nc" id="L692">            (fieldNames == null) ? descriptorMap.size() : fieldNames.length;</span>
<span class="nc" id="L693">        final Object[] responseFields = new Object[numberOfEntries];</span>

<span class="nc" id="L695">        int i = 0;</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L698">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L699">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldValues(String... fieldNames)&quot;,
                    &quot;Returning &quot; + numberOfEntries + &quot; fields&quot;);
        }

<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (fieldNames == null) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">            for (Object value : descriptorMap.values())</span>
<span class="nc" id="L706">                responseFields[i++] = value;</span>
        } else {
<span class="nc bnc" id="L708" title="All 2 branches missed.">            for (i=0; i &lt; fieldNames.length; i++) {</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">                if ((fieldNames[i] == null) || (fieldNames[i].equals(&quot;&quot;))) {</span>
<span class="nc" id="L710">                    responseFields[i] = null;</span>
                } else {
<span class="nc" id="L712">                    responseFields[i] = getFieldValue(fieldNames[i]);</span>
                }
            }
        }

<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L718">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L719">                    DescriptorSupport.class.getName(),</span>
                    &quot;getFieldValues(String... fieldNames)&quot;, &quot;Exit&quot;);
        }

<span class="nc" id="L723">        return responseFields;</span>
    }

    public synchronized void setFields(String[] fieldNames,
                                       Object[] fieldValues)
            throws RuntimeOperationsException {

<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L731">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L732">                    DescriptorSupport.class.getName(),</span>
                    &quot;setFields(fieldNames,fieldValues)&quot;, &quot;Entry&quot;);
        }

<span class="nc bnc" id="L736" title="All 6 branches missed.">        if ((fieldNames == null) || (fieldValues == null) ||</span>
            (fieldNames.length != fieldValues.length)) {
<span class="nc bnc" id="L738" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L739">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L740">                        DescriptorSupport.class.getName(),</span>
                        &quot;setFields(fieldNames,fieldValues)&quot;,
                        &quot;Illegal arguments&quot;);
            }

            final String msg = &quot;fieldNames and fieldValues are null or invalid&quot;;
<span class="nc" id="L746">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L747">            throw new RuntimeOperationsException(iae, msg);</span>
        }

<span class="nc bnc" id="L750" title="All 2 branches missed.">        for (int i=0; i &lt; fieldNames.length; i++) {</span>
<span class="nc bnc" id="L751" title="All 4 branches missed.">            if (( fieldNames[i] == null) || (fieldNames[i].equals(&quot;&quot;))) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L753">                    MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L754">                            DescriptorSupport.class.getName(),</span>
                            &quot;setFields(fieldNames,fieldValues)&quot;,
                            &quot;Null field name encountered at element &quot; + i);
                }
                final String msg = &quot;fieldNames is null or invalid&quot;;
<span class="nc" id="L759">                final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L760">                throw new RuntimeOperationsException(iae, msg);</span>
            }
<span class="nc" id="L762">            setField(fieldNames[i], fieldValues[i]);</span>
        }
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L765">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L766">                    DescriptorSupport.class.getName(),</span>
                    &quot;setFields(fieldNames,fieldValues)&quot;, &quot;Exit&quot;);
        }
<span class="nc" id="L769">    }</span>

    /**
     * Returns a new Descriptor which is a duplicate of the Descriptor.
     *
     * @exception RuntimeOperationsException for illegal value for
     * field Names or field Values.  If the descriptor construction
     * fails for any reason, this exception will be thrown.
     */

    @Override
    public synchronized Object clone() throws RuntimeOperationsException {
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L782">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L783">                    DescriptorSupport.class.getName(),</span>
                    &quot;clone()&quot;, &quot;Entry&quot;);
        }
<span class="nc" id="L786">        return(new DescriptorSupport(this));</span>
    }

    public synchronized void removeField(String fieldName) {
<span class="nc bnc" id="L790" title="All 4 branches missed.">        if ((fieldName == null) || (fieldName.equals(&quot;&quot;))) {</span>
<span class="nc" id="L791">            return;</span>
        }

<span class="nc" id="L794">        descriptorMap.remove(fieldName);</span>
<span class="nc" id="L795">    }</span>

    /**
     * Compares this descriptor to the given object.  The objects are equal if
     * the given object is also a Descriptor, and if the two Descriptors have
     * the same field names (possibly differing in case) and the same
     * associated values.  The respective values for a field in the two
     * Descriptors are equal if the following conditions hold:
     *
     * &lt;ul&gt;
     * &lt;li&gt;If one value is null then the other must be too.&lt;/li&gt;
     * &lt;li&gt;If one value is a primitive array then the other must be a primitive
     * array of the same type with the same elements.&lt;/li&gt;
     * &lt;li&gt;If one value is an object array then the other must be too and
     * {@link java.util.Arrays#deepEquals(Object[],Object[]) Arrays.deepEquals}
     * must return true.&lt;/li&gt;
     * &lt;li&gt;Otherwise {@link Object#equals(Object)} must return true.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param o the object to compare with.
     *
     * @return {@code true} if the objects are the same; {@code false}
     * otherwise.
     *
     */
    // Note: this Javadoc is copied from javax.management.Descriptor
    //       due to 6369229.
    @Override
    public synchronized boolean equals(Object o) {
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (o == this)</span>
<span class="nc" id="L825">            return true;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        if (! (o instanceof Descriptor))</span>
<span class="nc" id="L827">            return false;</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (o instanceof ImmutableDescriptor)</span>
<span class="nc" id="L829">            return o.equals(this);</span>
<span class="nc" id="L830">        return new ImmutableDescriptor(descriptorMap).equals(o);</span>
    }

    /**
     * &lt;p&gt;Returns the hash code value for this descriptor.  The hash
     * code is computed as the sum of the hash codes for each field in
     * the descriptor.  The hash code of a field with name {@code n}
     * and value {@code v} is {@code n.toLowerCase().hashCode() ^ h}.
     * Here {@code h} is the hash code of {@code v}, computed as
     * follows:&lt;/p&gt;
     *
     * &lt;ul&gt;
     * &lt;li&gt;If {@code v} is null then {@code h} is 0.&lt;/li&gt;
     * &lt;li&gt;If {@code v} is a primitive array then {@code h} is computed using
     * the appropriate overloading of {@code java.util.Arrays.hashCode}.&lt;/li&gt;
     * &lt;li&gt;If {@code v} is an object array then {@code h} is computed using
     * {@link java.util.Arrays#deepHashCode(Object[]) Arrays.deepHashCode}.&lt;/li&gt;
     * &lt;li&gt;Otherwise {@code h} is {@code v.hashCode()}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return A hash code value for this object.
     *
     */
    // Note: this Javadoc is copied from javax.management.Descriptor
    //       due to 6369229.
    @Override
    public synchronized int hashCode() {
<span class="nc" id="L857">        final int size = descriptorMap.size();</span>
        // descriptorMap is sorted with a comparator that ignores cases.
        //
<span class="nc" id="L860">        return Util.hashCode(</span>
<span class="nc" id="L861">                descriptorMap.keySet().toArray(new String[size]),</span>
<span class="nc" id="L862">                descriptorMap.values().toArray(new Object[size]));</span>
    }

    /**
     * Returns true if all of the fields have legal values given their
     * names.
     * &lt;P&gt;
     * This implementation does not support  interoperating with a directory
     * or lookup service. Thus, conforming to the specification, no checking is
     * done on the &lt;i&gt;&quot;export&quot;&lt;/i&gt; field.
     * &lt;P&gt;
     * Otherwise this implementation returns false if:
     * &lt;UL&gt;
     * &lt;LI&gt; name and descriptorType fieldNames are not defined, or
     * null, or empty, or not String
     * &lt;LI&gt; class, role, getMethod, setMethod fieldNames, if defined,
     * are null or not String
     * &lt;LI&gt; persistPeriod, currencyTimeLimit, lastUpdatedTimeStamp,
     * lastReturnedTimeStamp if defined, are null, or not a Numeric
     * String or not a Numeric Value {@literal &gt;= -1}
     * &lt;LI&gt; log fieldName, if defined, is null, or not a Boolean or
     * not a String with value &quot;t&quot;, &quot;f&quot;, &quot;true&quot;, &quot;false&quot;. These String
     * values must not be case sensitive.
     * &lt;LI&gt; visibility fieldName, if defined, is null, or not a
     * Numeric String or a not Numeric Value {@literal &gt;= 1 and &lt;= 4}
     * &lt;LI&gt; severity fieldName, if defined, is null, or not a Numeric
     * String or not a Numeric Value {@literal &gt;= 0 and &lt;= 6}&lt;br&gt;
     * &lt;LI&gt; persistPolicy fieldName, if defined, is null, or not one of
     * the following strings:&lt;br&gt;
     *   &quot;OnUpdate&quot;, &quot;OnTimer&quot;, &quot;NoMoreOftenThan&quot;, &quot;OnUnregister&quot;, &quot;Always&quot;,
     *   &quot;Never&quot;. These String values must not be case sensitive.&lt;br&gt;
     * &lt;/UL&gt;
     *
     * @exception RuntimeOperationsException If the validity checking
     * fails for any reason, this exception will be thrown.
     */

    public synchronized boolean isValid() throws RuntimeOperationsException {
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L901">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L902">                    DescriptorSupport.class.getName(),</span>
                    &quot;isValid()&quot;, &quot;Entry&quot;);
        }
        // verify that the descriptor is valid, by iterating over each field...

<span class="nc" id="L907">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; returnedSet = descriptorMap.entrySet();</span>

<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (returnedSet == null) {   // null descriptor, not valid</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L911">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L912">                        DescriptorSupport.class.getName(),</span>
                        &quot;isValid()&quot;, &quot;Returns false (null set)&quot;);
            }
<span class="nc" id="L915">            return false;</span>
        }
        // must have a name and descriptor type field
<span class="nc" id="L918">        String thisName = (String)(this.getFieldValue(&quot;name&quot;));</span>
<span class="nc" id="L919">        String thisDescType = (String)(getFieldValue(&quot;descriptorType&quot;));</span>

<span class="nc bnc" id="L921" title="All 4 branches missed.">        if ((thisName == null) || (thisDescType == null) ||</span>
<span class="nc bnc" id="L922" title="All 4 branches missed.">            (thisName.equals(&quot;&quot;)) || (thisDescType.equals(&quot;&quot;))) {</span>
<span class="nc" id="L923">            return false;</span>
        }

        // According to the descriptor type we validate the fields contained

<span class="nc bnc" id="L928" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; currElement : returnedSet) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (currElement != null) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (currElement.getValue() != null) {</span>
                    // validate the field valued...
<span class="nc bnc" id="L932" title="All 2 branches missed.">                    if (validateField((currElement.getKey()).toString(),</span>
<span class="nc" id="L933">                                      (currElement.getValue()).toString())) {</span>
<span class="nc" id="L934">                        continue;</span>
                    } else {
<span class="nc bnc" id="L936" title="All 2 branches missed.">                        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L937">                            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L938">                                    DescriptorSupport.class.getName(),</span>
                                    &quot;isValid()&quot;,
<span class="nc" id="L940">                                    &quot;Field &quot; + currElement.getKey() + &quot;=&quot; +</span>
<span class="nc" id="L941">                                    currElement.getValue() + &quot; is not valid&quot;);</span>
                        }
<span class="nc" id="L943">                        return false;</span>
                    }
                }
            }
<span class="nc" id="L947">        }</span>

        // fell through, all fields OK
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L951">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L952">                    DescriptorSupport.class.getName(),</span>
                    &quot;isValid()&quot;, &quot;Returns true&quot;);
        }
<span class="nc" id="L955">        return true;</span>
    }


    // worker routine for isValid()
    // name is not null
    // descriptorType is not null
    // getMethod and setMethod are not null
    // persistPeriod is numeric
    // currencyTimeLimit is numeric
    // lastUpdatedTimeStamp is numeric
    // visibility is 1-4
    // severity is 0-6
    // log is T or F
    // role is not null
    // class is not null
    // lastReturnedTimeStamp is numeric


    private boolean validateField(String fldName, Object fldValue) {
<span class="nc bnc" id="L975" title="All 4 branches missed.">        if ((fldName == null) || (fldName.equals(&quot;&quot;)))</span>
<span class="nc" id="L976">            return false;</span>
<span class="nc" id="L977">        String SfldValue = &quot;&quot;;</span>
<span class="nc" id="L978">        boolean isAString = false;</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">        if ((fldValue != null) &amp;&amp; (fldValue instanceof java.lang.String)) {</span>
<span class="nc" id="L980">            SfldValue = (String) fldValue;</span>
<span class="nc" id="L981">            isAString = true;</span>
        }

<span class="nc" id="L984">        boolean nameOrDescriptorType =</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">            (fldName.equalsIgnoreCase(&quot;Name&quot;) ||</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">             fldName.equalsIgnoreCase(&quot;DescriptorType&quot;));</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (nameOrDescriptorType ||</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">            fldName.equalsIgnoreCase(&quot;SetMethod&quot;) ||</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">            fldName.equalsIgnoreCase(&quot;GetMethod&quot;) ||</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            fldName.equalsIgnoreCase(&quot;Role&quot;) ||</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">            fldName.equalsIgnoreCase(&quot;Class&quot;)) {</span>
<span class="nc bnc" id="L992" title="All 4 branches missed.">            if (fldValue == null || !isAString)</span>
<span class="nc" id="L993">                return false;</span>
<span class="nc bnc" id="L994" title="All 4 branches missed.">            if (nameOrDescriptorType &amp;&amp; SfldValue.equals(&quot;&quot;))</span>
<span class="nc" id="L995">                return false;</span>
<span class="nc" id="L996">            return true;</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">        } else if (fldName.equalsIgnoreCase(&quot;visibility&quot;)) {</span>
            long v;
<span class="nc bnc" id="L999" title="All 4 branches missed.">            if ((fldValue != null) &amp;&amp; (isAString)) {</span>
<span class="nc" id="L1000">                v = toNumeric(SfldValue);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            } else if (fldValue instanceof java.lang.Integer) {</span>
<span class="nc" id="L1002">                v = ((Integer)fldValue).intValue();</span>
<span class="nc" id="L1003">            } else return false;</span>

<span class="nc bnc" id="L1005" title="All 4 branches missed.">            if (v &gt;= 1 &amp;&amp;  v &lt;= 4)</span>
<span class="nc" id="L1006">                return true;</span>
            else
<span class="nc" id="L1008">                return false;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        } else if (fldName.equalsIgnoreCase(&quot;severity&quot;)) {</span>

            long v;
<span class="nc bnc" id="L1012" title="All 4 branches missed.">            if ((fldValue != null) &amp;&amp; (isAString)) {</span>
<span class="nc" id="L1013">                v = toNumeric(SfldValue);</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            } else if (fldValue instanceof java.lang.Integer) {</span>
<span class="nc" id="L1015">                v = ((Integer)fldValue).intValue();</span>
<span class="nc" id="L1016">            } else return false;</span>

<span class="nc bnc" id="L1018" title="All 4 branches missed.">            return (v &gt;= 0 &amp;&amp; v &lt;= 6);</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">        } else if (fldName.equalsIgnoreCase(&quot;PersistPolicy&quot;)) {</span>
<span class="nc bnc" id="L1020" title="All 4 branches missed.">            return (((fldValue != null) &amp;&amp; (isAString)) &amp;&amp;</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                    ( SfldValue.equalsIgnoreCase(&quot;OnUpdate&quot;) ||</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;OnTimer&quot;) ||</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;NoMoreOftenThan&quot;) ||</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;Always&quot;) ||</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;Never&quot;) ||</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;OnUnregister&quot;)));</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        } else if (fldName.equalsIgnoreCase(&quot;PersistPeriod&quot;) ||</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                   fldName.equalsIgnoreCase(&quot;CurrencyTimeLimit&quot;) ||</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                   fldName.equalsIgnoreCase(&quot;LastUpdatedTimeStamp&quot;) ||</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                   fldName.equalsIgnoreCase(&quot;LastReturnedTimeStamp&quot;)) {</span>

            long v;
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            if ((fldValue != null) &amp;&amp; (isAString)) {</span>
<span class="nc" id="L1034">                v = toNumeric(SfldValue);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            } else if (fldValue instanceof java.lang.Number) {</span>
<span class="nc" id="L1036">                v = ((Number)fldValue).longValue();</span>
<span class="nc" id="L1037">            } else return false;</span>

<span class="nc bnc" id="L1039" title="All 2 branches missed.">            return (v &gt;= -1);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        } else if (fldName.equalsIgnoreCase(&quot;log&quot;)) {</span>
<span class="nc bnc" id="L1041" title="All 4 branches missed.">            return ((fldValue instanceof java.lang.Boolean) ||</span>
                    (isAString &amp;&amp;
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                     (SfldValue.equalsIgnoreCase(&quot;T&quot;) ||</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;true&quot;) ||</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;F&quot;) ||</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                      SfldValue.equalsIgnoreCase(&quot;false&quot;) )));</span>
        }

        // default to true, it is a field we aren't validating (user etc.)
<span class="nc" id="L1050">        return true;</span>
    }



    /**
     * &lt;p&gt;Returns an XML String representing the descriptor.&lt;/p&gt;
     *
     * &lt;p&gt;The format is not defined, but an implementation must
     * ensure that the string returned by this method can be
     * used to build an equivalent descriptor when instantiated
     * using the constructor {@link #DescriptorSupport(String)
     * DescriptorSupport(String inStr)}.&lt;/p&gt;
     *
     * &lt;p&gt;Fields which are not String objects will have toString()
     * called on them to create the value. The value will be
     * enclosed in parentheses.  It is not guaranteed that you can
     * reconstruct these objects unless they have been
     * specifically set up to support toString() in a meaningful
     * format and have a matching constructor that accepts a
     * String in the same format.&lt;/p&gt;
     *
     * &lt;p&gt;If the descriptor is empty the following String is
     * returned: &amp;lt;Descriptor&amp;gt;&amp;lt;/Descriptor&amp;gt;&lt;/p&gt;
     *
     * @return the XML string.
     *
     * @exception RuntimeOperationsException for illegal value for
     * field Names or field Values.  If the XML formatted string
     * construction fails for any reason, this exception will be
     * thrown.
     */
    public synchronized String toXMLString() {
<span class="nc" id="L1083">        final StringBuilder buf = new StringBuilder(&quot;&lt;Descriptor&gt;&quot;);</span>
<span class="nc" id="L1084">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; returnedSet = descriptorMap.entrySet();</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; currElement : returnedSet) {</span>
<span class="nc" id="L1086">            final String name = currElement.getKey();</span>
<span class="nc" id="L1087">            Object value = currElement.getValue();</span>
<span class="nc" id="L1088">            String valueString = null;</span>
            /* Set valueString to non-null if and only if this is a string that
               cannot be confused with the encoding of an object.  If it
               could be so confused (surrounded by parentheses) then we
               call makeFieldValue as for any non-String object and end
               up with an encoding like &quot;(java.lang.String/(thing))&quot;.  */
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (value instanceof String) {</span>
<span class="nc" id="L1095">                final String svalue = (String) value;</span>
<span class="nc bnc" id="L1096" title="All 4 branches missed.">                if (!svalue.startsWith(&quot;(&quot;) || !svalue.endsWith(&quot;)&quot;))</span>
<span class="nc" id="L1097">                    valueString = quote(svalue);</span>
            }
<span class="nc bnc" id="L1099" title="All 2 branches missed.">            if (valueString == null)</span>
<span class="nc" id="L1100">                valueString = makeFieldValue(value);</span>
<span class="nc" id="L1101">            buf.append(&quot;&lt;field name=\&quot;&quot;).append(name).append(&quot;\&quot; value=\&quot;&quot;)</span>
<span class="nc" id="L1102">                .append(valueString).append(&quot;\&quot;&gt;&lt;/field&gt;&quot;);</span>
<span class="nc" id="L1103">        }</span>
<span class="nc" id="L1104">        buf.append(&quot;&lt;/Descriptor&gt;&quot;);</span>
<span class="nc" id="L1105">        return buf.toString();</span>
    }

<span class="nc" id="L1108">    private static final String[] entities = {</span>
        &quot; &amp;#32;&quot;,
        &quot;\&quot;&amp;quot;&quot;,
        &quot;&lt;&amp;lt;&quot;,
        &quot;&gt;&amp;gt;&quot;,
        &quot;&amp;&amp;amp;&quot;,
        &quot;\r&amp;#13;&quot;,
        &quot;\t&amp;#9;&quot;,
        &quot;\n&amp;#10;&quot;,
        &quot;\f&amp;#12;&quot;,
    };
<span class="nc" id="L1119">    private static final Map&lt;String,Character&gt; entityToCharMap =</span>
        new HashMap&lt;String,Character&gt;();
    private static final String[] charToEntityMap;

    static {
<span class="nc" id="L1124">        char maxChar = 0;</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        for (int i = 0; i &lt; entities.length; i++) {</span>
<span class="nc" id="L1126">            final char c = entities[i].charAt(0);</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            if (c &gt; maxChar)</span>
<span class="nc" id="L1128">                maxChar = c;</span>
        }
<span class="nc" id="L1130">        charToEntityMap = new String[maxChar + 1];</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        for (int i = 0; i &lt; entities.length; i++) {</span>
<span class="nc" id="L1132">            final char c = entities[i].charAt(0);</span>
<span class="nc" id="L1133">            final String entity = entities[i].substring(1);</span>
<span class="nc" id="L1134">            charToEntityMap[c] = entity;</span>
<span class="nc" id="L1135">            entityToCharMap.put(entity, c);</span>
        }
<span class="nc" id="L1137">    }</span>

    private static boolean isMagic(char c) {
<span class="nc bnc" id="L1140" title="All 4 branches missed.">        return (c &lt; charToEntityMap.length &amp;&amp; charToEntityMap[c] != null);</span>
    }

    /*
     * Quote the string so that it will be acceptable to the (String)
     * constructor.  Since the parsing code in that constructor is fairly
     * stupid, we're obliged to quote apparently innocuous characters like
     * space, &lt;, and &gt;.  In a future version, we should rewrite the parser
     * and only quote &quot; plus either \ or &amp; (depending on the quote syntax).
     */
    private static String quote(String s) {
<span class="nc" id="L1151">        boolean found = false;</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            if (isMagic(s.charAt(i))) {</span>
<span class="nc" id="L1154">                found = true;</span>
<span class="nc" id="L1155">                break;</span>
            }
        }
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        if (!found)</span>
<span class="nc" id="L1159">            return s;</span>
<span class="nc" id="L1160">        final StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="nc" id="L1162">            char c = s.charAt(i);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if (isMagic(c))</span>
<span class="nc" id="L1164">                buf.append(charToEntityMap[c]);</span>
            else
<span class="nc" id="L1166">                buf.append(c);</span>
        }
<span class="nc" id="L1168">        return buf.toString();</span>
    }

    private static String unquote(String s) throws XMLParseException {
<span class="nc bnc" id="L1172" title="All 4 branches missed.">        if (!s.startsWith(&quot;\&quot;&quot;) || !s.endsWith(&quot;\&quot;&quot;))</span>
<span class="nc" id="L1173">            throw new XMLParseException(&quot;Value must be quoted: &lt;&quot; + s + &quot;&gt;&quot;);</span>
<span class="nc" id="L1174">        final StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L1175">        final int len = s.length() - 1;</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        for (int i = 1; i &lt; len; i++) {</span>
<span class="nc" id="L1177">            final char c = s.charAt(i);</span>
            final int semi;
            final Character quoted;
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            if (c == '&amp;'</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">                &amp;&amp; (semi = s.indexOf(';', i + 1)) &gt;= 0</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                &amp;&amp; ((quoted = entityToCharMap.get(s.substring(i, semi+1)))</span>
                    != null)) {
<span class="nc" id="L1184">                buf.append(quoted);</span>
<span class="nc" id="L1185">                i = semi;</span>
            } else
<span class="nc" id="L1187">                buf.append(c);</span>
        }
<span class="nc" id="L1189">        return buf.toString();</span>
    }

    /**
     * Make the string that will go inside &quot;...&quot; for a value that is not
     * a plain String.
     * @throws RuntimeOperationsException if the value cannot be encoded.
     */
    private static String makeFieldValue(Object value) {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L1199">            return &quot;(null)&quot;;</span>

<span class="nc" id="L1201">        Class&lt;?&gt; valueClass = value.getClass();</span>
        try {
<span class="nc" id="L1203">            valueClass.getConstructor(String.class);</span>
<span class="nc" id="L1204">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L1205">            final String msg =</span>
                &quot;Class &quot; + valueClass + &quot; does not have a public &quot; +
                &quot;constructor with a single string arg&quot;;
<span class="nc" id="L1208">            final RuntimeException iae = new IllegalArgumentException(msg);</span>
<span class="nc" id="L1209">            throw new RuntimeOperationsException(iae,</span>
                                                 &quot;Cannot make XML descriptor&quot;);
<span class="nc" id="L1211">        } catch (SecurityException e) {</span>
            // OK: we'll pretend the constructor is there
            // too bad if it's not: we'll find out when we try to
            // reconstruct the DescriptorSupport
<span class="nc" id="L1215">        }</span>

<span class="nc" id="L1217">        final String quotedValueString = quote(value.toString());</span>

<span class="nc" id="L1219">        return &quot;(&quot; + valueClass.getName() + &quot;/&quot; + quotedValueString + &quot;)&quot;;</span>
    }

    /*
     * Parse a field value from the XML produced by toXMLString().
     * Given a descriptor XML containing &lt;field name=&quot;nnn&quot; value=&quot;vvv&quot;&gt;,
     * the argument to this method will be &quot;vvv&quot; (a string including the
     * containing quote characters).  If vvv begins and ends with parentheses,
     * then it may contain:
     * - the characters &quot;null&quot;, in which case the result is null;
     * - a value of the form &quot;some.class.name/xxx&quot;, in which case the
     * result is equivalent to `new some.class.name(&quot;xxx&quot;)';
     * - some other string, in which case the result is that string,
     * without the parentheses.
     */
    private static Object parseQuotedFieldValue(String s)
            throws XMLParseException {
<span class="nc" id="L1236">        s = unquote(s);</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">        if (s.equalsIgnoreCase(&quot;(null)&quot;))</span>
<span class="nc" id="L1238">            return null;</span>
<span class="nc bnc" id="L1239" title="All 4 branches missed.">        if (!s.startsWith(&quot;(&quot;) || !s.endsWith(&quot;)&quot;))</span>
<span class="nc" id="L1240">            return s;</span>
<span class="nc" id="L1241">        final int slash = s.indexOf('/');</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        if (slash &lt; 0) {</span>
            // compatibility: old code didn't include class name
<span class="nc" id="L1244">            return s.substring(1, s.length() - 1);</span>
        }
<span class="nc" id="L1246">        final String className = s.substring(1, slash);</span>

        final Constructor&lt;?&gt; constr;
        try {
<span class="nc" id="L1250">            ReflectUtil.checkPackageAccess(className);</span>
            final ClassLoader contextClassLoader =
<span class="nc" id="L1252">                Thread.currentThread().getContextClassLoader();</span>
<span class="nc" id="L1253">            final Class&lt;?&gt; c =</span>
<span class="nc" id="L1254">                Class.forName(className, false, contextClassLoader);</span>
<span class="nc" id="L1255">            constr = c.getConstructor(new Class&lt;?&gt;[] {String.class});</span>
<span class="nc" id="L1256">        } catch (Exception e) {</span>
<span class="nc" id="L1257">            throw new XMLParseException(e,</span>
                                        &quot;Cannot parse value: &lt;&quot; + s + &quot;&gt;&quot;);
<span class="nc" id="L1259">        }</span>
<span class="nc" id="L1260">        final String arg = s.substring(slash + 1, s.length() - 1);</span>
        try {
<span class="nc" id="L1262">            return constr.newInstance(new Object[] {arg});</span>
<span class="nc" id="L1263">        } catch (Exception e) {</span>
<span class="nc" id="L1264">            final String msg =</span>
                &quot;Cannot construct instance of &quot; + className +
                &quot; with arg: &lt;&quot; + s + &quot;&gt;&quot;;
<span class="nc" id="L1267">            throw new XMLParseException(e, msg);</span>
        }
    }

    /**
     * Returns a human readable string representing the
     * descriptor.  The string will be in the format of
     * &quot;fieldName=fieldValue,fieldName2=fieldValue2,...&quot;&lt;br&gt;
     *
     * If there are no fields in the descriptor, then an empty String
     * is returned.&lt;br&gt;
     *
     * If a fieldValue is an object then the toString() method is
     * called on it and its returned value is used as the value for
     * the field enclosed in parenthesis.
     *
     * @exception RuntimeOperationsException for illegal value for
     * field Names or field Values.  If the descriptor string fails
     * for any reason, this exception will be thrown.
     */
    @Override
    public synchronized String toString() {
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1290">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1291">                    DescriptorSupport.class.getName(),</span>
                    &quot;toString()&quot;, &quot;Entry&quot;);
        }

<span class="nc" id="L1295">        String respStr = &quot;&quot;;</span>
<span class="nc" id="L1296">        String[] fields = getFields();</span>

<span class="nc bnc" id="L1298" title="All 4 branches missed.">        if ((fields == null) || (fields.length == 0)) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1300">                MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1301">                        DescriptorSupport.class.getName(),</span>
                        &quot;toString()&quot;, &quot;Empty Descriptor&quot;);
            }
<span class="nc" id="L1304">            return respStr;</span>
        }

<span class="nc bnc" id="L1307" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1308">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1309">                    DescriptorSupport.class.getName(),</span>
                    &quot;toString()&quot;, &quot;Printing &quot; + fields.length + &quot; fields&quot;);
        }

<span class="nc bnc" id="L1313" title="All 2 branches missed.">        for (int i=0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">            if (i == (fields.length - 1)) {</span>
<span class="nc" id="L1315">                respStr = respStr.concat(fields[i]);</span>
            } else {
<span class="nc" id="L1317">                respStr = respStr.concat(fields[i] + &quot;, &quot;);</span>
            }
        }

<span class="nc bnc" id="L1321" title="All 2 branches missed.">        if (MODELMBEAN_LOGGER.isLoggable(Level.FINEST)) {</span>
<span class="nc" id="L1322">            MODELMBEAN_LOGGER.logp(Level.FINEST,</span>
<span class="nc" id="L1323">                    DescriptorSupport.class.getName(),</span>
                    &quot;toString()&quot;, &quot;Exit returning &quot; + respStr);
        }

<span class="nc" id="L1327">        return respStr;</span>
    }

    // utility to convert to int, returns -2 if bogus.

    private long toNumeric(String inStr) {
        try {
<span class="nc" id="L1334">            return java.lang.Long.parseLong(inStr);</span>
<span class="nc" id="L1335">        } catch (Exception e) {</span>
<span class="nc" id="L1336">            return -2;</span>
        }
    }


    /**
     * Deserializes a {@link DescriptorSupport} from an {@link
     * ObjectInputStream}.
     */
    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L1347">        ObjectInputStream.GetField fields = in.readFields();</span>
<span class="nc" id="L1348">        Map&lt;String, Object&gt; descriptor = cast(fields.get(&quot;descriptor&quot;, null));</span>
<span class="nc" id="L1349">        init(null);</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (descriptor != null) {</span>
<span class="nc" id="L1351">            descriptorMap.putAll(descriptor);</span>
        }
<span class="nc" id="L1353">    }</span>


    /**
     * Serializes a {@link DescriptorSupport} to an {@link ObjectOutputStream}.
     */
    /* If you set jmx.serial.form to &quot;1.2.0&quot; or &quot;1.2.1&quot;, then we are
       bug-compatible with those versions.  Specifically, field names
       are forced to lower-case before being written.  This
       contradicts the spec, which, though it does not mention
       serialization explicitly, does say that the case of field names
       is preserved.  But in 1.2.0 and 1.2.1, this requirement was not
       met.  Instead, field names in the descriptor map were forced to
       lower case.  Those versions expect this to have happened to a
       descriptor they deserialize and e.g. getFieldValue will not
       find a field whose name is spelt with a different case.
    */
    private void writeObject(ObjectOutputStream out) throws IOException {
<span class="nc" id="L1371">        ObjectOutputStream.PutField fields = out.putFields();</span>
<span class="nc" id="L1372">        boolean compat = &quot;1.0&quot;.equals(serialForm);</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (compat)</span>
<span class="nc" id="L1374">            fields.put(&quot;currClass&quot;, currClass);</span>

        /* Purge the field &quot;targetObject&quot; from the DescriptorSupport before
         * serializing since the referenced object is typically not
         * serializable.  We do this here rather than purging the &quot;descriptor&quot;
         * variable below because that HashMap doesn't do case-insensitivity.
         * See CR 6332962.
         */
<span class="nc" id="L1382">        SortedMap&lt;String, Object&gt; startMap = descriptorMap;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (startMap.containsKey(&quot;targetObject&quot;)) {</span>
<span class="nc" id="L1384">            startMap = new TreeMap&lt;String, Object&gt;(descriptorMap);</span>
<span class="nc" id="L1385">            startMap.remove(&quot;targetObject&quot;);</span>
        }

        final HashMap&lt;String, Object&gt; descriptor;
<span class="nc bnc" id="L1389" title="All 4 branches missed.">        if (compat || &quot;1.2.0&quot;.equals(serialForm) ||</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                &quot;1.2.1&quot;.equals(serialForm)) {</span>
<span class="nc" id="L1391">            descriptor = new HashMap&lt;String, Object&gt;();</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">            for (Map.Entry&lt;String, Object&gt; entry : startMap.entrySet())</span>
<span class="nc" id="L1393">                descriptor.put(entry.getKey().toLowerCase(), entry.getValue());</span>
        } else
<span class="nc" id="L1395">            descriptor = new HashMap&lt;String, Object&gt;(startMap);</span>

<span class="nc" id="L1397">        fields.put(&quot;descriptor&quot;, descriptor);</span>
<span class="nc" id="L1398">        out.writeFields();</span>
<span class="nc" id="L1399">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>