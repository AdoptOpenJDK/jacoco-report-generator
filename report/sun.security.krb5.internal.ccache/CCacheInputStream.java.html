<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CCacheInputStream.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.krb5.internal.ccache</a> &gt; <span class="el_source">CCacheInputStream.java</span></div><h1>CCacheInputStream.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */

package sun.security.krb5.internal.ccache;

import java.io.IOException;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.StringTokenizer;
import sun.security.krb5.*;
import sun.security.krb5.internal.*;
import sun.security.krb5.internal.util.KrbDataInputStream;

/**
 * This class extends KrbDataInputStream. It is used for parsing FCC-format
 * data from file to memory.
 *
 * @author Yanni Zhang
 *
 */
public class CCacheInputStream extends KrbDataInputStream implements FileCCacheConstants {

    /*
     * FCC version 2 contains type information for principals.  FCC
     * version 1 does not.
     *
     * FCC version 3 contains keyblock encryption type information, and is
     * architecture independent.  Previous versions are not.
     *
     * The code will accept version 1, 2, and 3 ccaches, and depending
     * what KRB5_FCC_DEFAULT_FVNO is set to, it will create version 1, 2,
     * or 3 FCC caches.
     *
     * The default credentials cache should be type 3 for now (see
     * init_ctx.c).
     */
    /* V4 of the credentials cache format allows for header tags */

<span class="fc" id="L67">    private static boolean DEBUG = Krb5.DEBUG;</span>

    public CCacheInputStream(InputStream is){
<span class="fc" id="L70">        super(is);</span>
<span class="fc" id="L71">    }</span>

    /* Read tag field introduced in KRB5_FCC_FVNO_4 */
    // this needs to be public for Kinit.
    public Tag readTag() throws IOException {
<span class="fc" id="L76">        char[] buf = new char[1024];</span>
        byte[] bytes;
        int len;
<span class="fc" id="L79">        int tag = -1;</span>
        int taglen;
<span class="fc" id="L81">        Integer time_offset = null;</span>
<span class="fc" id="L82">        Integer usec_offset = null;</span>

<span class="fc" id="L84">        len = read(2);</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L86">            throw new IOException(&quot;stop.&quot;);</span>
        }
<span class="fc" id="L88">        bytes = new byte[len + 2];</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (len &gt; buf.length) {</span>
<span class="nc" id="L90">            throw new IOException(&quot;Invalid tag length.&quot;);</span>
        }
<span class="fc bfc" id="L92" title="All 2 branches covered.">        while (len &gt; 0) {</span>
<span class="fc" id="L93">            tag    = read(2);</span>
<span class="fc" id="L94">            taglen = read(2);</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">            switch (tag) {</span>
            case FCC_TAG_DELTATIME:
<span class="fc" id="L97">                time_offset = new Integer(read(4));</span>
<span class="fc" id="L98">                usec_offset = new Integer(read(4));</span>
<span class="fc" id="L99">                break;</span>
            default:
            }
<span class="fc" id="L102">            len = len - (4 + taglen);</span>
        }
        Tag result;
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (tag == -1) {</span>
        }
<span class="fc" id="L107">        result = new Tag(len, tag, time_offset, usec_offset);</span>
<span class="fc" id="L108">        return result;</span>
    }
    /*
     * In file-based credential cache, the realm name is stored as part of
     * principal name at the first place.
     */
    // made public for KinitOptions to call directly
    public PrincipalName readPrincipal(int version) throws IOException, RealmException {
        int type, length, namelength, kret;
<span class="fc" id="L117">        String[] pname = null;</span>
        String realm;
        /* Read principal type */
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (version == KRB5_FCC_FVNO_1) {</span>
<span class="nc" id="L121">            type = KRB5_NT_UNKNOWN;</span>
        } else {
<span class="fc" id="L123">            type = read(4);</span>
        }
<span class="fc" id="L125">        length = read(4);</span>
<span class="fc" id="L126">        String[] result = new String[length + 1];</span>
        /*
         * DCE includes the principal's realm in the count; the new format
         * does not.
         */
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (version == KRB5_FCC_FVNO_1)</span>
<span class="nc" id="L132">            length--;</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (int i = 0; i &lt;= length; i++) {</span>
<span class="fc" id="L134">            namelength = read(4);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if (namelength &gt; MAXNAMELENGTH) {</span>
<span class="nc" id="L136">                throw new IOException(&quot;Invalid name length in principal name.&quot;);</span>
            }
<span class="fc" id="L138">            byte[] bytes = new byte[namelength];</span>
<span class="fc" id="L139">            read(bytes, 0, namelength);</span>
<span class="fc" id="L140">            result[i] = new String(bytes);</span>
        }
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (isRealm(result[0])) {</span>
<span class="fc" id="L143">            realm = result[0];</span>
<span class="fc" id="L144">            pname = new String[length];</span>
<span class="fc" id="L145">            System.arraycopy(result, 1, pname, 0, length);</span>
<span class="fc" id="L146">            return new PrincipalName(type, pname, new Realm(realm));</span>
        }
        try {
<span class="nc" id="L149">            return new PrincipalName(result, type);</span>
<span class="nc" id="L150">        } catch (RealmException re) {</span>
<span class="nc" id="L151">            return null;</span>
        }
    }

    /*
     * In practice, a realm is named by uppercasing the DNS domain name. we currently
     * rely on this to determine if the string within the principal identifier is realm
     * name.
     *
     */
    boolean isRealm(String str) {
        try {
<span class="fc" id="L163">            Realm r = new Realm(str);</span>
        }
<span class="nc" id="L165">        catch (Exception e) {</span>
<span class="nc" id="L166">            return false;</span>
<span class="fc" id="L167">        }</span>
<span class="fc" id="L168">        StringTokenizer st = new StringTokenizer(str, &quot;.&quot;);</span>
        String s;
<span class="fc bfc" id="L170" title="All 2 branches covered.">        while (st.hasMoreTokens()) {</span>
<span class="fc" id="L171">            s = st.nextToken();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (s.charAt(i) &gt;= 141) {</span>
<span class="nc" id="L174">                    return false;</span>
                }
            }
        }
<span class="fc" id="L178">        return true;</span>
    }

    EncryptionKey readKey(int version) throws IOException {
        int keyType, keyLen;
<span class="fc" id="L183">        keyType = read(2);</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (version == KRB5_FCC_FVNO_3)</span>
<span class="nc" id="L185">            read(2); /* keytype recorded twice in fvno 3 */</span>
<span class="fc" id="L186">        keyLen = read(4);</span>
<span class="fc" id="L187">        byte[] bytes = new byte[keyLen];</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for (int i = 0; i &lt; keyLen; i++) {</span>
<span class="fc" id="L189">            bytes[i] = (byte)read();</span>
        }
<span class="fc" id="L191">        return new EncryptionKey(bytes, keyType, new Integer(version));</span>
    }

    long[] readTimes() throws IOException {
<span class="fc" id="L195">        long[] times = new long[4];</span>
<span class="fc" id="L196">        times[0] = (long)read(4) * 1000;</span>
<span class="fc" id="L197">        times[1] = (long)read(4) * 1000;</span>
<span class="fc" id="L198">        times[2] = (long)read(4) * 1000;</span>
<span class="fc" id="L199">        times[3] = (long)read(4) * 1000;</span>
<span class="fc" id="L200">        return times;</span>
    }

    boolean readskey() throws IOException {
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (read() == 0) {</span>
<span class="fc" id="L205">            return false;</span>
        }
<span class="nc" id="L207">        else return true;</span>
    }

    HostAddress[] readAddr() throws IOException, KrbApErrException {
        int numAddrs, addrType, addrLength;
<span class="fc" id="L212">        numAddrs = read(4);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (numAddrs &gt; 0) {</span>
<span class="nc" id="L214">            HostAddress[] addrs = new HostAddress[numAddrs];</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">            for (int i = 0; i &lt; numAddrs; i++) {</span>
<span class="nc" id="L216">                addrType = read(2);</span>
<span class="nc" id="L217">                addrLength = read(4);</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">                if (!(addrLength == 4 || addrLength == 16)) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                    if (DEBUG) {</span>
<span class="nc" id="L220">                        System.out.println(&quot;Incorrect address format.&quot;);</span>
                    }
<span class="nc" id="L222">                    return null;</span>
                }
<span class="nc" id="L224">                byte[] result = new byte[addrLength];</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                for (int j = 0; j &lt; addrLength; j++)</span>
<span class="nc" id="L226">                    result[j] = (byte)read(1);</span>
<span class="nc" id="L227">                addrs[i] = new HostAddress(addrType, result);</span>
            }
<span class="nc" id="L229">            return addrs;</span>
        }
<span class="fc" id="L231">        return null;</span>
    }

    AuthorizationDataEntry[] readAuth() throws IOException {
        int num, adtype, adlength;
<span class="fc" id="L236">        num = read(4);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (num &gt; 0) {</span>
<span class="nc" id="L238">            AuthorizationDataEntry[] auData = new AuthorizationDataEntry[num];</span>
<span class="nc" id="L239">            byte[] data = null;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L241">                adtype = read(2);</span>
<span class="nc" id="L242">                adlength = read(4);</span>
<span class="nc" id="L243">                data = new byte[adlength];</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                for (int j = 0; j &lt; adlength; j++) {</span>
<span class="nc" id="L245">                    data[j] = (byte)read();</span>
                }
<span class="nc" id="L247">                auData[i] = new AuthorizationDataEntry(adtype, data);</span>
            }
<span class="nc" id="L249">            return auData;</span>
        }
<span class="fc" id="L251">        else return null;</span>
    }

    byte[] readData() throws IOException {
        int length;
<span class="fc" id="L256">        length = read(4);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L258">            return null;</span>
        } else {
<span class="fc" id="L260">            byte[] bytes = new byte[length];</span>
<span class="fc" id="L261">            read(bytes, 0, length);</span>
<span class="fc" id="L262">            return bytes;</span>
        }
    }

    boolean[] readFlags() throws IOException {
<span class="fc" id="L267">        boolean[] flags = new boolean[Krb5.TKT_OPTS_MAX+1];</span>
        int ticketFlags;
<span class="fc" id="L269">        ticketFlags = read(4);</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x40000000) == TKT_FLG_FORWARDABLE)</span>
<span class="fc" id="L271">        flags[1] = true;</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x20000000) == TKT_FLG_FORWARDED)</span>
<span class="nc" id="L273">        flags[2] = true;</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x10000000) == TKT_FLG_PROXIABLE)</span>
<span class="nc" id="L275">        flags[3] = true;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x08000000) == TKT_FLG_PROXY)</span>
<span class="nc" id="L277">        flags[4] = true;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x04000000) == TKT_FLG_MAY_POSTDATE)</span>
<span class="nc" id="L279">        flags[5] = true;</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x02000000) == TKT_FLG_POSTDATED)</span>
<span class="nc" id="L281">        flags[6] = true;</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x01000000) == TKT_FLG_INVALID)</span>
<span class="nc" id="L283">        flags[7] = true;</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x00800000) == TKT_FLG_RENEWABLE)</span>
<span class="fc" id="L285">        flags[8] = true;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x00400000) == TKT_FLG_INITIAL)</span>
<span class="fc" id="L287">        flags[9] = true;</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x00200000) == TKT_FLG_PRE_AUTH)</span>
<span class="fc" id="L289">        flags[10] = true;</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if ((ticketFlags &amp; 0x00100000) == TKT_FLG_HW_AUTH)</span>
<span class="nc" id="L291">        flags[11] = true;</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="fc" id="L293">            String msg = &quot;&gt;&gt;&gt; CCacheInputStream: readFlags() &quot;;</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (flags[1] == true) {</span>
<span class="fc" id="L295">                msg += &quot; FORWARDABLE;&quot;;</span>
            }
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if (flags[2] == true) {</span>
<span class="nc" id="L298">                msg += &quot; FORWARDED;&quot;;</span>
            }
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            if (flags[3] == true) {</span>
<span class="nc" id="L301">                msg += &quot; PROXIABLE;&quot;;</span>
            }
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">            if (flags[4] == true) {</span>
<span class="nc" id="L304">                msg += &quot; PROXY;&quot;;</span>
            }
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if (flags[5] == true) {</span>
<span class="nc" id="L307">                msg += &quot; MAY_POSTDATE;&quot;;</span>
            }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">            if (flags[6] == true) {</span>
<span class="nc" id="L310">                msg += &quot; POSTDATED;&quot;;</span>
            }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            if (flags[7] == true) {</span>
<span class="nc" id="L313">                msg += &quot; INVALID;&quot;;</span>
            }
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            if (flags[8] == true) {</span>
<span class="fc" id="L316">                msg += &quot; RENEWABLE;&quot;;</span>
            }

<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (flags[9] == true) {</span>
<span class="fc" id="L320">                msg += &quot; INITIAL;&quot;;</span>
            }
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            if (flags[10] == true) {</span>
<span class="fc" id="L323">                msg += &quot; PRE_AUTH;&quot;;</span>
            }
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (flags[11] == true) {</span>
<span class="nc" id="L326">                msg += &quot; HW_AUTH;&quot;;</span>
            }
<span class="fc" id="L328">            System.out.println(msg);</span>
        }
<span class="fc" id="L330">        return flags;</span>
    }

    /**
     * Reads the next cred in stream.
     * @return the next cred, null if ticket or second_ticket unparseable.
     *
     * Note: MIT krb5 1.8.1 might generate a config entry with server principal
     * X-CACHECONF:/krb5_ccache_conf_data/fast_avail/krbtgt/REALM@REALM. The
     * entry is used by KDC to inform the client that it support certain
     * features. Its ticket is not a valid krb5 ticket and thus this method
     * returns null.
     */
    Credentials readCred(int version) throws IOException,RealmException, KrbApErrException, Asn1Exception {
<span class="fc" id="L344">        PrincipalName cpname = readPrincipal(version);</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (DEBUG)</span>
<span class="fc" id="L346">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt;  client principal is &quot; + cpname);</span>
<span class="fc" id="L347">        PrincipalName spname = readPrincipal(version);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">        if (DEBUG)</span>
<span class="fc" id="L349">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; server principal is &quot; + spname);</span>
<span class="fc" id="L350">        EncryptionKey key = readKey(version);</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (DEBUG)</span>
<span class="fc" id="L352">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; key type: &quot; + key.getEType());</span>
<span class="fc" id="L353">        long times[] = readTimes();</span>
<span class="fc" id="L354">        KerberosTime authtime = new KerberosTime(times[0]);</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        KerberosTime starttime =</span>
                (times[1]==0) ? null : new KerberosTime(times[1]);
<span class="fc" id="L357">        KerberosTime endtime = new KerberosTime(times[2]);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        KerberosTime renewTill =</span>
                (times[3]==0) ? null : new KerberosTime(times[3]);

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="fc" id="L362">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; auth time: &quot; + authtime.toDate().toString());</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; start time: &quot; +</span>
<span class="pc" id="L364">                    ((starttime==null)?&quot;null&quot;:starttime.toDate().toString()));</span>
<span class="fc" id="L365">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; end time: &quot; + endtime.toDate().toString());</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            System.out.println(&quot;&gt;&gt;&gt;DEBUG &lt;CCacheInputStream&gt; renew_till time: &quot; +</span>
<span class="pc" id="L367">                    ((renewTill==null)?&quot;null&quot;:renewTill.toDate().toString()));</span>
        }
<span class="fc" id="L369">        boolean skey = readskey();</span>
<span class="fc" id="L370">        boolean flags[] = readFlags();</span>
<span class="fc" id="L371">        TicketFlags tFlags = new TicketFlags(flags);</span>
<span class="fc" id="L372">        HostAddress addr[] = readAddr();</span>
<span class="fc" id="L373">        HostAddresses addrs = null;</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (addr != null) {</span>
<span class="nc" id="L375">            addrs = new HostAddresses(addr);</span>
        }
<span class="fc" id="L377">        AuthorizationDataEntry[] auDataEntry = readAuth();</span>
<span class="fc" id="L378">        AuthorizationData auData = null;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (auDataEntry != null) {</span>
<span class="nc" id="L380">            auData = new AuthorizationData(auDataEntry);</span>
        }
<span class="fc" id="L382">        byte[] ticketData = readData();</span>
<span class="fc" id="L383">        byte[] ticketData2 = readData();</span>

        try {
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">            return new Credentials(cpname, spname, key, authtime, starttime,</span>
                endtime, renewTill, skey, tFlags,
                addrs, auData,
                ticketData != null ? new Ticket(ticketData) : null,
                ticketData2 != null ? new Ticket(ticketData2) : null);
<span class="nc" id="L391">        } catch (Exception e) {     // If any of new Ticket(*) fails.</span>
<span class="nc" id="L392">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>