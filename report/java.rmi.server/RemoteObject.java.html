<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RemoteObject.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.rmi.server</a> &gt; <span class="el_source">RemoteObject.java</span></div><h1>RemoteObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.rmi.server;

import java.rmi.Remote;
import java.rmi.NoSuchObjectException;
import java.lang.reflect.Proxy;
import sun.rmi.server.Util;

/**
 * The &lt;code&gt;RemoteObject&lt;/code&gt; class implements the
 * &lt;code&gt;java.lang.Object&lt;/code&gt; behavior for remote objects.
 * &lt;code&gt;RemoteObject&lt;/code&gt; provides the remote semantics of Object by
 * implementing methods for hashCode, equals, and toString.
 *
 * @author      Ann Wollrath
 * @author      Laird Dornin
 * @author      Peter Jones
 * @since       JDK1.1
 */
public abstract class RemoteObject implements Remote, java.io.Serializable {

    /** The object's remote reference. */
    transient protected RemoteRef ref;

    /** indicate compatibility with JDK 1.1.x version of class */
    private static final long serialVersionUID = -3215090123894869218L;

    /**
     * Creates a remote object.
     */
<span class="fc" id="L55">    protected RemoteObject() {</span>
<span class="fc" id="L56">        ref = null;</span>
<span class="fc" id="L57">    }</span>

    /**
     * Creates a remote object, initialized with the specified remote
     * reference.
     * @param newref remote reference
     */
<span class="fc" id="L64">    protected RemoteObject(RemoteRef newref) {</span>
<span class="fc" id="L65">        ref = newref;</span>
<span class="fc" id="L66">    }</span>

    /**
     * Returns the remote reference for the remote object.
     *
     * &lt;p&gt;Note: The object returned from this method may be an instance of
     * an implementation-specific class.  The &lt;code&gt;RemoteObject&lt;/code&gt;
     * class ensures serialization portability of its instances' remote
     * references through the behavior of its custom
     * &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods.  An
     * instance of &lt;code&gt;RemoteRef&lt;/code&gt; should not be serialized outside
     * of its &lt;code&gt;RemoteObject&lt;/code&gt; wrapper instance or the result may
     * be unportable.
     *
     * @return remote reference for the remote object
     * @since 1.2
     */
    public RemoteRef getRef() {
<span class="fc" id="L84">        return ref;</span>
    }

    /**
     * Returns the stub for the remote object &lt;code&gt;obj&lt;/code&gt; passed
     * as a parameter. This operation is only valid &lt;i&gt;after&lt;/i&gt;
     * the object has been exported.
     * @param obj the remote object whose stub is needed
     * @return the stub for the remote object, &lt;code&gt;obj&lt;/code&gt;.
     * @exception NoSuchObjectException if the stub for the
     * remote object could not be found.
     * @since 1.2
     */
    public static Remote toStub(Remote obj) throws NoSuchObjectException {
<span class="pc bpc" id="L98" title="2 of 4 branches missed.">        if (obj instanceof RemoteStub ||</span>
            (obj != null &amp;&amp;
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">             Proxy.isProxyClass(obj.getClass()) &amp;&amp;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">             Proxy.getInvocationHandler(obj) instanceof</span>
             RemoteObjectInvocationHandler))
        {
<span class="nc" id="L104">            return obj;</span>
        } else {
<span class="fc" id="L106">            return sun.rmi.transport.ObjectTable.getStub(obj);</span>
        }
    }

    /**
     * Returns a hashcode for a remote object.  Two remote object stubs
     * that refer to the same remote object will have the same hash code
     * (in order to support remote objects as keys in hash tables).
     *
     * @see             java.util.Hashtable
     */
    public int hashCode() {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        return (ref == null) ? super.hashCode() : ref.remoteHashCode();</span>
    }

    /**
     * Compares two remote objects for equality.
     * Returns a boolean that indicates whether this remote object is
     * equivalent to the specified Object. This method is used when a
     * remote object is stored in a hashtable.
     * If the specified Object is not itself an instance of RemoteObject,
     * then this method delegates by returning the result of invoking the
     * &lt;code&gt;equals&lt;/code&gt; method of its parameter with this remote object
     * as the argument.
     * @param   obj     the Object to compare with
     * @return  true if these Objects are equal; false otherwise.
     * @see             java.util.Hashtable
     */
    public boolean equals(Object obj) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (obj instanceof RemoteObject) {</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (ref == null) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">                return obj == this;</span>
            } else {
<span class="fc" id="L139">                return ref.remoteEquals(((RemoteObject)obj).ref);</span>
            }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        } else if (obj != null) {</span>
            /*
             * Fix for 4099660: if object is not an instance of RemoteObject,
             * use the result of its equals method, to support symmetry is a
             * remote object implementation class that does not extend
             * RemoteObject wishes to support equality with its stub objects.
             */
<span class="fc" id="L148">            return obj.equals(this);</span>
        } else {
<span class="nc" id="L150">            return false;</span>
        }
    }

    /**
     * Returns a String that represents the value of this remote object.
     */
    public String toString() {
<span class="fc" id="L158">        String classname = Util.getUnqualifiedName(getClass());</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        return (ref == null) ? classname :</span>
<span class="fc" id="L160">            classname + &quot;[&quot; + ref.remoteToString() + &quot;]&quot;;</span>
    }

    /**
     * &lt;code&gt;writeObject&lt;/code&gt; for custom serialization.
     *
     * &lt;p&gt;This method writes this object's serialized form for this class
     * as follows:
     *
     * &lt;p&gt;The {@link RemoteRef#getRefClass(java.io.ObjectOutput) getRefClass}
     * method is invoked on this object's &lt;code&gt;ref&lt;/code&gt; field
     * to obtain its external ref type name.
     * If the value returned by &lt;code&gt;getRefClass&lt;/code&gt; was
     * a non-&lt;code&gt;null&lt;/code&gt; string of length greater than zero,
     * the &lt;code&gt;writeUTF&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * with the value returned by &lt;code&gt;getRefClass&lt;/code&gt;, and then
     * the &lt;code&gt;writeExternal&lt;/code&gt; method is invoked on
     * this object's &lt;code&gt;ref&lt;/code&gt; field passing &lt;code&gt;out&lt;/code&gt;
     * as the argument; otherwise,
     * the &lt;code&gt;writeUTF&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * with a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;), and then
     * the &lt;code&gt;writeObject&lt;/code&gt; method is invoked on &lt;code&gt;out&lt;/code&gt;
     * passing this object's &lt;code&gt;ref&lt;/code&gt; field as the argument.
     *
     * @serialData
     *
     * The serialized data for this class comprises a string (written with
     * &lt;code&gt;ObjectOutput.writeUTF&lt;/code&gt;) that is either the external
     * ref type name of the contained &lt;code&gt;RemoteRef&lt;/code&gt; instance
     * (the &lt;code&gt;ref&lt;/code&gt; field) or a zero-length string, followed by
     * either the external form of the &lt;code&gt;ref&lt;/code&gt; field as written by
     * its &lt;code&gt;writeExternal&lt;/code&gt; method if the string was of non-zero
     * length, or the serialized form of the &lt;code&gt;ref&lt;/code&gt; field as
     * written by passing it to the serialization stream's
     * &lt;code&gt;writeObject&lt;/code&gt; if the string was of zero length.
     *
     * &lt;p&gt;If this object is an instance of
     * {@link RemoteStub} or {@link RemoteObjectInvocationHandler}
     * that was returned from any of
     * the &lt;code&gt;UnicastRemoteObject.exportObject&lt;/code&gt; methods
     * and custom socket factories are not used,
     * the external ref type name is &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from any of
     * the &lt;code&gt;UnicastRemoteObject.exportObject&lt;/code&gt; methods
     * and custom socket factories are used,
     * the external ref type name is &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from any of
     * the &lt;code&gt;java.rmi.activation.Activatable.exportObject&lt;/code&gt; methods,
     * the external ref type name is &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was returned from
     * the &lt;code&gt;RemoteObject.toStub&lt;/code&gt; method (and the argument passed
     * to &lt;code&gt;toStub&lt;/code&gt; was not itself a &lt;code&gt;RemoteStub&lt;/code&gt;),
     * the external ref type name is a function of how the remote object
     * passed to &lt;code&gt;toStub&lt;/code&gt; was exported, as described above.
     *
     * If this object is an instance of
     * &lt;code&gt;RemoteStub&lt;/code&gt; or &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt;
     * that was originally created via deserialization,
     * the external ref type name is the same as that which was read
     * when this object was deserialized.
     *
     * &lt;p&gt;If this object is an instance of
     * &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt; that does not
     * use custom socket factories,
     * the external ref type name is &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt;.
     *
     * If this object is an instance of
     * &lt;code&gt;UnicastRemoteObject&lt;/code&gt; that does
     * use custom socket factories,
     * the external ref type name is &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;.
     *
     * &lt;p&gt;Following is the data that must be written by the
     * &lt;code&gt;writeExternal&lt;/code&gt; method and read by the
     * &lt;code&gt;readExternal&lt;/code&gt; method of &lt;code&gt;RemoteRef&lt;/code&gt;
     * implementation classes that correspond to the each of the
     * defined external ref type names:
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; with a
     * &lt;code&gt;null&lt;/code&gt; client socket factory:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the byte value &lt;code&gt;0x00&lt;/code&gt;
     * (indicating &lt;code&gt;null&lt;/code&gt; client socket factory),
     * written by {@link java.io.ObjectOutput#writeByte(int)}
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; with a
     * non-&lt;code&gt;null&lt;/code&gt; client socket factory:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;the byte value &lt;code&gt;0x01&lt;/code&gt;
     * (indicating non-&lt;code&gt;null&lt;/code&gt; client socket factory),
     * written by {@link java.io.ObjectOutput#writeByte(int)}
     *
     * &lt;li&gt;the hostname of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the port of the referenced remote object,
     * written by {@link java.io.ObjectOutput#writeInt(int)}
     *
     * &lt;li&gt;a client socket factory (object of type
     * &lt;code&gt;java.rmi.server.RMIClientSocketFactory&lt;/code&gt;),
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;the data written as a result of calling
     * {link java.rmi.server.ObjID#write(java.io.ObjectOutput)}
     * on the &lt;code&gt;ObjID&lt;/code&gt; instance contained in the reference
     *
     * &lt;li&gt;the boolean value &lt;code&gt;false&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeBoolean(boolean)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt; with a
     * &lt;code&gt;null&lt;/code&gt; nested remote reference:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;an instance of
     * &lt;code&gt;java.rmi.activation.ActivationID&lt;/code&gt;,
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;),
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt; with a
     * non-&lt;code&gt;null&lt;/code&gt; nested remote reference:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;an instance of
     * &lt;code&gt;java.rmi.activation.ActivationID&lt;/code&gt;,
     * written by passing it to an invocation of
     * &lt;code&gt;writeObject&lt;/code&gt; on the stream instance
     *
     * &lt;li&gt;the external ref type name of the nested remote reference,
     * which must be &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;,
     * written by {@link java.io.ObjectOutput#writeUTF(String)}
     *
     * &lt;li&gt;the external form of the nested remote reference,
     * written by invoking its &lt;code&gt;writeExternal&lt;/code&gt; method
     * with the stream instance
     * (see the description of the external form for
     * &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt; above)
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt; and
     * &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;, no data is written by the
     * &lt;code&gt;writeExternal&lt;/code&gt; method or read by the
     * &lt;code&gt;readExternal&lt;/code&gt; method.
     */
    private void writeObject(java.io.ObjectOutputStream out)
        throws java.io.IOException, java.lang.ClassNotFoundException
    {
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L364">            throw new java.rmi.MarshalException(&quot;Invalid remote object&quot;);</span>
        } else {
<span class="fc" id="L366">            String refClassName = ref.getRefClass(out);</span>
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">            if (refClassName == null || refClassName.length() == 0) {</span>
                /*
                 * No reference class name specified, so serialize
                 * remote reference.
                 */
<span class="fc" id="L372">                out.writeUTF(&quot;&quot;);</span>
<span class="fc" id="L373">                out.writeObject(ref);</span>
            } else {
                /*
                 * Built-in reference class specified, so delegate
                 * to reference to write out its external form.
                 */
<span class="fc" id="L379">                out.writeUTF(refClassName);</span>
<span class="fc" id="L380">                ref.writeExternal(out);</span>
            }
        }
<span class="fc" id="L383">    }</span>

    /**
     * &lt;code&gt;readObject&lt;/code&gt; for custom serialization.
     *
     * &lt;p&gt;This method reads this object's serialized form for this class
     * as follows:
     *
     * &lt;p&gt;The &lt;code&gt;readUTF&lt;/code&gt; method is invoked on &lt;code&gt;in&lt;/code&gt;
     * to read the external ref type name for the &lt;code&gt;RemoteRef&lt;/code&gt;
     * instance to be filled in to this object's &lt;code&gt;ref&lt;/code&gt; field.
     * If the string returned by &lt;code&gt;readUTF&lt;/code&gt; has length zero,
     * the &lt;code&gt;readObject&lt;/code&gt; method is invoked on &lt;code&gt;in&lt;/code&gt;,
     * and than the value returned by &lt;code&gt;readObject&lt;/code&gt; is cast to
     * &lt;code&gt;RemoteRef&lt;/code&gt; and this object's &lt;code&gt;ref&lt;/code&gt; field is
     * set to that value.
     * Otherwise, this object's &lt;code&gt;ref&lt;/code&gt; field is set to a
     * &lt;code&gt;RemoteRef&lt;/code&gt; instance that is created of an
     * implementation-specific class corresponding to the external ref
     * type name returned by &lt;code&gt;readUTF&lt;/code&gt;, and then
     * the &lt;code&gt;readExternal&lt;/code&gt; method is invoked on
     * this object's &lt;code&gt;ref&lt;/code&gt; field.
     *
     * &lt;p&gt;If the external ref type name is
     * &lt;code&gt;&quot;UnicastRef&quot;&lt;/code&gt;, &lt;code&gt;&quot;UnicastServerRef&quot;&lt;/code&gt;,
     * &lt;code&gt;&quot;UnicastRef2&quot;&lt;/code&gt;, &lt;code&gt;&quot;UnicastServerRef2&quot;&lt;/code&gt;,
     * or &lt;code&gt;&quot;ActivatableRef&quot;&lt;/code&gt;, a corresponding
     * implementation-specific class must be found, and its
     * &lt;code&gt;readExternal&lt;/code&gt; method must read the serial data
     * for that external ref type name as specified to be written
     * in the &lt;b&gt;serialData&lt;/b&gt; documentation for this class.
     * If the external ref type name is any other string (of non-zero
     * length), a &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown,
     * unless the implementation provides an implementation-specific
     * class corresponding to that external ref type name, in which
     * case this object's &lt;code&gt;ref&lt;/code&gt; field will be set to an
     * instance of that implementation-specific class.
     */
    private void readObject(java.io.ObjectInputStream in)
        throws java.io.IOException, java.lang.ClassNotFoundException
    {
<span class="fc" id="L424">        String refClassName = in.readUTF();</span>
<span class="pc bpc" id="L425" title="1 of 4 branches missed.">        if (refClassName == null || refClassName.length() == 0) {</span>
            /*
             * No reference class name specified, so construct
             * remote reference from its serialized form.
             */
<span class="fc" id="L430">            ref = (RemoteRef) in.readObject();</span>
        } else {
            /*
             * Built-in reference class specified, so delegate to
             * internal reference class to initialize its fields from
             * its external form.
             */
<span class="fc" id="L437">            String internalRefClassName =</span>
                RemoteRef.packagePrefix + &quot;.&quot; + refClassName;
<span class="fc" id="L439">            Class&lt;?&gt; refClass = Class.forName(internalRefClassName);</span>
            try {
<span class="fc" id="L441">                ref = (RemoteRef) refClass.newInstance();</span>

                /*
                 * If this step fails, assume we found an internal
                 * class that is not meant to be a serializable ref
                 * type.
                 */
<span class="fc" id="L448">            } catch (InstantiationException e) {</span>
<span class="fc" id="L449">                throw new ClassNotFoundException(internalRefClassName, e);</span>
<span class="nc" id="L450">            } catch (IllegalAccessException e) {</span>
<span class="nc" id="L451">                throw new ClassNotFoundException(internalRefClassName, e);</span>
<span class="nc" id="L452">            } catch (ClassCastException e) {</span>
<span class="nc" id="L453">                throw new ClassNotFoundException(internalRefClassName, e);</span>
<span class="fc" id="L454">            }</span>
<span class="fc" id="L455">            ref.readExternal(in);</span>
        }
<span class="fc" id="L457">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>