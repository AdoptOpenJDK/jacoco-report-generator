<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UnicodeSet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">UnicodeSet.java</span></div><h1>UnicodeSet.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

import java.text.ParsePosition;
import java.util.Iterator;
import java.util.TreeSet;

/**
 * A mutable set of Unicode characters and multicharacter strings.  Objects of this class
 * represent &lt;em&gt;character classes&lt;/em&gt; used in regular expressions.
 * A character specifies a subset of Unicode code points.  Legal
 * code points are U+0000 to U+10FFFF, inclusive.
 *
 * &lt;p&gt;The UnicodeSet class is not designed to be subclassed.
 *
 * &lt;p&gt;&lt;code&gt;UnicodeSet&lt;/code&gt; supports two APIs. The first is the
 * &lt;em&gt;operand&lt;/em&gt; API that allows the caller to modify the value of
 * a &lt;code&gt;UnicodeSet&lt;/code&gt; object. It conforms to Java 2's
 * &lt;code&gt;java.util.Set&lt;/code&gt; interface, although
 * &lt;code&gt;UnicodeSet&lt;/code&gt; does not actually implement that
 * interface. All methods of &lt;code&gt;Set&lt;/code&gt; are supported, with the
 * modification that they take a character range or single character
 * instead of an &lt;code&gt;Object&lt;/code&gt;, and they take a
 * &lt;code&gt;UnicodeSet&lt;/code&gt; instead of a &lt;code&gt;Collection&lt;/code&gt;.  The
 * operand API may be thought of in terms of boolean logic: a boolean
 * OR is implemented by &lt;code&gt;add&lt;/code&gt;, a boolean AND is implemented
 * by &lt;code&gt;retain&lt;/code&gt;, a boolean XOR is implemented by
 * &lt;code&gt;complement&lt;/code&gt; taking an argument, and a boolean NOT is
 * implemented by &lt;code&gt;complement&lt;/code&gt; with no argument.  In terms
 * of traditional set theory function names, &lt;code&gt;add&lt;/code&gt; is a
 * union, &lt;code&gt;retain&lt;/code&gt; is an intersection, &lt;code&gt;remove&lt;/code&gt;
 * is an asymmetric difference, and &lt;code&gt;complement&lt;/code&gt; with no
 * argument is a set complement with respect to the superset range
 * &lt;code&gt;MIN_VALUE-MAX_VALUE&lt;/code&gt;
 *
 * &lt;p&gt;The second API is the
 * &lt;code&gt;applyPattern()&lt;/code&gt;/&lt;code&gt;toPattern()&lt;/code&gt; API from the
 * &lt;code&gt;java.text.Format&lt;/code&gt;-derived classes.  Unlike the
 * methods that add characters, add categories, and control the logic
 * of the set, the method &lt;code&gt;applyPattern()&lt;/code&gt; sets all
 * attributes of a &lt;code&gt;UnicodeSet&lt;/code&gt; at once, based on a
 * string pattern.
 *
 * &lt;p&gt;&lt;b&gt;Pattern syntax&lt;/b&gt;&lt;/p&gt;
 *
 * Patterns are accepted by the constructors and the
 * &lt;code&gt;applyPattern()&lt;/code&gt; methods and returned by the
 * &lt;code&gt;toPattern()&lt;/code&gt; method.  These patterns follow a syntax
 * similar to that employed by version 8 regular expression character
 * classes.  Here are some simple examples:
 *
 * &lt;blockquote&gt;
 *   &lt;table&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;No characters&lt;/td&gt;
 *     &lt;/tr&gt;&lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;The character 'a'&lt;/td&gt;
 *     &lt;/tr&gt;&lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[ae]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;The characters 'a' and 'e'&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a-e]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;The characters 'a' through 'e' inclusive, in Unicode code
 *       point order&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[\\u4E01]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;The character U+4E01&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[a{ab}{ac}]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;The character 'a' and the multicharacter strings &amp;quot;ab&amp;quot; and
 *       &amp;quot;ac&amp;quot;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;code&gt;[\p{Lu}]&lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;All characters in the general category Uppercase Letter&lt;/td&gt;
 *     &lt;/tr&gt;
 *   &lt;/table&gt;
 * &lt;/blockquote&gt;
 *
 * Any character may be preceded by a backslash in order to remove any special
 * meaning.  White space characters, as defined by UCharacterProperty.isRuleWhiteSpace(), are
 * ignored, unless they are escaped.
 *
 * &lt;p&gt;Property patterns specify a set of characters having a certain
 * property as defined by the Unicode standard.  Both the POSIX-like
 * &quot;[:Lu:]&quot; and the Perl-like syntax &quot;\p{Lu}&quot; are recognized.  For a
 * complete list of supported property patterns, see the User's Guide
 * for UnicodeSet at
 * &lt;a href=&quot;http://www.icu-project.org/userguide/unicodeSet.html&quot;&gt;
 * http://www.icu-project.org/userguide/unicodeSet.html&lt;/a&gt;.
 * Actual determination of property data is defined by the underlying
 * Unicode database as implemented by UCharacter.
 *
 * &lt;p&gt;Patterns specify individual characters, ranges of characters, and
 * Unicode property sets.  When elements are concatenated, they
 * specify their union.  To complement a set, place a '^' immediately
 * after the opening '['.  Property patterns are inverted by modifying
 * their delimiters; &quot;[:^foo]&quot; and &quot;\P{foo}&quot;.  In any other location,
 * '^' has no special meaning.
 *
 * &lt;p&gt;Ranges are indicated by placing two a '-' between two
 * characters, as in &quot;a-z&quot;.  This specifies the range of all
 * characters from the left to the right, in Unicode order.  If the
 * left character is greater than or equal to the
 * right character it is a syntax error.  If a '-' occurs as the first
 * character after the opening '[' or '[^', or if it occurs as the
 * last character before the closing ']', then it is taken as a
 * literal.  Thus &quot;[a\\-b]&quot;, &quot;[-ab]&quot;, and &quot;[ab-]&quot; all indicate the same
 * set of three characters, 'a', 'b', and '-'.
 *
 * &lt;p&gt;Sets may be intersected using the '&amp;' operator or the asymmetric
 * set difference may be taken using the '-' operator, for example,
 * &quot;[[:L:]&amp;[\\u0000-\\u0FFF]]&quot; indicates the set of all Unicode letters
 * with values less than 4096.  Operators ('&amp;' and '|') have equal
 * precedence and bind left-to-right.  Thus
 * &quot;[[:L:]-[a-z]-[\\u0100-\\u01FF]]&quot; is equivalent to
 * &quot;[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]&quot;.  This only really matters for
 * difference; intersection is commutative.
 *
 * &lt;table&gt;
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[a]&lt;/code&gt;&lt;td&gt;The set containing 'a'
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;td&gt;The set containing 'a'
 * through 'z' and all letters in between, in Unicode order
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[^a-z]&lt;/code&gt;&lt;td&gt;The set containing
 * all characters but 'a' through 'z',
 * that is, U+0000 through 'a'-1 and 'z'+1 through U+10FFFF
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;][&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
 * &lt;td&gt;The union of sets specified by &lt;em&gt;pat1&lt;/em&gt; and &lt;em&gt;pat2&lt;/em&gt;
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;]&amp;[&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
 * &lt;td&gt;The intersection of sets specified by &lt;em&gt;pat1&lt;/em&gt; and &lt;em&gt;pat2&lt;/em&gt;
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[[&lt;em&gt;pat1&lt;/em&gt;]-[&lt;em&gt;pat2&lt;/em&gt;]]&lt;/code&gt;
 * &lt;td&gt;The asymmetric difference of sets specified by &lt;em&gt;pat1&lt;/em&gt; and
 * &lt;em&gt;pat2&lt;/em&gt;
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[:Lu:] or \p{Lu}&lt;/code&gt;
 * &lt;td&gt;The set of characters having the specified
 * Unicode property; in
 * this case, Unicode uppercase letters
 * &lt;tr valign=top&gt;&lt;td nowrap&gt;&lt;code&gt;[:^Lu:] or \P{Lu}&lt;/code&gt;
 * &lt;td&gt;The set of characters &lt;em&gt;not&lt;/em&gt; having the given
 * Unicode property
 * &lt;/table&gt;
 *
 * &lt;p&gt;&lt;b&gt;Warning&lt;/b&gt;: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;b&gt;Formal syntax&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;blockquote&gt;
 *   &lt;table&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;pattern :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;('[' '^'? item* ']') |
 *       property&lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;item :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;char | (char '-' char) | pattern-expr&lt;br&gt;
 *       &lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;pattern-expr :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;pattern | pattern-expr pattern |
 *       pattern-expr op pattern&lt;br&gt;
 *       &lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;op :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;'&amp;amp;' | '-'&lt;br&gt;
 *       &lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;special :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;'[' | ']' | '-'&lt;br&gt;
 *       &lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;char :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;any character that is not&lt;/em&gt;&lt;code&gt; special&lt;br&gt;
 *       | ('\\' &lt;/code&gt;&lt;em&gt;any character&lt;/em&gt;&lt;code&gt;)&lt;br&gt;
 *       | ('&amp;#92;u' hex hex hex hex)&lt;br&gt;
 *       &lt;/code&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr align=&quot;top&quot;&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;hex :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;any character for which
 *       &lt;/em&gt;&lt;code&gt;Character.digit(c, 16)&lt;/code&gt;&lt;em&gt;
 *       returns a non-negative result&lt;/em&gt;&lt;/td&gt;
 *     &lt;/tr&gt;
 *     &lt;tr&gt;
 *       &lt;td nowrap valign=&quot;top&quot; align=&quot;right&quot;&gt;&lt;code&gt;property :=&amp;nbsp; &lt;/code&gt;&lt;/td&gt;
 *       &lt;td valign=&quot;top&quot;&gt;&lt;em&gt;a Unicode property set pattern&lt;/td&gt;
 *     &lt;/tr&gt;
 *   &lt;/table&gt;
 *   &lt;br&gt;
 *   &lt;table border=&quot;1&quot;&gt;
 *     &lt;tr&gt;
 *       &lt;td&gt;Legend: &lt;table&gt;
 *         &lt;tr&gt;
 *           &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a := b&lt;/code&gt;&lt;/td&gt;
 *           &lt;td width=&quot;20&quot; valign=&quot;top&quot;&gt;&amp;nbsp; &lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;&lt;code&gt;a&lt;/code&gt; may be replaced by &lt;code&gt;b&lt;/code&gt; &lt;/td&gt;
 *         &lt;/tr&gt;
 *         &lt;tr&gt;
 *           &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a?&lt;/code&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;zero or one instance of &lt;code&gt;a&lt;/code&gt;&lt;br&gt;
 *           &lt;/td&gt;
 *         &lt;/tr&gt;
 *         &lt;tr&gt;
 *           &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a*&lt;/code&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;one or more instances of &lt;code&gt;a&lt;/code&gt;&lt;br&gt;
 *           &lt;/td&gt;
 *         &lt;/tr&gt;
 *         &lt;tr&gt;
 *           &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;a | b&lt;/code&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt;&lt;br&gt;
 *           &lt;/td&gt;
 *         &lt;/tr&gt;
 *         &lt;tr&gt;
 *           &lt;td nowrap valign=&quot;top&quot;&gt;&lt;code&gt;'a'&lt;/code&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;&lt;/td&gt;
 *           &lt;td valign=&quot;top&quot;&gt;the literal string between the quotes &lt;/td&gt;
 *         &lt;/tr&gt;
 *       &lt;/table&gt;
 *       &lt;/td&gt;
 *     &lt;/tr&gt;
 *   &lt;/table&gt;
 * &lt;/blockquote&gt;
 * &lt;p&gt;To iterate over contents of UnicodeSet, use UnicodeSetIterator class.
 *
 * @author Alan Liu
 * @stable ICU 2.0
 * @see UnicodeSetIterator
 */
public class UnicodeSet implements UnicodeMatcher {

    private static final int LOW = 0x000000; // LOW &lt;= all valid values. ZERO for codepoints
    private static final int HIGH = 0x110000; // HIGH &gt; all valid values. 10000 for code units.
                                             // 110000 for codepoints

    /**
     * Minimum value that can be stored in a UnicodeSet.
     * @stable ICU 2.0
     */
    public static final int MIN_VALUE = LOW;

    /**
     * Maximum value that can be stored in a UnicodeSet.
     * @stable ICU 2.0
     */
    public static final int MAX_VALUE = HIGH - 1;

    private int len;      // length used; list may be longer to minimize reallocs
    private int[] list;   // MUST be terminated with HIGH
    private int[] rangeList; // internal buffer
    private int[] buffer; // internal buffer

    // NOTE: normally the field should be of type SortedSet; but that is missing a public clone!!
    // is not private so that UnicodeSetIterator can get access
<span class="nc" id="L301">    TreeSet&lt;String&gt; strings = new TreeSet&lt;&gt;();</span>

    /**
     * The pattern representation of this set.  This may not be the
     * most economical pattern.  It is the pattern supplied to
     * applyPattern(), with variables substituted and whitespace
     * removed.  For sets constructed without applyPattern(), or
     * modified using the non-pattern API, this string will be null,
     * indicating that toPattern() must generate a pattern
     * representation from the inversion list.
     */
<span class="nc" id="L312">    private String pat = null;</span>

    private static final int START_EXTRA = 16;         // initial storage. Must be &gt;= 0
    private static final int GROW_EXTRA = START_EXTRA; // extra amount for growth. Must be &gt;= 0

    /**
     * A set of all characters _except_ the second through last characters of
     * certain ranges.  These ranges are ranges of characters whose
     * properties are all exactly alike, e.g. CJK Ideographs from
     * U+4E00 to U+9FA5.
     */
<span class="nc" id="L323">    private static UnicodeSet INCLUSIONS[] = null;</span>

    //----------------------------------------------------------------
    // Public API
    //----------------------------------------------------------------

    /**
     * Constructs an empty set.
     * @stable ICU 2.0
     */
<span class="nc" id="L333">    public UnicodeSet() {</span>
<span class="nc" id="L334">        list = new int[1 + START_EXTRA];</span>
<span class="nc" id="L335">        list[len++] = HIGH;</span>
<span class="nc" id="L336">    }</span>

    /**
     * Constructs a set containing the given range. If &lt;code&gt;end &gt;
     * start&lt;/code&gt; then an empty set is created.
     *
     * @param start first character, inclusive, of range
     * @param end last character, inclusive, of range
     * @stable ICU 2.0
     */
    public UnicodeSet(int start, int end) {
<span class="nc" id="L347">        this();</span>
<span class="nc" id="L348">        complement(start, end);</span>
<span class="nc" id="L349">    }</span>

    /**
     * Constructs a set from the given pattern.  See the class description
     * for the syntax of the pattern language.  Whitespace is ignored.
     * @param pattern a string specifying what characters are in the set
     * @exception java.lang.IllegalArgumentException if the pattern contains
     * a syntax error.
     * @stable ICU 2.0
     */
    public UnicodeSet(String pattern) {
<span class="nc" id="L360">        this();</span>
<span class="nc" id="L361">        applyPattern(pattern, null, null, IGNORE_SPACE);</span>
<span class="nc" id="L362">    }</span>

    /**
     * Make this object represent the same set as &lt;code&gt;other&lt;/code&gt;.
     * @param other a &lt;code&gt;UnicodeSet&lt;/code&gt; whose value will be
     * copied to this object
     * @stable ICU 2.0
     */
    public UnicodeSet set(UnicodeSet other) {
<span class="nc" id="L371">        list = other.list.clone();</span>
<span class="nc" id="L372">        len = other.len;</span>
<span class="nc" id="L373">        pat = other.pat;</span>
<span class="nc" id="L374">        strings = (TreeSet)other.strings.clone();</span>
<span class="nc" id="L375">        return this;</span>
    }

    /**
     * Modifies this set to represent the set specified by the given pattern.
     * See the class description for the syntax of the pattern language.
     * Whitespace is ignored.
     * @param pattern a string specifying what characters are in the set
     * @exception java.lang.IllegalArgumentException if the pattern
     * contains a syntax error.
     * @stable ICU 2.0
     */
    public final UnicodeSet applyPattern(String pattern) {
<span class="nc" id="L388">        return applyPattern(pattern, null, null, IGNORE_SPACE);</span>
    }

    /**
     * Append the &lt;code&gt;toPattern()&lt;/code&gt; representation of a
     * string to the given &lt;code&gt;StringBuffer&lt;/code&gt;.
     */
    private static void _appendToPat(StringBuffer buf, String s, boolean escapeUnprintable) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); i += UTF16.getCharCount(i)) {</span>
<span class="nc" id="L397">            _appendToPat(buf, UTF16.charAt(s, i), escapeUnprintable);</span>
        }
<span class="nc" id="L399">    }</span>

    /**
     * Append the &lt;code&gt;toPattern()&lt;/code&gt; representation of a
     * character to the given &lt;code&gt;StringBuffer&lt;/code&gt;.
     */
    private static void _appendToPat(StringBuffer buf, int c, boolean escapeUnprintable) {
<span class="nc bnc" id="L406" title="All 4 branches missed.">        if (escapeUnprintable &amp;&amp; Utility.isUnprintable(c)) {</span>
            // Use hex escape notation (&lt;backslash&gt;uxxxx or &lt;backslash&gt;Uxxxxxxxx) for anything
            // unprintable
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (Utility.escapeUnprintable(buf, c)) {</span>
<span class="nc" id="L410">                return;</span>
            }
        }
        // Okay to let ':' pass through
<span class="nc bnc" id="L414" title="All 2 branches missed.">        switch (c) {</span>
        case '[': // SET_OPEN:
        case ']': // SET_CLOSE:
        case '-': // HYPHEN:
        case '^': // COMPLEMENT:
        case '&amp;': // INTERSECTION:
        case '\\': //BACKSLASH:
        case '{':
        case '}':
        case '$':
        case ':':
<span class="nc" id="L425">            buf.append('\\');</span>
<span class="nc" id="L426">            break;</span>
        default:
            // Escape whitespace
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (UCharacterProperty.isRuleWhiteSpace(c)) {</span>
<span class="nc" id="L430">                buf.append('\\');</span>
            }
            break;
        }
<span class="nc" id="L434">        UTF16.append(buf, c);</span>
<span class="nc" id="L435">    }</span>

    /**
     * Append a string representation of this set to result.  This will be
     * a cleaned version of the string passed to applyPattern(), if there
     * is one.  Otherwise it will be generated.
     */
    private StringBuffer _toPattern(StringBuffer result,
                                    boolean escapeUnprintable) {
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (pat != null) {</span>
            int i;
<span class="nc" id="L446">            int backslashCount = 0;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            for (i=0; i&lt;pat.length(); ) {</span>
<span class="nc" id="L448">                int c = UTF16.charAt(pat, i);</span>
<span class="nc" id="L449">                i += UTF16.getCharCount(c);</span>
<span class="nc bnc" id="L450" title="All 4 branches missed.">                if (escapeUnprintable &amp;&amp; Utility.isUnprintable(c)) {</span>
                    // If the unprintable character is preceded by an odd
                    // number of backslashes, then it has been escaped.
                    // Before unescaping it, we delete the final
                    // backslash.
<span class="nc bnc" id="L455" title="All 2 branches missed.">                    if ((backslashCount % 2) == 1) {</span>
<span class="nc" id="L456">                        result.setLength(result.length() - 1);</span>
                    }
<span class="nc" id="L458">                    Utility.escapeUnprintable(result, c);</span>
<span class="nc" id="L459">                    backslashCount = 0;</span>
                } else {
<span class="nc" id="L461">                    UTF16.append(result, c);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                    if (c == '\\') {</span>
<span class="nc" id="L463">                        ++backslashCount;</span>
                    } else {
<span class="nc" id="L465">                        backslashCount = 0;</span>
                    }
                }
<span class="nc" id="L468">            }</span>
<span class="nc" id="L469">            return result;</span>
        }

<span class="nc" id="L472">        return _generatePattern(result, escapeUnprintable, true);</span>
    }

    /**
     * Generate and append a string representation of this set to result.
     * This does not use this.pat, the cleaned up copy of the string
     * passed to applyPattern().
     * @param includeStrings if false, doesn't include the strings.
     * @stable ICU 3.8
     */
    public StringBuffer _generatePattern(StringBuffer result,
                                         boolean escapeUnprintable, boolean includeStrings) {
<span class="nc" id="L484">        result.append('[');</span>

<span class="nc" id="L486">        int count = getRangeCount();</span>

        // If the set contains at least 2 intervals and includes both
        // MIN_VALUE and MAX_VALUE, then the inverse representation will
        // be more economical.
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (count &gt; 1 &amp;&amp;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            getRangeStart(0) == MIN_VALUE &amp;&amp;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            getRangeEnd(count-1) == MAX_VALUE) {</span>

            // Emit the inverse
<span class="nc" id="L496">            result.append('^');</span>

<span class="nc bnc" id="L498" title="All 2 branches missed.">            for (int i = 1; i &lt; count; ++i) {</span>
<span class="nc" id="L499">                int start = getRangeEnd(i-1)+1;</span>
<span class="nc" id="L500">                int end = getRangeStart(i)-1;</span>
<span class="nc" id="L501">                _appendToPat(result, start, escapeUnprintable);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (start != end) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                    if ((start+1) != end) {</span>
<span class="nc" id="L504">                        result.append('-');</span>
                    }
<span class="nc" id="L506">                    _appendToPat(result, end, escapeUnprintable);</span>
                }
            }
        }

        // Default; emit the ranges as pairs
        else {
<span class="nc bnc" id="L513" title="All 2 branches missed.">            for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc" id="L514">                int start = getRangeStart(i);</span>
<span class="nc" id="L515">                int end = getRangeEnd(i);</span>
<span class="nc" id="L516">                _appendToPat(result, start, escapeUnprintable);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (start != end) {</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                    if ((start+1) != end) {</span>
<span class="nc" id="L519">                        result.append('-');</span>
                    }
<span class="nc" id="L521">                    _appendToPat(result, end, escapeUnprintable);</span>
                }
            }
        }

<span class="nc bnc" id="L526" title="All 4 branches missed.">        if (includeStrings &amp;&amp; strings.size() &gt; 0) {</span>
<span class="nc" id="L527">            Iterator&lt;String&gt; it = strings.iterator();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L529">                result.append('{');</span>
<span class="nc" id="L530">                _appendToPat(result, it.next(), escapeUnprintable);</span>
<span class="nc" id="L531">                result.append('}');</span>
            }
        }
<span class="nc" id="L534">        return result.append(']');</span>
    }

    // for internal use, after checkFrozen has been called
    private UnicodeSet add_unchecked(int start, int end) {
<span class="nc bnc" id="L539" title="All 4 branches missed.">        if (start &lt; MIN_VALUE || start &gt; MAX_VALUE) {</span>
<span class="nc" id="L540">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(start, 6));</span>
        }
<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (end &lt; MIN_VALUE || end &gt; MAX_VALUE) {</span>
<span class="nc" id="L543">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(end, 6));</span>
        }
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (start &lt; end) {</span>
<span class="nc" id="L546">            add(range(start, end), 2, 0);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        } else if (start == end) {</span>
<span class="nc" id="L548">            add(start);</span>
        }
<span class="nc" id="L550">        return this;</span>
    }

    /**
     * Adds the specified character to this set if it is not already
     * present.  If this set already contains the specified character,
     * the call leaves this set unchanged.
     * @stable ICU 2.0
     */
    public final UnicodeSet add(int c) {
<span class="nc" id="L560">        return add_unchecked(c);</span>
    }

    // for internal use only, after checkFrozen has been called
    private final UnicodeSet add_unchecked(int c) {
<span class="nc bnc" id="L565" title="All 4 branches missed.">        if (c &lt; MIN_VALUE || c &gt; MAX_VALUE) {</span>
<span class="nc" id="L566">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(c, 6));</span>
        }

        // find smallest i such that c &lt; list[i]
        // if odd, then it is IN the set
        // if even, then it is OUT of the set
<span class="nc" id="L572">        int i = findCodePoint(c);</span>

        // already in set?
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if ((i &amp; 1) != 0) return this;</span>

        // HIGH is 0x110000
        // assert(list[len-1] == HIGH);

        // empty = [HIGH]
        // [start_0, limit_0, start_1, limit_1, HIGH]

        // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
        //                             ^
        //                             list[i]

        // i == 0 means c is before the first range

<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (c == list[i]-1) {</span>
            // c is before start of next range
<span class="nc" id="L591">            list[i] = c;</span>
            // if we touched the HIGH mark, then add a new one
<span class="nc bnc" id="L593" title="All 2 branches missed.">            if (c == MAX_VALUE) {</span>
<span class="nc" id="L594">                ensureCapacity(len+1);</span>
<span class="nc" id="L595">                list[len++] = HIGH;</span>
            }
<span class="nc bnc" id="L597" title="All 4 branches missed.">            if (i &gt; 0 &amp;&amp; c == list[i-1]) {</span>
                // collapse adjacent ranges

                // [..., start_k-1, c, c, limit_k, ..., HIGH]
                //                     ^
                //                     list[i]
<span class="nc" id="L603">                System.arraycopy(list, i+1, list, i-1, len-i-1);</span>
<span class="nc" id="L604">                len -= 2;</span>
            }
        }

<span class="nc bnc" id="L608" title="All 4 branches missed.">        else if (i &gt; 0 &amp;&amp; c == list[i-1]) {</span>
            // c is after end of prior range
<span class="nc" id="L610">            list[i-1]++;</span>
            // no need to chcek for collapse here
        }

        else {
            // At this point we know the new char is not adjacent to
            // any existing ranges, and it is not 10FFFF.


            // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
            //                             ^
            //                             list[i]

            // [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]
            //                             ^
            //                             list[i]

            // Don't use ensureCapacity() to save on copying.
            // NOTE: This has no measurable impact on performance,
            // but it might help in some usage patterns.
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (len+2 &gt; list.length) {</span>
<span class="nc" id="L631">                int[] temp = new int[len + 2 + GROW_EXTRA];</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (i != 0) System.arraycopy(list, 0, temp, 0, i);</span>
<span class="nc" id="L633">                System.arraycopy(list, i, temp, i+2, len-i);</span>
<span class="nc" id="L634">                list = temp;</span>
<span class="nc" id="L635">            } else {</span>
<span class="nc" id="L636">                System.arraycopy(list, i, list, i+2, len-i);</span>
            }

<span class="nc" id="L639">            list[i] = c;</span>
<span class="nc" id="L640">            list[i+1] = c+1;</span>
<span class="nc" id="L641">            len += 2;</span>
        }

<span class="nc" id="L644">        pat = null;</span>
<span class="nc" id="L645">        return this;</span>
    }

    /**
     * Adds the specified multicharacter to this set if it is not already
     * present.  If this set already contains the multicharacter,
     * the call leaves this set unchanged.
     * Thus &quot;ch&quot; =&gt; {&quot;ch&quot;}
     * &lt;br&gt;&lt;b&gt;Warning: you cannot add an empty string (&quot;&quot;) to a UnicodeSet.&lt;/b&gt;
     * @param s the source string
     * @return this object, for chaining
     * @stable ICU 2.0
     */
    public final UnicodeSet add(String s) {
<span class="nc" id="L659">        int cp = getSingleCP(s);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        if (cp &lt; 0) {</span>
<span class="nc" id="L661">            strings.add(s);</span>
<span class="nc" id="L662">            pat = null;</span>
        } else {
<span class="nc" id="L664">            add_unchecked(cp, cp);</span>
        }
<span class="nc" id="L666">        return this;</span>
    }

    /**
     * @return a code point IF the string consists of a single one.
     * otherwise returns -1.
     * @param string to test
     */
    private static int getSingleCP(String s) {
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (s.length() &lt; 1) {</span>
<span class="nc" id="L676">            throw new IllegalArgumentException(&quot;Can't use zero-length strings in UnicodeSet&quot;);</span>
        }
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (s.length() &gt; 2) return -1;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (s.length() == 1) return s.charAt(0);</span>

        // at this point, len = 2
<span class="nc" id="L682">        int cp = UTF16.charAt(s, 0);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (cp &gt; 0xFFFF) { // is surrogate pair</span>
<span class="nc" id="L684">            return cp;</span>
        }
<span class="nc" id="L686">        return -1;</span>
    }

    /**
     * Complements the specified range in this set.  Any character in
     * the range will be removed if it is in this set, or will be
     * added if it is not in this set.  If &lt;code&gt;end &gt; start&lt;/code&gt;
     * then an empty range is complemented, leaving the set unchanged.
     *
     * @param start first character, inclusive, of range to be removed
     * from this set.
     * @param end last character, inclusive, of range to be removed
     * from this set.
     * @stable ICU 2.0
     */
    public UnicodeSet complement(int start, int end) {
<span class="nc bnc" id="L702" title="All 4 branches missed.">        if (start &lt; MIN_VALUE || start &gt; MAX_VALUE) {</span>
<span class="nc" id="L703">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(start, 6));</span>
        }
<span class="nc bnc" id="L705" title="All 4 branches missed.">        if (end &lt; MIN_VALUE || end &gt; MAX_VALUE) {</span>
<span class="nc" id="L706">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(end, 6));</span>
        }
<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (start &lt;= end) {</span>
<span class="nc" id="L709">            xor(range(start, end), 2, 0);</span>
        }
<span class="nc" id="L711">        pat = null;</span>
<span class="nc" id="L712">        return this;</span>
    }

    /**
     * This is equivalent to
     * &lt;code&gt;complement(MIN_VALUE, MAX_VALUE)&lt;/code&gt;.
     * @stable ICU 2.0
     */
    public UnicodeSet complement() {
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (list[0] == LOW) {</span>
<span class="nc" id="L722">            System.arraycopy(list, 1, list, 0, len-1);</span>
<span class="nc" id="L723">            --len;</span>
        } else {
<span class="nc" id="L725">            ensureCapacity(len+1);</span>
<span class="nc" id="L726">            System.arraycopy(list, 0, list, 1, len);</span>
<span class="nc" id="L727">            list[0] = LOW;</span>
<span class="nc" id="L728">            ++len;</span>
        }
<span class="nc" id="L730">        pat = null;</span>
<span class="nc" id="L731">        return this;</span>
    }

    /**
     * Returns true if this set contains the given character.
     * @param c character to be checked for containment
     * @return true if the test condition is met
     * @stable ICU 2.0
     */
    public boolean contains(int c) {
<span class="nc bnc" id="L741" title="All 4 branches missed.">        if (c &lt; MIN_VALUE || c &gt; MAX_VALUE) {</span>
<span class="nc" id="L742">            throw new IllegalArgumentException(&quot;Invalid code point U+&quot; + Utility.hex(c, 6));</span>
        }

        /*
        // Set i to the index of the start item greater than ch
        // We know we will terminate without length test!
        int i = -1;
        while (true) {
            if (c &lt; list[++i]) break;
        }
        */

<span class="nc" id="L754">        int i = findCodePoint(c);</span>

<span class="nc bnc" id="L756" title="All 2 branches missed.">        return ((i &amp; 1) != 0); // return true if odd</span>
    }

    /**
     * Returns the smallest value i such that c &lt; list[i].  Caller
     * must ensure that c is a legal value or this method will enter
     * an infinite loop.  This method performs a binary search.
     * @param c a character in the range MIN_VALUE..MAX_VALUE
     * inclusive
     * @return the smallest integer i in the range 0..len-1,
     * inclusive, such that c &lt; list[i]
     */
    private final int findCodePoint(int c) {
        /* Examples:
                                           findCodePoint(c)
           set              list[]         c=0 1 3 4 7 8
           ===              ==============   ===========
           []               [110000]         0 0 0 0 0 0
           [\u0000-\u0003]  [0, 4, 110000]   1 1 1 2 2 2
           [\u0004-\u0007]  [4, 8, 110000]   0 0 0 1 1 2
           [:all:]          [0, 110000]      1 1 1 1 1 1
         */

        // Return the smallest i such that c &lt; list[i].  Assume
        // list[len - 1] == HIGH and that c is legal (0..HIGH-1).
<span class="nc bnc" id="L781" title="All 2 branches missed.">        if (c &lt; list[0]) return 0;</span>
        // High runner test.  c is often after the last range, so an
        // initial check for this condition pays off.
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if (len &gt;= 2 &amp;&amp; c &gt;= list[len-2]) return len-1;</span>
<span class="nc" id="L785">        int lo = 0;</span>
<span class="nc" id="L786">        int hi = len - 1;</span>
        // invariant: c &gt;= list[lo]
        // invariant: c &lt; list[hi]
        for (;;) {
<span class="nc" id="L790">            int i = (lo + hi) &gt;&gt;&gt; 1;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (i == lo) return hi;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (c &lt; list[i]) {</span>
<span class="nc" id="L793">                hi = i;</span>
            } else {
<span class="nc" id="L795">                lo = i;</span>
            }
<span class="nc" id="L797">        }</span>
    }

    /**
     * Adds all of the elements in the specified set to this set if
     * they're not already present.  This operation effectively
     * modifies this set so that its value is the &lt;i&gt;union&lt;/i&gt; of the two
     * sets.  The behavior of this operation is unspecified if the specified
     * collection is modified while the operation is in progress.
     *
     * @param c set whose elements are to be added to this set.
     * @stable ICU 2.0
     */
    public UnicodeSet addAll(UnicodeSet c) {
<span class="nc" id="L811">        add(c.list, c.len, 0);</span>
<span class="nc" id="L812">        strings.addAll(c.strings);</span>
<span class="nc" id="L813">        return this;</span>
    }

    /**
     * Retains only the elements in this set that are contained in the
     * specified set.  In other words, removes from this set all of
     * its elements that are not contained in the specified set.  This
     * operation effectively modifies this set so that its value is
     * the &lt;i&gt;intersection&lt;/i&gt; of the two sets.
     *
     * @param c set that defines which elements this set will retain.
     * @stable ICU 2.0
     */
    public UnicodeSet retainAll(UnicodeSet c) {
<span class="nc" id="L827">        retain(c.list, c.len, 0);</span>
<span class="nc" id="L828">        strings.retainAll(c.strings);</span>
<span class="nc" id="L829">        return this;</span>
    }

    /**
     * Removes from this set all of its elements that are contained in the
     * specified set.  This operation effectively modifies this
     * set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of
     * the two sets.
     *
     * @param c set that defines which elements will be removed from
     *          this set.
     * @stable ICU 2.0
     */
    public UnicodeSet removeAll(UnicodeSet c) {
<span class="nc" id="L843">        retain(c.list, c.len, 2);</span>
<span class="nc" id="L844">        strings.removeAll(c.strings);</span>
<span class="nc" id="L845">        return this;</span>
    }

    /**
     * Removes all of the elements from this set.  This set will be
     * empty after this call returns.
     * @stable ICU 2.0
     */
    public UnicodeSet clear() {
<span class="nc" id="L854">        list[0] = HIGH;</span>
<span class="nc" id="L855">        len = 1;</span>
<span class="nc" id="L856">        pat = null;</span>
<span class="nc" id="L857">        strings.clear();</span>
<span class="nc" id="L858">        return this;</span>
    }

    /**
     * Iteration method that returns the number of ranges contained in
     * this set.
     * @see #getRangeStart
     * @see #getRangeEnd
     * @stable ICU 2.0
     */
    public int getRangeCount() {
<span class="nc" id="L869">        return len/2;</span>
    }

    /**
     * Iteration method that returns the first character in the
     * specified range of this set.
     * @exception ArrayIndexOutOfBoundsException if index is outside
     * the range &lt;code&gt;0..getRangeCount()-1&lt;/code&gt;
     * @see #getRangeCount
     * @see #getRangeEnd
     * @stable ICU 2.0
     */
    public int getRangeStart(int index) {
<span class="nc" id="L882">        return list[index*2];</span>
    }

    /**
     * Iteration method that returns the last character in the
     * specified range of this set.
     * @exception ArrayIndexOutOfBoundsException if index is outside
     * the range &lt;code&gt;0..getRangeCount()-1&lt;/code&gt;
     * @see #getRangeStart
     * @see #getRangeEnd
     * @stable ICU 2.0
     */
    public int getRangeEnd(int index) {
<span class="nc" id="L895">        return (list[index*2 + 1] - 1);</span>
    }

    //----------------------------------------------------------------
    // Implementation: Pattern parsing
    //----------------------------------------------------------------

    /**
     * Parses the given pattern, starting at the given position.  The character
     * at pattern.charAt(pos.getIndex()) must be '[', or the parse fails.
     * Parsing continues until the corresponding closing ']'.  If a syntax error
     * is encountered between the opening and closing brace, the parse fails.
     * Upon return from a successful parse, the ParsePosition is updated to
     * point to the character following the closing ']', and an inversion
     * list for the parsed pattern is returned.  This method
     * calls itself recursively to parse embedded subpatterns.
     *
     * @param pattern the string containing the pattern to be parsed.  The
     * portion of the string from pos.getIndex(), which must be a '[', to the
     * corresponding closing ']', is parsed.
     * @param pos upon entry, the position at which to being parsing.  The
     * character at pattern.charAt(pos.getIndex()) must be a '['.  Upon return
     * from a successful parse, pos.getIndex() is either the character after the
     * closing ']' of the parsed pattern, or pattern.length() if the closing ']'
     * is the last character of the pattern string.
     * @return an inversion list for the parsed substring
     * of &lt;code&gt;pattern&lt;/code&gt;
     * @exception java.lang.IllegalArgumentException if the parse fails.
     */
    UnicodeSet applyPattern(String pattern,
                      ParsePosition pos,
                      SymbolTable symbols,
                      int options) {

        // Need to build the pattern in a temporary string because
        // _applyPattern calls add() etc., which set pat to empty.
<span class="nc bnc" id="L931" title="All 2 branches missed.">        boolean parsePositionWasNull = pos == null;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (parsePositionWasNull) {</span>
<span class="nc" id="L933">            pos = new ParsePosition(0);</span>
        }

<span class="nc" id="L936">        StringBuffer rebuiltPat = new StringBuffer();</span>
<span class="nc" id="L937">        RuleCharacterIterator chars =</span>
            new RuleCharacterIterator(pattern, symbols, pos);
<span class="nc" id="L939">        applyPattern(chars, symbols, rebuiltPat, options);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (chars.inVariable()) {</span>
<span class="nc" id="L941">            syntaxError(chars, &quot;Extra chars in variable value&quot;);</span>
        }
<span class="nc" id="L943">        pat = rebuiltPat.toString();</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (parsePositionWasNull) {</span>
<span class="nc" id="L945">            int i = pos.getIndex();</span>

            // Skip over trailing whitespace
<span class="nc bnc" id="L948" title="All 2 branches missed.">            if ((options &amp; IGNORE_SPACE) != 0) {</span>
<span class="nc" id="L949">                i = Utility.skipWhitespace(pattern, i);</span>
            }

<span class="nc bnc" id="L952" title="All 2 branches missed.">            if (i != pattern.length()) {</span>
<span class="nc" id="L953">                throw new IllegalArgumentException(&quot;Parse of \&quot;&quot; + pattern +</span>
                                                   &quot;\&quot; failed at &quot; + i);
            }
        }
<span class="nc" id="L957">        return this;</span>
    }

    /**
     * Parse the pattern from the given RuleCharacterIterator.  The
     * iterator is advanced over the parsed pattern.
     * @param chars iterator over the pattern characters.  Upon return
     * it will be advanced to the first character after the parsed
     * pattern, or the end of the iteration if all characters are
     * parsed.
     * @param symbols symbol table to use to parse and dereference
     * variables, or null if none.
     * @param rebuiltPat the pattern that was parsed, rebuilt or
     * copied from the input pattern, as appropriate.
     * @param options a bit mask of zero or more of the following:
     * IGNORE_SPACE, CASE.
     */
    void applyPattern(RuleCharacterIterator chars, SymbolTable symbols,
                      StringBuffer rebuiltPat, int options) {
        // Syntax characters: [ ] ^ - &amp; { }

        // Recognized special forms for chars, sets: c-c s-s s&amp;s

<span class="nc" id="L980">        int opts = RuleCharacterIterator.PARSE_VARIABLES |</span>
                   RuleCharacterIterator.PARSE_ESCAPES;
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if ((options &amp; IGNORE_SPACE) != 0) {</span>
<span class="nc" id="L983">            opts |= RuleCharacterIterator.SKIP_WHITESPACE;</span>
        }

<span class="nc" id="L986">        StringBuffer patBuf = new StringBuffer(), buf = null;</span>
<span class="nc" id="L987">        boolean usePat = false;</span>
<span class="nc" id="L988">        UnicodeSet scratch = null;</span>
<span class="nc" id="L989">        Object backup = null;</span>

        // mode: 0=before [, 1=between [...], 2=after ]
        // lastItem: 0=none, 1=char, 2=set
<span class="nc" id="L993">        int lastItem = 0, lastChar = 0, mode = 0;</span>
<span class="nc" id="L994">        char op = 0;</span>

<span class="nc" id="L996">        boolean invert = false;</span>

<span class="nc" id="L998">        clear();</span>

<span class="nc bnc" id="L1000" title="All 4 branches missed.">        while (mode != 2 &amp;&amp; !chars.atEnd()) {</span>
            if (false) {
                // Debugging assertion
                if (!((lastItem == 0 &amp;&amp; op == 0) ||
                      (lastItem == 1 &amp;&amp; (op == 0 || op == '-')) ||
                      (lastItem == 2 &amp;&amp; (op == 0 || op == '-' || op == '&amp;')))) {
                    throw new IllegalArgumentException();
                }
            }

<span class="nc" id="L1010">            int c = 0;</span>
<span class="nc" id="L1011">            boolean literal = false;</span>
<span class="nc" id="L1012">            UnicodeSet nested = null;</span>

            // -------- Check for property pattern

            // setMode: 0=none, 1=unicodeset, 2=propertypat, 3=preparsed
<span class="nc" id="L1017">            int setMode = 0;</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            if (resemblesPropertyPattern(chars, opts)) {</span>
<span class="nc" id="L1019">                setMode = 2;</span>
            }

            // -------- Parse '[' of opening delimiter OR nested set.
            // If there is a nested set, use `setMode' to define how
            // the set should be parsed.  If the '[' is part of the
            // opening delimiter for this pattern, parse special
            // strings &quot;[&quot;, &quot;[^&quot;, &quot;[-&quot;, and &quot;[^-&quot;.  Check for stand-in
            // characters representing a nested set in the symbol
            // table.

            else {
                // Prepare to backup if necessary
<span class="nc" id="L1032">                backup = chars.getPos(backup);</span>
<span class="nc" id="L1033">                c = chars.next(opts);</span>
<span class="nc" id="L1034">                literal = chars.isEscaped();</span>

<span class="nc bnc" id="L1036" title="All 4 branches missed.">                if (c == '[' &amp;&amp; !literal) {</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                    if (mode == 1) {</span>
<span class="nc" id="L1038">                        chars.setPos(backup); // backup</span>
<span class="nc" id="L1039">                        setMode = 1;</span>
                    } else {
                        // Handle opening '[' delimiter
<span class="nc" id="L1042">                        mode = 1;</span>
<span class="nc" id="L1043">                        patBuf.append('[');</span>
<span class="nc" id="L1044">                        backup = chars.getPos(backup); // prepare to backup</span>
<span class="nc" id="L1045">                        c = chars.next(opts);</span>
<span class="nc" id="L1046">                        literal = chars.isEscaped();</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">                        if (c == '^' &amp;&amp; !literal) {</span>
<span class="nc" id="L1048">                            invert = true;</span>
<span class="nc" id="L1049">                            patBuf.append('^');</span>
<span class="nc" id="L1050">                            backup = chars.getPos(backup); // prepare to backup</span>
<span class="nc" id="L1051">                            c = chars.next(opts);</span>
<span class="nc" id="L1052">                            literal = chars.isEscaped();</span>
                        }
                        // Fall through to handle special leading '-';
                        // otherwise restart loop for nested [], \p{}, etc.
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                        if (c == '-') {</span>
<span class="nc" id="L1057">                            literal = true;</span>
                            // Fall through to handle literal '-' below
                        } else {
<span class="nc" id="L1060">                            chars.setPos(backup); // backup</span>
<span class="nc" id="L1061">                            continue;</span>
                        }
                    }
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                } else if (symbols != null) {</span>
<span class="nc" id="L1065">                     UnicodeMatcher m = symbols.lookupMatcher(c); // may be null</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                     if (m != null) {</span>
                         try {
<span class="nc" id="L1068">                             nested = (UnicodeSet) m;</span>
<span class="nc" id="L1069">                             setMode = 3;</span>
<span class="nc" id="L1070">                         } catch (ClassCastException e) {</span>
<span class="nc" id="L1071">                             syntaxError(chars, &quot;Syntax error&quot;);</span>
<span class="nc" id="L1072">                         }</span>
                     }
                }
            }

            // -------- Handle a nested set.  This either is inline in
            // the pattern or represented by a stand-in that has
            // previously been parsed and was looked up in the symbol
            // table.

<span class="nc bnc" id="L1082" title="All 2 branches missed.">            if (setMode != 0) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">                if (lastItem == 1) {</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    if (op != 0) {</span>
<span class="nc" id="L1085">                        syntaxError(chars, &quot;Char expected after operator&quot;);</span>
                    }
<span class="nc" id="L1087">                    add_unchecked(lastChar, lastChar);</span>
<span class="nc" id="L1088">                    _appendToPat(patBuf, lastChar, false);</span>
<span class="nc" id="L1089">                    lastItem = op = 0;</span>
                }

<span class="nc bnc" id="L1092" title="All 4 branches missed.">                if (op == '-' || op == '&amp;') {</span>
<span class="nc" id="L1093">                    patBuf.append(op);</span>
                }

<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if (nested == null) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                    if (scratch == null) scratch = new UnicodeSet();</span>
<span class="nc" id="L1098">                    nested = scratch;</span>
                }
<span class="nc bnc" id="L1100" title="All 4 branches missed.">                switch (setMode) {</span>
                case 1:
<span class="nc" id="L1102">                    nested.applyPattern(chars, symbols, patBuf, options);</span>
<span class="nc" id="L1103">                    break;</span>
                case 2:
<span class="nc" id="L1105">                    chars.skipIgnored(opts);</span>
<span class="nc" id="L1106">                    nested.applyPropertyPattern(chars, patBuf, symbols);</span>
<span class="nc" id="L1107">                    break;</span>
                case 3: // `nested' already parsed
<span class="nc" id="L1109">                    nested._toPattern(patBuf, false);</span>
                    break;
                }

<span class="nc" id="L1113">                usePat = true;</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">                if (mode == 0) {</span>
                    // Entire pattern is a category; leave parse loop
<span class="nc" id="L1117">                    set(nested);</span>
<span class="nc" id="L1118">                    mode = 2;</span>
<span class="nc" id="L1119">                    break;</span>
                }

<span class="nc bnc" id="L1122" title="All 4 branches missed.">                switch (op) {</span>
                case '-':
<span class="nc" id="L1124">                    removeAll(nested);</span>
<span class="nc" id="L1125">                    break;</span>
                case '&amp;':
<span class="nc" id="L1127">                    retainAll(nested);</span>
<span class="nc" id="L1128">                    break;</span>
                case 0:
<span class="nc" id="L1130">                    addAll(nested);</span>
                    break;
                }

<span class="nc" id="L1134">                op = 0;</span>
<span class="nc" id="L1135">                lastItem = 2;</span>

<span class="nc" id="L1137">                continue;</span>
            }

<span class="nc bnc" id="L1140" title="All 2 branches missed.">            if (mode == 0) {</span>
<span class="nc" id="L1141">                syntaxError(chars, &quot;Missing '['&quot;);</span>
            }

            // -------- Parse special (syntax) characters.  If the
            // current character is not special, or if it is escaped,
            // then fall through and handle it below.

<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (!literal) {</span>
<span class="nc bnc" id="L1149" title="All 7 branches missed.">                switch (c) {</span>
                case ']':
<span class="nc bnc" id="L1151" title="All 2 branches missed.">                    if (lastItem == 1) {</span>
<span class="nc" id="L1152">                        add_unchecked(lastChar, lastChar);</span>
<span class="nc" id="L1153">                        _appendToPat(patBuf, lastChar, false);</span>
                    }
                    // Treat final trailing '-' as a literal
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                    if (op == '-') {</span>
<span class="nc" id="L1157">                        add_unchecked(op, op);</span>
<span class="nc" id="L1158">                        patBuf.append(op);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    } else if (op == '&amp;') {</span>
<span class="nc" id="L1160">                        syntaxError(chars, &quot;Trailing '&amp;'&quot;);</span>
                    }
<span class="nc" id="L1162">                    patBuf.append(']');</span>
<span class="nc" id="L1163">                    mode = 2;</span>
<span class="nc" id="L1164">                    continue;</span>
                case '-':
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                    if (op == 0) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                        if (lastItem != 0) {</span>
<span class="nc" id="L1168">                            op = (char) c;</span>
<span class="nc" id="L1169">                            continue;</span>
                        } else {
                            // Treat final trailing '-' as a literal
<span class="nc" id="L1172">                            add_unchecked(c, c);</span>
<span class="nc" id="L1173">                            c = chars.next(opts);</span>
<span class="nc" id="L1174">                            literal = chars.isEscaped();</span>
<span class="nc bnc" id="L1175" title="All 4 branches missed.">                            if (c == ']' &amp;&amp; !literal) {</span>
<span class="nc" id="L1176">                                patBuf.append(&quot;-]&quot;);</span>
<span class="nc" id="L1177">                                mode = 2;</span>
<span class="nc" id="L1178">                                continue;</span>
                            }
                        }
                    }
<span class="nc" id="L1182">                    syntaxError(chars, &quot;'-' not after char or set&quot;);</span>
<span class="nc" id="L1183">                    break;</span>
                case '&amp;':
<span class="nc bnc" id="L1185" title="All 4 branches missed.">                    if (lastItem == 2 &amp;&amp; op == 0) {</span>
<span class="nc" id="L1186">                        op = (char) c;</span>
<span class="nc" id="L1187">                        continue;</span>
                    }
<span class="nc" id="L1189">                    syntaxError(chars, &quot;'&amp;' not after set&quot;);</span>
<span class="nc" id="L1190">                    break;</span>
                case '^':
<span class="nc" id="L1192">                    syntaxError(chars, &quot;'^' not after '['&quot;);</span>
<span class="nc" id="L1193">                    break;</span>
                case '{':
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                    if (op != 0) {</span>
<span class="nc" id="L1196">                        syntaxError(chars, &quot;Missing operand after operator&quot;);</span>
                    }
<span class="nc bnc" id="L1198" title="All 2 branches missed.">                    if (lastItem == 1) {</span>
<span class="nc" id="L1199">                        add_unchecked(lastChar, lastChar);</span>
<span class="nc" id="L1200">                        _appendToPat(patBuf, lastChar, false);</span>
                    }
<span class="nc" id="L1202">                    lastItem = 0;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                    if (buf == null) {</span>
<span class="nc" id="L1204">                        buf = new StringBuffer();</span>
                    } else {
<span class="nc" id="L1206">                        buf.setLength(0);</span>
                    }
<span class="nc" id="L1208">                    boolean ok = false;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                    while (!chars.atEnd()) {</span>
<span class="nc" id="L1210">                        c = chars.next(opts);</span>
<span class="nc" id="L1211">                        literal = chars.isEscaped();</span>
<span class="nc bnc" id="L1212" title="All 4 branches missed.">                        if (c == '}' &amp;&amp; !literal) {</span>
<span class="nc" id="L1213">                            ok = true;</span>
<span class="nc" id="L1214">                            break;</span>
                        }
<span class="nc" id="L1216">                        UTF16.append(buf, c);</span>
                    }
<span class="nc bnc" id="L1218" title="All 4 branches missed.">                    if (buf.length() &lt; 1 || !ok) {</span>
<span class="nc" id="L1219">                        syntaxError(chars, &quot;Invalid multicharacter string&quot;);</span>
                    }
                    // We have new string. Add it to set and continue;
                    // we don't need to drop through to the further
                    // processing
<span class="nc" id="L1224">                    add(buf.toString());</span>
<span class="nc" id="L1225">                    patBuf.append('{');</span>
<span class="nc" id="L1226">                    _appendToPat(patBuf, buf.toString(), false);</span>
<span class="nc" id="L1227">                    patBuf.append('}');</span>
<span class="nc" id="L1228">                    continue;</span>
                case SymbolTable.SYMBOL_REF:
                    //         symbols  nosymbols
                    // [a-$]   error    error (ambiguous)
                    // [a$]    anchor   anchor
                    // [a-$x]  var &quot;x&quot;* literal '$'
                    // [a-$.]  error    literal '$'
                    // *We won't get here in the case of var &quot;x&quot;
<span class="nc" id="L1236">                    backup = chars.getPos(backup);</span>
<span class="nc" id="L1237">                    c = chars.next(opts);</span>
<span class="nc" id="L1238">                    literal = chars.isEscaped();</span>
<span class="nc bnc" id="L1239" title="All 4 branches missed.">                    boolean anchor = (c == ']' &amp;&amp; !literal);</span>
<span class="nc bnc" id="L1240" title="All 4 branches missed.">                    if (symbols == null &amp;&amp; !anchor) {</span>
<span class="nc" id="L1241">                        c = SymbolTable.SYMBOL_REF;</span>
<span class="nc" id="L1242">                        chars.setPos(backup);</span>
<span class="nc" id="L1243">                        break; // literal '$'</span>
                    }
<span class="nc bnc" id="L1245" title="All 4 branches missed.">                    if (anchor &amp;&amp; op == 0) {</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                        if (lastItem == 1) {</span>
<span class="nc" id="L1247">                            add_unchecked(lastChar, lastChar);</span>
<span class="nc" id="L1248">                            _appendToPat(patBuf, lastChar, false);</span>
                        }
<span class="nc" id="L1250">                        add_unchecked(UnicodeMatcher.ETHER);</span>
<span class="nc" id="L1251">                        usePat = true;</span>
<span class="nc" id="L1252">                        patBuf.append(SymbolTable.SYMBOL_REF).append(']');</span>
<span class="nc" id="L1253">                        mode = 2;</span>
<span class="nc" id="L1254">                        continue;</span>
                    }
<span class="nc" id="L1256">                    syntaxError(chars, &quot;Unquoted '$'&quot;);</span>
<span class="nc" id="L1257">                    break;</span>
                default:
                    break;
                }
            }

            // -------- Parse literal characters.  This includes both
            // escaped chars (&quot;\u4E01&quot;) and non-syntax characters
            // (&quot;a&quot;).

<span class="nc bnc" id="L1267" title="All 4 branches missed.">            switch (lastItem) {</span>
            case 0:
<span class="nc" id="L1269">                lastItem = 1;</span>
<span class="nc" id="L1270">                lastChar = c;</span>
<span class="nc" id="L1271">                break;</span>
            case 1:
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                if (op == '-') {</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">                    if (lastChar &gt;= c) {</span>
                        // Don't allow redundant (a-a) or empty (b-a) ranges;
                        // these are most likely typos.
<span class="nc" id="L1277">                        syntaxError(chars, &quot;Invalid range&quot;);</span>
                    }
<span class="nc" id="L1279">                    add_unchecked(lastChar, c);</span>
<span class="nc" id="L1280">                    _appendToPat(patBuf, lastChar, false);</span>
<span class="nc" id="L1281">                    patBuf.append(op);</span>
<span class="nc" id="L1282">                    _appendToPat(patBuf, c, false);</span>
<span class="nc" id="L1283">                    lastItem = op = 0;</span>
                } else {
<span class="nc" id="L1285">                    add_unchecked(lastChar, lastChar);</span>
<span class="nc" id="L1286">                    _appendToPat(patBuf, lastChar, false);</span>
<span class="nc" id="L1287">                    lastChar = c;</span>
                }
<span class="nc" id="L1289">                break;</span>
            case 2:
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                if (op != 0) {</span>
<span class="nc" id="L1292">                    syntaxError(chars, &quot;Set expected after operator&quot;);</span>
                }
<span class="nc" id="L1294">                lastChar = c;</span>
<span class="nc" id="L1295">                lastItem = 1;</span>
                break;
            }
<span class="nc" id="L1298">        }</span>

<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (mode != 2) {</span>
<span class="nc" id="L1301">            syntaxError(chars, &quot;Missing ']'&quot;);</span>
        }

<span class="nc" id="L1304">        chars.skipIgnored(opts);</span>

<span class="nc bnc" id="L1306" title="All 2 branches missed.">        if (invert) {</span>
<span class="nc" id="L1307">            complement();</span>
        }

        // Use the rebuilt pattern (pat) only if necessary.  Prefer the
        // generated pattern.
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        if (usePat) {</span>
<span class="nc" id="L1313">            rebuiltPat.append(patBuf.toString());</span>
        } else {
<span class="nc" id="L1315">            _generatePattern(rebuiltPat, false, true);</span>
        }
<span class="nc" id="L1317">    }</span>

    private static void syntaxError(RuleCharacterIterator chars, String msg) {
<span class="nc" id="L1320">        throw new IllegalArgumentException(&quot;Error: &quot; + msg + &quot; at \&quot;&quot; +</span>
<span class="nc" id="L1321">                                           Utility.escape(chars.toString()) +</span>
                                           '&quot;');
    }

    //----------------------------------------------------------------
    // Implementation: Utility methods
    //----------------------------------------------------------------

    private void ensureCapacity(int newLen) {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if (newLen &lt;= list.length) return;</span>
<span class="nc" id="L1331">        int[] temp = new int[newLen + GROW_EXTRA];</span>
<span class="nc" id="L1332">        System.arraycopy(list, 0, temp, 0, len);</span>
<span class="nc" id="L1333">        list = temp;</span>
<span class="nc" id="L1334">    }</span>

    private void ensureBufferCapacity(int newLen) {
<span class="nc bnc" id="L1337" title="All 4 branches missed.">        if (buffer != null &amp;&amp; newLen &lt;= buffer.length) return;</span>
<span class="nc" id="L1338">        buffer = new int[newLen + GROW_EXTRA];</span>
<span class="nc" id="L1339">    }</span>

    /**
     * Assumes start &lt;= end.
     */
    private int[] range(int start, int end) {
<span class="nc bnc" id="L1345" title="All 2 branches missed.">        if (rangeList == null) {</span>
<span class="nc" id="L1346">            rangeList = new int[] { start, end+1, HIGH };</span>
        } else {
<span class="nc" id="L1348">            rangeList[0] = start;</span>
<span class="nc" id="L1349">            rangeList[1] = end+1;</span>
        }
<span class="nc" id="L1351">        return rangeList;</span>
    }

    //----------------------------------------------------------------
    // Implementation: Fundamental operations
    //----------------------------------------------------------------

    // polarity = 0, 3 is normal: x xor y
    // polarity = 1, 2: x xor ~y == x === y

    private UnicodeSet xor(int[] other, int otherLen, int polarity) {
<span class="nc" id="L1362">        ensureBufferCapacity(len + otherLen);</span>
<span class="nc" id="L1363">        int i = 0, j = 0, k = 0;</span>
<span class="nc" id="L1364">        int a = list[i++];</span>
        int b;
<span class="nc bnc" id="L1366" title="All 4 branches missed.">        if (polarity == 1 || polarity == 2) {</span>
<span class="nc" id="L1367">            b = LOW;</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (other[j] == LOW) { // skip base if already LOW</span>
<span class="nc" id="L1369">                ++j;</span>
<span class="nc" id="L1370">                b = other[j];</span>
            }
        } else {
<span class="nc" id="L1373">            b = other[j++];</span>
        }
        // simplest of all the routines
        // sort the values, discarding identicals!
        while (true) {
<span class="nc bnc" id="L1378" title="All 2 branches missed.">            if (a &lt; b) {</span>
<span class="nc" id="L1379">                buffer[k++] = a;</span>
<span class="nc" id="L1380">                a = list[i++];</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">            } else if (b &lt; a) {</span>
<span class="nc" id="L1382">                buffer[k++] = b;</span>
<span class="nc" id="L1383">                b = other[j++];</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            } else if (a != HIGH) { // at this point, a == b</span>
                // discard both values!
<span class="nc" id="L1386">                a = list[i++];</span>
<span class="nc" id="L1387">                b = other[j++];</span>
            } else { // DONE!
<span class="nc" id="L1389">                buffer[k++] = HIGH;</span>
<span class="nc" id="L1390">                len = k;</span>
<span class="nc" id="L1391">                break;</span>
            }
        }
        // swap list and buffer
<span class="nc" id="L1395">        int[] temp = list;</span>
<span class="nc" id="L1396">        list = buffer;</span>
<span class="nc" id="L1397">        buffer = temp;</span>
<span class="nc" id="L1398">        pat = null;</span>
<span class="nc" id="L1399">        return this;</span>
    }

    // polarity = 0 is normal: x union y
    // polarity = 2: x union ~y
    // polarity = 1: ~x union y
    // polarity = 3: ~x union ~y

    private UnicodeSet add(int[] other, int otherLen, int polarity) {
<span class="nc" id="L1408">        ensureBufferCapacity(len + otherLen);</span>
<span class="nc" id="L1409">        int i = 0, j = 0, k = 0;</span>
<span class="nc" id="L1410">        int a = list[i++];</span>
<span class="nc" id="L1411">        int b = other[j++];</span>
        // change from xor is that we have to check overlapping pairs
        // polarity bit 1 means a is second, bit 2 means b is.
        main:
        while (true) {
<span class="nc bnc" id="L1416" title="All 5 branches missed.">            switch (polarity) {</span>
              case 0: // both first; take lower if unequal
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                if (a &lt; b) { // take a</span>
                    // Back up over overlapping ranges in buffer[]
<span class="nc bnc" id="L1420" title="All 4 branches missed.">                    if (k &gt; 0 &amp;&amp; a &lt;= buffer[k-1]) {</span>
                        // Pick latter end value in buffer[] vs. list[]
<span class="nc" id="L1422">                        a = max(list[i], buffer[--k]);</span>
                    } else {
                        // No overlap
<span class="nc" id="L1425">                        buffer[k++] = a;</span>
<span class="nc" id="L1426">                        a = list[i];</span>
                    }
<span class="nc" id="L1428">                    i++; // Common if/else code factored out</span>
<span class="nc" id="L1429">                    polarity ^= 1;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                } else if (b &lt; a) { // take b</span>
<span class="nc bnc" id="L1431" title="All 4 branches missed.">                    if (k &gt; 0 &amp;&amp; b &lt;= buffer[k-1]) {</span>
<span class="nc" id="L1432">                        b = max(other[j], buffer[--k]);</span>
                    } else {
<span class="nc" id="L1434">                        buffer[k++] = b;</span>
<span class="nc" id="L1435">                        b = other[j];</span>
                    }
<span class="nc" id="L1437">                    j++;</span>
<span class="nc" id="L1438">                    polarity ^= 2;</span>
                } else { // a == b, take a, drop b
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
                    // This is symmetrical; it doesn't matter if
                    // we backtrack with a or b. - liu
<span class="nc bnc" id="L1443" title="All 4 branches missed.">                    if (k &gt; 0 &amp;&amp; a &lt;= buffer[k-1]) {</span>
<span class="nc" id="L1444">                        a = max(list[i], buffer[--k]);</span>
                    } else {
                        // No overlap
<span class="nc" id="L1447">                        buffer[k++] = a;</span>
<span class="nc" id="L1448">                        a = list[i];</span>
                    }
<span class="nc" id="L1450">                    i++;</span>
<span class="nc" id="L1451">                    polarity ^= 1;</span>
<span class="nc" id="L1452">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1454">                break;</span>
              case 3: // both second; take higher if unequal, and drop other
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                if (b &lt;= a) { // take a</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1458">                    buffer[k++] = a;</span>
                } else { // take b
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                    if (b == HIGH) break main;</span>
<span class="nc" id="L1461">                    buffer[k++] = b;</span>
                }
<span class="nc" id="L1463">                a = list[i++]; polarity ^= 1;   // factored common code</span>
<span class="nc" id="L1464">                b = other[j++]; polarity ^= 2;</span>
<span class="nc" id="L1465">                break;</span>
              case 1: // a second, b first; if b &lt; a, overlap
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                if (a &lt; b) { // no overlap, take a</span>
<span class="nc" id="L1468">                    buffer[k++] = a; a = list[i++]; polarity ^= 1;</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">                } else if (b &lt; a) { // OVERLAP, drop b</span>
<span class="nc" id="L1470">                    b = other[j++]; polarity ^= 2;</span>
                } else { // a == b, drop both!
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1473">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1474">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1476">                break;</span>
              case 2: // a first, b second; if a &lt; b, overlap
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                if (b &lt; a) { // no overlap, take b</span>
<span class="nc" id="L1479">                    buffer[k++] = b; b = other[j++]; polarity ^= 2;</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">                } else  if (a &lt; b) { // OVERLAP, drop a</span>
<span class="nc" id="L1481">                    a = list[i++]; polarity ^= 1;</span>
                } else { // a == b, drop both!
<span class="nc bnc" id="L1483" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1484">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1485">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1487">                break;</span>
            }
        }
<span class="nc" id="L1490">        buffer[k++] = HIGH;    // terminate</span>
<span class="nc" id="L1491">        len = k;</span>
        // swap list and buffer
<span class="nc" id="L1493">        int[] temp = list;</span>
<span class="nc" id="L1494">        list = buffer;</span>
<span class="nc" id="L1495">        buffer = temp;</span>
<span class="nc" id="L1496">        pat = null;</span>
<span class="nc" id="L1497">        return this;</span>
    }

    // polarity = 0 is normal: x intersect y
    // polarity = 2: x intersect ~y == set-minus
    // polarity = 1: ~x intersect y
    // polarity = 3: ~x intersect ~y

    private UnicodeSet retain(int[] other, int otherLen, int polarity) {
<span class="nc" id="L1506">        ensureBufferCapacity(len + otherLen);</span>
<span class="nc" id="L1507">        int i = 0, j = 0, k = 0;</span>
<span class="nc" id="L1508">        int a = list[i++];</span>
<span class="nc" id="L1509">        int b = other[j++];</span>
        // change from xor is that we have to check overlapping pairs
        // polarity bit 1 means a is second, bit 2 means b is.
        main:
        while (true) {
<span class="nc bnc" id="L1514" title="All 5 branches missed.">            switch (polarity) {</span>
              case 0: // both first; drop the smaller
<span class="nc bnc" id="L1516" title="All 2 branches missed.">                if (a &lt; b) { // drop a</span>
<span class="nc" id="L1517">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">                } else if (b &lt; a) { // drop b</span>
<span class="nc" id="L1519">                    b = other[j++]; polarity ^= 2;</span>
                } else { // a == b, take one, drop other
<span class="nc bnc" id="L1521" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1522">                    buffer[k++] = a; a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1523">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1525">                break;</span>
              case 3: // both second; take lower if unequal
<span class="nc bnc" id="L1527" title="All 2 branches missed.">                if (a &lt; b) { // take a</span>
<span class="nc" id="L1528">                    buffer[k++] = a; a = list[i++]; polarity ^= 1;</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">                } else if (b &lt; a) { // take b</span>
<span class="nc" id="L1530">                    buffer[k++] = b; b = other[j++]; polarity ^= 2;</span>
                } else { // a == b, take one, drop other
<span class="nc bnc" id="L1532" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1533">                    buffer[k++] = a; a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1534">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1536">                break;</span>
              case 1: // a second, b first;
<span class="nc bnc" id="L1538" title="All 2 branches missed.">                if (a &lt; b) { // NO OVERLAP, drop a</span>
<span class="nc" id="L1539">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc bnc" id="L1540" title="All 2 branches missed.">                } else if (b &lt; a) { // OVERLAP, take b</span>
<span class="nc" id="L1541">                    buffer[k++] = b; b = other[j++]; polarity ^= 2;</span>
                } else { // a == b, drop both!
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1544">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1545">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1547">                break;</span>
              case 2: // a first, b second; if a &lt; b, overlap
<span class="nc bnc" id="L1549" title="All 2 branches missed.">                if (b &lt; a) { // no overlap, drop b</span>
<span class="nc" id="L1550">                    b = other[j++]; polarity ^= 2;</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                } else  if (a &lt; b) { // OVERLAP, take a</span>
<span class="nc" id="L1552">                    buffer[k++] = a; a = list[i++]; polarity ^= 1;</span>
                } else { // a == b, drop both!
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                    if (a == HIGH) break main;</span>
<span class="nc" id="L1555">                    a = list[i++]; polarity ^= 1;</span>
<span class="nc" id="L1556">                    b = other[j++]; polarity ^= 2;</span>
                }
<span class="nc" id="L1558">                break;</span>
            }
        }
<span class="nc" id="L1561">        buffer[k++] = HIGH;    // terminate</span>
<span class="nc" id="L1562">        len = k;</span>
        // swap list and buffer
<span class="nc" id="L1564">        int[] temp = list;</span>
<span class="nc" id="L1565">        list = buffer;</span>
<span class="nc" id="L1566">        buffer = temp;</span>
<span class="nc" id="L1567">        pat = null;</span>
<span class="nc" id="L1568">        return this;</span>
    }

    private static final int max(int a, int b) {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">        return (a &gt; b) ? a : b;</span>
    }

    //----------------------------------------------------------------
    // Generic filter-based scanning code
    //----------------------------------------------------------------

    private static interface Filter {
        boolean contains(int codePoint);
    }

    // VersionInfo for unassigned characters
<span class="nc" id="L1584">    static final VersionInfo NO_VERSION = VersionInfo.getInstance(0, 0, 0, 0);</span>

    private static class VersionFilter implements Filter {
        VersionInfo version;

<span class="nc" id="L1589">        VersionFilter(VersionInfo version) { this.version = version; }</span>

        public boolean contains(int ch) {
<span class="nc" id="L1592">            VersionInfo v = UCharacter.getAge(ch);</span>
            // Reference comparison ok; VersionInfo caches and reuses
            // unique objects.
<span class="nc bnc" id="L1595" title="All 2 branches missed.">            return v != NO_VERSION &amp;&amp;</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">                   v.compareTo(version) &lt;= 0;</span>
        }
    }

    private static synchronized UnicodeSet getInclusions(int src) {
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        if (INCLUSIONS == null) {</span>
<span class="nc" id="L1602">            INCLUSIONS = new UnicodeSet[UCharacterProperty.SRC_COUNT];</span>
        }
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        if(INCLUSIONS[src] == null) {</span>
<span class="nc" id="L1605">            UnicodeSet incl = new UnicodeSet();</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">            switch(src) {</span>
            case UCharacterProperty.SRC_PROPSVEC:
<span class="nc" id="L1608">                UCharacterProperty.getInstance().upropsvec_addPropertyStarts(incl);</span>
<span class="nc" id="L1609">                break;</span>
            default:
<span class="nc" id="L1611">                throw new IllegalStateException(&quot;UnicodeSet.getInclusions(unknown src &quot;+src+&quot;)&quot;);</span>
            }
<span class="nc" id="L1613">            INCLUSIONS[src] = incl;</span>
        }
<span class="nc" id="L1615">        return INCLUSIONS[src];</span>
    }

    /**
     * Generic filter-based scanning code for UCD property UnicodeSets.
     */
    private UnicodeSet applyFilter(Filter filter, int src) {
        // Walk through all Unicode characters, noting the start
        // and end of each range for which filter.contain(c) is
        // true.  Add each range to a set.
        //
        // To improve performance, use the INCLUSIONS set, which
        // encodes information about character ranges that are known
        // to have identical properties, such as the CJK Ideographs
        // from U+4E00 to U+9FA5.  INCLUSIONS contains all characters
        // except the first characters of such ranges.
        //
        // TODO Where possible, instead of scanning over code points,
        // use internal property data to initialize UnicodeSets for
        // those properties.  Scanning code points is slow.

<span class="nc" id="L1636">        clear();</span>

<span class="nc" id="L1638">        int startHasProperty = -1;</span>
<span class="nc" id="L1639">        UnicodeSet inclusions = getInclusions(src);</span>
<span class="nc" id="L1640">        int limitRange = inclusions.getRangeCount();</span>

<span class="nc bnc" id="L1642" title="All 2 branches missed.">        for (int j=0; j&lt;limitRange; ++j) {</span>
            // get current range
<span class="nc" id="L1644">            int start = inclusions.getRangeStart(j);</span>
<span class="nc" id="L1645">            int end = inclusions.getRangeEnd(j);</span>

            // for all the code points in the range, process
<span class="nc bnc" id="L1648" title="All 2 branches missed.">            for (int ch = start; ch &lt;= end; ++ch) {</span>
                // only add to the unicodeset on inflection points --
                // where the hasProperty value changes to false
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                if (filter.contains(ch)) {</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                    if (startHasProperty &lt; 0) {</span>
<span class="nc" id="L1653">                        startHasProperty = ch;</span>
                    }
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                } else if (startHasProperty &gt;= 0) {</span>
<span class="nc" id="L1656">                    add_unchecked(startHasProperty, ch-1);</span>
<span class="nc" id="L1657">                    startHasProperty = -1;</span>
                }
            }
        }
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        if (startHasProperty &gt;= 0) {</span>
<span class="nc" id="L1662">            add_unchecked(startHasProperty, 0x10FFFF);</span>
        }

<span class="nc" id="L1665">        return this;</span>
    }

    /**
     * Remove leading and trailing rule white space and compress
     * internal rule white space to a single space character.
     *
     * @see UCharacterProperty#isRuleWhiteSpace
     */
    private static String mungeCharName(String source) {
<span class="nc" id="L1675">        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        for (int i=0; i&lt;source.length(); ) {</span>
<span class="nc" id="L1677">            int ch = UTF16.charAt(source, i);</span>
<span class="nc" id="L1678">            i += UTF16.getCharCount(ch);</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">            if (UCharacterProperty.isRuleWhiteSpace(ch)) {</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">                if (buf.length() == 0 ||</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">                    buf.charAt(buf.length() - 1) == ' ') {</span>
<span class="nc" id="L1682">                    continue;</span>
                }
<span class="nc" id="L1684">                ch = ' '; // convert to ' '</span>
            }
<span class="nc" id="L1686">            UTF16.append(buf, ch);</span>
<span class="nc" id="L1687">        }</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">        if (buf.length() != 0 &amp;&amp;</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">            buf.charAt(buf.length() - 1) == ' ') {</span>
<span class="nc" id="L1690">            buf.setLength(buf.length() - 1);</span>
        }
<span class="nc" id="L1692">        return buf.toString();</span>
    }

    /**
     * Modifies this set to contain those code points which have the
     * given value for the given property.  Prior contents of this
     * set are lost.
     * @param propertyAlias
     * @param valueAlias
     * @param symbols if not null, then symbols are first called to see if a property
     * is available. If true, then everything else is skipped.
     * @return this set
     * @stable ICU 3.2
     */
    public UnicodeSet applyPropertyAlias(String propertyAlias,
                                         String valueAlias, SymbolTable symbols) {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">        if (valueAlias.length() &gt; 0) {</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">            if (propertyAlias.equals(&quot;Age&quot;)) {</span>
                // Must munge name, since
                // VersionInfo.getInstance() does not do
                // 'loose' matching.
<span class="nc" id="L1713">                VersionInfo version = VersionInfo.getInstance(mungeCharName(valueAlias));</span>
<span class="nc" id="L1714">                applyFilter(new VersionFilter(version), UCharacterProperty.SRC_PROPSVEC);</span>
<span class="nc" id="L1715">                return this;</span>
            }
        }
<span class="nc" id="L1718">        throw new IllegalArgumentException(&quot;Unsupported property: &quot; + propertyAlias);</span>
    }

    /**
     * Return true if the given iterator appears to point at a
     * property pattern.  Regardless of the result, return with the
     * iterator unchanged.
     * @param chars iterator over the pattern characters.  Upon return
     * it will be unchanged.
     * @param iterOpts RuleCharacterIterator options
     */
    private static boolean resemblesPropertyPattern(RuleCharacterIterator chars,
                                                    int iterOpts) {
<span class="nc" id="L1731">        boolean result = false;</span>
<span class="nc" id="L1732">        iterOpts &amp;= ~RuleCharacterIterator.PARSE_ESCAPES;</span>
<span class="nc" id="L1733">        Object pos = chars.getPos(null);</span>
<span class="nc" id="L1734">        int c = chars.next(iterOpts);</span>
<span class="nc bnc" id="L1735" title="All 4 branches missed.">        if (c == '[' || c == '\\') {</span>
<span class="nc" id="L1736">            int d = chars.next(iterOpts &amp; ~RuleCharacterIterator.SKIP_WHITESPACE);</span>
<span class="nc bnc" id="L1737" title="All 10 branches missed.">            result = (c == '[') ? (d == ':') :</span>
                     (d == 'N' || d == 'p' || d == 'P');
        }
<span class="nc" id="L1740">        chars.setPos(pos);</span>
<span class="nc" id="L1741">        return result;</span>
    }

    /**
     * Parse the given property pattern at the given parse position.
     * @param symbols TODO
     */
    private UnicodeSet applyPropertyPattern(String pattern, ParsePosition ppos, SymbolTable symbols) {
<span class="nc" id="L1749">        int pos = ppos.getIndex();</span>

        // On entry, ppos should point to one of the following locations:

        // Minimum length is 5 characters, e.g. \p{L}
<span class="nc bnc" id="L1754" title="All 2 branches missed.">        if ((pos+5) &gt; pattern.length()) {</span>
<span class="nc" id="L1755">            return null;</span>
        }

<span class="nc" id="L1758">        boolean posix = false; // true for [:pat:], false for \p{pat} \P{pat} \N{pat}</span>
<span class="nc" id="L1759">        boolean isName = false; // true for \N{pat}, o/w false</span>
<span class="nc" id="L1760">        boolean invert = false;</span>

        // Look for an opening [:, [:^, \p, or \P
<span class="nc bnc" id="L1763" title="All 2 branches missed.">        if (pattern.regionMatches(pos, &quot;[:&quot;, 0, 2)) {</span>
<span class="nc" id="L1764">            posix = true;</span>
<span class="nc" id="L1765">            pos = Utility.skipWhitespace(pattern, pos+2);</span>
<span class="nc bnc" id="L1766" title="All 4 branches missed.">            if (pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == '^') {</span>
<span class="nc" id="L1767">                ++pos;</span>
<span class="nc" id="L1768">                invert = true;</span>
            }
<span class="nc bnc" id="L1770" title="All 2 branches missed.">        } else if (pattern.regionMatches(true, pos, &quot;\\p&quot;, 0, 2) ||</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                   pattern.regionMatches(pos, &quot;\\N&quot;, 0, 2)) {</span>
<span class="nc" id="L1772">            char c = pattern.charAt(pos+1);</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">            invert = (c == 'P');</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">            isName = (c == 'N');</span>
<span class="nc" id="L1775">            pos = Utility.skipWhitespace(pattern, pos+2);</span>
<span class="nc bnc" id="L1776" title="All 4 branches missed.">            if (pos == pattern.length() || pattern.charAt(pos++) != '{') {</span>
                // Syntax error; &quot;\p&quot; or &quot;\P&quot; not followed by &quot;{&quot;
<span class="nc" id="L1778">                return null;</span>
            }
<span class="nc" id="L1780">        } else {</span>
            // Open delimiter not seen
<span class="nc" id="L1782">            return null;</span>
        }

        // Look for the matching close delimiter, either :] or }
<span class="nc bnc" id="L1786" title="All 2 branches missed.">        int close = pattern.indexOf(posix ? &quot;:]&quot; : &quot;}&quot;, pos);</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">        if (close &lt; 0) {</span>
            // Syntax error; close delimiter missing
<span class="nc" id="L1789">            return null;</span>
        }

        // Look for an '=' sign.  If this is present, we will parse a
        // medium \p{gc=Cf} or long \p{GeneralCategory=Format}
        // pattern.
<span class="nc" id="L1795">        int equals = pattern.indexOf('=', pos);</span>
        String propName, valueName;
<span class="nc bnc" id="L1797" title="All 6 branches missed.">        if (equals &gt;= 0 &amp;&amp; equals &lt; close &amp;&amp; !isName) {</span>
            // Equals seen; parse medium/long pattern
<span class="nc" id="L1799">            propName = pattern.substring(pos, equals);</span>
<span class="nc" id="L1800">            valueName = pattern.substring(equals+1, close);</span>
        }

        else {
            // Handle case where no '=' is seen, and \N{}
<span class="nc" id="L1805">            propName = pattern.substring(pos, close);</span>
<span class="nc" id="L1806">            valueName = &quot;&quot;;</span>

            // Handle \N{name}
<span class="nc bnc" id="L1809" title="All 2 branches missed.">            if (isName) {</span>
                // This is a little inefficient since it means we have to
                // parse &quot;na&quot; back to UProperty.NAME even though we already
                // know it's UProperty.NAME.  If we refactor the API to
                // support args of (int, String) then we can remove
                // &quot;na&quot; and make this a little more efficient.
<span class="nc" id="L1815">                valueName = propName;</span>
<span class="nc" id="L1816">                propName = &quot;na&quot;;</span>
            }
        }

<span class="nc" id="L1820">        applyPropertyAlias(propName, valueName, symbols);</span>

<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (invert) {</span>
<span class="nc" id="L1823">            complement();</span>
        }

        // Move to the limit position after the close delimiter
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        ppos.setIndex(close + (posix ? 2 : 1));</span>

<span class="nc" id="L1829">        return this;</span>
    }

    /**
     * Parse a property pattern.
     * @param chars iterator over the pattern characters.  Upon return
     * it will be advanced to the first character after the parsed
     * pattern, or the end of the iteration if all characters are
     * parsed.
     * @param rebuiltPat the pattern that was parsed, rebuilt or
     * copied from the input pattern, as appropriate.
     * @param symbols TODO
     */
    private void applyPropertyPattern(RuleCharacterIterator chars,
                                      StringBuffer rebuiltPat, SymbolTable symbols) {
<span class="nc" id="L1844">        String patStr = chars.lookahead();</span>
<span class="nc" id="L1845">        ParsePosition pos = new ParsePosition(0);</span>
<span class="nc" id="L1846">        applyPropertyPattern(patStr, pos, symbols);</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        if (pos.getIndex() == 0) {</span>
<span class="nc" id="L1848">            syntaxError(chars, &quot;Invalid property pattern&quot;);</span>
        }
<span class="nc" id="L1850">        chars.jumpahead(pos.getIndex());</span>
<span class="nc" id="L1851">        rebuiltPat.append(patStr.substring(0, pos.getIndex()));</span>
<span class="nc" id="L1852">    }</span>

    //----------------------------------------------------------------
    // Case folding API
    //----------------------------------------------------------------

    /**
     * Bitmask for constructor and applyPattern() indicating that
     * white space should be ignored.  If set, ignore characters for
     * which UCharacterProperty.isRuleWhiteSpace() returns true,
     * unless they are quoted or escaped.  This may be ORed together
     * with other selectors.
     * @stable ICU 3.8
     */
    public static final int IGNORE_SPACE = 1;

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>