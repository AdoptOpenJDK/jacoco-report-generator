<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Utility.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">Utility.java</span></div><h1>Utility.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

<span class="nc" id="L39">public final class Utility {</span>

    /**
     * Convenience utility to compare two Object[]s
     * Ought to be in System.
     * @param len the length to compare.
     * The start indices and start+len must be valid.
     */
    public final static boolean arrayRegionMatches(char[] source, int sourceStart,
                                            char[] target, int targetStart,
                                            int len)
    {
<span class="nc" id="L51">        int sourceEnd = sourceStart + len;</span>
<span class="nc" id="L52">        int delta = targetStart - sourceStart;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        for (int i = sourceStart; i &lt; sourceEnd; i++) {</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">            if (source[i]!=target[i + delta])</span>
<span class="nc" id="L55">            return false;</span>
        }
<span class="nc" id="L57">        return true;</span>
    }

    /**
     * Convert characters outside the range U+0020 to U+007F to
     * Unicode escapes, and convert backslash to a double backslash.
     */
    public static final String escape(String s) {
<span class="nc" id="L65">        StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (int i=0; i&lt;s.length(); ) {</span>
<span class="nc" id="L67">            int c = UTF16.charAt(s, i);</span>
<span class="nc" id="L68">            i += UTF16.getCharCount(c);</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">            if (c &gt;= ' ' &amp;&amp; c &lt;= 0x007F) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">                if (c == '\\') {</span>
<span class="nc" id="L71">                    buf.append(&quot;\\\\&quot;); // That is, &quot;\\&quot;</span>
                } else {
<span class="nc" id="L73">                    buf.append((char)c);</span>
                }
            } else {
<span class="nc bnc" id="L76" title="All 2 branches missed.">                boolean four = c &lt;= 0xFFFF;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                buf.append(four ? &quot;\\u&quot; : &quot;\\U&quot;);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">                hex(c, four ? 4 : 8, buf);</span>
            }
<span class="nc" id="L80">        }</span>
<span class="nc" id="L81">        return buf.toString();</span>
    }

    /* This map must be in ASCENDING ORDER OF THE ESCAPE CODE */
<span class="nc" id="L85">    static private final char[] UNESCAPE_MAP = {</span>
        /*&quot;   0x22, 0x22 */
        /*'   0x27, 0x27 */
        /*?   0x3F, 0x3F */
        /*\   0x5C, 0x5C */
        /*a*/ 0x61, 0x07,
        /*b*/ 0x62, 0x08,
        /*e*/ 0x65, 0x1b,
        /*f*/ 0x66, 0x0c,
        /*n*/ 0x6E, 0x0a,
        /*r*/ 0x72, 0x0d,
        /*t*/ 0x74, 0x09,
        /*v*/ 0x76, 0x0b
    };

    /**
     * Convert an escape to a 32-bit code point value.  We attempt
     * to parallel the icu4c unescapeAt() function.
     * @param offset16 an array containing offset to the character
     * &lt;em&gt;after&lt;/em&gt; the backslash.  Upon return offset16[0] will
     * be updated to point after the escape sequence.
     * @return character value from 0 to 10FFFF, or -1 on error.
     */
    public static int unescapeAt(String s, int[] offset16) {
        int c;
<span class="nc" id="L110">        int result = 0;</span>
<span class="nc" id="L111">        int n = 0;</span>
<span class="nc" id="L112">        int minDig = 0;</span>
<span class="nc" id="L113">        int maxDig = 0;</span>
<span class="nc" id="L114">        int bitsPerDigit = 4;</span>
        int dig;
        int i;
<span class="nc" id="L117">        boolean braces = false;</span>

        /* Check that offset is in range */
<span class="nc" id="L120">        int offset = offset16[0];</span>
<span class="nc" id="L121">        int length = s.length();</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">        if (offset &lt; 0 || offset &gt;= length) {</span>
<span class="nc" id="L123">            return -1;</span>
        }

        /* Fetch first UChar after '\\' */
<span class="nc" id="L127">        c = UTF16.charAt(s, offset);</span>
<span class="nc" id="L128">        offset += UTF16.getCharCount(c);</span>

        /* Convert hexadecimal and octal escapes */
<span class="nc bnc" id="L131" title="All 4 branches missed.">        switch (c) {</span>
        case 'u':
<span class="nc" id="L133">            minDig = maxDig = 4;</span>
<span class="nc" id="L134">            break;</span>
        case 'U':
<span class="nc" id="L136">            minDig = maxDig = 8;</span>
<span class="nc" id="L137">            break;</span>
        case 'x':
<span class="nc" id="L139">            minDig = 1;</span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">            if (offset &lt; length &amp;&amp; UTF16.charAt(s, offset) == 0x7B /*{*/) {</span>
<span class="nc" id="L141">                ++offset;</span>
<span class="nc" id="L142">                braces = true;</span>
<span class="nc" id="L143">                maxDig = 8;</span>
            } else {
<span class="nc" id="L145">                maxDig = 2;</span>
            }
<span class="nc" id="L147">            break;</span>
        default:
<span class="nc" id="L149">            dig = UCharacter.digit(c, 8);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (dig &gt;= 0) {</span>
<span class="nc" id="L151">                minDig = 1;</span>
<span class="nc" id="L152">                maxDig = 3;</span>
<span class="nc" id="L153">                n = 1; /* Already have first octal digit */</span>
<span class="nc" id="L154">                bitsPerDigit = 3;</span>
<span class="nc" id="L155">                result = dig;</span>
            }
            break;
        }
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (minDig != 0) {</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">            while (offset &lt; length &amp;&amp; n &lt; maxDig) {</span>
<span class="nc" id="L161">                c = UTF16.charAt(s, offset);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                dig = UCharacter.digit(c, (bitsPerDigit == 3) ? 8 : 16);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (dig &lt; 0) {</span>
<span class="nc" id="L164">                    break;</span>
                }
<span class="nc" id="L166">                result = (result &lt;&lt; bitsPerDigit) | dig;</span>
<span class="nc" id="L167">                offset += UTF16.getCharCount(c);</span>
<span class="nc" id="L168">                ++n;</span>
            }
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (n &lt; minDig) {</span>
<span class="nc" id="L171">                return -1;</span>
            }
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (braces) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">                if (c != 0x7D /*}*/) {</span>
<span class="nc" id="L175">                    return -1;</span>
                }
<span class="nc" id="L177">                ++offset;</span>
            }
<span class="nc bnc" id="L179" title="All 4 branches missed.">            if (result &lt; 0 || result &gt;= 0x110000) {</span>
<span class="nc" id="L180">                return -1;</span>
            }
            // If an escape sequence specifies a lead surrogate, see
            // if there is a trail surrogate after it, either as an
            // escape or as a literal.  If so, join them up into a
            // supplementary.
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (offset &lt; length &amp;&amp;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                UTF16.isLeadSurrogate((char) result)) {</span>
<span class="nc" id="L188">                int ahead = offset+1;</span>
<span class="nc" id="L189">                c = s.charAt(offset); // [sic] get 16-bit code unit</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">                if (c == '\\' &amp;&amp; ahead &lt; length) {</span>
<span class="nc" id="L191">                    int o[] = new int[] { ahead };</span>
<span class="nc" id="L192">                    c = unescapeAt(s, o);</span>
<span class="nc" id="L193">                    ahead = o[0];</span>
                }
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (UTF16.isTrailSurrogate((char) c)) {</span>
<span class="nc" id="L196">                    offset = ahead;</span>
<span class="nc" id="L197">                result = UCharacterProperty.getRawSupplementary(</span>
                                  (char) result, (char) c);
                }
            }
<span class="nc" id="L201">            offset16[0] = offset;</span>
<span class="nc" id="L202">            return result;</span>
        }

        /* Convert C-style escapes in table */
<span class="nc bnc" id="L206" title="All 2 branches missed.">        for (i=0; i&lt;UNESCAPE_MAP.length; i+=2) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (c == UNESCAPE_MAP[i]) {</span>
<span class="nc" id="L208">                offset16[0] = offset;</span>
<span class="nc" id="L209">                return UNESCAPE_MAP[i+1];</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            } else if (c &lt; UNESCAPE_MAP[i]) {</span>
<span class="nc" id="L211">                break;</span>
            }
        }

        /* Map \cX to control-X: X &amp; 0x1F */
<span class="nc bnc" id="L216" title="All 4 branches missed.">        if (c == 'c' &amp;&amp; offset &lt; length) {</span>
<span class="nc" id="L217">            c = UTF16.charAt(s, offset);</span>
<span class="nc" id="L218">            offset16[0] = offset + UTF16.getCharCount(c);</span>
<span class="nc" id="L219">            return 0x1F &amp; c;</span>
        }

        /* If no special forms are recognized, then consider
         * the backslash to generically escape the next character. */
<span class="nc" id="L224">        offset16[0] = offset;</span>
<span class="nc" id="L225">        return c;</span>
    }

    /**
     * Convert a integer to size width hex uppercase digits.
     * E.g., hex('a', 4, str) =&gt; &quot;0041&quot;.
     * Append the output to the given StringBuffer.
     * If width is too small to fit, nothing will be appended to output.
     */
    public static StringBuffer hex(int ch, int width, StringBuffer output) {
<span class="nc" id="L235">        return appendNumber(output, ch, 16, width);</span>
    }

    /**
     * Convert a integer to size width (minimum) hex uppercase digits.
     * E.g., hex('a', 4, str) =&gt; &quot;0041&quot;.  If the integer requires more
     * than width digits, more will be used.
     */
    public static String hex(int ch, int width) {
<span class="nc" id="L244">        StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L245">        return appendNumber(buf, ch, 16, width).toString();</span>
    }

    /**
     * Skip over a sequence of zero or more white space characters
     * at pos.  Return the index of the first non-white-space character
     * at or after pos, or str.length(), if there is none.
     */
    public static int skipWhitespace(String str, int pos) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        while (pos &lt; str.length()) {</span>
<span class="nc" id="L255">            int c = UTF16.charAt(str, pos);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (!UCharacterProperty.isRuleWhiteSpace(c)) {</span>
<span class="nc" id="L257">                break;</span>
            }
<span class="nc" id="L259">            pos += UTF16.getCharCount(c);</span>
<span class="nc" id="L260">        }</span>
<span class="nc" id="L261">        return pos;</span>
    }

<span class="nc" id="L264">    static final char DIGITS[] = {</span>
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z'
    };

    /**
     * Append the digits of a positive integer to the given
     * &lt;code&gt;StringBuffer&lt;/code&gt; in the given radix. This is
     * done recursively since it is easiest to generate the low-
     * order digit first, but it must be appended last.
     *
     * @param result is the &lt;code&gt;StringBuffer&lt;/code&gt; to append to
     * @param n is the positive integer
     * @param radix is the radix, from 2 to 36 inclusive
     * @param minDigits is the minimum number of digits to append.
     */
    private static void recursiveAppendNumber(StringBuffer result, int n,
                                                int radix, int minDigits)
    {
<span class="nc" id="L285">        int digit = n % radix;</span>

<span class="nc bnc" id="L287" title="All 4 branches missed.">        if (n &gt;= radix || minDigits &gt; 1) {</span>
<span class="nc" id="L288">            recursiveAppendNumber(result, n / radix, radix, minDigits - 1);</span>
        }

<span class="nc" id="L291">        result.append(DIGITS[digit]);</span>
<span class="nc" id="L292">    }</span>

    /**
     * Append a number to the given StringBuffer in the given radix.
     * Standard digits '0'-'9' are used and letters 'A'-'Z' for
     * radices 11 through 36.
     * @param result the digits of the number are appended here
     * @param n the number to be converted to digits; may be negative.
     * If negative, a '-' is prepended to the digits.
     * @param radix a radix from 2 to 36 inclusive.
     * @param minDigits the minimum number of digits, not including
     * any '-', to produce.  Values less than 2 have no effect.  One
     * digit is always emitted regardless of this parameter.
     * @return a reference to result
     */
    public static StringBuffer appendNumber(StringBuffer result, int n,
                                             int radix, int minDigits)
        throws IllegalArgumentException
    {
<span class="nc bnc" id="L311" title="All 4 branches missed.">        if (radix &lt; 2 || radix &gt; 36) {</span>
<span class="nc" id="L312">            throw new IllegalArgumentException(&quot;Illegal radix &quot; + radix);</span>
        }


<span class="nc" id="L316">        int abs = n;</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (n &lt; 0) {</span>
<span class="nc" id="L319">            abs = -n;</span>
<span class="nc" id="L320">            result.append(&quot;-&quot;);</span>
        }

<span class="nc" id="L323">        recursiveAppendNumber(result, abs, radix, minDigits);</span>

<span class="nc" id="L325">        return result;</span>
    }

    /**
     * Return true if the character is NOT printable ASCII.  The tab,
     * newline and linefeed characters are considered unprintable.
     */
    public static boolean isUnprintable(int c) {
<span class="nc bnc" id="L333" title="All 4 branches missed.">        return !(c &gt;= 0x20 &amp;&amp; c &lt;= 0x7E);</span>
    }

    /**
     * Escape unprintable characters using &lt;backslash&gt;uxxxx notation
     * for U+0000 to U+FFFF and &lt;backslash&gt;Uxxxxxxxx for U+10000 and
     * above.  If the character is printable ASCII, then do nothing
     * and return FALSE.  Otherwise, append the escaped notation and
     * return TRUE.
     */
    public static boolean escapeUnprintable(StringBuffer result, int c) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (isUnprintable(c)) {</span>
<span class="nc" id="L345">            result.append('\\');</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if ((c &amp; ~0xFFFF) != 0) {</span>
<span class="nc" id="L347">                result.append('U');</span>
<span class="nc" id="L348">                result.append(DIGITS[0xF&amp;(c&gt;&gt;28)]);</span>
<span class="nc" id="L349">                result.append(DIGITS[0xF&amp;(c&gt;&gt;24)]);</span>
<span class="nc" id="L350">                result.append(DIGITS[0xF&amp;(c&gt;&gt;20)]);</span>
<span class="nc" id="L351">                result.append(DIGITS[0xF&amp;(c&gt;&gt;16)]);</span>
            } else {
<span class="nc" id="L353">                result.append('u');</span>
            }
<span class="nc" id="L355">            result.append(DIGITS[0xF&amp;(c&gt;&gt;12)]);</span>
<span class="nc" id="L356">            result.append(DIGITS[0xF&amp;(c&gt;&gt;8)]);</span>
<span class="nc" id="L357">            result.append(DIGITS[0xF&amp;(c&gt;&gt;4)]);</span>
<span class="nc" id="L358">            result.append(DIGITS[0xF&amp;c]);</span>
<span class="nc" id="L359">            return true;</span>
        }
<span class="nc" id="L361">        return false;</span>
    }

    /**
    * Similar to StringBuffer.getChars, version 1.3.
    * Since JDK 1.2 implements StringBuffer.getChars differently, this method
    * is here to provide consistent results.
    * To be removed after JDK 1.2 ceased to be the reference platform.
    * @param src source string buffer
    * @param srcBegin offset to the start of the src to retrieve from
    * @param srcEnd offset to the end of the src to retrieve from
    * @param dst char array to store the retrieved chars
    * @param dstBegin offset to the start of the destination char array to
    *                 store the retrieved chars
    */
    public static void getChars(StringBuffer src, int srcBegin, int srcEnd,
                                char dst[], int dstBegin)
    {
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (srcBegin == srcEnd) {</span>
<span class="nc" id="L380">            return;</span>
        }
<span class="nc" id="L382">        src.getChars(srcBegin, srcEnd, dst, dstBegin);</span>
<span class="nc" id="L383">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>