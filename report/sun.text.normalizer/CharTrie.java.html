<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CharTrie.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">CharTrie.java</span></div><h1>CharTrie.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

import java.io.InputStream;
import java.io.DataInputStream;
import java.io.IOException;

/**
 * Trie implementation which stores data in char, 16 bits.
 * @author synwee
 * @see com.ibm.icu.impl.Trie
 * @since release 2.1, Jan 01 2002
 */

 // note that i need to handle the block calculations later, since chartrie
 // in icu4c uses the same index array.
public class CharTrie extends Trie
{
    // public constructors ---------------------------------------------

    /**
    * &lt;p&gt;Creates a new Trie with the settings for the trie data.&lt;/p&gt;
    * &lt;p&gt;Unserialize the 32-bit-aligned input stream and use the data for the
    * trie.&lt;/p&gt;
    * @param inputStream file input stream to a ICU data file, containing
    *                    the trie
    * @param dataManipulate object which provides methods to parse the char
    *                        data
    * @throws IOException thrown when data reading fails
    * @draft 2.1
    */
    public CharTrie(InputStream inputStream,
                    DataManipulate dataManipulate) throws IOException
    {
<span class="fc" id="L70">        super(inputStream, dataManipulate);</span>

<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (!isCharTrie()) {</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(</span>
                               &quot;Data given does not belong to a char trie.&quot;);
        }
<span class="fc" id="L76">        m_friendAgent_ = new FriendAgent();</span>
<span class="fc" id="L77">    }</span>

    /**
     * Make a dummy CharTrie.
     * A dummy trie is an empty runtime trie, used when a real data trie cannot
     * be loaded.
     *
     * The trie always returns the initialValue,
     * or the leadUnitValue for lead surrogate code points.
     * The Latin-1 part is always set up to be linear.
     *
     * @param initialValue the initial value that is set for all code points
     * @param leadUnitValue the value for lead surrogate code _units_ that do not
     *                      have associated supplementary data
     * @param dataManipulate object which provides methods to parse the char data
     */
    public CharTrie(int initialValue, int leadUnitValue, DataManipulate dataManipulate) {
<span class="nc" id="L94">        super(new char[BMP_INDEX_LENGTH+SURROGATE_BLOCK_COUNT], HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_, dataManipulate);</span>

        int dataLength, latin1Length, i, limit;
        char block;

        /* calculate the actual size of the dummy trie data */

        /* max(Latin-1, block 0) */
<span class="nc" id="L102">        dataLength=latin1Length= INDEX_STAGE_1_SHIFT_&lt;=8 ? 256 : DATA_BLOCK_LENGTH;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if(leadUnitValue!=initialValue) {</span>
<span class="nc" id="L104">            dataLength+=DATA_BLOCK_LENGTH;</span>
        }
<span class="nc" id="L106">        m_data_=new char[dataLength];</span>
<span class="nc" id="L107">        m_dataLength_=dataLength;</span>

<span class="nc" id="L109">        m_initialValue_=(char)initialValue;</span>

        /* fill the index and data arrays */

        /* indexes are preset to 0 (block 0) */

        /* Latin-1 data */
<span class="nc bnc" id="L116" title="All 2 branches missed.">        for(i=0; i&lt;latin1Length; ++i) {</span>
<span class="nc" id="L117">            m_data_[i]=(char)initialValue;</span>
        }

<span class="nc bnc" id="L120" title="All 2 branches missed.">        if(leadUnitValue!=initialValue) {</span>
            /* indexes for lead surrogate code units to the block after Latin-1 */
<span class="nc" id="L122">            block=(char)(latin1Length&gt;&gt;INDEX_STAGE_2_SHIFT_);</span>
<span class="nc" id="L123">            i=0xd800&gt;&gt;INDEX_STAGE_1_SHIFT_;</span>
<span class="nc" id="L124">            limit=0xdc00&gt;&gt;INDEX_STAGE_1_SHIFT_;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            for(; i&lt;limit; ++i) {</span>
<span class="nc" id="L126">                m_index_[i]=block;</span>
            }

            /* data for lead surrogate code units */
<span class="nc" id="L130">            limit=latin1Length+DATA_BLOCK_LENGTH;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            for(i=latin1Length; i&lt;limit; ++i) {</span>
<span class="nc" id="L132">                m_data_[i]=(char)leadUnitValue;</span>
            }
        }

<span class="nc" id="L136">        m_friendAgent_ = new FriendAgent();</span>
<span class="nc" id="L137">    }</span>

    /**
     * Java friend implementation
     */
<span class="fc" id="L142">    public class FriendAgent</span>
    {
        /**
         * Gives out the index array of the trie
         * @return index array of trie
         */
        public char[] getPrivateIndex()
        {
<span class="nc" id="L150">            return m_index_;</span>
        }
        /**
         * Gives out the data array of the trie
         * @return data array of trie
         */
        public char[] getPrivateData()
        {
<span class="nc" id="L158">            return m_data_;</span>
        }
        /**
         * Gives out the data offset in the trie
         * @return data offset in the trie
         */
        public int getPrivateInitialValue()
        {
<span class="nc" id="L166">            return m_initialValue_;</span>
        }
    }

    // public methods --------------------------------------------------

    /**
     * Java friend implementation
     * To store the index and data array into the argument.
     * @param friend java friend UCharacterProperty object to store the array
     */
    public void putIndexData(UCharacterProperty friend)
    {
<span class="nc" id="L179">        friend.setIndexData(m_friendAgent_);</span>
<span class="nc" id="L180">    }</span>

    /**
    * Gets the value associated with the codepoint.
    * If no value is associated with the codepoint, a default value will be
    * returned.
    * @param ch codepoint
    * @return offset to data
    * @draft 2.1
    */
    public final char getCodePointValue(int ch)
    {
        int offset;

        // fastpath for U+0000..U+D7FF
<span class="nc bnc" id="L195" title="All 4 branches missed.">        if(0 &lt;= ch &amp;&amp; ch &lt; UTF16.LEAD_SURROGATE_MIN_VALUE) {</span>
            // copy of getRawOffset()
<span class="nc" id="L197">            offset = (m_index_[ch &gt;&gt; INDEX_STAGE_1_SHIFT_] &lt;&lt; INDEX_STAGE_2_SHIFT_)</span>
                    + (ch &amp; INDEX_STAGE_3_MASK_);
<span class="nc" id="L199">            return m_data_[offset];</span>
        }

        // handle U+D800..U+10FFFF
<span class="nc" id="L203">        offset = getCodePointOffset(ch);</span>

        // return -1 if there is an error, in this case we return the default
        // value: m_initialValue_
<span class="nc bnc" id="L207" title="All 2 branches missed.">        return (offset &gt;= 0) ? m_data_[offset] : m_initialValue_;</span>
    }

    /**
    * Gets the value to the data which this lead surrogate character points
    * to.
    * Returned data may contain folding offset information for the next
    * trailing surrogate character.
    * This method does not guarantee correct results for trail surrogates.
    * @param ch lead surrogate character
    * @return data value
    * @draft 2.1
    */
    public final char getLeadValue(char ch)
    {
<span class="nc" id="L222">       return m_data_[getLeadOffset(ch)];</span>
    }

    /**
    * Get the value associated with a pair of surrogates.
    * @param lead a lead surrogate
    * @param trail a trail surrogate
    * @draft 2.1
    */
    public final char getSurrogateValue(char lead, char trail)
    {
<span class="nc" id="L233">        int offset = getSurrogateOffset(lead, trail);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (offset &gt; 0) {</span>
<span class="nc" id="L235">            return m_data_[offset];</span>
        }
<span class="nc" id="L237">        return m_initialValue_;</span>
    }

    /**
    * &lt;p&gt;Get a value from a folding offset (from the value of a lead surrogate)
    * and a trail surrogate.&lt;/p&gt;
    * &lt;p&gt;If the
    * @param leadvalue value associated with the lead surrogate which contains
    *        the folding offset
    * @param trail surrogate
    * @return trie data value associated with the trail character
    * @draft 2.1
    */
    public final char getTrailValue(int leadvalue, char trail)
    {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (m_dataManipulate_ == null) {</span>
<span class="nc" id="L253">            throw new NullPointerException(</span>
                             &quot;The field DataManipulate in this Trie is null&quot;);
        }
<span class="nc" id="L256">        int offset = m_dataManipulate_.getFoldingOffset(leadvalue);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (offset &gt; 0) {</span>
<span class="nc" id="L258">            return m_data_[getRawOffset(offset,</span>
                                        (char)(trail &amp; SURROGATE_MASK_))];
        }
<span class="nc" id="L261">        return m_initialValue_;</span>
    }

    // protected methods -----------------------------------------------

    /**
    * &lt;p&gt;Parses the input stream and stores its trie content into a index and
    * data array&lt;/p&gt;
    * @param inputStream data input stream containing trie data
    * @exception IOException thrown when data reading fails
    */
    protected final void unserialize(InputStream inputStream)
                                                throws IOException
    {
<span class="fc" id="L275">        DataInputStream input = new DataInputStream(inputStream);</span>
<span class="fc" id="L276">        int indexDataLength = m_dataOffset_ + m_dataLength_;</span>
<span class="fc" id="L277">        m_index_ = new char[indexDataLength];</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (int i = 0; i &lt; indexDataLength; i ++) {</span>
<span class="fc" id="L279">            m_index_[i] = input.readChar();</span>
        }
<span class="fc" id="L281">        m_data_           = m_index_;</span>
<span class="fc" id="L282">        m_initialValue_   = m_data_[m_dataOffset_];</span>
<span class="fc" id="L283">    }</span>

    /**
    * Gets the offset to the data which the surrogate pair points to.
    * @param lead lead surrogate
    * @param trail trailing surrogate
    * @return offset to data
    * @draft 2.1
    */
    protected final int getSurrogateOffset(char lead, char trail)
    {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (m_dataManipulate_ == null) {</span>
<span class="nc" id="L295">            throw new NullPointerException(</span>
                             &quot;The field DataManipulate in this Trie is null&quot;);
        }

        // get fold position for the next trail surrogate
<span class="nc" id="L300">        int offset = m_dataManipulate_.getFoldingOffset(getLeadValue(lead));</span>

        // get the real data from the folded lead/trail units
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (offset &gt; 0) {</span>
<span class="nc" id="L304">            return getRawOffset(offset, (char)(trail &amp; SURROGATE_MASK_));</span>
        }

        // return -1 if there is an error, in this case we return the default
        // value: m_initialValue_
<span class="nc" id="L309">        return -1;</span>
    }

    /**
    * Gets the value at the argument index.
    * For use internally in TrieIterator.
    * @param index value at index will be retrieved
    * @return 32 bit value
    * @see com.ibm.icu.impl.TrieIterator
    * @draft 2.1
    */
    protected final int getValue(int index)
    {
<span class="nc" id="L322">        return m_data_[index];</span>
    }

    /**
    * Gets the default initial value
    * @return 32 bit value
    * @draft 2.1
    */
    protected final int getInitialValue()
    {
<span class="nc" id="L332">        return m_initialValue_;</span>
    }

    // private data members --------------------------------------------

    /**
    * Default value
    */
    private char m_initialValue_;
    /**
    * Array of char data
    */
    private char m_data_[];
    /**
     * Agent for friends
     */
    private FriendAgent m_friendAgent_;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>