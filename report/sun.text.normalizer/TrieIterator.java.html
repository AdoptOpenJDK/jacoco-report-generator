<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>TrieIterator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">TrieIterator.java</span></div><h1>TrieIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

/**
 * &lt;p&gt;Class enabling iteration of the values in a Trie.&lt;/p&gt;
 * &lt;p&gt;Result of each iteration contains the interval of codepoints that have
 * the same value type and the value type itself.&lt;/p&gt;
 * &lt;p&gt;The comparison of each codepoint value is done via extract(), which the
 * default implementation is to return the value as it is.&lt;/p&gt;
 * &lt;p&gt;Method extract() can be overwritten to perform manipulations on
 * codepoint values in order to perform specialized comparison.&lt;/p&gt;
 * &lt;p&gt;TrieIterator is designed to be a generic iterator for the CharTrie
 * and the IntTrie, hence to accommodate both types of data, the return
 * result will be in terms of int (32 bit) values.&lt;/p&gt;
 * &lt;p&gt;See com.ibm.icu.text.UCharacterTypeIterator for examples of use.&lt;/p&gt;
 * &lt;p&gt;Notes for porting utrie_enum from icu4c to icu4j:&lt;br&gt;
 * Internally, icu4c's utrie_enum performs all iterations in its body. In Java
 * sense, the caller will have to pass a object with a callback function
 * UTrieEnumRange(const void *context, UChar32 start, UChar32 limit,
 * uint32_t value) into utrie_enum. utrie_enum will then find ranges of
 * codepoints with the same value as determined by
 * UTrieEnumValue(const void *context, uint32_t value). for each range,
 * utrie_enum calls the callback function to perform a task. In this way,
 * icu4c performs the iteration within utrie_enum.
 * To follow the JDK model, icu4j is slightly different from icu4c.
 * Instead of requesting the caller to implement an object for a callback.
 * The caller will have to implement a subclass of TrieIterator, fleshing out
 * the method extract(int) (equivalent to UTrieEnumValue). Independent of icu4j,
 * the caller will have to code his own iteration and flesh out the task
 * (equivalent to UTrieEnumRange) to be performed in the iteration loop.
 * &lt;/p&gt;
 * &lt;p&gt;There are basically 3 usage scenarios for porting:&lt;/p&gt;
 * &lt;p&gt;1) UTrieEnumValue is the only implemented callback then just implement a
 * subclass of TrieIterator and override the extract(int) method. The
 * extract(int) method is analogus to UTrieEnumValue callback.
 * &lt;/p&gt;
 * &lt;p&gt;2) UTrieEnumValue and UTrieEnumRange both are implemented then implement
 * a subclass of TrieIterator, override the extract method and iterate, e.g
 * &lt;/p&gt;
 * &lt;p&gt;utrie_enum(&amp;normTrie, _enumPropertyStartsValue, _enumPropertyStartsRange,
 *               set);&lt;br&gt;
 * In Java :&lt;br&gt;
 * &lt;pre&gt;
 * class TrieIteratorImpl extends TrieIterator{
 *     public TrieIteratorImpl(Trie data){
 *         super(data);
 *     }
 *     public int extract(int value){
 *         // port the implementation of _enumPropertyStartsValue here
 *     }
 * }
 * ....
 * TrieIterator fcdIter  = new TrieIteratorImpl(fcdTrieImpl.fcdTrie);
 * while(fcdIter.next(result)) {
 *     // port the implementation of _enumPropertyStartsRange
 * }
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;3) UTrieEnumRange is the only implemented callback then just implement
 * the while loop, when utrie_enum is called
 * &lt;pre&gt;
 * // utrie_enum(&amp;fcdTrie, NULL, _enumPropertyStartsRange, set);
 * TrieIterator fcdIter  = new TrieIterator(fcdTrieImpl.fcdTrie);
 * while(fcdIter.next(result)){
 *     set.add(result.start);
 * }
 * &lt;/pre&gt;
 * &lt;/p&gt;
 * @author synwee
 * @see com.ibm.icu.impl.Trie
 * @see com.ibm.icu.lang.UCharacterTypeIterator
 * @since release 2.1, Jan 17 2002
 */
public class TrieIterator implements RangeValueIterator
{

    // public constructor ---------------------------------------------

    /**
    * TrieEnumeration constructor
    * @param trie to be used
    * @exception IllegalArgumentException throw when argument is null.
    */
    public TrieIterator(Trie trie)
<span class="nc" id="L120">    {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (trie == null) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(</span>
                                          &quot;Argument trie cannot be null&quot;);
        }
<span class="nc" id="L125">        m_trie_             = trie;</span>
        // synwee: check that extract belongs to the child class
<span class="nc" id="L127">        m_initialValue_     = extract(m_trie_.getInitialValue());</span>
<span class="nc" id="L128">        reset();</span>
<span class="nc" id="L129">    }</span>

    // public methods -------------------------------------------------

    /**
    * &lt;p&gt;Returns true if we are not at the end of the iteration, false
    * otherwise.&lt;/p&gt;
    * &lt;p&gt;The next set of codepoints with the same value type will be
    * calculated during this call and returned in the arguement element.&lt;/p&gt;
    * @param element return result
    * @return true if we are not at the end of the iteration, false otherwise.
    * @exception NoSuchElementException - if no more elements exist.
    * @see com.ibm.icu.util.RangeValueIterator.Element
    */
    public final boolean next(Element element)
    {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (m_nextCodepoint_ &gt; UCharacter.MAX_VALUE) {</span>
<span class="nc" id="L146">            return false;</span>
        }
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (m_nextCodepoint_ &lt; UCharacter.SUPPLEMENTARY_MIN_VALUE &amp;&amp;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            calculateNextBMPElement(element)) {</span>
<span class="nc" id="L150">            return true;</span>
        }
<span class="nc" id="L152">        calculateNextSupplementaryElement(element);</span>
<span class="nc" id="L153">        return true;</span>
    }

    /**
    * Resets the iterator to the beginning of the iteration
    */
    public final void reset()
    {
<span class="nc" id="L161">        m_currentCodepoint_ = 0;</span>
<span class="nc" id="L162">        m_nextCodepoint_    = 0;</span>
<span class="nc" id="L163">        m_nextIndex_        = 0;</span>
<span class="nc" id="L164">        m_nextBlock_ = m_trie_.m_index_[0] &lt;&lt; Trie.INDEX_STAGE_2_SHIFT_;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (m_nextBlock_ == 0) {</span>
<span class="nc" id="L166">            m_nextValue_ = m_initialValue_;</span>
        }
        else {
<span class="nc" id="L169">            m_nextValue_ = extract(m_trie_.getValue(m_nextBlock_));</span>
        }
<span class="nc" id="L171">        m_nextBlockIndex_ = 0;</span>
<span class="nc" id="L172">        m_nextTrailIndexOffset_ = TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_;</span>
<span class="nc" id="L173">    }</span>

    // protected methods ----------------------------------------------

    /**
    * Called by next() to extracts a 32 bit value from a trie value
    * used for comparison.
    * This method is to be overwritten if special manipulation is to be done
    * to retrieve a relevant comparison.
    * The default function is to return the value as it is.
    * @param value a value from the trie
    * @return extracted value
    */
    protected int extract(int value)
    {
<span class="nc" id="L188">        return value;</span>
    }

    // private methods ------------------------------------------------

    /**
    * Set the result values
    * @param element return result object
    * @param start codepoint of range
    * @param limit (end + 1) codepoint of range
    * @param value common value of range
    */
    private final void setResult(Element element, int start, int limit,
                                 int value)
    {
<span class="nc" id="L203">        element.start = start;</span>
<span class="nc" id="L204">        element.limit = limit;</span>
<span class="nc" id="L205">        element.value = value;</span>
<span class="nc" id="L206">    }</span>

    /**
    * Finding the next element.
    * This method is called just before returning the result of
    * next().
    * We always store the next element before it is requested.
    * In the case that we have to continue calculations into the
    * supplementary planes, a false will be returned.
    * @param element return result object
    * @return true if the next range is found, false if we have to proceed to
    *         the supplementary range.
    */
    private final boolean calculateNextBMPElement(Element element)
    {
<span class="nc" id="L221">        int currentBlock    = m_nextBlock_;</span>
<span class="nc" id="L222">        int currentValue    = m_nextValue_;</span>
<span class="nc" id="L223">        m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L224">        m_nextCodepoint_ ++;</span>
<span class="nc" id="L225">        m_nextBlockIndex_ ++;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (!checkBlockDetail(currentValue)) {</span>
<span class="nc" id="L227">            setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                      currentValue);
<span class="nc" id="L229">            return true;</span>
        }
        // synwee check that next block index == 0 here
        // enumerate BMP - the main loop enumerates data blocks
<span class="nc bnc" id="L233" title="All 2 branches missed.">        while (m_nextCodepoint_ &lt; UCharacter.SUPPLEMENTARY_MIN_VALUE) {</span>
<span class="nc" id="L234">            m_nextIndex_ ++;</span>
            // because of the way the character is split to form the index
            // the lead surrogate and trail surrogate can not be in the
            // mid of a block
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (m_nextCodepoint_ == LEAD_SURROGATE_MIN_VALUE_) {</span>
                // skip lead surrogate code units,
                // go to lead surrogate codepoints
<span class="nc" id="L241">                m_nextIndex_ = BMP_INDEX_LENGTH_;</span>
            }
<span class="nc bnc" id="L243" title="All 2 branches missed.">            else if (m_nextCodepoint_ == TRAIL_SURROGATE_MIN_VALUE_) {</span>
                // go back to regular BMP code points
<span class="nc" id="L245">                m_nextIndex_ = m_nextCodepoint_ &gt;&gt; Trie.INDEX_STAGE_1_SHIFT_;</span>
            }

<span class="nc" id="L248">            m_nextBlockIndex_ = 0;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (!checkBlock(currentBlock, currentValue)) {</span>
<span class="nc" id="L250">                setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                          currentValue);
<span class="nc" id="L252">                return true;</span>
            }
        }
<span class="nc" id="L255">        m_nextCodepoint_ --;   // step one back since this value has not been</span>
<span class="nc" id="L256">        m_nextBlockIndex_ --;  // retrieved yet.</span>
<span class="nc" id="L257">        return false;</span>
    }

    /**
    * Finds the next supplementary element.
    * For each entry in the trie, the value to be delivered is passed through
    * extract().
    * We always store the next element before it is requested.
    * Called after calculateNextBMP() completes its round of BMP characters.
    * There is a slight difference in the usage of m_currentCodepoint_
    * here as compared to calculateNextBMP(). Though both represents the
    * lower bound of the next element, in calculateNextBMP() it gets set
    * at the start of any loop, where-else, in calculateNextSupplementary()
    * since m_currentCodepoint_ already contains the lower bound of the
    * next element (passed down from calculateNextBMP()), we keep it till
    * the end before resetting it to the new value.
    * Note, if there are no more iterations, it will never get to here.
    * Blocked out by next().
    * @param element return result object
    */
    private final void calculateNextSupplementaryElement(Element element)
    {
<span class="nc" id="L279">        int currentValue = m_nextValue_;</span>
<span class="nc" id="L280">        int currentBlock = m_nextBlock_;</span>
<span class="nc" id="L281">        m_nextCodepoint_ ++;</span>
<span class="nc" id="L282">        m_nextBlockIndex_ ++;</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (UTF16.getTrailSurrogate(m_nextCodepoint_)</span>
                                        != UTF16.TRAIL_SURROGATE_MIN_VALUE) {
            // this piece is only called when we are in the middle of a lead
            // surrogate block
<span class="nc bnc" id="L288" title="All 4 branches missed.">            if (!checkNullNextTrailIndex() &amp;&amp; !checkBlockDetail(currentValue)) {</span>
<span class="nc" id="L289">                setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                          currentValue);
<span class="nc" id="L291">                m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L292">                return;</span>
            }
            // we have cleared one block
<span class="nc" id="L295">            m_nextIndex_ ++;</span>
<span class="nc" id="L296">            m_nextTrailIndexOffset_ ++;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if (!checkTrailBlock(currentBlock, currentValue)) {</span>
<span class="nc" id="L298">                setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                          currentValue);
<span class="nc" id="L300">                m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L301">                return;</span>
            }
        }
<span class="nc" id="L304">        int nextLead  = UTF16.getLeadSurrogate(m_nextCodepoint_);</span>
        // enumerate supplementary code points
<span class="nc bnc" id="L306" title="All 2 branches missed.">        while (nextLead &lt; TRAIL_SURROGATE_MIN_VALUE_) {</span>
            // lead surrogate access
<span class="nc" id="L308">            int leadBlock =</span>
                   m_trie_.m_index_[nextLead &gt;&gt; Trie.INDEX_STAGE_1_SHIFT_] &lt;&lt;
                                                   Trie.INDEX_STAGE_2_SHIFT_;
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (leadBlock == m_trie_.m_dataOffset_) {</span>
                // no entries for a whole block of lead surrogates
<span class="nc bnc" id="L313" title="All 2 branches missed.">                if (currentValue != m_initialValue_) {</span>
<span class="nc" id="L314">                    m_nextValue_      = m_initialValue_;</span>
<span class="nc" id="L315">                    m_nextBlock_      = 0;</span>
<span class="nc" id="L316">                    m_nextBlockIndex_ = 0;</span>
<span class="nc" id="L317">                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                              currentValue);
<span class="nc" id="L319">                    m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L320">                    return;</span>
                }

<span class="nc" id="L323">                nextLead += DATA_BLOCK_LENGTH_;</span>
                // number of total affected supplementary codepoints in one
                // block
                // this is not a simple addition of
                // DATA_BLOCK_SUPPLEMENTARY_LENGTH since we need to consider
                // that we might have moved some of the codepoints
<span class="nc" id="L329">                m_nextCodepoint_ = UCharacterProperty.getRawSupplementary(</span>
                                     (char)nextLead,
                                     (char)UTF16.TRAIL_SURROGATE_MIN_VALUE);
<span class="nc" id="L332">                continue;</span>
            }
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (m_trie_.m_dataManipulate_ == null) {</span>
<span class="nc" id="L335">                throw new NullPointerException(</span>
                            &quot;The field DataManipulate in this Trie is null&quot;);
            }
            // enumerate trail surrogates for this lead surrogate
<span class="nc" id="L339">            m_nextIndex_ = m_trie_.m_dataManipulate_.getFoldingOffset(</span>
<span class="nc" id="L340">                               m_trie_.getValue(leadBlock +</span>
                                   (nextLead &amp; Trie.INDEX_STAGE_3_MASK_)));
<span class="nc bnc" id="L342" title="All 2 branches missed.">            if (m_nextIndex_ &lt;= 0) {</span>
                // no data for this lead surrogate
<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (currentValue != m_initialValue_) {</span>
<span class="nc" id="L345">                    m_nextValue_      = m_initialValue_;</span>
<span class="nc" id="L346">                    m_nextBlock_      = 0;</span>
<span class="nc" id="L347">                    m_nextBlockIndex_ = 0;</span>
<span class="nc" id="L348">                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                              currentValue);
<span class="nc" id="L350">                    m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L351">                    return;</span>
                }
<span class="nc" id="L353">                m_nextCodepoint_ += TRAIL_SURROGATE_COUNT_;</span>
            } else {
<span class="nc" id="L355">                m_nextTrailIndexOffset_ = 0;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (!checkTrailBlock(currentBlock, currentValue)) {</span>
<span class="nc" id="L357">                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,</span>
                              currentValue);
<span class="nc" id="L359">                    m_currentCodepoint_ = m_nextCodepoint_;</span>
<span class="nc" id="L360">                    return;</span>
                }
            }
<span class="nc" id="L363">            nextLead ++;</span>
<span class="nc" id="L364">         }</span>

         // deliver last range
<span class="nc" id="L367">         setResult(element, m_currentCodepoint_, UCharacter.MAX_VALUE + 1,</span>
                   currentValue);
<span class="nc" id="L369">    }</span>

    /**
    * Internal block value calculations
    * Performs calculations on a data block to find codepoints in m_nextBlock_
    * after the index m_nextBlockIndex_ that has the same value.
    * Note m_*_ variables at this point is the next codepoint whose value
    * has not been calculated.
    * But when returned with false, it will be the last codepoint whose
    * value has been calculated.
    * @param currentValue the value which other codepoints are tested against
    * @return true if the whole block has the same value as currentValue or if
    *              the whole block has been calculated, false otherwise.
    */
    private final boolean checkBlockDetail(int currentValue)
    {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        while (m_nextBlockIndex_ &lt; DATA_BLOCK_LENGTH_) {</span>
<span class="nc" id="L386">            m_nextValue_ = extract(m_trie_.getValue(m_nextBlock_ +</span>
                                                    m_nextBlockIndex_));
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (m_nextValue_ != currentValue) {</span>
<span class="nc" id="L389">                return false;</span>
            }
<span class="nc" id="L391">            ++ m_nextBlockIndex_;</span>
<span class="nc" id="L392">            ++ m_nextCodepoint_;</span>
        }
<span class="nc" id="L394">        return true;</span>
    }

    /**
    * Internal block value calculations
    * Performs calculations on a data block to find codepoints in m_nextBlock_
    * that has the same value.
    * Will call checkBlockDetail() if highlevel check fails.
    * Note m_*_ variables at this point is the next codepoint whose value
    * has not been calculated.
    * @param currentBlock the initial block containing all currentValue
    * @param currentValue the value which other codepoints are tested against
    * @return true if the whole block has the same value as currentValue or if
    *              the whole block has been calculated, false otherwise.
    */
    private final boolean checkBlock(int currentBlock, int currentValue)
    {
<span class="nc" id="L411">        m_nextBlock_ = m_trie_.m_index_[m_nextIndex_] &lt;&lt;</span>
                                                  Trie.INDEX_STAGE_2_SHIFT_;
<span class="nc bnc" id="L413" title="All 4 branches missed.">        if (m_nextBlock_ == currentBlock &amp;&amp;</span>
            (m_nextCodepoint_ - m_currentCodepoint_) &gt;= DATA_BLOCK_LENGTH_) {
            // the block is the same as the previous one, filled with
            // currentValue
<span class="nc" id="L417">            m_nextCodepoint_ += DATA_BLOCK_LENGTH_;</span>
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        else if (m_nextBlock_ == 0) {</span>
            // this is the all-initial-value block
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (currentValue != m_initialValue_) {</span>
<span class="nc" id="L422">                m_nextValue_      = m_initialValue_;</span>
<span class="nc" id="L423">                m_nextBlockIndex_ = 0;</span>
<span class="nc" id="L424">                return false;</span>
            }
<span class="nc" id="L426">            m_nextCodepoint_ += DATA_BLOCK_LENGTH_;</span>
        }
        else {
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (!checkBlockDetail(currentValue)) {</span>
<span class="nc" id="L430">                return false;</span>
            }
        }
<span class="nc" id="L433">        return true;</span>
    }

    /**
    * Internal block value calculations
    * Performs calculations on multiple data blocks for a set of trail
    * surrogates to find codepoints in m_nextBlock_ that has the same value.
    * Will call checkBlock() for internal block checks.
    * Note m_*_ variables at this point is the next codepoint whose value
    * has not been calculated.
    * @param currentBlock the initial block containing all currentValue
    * @param currentValue the value which other codepoints are tested against
    * @return true if the whole block has the same value as currentValue or if
    *              the whole block has been calculated, false otherwise.
    */
    private final boolean checkTrailBlock(int currentBlock,
                                          int currentValue)
    {
        // enumerate code points for this lead surrogate
<span class="nc bnc" id="L452" title="All 2 branches missed.">        while (m_nextTrailIndexOffset_ &lt; TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_)</span>
        {
            // if we ever reach here, we are at the start of a new block
<span class="nc" id="L455">            m_nextBlockIndex_ = 0;</span>
            // copy of most of the body of the BMP loop
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (!checkBlock(currentBlock, currentValue)) {</span>
<span class="nc" id="L458">                return false;</span>
            }
<span class="nc" id="L460">            m_nextTrailIndexOffset_ ++;</span>
<span class="nc" id="L461">            m_nextIndex_ ++;</span>
        }
<span class="nc" id="L463">        return true;</span>
    }

    /**
    * Checks if we are beginning at the start of a initial block.
    * If we are then the rest of the codepoints in this initial block
    * has the same values.
    * We increment m_nextCodepoint_ and relevant data members if so.
    * This is used only in for the supplementary codepoints because
    * the offset to the trail indexes could be 0.
    * @return true if we are at the start of a initial block.
    */
    private final boolean checkNullNextTrailIndex()
    {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (m_nextIndex_ &lt;= 0) {</span>
<span class="nc" id="L478">            m_nextCodepoint_ += TRAIL_SURROGATE_COUNT_ - 1;</span>
<span class="nc" id="L479">            int nextLead  = UTF16.getLeadSurrogate(m_nextCodepoint_);</span>
<span class="nc" id="L480">            int leadBlock =</span>
                   m_trie_.m_index_[nextLead &gt;&gt; Trie.INDEX_STAGE_1_SHIFT_] &lt;&lt;
                                                   Trie.INDEX_STAGE_2_SHIFT_;
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (m_trie_.m_dataManipulate_ == null) {</span>
<span class="nc" id="L484">                throw new NullPointerException(</span>
                            &quot;The field DataManipulate in this Trie is null&quot;);
            }
<span class="nc" id="L487">            m_nextIndex_ = m_trie_.m_dataManipulate_.getFoldingOffset(</span>
<span class="nc" id="L488">                               m_trie_.getValue(leadBlock +</span>
                                   (nextLead &amp; Trie.INDEX_STAGE_3_MASK_)));
<span class="nc" id="L490">            m_nextIndex_ --;</span>
<span class="nc" id="L491">            m_nextBlockIndex_ =  DATA_BLOCK_LENGTH_;</span>
<span class="nc" id="L492">            return true;</span>
        }
<span class="nc" id="L494">        return false;</span>
    }

    // private data members --------------------------------------------

    /**
    * Size of the stage 1 BMP indexes
    */
    private static final int BMP_INDEX_LENGTH_ =
                                        0x10000 &gt;&gt; Trie.INDEX_STAGE_1_SHIFT_;
    /**
    * Lead surrogate minimum value
    */
    private static final int LEAD_SURROGATE_MIN_VALUE_ = 0xD800;
    /**
    * Trail surrogate minimum value
    */
    private static final int TRAIL_SURROGATE_MIN_VALUE_ = 0xDC00;
    /**
    * Number of trail surrogate
    */
    private static final int TRAIL_SURROGATE_COUNT_ = 0x400;
    /**
    * Number of stage 1 indexes for supplementary calculations that maps to
    * each lead surrogate character.
    * See second pass into getRawOffset for the trail surrogate character.
    * 10 for significant number of bits for trail surrogates, 5 for what we
    * discard during shifting.
    */
    private static final int TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_ =
                                    1 &lt;&lt; (10 - Trie.INDEX_STAGE_1_SHIFT_);
    /**
    * Number of data values in a stage 2 (data array) block.
    */
    private static final int DATA_BLOCK_LENGTH_ =
                                              1 &lt;&lt; Trie.INDEX_STAGE_1_SHIFT_;
    /**
    * Trie instance
    */
    private Trie m_trie_;
    /**
    * Initial value for trie values
    */
    private int m_initialValue_;
    /**
    * Next element results and data.
    */
    private int m_currentCodepoint_;
    private int m_nextCodepoint_;
    private int m_nextValue_;
    private int m_nextIndex_;
    private int m_nextBlock_;
    private int m_nextBlockIndex_;
    private int m_nextTrailIndexOffset_;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>