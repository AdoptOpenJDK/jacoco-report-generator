<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NormalizerImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">NormalizerImpl.java</span></div><h1>NormalizerImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.BufferedInputStream;
import java.io.InputStream;

/**
 * @author  Ram Viswanadha
 */
public final class NormalizerImpl {
    // Static block for the class to initialize its own self
    static final NormalizerImpl IMPL;

    static
    {
        try
        {
<span class="nc" id="L56">            IMPL = new NormalizerImpl();</span>
        }
<span class="fc" id="L58">        catch (Exception e)</span>
        {
<span class="fc" id="L60">            throw new RuntimeException(e.getMessage());</span>
<span class="nc" id="L61">        }</span>
    }

    static final int UNSIGNED_BYTE_MASK =0xFF;
    static final long UNSIGNED_INT_MASK = 0xffffffffL;
    /*
     * This new implementation of the normalization code loads its data from
     * unorm.icu, which is generated with the gennorm tool.
     * The format of that file is described at the end of this file.
     */
    private static final String DATA_FILE_NAME = &quot;/sun/text/resources/unorm.icu&quot;;

    // norm32 value constants

    // quick check flags 0..3 set mean &quot;no&quot; for their forms
    public static final int QC_NFC=0x11;          /* no|maybe */
    public static final int QC_NFKC=0x22;         /* no|maybe */
    public static final int QC_NFD=4;             /* no */
    public static final int QC_NFKD=8;            /* no */

    public static final int QC_ANY_NO=0xf;

    /* quick check flags 4..5 mean &quot;maybe&quot; for their forms;
     * test flags&gt;=QC_MAYBE
     */
    public static final int QC_MAYBE=0x10;
    public static final int QC_ANY_MAYBE=0x30;

    public static final int QC_MASK=0x3f;

    private static final int COMBINES_FWD=0x40;
    private static final int COMBINES_BACK=0x80;
    public  static final int COMBINES_ANY=0xc0;
    // UnicodeData.txt combining class in bits 15.
    private static final int CC_SHIFT=8;
    public  static final int CC_MASK=0xff00;
    // 16 bits for the index to UChars and other extra data
    private static final int EXTRA_SHIFT=16;

    /* norm32 value constants using &gt;16 bits */
    private static final long  MIN_SPECIAL    =  0xfc000000 &amp; UNSIGNED_INT_MASK;
    private static final long  SURROGATES_TOP =  0xfff00000 &amp; UNSIGNED_INT_MASK;
    private static final long  MIN_HANGUL     =  0xfff00000 &amp; UNSIGNED_INT_MASK;
//  private static final long  MIN_JAMO_V     =  0xfff20000 &amp; UNSIGNED_INT_MASK;
    private static final long  JAMO_V_TOP     =  0xfff30000 &amp; UNSIGNED_INT_MASK;


    /* indexes[] value names */
    /* number of bytes in normalization trie */
    static final int INDEX_TRIE_SIZE           = 0;
    /* number of chars in extra data */
    static final int INDEX_CHAR_COUNT           = 1;
    /* number of uint16_t words for combining data */
    static final int INDEX_COMBINE_DATA_COUNT = 2;
    /* first code point with quick check NFC NO/MAYBE */
    public static final int INDEX_MIN_NFC_NO_MAYBE   = 6;
    /* first code point with quick check NFKC NO/MAYBE */
    public static final int INDEX_MIN_NFKC_NO_MAYBE  = 7;
    /* first code point with quick check NFD NO/MAYBE */
    public static final int INDEX_MIN_NFD_NO_MAYBE   = 8;
    /* first code point with quick check NFKD NO/MAYBE */
    public static final int INDEX_MIN_NFKD_NO_MAYBE  = 9;
    /* number of bytes in FCD trie */
    static final int INDEX_FCD_TRIE_SIZE      = 10;
    /* number of bytes in the auxiliary trie */
    static final int INDEX_AUX_TRIE_SIZE      = 11;
    /* changing this requires a new formatVersion */
    static final int INDEX_TOP                = 32;


    /* AUX constants */
    /* value constants for auxTrie */
    private static final int AUX_UNSAFE_SHIFT           = 11;
    private static final int AUX_COMP_EX_SHIFT           = 10;
    private static final int AUX_NFC_SKIPPABLE_F_SHIFT = 12;

    private static final int AUX_MAX_FNC          =   1&lt;&lt;AUX_COMP_EX_SHIFT;
    private static final int AUX_UNSAFE_MASK      =   (int)((1&lt;&lt;AUX_UNSAFE_SHIFT) &amp; UNSIGNED_INT_MASK);
    private static final int AUX_FNC_MASK         =   (int)((AUX_MAX_FNC-1) &amp; UNSIGNED_INT_MASK);
    private static final int AUX_COMP_EX_MASK     =   (int)((1&lt;&lt;AUX_COMP_EX_SHIFT) &amp; UNSIGNED_INT_MASK);
    private static final long AUX_NFC_SKIP_F_MASK =   ((UNSIGNED_INT_MASK&amp;1)&lt;&lt;AUX_NFC_SKIPPABLE_F_SHIFT);

    private static final int MAX_BUFFER_SIZE                    = 20;

    /*******************************/

    /* Wrappers for Trie implementations */
<span class="nc" id="L148">    static final class NormTrieImpl implements Trie.DataManipulate{</span>
<span class="nc" id="L149">        static IntTrie normTrie= null;</span>
       /**
        * Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
        * data the index array offset of the indexes for that lead surrogate.
        * @param property data value for a surrogate from the trie, including
        *         the folding offset
        * @return data offset or 0 if there is no data for the lead surrogate
        */
        /* normTrie: 32-bit trie result may contain a special extraData index with the folding offset */
        public int getFoldingOffset(int value){
<span class="nc" id="L159">            return  BMP_INDEX_LENGTH+</span>
                    ((value&gt;&gt;(EXTRA_SHIFT-SURROGATE_BLOCK_BITS))&amp;
                    (0x3ff&lt;&lt;SURROGATE_BLOCK_BITS));
        }

    }
<span class="nc" id="L165">    static final class FCDTrieImpl implements Trie.DataManipulate{</span>
<span class="nc" id="L166">        static CharTrie fcdTrie=null;</span>
       /**
        * Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
        * data the index array offset of the indexes for that lead surrogate.
        * @param property data value for a surrogate from the trie, including
        *         the folding offset
        * @return data offset or 0 if there is no data for the lead surrogate
        */
        /* fcdTrie: the folding offset is the lead FCD value itself */
        public int getFoldingOffset(int value){
<span class="nc" id="L176">            return value;</span>
        }
    }

<span class="nc" id="L180">    static final class AuxTrieImpl implements Trie.DataManipulate{</span>
<span class="nc" id="L181">        static CharTrie auxTrie = null;</span>
       /**
        * Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
        * data the index array offset of the indexes for that lead surrogate.
        * @param property data value for a surrogate from the trie, including
        *        the folding offset
        * @return data offset or 0 if there is no data for the lead surrogate
        */
        /* auxTrie: the folding offset is in bits 9..0 of the 16-bit trie result */
        public int getFoldingOffset(int value){
<span class="nc" id="L191">            return (value &amp;AUX_FNC_MASK)&lt;&lt;SURROGATE_BLOCK_BITS;</span>
        }
    }

    /****************************************************/


    private static FCDTrieImpl fcdTrieImpl;
    private static NormTrieImpl normTrieImpl;
    private static AuxTrieImpl auxTrieImpl;
    private static int[] indexes;
    private static char[] combiningTable;
    private static char[] extraData;

    private static boolean isDataLoaded;
    private static boolean isFormatVersion_2_1;
    private static boolean isFormatVersion_2_2;
    private static byte[] unicodeVersion;

    /**
     * Default buffer size of datafile
     */
    private static final int DATA_BUFFER_SIZE = 25000;

    /**
     * FCD check: everything below this code point is known to have a 0
     * lead combining class
     */
    public static final int MIN_WITH_LEAD_CC=0x300;


    /**
     * Bit 7 of the length byte for a decomposition string in extra data is
     * a flag indicating whether the decomposition string is
     * preceded by a 16-bit word with the leading and trailing cc
     * of the decomposition (like for A-umlaut);
     * if not, then both cc's are zero (like for compatibility ideographs).
     */
    private static final int DECOMP_FLAG_LENGTH_HAS_CC=0x80;
    /**
     * Bits 6..0 of the length byte contain the actual length.
     */
    private static final int DECOMP_LENGTH_MASK=0x7f;

    /** Length of the BMP portion of the index (stage 1) array. */
    private static final int BMP_INDEX_LENGTH=0x10000&gt;&gt;Trie.INDEX_STAGE_1_SHIFT_;
    /** Number of bits of a trail surrogate that are used in index table
     * lookups.
     */
    private static final int SURROGATE_BLOCK_BITS=10-Trie.INDEX_STAGE_1_SHIFT_;


   // public utility
   public static int getFromIndexesArr(int index){
<span class="nc" id="L245">        return indexes[index];</span>
   }

   // protected constructor ---------------------------------------------

    /**
    * Constructor
    * @exception thrown when data reading fails or data corrupted
    */
<span class="nc" id="L254">    private NormalizerImpl() throws IOException {</span>
        //data should be loaded only once
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if(!isDataLoaded){</span>

            // jar access
<span class="nc" id="L259">            InputStream i = ICUData.getRequiredStream(DATA_FILE_NAME);</span>
<span class="nc" id="L260">            BufferedInputStream b = new BufferedInputStream(i,DATA_BUFFER_SIZE);</span>
<span class="nc" id="L261">            NormalizerDataReader reader = new NormalizerDataReader(b);</span>

            // read the indexes
<span class="nc" id="L264">            indexes = reader.readIndexes(NormalizerImpl.INDEX_TOP);</span>

<span class="nc" id="L266">            byte[] normBytes = new byte[indexes[NormalizerImpl.INDEX_TRIE_SIZE]];</span>

<span class="nc" id="L268">            int combiningTableTop = indexes[NormalizerImpl.INDEX_COMBINE_DATA_COUNT];</span>
<span class="nc" id="L269">            combiningTable = new char[combiningTableTop];</span>

<span class="nc" id="L271">            int extraDataTop = indexes[NormalizerImpl.INDEX_CHAR_COUNT];</span>
<span class="nc" id="L272">            extraData = new char[extraDataTop];</span>

<span class="nc" id="L274">            byte[] fcdBytes = new byte[indexes[NormalizerImpl.INDEX_FCD_TRIE_SIZE]];</span>
<span class="nc" id="L275">            byte[] auxBytes = new byte[indexes[NormalizerImpl.INDEX_AUX_TRIE_SIZE]];</span>

<span class="nc" id="L277">            fcdTrieImpl = new FCDTrieImpl();</span>
<span class="nc" id="L278">            normTrieImpl = new NormTrieImpl();</span>
<span class="nc" id="L279">            auxTrieImpl = new AuxTrieImpl();</span>

            // load the rest of the data data and initialize the data members
<span class="nc" id="L282">            reader.read(normBytes, fcdBytes,auxBytes, extraData, combiningTable);</span>

<span class="nc" id="L284">            NormTrieImpl.normTrie = new IntTrie( new ByteArrayInputStream(normBytes),normTrieImpl );</span>
<span class="nc" id="L285">            FCDTrieImpl.fcdTrie   = new CharTrie( new ByteArrayInputStream(fcdBytes),fcdTrieImpl  );</span>
<span class="nc" id="L286">            AuxTrieImpl.auxTrie   = new CharTrie( new ByteArrayInputStream(auxBytes),auxTrieImpl  );</span>

            // we reached here without any exceptions so the data is fully
            // loaded set the variable to true
<span class="nc" id="L290">            isDataLoaded = true;</span>

            // get the data format version
<span class="nc" id="L293">            byte[] formatVersion = reader.getDataFormatVersion();</span>

<span class="nc bnc" id="L295" title="All 6 branches missed.">            isFormatVersion_2_1 =( formatVersion[0]&gt;2</span>
                                    ||
                                   (formatVersion[0]==2 &amp;&amp; formatVersion[1]&gt;=1)
                                 );
<span class="nc bnc" id="L299" title="All 6 branches missed.">            isFormatVersion_2_2 =( formatVersion[0]&gt;2</span>
                                    ||
                                   (formatVersion[0]==2 &amp;&amp; formatVersion[1]&gt;=2)
                                 );
<span class="nc" id="L303">            unicodeVersion = reader.getUnicodeVersion();</span>
<span class="nc" id="L304">            b.close();</span>
        }
<span class="nc" id="L306">    }</span>

    /* ---------------------------------------------------------------------- */

    /* Korean Hangul and Jamo constants */

    public static final int JAMO_L_BASE=0x1100;     /* &quot;lead&quot; jamo */
    public static final int JAMO_V_BASE=0x1161;     /* &quot;vowel&quot; jamo */
    public static final int JAMO_T_BASE=0x11a7;     /* &quot;trail&quot; jamo */

    public static final int HANGUL_BASE=0xac00;

    public static final int JAMO_L_COUNT=19;
    public static final int JAMO_V_COUNT=21;
    public static final int JAMO_T_COUNT=28;
    public  static final int HANGUL_COUNT=JAMO_L_COUNT*JAMO_V_COUNT*JAMO_T_COUNT;

    private static boolean isHangulWithoutJamoT(char c) {
<span class="nc" id="L324">        c-=HANGUL_BASE;</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">        return c&lt;HANGUL_COUNT &amp;&amp; c%JAMO_T_COUNT==0;</span>
    }

    /* norm32 helpers */

    /* is this a norm32 with a regular index? */
    private static boolean isNorm32Regular(long norm32) {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        return norm32&lt;MIN_SPECIAL;</span>
    }

    /* is this a norm32 with a special index for a lead surrogate? */
    private static boolean isNorm32LeadSurrogate(long norm32) {
<span class="nc bnc" id="L337" title="All 4 branches missed.">        return MIN_SPECIAL&lt;=norm32 &amp;&amp; norm32&lt;SURROGATES_TOP;</span>
    }

    /* is this a norm32 with a special index for a Hangul syllable or a Jamo? */
    private static boolean isNorm32HangulOrJamo(long norm32) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        return norm32&gt;=MIN_HANGUL;</span>
    }

    /*
     * Given norm32 for Jamo V or T,
     * is this a Jamo V?
     */
    private static boolean isJamoVTNorm32JamoV(long norm32) {
<span class="nc bnc" id="L350" title="All 2 branches missed.">        return norm32&lt;JAMO_V_TOP;</span>
    }

    /* data access primitives ----------------------------------------------- */

    public static long/*unsigned*/ getNorm32(char c) {
<span class="nc" id="L356">        return ((UNSIGNED_INT_MASK) &amp; (NormTrieImpl.normTrie.getLeadValue(c)));</span>
    }

    public static long/*unsigned*/ getNorm32FromSurrogatePair(long norm32,
                                                               char c2) {
        /*
         * the surrogate index in norm32 stores only the number of the surrogate
         * index block see gennorm/store.c/getFoldedNormValue()
         */
<span class="nc" id="L365">        return ((UNSIGNED_INT_MASK) &amp;</span>
<span class="nc" id="L366">                    NormTrieImpl.normTrie.getTrailValue((int)norm32, c2));</span>
    }
    ///CLOVER:OFF
    private static long getNorm32(int c){
<span class="nc" id="L370">        return (UNSIGNED_INT_MASK&amp;(NormTrieImpl.normTrie.getCodePointValue(c)));</span>
    }

    /*
     * get a norm32 from text with complete code points
     * (like from decompositions)
     */
    private static long/*unsigned*/ getNorm32(char[] p,int start,
                                              int/*unsigned*/ mask) {
<span class="nc" id="L379">        long/*unsigned*/ norm32= getNorm32(p[start]);</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">        if(((norm32&amp;mask)&gt;0) &amp;&amp; isNorm32LeadSurrogate(norm32)) {</span>
            /* *p is a lead surrogate, get the real norm32 */
<span class="nc" id="L382">            norm32=getNorm32FromSurrogatePair(norm32, p[start+1]);</span>
        }
<span class="nc" id="L384">        return norm32;</span>
    }

    //// for StringPrep
    public static VersionInfo getUnicodeVersion(){
<span class="nc" id="L389">        return VersionInfo.getInstance(unicodeVersion[0], unicodeVersion[1],</span>
                                       unicodeVersion[2], unicodeVersion[3]);
    }

    public static char    getFCD16(char c) {
<span class="nc" id="L394">        return  FCDTrieImpl.fcdTrie.getLeadValue(c);</span>
    }

    public static char getFCD16FromSurrogatePair(char fcd16, char c2) {
        /* the surrogate index in fcd16 is an absolute offset over the
         * start of stage 1
         * */
<span class="nc" id="L401">        return FCDTrieImpl.fcdTrie.getTrailValue(fcd16, c2);</span>
    }
    public static int getFCD16(int c) {
<span class="nc" id="L404">        return  FCDTrieImpl.fcdTrie.getCodePointValue(c);</span>
    }

    private static int getExtraDataIndex(long norm32) {
<span class="nc" id="L408">        return (int)(norm32&gt;&gt;EXTRA_SHIFT);</span>
    }

<span class="nc" id="L411">    private static final class DecomposeArgs{</span>
        int /*unsigned byte*/ cc;
        int /*unsigned byte*/ trailCC;
        int length;
    }
    /**
     *
     * get the canonical or compatibility decomposition for one character
     *
     * @return index into the extraData array
     */
    private static int/*index*/ decompose(long/*unsigned*/ norm32,
                                          int/*unsigned*/ qcMask,
                                          DecomposeArgs args) {
<span class="nc" id="L425">        int p= getExtraDataIndex(norm32);</span>
<span class="nc" id="L426">        args.length=extraData[p++];</span>

<span class="nc bnc" id="L428" title="All 4 branches missed.">        if((norm32&amp;qcMask&amp;QC_NFKD)!=0 &amp;&amp; args.length&gt;=0x100) {</span>
            /* use compatibility decomposition, skip canonical data */
<span class="nc" id="L430">            p+=((args.length&gt;&gt;7)&amp;1)+(args.length&amp;DECOMP_LENGTH_MASK);</span>
<span class="nc" id="L431">            args.length&gt;&gt;=8;</span>
        }

<span class="nc bnc" id="L434" title="All 2 branches missed.">        if((args.length&amp;DECOMP_FLAG_LENGTH_HAS_CC)&gt;0) {</span>
            /* get the lead and trail cc's */
<span class="nc" id="L436">            char bothCCs=extraData[p++];</span>
<span class="nc" id="L437">            args.cc=(UNSIGNED_BYTE_MASK) &amp; (bothCCs&gt;&gt;8);</span>
<span class="nc" id="L438">            args.trailCC=(UNSIGNED_BYTE_MASK) &amp; bothCCs;</span>
<span class="nc" id="L439">        } else {</span>
            /* lead and trail cc's are both 0 */
<span class="nc" id="L441">            args.cc=args.trailCC=0;</span>
        }

<span class="nc" id="L444">        args.length&amp;=DECOMP_LENGTH_MASK;</span>
<span class="nc" id="L445">        return p;</span>
    }


    /**
     * get the canonical decomposition for one character
     * @return index into the extraData array
     */
    private static int decompose(long/*unsigned*/ norm32,
                                 DecomposeArgs args) {

<span class="nc" id="L456">        int p= getExtraDataIndex(norm32);</span>
<span class="nc" id="L457">        args.length=extraData[p++];</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">        if((args.length&amp;DECOMP_FLAG_LENGTH_HAS_CC)&gt;0) {</span>
            /* get the lead and trail cc's */
<span class="nc" id="L461">            char bothCCs=extraData[p++];</span>
<span class="nc" id="L462">            args.cc=(UNSIGNED_BYTE_MASK) &amp; (bothCCs&gt;&gt;8);</span>
<span class="nc" id="L463">            args.trailCC=(UNSIGNED_BYTE_MASK) &amp; bothCCs;</span>
<span class="nc" id="L464">        } else {</span>
            /* lead and trail cc's are both 0 */
<span class="nc" id="L466">            args.cc=args.trailCC=0;</span>
        }

<span class="nc" id="L469">        args.length&amp;=DECOMP_LENGTH_MASK;</span>
<span class="nc" id="L470">        return p;</span>
    }


<span class="nc" id="L474">    private static final class NextCCArgs{</span>
        char[] source;
        int next;
        int limit;
        char c;
        char c2;
    }

    /*
     * get the combining class of (c, c2)= args.source[args.next++]
     * before: args.next&lt;args.limit  after: args.next&lt;=args.limit
     * if only one code unit is used, then c2==0
     */
    private static int /*unsigned byte*/ getNextCC(NextCCArgs args) {
        long /*unsigned*/ norm32;

<span class="nc" id="L490">        args.c=args.source[args.next++];</span>

<span class="nc" id="L492">        norm32= getNorm32(args.c);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if((norm32 &amp; CC_MASK)==0) {</span>
<span class="nc" id="L494">            args.c2=0;</span>
<span class="nc" id="L495">            return 0;</span>
        } else {
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if(!isNorm32LeadSurrogate(norm32)) {</span>
<span class="nc" id="L498">                args.c2=0;</span>
            } else {
                /* c is a lead surrogate, get the real norm32 */
<span class="nc bnc" id="L501" title="All 2 branches missed.">                if(args.next!=args.limit &amp;&amp;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                        UTF16.isTrailSurrogate(args.c2=args.source[args.next])){</span>
<span class="nc" id="L503">                    ++args.next;</span>
<span class="nc" id="L504">                    norm32=getNorm32FromSurrogatePair(norm32, args.c2);</span>
                } else {
<span class="nc" id="L506">                    args.c2=0;</span>
<span class="nc" id="L507">                    return 0;</span>
                }
            }

<span class="nc" id="L511">            return (int)((UNSIGNED_BYTE_MASK) &amp; (norm32&gt;&gt;CC_SHIFT));</span>
        }
    }

<span class="nc" id="L515">    private static final class PrevArgs{</span>
        char[] src;
        int start;
        int current;
        char c;
        char c2;
    }

    /*
     * read backwards and get norm32
     * return 0 if the character is &lt;minC
     * if c2!=0 then (c2, c) is a surrogate pair (reversed - c2 is first
     * surrogate but read second!)
     */
    private static long /*unsigned*/ getPrevNorm32(PrevArgs args,
                                                      int/*unsigned*/ minC,
                                                      int/*unsigned*/ mask) {
        long/*unsigned*/ norm32;

<span class="nc" id="L534">        args.c=args.src[--args.current];</span>
<span class="nc" id="L535">        args.c2=0;</span>

        /* check for a surrogate before getting norm32 to see if we need to
         * predecrement further
         */
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if(args.c&lt;minC) {</span>
<span class="nc" id="L541">            return 0;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        } else if(!UTF16.isSurrogate(args.c)) {</span>
<span class="nc" id="L543">            return getNorm32(args.c);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        } else if(UTF16.isLeadSurrogate(args.c)) {</span>
            /* unpaired first surrogate */
<span class="nc" id="L546">            return 0;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        } else if(args.current!=args.start &amp;&amp;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                    UTF16.isLeadSurrogate(args.c2=args.src[args.current-1])) {</span>
<span class="nc" id="L549">            --args.current;</span>
<span class="nc" id="L550">            norm32=getNorm32(args.c2);</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">            if((norm32&amp;mask)==0) {</span>
                /* all surrogate pairs with this lead surrogate have
                 * only irrelevant data
                 */
<span class="nc" id="L556">                return 0;</span>
            } else {
                /* norm32 must be a surrogate special */
<span class="nc" id="L559">                return getNorm32FromSurrogatePair(norm32, args.c);</span>
            }
        } else {
            /* unpaired second surrogate */
<span class="nc" id="L563">            args.c2=0;</span>
<span class="nc" id="L564">            return 0;</span>
        }
    }

    /*
     * get the combining class of (c, c2)=*--p
     * before: start&lt;p  after: start&lt;=p
     */
    private static int /*unsigned byte*/ getPrevCC(PrevArgs args) {

<span class="nc" id="L574">        return (int)((UNSIGNED_BYTE_MASK)&amp;(getPrevNorm32(args, MIN_WITH_LEAD_CC,</span>
                                                         CC_MASK)&gt;&gt;CC_SHIFT));
    }

    /*
     * is this a safe boundary character for NF*D?
     * (lead cc==0)
     */
    public static boolean isNFDSafe(long/*unsigned*/ norm32,
                                     int/*unsigned*/ccOrQCMask,
                                     int/*unsigned*/ decompQCMask) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if((norm32&amp;ccOrQCMask)==0) {</span>
<span class="nc" id="L586">            return true; /* cc==0 and no decomposition: this is NF*D safe */</span>
        }

        /* inspect its decomposition - maybe a Hangul but not a surrogate here*/
<span class="nc bnc" id="L590" title="All 4 branches missed.">        if(isNorm32Regular(norm32) &amp;&amp; (norm32&amp;decompQCMask)!=0) {</span>
<span class="nc" id="L591">            DecomposeArgs args=new DecomposeArgs();</span>
            /* decomposes, get everything from the variable-length extra data */
<span class="nc" id="L593">            decompose(norm32, decompQCMask, args);</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">            return args.cc==0;</span>
        } else {
            /* no decomposition (or Hangul), test the cc directly */
<span class="nc bnc" id="L597" title="All 2 branches missed.">            return (norm32&amp;CC_MASK)==0;</span>
        }
    }

    /*
     * is this (or does its decomposition begin with) a &quot;true starter&quot;?
     * (cc==0 and NF*C_YES)
     */
    public static boolean isTrueStarter(long/*unsigned*/ norm32,
                                          int/*unsigned*/ ccOrQCMask,
                                          int/*unsigned*/ decompQCMask) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if((norm32&amp;ccOrQCMask)==0) {</span>
<span class="nc" id="L609">            return true; /* this is a true starter (could be Hangul or Jamo L)*/</span>
        }

        /* inspect its decomposition - not a Hangul or a surrogate here */
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if((norm32&amp;decompQCMask)!=0) {</span>
            int p; /* index into extra data array */
<span class="nc" id="L615">            DecomposeArgs args=new DecomposeArgs();</span>
            /* decomposes, get everything from the variable-length extra data */
<span class="nc" id="L617">            p=decompose(norm32, decompQCMask, args);</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">            if(args.cc==0) {</span>
<span class="nc" id="L620">                int/*unsigned*/ qcMask=ccOrQCMask&amp;QC_MASK;</span>

                /* does it begin with NFC_YES? */
<span class="nc bnc" id="L623" title="All 2 branches missed.">                if((getNorm32(extraData,p, qcMask)&amp;qcMask)==0) {</span>
                    /* yes, the decomposition begins with a true starter */
<span class="nc" id="L625">                    return true;</span>
                }
            }
        }
<span class="nc" id="L629">        return false;</span>
    }

    /* reorder UTF-16 in-place ---------------------------------------------- */

    /**
     * simpler, single-character version of mergeOrdered() -
     * bubble-insert one single code point into the preceding string
     * which is already canonically ordered
     * (c, c2) may or may not yet have been inserted at src[current]..src[p]
     *
     * it must be p=current+lengthof(c, c2) i.e. p=current+(c2==0 ? 1 : 2)
     *
     * before: src[start]..src[current] is already ordered, and
     *         src[current]..src[p]     may or may not hold (c, c2) but
     *                          must be exactly the same length as (c, c2)
     * after: src[start]..src[p] is ordered
     *
     * @return the trailing combining class
     */
    private static int/*unsigned byte*/ insertOrdered(char[] source,
                                                      int start,
                                                      int current, int p,
                                                         char c, char c2,
                                                         int/*unsigned byte*/ cc) {
        int back, preBack;
        int r;
<span class="nc" id="L656">        int prevCC, trailCC=cc;</span>

<span class="nc bnc" id="L658" title="All 4 branches missed.">        if(start&lt;current &amp;&amp; cc!=0) {</span>
            // search for the insertion point where cc&gt;=prevCC
<span class="nc" id="L660">            preBack=back=current;</span>
<span class="nc" id="L661">            PrevArgs prevArgs = new PrevArgs();</span>
<span class="nc" id="L662">            prevArgs.current  = current;</span>
<span class="nc" id="L663">            prevArgs.start    = start;</span>
<span class="nc" id="L664">            prevArgs.src      = source;</span>
            // get the prevCC
<span class="nc" id="L666">            prevCC=getPrevCC(prevArgs);</span>
<span class="nc" id="L667">            preBack = prevArgs.current;</span>

<span class="nc bnc" id="L669" title="All 2 branches missed.">            if(cc&lt;prevCC) {</span>
                // this will be the last code point, so keep its cc
<span class="nc" id="L671">                trailCC=prevCC;</span>
<span class="nc" id="L672">                back=preBack;</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                while(start&lt;preBack) {</span>
<span class="nc" id="L674">                    prevCC=getPrevCC(prevArgs);</span>
<span class="nc" id="L675">                    preBack=prevArgs.current;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                    if(cc&gt;=prevCC) {</span>
<span class="nc" id="L677">                        break;</span>
                    }
<span class="nc" id="L679">                    back=preBack;</span>
                }


                // this is where we are right now with all these indicies:
                // [start]..[pPreBack] 0..? code points that we can ignore
                // [pPreBack]..[pBack] 0..1 code points with prevCC&lt;=cc
                // [pBack]..[current] 0..n code points with &gt;cc, move up to insert (c, c2)
                // [current]..[p]         1 code point (c, c2) with cc

                // move the code units in between up
<span class="nc" id="L690">                r=p;</span>
                do {
<span class="nc" id="L692">                    source[--r]=source[--current];</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                } while(back!=current);</span>
            }
        }

        // insert (c, c2)
<span class="nc" id="L698">        source[current]=c;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if(c2!=0) {</span>
<span class="nc" id="L700">            source[(current+1)]=c2;</span>
        }

        // we know the cc of the last code point
<span class="nc" id="L704">        return trailCC;</span>
    }

    /**
     * merge two UTF-16 string parts together
     * to canonically order (order by combining classes) their concatenation
     *
     * the two strings may already be adjacent, so that the merging is done
     * in-place if the two strings are not adjacent, then the buffer holding the
     * first one must be large enough
     * the second string may or may not be ordered in itself
     *
     * before: [start]..[current] is already ordered, and
     *         [next]..[limit]    may be ordered in itself, but
     *                          is not in relation to [start..current[
     * after: [start..current+(limit-next)[ is ordered
     *
     * the algorithm is a simple bubble-sort that takes the characters from
     * src[next++] and inserts them in correct combining class order into the
     * preceding part of the string
     *
     * since this function is called much less often than the single-code point
     * insertOrdered(), it just uses that for easier maintenance
     *
     * @return the trailing combining class
     */
    private static int /*unsigned byte*/ mergeOrdered(char[] source,
                                                      int start,
                                                      int current,
                                                      char[] data,
                                                        int next,
                                                        int limit,
                                                        boolean isOrdered) {
            int r;
<span class="nc" id="L738">            int /*unsigned byte*/ cc, trailCC=0;</span>
            boolean adjacent;

<span class="nc bnc" id="L741" title="All 2 branches missed.">            adjacent= current==next;</span>
<span class="nc" id="L742">            NextCCArgs ncArgs = new NextCCArgs();</span>
<span class="nc" id="L743">            ncArgs.source = data;</span>
<span class="nc" id="L744">            ncArgs.next   = next;</span>
<span class="nc" id="L745">            ncArgs.limit  = limit;</span>

<span class="nc bnc" id="L747" title="All 4 branches missed.">            if(start!=current || !isOrdered) {</span>

<span class="nc bnc" id="L749" title="All 2 branches missed.">                while(ncArgs.next&lt;ncArgs.limit) {</span>
<span class="nc" id="L750">                    cc=getNextCC(ncArgs);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                    if(cc==0) {</span>
                        // does not bubble back
<span class="nc" id="L753">                        trailCC=0;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                        if(adjacent) {</span>
<span class="nc" id="L755">                            current=ncArgs.next;</span>
                        } else {
<span class="nc" id="L757">                            data[current++]=ncArgs.c;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                            if(ncArgs.c2!=0) {</span>
<span class="nc" id="L759">                                data[current++]=ncArgs.c2;</span>
                            }
                        }
<span class="nc bnc" id="L762" title="All 2 branches missed.">                        if(isOrdered) {</span>
<span class="nc" id="L763">                            break;</span>
                        } else {
<span class="nc" id="L765">                            start=current;</span>
                        }
                    } else {
<span class="nc bnc" id="L768" title="All 2 branches missed.">                        r=current+(ncArgs.c2==0 ? 1 : 2);</span>
<span class="nc" id="L769">                        trailCC=insertOrdered(source,start, current, r,</span>
                                              ncArgs.c, ncArgs.c2, cc);
<span class="nc" id="L771">                        current=r;</span>
                    }
                }
            }

<span class="nc bnc" id="L776" title="All 2 branches missed.">            if(ncArgs.next==ncArgs.limit) {</span>
                // we know the cc of the last code point
<span class="nc" id="L778">                return trailCC;</span>
            } else {
<span class="nc bnc" id="L780" title="All 2 branches missed.">                if(!adjacent) {</span>
                    // copy the second string part
                    do {
<span class="nc" id="L783">                        source[current++]=data[ncArgs.next++];</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                    } while(ncArgs.next!=ncArgs.limit);</span>
<span class="nc" id="L785">                    ncArgs.limit=current;</span>
                }
<span class="nc" id="L787">                PrevArgs prevArgs = new PrevArgs();</span>
<span class="nc" id="L788">                prevArgs.src   = data;</span>
<span class="nc" id="L789">                prevArgs.start = start;</span>
<span class="nc" id="L790">                prevArgs.current =  ncArgs.limit;</span>
<span class="nc" id="L791">                return getPrevCC(prevArgs);</span>
            }

    }
    private static int /*unsigned byte*/ mergeOrdered(char[] source,
                                                      int start,
                                                      int current,
                                                      char[] data,
                                                        final int next,
                                                        final int limit) {
<span class="nc" id="L801">        return mergeOrdered(source,start,current,data,next,limit,true);</span>
    }

    public static NormalizerBase.QuickCheckResult quickCheck(char[] src,
                                                            int srcStart,
                                                            int srcLimit,
                                                            int minNoMaybe,
                                                            int qcMask,
                                                            int options,
                                                            boolean allowMaybe,
                                                            UnicodeSet nx){

        int ccOrQCMask;
        long norm32;
        char c, c2;
        char cc, prevCC;
        long qcNorm32;
        NormalizerBase.QuickCheckResult result;
<span class="nc" id="L819">        ComposePartArgs args = new ComposePartArgs();</span>
        char[] buffer ;
<span class="nc" id="L821">        int start = srcStart;</span>

<span class="nc bnc" id="L823" title="All 2 branches missed.">        if(!isDataLoaded) {</span>
<span class="nc" id="L824">            return NormalizerBase.MAYBE;</span>
        }
        // initialize
<span class="nc" id="L827">        ccOrQCMask=CC_MASK|qcMask;</span>
<span class="nc" id="L828">        result=NormalizerBase.YES;</span>
<span class="nc" id="L829">        prevCC=0;</span>

        for(;;) {
            for(;;) {
<span class="nc bnc" id="L833" title="All 2 branches missed.">                if(srcStart==srcLimit) {</span>
<span class="nc" id="L834">                    return result;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                } else if((c=src[srcStart++])&gt;=minNoMaybe &amp;&amp;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                                  (( norm32=getNorm32(c)) &amp; ccOrQCMask)!=0) {</span>
<span class="nc" id="L837">                    break;</span>
                }
<span class="nc" id="L839">                prevCC=0;</span>
            }


            // check one above-minimum, relevant code unit
<span class="nc bnc" id="L844" title="All 2 branches missed.">            if(isNorm32LeadSurrogate(norm32)) {</span>
                // c is a lead surrogate, get the real norm32
<span class="nc bnc" id="L846" title="All 4 branches missed.">                if(srcStart!=srcLimit&amp;&amp; UTF16.isTrailSurrogate(c2=src[srcStart])) {</span>
<span class="nc" id="L847">                    ++srcStart;</span>
<span class="nc" id="L848">                    norm32=getNorm32FromSurrogatePair(norm32,c2);</span>
                } else {
<span class="nc" id="L850">                    norm32=0;</span>
<span class="nc" id="L851">                    c2=0;</span>
                }
            }else{
<span class="nc" id="L854">                c2=0;</span>
            }
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if(nx_contains(nx, c, c2)) {</span>
                /* excluded: norm32==0 */
<span class="nc" id="L858">                norm32=0;</span>
            }

            // check the combining order
<span class="nc" id="L862">            cc=(char)((norm32&gt;&gt;CC_SHIFT)&amp;0xFF);</span>
<span class="nc bnc" id="L863" title="All 4 branches missed.">            if(cc!=0 &amp;&amp; cc&lt;prevCC) {</span>
<span class="nc" id="L864">                return NormalizerBase.NO;</span>
            }
<span class="nc" id="L866">            prevCC=cc;</span>

            // check for &quot;no&quot; or &quot;maybe&quot; quick check flags
<span class="nc" id="L869">            qcNorm32 = norm32 &amp; qcMask;</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            if((qcNorm32&amp; QC_ANY_NO)&gt;=1) {</span>
<span class="nc" id="L871">                result= NormalizerBase.NO;</span>
<span class="nc" id="L872">                break;</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            } else if(qcNorm32!=0) {</span>
                // &quot;maybe&quot; can only occur for NFC and NFKC
<span class="nc bnc" id="L875" title="All 2 branches missed.">                if(allowMaybe){</span>
<span class="nc" id="L876">                    result=NormalizerBase.MAYBE;</span>
                }else{
                    // normalize a section around here to see if it is really
                    // normalized or not
                    int prevStarter;
                    int/*unsigned*/ decompQCMask;

<span class="nc" id="L883">                    decompQCMask=(qcMask&lt;&lt;2)&amp;0xf; // decomposition quick check mask</span>

                    // find the previous starter

                    // set prevStarter to the beginning of the current character
<span class="nc" id="L888">                    prevStarter=srcStart-1;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                    if(UTF16.isTrailSurrogate(src[prevStarter])) {</span>
                        // safe because unpaired surrogates do not result
                        // in &quot;maybe&quot;
<span class="nc" id="L892">                        --prevStarter;</span>
                    }
<span class="nc" id="L894">                    prevStarter=findPreviousStarter(src, start, prevStarter,</span>
                                                    ccOrQCMask, decompQCMask,
                                                    (char)minNoMaybe);

                    // find the next true starter in [src..limit[ - modifies
                    // src to point to the next starter
<span class="nc" id="L900">                    srcStart=findNextStarter(src,srcStart, srcLimit, qcMask,</span>
                                             decompQCMask,(char) minNoMaybe);

                    //set the args for compose part
<span class="nc" id="L904">                    args.prevCC = prevCC;</span>

                    // decompose and recompose [prevStarter..src[
<span class="nc" id="L907">                    buffer = composePart(args,prevStarter,src,srcStart,srcLimit,options,nx);</span>

                    // compare the normalized version with the original
<span class="nc bnc" id="L910" title="All 2 branches missed.">                    if(0!=strCompare(buffer,0,args.length,src,prevStarter,srcStart, false)) {</span>
<span class="nc" id="L911">                        result=NormalizerBase.NO; // normalization differs</span>
<span class="nc" id="L912">                        break;</span>
                    }

                    // continue after the next starter
<span class="nc" id="L916">                }</span>
            }
        }
<span class="nc" id="L919">        return result;</span>
    }


    //------------------------------------------------------
    // make NFD &amp; NFKD
    //------------------------------------------------------

    public static int decompose(char[] src,int srcStart,int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                 boolean compat,int[] outTrailCC,
                                 UnicodeSet nx) {

<span class="nc" id="L932">        char[] buffer = new char[3];</span>
        int prevSrc;
        long norm32;
        int ccOrQCMask, qcMask;
        int reorderStartIndex, length;
        char c, c2, minNoMaybe;
        int/*unsigned byte*/ cc, prevCC, trailCC;
        char[] p;
        int pStart;
<span class="nc" id="L941">        int destIndex = destStart;</span>
<span class="nc" id="L942">        int srcIndex = srcStart;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if(!compat) {</span>
<span class="nc" id="L944">            minNoMaybe=(char)indexes[INDEX_MIN_NFD_NO_MAYBE];</span>
<span class="nc" id="L945">            qcMask=QC_NFD;</span>
        } else {
<span class="nc" id="L947">            minNoMaybe=(char)indexes[INDEX_MIN_NFKD_NO_MAYBE];</span>
<span class="nc" id="L948">            qcMask=QC_NFKD;</span>
        }

        /* initialize */
<span class="nc" id="L952">        ccOrQCMask=CC_MASK|qcMask;</span>
<span class="nc" id="L953">        reorderStartIndex=0;</span>
<span class="nc" id="L954">        prevCC=0;</span>
<span class="nc" id="L955">        norm32=0;</span>
<span class="nc" id="L956">        c=0;</span>
<span class="nc" id="L957">        pStart=0;</span>

<span class="nc" id="L959">        cc=trailCC=-1;//initialize to bogus value</span>

        for(;;) {
            /* count code units below the minimum or with irrelevant data for
             * the quick check
             */
<span class="nc" id="L965">            prevSrc=srcIndex;</span>

<span class="nc bnc" id="L967" title="All 4 branches missed.">            while(srcIndex!=srcLimit &amp;&amp;((c=src[srcIndex])&lt;minNoMaybe ||</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">                                        ((norm32=getNorm32(c))&amp;ccOrQCMask)==0)){</span>
<span class="nc" id="L969">                prevCC=0;</span>
<span class="nc" id="L970">                ++srcIndex;</span>
            }

            /* copy these code units all at once */
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if(srcIndex!=prevSrc) {</span>
<span class="nc" id="L975">                length=srcIndex-prevSrc;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                if((destIndex+length)&lt;=destLimit) {</span>
<span class="nc" id="L977">                    System.arraycopy(src,prevSrc,dest,destIndex,length);</span>
                }

<span class="nc" id="L980">                destIndex+=length;</span>
<span class="nc" id="L981">                reorderStartIndex=destIndex;</span>
            }

            /* end of source reached? */
<span class="nc bnc" id="L985" title="All 2 branches missed.">            if(srcIndex==srcLimit) {</span>
<span class="nc" id="L986">                break;</span>
            }

            /* c already contains *src and norm32 is set for it, increment src*/
<span class="nc" id="L990">            ++srcIndex;</span>

            /* check one above-minimum, relevant code unit */
            /*
             * generally, set p and length to the decomposition string
             * in simple cases, p==NULL and (c, c2) will hold the length code
             * units to append in all cases, set cc to the lead and trailCC to
             * the trail combining class
             *
             * the following merge-sort of the current character into the
             * preceding, canonically ordered result text will use the
             * optimized insertOrdered()
             * if there is only one single code point to process;
             * this is indicated with p==NULL, and (c, c2) is the character to
             * insert
             * ((c, 0) for a BMP character and (lead surrogate, trail surrogate)
             * for a supplementary character)
             * otherwise, p[length] is merged in with _mergeOrdered()
             */
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if(isNorm32HangulOrJamo(norm32)) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                if(nx_contains(nx, c)) {</span>
<span class="nc" id="L1011">                    c2=0;</span>
<span class="nc" id="L1012">                    p=null;</span>
<span class="nc" id="L1013">                    length=1;</span>
                } else {
                    // Hangul syllable: decompose algorithmically
<span class="nc" id="L1016">                    p=buffer;</span>
<span class="nc" id="L1017">                    pStart=0;</span>
<span class="nc" id="L1018">                    cc=trailCC=0;</span>

<span class="nc" id="L1020">                    c-=HANGUL_BASE;</span>

<span class="nc" id="L1022">                    c2=(char)(c%JAMO_T_COUNT);</span>
<span class="nc" id="L1023">                    c/=JAMO_T_COUNT;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    if(c2&gt;0) {</span>
<span class="nc" id="L1025">                        buffer[2]=(char)(JAMO_T_BASE+c2);</span>
<span class="nc" id="L1026">                        length=3;</span>
                    } else {
<span class="nc" id="L1028">                        length=2;</span>
                    }

<span class="nc" id="L1031">                    buffer[1]=(char)(JAMO_V_BASE+c%JAMO_V_COUNT);</span>
<span class="nc" id="L1032">                    buffer[0]=(char)(JAMO_L_BASE+c/JAMO_V_COUNT);</span>
                }
            } else {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                if(isNorm32Regular(norm32)) {</span>
<span class="nc" id="L1036">                    c2=0;</span>
<span class="nc" id="L1037">                    length=1;</span>
                } else {
                    // c is a lead surrogate, get the real norm32
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                    if(srcIndex!=srcLimit &amp;&amp;</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                                    UTF16.isTrailSurrogate(c2=src[srcIndex])) {</span>
<span class="nc" id="L1042">                        ++srcIndex;</span>
<span class="nc" id="L1043">                        length=2;</span>
<span class="nc" id="L1044">                        norm32=getNorm32FromSurrogatePair(norm32, c2);</span>
                    } else {
<span class="nc" id="L1046">                        c2=0;</span>
<span class="nc" id="L1047">                        length=1;</span>
<span class="nc" id="L1048">                        norm32=0;</span>
                    }
                }

                /* get the decomposition and the lead and trail cc's */
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                if(nx_contains(nx, c, c2)) {</span>
                    /* excluded: norm32==0 */
<span class="nc" id="L1055">                    cc=trailCC=0;</span>
<span class="nc" id="L1056">                    p=null;</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                } else if((norm32&amp;qcMask)==0) {</span>
                    /* c does not decompose */
<span class="nc" id="L1059">                    cc=trailCC=(int)((UNSIGNED_BYTE_MASK) &amp; (norm32&gt;&gt;CC_SHIFT));</span>
<span class="nc" id="L1060">                    p=null;</span>
<span class="nc" id="L1061">                    pStart=-1;</span>
                } else {
<span class="nc" id="L1063">                    DecomposeArgs arg = new DecomposeArgs();</span>
                    /* c decomposes, get everything from the variable-length
                     * extra data
                     */
<span class="nc" id="L1067">                    pStart=decompose(norm32, qcMask, arg);</span>
<span class="nc" id="L1068">                    p=extraData;</span>
<span class="nc" id="L1069">                    length=arg.length;</span>
<span class="nc" id="L1070">                    cc=arg.cc;</span>
<span class="nc" id="L1071">                    trailCC=arg.trailCC;</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                    if(length==1) {</span>
                        /* fastpath a single code unit from decomposition */
<span class="nc" id="L1074">                        c=p[pStart];</span>
<span class="nc" id="L1075">                        c2=0;</span>
<span class="nc" id="L1076">                        p=null;</span>
<span class="nc" id="L1077">                        pStart=-1;</span>
                    }
                }
            }

            /* append the decomposition to the destination buffer, assume
             * length&gt;0
             */
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if((destIndex+length)&lt;=destLimit) {</span>
<span class="nc" id="L1086">                int reorderSplit=destIndex;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">                if(p==null) {</span>
                    /* fastpath: single code point */
<span class="nc bnc" id="L1089" title="All 4 branches missed.">                    if(cc!=0 &amp;&amp; cc&lt;prevCC) {</span>
                        /* (c, c2) is out of order with respect to the preceding
                         *  text
                         */
<span class="nc" id="L1093">                        destIndex+=length;</span>
<span class="nc" id="L1094">                        trailCC=insertOrdered(dest,reorderStartIndex,</span>
                                            reorderSplit, destIndex, c, c2, cc);
                    } else {
                        /* just append (c, c2) */
<span class="nc" id="L1098">                        dest[destIndex++]=c;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                        if(c2!=0) {</span>
<span class="nc" id="L1100">                            dest[destIndex++]=c2;</span>
                        }
                    }
                } else {
                    /* general: multiple code points (ordered by themselves)
                     * from decomposition
                     */
<span class="nc bnc" id="L1107" title="All 4 branches missed.">                    if(cc!=0 &amp;&amp; cc&lt;prevCC) {</span>
                        /* the decomposition is out of order with respect to the
                         *  preceding text
                         */
<span class="nc" id="L1111">                        destIndex+=length;</span>
<span class="nc" id="L1112">                        trailCC=mergeOrdered(dest,reorderStartIndex,</span>
                                          reorderSplit,p, pStart,pStart+length);
                    } else {
                        /* just append the decomposition */
                        do {
<span class="nc" id="L1117">                            dest[destIndex++]=p[pStart++];</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                        } while(--length&gt;0);</span>
                    }
                }
<span class="nc" id="L1121">            } else {</span>
                /* buffer overflow */
                /* keep incrementing the destIndex for preflighting */
<span class="nc" id="L1124">                destIndex+=length;</span>
            }

<span class="nc" id="L1127">            prevCC=trailCC;</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if(prevCC==0) {</span>
<span class="nc" id="L1129">                reorderStartIndex=destIndex;</span>
            }
        }

<span class="nc" id="L1133">        outTrailCC[0]=prevCC;</span>

<span class="nc" id="L1135">        return destIndex - destStart;</span>
    }

    /* make NFC &amp; NFKC ------------------------------------------------------ */
<span class="nc" id="L1139">    private static final class NextCombiningArgs{</span>
        char[] source;
        int start;
        //int limit;
        char c;
        char c2;
        int/*unsigned*/ combiningIndex;
        char /*unsigned byte*/ cc;
    }

    /* get the composition properties of the next character */
    private static int /*unsigned*/    getNextCombining(NextCombiningArgs args,
                                                    int limit,
                                                    UnicodeSet nx) {
        long/*unsigned*/ norm32;
        int combineFlags;
        /* get properties */
<span class="nc" id="L1156">        args.c=args.source[args.start++];</span>
<span class="nc" id="L1157">        norm32=getNorm32(args.c);</span>

        /* preset output values for most characters */
<span class="nc" id="L1160">        args.c2=0;</span>
<span class="nc" id="L1161">        args.combiningIndex=0;</span>
<span class="nc" id="L1162">        args.cc=0;</span>

<span class="nc bnc" id="L1164" title="All 2 branches missed.">        if((norm32&amp;(CC_MASK|COMBINES_ANY))==0) {</span>
<span class="nc" id="L1165">            return 0;</span>
        } else {
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if(isNorm32Regular(norm32)) {</span>
                /* set cc etc. below */
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            } else if(isNorm32HangulOrJamo(norm32)) {</span>
                /* a compatibility decomposition contained Jamos */
<span class="nc" id="L1171">                args.combiningIndex=(int)((UNSIGNED_INT_MASK)&amp;(0xfff0|</span>
                                                        (norm32&gt;&gt;EXTRA_SHIFT)));
<span class="nc" id="L1173">                return (int)(norm32&amp;COMBINES_ANY);</span>
            } else {
                /* c is a lead surrogate, get the real norm32 */
<span class="nc bnc" id="L1176" title="All 4 branches missed.">                if(args.start!=limit &amp;&amp; UTF16.isTrailSurrogate(args.c2=</span>
                                                     args.source[args.start])) {
<span class="nc" id="L1178">                    ++args.start;</span>
<span class="nc" id="L1179">                    norm32=getNorm32FromSurrogatePair(norm32, args.c2);</span>
                } else {
<span class="nc" id="L1181">                    args.c2=0;</span>
<span class="nc" id="L1182">                    return 0;</span>
                }
            }

<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if(nx_contains(nx, args.c, args.c2)) {</span>
<span class="nc" id="L1187">                return 0; /* excluded: norm32==0 */</span>
            }

<span class="nc" id="L1190">            args.cc= (char)((norm32&gt;&gt;CC_SHIFT)&amp;0xff);</span>

<span class="nc" id="L1192">            combineFlags=(int)(norm32&amp;COMBINES_ANY);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if(combineFlags!=0) {</span>
<span class="nc" id="L1194">                int index = getExtraDataIndex(norm32);</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                args.combiningIndex=index&gt;0 ? extraData[(index-1)] :0;</span>
            }

<span class="nc" id="L1198">            return combineFlags;</span>
        }
    }

    /*
     * given a composition-result starter (c, c2) - which means its cc==0,
     * it combines forward, it has extra data, its norm32!=0,
     * it is not a Hangul or Jamo,
     * get just its combineFwdIndex
     *
     * norm32(c) is special if and only if c2!=0
     */
    private static int/*unsigned*/ getCombiningIndexFromStarter(char c,char c2){
        long/*unsigned*/ norm32;

<span class="nc" id="L1213">        norm32=getNorm32(c);</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if(c2!=0) {</span>
<span class="nc" id="L1215">            norm32=getNorm32FromSurrogatePair(norm32, c2);</span>
        }
<span class="nc" id="L1217">        return extraData[(getExtraDataIndex(norm32)-1)];</span>
    }

    /*
     * Find the recomposition result for
     * a forward-combining character
     * (specified with a pointer to its part of the combiningTable[])
     * and a backward-combining character
     * (specified with its combineBackIndex).
     *
     * If these two characters combine, then set (value, value2)
     * with the code unit(s) of the composition character.
     *
     * Return value:
     * 0    do not combine
     * 1    combine
     * &gt;1   combine, and the composition is a forward-combining starter
     *
     * See unormimp.h for a description of the composition table format.
     */
    private static int/*unsigned*/ combine(char[]table,int tableStart,
                                   int/*unsinged*/ combineBackIndex,
                                    int[] outValues) {
        int/*unsigned*/ key;
        int value,value2;

<span class="nc bnc" id="L1243" title="All 2 branches missed.">        if(outValues.length&lt;2){</span>
<span class="nc" id="L1244">            throw new IllegalArgumentException();</span>
        }

        /* search in the starter's composition table */
        for(;;) {
<span class="nc" id="L1249">            key=table[tableStart++];</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">            if(key&gt;=combineBackIndex) {</span>
<span class="nc" id="L1251">                break;</span>
            }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            tableStart+= ((table[tableStart]&amp;0x8000) != 0)? 2 : 1;</span>
        }

        /* mask off bit 15, the last-entry-in-the-list flag */
<span class="nc bnc" id="L1257" title="All 2 branches missed.">        if((key&amp;0x7fff)==combineBackIndex) {</span>
            /* found! combine! */
<span class="nc" id="L1259">            value=table[tableStart];</span>

            /* is the composition a starter that combines forward? */
<span class="nc" id="L1262">            key=(int)((UNSIGNED_INT_MASK)&amp;((value&amp;0x2000)+1));</span>

            /* get the composition result code point from the variable-length
             * result value
             */
<span class="nc bnc" id="L1267" title="All 2 branches missed.">            if((value&amp;0x8000) != 0) {</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                if((value&amp;0x4000) != 0) {</span>
                    /* surrogate pair composition result */
<span class="nc" id="L1270">                    value=(int)((UNSIGNED_INT_MASK)&amp;((value&amp;0x3ff)|0xd800));</span>
<span class="nc" id="L1271">                    value2=table[tableStart+1];</span>
                } else {
                    /* BMP composition result U+2000..U+ffff */
<span class="nc" id="L1274">                    value=table[tableStart+1];</span>
<span class="nc" id="L1275">                    value2=0;</span>
                }
            } else {
                /* BMP composition result U+0000..U+1fff */
<span class="nc" id="L1279">                value&amp;=0x1fff;</span>
<span class="nc" id="L1280">                value2=0;</span>
            }
<span class="nc" id="L1282">            outValues[0]=value;</span>
<span class="nc" id="L1283">            outValues[1]=value2;</span>
<span class="nc" id="L1284">            return key;</span>
        } else {
            /* not found */
<span class="nc" id="L1287">            return 0;</span>
        }
    }


<span class="nc" id="L1292">    private static final class RecomposeArgs{</span>
        char[] source;
        int start;
        int limit;
    }
    /*
     * recompose the characters in [p..limit[
     * (which is in NFD - decomposed and canonically ordered),
     * adjust limit, and return the trailing cc
     *
     * since for NFKC we may get Jamos in decompositions, we need to
     * recompose those too
     *
     * note that recomposition never lengthens the text:
     * any character consists of either one or two code units;
     * a composition may contain at most one more code unit than the original
     * starter, while the combining mark that is removed has at least one code
     * unit
     */
    private static char/*unsigned byte*/ recompose(RecomposeArgs args, int options, UnicodeSet nx) {
        int  remove, q, r;
        int /*unsigned*/ combineFlags;
        int /*unsigned*/ combineFwdIndex, combineBackIndex;
<span class="nc" id="L1315">        int /*unsigned*/ result, value=0, value2=0;</span>
        int /*unsigned byte*/  prevCC;
        boolean starterIsSupplementary;
        int starter;
<span class="nc" id="L1319">        int[] outValues = new int[2];</span>
<span class="nc" id="L1320">        starter=-1;                   /* no starter */</span>
<span class="nc" id="L1321">        combineFwdIndex=0;            /* will not be used until starter!=NULL */</span>
<span class="nc" id="L1322">        starterIsSupplementary=false; /* will not be used until starter!=NULL */</span>
<span class="nc" id="L1323">        prevCC=0;</span>

<span class="nc" id="L1325">        NextCombiningArgs ncArg = new NextCombiningArgs();</span>
<span class="nc" id="L1326">        ncArg.source  = args.source;</span>

<span class="nc" id="L1328">        ncArg.cc      =0;</span>
<span class="nc" id="L1329">        ncArg.c2      =0;</span>

        for(;;) {
<span class="nc" id="L1332">            ncArg.start = args.start;</span>
<span class="nc" id="L1333">            combineFlags=getNextCombining(ncArg,args.limit,nx);</span>
<span class="nc" id="L1334">            combineBackIndex=ncArg.combiningIndex;</span>
<span class="nc" id="L1335">            args.start = ncArg.start;</span>

<span class="nc bnc" id="L1337" title="All 4 branches missed.">            if(((combineFlags&amp;COMBINES_BACK)!=0) &amp;&amp; starter!=-1) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                if((combineBackIndex&amp;0x8000)!=0) {</span>
                    /* c is a Jamo V/T, see if we can compose it with the
                     * previous character
                     */
                    /* for the PRI #29 fix, check that there is no intervening combining mark */
<span class="nc bnc" id="L1343" title="All 4 branches missed.">                    if((options&amp;BEFORE_PRI_29)!=0 || prevCC==0) {</span>
<span class="nc" id="L1344">                        remove=-1; /* NULL while no Hangul composition */</span>
<span class="nc" id="L1345">                        combineFlags=0;</span>
<span class="nc" id="L1346">                        ncArg.c2=args.source[starter];</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                        if(combineBackIndex==0xfff2) {</span>
                            /* Jamo V, compose with previous Jamo L and following
                             * Jamo T
                             */
<span class="nc" id="L1351">                            ncArg.c2=(char)(ncArg.c2-JAMO_L_BASE);</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">                            if(ncArg.c2&lt;JAMO_L_COUNT) {</span>
<span class="nc" id="L1353">                                remove=args.start-1;</span>
<span class="nc" id="L1354">                                ncArg.c=(char)(HANGUL_BASE+(ncArg.c2*JAMO_V_COUNT+</span>
                                               (ncArg.c-JAMO_V_BASE))*JAMO_T_COUNT);
<span class="nc bnc" id="L1356" title="All 4 branches missed.">                                if(args.start!=args.limit &amp;&amp;</span>
                                            (ncArg.c2=(char)(args.source[args.start]
                                             -JAMO_T_BASE))&lt;JAMO_T_COUNT) {
<span class="nc" id="L1359">                                    ++args.start;</span>
<span class="nc" id="L1360">                                    ncArg.c+=ncArg.c2;</span>
                                 } else {
                                     /* the result is an LV syllable, which is a starter (unlike LVT) */
<span class="nc" id="L1363">                                     combineFlags=COMBINES_FWD;</span>
                                }
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                                if(!nx_contains(nx, ncArg.c)) {</span>
<span class="nc" id="L1366">                                    args.source[starter]=ncArg.c;</span>
                                   } else {
                                    /* excluded */
<span class="nc bnc" id="L1369" title="All 2 branches missed.">                                    if(!isHangulWithoutJamoT(ncArg.c)) {</span>
<span class="nc" id="L1370">                                        --args.start; /* undo the ++args.start from reading the Jamo T */</span>
                                    }
                                    /* c is modified but not used any more -- c=*(p-1); -- re-read the Jamo V/T */
<span class="nc" id="L1373">                                    remove=args.start;</span>
                                }
                            }

                        /*
                         * Normally, the following can not occur:
                         * Since the input is in NFD, there are no Hangul LV syllables that
                         * a Jamo T could combine with.
                         * All Jamo Ts are combined above when handling Jamo Vs.
                         *
                         * However, before the PRI #29 fix, this can occur due to
                         * an intervening combining mark between the Hangul LV and the Jamo T.
                         */
                        } else {
                            /* Jamo T, compose with previous Hangul that does not have a Jamo T */
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                            if(isHangulWithoutJamoT(ncArg.c2)) {</span>
<span class="nc" id="L1389">                                ncArg.c2+=ncArg.c-JAMO_T_BASE;</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                                if(!nx_contains(nx, ncArg.c2)) {</span>
<span class="nc" id="L1391">                                    remove=args.start-1;</span>
<span class="nc" id="L1392">                                    args.source[starter]=ncArg.c2;</span>
                                }
                            }
                        }

<span class="nc bnc" id="L1397" title="All 2 branches missed.">                        if(remove!=-1) {</span>
                            /* remove the Jamo(s) */
<span class="nc" id="L1399">                            q=remove;</span>
<span class="nc" id="L1400">                            r=args.start;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                            while(r&lt;args.limit) {</span>
<span class="nc" id="L1402">                                args.source[q++]=args.source[r++];</span>
                            }
<span class="nc" id="L1404">                            args.start=remove;</span>
<span class="nc" id="L1405">                            args.limit=q;</span>
                        }

<span class="nc" id="L1408">                        ncArg.c2=0; /* c2 held *starter temporarily */</span>

<span class="nc bnc" id="L1410" title="All 2 branches missed.">                        if(combineFlags!=0) {</span>
                            /*
                             * not starter=NULL because the composition is a Hangul LV syllable
                             * and might combine once more (but only before the PRI #29 fix)
                             */

                            /* done? */
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                            if(args.start==args.limit) {</span>
<span class="nc" id="L1418">                                return (char)prevCC;</span>
                            }

                            /* the composition is a Hangul LV syllable which is a starter that combines forward */
<span class="nc" id="L1422">                            combineFwdIndex=0xfff0;</span>

                            /* we combined; continue with looking for compositions */
<span class="nc" id="L1425">                            continue;</span>
                        }
                    }

                    /*
                     * now: cc==0 and the combining index does not include
                     * &quot;forward&quot; -&gt; the rest of the loop body will reset starter
                     * to NULL; technically, a composed Hangul syllable is a
                     * starter, but it does not combine forward now that we have
                     * consumed all eligible Jamos; for Jamo V/T, combineFlags
                     * does not contain _NORM_COMBINES_FWD
                     */

<span class="nc bnc" id="L1438" title="All 12 branches missed.">                } else if(</span>
                    /* the starter is not a Hangul LV or Jamo V/T and */
                    !((combineFwdIndex&amp;0x8000)!=0) &amp;&amp;
                    /* the combining mark is not blocked and */
                    ((options&amp;BEFORE_PRI_29)!=0 ?
                        (prevCC!=ncArg.cc || prevCC==0) :
                        (prevCC&lt;ncArg.cc || prevCC==0)) &amp;&amp;
                    /* the starter and the combining mark (c, c2) do combine */
<span class="nc bnc" id="L1446" title="All 2 branches missed.">                    0!=(result=combine(combiningTable,combineFwdIndex,</span>
                                       combineBackIndex, outValues)) &amp;&amp;
                    /* the composition result is not excluded */
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                    !nx_contains(nx, (char)value, (char)value2)</span>
                ) {
<span class="nc" id="L1451">                    value=outValues[0];</span>
<span class="nc" id="L1452">                    value2=outValues[1];</span>
                    /* replace the starter with the composition, remove the
                     * combining mark
                     */
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                    remove= ncArg.c2==0 ? args.start-1 : args.start-2; /* index to the combining mark */</span>

                    /* replace the starter with the composition */
<span class="nc" id="L1459">                    args.source[starter]=(char)value;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                    if(starterIsSupplementary) {</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">                        if(value2!=0) {</span>
                            /* both are supplementary */
<span class="nc" id="L1463">                            args.source[starter+1]=(char)value2;</span>
                        } else {
                            /* the composition is shorter than the starter,
                             * move the intermediate characters forward one */
<span class="nc" id="L1467">                            starterIsSupplementary=false;</span>
<span class="nc" id="L1468">                            q=starter+1;</span>
<span class="nc" id="L1469">                            r=q+1;</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">                            while(r&lt;remove) {</span>
<span class="nc" id="L1471">                                args.source[q++]=args.source[r++];</span>
                            }
<span class="nc" id="L1473">                            --remove;</span>
                        }
<span class="nc bnc" id="L1475" title="All 2 branches missed.">                    } else if(value2!=0) { // for U+1109A, U+1109C, and U+110AB</span>
<span class="nc" id="L1476">                        starterIsSupplementary=true;</span>
<span class="nc" id="L1477">                        args.source[starter+1]=(char)value2;</span>
                    /* } else { both are on the BMP, nothing more to do */
                    }

                    /* remove the combining mark by moving the following text
                     * over it */
<span class="nc bnc" id="L1483" title="All 2 branches missed.">                    if(remove&lt;args.start) {</span>
<span class="nc" id="L1484">                        q=remove;</span>
<span class="nc" id="L1485">                        r=args.start;</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">                        while(r&lt;args.limit) {</span>
<span class="nc" id="L1487">                            args.source[q++]=args.source[r++];</span>
                        }
<span class="nc" id="L1489">                        args.start=remove;</span>
<span class="nc" id="L1490">                        args.limit=q;</span>
                    }

                    /* keep prevCC because we removed the combining mark */

                    /* done? */
<span class="nc bnc" id="L1496" title="All 2 branches missed.">                    if(args.start==args.limit) {</span>
<span class="nc" id="L1497">                        return (char)prevCC;</span>
                    }

                    /* is the composition a starter that combines forward? */
<span class="nc bnc" id="L1501" title="All 2 branches missed.">                    if(result&gt;1) {</span>
<span class="nc" id="L1502">                       combineFwdIndex=getCombiningIndexFromStarter((char)value,</span>
                                                                  (char)value2);
                    } else {
<span class="nc" id="L1505">                       starter=-1;</span>
                    }

                    /* we combined; continue with looking for compositions */
<span class="nc" id="L1509">                    continue;</span>
                }
            }

            /* no combination this time */
<span class="nc" id="L1514">            prevCC=ncArg.cc;</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">            if(args.start==args.limit) {</span>
<span class="nc" id="L1516">                return (char)prevCC;</span>
            }

            /* if (c, c2) did not combine, then check if it is a starter */
<span class="nc bnc" id="L1520" title="All 2 branches missed.">            if(ncArg.cc==0) {</span>
                /* found a new starter; combineFlags==0 if (c, c2) is excluded */
<span class="nc bnc" id="L1522" title="All 2 branches missed.">                if((combineFlags&amp;COMBINES_FWD)!=0) {</span>
                    /* it may combine with something, prepare for it */
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                    if(ncArg.c2==0) {</span>
<span class="nc" id="L1525">                        starterIsSupplementary=false;</span>
<span class="nc" id="L1526">                        starter=args.start-1;</span>
                    } else {
<span class="nc" id="L1528">                        starterIsSupplementary=false;</span>
<span class="nc" id="L1529">                        starter=args.start-2;</span>
                    }
<span class="nc" id="L1531">                    combineFwdIndex=combineBackIndex;</span>
                } else {
                    /* it will not combine with anything */
<span class="nc" id="L1534">                    starter=-1;</span>
                }
<span class="nc bnc" id="L1536" title="All 2 branches missed.">            } else if((options&amp;OPTIONS_COMPOSE_CONTIGUOUS)!=0) {</span>
                /* FCC: no discontiguous compositions; any intervening character blocks */
<span class="nc" id="L1538">                starter=-1;</span>
            }
        }
    }

    // find the last true starter between src[start]....src[current] going
    // backwards and return its index
    private static int findPreviousStarter(char[]src, int srcStart, int current,
                                          int/*unsigned*/ ccOrQCMask,
                                          int/*unsigned*/ decompQCMask,
                                          char minNoMaybe) {
       long norm32;
<span class="nc" id="L1550">       PrevArgs args = new PrevArgs();</span>
<span class="nc" id="L1551">       args.src = src;</span>
<span class="nc" id="L1552">       args.start = srcStart;</span>
<span class="nc" id="L1553">       args.current = current;</span>

<span class="nc bnc" id="L1555" title="All 2 branches missed.">       while(args.start&lt;args.current) {</span>
<span class="nc" id="L1556">           norm32= getPrevNorm32(args, minNoMaybe, ccOrQCMask|decompQCMask);</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">           if(isTrueStarter(norm32, ccOrQCMask, decompQCMask)) {</span>
<span class="nc" id="L1558">               break;</span>
           }
       }
<span class="nc" id="L1561">       return args.current;</span>
    }

    /* find the first true starter in [src..limit[ and return the
     * pointer to it
     */
    private static int/*index*/    findNextStarter(char[] src,int start,int limit,
                                                 int/*unsigned*/ qcMask,
                                                 int/*unsigned*/ decompQCMask,
                                                 char minNoMaybe) {
        int p;
        long/*unsigned*/ norm32;
        int ccOrQCMask;
        char c, c2;

<span class="nc" id="L1576">        ccOrQCMask=CC_MASK|qcMask;</span>

<span class="nc" id="L1578">        DecomposeArgs decompArgs = new DecomposeArgs();</span>

        for(;;) {
<span class="nc bnc" id="L1581" title="All 2 branches missed.">            if(start==limit) {</span>
<span class="nc" id="L1582">                break; /* end of string */</span>
            }
<span class="nc" id="L1584">            c=src[start];</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">            if(c&lt;minNoMaybe) {</span>
<span class="nc" id="L1586">                break; /* catches NUL terminater, too */</span>
            }

<span class="nc" id="L1589">            norm32=getNorm32(c);</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">            if((norm32&amp;ccOrQCMask)==0) {</span>
<span class="nc" id="L1591">                break; /* true starter */</span>
            }

<span class="nc bnc" id="L1594" title="All 2 branches missed.">            if(isNorm32LeadSurrogate(norm32)) {</span>
                /* c is a lead surrogate, get the real norm32 */
<span class="nc bnc" id="L1596" title="All 2 branches missed.">                if((start+1)==limit ||</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">                                   !UTF16.isTrailSurrogate(c2=(src[start+1]))){</span>
                    /* unmatched first surrogate: counts as a true starter */
<span class="nc" id="L1599">                    break;</span>
                }
<span class="nc" id="L1601">                norm32=getNorm32FromSurrogatePair(norm32, c2);</span>

<span class="nc bnc" id="L1603" title="All 2 branches missed.">                if((norm32&amp;ccOrQCMask)==0) {</span>
<span class="nc" id="L1604">                    break; /* true starter */</span>
                }
            } else {
<span class="nc" id="L1607">                c2=0;</span>
            }

            /* (c, c2) is not a true starter but its decomposition may be */
<span class="nc bnc" id="L1611" title="All 2 branches missed.">            if((norm32&amp;decompQCMask)!=0) {</span>
                /* (c, c2) decomposes, get everything from the variable-length
                 *  extra data */
<span class="nc" id="L1614">                p=decompose(norm32, decompQCMask, decompArgs);</span>

                /* get the first character's norm32 to check if it is a true
                 * starter */
<span class="nc bnc" id="L1618" title="All 4 branches missed.">                if(decompArgs.cc==0 &amp;&amp; (getNorm32(extraData,p, qcMask)&amp;qcMask)==0) {</span>
<span class="nc" id="L1619">                    break; /* true starter */</span>
                }
            }

<span class="nc bnc" id="L1623" title="All 2 branches missed.">            start+= c2==0 ? 1 : 2; /* not a true starter, continue */</span>
        }

<span class="nc" id="L1626">        return start;</span>
    }


<span class="nc" id="L1630">    private static final class ComposePartArgs{</span>
        int prevCC;
        int length;   /* length of decomposed part */
    }

     /* decompose and recompose [prevStarter..src[ */
    private static char[] composePart(ComposePartArgs args,
                                      int prevStarter,
                                         char[] src, int start, int limit,
                                       int options,
                                       UnicodeSet nx) {
        int recomposeLimit;
<span class="nc bnc" id="L1642" title="All 2 branches missed.">        boolean compat =((options&amp;OPTIONS_COMPAT)!=0);</span>

        /* decompose [prevStarter..src[ */
<span class="nc" id="L1645">        int[] outTrailCC = new int[1];</span>
<span class="nc" id="L1646">        char[] buffer = new char[(limit-prevStarter)*MAX_BUFFER_SIZE];</span>

        for(;;){
<span class="nc" id="L1649">            args.length=decompose(src,prevStarter,(start),</span>
                                      buffer,0,buffer.length,
                                      compat,outTrailCC,nx);
<span class="nc bnc" id="L1652" title="All 2 branches missed.">            if(args.length&lt;=buffer.length){</span>
<span class="nc" id="L1653">                break;</span>
            }else{
<span class="nc" id="L1655">                buffer = new char[args.length];</span>
            }
        }

        /* recompose the decomposition */
<span class="nc" id="L1660">        recomposeLimit=args.length;</span>

<span class="nc bnc" id="L1662" title="All 2 branches missed.">        if(args.length&gt;=2) {</span>
<span class="nc" id="L1663">            RecomposeArgs rcArgs = new RecomposeArgs();</span>
<span class="nc" id="L1664">            rcArgs.source    = buffer;</span>
<span class="nc" id="L1665">            rcArgs.start    = 0;</span>
<span class="nc" id="L1666">            rcArgs.limit    = recomposeLimit;</span>
<span class="nc" id="L1667">            args.prevCC=recompose(rcArgs, options, nx);</span>
<span class="nc" id="L1668">            recomposeLimit = rcArgs.limit;</span>
        }

        /* return with a pointer to the recomposition and its length */
<span class="nc" id="L1672">        args.length=recomposeLimit;</span>
<span class="nc" id="L1673">        return buffer;</span>
    }

    private static boolean composeHangul(char prev, char c,
                                         long/*unsigned*/ norm32,
                                         char[] src,int[] srcIndex, int limit,
                                            boolean compat,
                                         char[] dest,int destIndex,
                                         UnicodeSet nx) {
<span class="nc" id="L1682">        int start=srcIndex[0];</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">        if(isJamoVTNorm32JamoV(norm32)) {</span>
            /* c is a Jamo V, compose with previous Jamo L and
             * following Jamo T */
<span class="nc" id="L1686">            prev=(char)(prev-JAMO_L_BASE);</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">            if(prev&lt;JAMO_L_COUNT) {</span>
<span class="nc" id="L1688">                c=(char)(HANGUL_BASE+(prev*JAMO_V_COUNT+</span>
                                                 (c-JAMO_V_BASE))*JAMO_T_COUNT);

                /* check if the next character is a Jamo T (normal or
                 * compatibility) */
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                if(start!=limit) {</span>
                    char next, t;

<span class="nc" id="L1696">                    next=src[start];</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                    if((t=(char)(next-JAMO_T_BASE))&lt;JAMO_T_COUNT) {</span>
                        /* normal Jamo T */
<span class="nc" id="L1699">                        ++start;</span>
<span class="nc" id="L1700">                        c+=t;</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                    } else if(compat) {</span>
                        /* if NFKC, then check for compatibility Jamo T
                         * (BMP only) */
<span class="nc" id="L1704">                        norm32=getNorm32(next);</span>
<span class="nc bnc" id="L1705" title="All 4 branches missed.">                        if(isNorm32Regular(norm32) &amp;&amp; ((norm32&amp;QC_NFKD)!=0)) {</span>
                            int p /*index into extra data array*/;
<span class="nc" id="L1707">                            DecomposeArgs dcArgs = new DecomposeArgs();</span>
<span class="nc" id="L1708">                            p=decompose(norm32, QC_NFKD, dcArgs);</span>
<span class="nc bnc" id="L1709" title="All 4 branches missed.">                            if(dcArgs.length==1 &amp;&amp;</span>
                                   (t=(char)(extraData[p]-JAMO_T_BASE))
                                                   &lt;JAMO_T_COUNT) {
                                /* compatibility Jamo T */
<span class="nc" id="L1713">                                ++start;</span>
<span class="nc" id="L1714">                                c+=t;</span>
                            }
                        }
                    }
                }
<span class="nc bnc" id="L1719" title="All 2 branches missed.">                if(nx_contains(nx, c)) {</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">                    if(!isHangulWithoutJamoT(c)) {</span>
<span class="nc" id="L1721">                        --start; /* undo ++start from reading the Jamo T */</span>
                    }
<span class="nc" id="L1723">                    return false;</span>
                }
<span class="nc" id="L1725">                dest[destIndex]=c;</span>
<span class="nc" id="L1726">                srcIndex[0]=start;</span>
<span class="nc" id="L1727">                return true;</span>
            }
<span class="nc bnc" id="L1729" title="All 2 branches missed.">        } else if(isHangulWithoutJamoT(prev)) {</span>
            /* c is a Jamo T, compose with previous Hangul LV that does not
             * contain a Jamo T */
<span class="nc" id="L1732">            c=(char)(prev+(c-JAMO_T_BASE));</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">            if(nx_contains(nx, c)) {</span>
<span class="nc" id="L1734">                return false;</span>
            }
<span class="nc" id="L1736">            dest[destIndex]=c;</span>
<span class="nc" id="L1737">            srcIndex[0]=start;</span>
<span class="nc" id="L1738">            return true;</span>
        }
<span class="nc" id="L1740">        return false;</span>
    }
    /*
    public static int compose(char[] src, char[] dest,boolean compat, UnicodeSet nx){
        return compose(src,0,src.length,dest,0,dest.length,compat, nx);
    }
    */

    public static int compose(char[] src, int srcStart, int srcLimit,
                              char[] dest,int destStart,int destLimit,
                              int options,UnicodeSet nx) {

        int prevSrc, prevStarter;
        long/*unsigned*/ norm32;
        int ccOrQCMask, qcMask;
        int  reorderStartIndex, length;
        char c, c2, minNoMaybe;
        int/*unsigned byte*/ cc, prevCC;
<span class="nc" id="L1758">        int[] ioIndex = new int[1];</span>
<span class="nc" id="L1759">        int destIndex = destStart;</span>
<span class="nc" id="L1760">        int srcIndex = srcStart;</span>

<span class="nc bnc" id="L1762" title="All 2 branches missed.">        if((options&amp;OPTIONS_COMPAT)!=0) {</span>
<span class="nc" id="L1763">            minNoMaybe=(char)indexes[INDEX_MIN_NFKC_NO_MAYBE];</span>
<span class="nc" id="L1764">            qcMask=QC_NFKC;</span>
        } else {
<span class="nc" id="L1766">            minNoMaybe=(char)indexes[INDEX_MIN_NFC_NO_MAYBE];</span>
<span class="nc" id="L1767">            qcMask=QC_NFC;</span>
        }

        /*
         * prevStarter points to the last character before the current one
         * that is a &quot;true&quot; starter with cc==0 and quick check &quot;yes&quot;.
         *
         * prevStarter will be used instead of looking for a true starter
         * while incrementally decomposing [prevStarter..prevSrc[
         * in _composePart(). Having a good prevStarter allows to just decompose
         * the entire [prevStarter..prevSrc[.
         *
         * When _composePart() backs out from prevSrc back to prevStarter,
         * then it also backs out destIndex by the same amount.
         * Therefore, at all times, the (prevSrc-prevStarter) source units
         * must correspond 1:1 to destination units counted with destIndex,
         * except for reordering.
         * This is true for the qc &quot;yes&quot; characters copied in the fast loop,
         * and for pure reordering.
         * prevStarter must be set forward to src when this is not true:
         * In _composePart() and after composing a Hangul syllable.
         *
         * This mechanism relies on the assumption that the decomposition of a
         * true starter also begins with a true starter. gennorm/store.c checks
         * for this.
         */
<span class="nc" id="L1793">        prevStarter=srcIndex;</span>

<span class="nc" id="L1795">        ccOrQCMask=CC_MASK|qcMask;</span>
<span class="nc" id="L1796">        /*destIndex=*/reorderStartIndex=0;/* ####TODO#### check this **/</span>
<span class="nc" id="L1797">        prevCC=0;</span>

        /* avoid compiler warnings */
<span class="nc" id="L1800">        norm32=0;</span>
<span class="nc" id="L1801">        c=0;</span>

        for(;;) {
            /* count code units below the minimum or with irrelevant data for
             * the quick check */
<span class="nc" id="L1806">            prevSrc=srcIndex;</span>

<span class="nc bnc" id="L1808" title="All 4 branches missed.">            while(srcIndex!=srcLimit &amp;&amp; ((c=src[srcIndex])&lt;minNoMaybe ||</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                     ((norm32=getNorm32(c))&amp;ccOrQCMask)==0)) {</span>
<span class="nc" id="L1810">                prevCC=0;</span>
<span class="nc" id="L1811">                ++srcIndex;</span>
            }


            /* copy these code units all at once */
<span class="nc bnc" id="L1816" title="All 2 branches missed.">            if(srcIndex!=prevSrc) {</span>
<span class="nc" id="L1817">                length=srcIndex-prevSrc;</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">                if((destIndex+length)&lt;=destLimit) {</span>
<span class="nc" id="L1819">                    System.arraycopy(src,prevSrc,dest,destIndex,length);</span>
                }
<span class="nc" id="L1821">                destIndex+=length;</span>
<span class="nc" id="L1822">                reorderStartIndex=destIndex;</span>

                /* set prevStarter to the last character in the quick check
                 * loop */
<span class="nc" id="L1826">                prevStarter=srcIndex-1;</span>
<span class="nc bnc" id="L1827" title="All 4 branches missed.">                if(UTF16.isTrailSurrogate(src[prevStarter]) &amp;&amp;</span>
                    prevSrc&lt;prevStarter &amp;&amp;
<span class="nc bnc" id="L1829" title="All 2 branches missed.">                    UTF16.isLeadSurrogate(src[(prevStarter-1)])) {</span>
<span class="nc" id="L1830">                    --prevStarter;</span>
                }

<span class="nc" id="L1833">                prevSrc=srcIndex;</span>
            }

            /* end of source reached? */
<span class="nc bnc" id="L1837" title="All 2 branches missed.">            if(srcIndex==srcLimit) {</span>
<span class="nc" id="L1838">                break;</span>
            }

            /* c already contains *src and norm32 is set for it, increment src*/
<span class="nc" id="L1842">            ++srcIndex;</span>

            /*
             * source buffer pointers:
             *
             *  all done      quick check   current char  not yet
             *                &quot;yes&quot; but     (c, c2)       processed
             *                may combine
             *                forward
             * [-------------[-------------[-------------[-------------[
             * |             |             |             |             |
             * start         prevStarter   prevSrc       src           limit
             *
             *
             * destination buffer pointers and indexes:
             *
             *  all done      might take    not filled yet
             *                characters for
             *                reordering
             * [-------------[-------------[-------------[
             * |             |             |             |
             * dest      reorderStartIndex destIndex     destCapacity
             */

            /* check one above-minimum, relevant code unit */
            /*
             * norm32 is for c=*(src-1), and the quick check flag is &quot;no&quot; or
             * &quot;maybe&quot;, and/or cc!=0
             * check for Jamo V/T, then for surrogates and regular characters
             * c is not a Hangul syllable or Jamo L because
             * they are not marked with no/maybe for NFC &amp; NFKC(and their cc==0)
             */
<span class="nc bnc" id="L1874" title="All 2 branches missed.">            if(isNorm32HangulOrJamo(norm32)) {</span>
                /*
                 * c is a Jamo V/T:
                 * try to compose with the previous character, Jamo V also with
                 * a following Jamo T, and set values here right now in case we
                 * just continue with the main loop
                 */
<span class="nc" id="L1881">                prevCC=cc=0;</span>
<span class="nc" id="L1882">                reorderStartIndex=destIndex;</span>
<span class="nc" id="L1883">                ioIndex[0]=srcIndex;</span>
<span class="nc bnc" id="L1884" title="All 6 branches missed.">                if(</span>
                    destIndex&gt;0 &amp;&amp;
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                    composeHangul(src[(prevSrc-1)], c, norm32,src, ioIndex,</span>
                                  srcLimit, (options&amp;OPTIONS_COMPAT)!=0, dest,
                                  destIndex&lt;=destLimit ? destIndex-1: 0,
                                  nx)
                ) {
<span class="nc" id="L1891">                    srcIndex=ioIndex[0];</span>
<span class="nc" id="L1892">                    prevStarter=srcIndex;</span>
<span class="nc" id="L1893">                    continue;</span>
                }

<span class="nc" id="L1896">                srcIndex = ioIndex[0];</span>

                /* the Jamo V/T did not compose into a Hangul syllable, just
                 * append to dest */
<span class="nc" id="L1900">                c2=0;</span>
<span class="nc" id="L1901">                length=1;</span>
<span class="nc" id="L1902">                prevStarter=prevSrc;</span>
            } else {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">                if(isNorm32Regular(norm32)) {</span>
<span class="nc" id="L1905">                    c2=0;</span>
<span class="nc" id="L1906">                    length=1;</span>
                } else {
                    /* c is a lead surrogate, get the real norm32 */
<span class="nc bnc" id="L1909" title="All 2 branches missed.">                    if(srcIndex!=srcLimit &amp;&amp;</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">                                     UTF16.isTrailSurrogate(c2=src[srcIndex])) {</span>
<span class="nc" id="L1911">                        ++srcIndex;</span>
<span class="nc" id="L1912">                        length=2;</span>
<span class="nc" id="L1913">                        norm32=getNorm32FromSurrogatePair(norm32, c2);</span>
                    } else {
                        /* c is an unpaired lead surrogate, nothing to do */
<span class="nc" id="L1916">                        c2=0;</span>
<span class="nc" id="L1917">                        length=1;</span>
<span class="nc" id="L1918">                        norm32=0;</span>
                    }
                }
<span class="nc" id="L1921">                ComposePartArgs args =new ComposePartArgs();</span>

                /* we are looking at the character (c, c2) at [prevSrc..src[ */
<span class="nc bnc" id="L1924" title="All 2 branches missed.">                if(nx_contains(nx, c, c2)) {</span>
                    /* excluded: norm32==0 */
<span class="nc" id="L1926">                    cc=0;</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">                } else if((norm32&amp;qcMask)==0) {</span>
<span class="nc" id="L1928">                    cc=(int)((UNSIGNED_BYTE_MASK)&amp;(norm32&gt;&gt;CC_SHIFT));</span>
                } else {
                    char[] p;

                    /*
                     * find appropriate boundaries around this character,
                     * decompose the source text from between the boundaries,
                     * and recompose it
                     *
                     * this puts the intermediate text into the side buffer because
                     * it might be longer than the recomposition end result,
                     * or the destination buffer may be too short or missing
                     *
                     * note that destIndex may be adjusted backwards to account
                     * for source text that passed the quick check but needed to
                     * take part in the recomposition
                     */
<span class="nc" id="L1945">                    int decompQCMask=(qcMask&lt;&lt;2)&amp;0xf; /* decomposition quick check mask */</span>
                    /*
                     * find the last true starter in [prevStarter..src[
                     * it is either the decomposition of the current character (at prevSrc),
                     * or prevStarter
                     */
<span class="nc bnc" id="L1951" title="All 2 branches missed.">                    if(isTrueStarter(norm32, CC_MASK|qcMask, decompQCMask)) {</span>
<span class="nc" id="L1952">                        prevStarter=prevSrc;</span>
                    } else {
                        /* adjust destIndex: back out what had been copied with qc &quot;yes&quot; */
<span class="nc" id="L1955">                        destIndex-=prevSrc-prevStarter;</span>
                    }

                    /* find the next true starter in [src..limit[ */
<span class="nc" id="L1959">                    srcIndex=findNextStarter(src, srcIndex,srcLimit, qcMask,</span>
                                               decompQCMask, minNoMaybe);
                    //args.prevStarter = prevStarter;
<span class="nc" id="L1962">                    args.prevCC    = prevCC;</span>
                    //args.destIndex = destIndex;
<span class="nc" id="L1964">                    args.length = length;</span>
<span class="nc" id="L1965">                    p=composePart(args,prevStarter,src,srcIndex,srcLimit,options,nx);</span>

<span class="nc bnc" id="L1967" title="All 2 branches missed.">                    if(p==null) {</span>
                        /* an error occurred (out of memory) */
<span class="nc" id="L1969">                        break;</span>
                    }

<span class="nc" id="L1972">                    prevCC      = args.prevCC;</span>
<span class="nc" id="L1973">                    length      = args.length;</span>

                    /* append the recomposed buffer contents to the destination
                     * buffer */
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                    if((destIndex+args.length)&lt;=destLimit) {</span>
<span class="nc" id="L1978">                        int i=0;</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                        while(i&lt;args.length) {</span>
<span class="nc" id="L1980">                            dest[destIndex++]=p[i++];</span>
<span class="nc" id="L1981">                            --length;</span>
                        }
<span class="nc" id="L1983">                    } else {</span>
                        /* buffer overflow */
                        /* keep incrementing the destIndex for preflighting */
<span class="nc" id="L1986">                        destIndex+=length;</span>
                    }

<span class="nc" id="L1989">                    prevStarter=srcIndex;</span>
<span class="nc" id="L1990">                    continue;</span>
                }
            }

            /* append the single code point (c, c2) to the destination buffer */
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            if((destIndex+length)&lt;=destLimit) {</span>
<span class="nc bnc" id="L1996" title="All 4 branches missed.">                if(cc!=0 &amp;&amp; cc&lt;prevCC) {</span>
                    /* (c, c2) is out of order with respect to the preceding
                     * text */
<span class="nc" id="L1999">                    int reorderSplit= destIndex;</span>
<span class="nc" id="L2000">                    destIndex+=length;</span>
<span class="nc" id="L2001">                    prevCC=insertOrdered(dest,reorderStartIndex, reorderSplit,</span>
                                         destIndex, c, c2, cc);
<span class="nc" id="L2003">                } else {</span>
                    /* just append (c, c2) */
<span class="nc" id="L2005">                    dest[destIndex++]=c;</span>
<span class="nc bnc" id="L2006" title="All 2 branches missed.">                    if(c2!=0) {</span>
<span class="nc" id="L2007">                        dest[destIndex++]=c2;</span>
                    }
<span class="nc" id="L2009">                    prevCC=cc;</span>
                }
            } else {
                /* buffer overflow */
                /* keep incrementing the destIndex for preflighting */
<span class="nc" id="L2014">                destIndex+=length;</span>
<span class="nc" id="L2015">                prevCC=cc;</span>
            }
        }

<span class="nc" id="L2019">        return destIndex - destStart;</span>
    }

    public static int getCombiningClass(int c) {
        long norm32;
<span class="nc" id="L2024">        norm32=getNorm32(c);</span>
<span class="nc" id="L2025">        return (int)((norm32&gt;&gt;CC_SHIFT)&amp;0xFF);</span>
    }

    public static boolean isFullCompositionExclusion(int c) {
<span class="nc bnc" id="L2029" title="All 2 branches missed.">        if(isFormatVersion_2_1) {</span>
<span class="nc" id="L2030">            int aux =AuxTrieImpl.auxTrie.getCodePointValue(c);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">            return (aux &amp; AUX_COMP_EX_MASK)!=0;</span>
        } else {
<span class="nc" id="L2033">            return false;</span>
        }
    }

    public static boolean isCanonSafeStart(int c) {
<span class="nc bnc" id="L2038" title="All 2 branches missed.">        if(isFormatVersion_2_1) {</span>
<span class="nc" id="L2039">            int aux = AuxTrieImpl.auxTrie.getCodePointValue(c);</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">            return (aux &amp; AUX_UNSAFE_MASK)==0;</span>
        } else {
<span class="nc" id="L2042">            return false;</span>
        }
    }

    /* Is c an NF&lt;mode&gt;-skippable code point? See unormimp.h. */
    public static boolean isNFSkippable(int c, NormalizerBase.Mode mode, long mask) {
        long /*unsigned int*/ norm32;
<span class="nc" id="L2049">        mask = mask &amp; UNSIGNED_INT_MASK;</span>
        char aux;

        /* check conditions (a)..(e), see unormimp.h */
<span class="nc" id="L2053">        norm32 = getNorm32(c);</span>

<span class="nc bnc" id="L2055" title="All 2 branches missed.">        if((norm32&amp;mask)!=0) {</span>
<span class="nc" id="L2056">            return false; /* fails (a)..(e), not skippable */</span>
        }

<span class="nc bnc" id="L2059" title="All 6 branches missed.">        if(mode == NormalizerBase.NFD || mode == NormalizerBase.NFKD || mode == NormalizerBase.NONE){</span>
<span class="nc" id="L2060">            return true; /* NF*D, passed (a)..(c), is skippable */</span>
        }
        /* check conditions (a)..(e), see unormimp.h */

        /* NF*C/FCC, passed (a)..(e) */
<span class="nc bnc" id="L2065" title="All 2 branches missed.">        if((norm32&amp; QC_NFD)==0) {</span>
<span class="nc" id="L2066">            return true; /* no canonical decomposition, is skippable */</span>
        }

        /* check Hangul syllables algorithmically */
<span class="nc bnc" id="L2070" title="All 2 branches missed.">        if(isNorm32HangulOrJamo(norm32)) {</span>
            /* Jamo passed (a)..(e) above, must be Hangul */
<span class="nc bnc" id="L2072" title="All 2 branches missed.">            return !isHangulWithoutJamoT((char)c); /* LVT are skippable, LV are not */</span>
        }

        /* if(mode&lt;=UNORM_NFKC) { -- enable when implementing FCC */
        /* NF*C, test (f) flag */
<span class="nc bnc" id="L2077" title="All 2 branches missed.">        if(!isFormatVersion_2_2) {</span>
<span class="nc" id="L2078">            return false; /* no (f) data, say not skippable to be safe */</span>
        }


<span class="nc" id="L2082">        aux = AuxTrieImpl.auxTrie.getCodePointValue(c);</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">        return (aux&amp;AUX_NFC_SKIP_F_MASK)==0; /* TRUE=skippable if the (f) flag is not set */</span>

        /* } else { FCC, test fcd&lt;=1 instead of the above } */
    }

    public static UnicodeSet addPropertyStarts(UnicodeSet set) {
        int c;

        /* add the start code point of each same-value range of each trie */
        //utrie_enum(&amp;normTrie, NULL, _enumPropertyStartsRange, set);
<span class="nc" id="L2093">        TrieIterator normIter = new TrieIterator(NormTrieImpl.normTrie);</span>
<span class="nc" id="L2094">        RangeValueIterator.Element normResult = new RangeValueIterator.Element();</span>

<span class="nc bnc" id="L2096" title="All 2 branches missed.">        while(normIter.next(normResult)){</span>
<span class="nc" id="L2097">            set.add(normResult.start);</span>
        }

        //utrie_enum(&amp;fcdTrie, NULL, _enumPropertyStartsRange, set);
<span class="nc" id="L2101">        TrieIterator fcdIter  = new TrieIterator(FCDTrieImpl.fcdTrie);</span>
<span class="nc" id="L2102">        RangeValueIterator.Element fcdResult = new RangeValueIterator.Element();</span>

<span class="nc bnc" id="L2104" title="All 2 branches missed.">        while(fcdIter.next(fcdResult)){</span>
<span class="nc" id="L2105">            set.add(fcdResult.start);</span>
        }

<span class="nc bnc" id="L2108" title="All 2 branches missed.">        if(isFormatVersion_2_1){</span>
            //utrie_enum(&amp;auxTrie, NULL, _enumPropertyStartsRange, set);
<span class="nc" id="L2110">            TrieIterator auxIter  = new TrieIterator(AuxTrieImpl.auxTrie);</span>
<span class="nc" id="L2111">            RangeValueIterator.Element auxResult = new RangeValueIterator.Element();</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">            while(auxIter.next(auxResult)){</span>
<span class="nc" id="L2113">                set.add(auxResult.start);</span>
            }
        }
        /* add Hangul LV syllables and LV+1 because of skippables */
<span class="nc bnc" id="L2117" title="All 2 branches missed.">        for(c=HANGUL_BASE; c&lt;HANGUL_BASE+HANGUL_COUNT; c+=JAMO_T_COUNT) {</span>
<span class="nc" id="L2118">            set.add(c);</span>
<span class="nc" id="L2119">            set.add(c+1);</span>
        }
<span class="nc" id="L2121">        set.add(HANGUL_BASE+HANGUL_COUNT); /* add Hangul+1 to continue with other properties */</span>
<span class="nc" id="L2122">        return set; // for chaining</span>
    }

    /**
     * Internal API, used in UCharacter.getIntPropertyValue().
     * @internal
     * @param c code point
     * @param modeValue numeric value compatible with Mode
     * @return numeric value compatible with QuickCheck
     */
    public static final int quickCheck(int c, int modeValue) {
<span class="nc" id="L2133">        final int qcMask[/*UNORM_MODE_COUNT*/]={</span>
            0, 0, QC_NFD, QC_NFKD, QC_NFC, QC_NFKC
        };

<span class="nc" id="L2137">        int norm32=(int)getNorm32(c)&amp;qcMask[modeValue];</span>

<span class="nc bnc" id="L2139" title="All 2 branches missed.">        if(norm32==0) {</span>
<span class="nc" id="L2140">            return 1; // YES</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">        } else if((norm32&amp;QC_ANY_NO)!=0) {</span>
<span class="nc" id="L2142">            return 0; // NO</span>
        } else /* _NORM_QC_ANY_MAYBE */ {
<span class="nc" id="L2144">            return 2; // MAYBE;</span>
        }
    }

    private static int strCompare(char[] s1, int s1Start, int s1Limit,
                                  char[] s2, int s2Start, int s2Limit,
                                  boolean codePointOrder) {

        int start1, start2, limit1, limit2;

        char c1, c2;

        /* setup for fix-up */
<span class="nc" id="L2157">        start1=s1Start;</span>
<span class="nc" id="L2158">        start2=s2Start;</span>

        int length1, length2;

<span class="nc" id="L2162">        length1 = s1Limit - s1Start;</span>
<span class="nc" id="L2163">        length2 = s2Limit - s2Start;</span>

        int lengthResult;

<span class="nc bnc" id="L2167" title="All 2 branches missed.">        if(length1&lt;length2) {</span>
<span class="nc" id="L2168">            lengthResult=-1;</span>
<span class="nc" id="L2169">            limit1=start1+length1;</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">        } else if(length1==length2) {</span>
<span class="nc" id="L2171">            lengthResult=0;</span>
<span class="nc" id="L2172">            limit1=start1+length1;</span>
        } else /* length1&gt;length2 */ {
<span class="nc" id="L2174">            lengthResult=1;</span>
<span class="nc" id="L2175">            limit1=start1+length2;</span>
        }

<span class="nc bnc" id="L2178" title="All 2 branches missed.">        if(s1==s2) {</span>
<span class="nc" id="L2179">            return lengthResult;</span>
        }

        for(;;) {
            /* check pseudo-limit */
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            if(s1Start==limit1) {</span>
<span class="nc" id="L2185">                return lengthResult;</span>
            }

<span class="nc" id="L2188">            c1=s1[s1Start];</span>
<span class="nc" id="L2189">            c2=s2[s2Start];</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">            if(c1!=c2) {</span>
<span class="nc" id="L2191">                break;</span>
            }
<span class="nc" id="L2193">            ++s1Start;</span>
<span class="nc" id="L2194">            ++s2Start;</span>
        }

        /* setup for fix-up */
<span class="nc" id="L2198">        limit1=start1+length1;</span>
<span class="nc" id="L2199">        limit2=start2+length2;</span>


        /* if both values are in or above the surrogate range, fix them up */
<span class="nc bnc" id="L2203" title="All 6 branches missed.">        if(c1&gt;=0xd800 &amp;&amp; c2&gt;=0xd800 &amp;&amp; codePointOrder) {</span>
            /* subtract 0x2800 from BMP code points to make them smaller than
             *  supplementary ones */
<span class="nc bnc" id="L2206" title="All 4 branches missed.">            if(</span>
                ( c1&lt;=0xdbff &amp;&amp; (s1Start+1)!=limit1 &amp;&amp;
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                  UTF16.isTrailSurrogate(s1[(s1Start+1)])</span>
                ) ||
<span class="nc bnc" id="L2210" title="All 4 branches missed.">                ( UTF16.isTrailSurrogate(c1) &amp;&amp; start1!=s1Start &amp;&amp;</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                  UTF16.isLeadSurrogate(s1[(s1Start-1)])</span>
                )
            ) {
                /* part of a surrogate pair, leave &gt;=d800 */
            } else {
                /* BMP code point - may be surrogate code point - make &lt;d800 */
<span class="nc" id="L2217">                c1-=0x2800;</span>
            }

<span class="nc bnc" id="L2220" title="All 4 branches missed.">            if(</span>
                ( c2&lt;=0xdbff &amp;&amp; (s2Start+1)!=limit2 &amp;&amp;
<span class="nc bnc" id="L2222" title="All 2 branches missed.">                  UTF16.isTrailSurrogate(s2[(s2Start+1)])</span>
                ) ||
<span class="nc bnc" id="L2224" title="All 4 branches missed.">                ( UTF16.isTrailSurrogate(c2) &amp;&amp; start2!=s2Start &amp;&amp;</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">                  UTF16.isLeadSurrogate(s2[(s2Start-1)])</span>
                )
            ) {
                /* part of a surrogate pair, leave &gt;=d800 */
            } else {
                /* BMP code point - may be surrogate code point - make &lt;d800 */
<span class="nc" id="L2231">                c2-=0x2800;</span>
            }
        }

        /* now c1 and c2 are in UTF-32-compatible order */
<span class="nc" id="L2236">        return (int)c1-(int)c2;</span>
    }


    /*
     * Status of tailored normalization
     *
     * This was done initially for investigation on Unicode public review issue 7
     * (http://www.unicode.org/review/). See Jitterbug 2481.
     * While the UTC at meeting #94 (2003mar) did not take up the issue, this is
     * a permanent feature in ICU 2.6 in support of IDNA which requires true
     * Unicode 3.2 normalization.
     * (NormalizationCorrections are rolled into IDNA mapping tables.)
     *
     * Tailored normalization as implemented here allows to &quot;normalize less&quot;
     * than full Unicode normalization would.
     * Based internally on a UnicodeSet of code points that are
     * &quot;excluded from normalization&quot;, the normalization functions leave those
     * code points alone (&quot;inert&quot;). This means that tailored normalization
     * still transforms text into a canonically equivalent form.
     * It does not add decompositions to code points that do not have any or
     * change decomposition results.
     *
     * Any function that searches for a safe boundary has not been touched,
     * which means that these functions will be over-pessimistic when
     * exclusions are applied.
     * This should not matter because subsequent checks and normalizations
     * do apply the exclusions; only a little more of the text may be processed
     * than necessary under exclusions.
     *
     * Normalization exclusions have the following effect on excluded code points c:
     * - c is not decomposed
     * - c is not a composition target
     * - c does not combine forward or backward for composition
     *   except that this is not implemented for Jamo
     * - c is treated as having a combining class of 0
     */

    /*
     * Constants for the bit fields in the options bit set parameter.
     * These need not be public.
     * A user only needs to know the currently assigned values.
     * The number and positions of reserved bits per field can remain private.
     */
    private static final int OPTIONS_NX_MASK=0x1f;
    private static final int OPTIONS_UNICODE_MASK=0xe0;
    public  static final int OPTIONS_SETS_MASK=0xff;
//  private static final int OPTIONS_UNICODE_SHIFT=5;
<span class="nc" id="L2284">    private static final UnicodeSet[] nxCache = new UnicodeSet[OPTIONS_SETS_MASK+1];</span>

    /* Constants for options flags for normalization.*/

    /**
     * Options bit 0, do not decompose Hangul syllables.
     * @draft ICU 2.6
     */
    private static final int NX_HANGUL = 1;
    /**
     * Options bit 1, do not decompose CJK compatibility characters.
     * @draft ICU 2.6
     */
    private static final int NX_CJK_COMPAT=2;
    /**
     * Options bit 8, use buggy recomposition described in
     * Unicode Public Review Issue #29
     * at http://www.unicode.org/review/resolved-pri.html#pri29
     *
     * Used in IDNA implementation according to strict interpretation
     * of IDNA definition based on Unicode 3.2 which predates PRI #29.
     *
     * See ICU4C unormimp.h
     *
     * @draft ICU 3.2
     */
    public static final int BEFORE_PRI_29=0x100;

    /*
     * The following options are used only in some composition functions.
     * They use bits 12 and up to preserve lower bits for the available options
     * space in unorm_compare() -
     * see documentation for UNORM_COMPARE_NORM_OPTIONS_SHIFT.
     */

    /** Options bit 12, for compatibility vs. canonical decomposition. */
    public static final int OPTIONS_COMPAT=0x1000;
    /** Options bit 13, no discontiguous composition (FCC vs. NFC). */
    public static final int OPTIONS_COMPOSE_CONTIGUOUS=0x2000;

    /* normalization exclusion sets --------------------------------------------- */

    /*
     * Normalization exclusion UnicodeSets are used for tailored normalization;
     * see the comment near the beginning of this file.
     *
     * By specifying one or several sets of code points,
     * those code points become inert for normalization.
     */
    private static final synchronized UnicodeSet internalGetNXHangul() {
        /* internal function, does not check for incoming U_FAILURE */

<span class="nc bnc" id="L2336" title="All 2 branches missed.">        if(nxCache[NX_HANGUL]==null) {</span>
<span class="nc" id="L2337">             nxCache[NX_HANGUL]=new UnicodeSet(0xac00, 0xd7a3);</span>
        }
<span class="nc" id="L2339">        return nxCache[NX_HANGUL];</span>
    }

    private static final synchronized UnicodeSet internalGetNXCJKCompat() {
        /* internal function, does not check for incoming U_FAILURE */

<span class="nc bnc" id="L2345" title="All 2 branches missed.">        if(nxCache[NX_CJK_COMPAT]==null) {</span>

            /* build a set from [CJK Ideographs]&amp;[has canonical decomposition] */
            UnicodeSet set, hasDecomp;

<span class="nc" id="L2350">            set=new UnicodeSet(&quot;[:Ideographic:]&quot;);</span>

            /* start with an empty set for [has canonical decomposition] */
<span class="nc" id="L2353">            hasDecomp=new UnicodeSet();</span>

            /* iterate over all ideographs and remember which canonically decompose */
<span class="nc" id="L2356">            UnicodeSetIterator it = new UnicodeSetIterator(set);</span>
            int start, end;
            long norm32;

<span class="nc bnc" id="L2360" title="All 4 branches missed.">            while(it.nextRange() &amp;&amp; (it.codepoint != UnicodeSetIterator.IS_STRING)) {</span>
<span class="nc" id="L2361">                start=it.codepoint;</span>
<span class="nc" id="L2362">                end=it.codepointEnd;</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">                while(start&lt;=end) {</span>
<span class="nc" id="L2364">                    norm32 = getNorm32(start);</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">                    if((norm32 &amp; QC_NFD)&gt;0) {</span>
<span class="nc" id="L2366">                        hasDecomp.add(start);</span>
                    }
<span class="nc" id="L2368">                    ++start;</span>
                }
            }

            /* hasDecomp now contains all ideographs that decompose canonically */
<span class="nc" id="L2373">             nxCache[NX_CJK_COMPAT]=hasDecomp;</span>

        }

<span class="nc" id="L2377">        return nxCache[NX_CJK_COMPAT];</span>
    }

    private static final synchronized UnicodeSet internalGetNXUnicode(int options) {
<span class="nc" id="L2381">        options &amp;= OPTIONS_UNICODE_MASK;</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">        if(options==0) {</span>
<span class="nc" id="L2383">            return null;</span>
        }

<span class="nc bnc" id="L2386" title="All 2 branches missed.">        if(nxCache[options]==null) {</span>
            /* build a set with all code points that were not designated by the specified Unicode version */
<span class="nc" id="L2388">            UnicodeSet set = new UnicodeSet();</span>

<span class="nc bnc" id="L2390" title="All 2 branches missed.">            switch(options) {</span>
            case NormalizerBase.UNICODE_3_2:
<span class="nc" id="L2392">                set.applyPattern(&quot;[:^Age=3.2:]&quot;);</span>
<span class="nc" id="L2393">                break;</span>
            default:
<span class="nc" id="L2395">                return null;</span>
            }

<span class="nc" id="L2398">            nxCache[options]=set;</span>
        }

<span class="nc" id="L2401">        return nxCache[options];</span>
    }

    /* Get a decomposition exclusion set. The data must be loaded. */
    private static final synchronized UnicodeSet internalGetNX(int options) {
<span class="nc" id="L2406">        options&amp;=OPTIONS_SETS_MASK;</span>

<span class="nc bnc" id="L2408" title="All 2 branches missed.">        if(nxCache[options]==null) {</span>
            /* return basic sets */
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            if(options==NX_HANGUL) {</span>
<span class="nc" id="L2411">                return internalGetNXHangul();</span>
            }
<span class="nc bnc" id="L2413" title="All 2 branches missed.">            if(options==NX_CJK_COMPAT) {</span>
<span class="nc" id="L2414">                return internalGetNXCJKCompat();</span>
            }
<span class="nc bnc" id="L2416" title="All 4 branches missed.">            if((options &amp; OPTIONS_UNICODE_MASK)!=0 &amp;&amp; (options &amp; OPTIONS_NX_MASK)==0) {</span>
<span class="nc" id="L2417">                return internalGetNXUnicode(options);</span>
            }

            /* build a set from multiple subsets */
            UnicodeSet set;
            UnicodeSet other;

<span class="nc" id="L2424">            set=new UnicodeSet();</span>


<span class="nc bnc" id="L2427" title="All 4 branches missed.">            if((options &amp; NX_HANGUL)!=0 &amp;&amp; null!=(other=internalGetNXHangul())) {</span>
<span class="nc" id="L2428">                set.addAll(other);</span>
            }
<span class="nc bnc" id="L2430" title="All 4 branches missed.">            if((options&amp;NX_CJK_COMPAT)!=0 &amp;&amp; null!=(other=internalGetNXCJKCompat())) {</span>
<span class="nc" id="L2431">                set.addAll(other);</span>
            }
<span class="nc bnc" id="L2433" title="All 4 branches missed.">            if((options&amp;OPTIONS_UNICODE_MASK)!=0 &amp;&amp; null!=(other=internalGetNXUnicode(options))) {</span>
<span class="nc" id="L2434">                set.addAll(other);</span>
            }

<span class="nc" id="L2437">               nxCache[options]=set;</span>
        }
<span class="nc" id="L2439">        return nxCache[options];</span>
    }

    public static final UnicodeSet getNX(int options) {
<span class="nc bnc" id="L2443" title="All 2 branches missed.">        if((options&amp;=OPTIONS_SETS_MASK)==0) {</span>
            /* incoming failure, or no decomposition exclusions requested */
<span class="nc" id="L2445">            return null;</span>
        } else {
<span class="nc" id="L2447">            return internalGetNX(options);</span>
        }
    }

    private static final boolean nx_contains(UnicodeSet nx, int c) {
<span class="nc bnc" id="L2452" title="All 4 branches missed.">        return nx!=null &amp;&amp; nx.contains(c);</span>
    }

    private static final boolean nx_contains(UnicodeSet nx, char c, char c2) {
<span class="nc bnc" id="L2456" title="All 6 branches missed.">        return nx!=null &amp;&amp; nx.contains(c2==0 ? c : UCharacterProperty.getRawSupplementary(c, c2));</span>
    }

/*****************************************************************************/

    /**
     * Get the canonical decomposition
     * sherman  for ComposedCharIter
     */

    public static int getDecompose(int chars[], String decomps[]) {
<span class="nc" id="L2467">        DecomposeArgs args = new DecomposeArgs();</span>
<span class="nc" id="L2468">        int length=0;</span>
<span class="nc" id="L2469">        long norm32 = 0;</span>
<span class="nc" id="L2470">        int ch = -1;</span>
<span class="nc" id="L2471">        int index = 0;</span>
<span class="nc" id="L2472">        int i = 0;</span>

<span class="nc bnc" id="L2474" title="All 2 branches missed.">        while (++ch &lt; 0x2fa1e) {   //no cannoical above 0x3ffff</span>
            //TBD !!!! the hack code heres save us about 50ms for startup
            //need a better solution/lookup
<span class="nc bnc" id="L2477" title="All 2 branches missed.">            if (ch == 0x30ff)</span>
<span class="nc" id="L2478">                ch = 0xf900;</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">            else if (ch == 0x10000)</span>
<span class="nc" id="L2480">                ch = 0x1d15e;</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">            else if (ch == 0x1d1c1)</span>
<span class="nc" id="L2482">                ch = 0x2f800;</span>

<span class="nc" id="L2484">            norm32 = NormalizerImpl.getNorm32(ch);</span>
<span class="nc bnc" id="L2485" title="All 4 branches missed.">            if((norm32 &amp; QC_NFD)!=0 &amp;&amp; i &lt; chars.length) {</span>
<span class="nc" id="L2486">                chars[i] = ch;</span>
<span class="nc" id="L2487">                index = decompose(norm32, args);</span>
<span class="nc" id="L2488">                decomps[i++] = new String(extraData,index, args.length);</span>
            }
        }
<span class="nc" id="L2491">        return i;</span>
    }

    //------------------------------------------------------
    // special method for Collation
    //------------------------------------------------------
    private static boolean needSingleQuotation(char c) {
<span class="nc bnc" id="L2498" title="All 20 branches missed.">        return (c &gt;= 0x0009 &amp;&amp; c &lt;= 0x000D) ||</span>
               (c &gt;= 0x0020 &amp;&amp; c &lt;= 0x002F) ||
               (c &gt;= 0x003A &amp;&amp; c &lt;= 0x0040) ||
               (c &gt;= 0x005B &amp;&amp; c &lt;= 0x0060) ||
               (c &gt;= 0x007B &amp;&amp; c &lt;= 0x007E);
    }

    public static String canonicalDecomposeWithSingleQuotation(String string) {
<span class="nc" id="L2506">        char[] src = string.toCharArray();</span>
<span class="nc" id="L2507">        int    srcIndex = 0;</span>
<span class="nc" id="L2508">        int    srcLimit = src.length;</span>
<span class="nc" id="L2509">        char[] dest = new char[src.length * 3];  //MAX_BUF_SIZE_DECOMPOSE = 3</span>
<span class="nc" id="L2510">        int    destIndex = 0;</span>
<span class="nc" id="L2511">        int    destLimit = dest.length;</span>

<span class="nc" id="L2513">        char[] buffer = new char[3];</span>
        int prevSrc;
        long norm32;
        int ccOrQCMask;
<span class="nc" id="L2517">        int qcMask = QC_NFD;</span>
        int reorderStartIndex, length;
        char c, c2;
<span class="nc" id="L2520">        char minNoMaybe = (char)indexes[INDEX_MIN_NFD_NO_MAYBE];</span>
        int cc, prevCC, trailCC;
        char[] p;
        int pStart;


        // initialize
<span class="nc" id="L2527">        ccOrQCMask = CC_MASK | qcMask;</span>
<span class="nc" id="L2528">        reorderStartIndex = 0;</span>
<span class="nc" id="L2529">        prevCC = 0;</span>
<span class="nc" id="L2530">        norm32 = 0;</span>
<span class="nc" id="L2531">        c = 0;</span>
<span class="nc" id="L2532">        pStart = 0;</span>

<span class="nc" id="L2534">        cc = trailCC = -1; // initialize to bogus value</span>
        for(;;) {
<span class="nc" id="L2536">            prevSrc=srcIndex;</span>
            //quick check (1)less than minNoMaybe (2)no decomp (3)hangual
<span class="nc bnc" id="L2538" title="All 4 branches missed.">            while (srcIndex != srcLimit &amp;&amp;</span>
                   (( c = src[srcIndex]) &lt; minNoMaybe ||
<span class="nc bnc" id="L2540" title="All 6 branches missed.">                    ((norm32 = getNorm32(c)) &amp; ccOrQCMask) == 0 ||</span>
                    ( c &gt;= '\uac00' &amp;&amp; c &lt;= '\ud7a3'))){

<span class="nc" id="L2543">                prevCC = 0;</span>
<span class="nc" id="L2544">                ++srcIndex;</span>
            }

            // copy these code units all at once
<span class="nc bnc" id="L2548" title="All 2 branches missed.">            if (srcIndex != prevSrc) {</span>
<span class="nc" id="L2549">                length = srcIndex - prevSrc;</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">                if ((destIndex + length) &lt;= destLimit) {</span>
<span class="nc" id="L2551">                    System.arraycopy(src,prevSrc,dest,destIndex,length);</span>
                }

<span class="nc" id="L2554">                destIndex += length;</span>
<span class="nc" id="L2555">                reorderStartIndex = destIndex;</span>
            }

            // end of source reached?
<span class="nc bnc" id="L2559" title="All 2 branches missed.">            if(srcIndex == srcLimit) {</span>
<span class="nc" id="L2560">                break;</span>
            }
            // c already contains *src and norm32 is set for it, increment src
<span class="nc" id="L2563">            ++srcIndex;</span>

<span class="nc bnc" id="L2565" title="All 2 branches missed.">            if(isNorm32Regular(norm32)) {</span>
<span class="nc" id="L2566">                c2 = 0;</span>
<span class="nc" id="L2567">                length = 1;</span>
            } else {
                // c is a lead surrogate, get the real norm32
<span class="nc bnc" id="L2570" title="All 2 branches missed.">                if(srcIndex != srcLimit &amp;&amp;</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">                    Character.isLowSurrogate(c2 = src[srcIndex])) {</span>
<span class="nc" id="L2572">                        ++srcIndex;</span>
<span class="nc" id="L2573">                        length = 2;</span>
<span class="nc" id="L2574">                        norm32 = getNorm32FromSurrogatePair(norm32, c2);</span>
                } else {
<span class="nc" id="L2576">                    c2 = 0;</span>
<span class="nc" id="L2577">                    length = 1;</span>
<span class="nc" id="L2578">                    norm32 = 0;</span>
                }
            }

            // get the decomposition and the lead and trail cc's
<span class="nc bnc" id="L2583" title="All 2 branches missed.">            if((norm32 &amp; qcMask) == 0) {</span>
                // c does not decompose
<span class="nc" id="L2585">                cc = trailCC = (int)((UNSIGNED_BYTE_MASK) &amp; (norm32 &gt;&gt; CC_SHIFT));</span>
<span class="nc" id="L2586">                p = null;</span>
<span class="nc" id="L2587">                pStart = -1;</span>
            } else {
<span class="nc" id="L2589">                DecomposeArgs arg = new DecomposeArgs();</span>
                // c decomposes, get everything from the variable-length
                // extra data
<span class="nc" id="L2592">                pStart = decompose(norm32, qcMask, arg);</span>
<span class="nc" id="L2593">                p = extraData;</span>
<span class="nc" id="L2594">                length = arg.length;</span>
<span class="nc" id="L2595">                cc = arg.cc;</span>
<span class="nc" id="L2596">                trailCC = arg.trailCC;</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">                if(length == 1) {</span>
                    // fastpath a single code unit from decomposition
<span class="nc" id="L2599">                    c = p[pStart];</span>
<span class="nc" id="L2600">                    c2 = 0;</span>
<span class="nc" id="L2601">                    p = null;</span>
<span class="nc" id="L2602">                    pStart = -1;</span>
                }
            }

<span class="nc bnc" id="L2606" title="All 2 branches missed.">            if((destIndex + length * 3) &gt;= destLimit) {  // 2 SingleQuotations</span>
                // buffer overflow
<span class="nc" id="L2608">                char[] tmpBuf = new char[destLimit * 2];</span>
<span class="nc" id="L2609">                System.arraycopy(dest, 0, tmpBuf, 0, destIndex);</span>
<span class="nc" id="L2610">                dest = tmpBuf;</span>
<span class="nc" id="L2611">                destLimit = dest.length;</span>
            }
            // append the decomposition to the destination buffer, assume length&gt;0
            {
<span class="nc" id="L2615">                int reorderSplit = destIndex;</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">                if(p == null) {</span>
                    // fastpath: single code point
<span class="nc bnc" id="L2618" title="All 2 branches missed.">                    if (needSingleQuotation(c)) {</span>
                        //if we need single quotation, no need to consider &quot;prevCC&quot;
                        //and it must NOT be a supplementary pair
<span class="nc" id="L2621">                        dest[destIndex++] = '\'';</span>
<span class="nc" id="L2622">                        dest[destIndex++] = c;</span>
<span class="nc" id="L2623">                        dest[destIndex++] = '\'';</span>
<span class="nc" id="L2624">                        trailCC = 0;</span>
<span class="nc bnc" id="L2625" title="All 4 branches missed.">                    } else if(cc != 0 &amp;&amp; cc &lt; prevCC) {</span>
                        // (c, c2) is out of order with respect to the preceding
                        //  text
<span class="nc" id="L2628">                        destIndex += length;</span>
<span class="nc" id="L2629">                        trailCC = insertOrdered(dest,reorderStartIndex,</span>
                                                reorderSplit, destIndex, c, c2, cc);
                    } else {
                        // just append (c, c2)
<span class="nc" id="L2633">                        dest[destIndex++] = c;</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">                        if(c2 != 0) {</span>
<span class="nc" id="L2635">                            dest[destIndex++] = c2;</span>
                        }
                    }
                } else {
                    // general: multiple code points (ordered by themselves)
                    // from decomposition
<span class="nc bnc" id="L2641" title="All 2 branches missed.">                    if (needSingleQuotation(p[pStart])) {</span>
<span class="nc" id="L2642">                        dest[destIndex++] = '\'';</span>
<span class="nc" id="L2643">                        dest[destIndex++] = p[pStart++];</span>
<span class="nc" id="L2644">                        dest[destIndex++] = '\'';</span>
<span class="nc" id="L2645">                        length--;</span>
                        do {
<span class="nc" id="L2647">                            dest[destIndex++] = p[pStart++];</span>
<span class="nc bnc" id="L2648" title="All 2 branches missed.">                        } while(--length &gt; 0);</span>
                    } else
<span class="nc bnc" id="L2650" title="All 4 branches missed.">                    if(cc != 0 &amp;&amp; cc &lt; prevCC) {</span>
<span class="nc" id="L2651">                        destIndex += length;</span>
<span class="nc" id="L2652">                        trailCC = mergeOrdered(dest,reorderStartIndex,</span>
                                               reorderSplit,p, pStart,pStart+length);
                    } else {
                        // just append the decomposition
                        do {
<span class="nc" id="L2657">                            dest[destIndex++] = p[pStart++];</span>
<span class="nc bnc" id="L2658" title="All 2 branches missed.">                        } while(--length &gt; 0);</span>
                    }
                }
            }
<span class="nc" id="L2662">            prevCC = trailCC;</span>
<span class="nc bnc" id="L2663" title="All 2 branches missed.">            if(prevCC == 0) {</span>
<span class="nc" id="L2664">                reorderStartIndex = destIndex;</span>
            }
        }
<span class="nc" id="L2667">        return new String(dest, 0, destIndex);</span>
    }

    //------------------------------------------------------
    // mapping method for IDNA/StringPrep
    //------------------------------------------------------

    /*
     * Normalization using NormalizerBase.UNICODE_3_2 option supports Unicode
     * 3.2 normalization with Corrigendum 4 corrections. However, normalization
     * without the corrections is necessary for IDNA/StringPrep support.
     * This method is called when NormalizerBase.UNICODE_3_2_0_ORIGINAL option
     * (= sun.text.Normalizer.UNICODE_3_2) is used and normalizes five
     * characters in Corrigendum 4 before normalization in order to avoid
     * incorrect normalization.
     * For the Corrigendum 4 issue, refer
     *   http://www.unicode.org/versions/corrigendum4.html
     */

    /*
     * Option used in NormalizerBase.UNICODE_3_2_0_ORIGINAL.
     */
    public static final int WITHOUT_CORRIGENDUM4_CORRECTIONS=0x40000;

<span class="nc" id="L2691">    private static final char[][] corrigendum4MappingTable = {</span>
        {'\uD844', '\uDF6A'},  // 0x2F868
        {'\u5F33'},            // 0x2F874
        {'\u43AB'},            // 0x2F91F
        {'\u7AAE'},            // 0x2F95F
        {'\u4D57'}};           // 0x2F9BF

    /*
     * Removing Corrigendum 4 fix
     * @return normalized text
     */
    public static String convert(String str) {
<span class="nc bnc" id="L2703" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L2704">            return null;</span>
        }

<span class="nc" id="L2707">        int ch  = UCharacterIterator.DONE;</span>
<span class="nc" id="L2708">        StringBuffer dest = new StringBuffer();</span>
<span class="nc" id="L2709">        UCharacterIterator iter = UCharacterIterator.getInstance(str);</span>

<span class="nc bnc" id="L2711" title="All 2 branches missed.">        while ((ch=iter.nextCodePoint())!= UCharacterIterator.DONE){</span>
<span class="nc bnc" id="L2712" title="All 6 branches missed.">            switch (ch) {</span>
            case 0x2F868:
<span class="nc" id="L2714">                dest.append(corrigendum4MappingTable[0]);</span>
<span class="nc" id="L2715">                break;</span>
            case 0x2F874:
<span class="nc" id="L2717">                dest.append(corrigendum4MappingTable[1]);</span>
<span class="nc" id="L2718">                break;</span>
            case 0x2F91F:
<span class="nc" id="L2720">                dest.append(corrigendum4MappingTable[2]);</span>
<span class="nc" id="L2721">                break;</span>
            case 0x2F95F:
<span class="nc" id="L2723">                dest.append(corrigendum4MappingTable[3]);</span>
<span class="nc" id="L2724">                break;</span>
            case 0x2F9BF:
<span class="nc" id="L2726">                dest.append(corrigendum4MappingTable[4]);</span>
<span class="nc" id="L2727">                break;</span>
            default:
<span class="nc" id="L2729">                UTF16.append(dest,ch);</span>
<span class="nc" id="L2730">                break;</span>
            }
        }

<span class="nc" id="L2734">        return dest.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>