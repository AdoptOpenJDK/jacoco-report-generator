<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NormalizerBase.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">NormalizerBase.java</span></div><h1>NormalizerBase.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

import java.text.CharacterIterator;
import java.text.Normalizer;

/**
 * Unicode Normalization
 *
 * &lt;h2&gt;Unicode normalization API&lt;/h2&gt;
 *
 * &lt;code&gt;normalize&lt;/code&gt; transforms Unicode text into an equivalent composed or
 * decomposed form, allowing for easier sorting and searching of text.
 * &lt;code&gt;normalize&lt;/code&gt; supports the standard normalization forms described in
 * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr15/&quot; target=&quot;unicode&quot;&gt;
 * Unicode Standard Annex #15 &amp;mdash; Unicode Normalization Forms&lt;/a&gt;.
 *
 * Characters with accents or other adornments can be encoded in
 * several different ways in Unicode.  For example, take the character A-acute.
 * In Unicode, this can be encoded as a single character (the
 * &quot;composed&quot; form):
 *
 * &lt;p&gt;
 *      00C1    LATIN CAPITAL LETTER A WITH ACUTE
 * &lt;/p&gt;
 *
 * or as two separate characters (the &quot;decomposed&quot; form):
 *
 * &lt;p&gt;
 *      0041    LATIN CAPITAL LETTER A
 *      0301    COMBINING ACUTE ACCENT
 * &lt;/p&gt;
 *
 * To a user of your program, however, both of these sequences should be
 * treated as the same &quot;user-level&quot; character &quot;A with acute accent&quot;.  When you
 * are searching or comparing text, you must ensure that these two sequences are
 * treated equivalently.  In addition, you must handle characters with more than
 * one accent.  Sometimes the order of a character's combining accents is
 * significant, while in other cases accent sequences in different orders are
 * really equivalent.
 *
 * Similarly, the string &quot;ffi&quot; can be encoded as three separate letters:
 *
 * &lt;p&gt;
 *      0066    LATIN SMALL LETTER F
 *      0066    LATIN SMALL LETTER F
 *      0069    LATIN SMALL LETTER I
 * &lt;/p&gt;
 *
 * or as the single character
 *
 * &lt;p&gt;
 *      FB03    LATIN SMALL LIGATURE FFI
 * &lt;/p&gt;
 *
 * The ffi ligature is not a distinct semantic character, and strictly speaking
 * it shouldn't be in Unicode at all, but it was included for compatibility
 * with existing character sets that already provided it.  The Unicode standard
 * identifies such characters by giving them &quot;compatibility&quot; decompositions
 * into the corresponding semantic characters.  When sorting and searching, you
 * will often want to use these mappings.
 *
 * &lt;code&gt;normalize&lt;/code&gt; helps solve these problems by transforming text into
 * the canonical composed and decomposed forms as shown in the first example
 * above. In addition, you can have it perform compatibility decompositions so
 * that you can treat compatibility characters the same as their equivalents.
 * Finally, &lt;code&gt;normalize&lt;/code&gt; rearranges accents into the proper canonical
 * order, so that you do not have to worry about accent rearrangement on your
 * own.
 *
 * Form FCD, &quot;Fast C or D&quot;, is also designed for collation.
 * It allows to work on strings that are not necessarily normalized
 * with an algorithm (like in collation) that works under &quot;canonical closure&quot;,
 * i.e., it treats precomposed characters and their decomposed equivalents the
 * same.
 *
 * It is not a normalization form because it does not provide for uniqueness of
 * representation. Multiple strings may be canonically equivalent (their NFDs
 * are identical) and may all conform to FCD without being identical themselves.
 *
 * The form is defined such that the &quot;raw decomposition&quot;, the recursive
 * canonical decomposition of each character, results in a string that is
 * canonically ordered. This means that precomposed characters are allowed for
 * as long as their decompositions do not need canonical reordering.
 *
 * Its advantage for a process like collation is that all NFD and most NFC texts
 * - and many unnormalized texts - already conform to FCD and do not need to be
 * normalized (NFD) for such a process. The FCD quick check will return YES for
 * most strings in practice.
 *
 * normalize(FCD) may be implemented with NFD.
 *
 * For more details on FCD see the collation design document:
 * http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm
 *
 * ICU collation performs either NFD or FCD normalization automatically if
 * normalization is turned on for the collator object. Beyond collation and
 * string search, normalized strings may be useful for string equivalence
 * comparisons, transliteration/transcription, unique representations, etc.
 *
 * The W3C generally recommends to exchange texts in NFC.
 * Note also that most legacy character encodings use only precomposed forms and
 * often do not encode any combining marks by themselves. For conversion to such
 * character encodings the Unicode text needs to be normalized to NFC.
 * For more usage examples, see the Unicode Standard Annex.
 * @stable ICU 2.8
 */

public final class NormalizerBase implements Cloneable {

    //-------------------------------------------------------------------------
    // Private data
    //-------------------------------------------------------------------------
<span class="nc" id="L149">    private char[] buffer = new char[100];</span>
<span class="nc" id="L150">    private int bufferStart = 0;</span>
<span class="nc" id="L151">    private int bufferPos   = 0;</span>
<span class="nc" id="L152">    private int bufferLimit = 0;</span>

    // The input text and our position in it
    private UCharacterIterator  text;
<span class="nc" id="L156">    private Mode                mode = NFC;</span>
<span class="nc" id="L157">    private int                 options = 0;</span>
    private int                 currentIndex;
    private int                 nextIndex;

    /**
     * Options bit set value to select Unicode 3.2 normalization
     * (except NormalizationCorrections).
     * At most one Unicode version can be selected at a time.
     * @stable ICU 2.6
     */
    public static final int UNICODE_3_2=0x20;

    /**
     * Constant indicating that the end of the iteration has been reached.
     * This is guaranteed to have the same value as {@link UCharacterIterator#DONE}.
     * @stable ICU 2.8
     */
    public static final int DONE = UCharacterIterator.DONE;

    /**
     * Constants for normalization modes.
     * @stable ICU 2.8
     */
    public static class Mode {
        private int modeValue;
<span class="fc" id="L182">        private Mode(int value) {</span>
<span class="fc" id="L183">            modeValue = value;</span>
<span class="fc" id="L184">        }</span>

        /**
         * This method is used for method dispatch
         * @stable ICU 2.6
         */
        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                UnicodeSet nx) {
<span class="nc" id="L193">            int srcLen = (srcLimit - srcStart);</span>
<span class="nc" id="L194">            int destLen = (destLimit - destStart);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if( srcLen &gt; destLen ) {</span>
<span class="nc" id="L196">                return srcLen;</span>
            }
<span class="nc" id="L198">            System.arraycopy(src,srcStart,dest,destStart,srcLen);</span>
<span class="nc" id="L199">            return srcLen;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.6
         */
        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                int options) {
<span class="nc" id="L209">            return normalize(   src, srcStart, srcLimit,</span>
                                dest,destStart,destLimit,
<span class="nc" id="L211">                                NormalizerImpl.getNX(options)</span>
                                );
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.6
         */
        protected String normalize(String src, int options) {
<span class="nc" id="L220">            return src;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.8
         */
        protected int getMinC() {
<span class="nc" id="L228">            return -1;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.8
         */
        protected int getMask() {
<span class="nc" id="L236">            return -1;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.8
         */
        protected IsPrevBoundary getPrevBoundary() {
<span class="nc" id="L244">            return null;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.8
         */
        protected IsNextBoundary getNextBoundary() {
<span class="nc" id="L252">            return null;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.6
         */
        protected QuickCheckResult quickCheck(char[] src,int start, int limit,
                                              boolean allowMaybe,UnicodeSet nx) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if(allowMaybe) {</span>
<span class="nc" id="L262">                return MAYBE;</span>
            }
<span class="nc" id="L264">            return NO;</span>
        }

        /**
         * This method is used for method dispatch
         * @stable ICU 2.8
         */
        protected boolean isNFSkippable(int c) {
<span class="nc" id="L272">            return true;</span>
        }
    }

    /**
     * No decomposition/composition.
     * @stable ICU 2.8
     */
<span class="fc" id="L280">    public static final Mode NONE = new Mode(1);</span>

    /**
     * Canonical decomposition.
     * @stable ICU 2.8
     */
<span class="fc" id="L286">    public static final Mode NFD = new NFDMode(2);</span>

    private static final class NFDMode extends Mode {
        private NFDMode(int value) {
<span class="fc" id="L290">            super(value);</span>
<span class="fc" id="L291">        }</span>

        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                UnicodeSet nx) {
<span class="nc" id="L296">            int[] trailCC = new int[1];</span>
<span class="nc" id="L297">            return NormalizerImpl.decompose(src,  srcStart,srcLimit,</span>
                                            dest, destStart,destLimit,
                                            false, trailCC,nx);
        }

        protected String normalize( String src, int options) {
<span class="nc" id="L303">            return decompose(src,false,options);</span>
        }

        protected int getMinC() {
<span class="nc" id="L307">            return NormalizerImpl.MIN_WITH_LEAD_CC;</span>
        }

        protected IsPrevBoundary getPrevBoundary() {
<span class="nc" id="L311">            return new IsPrevNFDSafe();</span>
        }

        protected IsNextBoundary getNextBoundary() {
<span class="nc" id="L315">            return new IsNextNFDSafe();</span>
        }

        protected int getMask() {
<span class="nc" id="L319">            return (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFD);</span>
        }

        protected QuickCheckResult quickCheck(char[] src,int start,
                                              int limit,boolean allowMaybe,
                                              UnicodeSet nx) {
<span class="nc" id="L325">            return NormalizerImpl.quickCheck(</span>
                                             src, start,limit,
<span class="nc" id="L327">                                             NormalizerImpl.getFromIndexesArr(</span>
                                                                              NormalizerImpl.INDEX_MIN_NFD_NO_MAYBE
                                                                              ),
                                             NormalizerImpl.QC_NFD,
                                             0,
                                             allowMaybe,
                                             nx
                                             );
        }

        protected boolean isNFSkippable(int c) {
<span class="nc" id="L338">            return NormalizerImpl.isNFSkippable(c,this,</span>
                                                (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFD)
                                                );
        }
    }

    /**
     * Compatibility decomposition.
     * @stable ICU 2.8
     */
<span class="fc" id="L348">    public static final Mode NFKD = new NFKDMode(3);</span>

    private static final class NFKDMode extends Mode {
        private NFKDMode(int value) {
<span class="fc" id="L352">            super(value);</span>
<span class="fc" id="L353">        }</span>

        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                UnicodeSet nx) {
<span class="nc" id="L358">            int[] trailCC = new int[1];</span>
<span class="nc" id="L359">            return NormalizerImpl.decompose(src,  srcStart,srcLimit,</span>
                                            dest, destStart,destLimit,
                                            true, trailCC, nx);
        }

        protected String normalize( String src, int options) {
<span class="nc" id="L365">            return decompose(src,true,options);</span>
        }

        protected int getMinC() {
<span class="nc" id="L369">            return NormalizerImpl.MIN_WITH_LEAD_CC;</span>
        }

        protected IsPrevBoundary getPrevBoundary() {
<span class="nc" id="L373">            return new IsPrevNFDSafe();</span>
        }

        protected IsNextBoundary getNextBoundary() {
<span class="nc" id="L377">            return new IsNextNFDSafe();</span>
        }

        protected int getMask() {
<span class="nc" id="L381">            return (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFKD);</span>
        }

        protected QuickCheckResult quickCheck(char[] src,int start,
                                              int limit,boolean allowMaybe,
                                              UnicodeSet nx) {
<span class="nc" id="L387">            return NormalizerImpl.quickCheck(</span>
                                             src,start,limit,
<span class="nc" id="L389">                                             NormalizerImpl.getFromIndexesArr(</span>
                                                                              NormalizerImpl.INDEX_MIN_NFKD_NO_MAYBE
                                                                              ),
                                             NormalizerImpl.QC_NFKD,
                                             NormalizerImpl.OPTIONS_COMPAT,
                                             allowMaybe,
                                             nx
                                             );
        }

        protected boolean isNFSkippable(int c) {
<span class="nc" id="L400">            return NormalizerImpl.isNFSkippable(c, this,</span>
                                                (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFKD)
                                                );
        }
    }

    /**
     * Canonical decomposition followed by canonical composition.
     * @stable ICU 2.8
     */
<span class="fc" id="L410">    public static final Mode NFC = new NFCMode(4);</span>

    private static final class NFCMode extends Mode{
        private NFCMode(int value) {
<span class="fc" id="L414">            super(value);</span>
<span class="fc" id="L415">        }</span>
        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                UnicodeSet nx) {
<span class="nc" id="L419">            return NormalizerImpl.compose( src, srcStart, srcLimit,</span>
                                           dest,destStart,destLimit,
                                           0, nx);
        }

        protected String normalize( String src, int options) {
<span class="nc" id="L425">            return compose(src, false, options);</span>
        }

        protected int getMinC() {
<span class="nc" id="L429">            return NormalizerImpl.getFromIndexesArr(</span>
                                                    NormalizerImpl.INDEX_MIN_NFC_NO_MAYBE
                                                    );
        }
        protected IsPrevBoundary getPrevBoundary() {
<span class="nc" id="L434">            return new IsPrevTrueStarter();</span>
        }
        protected IsNextBoundary getNextBoundary() {
<span class="nc" id="L437">            return new IsNextTrueStarter();</span>
        }
        protected int getMask() {
<span class="nc" id="L440">            return (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFC);</span>
        }
        protected QuickCheckResult quickCheck(char[] src,int start,
                                              int limit,boolean allowMaybe,
                                              UnicodeSet nx) {
<span class="nc" id="L445">            return NormalizerImpl.quickCheck(</span>
                                             src,start,limit,
<span class="nc" id="L447">                                             NormalizerImpl.getFromIndexesArr(</span>
                                                                              NormalizerImpl.INDEX_MIN_NFC_NO_MAYBE
                                                                              ),
                                             NormalizerImpl.QC_NFC,
                                             0,
                                             allowMaybe,
                                             nx
                                             );
        }
        protected boolean isNFSkippable(int c) {
<span class="nc" id="L457">            return NormalizerImpl.isNFSkippable(c,this,</span>
                                                ( NormalizerImpl.CC_MASK|NormalizerImpl.COMBINES_ANY|
                                                  (NormalizerImpl.QC_NFC &amp; NormalizerImpl.QC_ANY_NO)
                                                  )
                                                );
        }
    };

    /**
     * Compatibility decomposition followed by canonical composition.
     * @stable ICU 2.8
     */
<span class="fc" id="L469">    public static final Mode NFKC =new NFKCMode(5);</span>

    private static final class NFKCMode extends Mode{
        private NFKCMode(int value) {
<span class="fc" id="L473">            super(value);</span>
<span class="fc" id="L474">        }</span>
        protected int normalize(char[] src, int srcStart, int srcLimit,
                                char[] dest,int destStart,int destLimit,
                                UnicodeSet nx) {
<span class="nc" id="L478">            return NormalizerImpl.compose(src,  srcStart,srcLimit,</span>
                                          dest, destStart,destLimit,
                                          NormalizerImpl.OPTIONS_COMPAT, nx);
        }

        protected String normalize( String src, int options) {
<span class="nc" id="L484">            return compose(src, true, options);</span>
        }
        protected int getMinC() {
<span class="nc" id="L487">            return NormalizerImpl.getFromIndexesArr(</span>
                                                    NormalizerImpl.INDEX_MIN_NFKC_NO_MAYBE
                                                    );
        }
        protected IsPrevBoundary getPrevBoundary() {
<span class="nc" id="L492">            return new IsPrevTrueStarter();</span>
        }
        protected IsNextBoundary getNextBoundary() {
<span class="nc" id="L495">            return new IsNextTrueStarter();</span>
        }
        protected int getMask() {
<span class="nc" id="L498">            return (NormalizerImpl.CC_MASK|NormalizerImpl.QC_NFKC);</span>
        }
        protected QuickCheckResult quickCheck(char[] src,int start,
                                              int limit,boolean allowMaybe,
                                              UnicodeSet nx) {
<span class="nc" id="L503">            return NormalizerImpl.quickCheck(</span>
                                             src,start,limit,
<span class="nc" id="L505">                                             NormalizerImpl.getFromIndexesArr(</span>
                                                                              NormalizerImpl.INDEX_MIN_NFKC_NO_MAYBE
                                                                              ),
                                             NormalizerImpl.QC_NFKC,
                                             NormalizerImpl.OPTIONS_COMPAT,
                                             allowMaybe,
                                             nx
                                             );
        }
        protected boolean isNFSkippable(int c) {
<span class="nc" id="L515">            return NormalizerImpl.isNFSkippable(c, this,</span>
                                                ( NormalizerImpl.CC_MASK|NormalizerImpl.COMBINES_ANY|
                                                  (NormalizerImpl.QC_NFKC &amp; NormalizerImpl.QC_ANY_NO)
                                                  )
                                                );
        }
    };

    /**
     * Result values for quickCheck().
     * For details see Unicode Technical Report 15.
     * @stable ICU 2.8
     */
    public static final class QuickCheckResult{
        private int resultValue;
<span class="fc" id="L530">        private QuickCheckResult(int value) {</span>
<span class="fc" id="L531">            resultValue=value;</span>
<span class="fc" id="L532">        }</span>
    }
    /**
     * Indicates that string is not in the normalized format
     * @stable ICU 2.8
     */
<span class="fc" id="L538">    public static final QuickCheckResult NO = new QuickCheckResult(0);</span>

    /**
     * Indicates that string is in the normalized format
     * @stable ICU 2.8
     */
<span class="fc" id="L544">    public static final QuickCheckResult YES = new QuickCheckResult(1);</span>

    /**
     * Indicates it cannot be determined if string is in the normalized
     * format without further thorough checks.
     * @stable ICU 2.8
     */
<span class="fc" id="L551">    public static final QuickCheckResult MAYBE = new QuickCheckResult(2);</span>

    //-------------------------------------------------------------------------
    // Constructors
    //-------------------------------------------------------------------------

    /**
     * Creates a new &lt;tt&gt;Normalizer&lt;/tt&gt; object for iterating over the
     * normalized form of a given string.
     * &lt;p&gt;
     * The &lt;tt&gt;options&lt;/tt&gt; parameter specifies which optional
     * &lt;tt&gt;Normalizer&lt;/tt&gt; features are to be enabled for this object.
     * &lt;p&gt;
     * @param str  The string to be normalized.  The normalization
     *              will start at the beginning of the string.
     *
     * @param mode The normalization mode.
     *
     * @param opt Any optional features to be enabled.
     *            Currently the only available option is {@link #UNICODE_3_2}.
     *            If you want the default behavior corresponding to one of the
     *            standard Unicode Normalization Forms, use 0 for this argument.
     * @stable ICU 2.6
     */
<span class="nc" id="L575">    public NormalizerBase(String str, Mode mode, int opt) {</span>
<span class="nc" id="L576">        this.text = UCharacterIterator.getInstance(str);</span>
<span class="nc" id="L577">        this.mode = mode;</span>
<span class="nc" id="L578">        this.options=opt;</span>
<span class="nc" id="L579">    }</span>

    /**
     * Creates a new &lt;tt&gt;Normalizer&lt;/tt&gt; object for iterating over the
     * normalized form of the given text.
     * &lt;p&gt;
     * @param iter  The input text to be normalized.  The normalization
     *              will start at the beginning of the string.
     *
     * @param mode  The normalization mode.
     */
    public NormalizerBase(CharacterIterator iter, Mode mode) {
<span class="nc" id="L591">          this(iter, mode, UNICODE_LATEST);</span>
<span class="nc" id="L592">    }</span>

    /**
     * Creates a new &lt;tt&gt;Normalizer&lt;/tt&gt; object for iterating over the
     * normalized form of the given text.
     * &lt;p&gt;
     * @param iter  The input text to be normalized.  The normalization
     *              will start at the beginning of the string.
     *
     * @param mode  The normalization mode.
     *
     * @param opt Any optional features to be enabled.
     *            Currently the only available option is {@link #UNICODE_3_2}.
     *            If you want the default behavior corresponding to one of the
     *            standard Unicode Normalization Forms, use 0 for this argument.
     * @stable ICU 2.6
     */
<span class="nc" id="L609">    public NormalizerBase(CharacterIterator iter, Mode mode, int opt) {</span>
<span class="nc" id="L610">        this.text = UCharacterIterator.getInstance(</span>
<span class="nc" id="L611">                                                   (CharacterIterator)iter.clone()</span>
                                                   );
<span class="nc" id="L613">        this.mode = mode;</span>
<span class="nc" id="L614">        this.options = opt;</span>
<span class="nc" id="L615">    }</span>

    /**
     * Clones this &lt;tt&gt;Normalizer&lt;/tt&gt; object.  All properties of this
     * object are duplicated in the new object, including the cloning of any
     * {@link CharacterIterator} that was passed in to the constructor
     * or to {@link #setText(CharacterIterator) setText}.
     * However, the text storage underlying
     * the &lt;tt&gt;CharacterIterator&lt;/tt&gt; is not duplicated unless the
     * iterator's &lt;tt&gt;clone&lt;/tt&gt; method does so.
     * @stable ICU 2.8
     */
    public Object clone() {
        try {
<span class="nc" id="L629">            NormalizerBase copy = (NormalizerBase) super.clone();</span>
<span class="nc" id="L630">            copy.text = (UCharacterIterator) text.clone();</span>
            //clone the internal buffer
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (buffer != null) {</span>
<span class="nc" id="L633">                copy.buffer = new char[buffer.length];</span>
<span class="nc" id="L634">                System.arraycopy(buffer,0,copy.buffer,0,buffer.length);</span>
            }
<span class="nc" id="L636">            return copy;</span>
        }
<span class="nc" id="L638">        catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L639">            throw new InternalError(e.toString(), e);</span>
        }
    }

    //--------------------------------------------------------------------------
    // Static Utility methods
    //--------------------------------------------------------------------------

    /**
     * Compose a string.
     * The string will be composed to according the the specified mode.
     * @param str        The string to compose.
     * @param compat     If true the string will be composed accoding to
     *                    NFKC rules and if false will be composed according to
     *                    NFC rules.
     * @param options    The only recognized option is UNICODE_3_2
     * @return String    The composed string
     * @stable ICU 2.6
     */
    public static String compose(String str, boolean compat, int options) {

        char[] dest, src;
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        if (options == UNICODE_3_2_0_ORIGINAL) {</span>
<span class="nc" id="L662">            String mappedStr = NormalizerImpl.convert(str);</span>
<span class="nc" id="L663">            dest = new char[mappedStr.length()*MAX_BUF_SIZE_COMPOSE];</span>
<span class="nc" id="L664">            src = mappedStr.toCharArray();</span>
<span class="nc" id="L665">        } else {</span>
<span class="fc" id="L666">            dest = new char[str.length()*MAX_BUF_SIZE_COMPOSE];</span>
<span class="fc" id="L667">            src = str.toCharArray();</span>
        }
<span class="nc" id="L669">        int destSize=0;</span>

<span class="nc" id="L671">        UnicodeSet nx = NormalizerImpl.getNX(options);</span>

        /* reset options bits that should only be set here or inside compose() */
<span class="nc" id="L674">        options&amp;=~(NormalizerImpl.OPTIONS_SETS_MASK|NormalizerImpl.OPTIONS_COMPAT|NormalizerImpl.OPTIONS_COMPOSE_CONTIGUOUS);</span>

<span class="nc bnc" id="L676" title="All 2 branches missed.">        if(compat) {</span>
<span class="nc" id="L677">            options|=NormalizerImpl.OPTIONS_COMPAT;</span>
        }

        for(;;) {
<span class="nc" id="L681">            destSize=NormalizerImpl.compose(src,0,src.length,</span>
                                            dest,0,dest.length,options,
                                            nx);
<span class="nc bnc" id="L684" title="All 2 branches missed.">            if(destSize&lt;=dest.length) {</span>
<span class="nc" id="L685">                return new String(dest,0,destSize);</span>
            } else {
<span class="nc" id="L687">                dest = new char[destSize];</span>
            }
        }
    }

    private static final int MAX_BUF_SIZE_COMPOSE = 2;
    private static final int MAX_BUF_SIZE_DECOMPOSE = 3;

    /**
     * Decompose a string.
     * The string will be decomposed to according the the specified mode.
     * @param str       The string to decompose.
     * @param compat    If true the string will be decomposed accoding to NFKD
     *                   rules and if false will be decomposed according to NFD
     *                   rules.
     * @return String   The decomposed string
     * @stable ICU 2.8
     */
    public static String decompose(String str, boolean compat) {
<span class="nc" id="L706">        return decompose(str,compat,UNICODE_LATEST);</span>
    }

    /**
     * Decompose a string.
     * The string will be decomposed to according the the specified mode.
     * @param str     The string to decompose.
     * @param compat  If true the string will be decomposed accoding to NFKD
     *                 rules and if false will be decomposed according to NFD
     *                 rules.
     * @param options The normalization options, ORed together (0 for no options).
     * @return String The decomposed string
     * @stable ICU 2.6
     */
    public static String decompose(String str, boolean compat, int options) {

<span class="nc" id="L722">        int[] trailCC = new int[1];</span>
<span class="nc" id="L723">        int destSize=0;</span>
<span class="nc" id="L724">        UnicodeSet nx = NormalizerImpl.getNX(options);</span>
        char[] dest;

<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (options == UNICODE_3_2_0_ORIGINAL) {</span>
<span class="nc" id="L728">            String mappedStr = NormalizerImpl.convert(str);</span>
<span class="nc" id="L729">            dest = new char[mappedStr.length()*MAX_BUF_SIZE_DECOMPOSE];</span>

            for(;;) {
<span class="nc" id="L732">                destSize=NormalizerImpl.decompose(mappedStr.toCharArray(),0,mappedStr.length(),</span>
                                                  dest,0,dest.length,
                                                  compat,trailCC, nx);
<span class="nc bnc" id="L735" title="All 2 branches missed.">                if(destSize&lt;=dest.length) {</span>
<span class="nc" id="L736">                    return new String(dest,0,destSize);</span>
                } else {
<span class="nc" id="L738">                    dest = new char[destSize];</span>
                }
            }
        } else {
<span class="nc" id="L742">            dest = new char[str.length()*MAX_BUF_SIZE_DECOMPOSE];</span>

            for(;;) {
<span class="nc" id="L745">                destSize=NormalizerImpl.decompose(str.toCharArray(),0,str.length(),</span>
                                                  dest,0,dest.length,
                                                  compat,trailCC, nx);
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if(destSize&lt;=dest.length) {</span>
<span class="nc" id="L749">                    return new String(dest,0,destSize);</span>
                } else {
<span class="nc" id="L751">                    dest = new char[destSize];</span>
                }
            }
        }
    }

    /**
     * Normalize a string.
     * The string will be normalized according the the specified normalization
     * mode and options.
     * @param src       The char array to compose.
     * @param srcStart  Start index of the source
     * @param srcLimit  Limit index of the source
     * @param dest      The char buffer to fill in
     * @param destStart Start index of the destination buffer
     * @param destLimit End index of the destination buffer
     * @param mode      The normalization mode; one of Normalizer.NONE,
     *                   Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
     *                   Normalizer.NFKD, Normalizer.DEFAULT
     * @param options The normalization options, ORed together (0 for no options).
     * @return int      The total buffer size needed;if greater than length of
     *                   result, the output was truncated.
     * @exception       IndexOutOfBoundsException if the target capacity is
     *                   less than the required length
     * @stable ICU 2.6
     */
    public static int normalize(char[] src,int srcStart, int srcLimit,
                                char[] dest,int destStart, int destLimit,
                                Mode  mode, int options) {
<span class="nc" id="L780">        int length = mode.normalize(src,srcStart,srcLimit,dest,destStart,destLimit, options);</span>

<span class="nc bnc" id="L782" title="All 2 branches missed.">        if(length&lt;=(destLimit-destStart)) {</span>
<span class="nc" id="L783">            return length;</span>
        } else {
<span class="nc" id="L785">            throw new IndexOutOfBoundsException(Integer.toString(length));</span>
        }
    }

    //-------------------------------------------------------------------------
    // Iteration API
    //-------------------------------------------------------------------------

    /**
     * Return the current character in the normalized text-&gt;
     * @return The codepoint as an int
     * @stable ICU 2.8
     */
    public int current() {
<span class="nc bnc" id="L799" title="All 4 branches missed.">        if(bufferPos&lt;bufferLimit || nextNormalize()) {</span>
<span class="nc" id="L800">            return getCodePointAt(bufferPos);</span>
        } else {
<span class="nc" id="L802">            return DONE;</span>
        }
    }

    /**
     * Return the next character in the normalized text and advance
     * the iteration position by one.  If the end
     * of the text has already been reached, {@link #DONE} is returned.
     * @return The codepoint as an int
     * @stable ICU 2.8
     */
    public int next() {
<span class="nc bnc" id="L814" title="All 4 branches missed.">        if(bufferPos&lt;bufferLimit ||  nextNormalize()) {</span>
<span class="nc" id="L815">            int c=getCodePointAt(bufferPos);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            bufferPos+=(c&gt;0xFFFF) ? 2 : 1;</span>
<span class="nc" id="L817">            return c;</span>
        } else {
<span class="nc" id="L819">            return DONE;</span>
        }
    }


    /**
     * Return the previous character in the normalized text and decrement
     * the iteration position by one.  If the beginning
     * of the text has already been reached, {@link #DONE} is returned.
     * @return The codepoint as an int
     * @stable ICU 2.8
     */
    public int previous() {
<span class="nc bnc" id="L832" title="All 4 branches missed.">        if(bufferPos&gt;0 || previousNormalize()) {</span>
<span class="nc" id="L833">            int c=getCodePointAt(bufferPos-1);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            bufferPos-=(c&gt;0xFFFF) ? 2 : 1;</span>
<span class="nc" id="L835">            return c;</span>
        } else {
<span class="nc" id="L837">            return DONE;</span>
        }
    }

    /**
     * Reset the index to the beginning of the text.
     * This is equivalent to setIndexOnly(startIndex)).
     * @stable ICU 2.8
     */
    public void reset() {
<span class="nc" id="L847">        text.setIndex(0);</span>
<span class="nc" id="L848">        currentIndex=nextIndex=0;</span>
<span class="nc" id="L849">        clearBuffer();</span>
<span class="nc" id="L850">    }</span>

    /**
     * Set the iteration position in the input text that is being normalized,
     * without any immediate normalization.
     * After setIndexOnly(), getIndex() will return the same index that is
     * specified here.
     *
     * @param index the desired index in the input text.
     * @stable ICU 2.8
     */
    public void setIndexOnly(int index) {
<span class="nc" id="L862">        text.setIndex(index);</span>
<span class="nc" id="L863">        currentIndex=nextIndex=index; // validates index</span>
<span class="nc" id="L864">        clearBuffer();</span>
<span class="nc" id="L865">    }</span>

    /**
     * Set the iteration position in the input text that is being normalized
     * and return the first normalized character at that position.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This method sets the position in the &lt;em&gt;input&lt;/em&gt; text,
     * while {@link #next} and {@link #previous} iterate through characters
     * in the normalized &lt;em&gt;output&lt;/em&gt;.  This means that there is not
     * necessarily a one-to-one correspondence between characters returned
     * by &lt;tt&gt;next&lt;/tt&gt; and &lt;tt&gt;previous&lt;/tt&gt; and the indices passed to and
     * returned from &lt;tt&gt;setIndex&lt;/tt&gt; and {@link #getIndex}.
     * &lt;p&gt;
     * @param index the desired index in the input text-&gt;
     *
     * @return   the first normalized character that is the result of iterating
     *            forward starting at the given index.
     *
     * @throws IllegalArgumentException if the given index is less than
     *          {@link #getBeginIndex} or greater than {@link #getEndIndex}.
     * @return The codepoint as an int
     * @deprecated ICU 3.2
     * @obsolete ICU 3.2
     */
     @Deprecated
     public int setIndex(int index) {
<span class="nc" id="L891">         setIndexOnly(index);</span>
<span class="nc" id="L892">         return current();</span>
     }

    /**
     * Retrieve the index of the start of the input text. This is the begin
     * index of the &lt;tt&gt;CharacterIterator&lt;/tt&gt; or the start (i.e. 0) of the
     * &lt;tt&gt;String&lt;/tt&gt; over which this &lt;tt&gt;Normalizer&lt;/tt&gt; is iterating
     * @deprecated ICU 2.2. Use startIndex() instead.
     * @return The codepoint as an int
     * @see #startIndex
     */
    @Deprecated
    public int getBeginIndex() {
<span class="nc" id="L905">        return 0;</span>
    }

    /**
     * Retrieve the index of the end of the input text.  This is the end index
     * of the &lt;tt&gt;CharacterIterator&lt;/tt&gt; or the length of the &lt;tt&gt;String&lt;/tt&gt;
     * over which this &lt;tt&gt;Normalizer&lt;/tt&gt; is iterating
     * @deprecated ICU 2.2. Use endIndex() instead.
     * @return The codepoint as an int
     * @see #endIndex
     */
    @Deprecated
    public int getEndIndex() {
<span class="nc" id="L918">        return endIndex();</span>
    }

    /**
     * Retrieve the current iteration position in the input text that is
     * being normalized.  This method is useful in applications such as
     * searching, where you need to be able to determine the position in
     * the input text that corresponds to a given normalized output character.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This method sets the position in the &lt;em&gt;input&lt;/em&gt;, while
     * {@link #next} and {@link #previous} iterate through characters in the
     * &lt;em&gt;output&lt;/em&gt;.  This means that there is not necessarily a one-to-one
     * correspondence between characters returned by &lt;tt&gt;next&lt;/tt&gt; and
     * &lt;tt&gt;previous&lt;/tt&gt; and the indices passed to and returned from
     * &lt;tt&gt;setIndex&lt;/tt&gt; and {@link #getIndex}.
     * @return The current iteration position
     * @stable ICU 2.8
     */
    public int getIndex() {
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if(bufferPos&lt;bufferLimit) {</span>
<span class="nc" id="L938">            return currentIndex;</span>
        } else {
<span class="nc" id="L940">            return nextIndex;</span>
        }
    }

    /**
     * Retrieve the index of the end of the input text-&gt;  This is the end index
     * of the &lt;tt&gt;CharacterIterator&lt;/tt&gt; or the length of the &lt;tt&gt;String&lt;/tt&gt;
     * over which this &lt;tt&gt;Normalizer&lt;/tt&gt; is iterating
     * @return The current iteration position
     * @stable ICU 2.8
     */
    public int endIndex() {
<span class="nc" id="L952">        return text.getLength();</span>
    }

    //-------------------------------------------------------------------------
    // Property access methods
    //-------------------------------------------------------------------------
    /**
     * Set the normalization mode for this object.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt;If the normalization mode is changed while iterating
     * over a string, calls to {@link #next} and {@link #previous} may
     * return previously buffers characters in the old normalization mode
     * until the iteration is able to re-sync at the next base character.
     * It is safest to call {@link #setText setText()}, {@link #first},
     * {@link #last}, etc. after calling &lt;tt&gt;setMode&lt;/tt&gt;.
     * &lt;p&gt;
     * @param newMode the new mode for this &lt;tt&gt;Normalizer&lt;/tt&gt;.
     * The supported modes are:
     * &lt;ul&gt;
     *  &lt;li&gt;{@link #COMPOSE}        - Unicode canonical decompositiion
     *                                  followed by canonical composition.
     *  &lt;li&gt;{@link #COMPOSE_COMPAT} - Unicode compatibility decompositiion
     *                                  follwed by canonical composition.
     *  &lt;li&gt;{@link #DECOMP}         - Unicode canonical decomposition
     *  &lt;li&gt;{@link #DECOMP_COMPAT}  - Unicode compatibility decomposition.
     *  &lt;li&gt;{@link #NO_OP}          - Do nothing but return characters
     *                                  from the underlying input text.
     * &lt;/ul&gt;
     *
     * @see #getMode
     * @stable ICU 2.8
     */
    public void setMode(Mode newMode) {
<span class="nc" id="L985">        mode = newMode;</span>
<span class="nc" id="L986">    }</span>
    /**
     * Return the basic operation performed by this &lt;tt&gt;Normalizer&lt;/tt&gt;
     *
     * @see #setMode
     * @stable ICU 2.8
     */
    public Mode getMode() {
<span class="nc" id="L994">        return mode;</span>
    }

    /**
     * Set the input text over which this &lt;tt&gt;Normalizer&lt;/tt&gt; will iterate.
     * The iteration position is set to the beginning of the input text-&gt;
     * @param newText   The new string to be normalized.
     * @stable ICU 2.8
     */
    public void setText(String newText) {

<span class="nc" id="L1005">        UCharacterIterator newIter = UCharacterIterator.getInstance(newText);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        if (newIter == null) {</span>
<span class="nc" id="L1007">            throw new InternalError(&quot;Could not create a new UCharacterIterator&quot;);</span>
        }
<span class="nc" id="L1009">        text = newIter;</span>
<span class="nc" id="L1010">        reset();</span>
<span class="nc" id="L1011">    }</span>

    /**
     * Set the input text over which this &lt;tt&gt;Normalizer&lt;/tt&gt; will iterate.
     * The iteration position is set to the beginning of the input text-&gt;
     * @param newText   The new string to be normalized.
     * @stable ICU 2.8
     */
    public void setText(CharacterIterator newText) {

<span class="nc" id="L1021">        UCharacterIterator newIter = UCharacterIterator.getInstance(newText);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if (newIter == null) {</span>
<span class="nc" id="L1023">            throw new InternalError(&quot;Could not create a new UCharacterIterator&quot;);</span>
        }
<span class="nc" id="L1025">        text = newIter;</span>
<span class="nc" id="L1026">        currentIndex=nextIndex=0;</span>
<span class="nc" id="L1027">        clearBuffer();</span>
<span class="nc" id="L1028">    }</span>

    //-------------------------------------------------------------------------
    // Private utility methods
    //-------------------------------------------------------------------------


    /* backward iteration --------------------------------------------------- */

    /*
     * read backwards and get norm32
     * return 0 if the character is &lt;minC
     * if c2!=0 then (c2, c) is a surrogate pair (reversed - c2 is first
     * surrogate but read second!)
     */

    private static  long getPrevNorm32(UCharacterIterator src,
                                       int/*unsigned*/ minC,
                                       int/*unsigned*/ mask,
                                       char[] chars) {
        long norm32;
<span class="nc" id="L1049">        int ch=0;</span>
        /* need src.hasPrevious() */
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        if((ch=src.previous()) == UCharacterIterator.DONE) {</span>
<span class="nc" id="L1052">            return 0;</span>
        }
<span class="nc" id="L1054">        chars[0]=(char)ch;</span>
<span class="nc" id="L1055">        chars[1]=0;</span>

        /* check for a surrogate before getting norm32 to see if we need to
         * predecrement further */
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        if(chars[0]&lt;minC) {</span>
<span class="nc" id="L1060">            return 0;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        } else if(!UTF16.isSurrogate(chars[0])) {</span>
<span class="nc" id="L1062">            return NormalizerImpl.getNorm32(chars[0]);</span>
<span class="nc bnc" id="L1063" title="All 4 branches missed.">        } else if(UTF16.isLeadSurrogate(chars[0]) || (src.getIndex()==0)) {</span>
            /* unpaired surrogate */
<span class="nc" id="L1065">            chars[1]=(char)src.current();</span>
<span class="nc" id="L1066">            return 0;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        } else if(UTF16.isLeadSurrogate(chars[1]=(char)src.previous())) {</span>
<span class="nc" id="L1068">            norm32=NormalizerImpl.getNorm32(chars[1]);</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">            if((norm32&amp;mask)==0) {</span>
                /* all surrogate pairs with this lead surrogate have irrelevant
                 * data */
<span class="nc" id="L1072">                return 0;</span>
            } else {
                /* norm32 must be a surrogate special */
<span class="nc" id="L1075">                return NormalizerImpl.getNorm32FromSurrogatePair(norm32,chars[0]);</span>
            }
        } else {
            /* unpaired second surrogate, undo the c2=src.previous() movement */
<span class="nc" id="L1079">            src.moveIndex( 1);</span>
<span class="nc" id="L1080">            return 0;</span>
        }
    }

    private interface IsPrevBoundary{
        public boolean isPrevBoundary(UCharacterIterator src,
                                      int/*unsigned*/ minC,
                                      int/*unsigned*/ mask,
                                      char[] chars);
    }
<span class="nc" id="L1090">    private static final class IsPrevNFDSafe implements IsPrevBoundary{</span>
        /*
         * for NF*D:
         * read backwards and check if the lead combining class is 0
         * if c2!=0 then (c2, c) is a surrogate pair (reversed - c2 is first
         * surrogate but read second!)
         */
        public boolean isPrevBoundary(UCharacterIterator src,
                                      int/*unsigned*/ minC,
                                      int/*unsigned*/ ccOrQCMask,
                                      char[] chars) {

<span class="nc" id="L1102">            return NormalizerImpl.isNFDSafe(getPrevNorm32(src, minC,</span>
                                                          ccOrQCMask, chars),
                                            ccOrQCMask,
                                            ccOrQCMask&amp; NormalizerImpl.QC_MASK);
        }
    }

<span class="nc" id="L1109">    private static final class IsPrevTrueStarter implements IsPrevBoundary{</span>
        /*
         * read backwards and check if the character is (or its decomposition
         * begins with) a &quot;true starter&quot; (cc==0 and NF*C_YES)
         * if c2!=0 then (c2, c) is a surrogate pair (reversed - c2 is first
         * surrogate but read second!)
         */
        public boolean isPrevBoundary(UCharacterIterator src,
                                      int/*unsigned*/ minC,
                                      int/*unsigned*/ ccOrQCMask,
                                      char[] chars) {
            long norm32;
            int/*unsigned*/ decompQCMask;

<span class="nc" id="L1123">            decompQCMask=(ccOrQCMask&lt;&lt;2)&amp;0xf; /*decomposition quick check mask*/</span>
<span class="nc" id="L1124">            norm32=getPrevNorm32(src, minC, ccOrQCMask|decompQCMask, chars);</span>
<span class="nc" id="L1125">            return NormalizerImpl.isTrueStarter(norm32,ccOrQCMask,decompQCMask);</span>
        }
    }

    private static int findPreviousIterationBoundary(UCharacterIterator src,
                                                     IsPrevBoundary obj,
                                                     int/*unsigned*/ minC,
                                                     int/*mask*/ mask,
                                                     char[] buffer,
                                                     int[] startIndex) {
<span class="nc" id="L1135">        char[] chars=new char[2];</span>
        boolean isBoundary;

        /* fill the buffer from the end backwards */
<span class="nc" id="L1139">        startIndex[0] = buffer.length;</span>
<span class="nc" id="L1140">        chars[0]=0;</span>
<span class="nc bnc" id="L1141" title="All 4 branches missed.">        while(src.getIndex()&gt;0 &amp;&amp; chars[0]!=UCharacterIterator.DONE) {</span>
<span class="nc" id="L1142">            isBoundary=obj.isPrevBoundary(src, minC, mask, chars);</span>

            /* always write this character to the front of the buffer */
            /* make sure there is enough space in the buffer */
<span class="nc bnc" id="L1146" title="All 4 branches missed.">            if(startIndex[0] &lt; (chars[1]==0 ? 1 : 2)) {</span>

                // grow the buffer
<span class="nc" id="L1149">                char[] newBuf = new char[buffer.length*2];</span>
                /* move the current buffer contents up */
<span class="nc" id="L1151">                System.arraycopy(buffer,startIndex[0],newBuf,</span>
                                 newBuf.length-(buffer.length-startIndex[0]),
                                 buffer.length-startIndex[0]);
                //adjust the startIndex
<span class="nc" id="L1155">                startIndex[0]+=newBuf.length-buffer.length;</span>

<span class="nc" id="L1157">                buffer=newBuf;</span>
<span class="nc" id="L1158">                newBuf=null;</span>

            }

<span class="nc" id="L1162">            buffer[--startIndex[0]]=chars[0];</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            if(chars[1]!=0) {</span>
<span class="nc" id="L1164">                buffer[--startIndex[0]]=chars[1];</span>
            }

            /* stop if this just-copied character is a boundary */
<span class="nc bnc" id="L1168" title="All 2 branches missed.">            if(isBoundary) {</span>
<span class="nc" id="L1169">                break;</span>
            }
        }

        /* return the length of the buffer contents */
<span class="nc" id="L1174">        return buffer.length-startIndex[0];</span>
    }

    private static int previous(UCharacterIterator src,
                                char[] dest, int destStart, int destLimit,
                                Mode mode,
                                boolean doNormalize,
                                boolean[] pNeededToNormalize,
                                int options) {

        IsPrevBoundary isPreviousBoundary;
        int destLength, bufferLength;
        int/*unsigned*/ mask;
        int c,c2;

        char minC;
<span class="nc" id="L1190">        int destCapacity = destLimit-destStart;</span>
<span class="nc" id="L1191">        destLength=0;</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if(pNeededToNormalize!=null) {</span>
<span class="nc" id="L1194">            pNeededToNormalize[0]=false;</span>
        }
<span class="nc" id="L1196">        minC = (char)mode.getMinC();</span>
<span class="nc" id="L1197">        mask = mode.getMask();</span>
<span class="nc" id="L1198">        isPreviousBoundary = mode.getPrevBoundary();</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if(isPreviousBoundary==null) {</span>
<span class="nc" id="L1201">            destLength=0;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if((c=src.previous())&gt;=0) {</span>
<span class="nc" id="L1203">                destLength=1;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                if(UTF16.isTrailSurrogate((char)c)) {</span>
<span class="nc" id="L1205">                    c2= src.previous();</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                    if(c2!= UCharacterIterator.DONE) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                        if(UTF16.isLeadSurrogate((char)c2)) {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                            if(destCapacity&gt;=2) {</span>
<span class="nc" id="L1209">                                dest[1]=(char)c; // trail surrogate</span>
<span class="nc" id="L1210">                                destLength=2;</span>
                            }
                            // lead surrogate to be written below
<span class="nc" id="L1213">                            c=c2;</span>
                        } else {
<span class="nc" id="L1215">                            src.moveIndex(1);</span>
                        }
                    }
                }

<span class="nc bnc" id="L1220" title="All 2 branches missed.">                if(destCapacity&gt;0) {</span>
<span class="nc" id="L1221">                    dest[0]=(char)c;</span>
                }
            }
<span class="nc" id="L1224">            return destLength;</span>
        }

<span class="nc" id="L1227">        char[] buffer = new char[100];</span>
<span class="nc" id="L1228">        int[] startIndex= new int[1];</span>
<span class="nc" id="L1229">        bufferLength=findPreviousIterationBoundary(src,</span>
                                                   isPreviousBoundary,
                                                   minC, mask,buffer,
                                                   startIndex);
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if(bufferLength&gt;0) {</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            if(doNormalize) {</span>
<span class="nc" id="L1235">                destLength=NormalizerBase.normalize(buffer,startIndex[0],</span>
                                                startIndex[0]+bufferLength,
                                                dest, destStart,destLimit,
                                                mode, options);

<span class="nc bnc" id="L1240" title="All 2 branches missed.">                if(pNeededToNormalize!=null) {</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">                    pNeededToNormalize[0]=destLength!=bufferLength ||</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">                                          Utility.arrayRegionMatches(</span>
                                            buffer,0,dest,
                                            destStart,destLimit
                                          );
                }
            } else {
                /* just copy the source characters */
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                if(destCapacity&gt;0) {</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">                    System.arraycopy(buffer,startIndex[0],dest,0,</span>
                                     (bufferLength&lt;destCapacity) ?
                                     bufferLength : destCapacity
                                     );
                }
            }
        }


<span class="nc" id="L1259">        return destLength;</span>
    }



    /* forward iteration ---------------------------------------------------- */
    /*
     * read forward and check if the character is a next-iteration boundary
     * if c2!=0 then (c, c2) is a surrogate pair
     */
    private interface IsNextBoundary{
        boolean isNextBoundary(UCharacterIterator src,
                               int/*unsigned*/ minC,
                               int/*unsigned*/ mask,
                               int[] chars);
    }
    /*
     * read forward and get norm32
     * return 0 if the character is &lt;minC
     * if c2!=0 then (c2, c) is a surrogate pair
     * always reads complete characters
     */
    private static long /*unsigned*/ getNextNorm32(UCharacterIterator src,
                                                   int/*unsigned*/ minC,
                                                   int/*unsigned*/ mask,
                                                   int[] chars) {
        long norm32;

        /* need src.hasNext() to be true */
<span class="nc" id="L1288">        chars[0]=src.next();</span>
<span class="nc" id="L1289">        chars[1]=0;</span>

<span class="nc bnc" id="L1291" title="All 2 branches missed.">        if(chars[0]&lt;minC) {</span>
<span class="nc" id="L1292">            return 0;</span>
        }

<span class="nc" id="L1295">        norm32=NormalizerImpl.getNorm32((char)chars[0]);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        if(UTF16.isLeadSurrogate((char)chars[0])) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            if(src.current()!=UCharacterIterator.DONE &amp;&amp;</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">               UTF16.isTrailSurrogate((char)(chars[1]=src.current()))) {</span>
<span class="nc" id="L1299">                src.moveIndex(1); /* skip the c2 surrogate */</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                if((norm32&amp;mask)==0) {</span>
                    /* irrelevant data */
<span class="nc" id="L1302">                    return 0;</span>
                } else {
                    /* norm32 must be a surrogate special */
<span class="nc" id="L1305">                    return NormalizerImpl.getNorm32FromSurrogatePair(norm32,(char)chars[1]);</span>
                }
            } else {
                /* unmatched surrogate */
<span class="nc" id="L1309">                return 0;</span>
            }
        }
<span class="nc" id="L1312">        return norm32;</span>
    }


    /*
     * for NF*D:
     * read forward and check if the lead combining class is 0
     * if c2!=0 then (c, c2) is a surrogate pair
     */
<span class="nc" id="L1321">    private static final class IsNextNFDSafe implements IsNextBoundary{</span>
        public boolean isNextBoundary(UCharacterIterator src,
                                      int/*unsigned*/ minC,
                                      int/*unsigned*/ ccOrQCMask,
                                      int[] chars) {
<span class="nc" id="L1326">            return NormalizerImpl.isNFDSafe(getNextNorm32(src,minC,ccOrQCMask,chars),</span>
                                            ccOrQCMask, ccOrQCMask&amp;NormalizerImpl.QC_MASK);
        }
    }

    /*
     * for NF*C:
     * read forward and check if the character is (or its decomposition begins
     * with) a &quot;true starter&quot; (cc==0 and NF*C_YES)
     * if c2!=0 then (c, c2) is a surrogate pair
     */
<span class="nc" id="L1337">    private static final class IsNextTrueStarter implements IsNextBoundary{</span>
        public boolean isNextBoundary(UCharacterIterator src,
                                      int/*unsigned*/ minC,
                                      int/*unsigned*/ ccOrQCMask,
                                      int[] chars) {
            long norm32;
            int/*unsigned*/ decompQCMask;

<span class="nc" id="L1345">            decompQCMask=(ccOrQCMask&lt;&lt;2)&amp;0xf; /*decomposition quick check mask*/</span>
<span class="nc" id="L1346">            norm32=getNextNorm32(src, minC, ccOrQCMask|decompQCMask, chars);</span>
<span class="nc" id="L1347">            return NormalizerImpl.isTrueStarter(norm32, ccOrQCMask, decompQCMask);</span>
        }
    }

    private static int findNextIterationBoundary(UCharacterIterator src,
                                                 IsNextBoundary obj,
                                                 int/*unsigned*/ minC,
                                                 int/*unsigned*/ mask,
                                                 char[] buffer) {
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if(src.current()==UCharacterIterator.DONE) {</span>
<span class="nc" id="L1357">            return 0;</span>
        }

        /* get one character and ignore its properties */
<span class="nc" id="L1361">        int[] chars = new int[2];</span>
<span class="nc" id="L1362">        chars[0]=src.next();</span>
<span class="nc" id="L1363">        buffer[0]=(char)chars[0];</span>
<span class="nc" id="L1364">        int bufferIndex = 1;</span>

<span class="nc bnc" id="L1366" title="All 2 branches missed.">        if(UTF16.isLeadSurrogate((char)chars[0])&amp;&amp;</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">           src.current()!=UCharacterIterator.DONE) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if(UTF16.isTrailSurrogate((char)(chars[1]=src.next()))) {</span>
<span class="nc" id="L1369">                buffer[bufferIndex++]=(char)chars[1];</span>
            } else {
<span class="nc" id="L1371">                src.moveIndex(-1); /* back out the non-trail-surrogate */</span>
            }
        }

        /* get all following characters until we see a boundary */
        /* checking hasNext() instead of c!=DONE on the off-chance that U+ffff
         * is part of the string */
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        while( src.current()!=UCharacterIterator.DONE) {</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">            if(obj.isNextBoundary(src, minC, mask, chars)) {</span>
                /* back out the latest movement to stop at the boundary */
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                src.moveIndex(chars[1]==0 ? -1 : -2);</span>
<span class="nc" id="L1382">                break;</span>
            } else {
<span class="nc bnc" id="L1384" title="All 4 branches missed.">                if(bufferIndex+(chars[1]==0 ? 1 : 2)&lt;=buffer.length) {</span>
<span class="nc" id="L1385">                    buffer[bufferIndex++]=(char)chars[0];</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                    if(chars[1]!=0) {</span>
<span class="nc" id="L1387">                        buffer[bufferIndex++]=(char)chars[1];</span>
                    }
                } else {
<span class="nc" id="L1390">                    char[] newBuf = new char[buffer.length*2];</span>
<span class="nc" id="L1391">                    System.arraycopy(buffer,0,newBuf,0,bufferIndex);</span>
<span class="nc" id="L1392">                    buffer = newBuf;</span>
<span class="nc" id="L1393">                    buffer[bufferIndex++]=(char)chars[0];</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                    if(chars[1]!=0) {</span>
<span class="nc" id="L1395">                        buffer[bufferIndex++]=(char)chars[1];</span>
                    }
<span class="nc" id="L1397">                }</span>
            }
        }

        /* return the length of the buffer contents */
<span class="nc" id="L1402">        return bufferIndex;</span>
    }

    private static int next(UCharacterIterator src,
                            char[] dest, int destStart, int destLimit,
                            NormalizerBase.Mode mode,
                            boolean doNormalize,
                            boolean[] pNeededToNormalize,
                            int options) {

        IsNextBoundary isNextBoundary;
        int /*unsigned*/ mask;
        int /*unsigned*/ bufferLength;
        int c,c2;
        char minC;
<span class="nc" id="L1417">        int destCapacity = destLimit - destStart;</span>
<span class="nc" id="L1418">        int destLength = 0;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        if(pNeededToNormalize!=null) {</span>
<span class="nc" id="L1420">            pNeededToNormalize[0]=false;</span>
        }

<span class="nc" id="L1423">        minC = (char)mode.getMinC();</span>
<span class="nc" id="L1424">        mask = mode.getMask();</span>
<span class="nc" id="L1425">        isNextBoundary = mode.getNextBoundary();</span>

<span class="nc bnc" id="L1427" title="All 2 branches missed.">        if(isNextBoundary==null) {</span>
<span class="nc" id="L1428">            destLength=0;</span>
<span class="nc" id="L1429">            c=src.next();</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">            if(c!=UCharacterIterator.DONE) {</span>
<span class="nc" id="L1431">                destLength=1;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                if(UTF16.isLeadSurrogate((char)c)) {</span>
<span class="nc" id="L1433">                    c2= src.next();</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                    if(c2!= UCharacterIterator.DONE) {</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">                        if(UTF16.isTrailSurrogate((char)c2)) {</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                            if(destCapacity&gt;=2) {</span>
<span class="nc" id="L1437">                                dest[1]=(char)c2; // trail surrogate</span>
<span class="nc" id="L1438">                                destLength=2;</span>
                            }
                            // lead surrogate to be written below
                        } else {
<span class="nc" id="L1442">                            src.moveIndex(-1);</span>
                        }
                    }
                }

<span class="nc bnc" id="L1447" title="All 2 branches missed.">                if(destCapacity&gt;0) {</span>
<span class="nc" id="L1448">                    dest[0]=(char)c;</span>
                }
            }
<span class="nc" id="L1451">            return destLength;</span>
        }

<span class="nc" id="L1454">        char[] buffer=new char[100];</span>
<span class="nc" id="L1455">        int[] startIndex = new int[1];</span>
<span class="nc" id="L1456">        bufferLength=findNextIterationBoundary(src,isNextBoundary, minC, mask,</span>
                                               buffer);
<span class="nc bnc" id="L1458" title="All 2 branches missed.">        if(bufferLength&gt;0) {</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">            if(doNormalize) {</span>
<span class="nc" id="L1460">                destLength=mode.normalize(buffer,startIndex[0],bufferLength,</span>
                                          dest,destStart,destLimit, options);

<span class="nc bnc" id="L1463" title="All 2 branches missed.">                if(pNeededToNormalize!=null) {</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">                    pNeededToNormalize[0]=destLength!=bufferLength ||</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                                          Utility.arrayRegionMatches(buffer,startIndex[0],</span>
                                            dest,destStart,
                                            destLength);
                }
            } else {
                /* just copy the source characters */
<span class="nc bnc" id="L1471" title="All 2 branches missed.">                if(destCapacity&gt;0) {</span>
<span class="nc" id="L1472">                    System.arraycopy(buffer,0,dest,destStart,</span>
<span class="nc" id="L1473">                                     Math.min(bufferLength,destCapacity)</span>
                                     );
                }


            }
        }
<span class="nc" id="L1480">        return destLength;</span>
    }

    private void clearBuffer() {
<span class="nc" id="L1484">        bufferLimit=bufferStart=bufferPos=0;</span>
<span class="nc" id="L1485">    }</span>

    private boolean nextNormalize() {

<span class="nc" id="L1489">        clearBuffer();</span>
<span class="nc" id="L1490">        currentIndex=nextIndex;</span>
<span class="nc" id="L1491">        text.setIndex(nextIndex);</span>

<span class="nc" id="L1493">        bufferLimit=next(text,buffer,bufferStart,buffer.length,mode,true,null,options);</span>

<span class="nc" id="L1495">        nextIndex=text.getIndex();</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        return (bufferLimit&gt;0);</span>
    }

    private boolean previousNormalize() {

<span class="nc" id="L1501">        clearBuffer();</span>
<span class="nc" id="L1502">        nextIndex=currentIndex;</span>
<span class="nc" id="L1503">        text.setIndex(currentIndex);</span>
<span class="nc" id="L1504">        bufferLimit=previous(text,buffer,bufferStart,buffer.length,mode,true,null,options);</span>

<span class="nc" id="L1506">        currentIndex=text.getIndex();</span>
<span class="nc" id="L1507">        bufferPos = bufferLimit;</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        return bufferLimit&gt;0;</span>
    }

    private int getCodePointAt(int index) {
<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if( UTF16.isSurrogate(buffer[index])) {</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">            if(UTF16.isLeadSurrogate(buffer[index])) {</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">                if((index+1)&lt;bufferLimit &amp;&amp;</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                   UTF16.isTrailSurrogate(buffer[index+1])) {</span>
<span class="nc" id="L1516">                    return UCharacterProperty.getRawSupplementary(</span>
                                                                  buffer[index],
                                                                  buffer[index+1]
                                                                  );
                }
<span class="nc bnc" id="L1521" title="All 2 branches missed.">            }else if(UTF16.isTrailSurrogate(buffer[index])) {</span>
<span class="nc bnc" id="L1522" title="All 4 branches missed.">                if(index&gt;0 &amp;&amp; UTF16.isLeadSurrogate(buffer[index-1])) {</span>
<span class="nc" id="L1523">                    return UCharacterProperty.getRawSupplementary(</span>
                                                                  buffer[index-1],
                                                                  buffer[index]
                                                                  );
                }
            }
        }
<span class="nc" id="L1530">        return buffer[index];</span>

    }

    /**
     * Internal API
     * @internal
     */
    public static boolean isNFSkippable(int c, Mode mode) {
<span class="nc" id="L1539">        return mode.isNFSkippable(c);</span>
    }

    //
    // Options
    //

    /*
     * Default option for Unicode 3.2.0 normalization.
     * Corrigendum 4 was fixed in Unicode 3.2.0 but isn't supported in
     * IDNA/StringPrep.
     * The public review issue #29 was fixed in Unicode 4.1.0. Corrigendum 5
     * allowed Unicode 3.2 to 4.0.1 to apply the fix for PRI #29, but it isn't
     * supported by IDNA/StringPrep as well as Corrigendum 4.
     */
    public static final int UNICODE_3_2_0_ORIGINAL =
                               UNICODE_3_2 |
                               NormalizerImpl.WITHOUT_CORRIGENDUM4_CORRECTIONS |
                               NormalizerImpl.BEFORE_PRI_29;

    /*
     * Default option for the latest Unicode normalization. This option is
     * provided mainly for testing.
     * The value zero means that normalization is done with the fixes for
     *   - Corrigendum 4 (Five CJK Canonical Mapping Errors)
     *   - Corrigendum 5 (Normalization Idempotency)
     */
    public static final int UNICODE_LATEST = 0x00;

    //
    // public constructor and methods for java.text.Normalizer and
    // sun.text.Normalizer
    //

    /**
     * Creates a new &lt;tt&gt;Normalizer&lt;/tt&gt; object for iterating over the
     * normalized form of a given string.
     *
     * @param str  The string to be normalized.  The normalization
     *              will start at the beginning of the string.
     *
     * @param mode The normalization mode.
     */
    public NormalizerBase(String str, Mode mode) {
<span class="nc" id="L1583">          this(str, mode, UNICODE_LATEST);</span>
<span class="nc" id="L1584">    }</span>

    /**
     * Normalizes a &lt;code&gt;String&lt;/code&gt; using the given normalization form.
     *
     * @param str      the input string to be normalized.
     * @param form     the normalization form
     */
    public static String normalize(String str, Normalizer.Form form) {
<span class="fc" id="L1593">        return normalize(str, form, UNICODE_LATEST);</span>
    }

    /**
     * Normalizes a &lt;code&gt;String&lt;/code&gt; using the given normalization form.
     *
     * @param str      the input string to be normalized.
     * @param form     the normalization form
     * @param options   the optional features to be enabled.
     */
    public static String normalize(String str, Normalizer.Form form, int options) {
<span class="fc" id="L1604">        int len = str.length();</span>
<span class="fc" id="L1605">        boolean asciiOnly = true;</span>
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">        if (len &lt; 80) {</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">                if (str.charAt(i) &gt; 127) {</span>
<span class="fc" id="L1609">                    asciiOnly = false;</span>
<span class="fc" id="L1610">                    break;</span>
                }
            }
        } else {
<span class="nc" id="L1614">            char[] a = str.toCharArray();</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">                if (a[i] &gt; 127) {</span>
<span class="nc" id="L1617">                    asciiOnly = false;</span>
<span class="nc" id="L1618">                    break;</span>
                }
            }
        }

<span class="pc bpc" id="L1623" title="4 of 5 branches missed.">        switch (form) {</span>
        case NFC :
<span class="nc bnc" id="L1625" title="All 2 branches missed.">            return asciiOnly ? str : NFC.normalize(str, options);</span>
        case NFD :
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            return asciiOnly ? str : NFD.normalize(str, options);</span>
        case NFKC :
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            return asciiOnly ? str : NFKC.normalize(str, options);</span>
        case NFKD :
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            return asciiOnly ? str : NFKD.normalize(str, options);</span>
        }

<span class="nc" id="L1634">        throw new IllegalArgumentException(&quot;Unexpected normalization form: &quot; +</span>
                                           form);
    }

    /**
     * Test if a string is in a given normalization form.
     * This is semantically equivalent to source.equals(normalize(source, mode)).
     *
     * Unlike quickCheck(), this function returns a definitive result,
     * never a &quot;maybe&quot;.
     * For NFD, NFKD, and FCD, both functions work exactly the same.
     * For NFC and NFKC where quickCheck may return &quot;maybe&quot;, this function will
     * perform further tests to arrive at a true/false result.
     * @param str       the input string to be checked to see if it is normalized
     * @param form      the normalization form
     * @param options   the optional features to be enabled.
     */
    public static boolean isNormalized(String str, Normalizer.Form form) {
<span class="nc" id="L1652">        return isNormalized(str, form, UNICODE_LATEST);</span>
    }

    /**
     * Test if a string is in a given normalization form.
     * This is semantically equivalent to source.equals(normalize(source, mode)).
     *
     * Unlike quickCheck(), this function returns a definitive result,
     * never a &quot;maybe&quot;.
     * For NFD, NFKD, and FCD, both functions work exactly the same.
     * For NFC and NFKC where quickCheck may return &quot;maybe&quot;, this function will
     * perform further tests to arrive at a true/false result.
     * @param str       the input string to be checked to see if it is normalized
     * @param form      the normalization form
     * @param options   the optional features to be enabled.
     */
    public static boolean isNormalized(String str, Normalizer.Form form, int options) {
<span class="nc bnc" id="L1669" title="All 5 branches missed.">        switch (form) {</span>
        case NFC:
<span class="nc bnc" id="L1671" title="All 2 branches missed.">            return (NFC.quickCheck(str.toCharArray(),0,str.length(),false,NormalizerImpl.getNX(options))==YES);</span>
        case NFD:
<span class="nc bnc" id="L1673" title="All 2 branches missed.">            return (NFD.quickCheck(str.toCharArray(),0,str.length(),false,NormalizerImpl.getNX(options))==YES);</span>
        case NFKC:
<span class="nc bnc" id="L1675" title="All 2 branches missed.">            return (NFKC.quickCheck(str.toCharArray(),0,str.length(),false,NormalizerImpl.getNX(options))==YES);</span>
        case NFKD:
<span class="nc bnc" id="L1677" title="All 2 branches missed.">            return (NFKD.quickCheck(str.toCharArray(),0,str.length(),false,NormalizerImpl.getNX(options))==YES);</span>
        }

<span class="nc" id="L1680">        throw new IllegalArgumentException(&quot;Unexpected normalization form: &quot; +</span>
                                           form);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>