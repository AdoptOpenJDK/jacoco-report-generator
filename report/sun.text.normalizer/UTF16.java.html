<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UTF16.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">UTF16.java</span></div><h1>UTF16.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

/**
 * &lt;p&gt;Standalone utility class providing UTF16 character conversions and
 * indexing conversions.&lt;/p&gt;
 * &lt;p&gt;Code that uses strings alone rarely need modification.
 * By design, UTF-16 does not allow overlap, so searching for strings is a safe
 * operation. Similarly, concatenation is always safe. Substringing is safe if
 * the start and end are both on UTF-32 boundaries. In normal code, the values
 * for start and end are on those boundaries, since they arose from operations
 * like searching. If not, the nearest UTF-32 boundaries can be determined
 * using &lt;code&gt;bounds()&lt;/code&gt;.&lt;/p&gt;
 * &lt;strong&gt;Examples:&lt;/strong&gt;
 * &lt;p&gt;The following examples illustrate use of some of these methods.
 * &lt;pre&gt;
 * // iteration forwards: Original
 * for (int i = 0; i &amp;lt; s.length(); ++i) {
 *     char ch = s.charAt(i);
 *     doSomethingWith(ch);
 * }
 *
 * // iteration forwards: Changes for UTF-32
 * int ch;
 * for (int i = 0; i &amp;lt; s.length(); i+=UTF16.getCharCount(ch)) {
 *     ch = UTF16.charAt(s,i);
 *     doSomethingWith(ch);
 * }
 *
 * // iteration backwards: Original
 * for (int i = s.length() -1; i &gt;= 0; --i) {
 *     char ch = s.charAt(i);
 *     doSomethingWith(ch);
 * }
 *
 * // iteration backwards: Changes for UTF-32
 * int ch;
 * for (int i = s.length() -1; i &gt; 0; i-=UTF16.getCharCount(ch)) {
 *     ch = UTF16.charAt(s,i);
 *     doSomethingWith(ch);
 * }
 * &lt;/pre&gt;
 * &lt;strong&gt;Notes:&lt;/strong&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;
 *   &lt;strong&gt;Naming:&lt;/strong&gt; For clarity, High and Low surrogates are called
 *   &lt;code&gt;Lead&lt;/code&gt; and &lt;code&gt;Trail&lt;/code&gt; in the API, which gives a better
 *   sense of their ordering in a string. &lt;code&gt;offset16&lt;/code&gt; and
 *   &lt;code&gt;offset32&lt;/code&gt; are used to distinguish offsets to UTF-16
 *   boundaries vs offsets to UTF-32 boundaries. &lt;code&gt;int char32&lt;/code&gt; is
 *   used to contain UTF-32 characters, as opposed to &lt;code&gt;char16&lt;/code&gt;,
 *   which is a UTF-16 code unit.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *   &lt;strong&gt;Roundtripping Offsets:&lt;/strong&gt; You can always roundtrip from a
 *   UTF-32 offset to a UTF-16 offset and back. Because of the difference in
 *   structure, you can roundtrip from a UTF-16 offset to a UTF-32 offset and
 *   back if and only if &lt;code&gt;bounds(string, offset16) != TRAIL&lt;/code&gt;.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *    &lt;strong&gt;Exceptions:&lt;/strong&gt; The error checking will throw an exception
 *   if indices are out of bounds. Other than than that, all methods will
 *   behave reasonably, even if unmatched surrogates or out-of-bounds UTF-32
 *   values are present. &lt;code&gt;UCharacter.isLegal()&lt;/code&gt; can be used to check
 *   for validity if desired.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *   &lt;strong&gt;Unmatched Surrogates:&lt;/strong&gt; If the string contains unmatched
 *   surrogates, then these are counted as one UTF-32 value. This matches
 *   their iteration behavior, which is vital. It also matches common display
 *   practice as missing glyphs (see the Unicode Standard Section 5.4, 5.5).
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     &lt;strong&gt;Optimization:&lt;/strong&gt; The method implementations may need
 *     optimization if the compiler doesn't fold static final methods. Since
 *     surrogate pairs will form an exceeding small percentage of all the text
 *     in the world, the singleton case should always be optimized for.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 * @author Mark Davis, with help from Markus Scherer
 * @stable ICU 2.1
 */

<span class="nc" id="L119">public final class UTF16</span>
{
    // public variables ---------------------------------------------------

    /**
     * The lowest Unicode code point value.
     * @stable ICU 2.1
     */
    public static final int CODEPOINT_MIN_VALUE = 0;
    /**
     * The highest Unicode code point value (scalar value) according to the
     * Unicode Standard.
     * @stable ICU 2.1
     */
    public static final int CODEPOINT_MAX_VALUE = 0x10ffff;
    /**
     * The minimum value for Supplementary code points
     * @stable ICU 2.1
     */
    public static final int SUPPLEMENTARY_MIN_VALUE  = 0x10000;
    /**
     * Lead surrogate minimum value
     * @stable ICU 2.1
     */
    public static final int LEAD_SURROGATE_MIN_VALUE = 0xD800;
    /**
     * Trail surrogate minimum value
     * @stable ICU 2.1
     */
    public static final int TRAIL_SURROGATE_MIN_VALUE = 0xDC00;
    /**
     * Lead surrogate maximum value
     * @stable ICU 2.1
     */
    public static final int LEAD_SURROGATE_MAX_VALUE = 0xDBFF;
    /**
     * Trail surrogate maximum value
     * @stable ICU 2.1
     */
    public static final int TRAIL_SURROGATE_MAX_VALUE = 0xDFFF;
    /**
     * Surrogate minimum value
     * @stable ICU 2.1
     */
    public static final int SURROGATE_MIN_VALUE = LEAD_SURROGATE_MIN_VALUE;

    // public method ------------------------------------------------------

    /**
     * Extract a single UTF-32 value from a string.
     * Used when iterating forwards or backwards (with
     * &lt;code&gt;UTF16.getCharCount()&lt;/code&gt;, as well as random access. If a
     * validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;
     * UCharacter.isLegal()&lt;/a&gt;&lt;/code&gt; on the return value.
     * If the char retrieved is part of a surrogate pair, its supplementary
     * character will be returned. If a complete supplementary character is
     * not found the incomplete character will be returned
     * @param source array of UTF-16 chars
     * @param offset16 UTF-16 offset to the start of the character.
     * @return UTF-32 value for the UTF-32 value that contains the char at
     *         offset16. The boundaries of that codepoint are the same as in
     *         &lt;code&gt;bounds32()&lt;/code&gt;.
     * @exception IndexOutOfBoundsException thrown if offset16 is out of
     *            bounds.
     * @stable ICU 2.1
     */
    public static int charAt(String source, int offset16) {
<span class="nc" id="L187">        char single = source.charAt(offset16);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (single &lt; LEAD_SURROGATE_MIN_VALUE) {</span>
<span class="nc" id="L189">            return single;</span>
        }
<span class="nc" id="L191">        return _charAt(source, offset16, single);</span>
    }

    private static int _charAt(String source, int offset16, char single) {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (single &gt; TRAIL_SURROGATE_MAX_VALUE) {</span>
<span class="nc" id="L196">            return single;</span>
        }

        // Convert the UTF-16 surrogate pair if necessary.
        // For simplicity in usage, and because the frequency of pairs is
        // low, look both directions.

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (single &lt;= LEAD_SURROGATE_MAX_VALUE) {</span>
<span class="nc" id="L204">            ++offset16;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (source.length() != offset16) {</span>
<span class="nc" id="L206">                char trail = source.charAt(offset16);</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">                if (trail &gt;= TRAIL_SURROGATE_MIN_VALUE &amp;&amp; trail &lt;= TRAIL_SURROGATE_MAX_VALUE) {</span>
<span class="nc" id="L208">                    return UCharacterProperty.getRawSupplementary(single, trail);</span>
                }
<span class="nc" id="L210">            }</span>
        } else {
<span class="nc" id="L212">            --offset16;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (offset16 &gt;= 0) {</span>
                // single is a trail surrogate so
<span class="nc" id="L215">                char lead = source.charAt(offset16);</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">                if (lead &gt;= LEAD_SURROGATE_MIN_VALUE &amp;&amp; lead &lt;= LEAD_SURROGATE_MAX_VALUE) {</span>
<span class="nc" id="L217">                    return UCharacterProperty.getRawSupplementary(lead, single);</span>
                }
            }
        }
<span class="nc" id="L221">        return single; // return unmatched surrogate</span>
    }

    /**
     * Extract a single UTF-32 value from a substring.
     * Used when iterating forwards or backwards (with
     * &lt;code&gt;UTF16.getCharCount()&lt;/code&gt;, as well as random access. If a
     * validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;UCharacter.isLegal()
     * &lt;/a&gt;&lt;/code&gt; on the return value.
     * If the char retrieved is part of a surrogate pair, its supplementary
     * character will be returned. If a complete supplementary character is
     * not found the incomplete character will be returned
     * @param source array of UTF-16 chars
     * @param start offset to substring in the source array for analyzing
     * @param limit offset to substring in the source array for analyzing
     * @param offset16 UTF-16 offset relative to start
     * @return UTF-32 value for the UTF-32 value that contains the char at
     *         offset16. The boundaries of that codepoint are the same as in
     *         &lt;code&gt;bounds32()&lt;/code&gt;.
     * @exception IndexOutOfBoundsException thrown if offset16 is not within
     *            the range of start and limit.
     * @stable ICU 2.1
     */
    public static int charAt(char source[], int start, int limit,
                             int offset16)
    {
<span class="nc" id="L248">        offset16 += start;</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">        if (offset16 &lt; start || offset16 &gt;= limit) {</span>
<span class="nc" id="L250">            throw new ArrayIndexOutOfBoundsException(offset16);</span>
        }

<span class="nc" id="L253">        char single = source[offset16];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (!isSurrogate(single)) {</span>
<span class="nc" id="L255">            return single;</span>
        }

        // Convert the UTF-16 surrogate pair if necessary.
        // For simplicity in usage, and because the frequency of pairs is
        // low, look both directions.
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (single &lt;= LEAD_SURROGATE_MAX_VALUE) {</span>
<span class="nc" id="L262">            offset16 ++;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (offset16 &gt;= limit) {</span>
<span class="nc" id="L264">                return single;</span>
            }
<span class="nc" id="L266">            char trail = source[offset16];</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if (isTrailSurrogate(trail)) {</span>
<span class="nc" id="L268">                return UCharacterProperty.getRawSupplementary(single, trail);</span>
            }
<span class="nc" id="L270">        }</span>
        else { // isTrailSurrogate(single), so
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (offset16 == start) {</span>
<span class="nc" id="L273">                return single;</span>
            }
<span class="nc" id="L275">            offset16 --;</span>
<span class="nc" id="L276">            char lead = source[offset16];</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (isLeadSurrogate(lead))</span>
<span class="nc" id="L278">                return UCharacterProperty.getRawSupplementary(lead, single);</span>
        }
<span class="nc" id="L280">        return single; // return unmatched surrogate</span>
    }

    /**
     * Determines how many chars this char32 requires.
     * If a validity check is required, use &lt;code&gt;
     * &lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;isLegal()&lt;/a&gt;&lt;/code&gt; on
     * char32 before calling.
     * @param char32 the input codepoint.
     * @return 2 if is in supplementary space, otherwise 1.
     * @stable ICU 2.1
     */
    public static int getCharCount(int char32)
    {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (char32 &lt; SUPPLEMENTARY_MIN_VALUE) {</span>
<span class="fc" id="L295">            return 1;</span>
        }
<span class="nc" id="L297">        return 2;</span>
    }

    /**
     * Determines whether the code value is a surrogate.
     * @param char16 the input character.
     * @return true iff the input character is a surrogate.
     * @stable ICU 2.1
     */
    public static boolean isSurrogate(char char16)
    {
<span class="pc bpc" id="L308" title="3 of 4 branches missed.">        return LEAD_SURROGATE_MIN_VALUE &lt;= char16 &amp;&amp;</span>
            char16 &lt;= TRAIL_SURROGATE_MAX_VALUE;
    }

    /**
     * Determines whether the character is a trail surrogate.
     * @param char16 the input character.
     * @return true iff the input character is a trail surrogate.
     * @stable ICU 2.1
     */
    public static boolean isTrailSurrogate(char char16)
    {
<span class="nc bnc" id="L320" title="All 4 branches missed.">        return (TRAIL_SURROGATE_MIN_VALUE &lt;= char16 &amp;&amp;</span>
                char16 &lt;= TRAIL_SURROGATE_MAX_VALUE);
    }

    /**
     * Determines whether the character is a lead surrogate.
     * @param char16 the input character.
     * @return true iff the input character is a lead surrogate
     * @stable ICU 2.1
     */
    public static boolean isLeadSurrogate(char char16)
    {
<span class="nc bnc" id="L332" title="All 4 branches missed.">        return LEAD_SURROGATE_MIN_VALUE &lt;= char16 &amp;&amp;</span>
            char16 &lt;= LEAD_SURROGATE_MAX_VALUE;
    }

    /**
     * Returns the lead surrogate.
     * If a validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;isLegal()&lt;/a&gt;&lt;/code&gt;
     * on char32 before calling.
     * @param char32 the input character.
     * @return lead surrogate if the getCharCount(ch) is 2; &lt;br&gt;
     *         and 0 otherwise (note: 0 is not a valid lead surrogate).
     * @stable ICU 2.1
     */
    public static char getLeadSurrogate(int char32)
    {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (char32 &gt;= SUPPLEMENTARY_MIN_VALUE) {</span>
<span class="nc" id="L349">            return (char)(LEAD_SURROGATE_OFFSET_ +</span>
                          (char32 &gt;&gt; LEAD_SURROGATE_SHIFT_));
        }

<span class="nc" id="L353">        return 0;</span>
    }

    /**
     * Returns the trail surrogate.
     * If a validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;isLegal()&lt;/a&gt;&lt;/code&gt;
     * on char32 before calling.
     * @param char32 the input character.
     * @return the trail surrogate if the getCharCount(ch) is 2; &lt;br&gt;otherwise
     *         the character itself
     * @stable ICU 2.1
     */
    public static char getTrailSurrogate(int char32)
    {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (char32 &gt;= SUPPLEMENTARY_MIN_VALUE) {</span>
<span class="nc" id="L369">            return (char)(TRAIL_SURROGATE_MIN_VALUE +</span>
                          (char32 &amp; TRAIL_SURROGATE_MASK_));
        }

<span class="nc" id="L373">        return (char)char32;</span>
    }

    /**
     * Convenience method corresponding to String.valueOf(char). Returns a one
     * or two char string containing the UTF-32 value in UTF16 format. If a
     * validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;isLegal()&lt;/a&gt;&lt;/code&gt;
     * on char32 before calling.
     * @param char32 the input character.
     * @return string value of char32 in UTF16 format
     * @exception IllegalArgumentException thrown if char32 is a invalid
     *            codepoint.
     * @stable ICU 2.1
     */
    public static String valueOf(int char32)
    {
<span class="nc bnc" id="L390" title="All 4 branches missed.">        if (char32 &lt; CODEPOINT_MIN_VALUE || char32 &gt; CODEPOINT_MAX_VALUE) {</span>
<span class="nc" id="L391">            throw new IllegalArgumentException(&quot;Illegal codepoint&quot;);</span>
        }
<span class="nc" id="L393">        return toString(char32);</span>
    }

    /**
     * Append a single UTF-32 value to the end of a StringBuffer.
     * If a validity check is required, use
     * &lt;code&gt;&lt;a href=&quot;../lang/UCharacter.html#isLegal(char)&quot;&gt;isLegal()&lt;/a&gt;&lt;/code&gt;
     * on char32 before calling.
     * @param target the buffer to append to
     * @param char32 value to append.
     * @return the updated StringBuffer
     * @exception IllegalArgumentException thrown when char32 does not lie
     *            within the range of the Unicode codepoints
     * @stable ICU 2.1
     */
    public static StringBuffer append(StringBuffer target, int char32)
    {
        // Check for irregular values
<span class="nc bnc" id="L411" title="All 4 branches missed.">        if (char32 &lt; CODEPOINT_MIN_VALUE || char32 &gt; CODEPOINT_MAX_VALUE) {</span>
<span class="nc" id="L412">            throw new IllegalArgumentException(&quot;Illegal codepoint: &quot; + Integer.toHexString(char32));</span>
        }

        // Write the UTF-16 values
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (char32 &gt;= SUPPLEMENTARY_MIN_VALUE)</span>
            {
<span class="nc" id="L418">                target.append(getLeadSurrogate(char32));</span>
<span class="nc" id="L419">                target.append(getTrailSurrogate(char32));</span>
            }
        else {
<span class="nc" id="L422">            target.append((char)char32);</span>
        }
<span class="nc" id="L424">        return target;</span>
    }

    //// for StringPrep
    /**
     * Shifts offset16 by the argument number of codepoints within a subarray.
     * @param source char array
     * @param start position of the subarray to be performed on
     * @param limit position of the subarray to be performed on
     * @param offset16 UTF16 position to shift relative to start
     * @param shift32 number of codepoints to shift
     * @return new shifted offset16 relative to start
     * @exception IndexOutOfBoundsException if the new offset16 is out of
     *            bounds with respect to the subarray or the subarray bounds
     *            are out of range.
     * @stable ICU 2.1
     */
    public static int moveCodePointOffset(char source[], int start, int limit,
                                          int offset16, int shift32)
    {
<span class="nc" id="L444">        int         size = source.length;</span>
        int         count;
        char        ch;
<span class="nc" id="L447">        int         result = offset16 + start;</span>
<span class="nc bnc" id="L448" title="All 4 branches missed.">        if (start&lt;0 || limit&lt;start) {</span>
<span class="nc" id="L449">            throw new StringIndexOutOfBoundsException(start);</span>
        }
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (limit&gt;size) {</span>
<span class="nc" id="L452">            throw new StringIndexOutOfBoundsException(limit);</span>
        }
<span class="nc bnc" id="L454" title="All 4 branches missed.">        if (offset16&lt;0 || result&gt;limit) {</span>
<span class="nc" id="L455">            throw new StringIndexOutOfBoundsException(offset16);</span>
        }
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (shift32 &gt; 0 ) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (shift32 + result &gt; size) {</span>
<span class="nc" id="L459">                throw new StringIndexOutOfBoundsException(result);</span>
            }
<span class="nc" id="L461">            count = shift32;</span>
<span class="nc bnc" id="L462" title="All 4 branches missed.">            while (result &lt; limit &amp;&amp; count &gt; 0)</span>
            {
<span class="nc" id="L464">                ch = source[result];</span>
<span class="nc bnc" id="L465" title="All 4 branches missed.">                if (isLeadSurrogate(ch) &amp;&amp; (result+1 &lt; limit) &amp;&amp;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                        isTrailSurrogate(source[result+1])) {</span>
<span class="nc" id="L467">                    result ++;</span>
                }
<span class="nc" id="L469">                count --;</span>
<span class="nc" id="L470">                result ++;</span>
            }
        } else {
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (result + shift32 &lt; start) {</span>
<span class="nc" id="L474">                throw new StringIndexOutOfBoundsException(result);</span>
            }
<span class="nc bnc" id="L476" title="All 2 branches missed.">            for (count=-shift32; count&gt;0; count--) {</span>
<span class="nc" id="L477">                result--;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                if (result&lt;start) {</span>
<span class="nc" id="L479">                    break;</span>
                }
<span class="nc" id="L481">                ch = source[result];</span>
<span class="nc bnc" id="L482" title="All 6 branches missed.">                if (isTrailSurrogate(ch) &amp;&amp; result&gt;start &amp;&amp; isLeadSurrogate(source[result-1])) {</span>
<span class="nc" id="L483">                    result--;</span>
                }
            }
        }
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (count != 0)  {</span>
<span class="nc" id="L488">            throw new StringIndexOutOfBoundsException(shift32);</span>
        }
<span class="nc" id="L490">        result -= start;</span>
<span class="nc" id="L491">        return result;</span>
    }

    // private data members -------------------------------------------------

    /**
     * Shift value for lead surrogate to form a supplementary character.
     */
    private static final int LEAD_SURROGATE_SHIFT_ = 10;

    /**
     * Mask to retrieve the significant value from a trail surrogate.
     */
    private static final int TRAIL_SURROGATE_MASK_     = 0x3FF;

    /**
     * Value that all lead surrogate starts with
     */
    private static final int LEAD_SURROGATE_OFFSET_ =
        LEAD_SURROGATE_MIN_VALUE -
        (SUPPLEMENTARY_MIN_VALUE
         &gt;&gt; LEAD_SURROGATE_SHIFT_);

    // private methods ------------------------------------------------------

    /**
     * &lt;p&gt;Converts argument code point and returns a String object representing
     * the code point's value in UTF16 format.&lt;/p&gt;
     * &lt;p&gt;This method does not check for the validity of the codepoint, the
     * results are not guaranteed if a invalid codepoint is passed as
     * argument.&lt;/p&gt;
     * &lt;p&gt;The result is a string whose length is 1 for non-supplementary code
     * points, 2 otherwise.&lt;/p&gt;
     * @param ch code point
     * @return string representation of the code point
     */
    private static String toString(int ch)
    {
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (ch &lt; SUPPLEMENTARY_MIN_VALUE) {</span>
<span class="nc" id="L530">            return String.valueOf((char)ch);</span>
        }

<span class="nc" id="L533">        StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L534">        result.append(getLeadSurrogate(ch));</span>
<span class="nc" id="L535">        result.append(getTrailSurrogate(ch));</span>
<span class="nc" id="L536">        return result.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>