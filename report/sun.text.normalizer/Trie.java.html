<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Trie.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.text.normalizer</a> &gt; <span class="el_source">Trie.java</span></div><h1>Trie.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *******************************************************************************
 * (C) Copyright IBM Corp. and others, 1996-2009 - All Rights Reserved         *
 *                                                                             *
 * The original version of this source code and documentation is copyrighted   *
 * and owned by IBM, These materials are provided under terms of a License     *
 * Agreement between IBM and Sun. This technology is protected by multiple     *
 * US and International patents. This notice and attribution to IBM may not    *
 * to removed.                                                                 *
 *******************************************************************************
 */

package sun.text.normalizer;

import java.io.DataInputStream;
import java.io.InputStream;
import java.io.IOException;

/**
 * &lt;p&gt;A trie is a kind of compressed, serializable table of values
 * associated with Unicode code points (0..0x10ffff).&lt;/p&gt;
 * &lt;p&gt;This class defines the basic structure of a trie and provides methods
 * to &lt;b&gt;retrieve the offsets to the actual data&lt;/b&gt;.&lt;/p&gt;
 * &lt;p&gt;Data will be the form of an array of basic types, char or int.&lt;/p&gt;
 * &lt;p&gt;The actual data format will have to be specified by the user in the
 * inner static interface com.ibm.icu.impl.Trie.DataManipulate.&lt;/p&gt;
 * &lt;p&gt;This trie implementation is optimized for getting offset while walking
 * forward through a UTF-16 string.
 * Therefore, the simplest and fastest access macros are the
 * fromLead() and fromOffsetTrail() methods.
 * The fromBMP() method are a little more complicated; they get offsets even
 * for lead surrogate codepoints, while the fromLead() method get special
 * &quot;folded&quot; offsets for lead surrogate code units if there is relevant data
 * associated with them.
 * From such a folded offsets, an offset needs to be extracted to supply
 * to the fromOffsetTrail() methods.
 * To handle such supplementary codepoints, some offset information are kept
 * in the data.&lt;/p&gt;
 * &lt;p&gt;Methods in com.ibm.icu.impl.Trie.DataManipulate are called to retrieve
 * that offset from the folded value for the lead surrogate unit.&lt;/p&gt;
 * &lt;p&gt;For examples of use, see com.ibm.icu.impl.CharTrie or
 * com.ibm.icu.impl.IntTrie.&lt;/p&gt;
 * @author synwee
 * @see com.ibm.icu.impl.CharTrie
 * @see com.ibm.icu.impl.IntTrie
 * @since release 2.1, Jan 01 2002
 */
public abstract class Trie
{
    // public class declaration ----------------------------------------

    /**
    * Character data in com.ibm.impl.Trie have different user-specified format
    * for different purposes.
    * This interface specifies methods to be implemented in order for
    * com.ibm.impl.Trie, to surrogate offset information encapsulated within
    * the data.
    */
    public static interface DataManipulate
    {
        /**
        * Called by com.ibm.icu.impl.Trie to extract from a lead surrogate's
        * data
        * the index array offset of the indexes for that lead surrogate.
        * @param value data value for a surrogate from the trie, including the
        *        folding offset
        * @return data offset or 0 if there is no data for the lead surrogate
        */
        public int getFoldingOffset(int value);
    }

    // default implementation
<span class="nc" id="L97">    private static class DefaultGetFoldingOffset implements DataManipulate {</span>
        public int getFoldingOffset(int value) {
<span class="nc" id="L99">            return value;</span>
        }
    }

    // protected constructor -------------------------------------------

    /**
    * Trie constructor for CharTrie use.
    * @param inputStream ICU data file input stream which contains the
    *                        trie
    * @param dataManipulate object containing the information to parse the
    *                       trie data
    * @throws IOException thrown when input stream does not have the
    *                        right header.
    */
    protected Trie(InputStream inputStream,
                   DataManipulate  dataManipulate) throws IOException
<span class="fc" id="L116">    {</span>
<span class="fc" id="L117">        DataInputStream input = new DataInputStream(inputStream);</span>
        // Magic number to authenticate the data.
<span class="fc" id="L119">        int signature = input.readInt();</span>
<span class="fc" id="L120">        m_options_    = input.readInt();</span>

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if (!checkHeader(signature)) {</span>
<span class="nc" id="L123">            throw new IllegalArgumentException(&quot;ICU data file error: Trie header authentication failed, please check if you have the most updated ICU data file&quot;);</span>
        }

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if(dataManipulate != null) {</span>
<span class="fc" id="L127">            m_dataManipulate_ = dataManipulate;</span>
        } else {
<span class="nc" id="L129">            m_dataManipulate_ = new DefaultGetFoldingOffset();</span>
        }
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        m_isLatin1Linear_ = (m_options_ &amp;</span>
                             HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_) != 0;
<span class="fc" id="L133">        m_dataOffset_     = input.readInt();</span>
<span class="fc" id="L134">        m_dataLength_     = input.readInt();</span>
<span class="fc" id="L135">        unserialize(inputStream);</span>
<span class="fc" id="L136">    }</span>

    /**
    * Trie constructor
    * @param index array to be used for index
    * @param options used by the trie
    * @param dataManipulate object containing the information to parse the
    *                       trie data
    */
    protected Trie(char index[], int options, DataManipulate dataManipulate)
<span class="nc" id="L146">    {</span>
<span class="nc" id="L147">        m_options_ = options;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if(dataManipulate != null) {</span>
<span class="nc" id="L149">            m_dataManipulate_ = dataManipulate;</span>
        } else {
<span class="nc" id="L151">            m_dataManipulate_ = new DefaultGetFoldingOffset();</span>
        }
<span class="nc bnc" id="L153" title="All 2 branches missed.">        m_isLatin1Linear_ = (m_options_ &amp;</span>
                             HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_) != 0;
<span class="nc" id="L155">        m_index_ = index;</span>
<span class="nc" id="L156">        m_dataOffset_ = m_index_.length;</span>
<span class="nc" id="L157">    }</span>

    // protected data members ------------------------------------------

    /**
    * Lead surrogate code points' index displacement in the index array.
    * 0x10000-0xd800=0x2800
    * 0x2800 &gt;&gt; INDEX_STAGE_1_SHIFT_
    */
    protected static final int LEAD_INDEX_OFFSET_ = 0x2800 &gt;&gt; 5;
    /**
    * Shift size for shifting right the input index. 1..9
    */
    protected static final int INDEX_STAGE_1_SHIFT_ = 5;
    /**
    * Shift size for shifting left the index array values.
    * Increases possible data size with 16-bit index values at the cost
    * of compactability.
    * This requires blocks of stage 2 data to be aligned by
    * DATA_GRANULARITY.
    * 0..INDEX_STAGE_1_SHIFT
    */
    protected static final int INDEX_STAGE_2_SHIFT_ = 2;
    /**
     * Number of data values in a stage 2 (data array) block.
     */
    protected static final int DATA_BLOCK_LENGTH=1&lt;&lt;INDEX_STAGE_1_SHIFT_;
    /**
    * Mask for getting the lower bits from the input index.
    * DATA_BLOCK_LENGTH - 1.
    */
    protected static final int INDEX_STAGE_3_MASK_ = DATA_BLOCK_LENGTH - 1;
    /** Number of bits of a trail surrogate that are used in index table lookups. */
    protected static final int SURROGATE_BLOCK_BITS=10-INDEX_STAGE_1_SHIFT_;
    /**
     * Number of index (stage 1) entries per lead surrogate.
     * Same as number of index entries for 1024 trail surrogates,
     * ==0x400&gt;&gt;INDEX_STAGE_1_SHIFT_
     */
    protected static final int SURROGATE_BLOCK_COUNT=(1&lt;&lt;SURROGATE_BLOCK_BITS);
    /** Length of the BMP portion of the index (stage 1) array. */
    protected static final int BMP_INDEX_LENGTH=0x10000&gt;&gt;INDEX_STAGE_1_SHIFT_;
    /**
    * Surrogate mask to use when shifting offset to retrieve supplementary
    * values
    */
    protected static final int SURROGATE_MASK_ = 0x3FF;
    /**
    * Index or UTF16 characters
    */
    protected char m_index_[];
    /**
    * Internal TrieValue which handles the parsing of the data value.
    * This class is to be implemented by the user
    */
    protected DataManipulate m_dataManipulate_;
    /**
    * Start index of the data portion of the trie. CharTrie combines
    * index and data into a char array, so this is used to indicate the
    * initial offset to the data portion.
    * Note this index always points to the initial value.
    */
    protected int m_dataOffset_;
    /**
    * Length of the data array
    */
    protected int m_dataLength_;

    // protected methods -----------------------------------------------

    /**
    * Gets the offset to the data which the surrogate pair points to.
    * @param lead lead surrogate
    * @param trail trailing surrogate
    * @return offset to data
    */
    protected abstract int getSurrogateOffset(char lead, char trail);

    /**
    * Gets the value at the argument index
    * @param index value at index will be retrieved
    * @return 32 bit value
    */
    protected abstract int getValue(int index);

    /**
    * Gets the default initial value
    * @return 32 bit value
    */
    protected abstract int getInitialValue();

    /**
    * Gets the offset to the data which the index ch after variable offset
    * points to.
    * Note for locating a non-supplementary character data offset, calling
    * &lt;p&gt;
    * getRawOffset(0, ch);
    * &lt;/p&gt;
    * will do. Otherwise if it is a supplementary character formed by
    * surrogates lead and trail. Then we would have to call getRawOffset()
    * with getFoldingIndexOffset(). See getSurrogateOffset().
    * @param offset index offset which ch is to start from
    * @param ch index to be used after offset
    * @return offset to the data
    */
    protected final int getRawOffset(int offset, char ch)
    {
<span class="nc" id="L264">        return (m_index_[offset + (ch &gt;&gt; INDEX_STAGE_1_SHIFT_)]</span>
                &lt;&lt; INDEX_STAGE_2_SHIFT_)
                + (ch &amp; INDEX_STAGE_3_MASK_);
    }

    /**
    * Gets the offset to data which the BMP character points to
    * Treats a lead surrogate as a normal code point.
    * @param ch BMP character
    * @return offset to data
    */
    protected final int getBMPOffset(char ch)
    {
<span class="nc bnc" id="L277" title="All 4 branches missed.">        return (ch &gt;= UTF16.LEAD_SURROGATE_MIN_VALUE</span>
                &amp;&amp; ch &lt;= UTF16.LEAD_SURROGATE_MAX_VALUE)
<span class="nc" id="L279">                ? getRawOffset(LEAD_INDEX_OFFSET_, ch)</span>
<span class="nc" id="L280">                : getRawOffset(0, ch);</span>
                // using a getRawOffset(ch) makes no diff
    }

    /**
    * Gets the offset to the data which this lead surrogate character points
    * to.
    * Data at the returned offset may contain folding offset information for
    * the next trailing surrogate character.
    * @param ch lead surrogate character
    * @return offset to data
    */
    protected final int getLeadOffset(char ch)
    {
<span class="nc" id="L294">       return getRawOffset(0, ch);</span>
    }

    /**
    * Internal trie getter from a code point.
    * Could be faster(?) but longer with
    *   if((c32)&lt;=0xd7ff) { (result)=_TRIE_GET_RAW(trie, data, 0, c32); }
    * Gets the offset to data which the codepoint points to
    * @param ch codepoint
    * @return offset to data
    */
    protected final int getCodePointOffset(int ch)
    {
        // if ((ch &gt;&gt; 16) == 0) slower
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (ch &lt; 0) {</span>
<span class="nc" id="L309">            return -1;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        } else if (ch &lt; UTF16.LEAD_SURROGATE_MIN_VALUE) {</span>
            // fastpath for the part of the BMP below surrogates (D800) where getRawOffset() works
<span class="nc" id="L312">            return getRawOffset(0, (char)ch);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        } else if (ch &lt; UTF16.SUPPLEMENTARY_MIN_VALUE) {</span>
            // BMP codepoint
<span class="nc" id="L315">            return getBMPOffset((char)ch);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        } else if (ch &lt;= UCharacter.MAX_VALUE) {</span>
            // look at the construction of supplementary characters
            // trail forms the ends of it.
<span class="nc" id="L319">            return getSurrogateOffset(UTF16.getLeadSurrogate(ch),</span>
                                      (char)(ch &amp; SURROGATE_MASK_));
        } else {
            // return -1 // if there is an error, in this case we return
<span class="nc" id="L323">            return -1;</span>
        }
    }

    /**
    * &lt;p&gt;Parses the inputstream and creates the trie index with it.&lt;/p&gt;
    * &lt;p&gt;This is overwritten by the child classes.
    * @param inputStream input stream containing the trie information
    * @exception IOException thrown when data reading fails.
    */
    protected void unserialize(InputStream inputStream) throws IOException
    {
        //indexLength is a multiple of 1024 &gt;&gt; INDEX_STAGE_2_SHIFT_
<span class="nc" id="L336">        m_index_              = new char[m_dataOffset_];</span>
<span class="nc" id="L337">        DataInputStream input = new DataInputStream(inputStream);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        for (int i = 0; i &lt; m_dataOffset_; i ++) {</span>
<span class="nc" id="L339">             m_index_[i] = input.readChar();</span>
        }
<span class="nc" id="L341">    }</span>

    /**
    * Determines if this is a 32 bit trie
    * @return true if options specifies this is a 32 bit trie
    */
    protected final boolean isIntTrie()
    {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        return (m_options_ &amp; HEADER_OPTIONS_DATA_IS_32_BIT_) != 0;</span>
    }

    /**
    * Determines if this is a 16 bit trie
    * @return true if this is a 16 bit trie
    */
    protected final boolean isCharTrie()
    {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        return (m_options_ &amp; HEADER_OPTIONS_DATA_IS_32_BIT_) == 0;</span>
    }

    // private data members --------------------------------------------

    /**
    * Latin 1 option mask
    */
    protected static final int HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_ = 0x200;
    /**
    * Constant number to authenticate the byte block
    */
    protected static final int HEADER_SIGNATURE_ = 0x54726965;
    /**
    * Header option formatting
    */
    private static final int HEADER_OPTIONS_SHIFT_MASK_ = 0xF;
    protected static final int HEADER_OPTIONS_INDEX_SHIFT_ = 4;
    protected static final int HEADER_OPTIONS_DATA_IS_32_BIT_ = 0x100;

    /**
    * Flag indicator for Latin quick access data block
    */
    private boolean m_isLatin1Linear_;

    /**
    * &lt;p&gt;Trie options field.&lt;/p&gt;
    * &lt;p&gt;options bit field:&lt;br&gt;
    * 9  1 = Latin-1 data is stored linearly at data + DATA_BLOCK_LENGTH&lt;br&gt;
    * 8  0 = 16-bit data, 1=32-bit data&lt;br&gt;
    * 7..4  INDEX_STAGE_1_SHIFT   // 0..INDEX_STAGE_2_SHIFT&lt;br&gt;
    * 3..0  INDEX_STAGE_2_SHIFT   // 1..9&lt;br&gt;
    */
    private int m_options_;

    // private methods ---------------------------------------------------

    /**
    * Authenticates raw data header.
    * Checking the header information, signature and options.
    * @param signature This contains the options and type of a Trie
    * @return true if the header is authenticated valid
    */
    private final boolean checkHeader(int signature)
    {
        // check the signature
        // Trie in big-endian US-ASCII (0x54726965).
        // Magic number to authenticate the data.
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (signature != HEADER_SIGNATURE_) {</span>
<span class="nc" id="L407">            return false;</span>
        }

<span class="pc bpc" id="L410" title="2 of 4 branches missed.">        if ((m_options_ &amp; HEADER_OPTIONS_SHIFT_MASK_) !=</span>
                                                    INDEX_STAGE_1_SHIFT_ ||
            ((m_options_ &gt;&gt; HEADER_OPTIONS_INDEX_SHIFT_) &amp;
                                                HEADER_OPTIONS_SHIFT_MASK_)
                                                 != INDEX_STAGE_2_SHIFT_) {
<span class="nc" id="L415">            return false;</span>
        }
<span class="fc" id="L417">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>