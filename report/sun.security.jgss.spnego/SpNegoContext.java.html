<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SpNegoContext.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.jgss.spnego</a> &gt; <span class="el_source">SpNegoContext.java</span></div><h1>SpNegoContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss.spnego;

import com.sun.security.jgss.ExtendedGSSContext;
import com.sun.security.jgss.InquireType;
import java.io.*;
import java.security.Provider;
import org.ietf.jgss.*;
import sun.security.jgss.*;
import sun.security.jgss.spi.*;
import sun.security.util.*;

/**
 * Implements the mechanism specific context class for SPNEGO
 * GSS-API mechanism
 *
 * @author Seema Malkani
 * @since 1.6
 */
public class SpNegoContext implements GSSContextSpi {

    /*
     * The different states that this context can be in.
     */
    private static final int STATE_NEW = 1;
    private static final int STATE_IN_PROCESS = 2;
    private static final int STATE_DONE = 3;
    private static final int STATE_DELETED = 4;

<span class="nc" id="L54">    private int state = STATE_NEW;</span>

    /*
     * Optional features that the application can set and their default
     * values.
     */
<span class="nc" id="L60">    private boolean credDelegState = false;</span>
<span class="nc" id="L61">    private boolean mutualAuthState = true;</span>
<span class="nc" id="L62">    private boolean replayDetState = true;</span>
<span class="nc" id="L63">    private boolean sequenceDetState = true;</span>
<span class="nc" id="L64">    private boolean confState = true;</span>
<span class="nc" id="L65">    private boolean integState = true;</span>
<span class="nc" id="L66">    private boolean delegPolicyState = false;</span>

<span class="nc" id="L68">    private GSSNameSpi peerName = null;</span>
<span class="nc" id="L69">    private GSSNameSpi myName = null;</span>
<span class="nc" id="L70">    private SpNegoCredElement myCred = null;</span>

<span class="nc" id="L72">    private GSSContext mechContext = null;</span>
<span class="nc" id="L73">    private byte[] DER_mechTypes = null;</span>

    private int lifetime;
    private ChannelBinding channelBinding;
    private boolean initiator;

    // the underlying negotiated mechanism
<span class="nc" id="L80">    private Oid internal_mech = null;</span>

    // the SpNegoMechFactory that creates this context
    final private SpNegoMechFactory factory;

    // debug property
<span class="nc" id="L86">    static final boolean DEBUG =</span>
<span class="nc" id="L87">        java.security.AccessController.doPrivileged(</span>
            new sun.security.action.GetBooleanAction
<span class="nc" id="L89">            (&quot;sun.security.spnego.debug&quot;)).booleanValue();</span>

    /**
     * Constructor for SpNegoContext to be called on the context initiator's
     * side.
     */
    public SpNegoContext(SpNegoMechFactory factory, GSSNameSpi peerName,
                        GSSCredentialSpi myCred,
<span class="nc" id="L97">                        int lifetime) throws GSSException {</span>

<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (peerName == null)</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;Cannot have null peer name&quot;);</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">        if ((myCred != null) &amp;&amp; !(myCred instanceof SpNegoCredElement)) {</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;Wrong cred element type&quot;);</span>
        }
<span class="nc" id="L104">        this.peerName = peerName;</span>
<span class="nc" id="L105">        this.myCred = (SpNegoCredElement) myCred;</span>
<span class="nc" id="L106">        this.lifetime = lifetime;</span>
<span class="nc" id="L107">        this.initiator = true;</span>
<span class="nc" id="L108">        this.factory = factory;</span>
<span class="nc" id="L109">    }</span>

    /**
     * Constructor for SpNegoContext to be called on the context acceptor's
     * side.
     */
    public SpNegoContext(SpNegoMechFactory factory, GSSCredentialSpi myCred)
<span class="nc" id="L116">            throws GSSException {</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if ((myCred != null) &amp;&amp; !(myCred instanceof SpNegoCredElement)) {</span>
<span class="nc" id="L118">            throw new IllegalArgumentException(&quot;Wrong cred element type&quot;);</span>
        }
<span class="nc" id="L120">        this.myCred = (SpNegoCredElement) myCred;</span>
<span class="nc" id="L121">        this.initiator = false;</span>
<span class="nc" id="L122">        this.factory = factory;</span>
<span class="nc" id="L123">    }</span>

    /**
     * Constructor for SpNegoContext to import a previously exported context.
     */
    public SpNegoContext(SpNegoMechFactory factory, byte [] interProcessToken)
<span class="nc" id="L129">        throws GSSException {</span>
<span class="nc" id="L130">        throw new GSSException(GSSException.UNAVAILABLE,</span>
                               -1, &quot;GSS Import Context not available&quot;);
    }

    /**
     * Requests that confidentiality be available.
     */
    public final void requestConf(boolean value) throws GSSException {
<span class="nc bnc" id="L138" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L139">            confState  = value;</span>
<span class="nc" id="L140">    }</span>

    /**
     * Is confidentiality available?
     */
    public final boolean getConfState() {
<span class="nc" id="L146">        return confState;</span>
    }

    /**
     * Requests that integrity be available.
     */
    public final void requestInteg(boolean value) throws GSSException {
<span class="nc bnc" id="L153" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L154">            integState  = value;</span>
<span class="nc" id="L155">    }</span>

    /**
     * Requests that deleg policy be respected.
     */
    public final void requestDelegPolicy(boolean value) throws GSSException {
<span class="nc bnc" id="L161" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L162">            delegPolicyState = value;</span>
<span class="nc" id="L163">    }</span>

    /**
     * Is integrity available?
     */
    public final boolean getIntegState() {
<span class="nc" id="L169">        return integState;</span>
    }

    /**
     * Is deleg policy respected?
     */
    public final boolean getDelegPolicyState() {
<span class="nc bnc" id="L176" title="All 10 branches missed.">        if (isInitiator() &amp;&amp; mechContext != null &amp;&amp;</span>
                mechContext instanceof ExtendedGSSContext &amp;&amp;
                (state == STATE_IN_PROCESS || state == STATE_DONE)) {
<span class="nc" id="L179">            return ((ExtendedGSSContext)mechContext).getDelegPolicyState();</span>
        } else {
<span class="nc" id="L181">            return delegPolicyState;</span>
        }
    }

    /**
     * Requests that credential delegation be done during context
     * establishment.
     */
    public final void requestCredDeleg(boolean value) throws GSSException {
<span class="nc bnc" id="L190" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L191">            credDelegState  = value;</span>
<span class="nc" id="L192">    }</span>

    /**
     * Is credential delegation enabled?
     */
    public final boolean getCredDelegState() {
<span class="nc bnc" id="L198" title="All 8 branches missed.">        if (isInitiator() &amp;&amp; mechContext != null &amp;&amp;</span>
                (state == STATE_IN_PROCESS || state == STATE_DONE)) {
<span class="nc" id="L200">            return mechContext.getCredDelegState();</span>
        } else {
<span class="nc" id="L202">            return credDelegState;</span>
        }
    }

    /**
     * Requests that mutual authentication be done during context
     * establishment. Since this is fromm the client's perspective, it
     * essentially requests that the server be authenticated.
     */
    public final void requestMutualAuth(boolean value) throws GSSException {
<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator()) {</span>
<span class="nc" id="L213">            mutualAuthState  = value;</span>
        }
<span class="nc" id="L215">    }</span>

    /**
     * Is mutual authentication enabled? Since this is from the client's
     * perspective, it essentially meas that the server is being
     * authenticated.
     */
    public final boolean getMutualAuthState() {
<span class="nc" id="L223">        return mutualAuthState;</span>
    }

    /**
     * Returns the mechanism oid.
     *
     * @return the Oid of this context
     */
    public final Oid getMech() {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (isEstablished()) {</span>
<span class="nc" id="L233">            return getNegotiatedMech();</span>
        }
<span class="nc" id="L235">        return (SpNegoMechFactory.GSS_SPNEGO_MECH_OID);</span>
    }

    public final Oid getNegotiatedMech() {
<span class="nc" id="L239">        return (internal_mech);</span>
    }

    public final Provider getProvider() {
<span class="nc" id="L243">        return SpNegoMechFactory.PROVIDER;</span>
    }

    public final void dispose() throws GSSException {
<span class="nc" id="L247">        mechContext = null;</span>
<span class="nc" id="L248">        state = STATE_DELETED;</span>
<span class="nc" id="L249">    }</span>

    /**
     * Tests if this is the initiator side of the context.
     *
     * @return boolean indicating if this is initiator (true)
     *  or target (false)
     */
    public final boolean isInitiator() {
<span class="nc" id="L258">        return initiator;</span>
    }

    /**
     * Tests if the context can be used for per-message service.
     * Context may allow the calls to the per-message service
     * functions before being fully established.
     *
     * @return boolean indicating if per-message methods can
     *  be called.
     */
    public final boolean isProtReady() {
<span class="nc bnc" id="L270" title="All 2 branches missed.">        return (state == STATE_DONE);</span>
    }

    /**
     * Initiator context establishment call. This method may be
     * required to be called several times. A CONTINUE_NEEDED return
     * call indicates that more calls are needed after the next token
     * is received from the peer.
     *
     * @param is contains the token received from the peer. On the
     *        first call it will be ignored.
     * @return any token required to be sent to the peer
     * It is responsibility of the caller to send the token
     * to its peer for processing.
     * @exception GSSException
     */
    public final byte[] initSecContext(InputStream is, int mechTokenSize)
        throws GSSException {

<span class="nc" id="L289">        byte[] retVal = null;</span>
<span class="nc" id="L290">        NegTokenInit initToken = null;</span>
<span class="nc" id="L291">        byte[] mechToken = null;</span>
<span class="nc" id="L292">        int errorCode = GSSException.FAILURE;</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L295">            System.out.println(&quot;Entered SpNego.initSecContext with &quot; +</span>
<span class="nc" id="L296">                                &quot;state=&quot; + printState(state));</span>
        }
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (!isInitiator()) {</span>
<span class="nc" id="L299">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;initSecContext on an acceptor GSSContext&quot;);
        }

        try {
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (state == STATE_NEW) {</span>
<span class="nc" id="L305">                state = STATE_IN_PROCESS;</span>

<span class="nc" id="L307">                errorCode = GSSException.NO_CRED;</span>

                // determine available mech set
<span class="nc" id="L310">                Oid[] mechList = getAvailableMechs();</span>
<span class="nc" id="L311">                DER_mechTypes = getEncodedMechs(mechList);</span>

                // pull out first mechanism
<span class="nc" id="L314">                internal_mech = mechList[0];</span>

                // get the token for first mechanism
<span class="nc" id="L317">                mechToken = GSS_initSecContext(null);</span>

<span class="nc" id="L319">                errorCode = GSSException.DEFECTIVE_TOKEN;</span>
                // generate SPNEGO token
<span class="nc" id="L321">                initToken = new NegTokenInit(DER_mechTypes, getContextFlags(),</span>
                                        mechToken, null);
<span class="nc bnc" id="L323" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L324">                    System.out.println(&quot;SpNegoContext.initSecContext: &quot; +</span>
                                &quot;sending token of type = &quot; +
<span class="nc" id="L326">                                SpNegoToken.getTokenName(initToken.getType()));</span>
                }
                // get the encoded token
<span class="nc" id="L329">                retVal = initToken.getEncoded();</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">            } else if (state == STATE_IN_PROCESS) {</span>

<span class="nc" id="L333">                errorCode = GSSException.FAILURE;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (is == null) {</span>
<span class="nc" id="L335">                    throw new GSSException(errorCode, -1,</span>
                                &quot;No token received from peer!&quot;);
                }

<span class="nc" id="L339">                errorCode = GSSException.DEFECTIVE_TOKEN;</span>
<span class="nc" id="L340">                byte[] server_token = new byte[is.available()];</span>
<span class="nc" id="L341">                SpNegoToken.readFully(is, server_token);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L343">                    System.out.println(&quot;SpNegoContext.initSecContext: &quot; +</span>
                                        &quot;process received token = &quot; +
<span class="nc" id="L345">                                        SpNegoToken.getHexBytes(server_token));</span>
                }

                // read the SPNEGO token
                // token will be validated when parsing
<span class="nc" id="L350">                NegTokenTarg targToken = new NegTokenTarg(server_token);</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L353">                    System.out.println(&quot;SpNegoContext.initSecContext: &quot; +</span>
                                &quot;received token of type = &quot; +
<span class="nc" id="L355">                                SpNegoToken.getTokenName(targToken.getType()));</span>
                }

                // pull out mechanism
<span class="nc" id="L359">                internal_mech = targToken.getSupportedMech();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (internal_mech == null) {</span>
                    // return wth failure
<span class="nc" id="L362">                    throw new GSSException(errorCode, -1,</span>
                                &quot;supported mechanism from server is null&quot;);
                }

                // get the negotiated result
<span class="nc" id="L367">                SpNegoToken.NegoResult negoResult = null;</span>
<span class="nc" id="L368">                int result = targToken.getNegotiatedResult();</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">                switch (result) {</span>
                    case 0:
<span class="nc" id="L371">                        negoResult = SpNegoToken.NegoResult.ACCEPT_COMPLETE;</span>
<span class="nc" id="L372">                        state = STATE_DONE;</span>
<span class="nc" id="L373">                        break;</span>
                    case 1:
<span class="nc" id="L375">                        negoResult = SpNegoToken.NegoResult.ACCEPT_INCOMPLETE;</span>
<span class="nc" id="L376">                        state = STATE_IN_PROCESS;</span>
<span class="nc" id="L377">                        break;</span>
                    case 2:
<span class="nc" id="L379">                        negoResult = SpNegoToken.NegoResult.REJECT;</span>
<span class="nc" id="L380">                        state = STATE_DELETED;</span>
<span class="nc" id="L381">                        break;</span>
                    default:
<span class="nc" id="L383">                        state = STATE_DONE;</span>
                        break;
                }

<span class="nc" id="L387">                errorCode = GSSException.BAD_MECH;</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (negoResult == SpNegoToken.NegoResult.REJECT) {</span>
<span class="nc" id="L390">                    throw new GSSException(errorCode, -1,</span>
<span class="nc" id="L391">                                        internal_mech.toString());</span>
                }

<span class="nc" id="L394">                errorCode = GSSException.DEFECTIVE_TOKEN;</span>

<span class="nc bnc" id="L396" title="All 4 branches missed.">                if ((negoResult == SpNegoToken.NegoResult.ACCEPT_COMPLETE) ||</span>
                    (negoResult == SpNegoToken.NegoResult.ACCEPT_INCOMPLETE)) {

                    // pull out the mechanism token
<span class="nc" id="L400">                    byte[] accept_token = targToken.getResponseToken();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                    if (accept_token == null) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                        if (!isMechContextEstablished()) {</span>
                            // return with failure
<span class="nc" id="L404">                            throw new GSSException(errorCode, -1,</span>
                                    &quot;mechanism token from server is null&quot;);
                        }
                    } else {
<span class="nc" id="L408">                        mechToken = GSS_initSecContext(accept_token);</span>
                    }
                    // verify MIC
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    if (!GSSUtil.useMSInterop()) {</span>
<span class="nc" id="L412">                        byte[] micToken = targToken.getMechListMIC();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                        if (!verifyMechListMIC(DER_mechTypes, micToken)) {</span>
<span class="nc" id="L414">                            throw new GSSException(errorCode, -1,</span>
                                &quot;verification of MIC on MechList Failed!&quot;);
                        }
                    }
<span class="nc bnc" id="L418" title="All 2 branches missed.">                    if (isMechContextEstablished()) {</span>
<span class="nc" id="L419">                        state = STATE_DONE;</span>
<span class="nc" id="L420">                        retVal = mechToken;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                        if (DEBUG) {</span>
<span class="nc" id="L422">                            System.out.println(&quot;SPNEGO Negotiated Mechanism = &quot;</span>
                                + internal_mech + &quot; &quot; +
<span class="nc" id="L424">                                GSSUtil.getMechStr(internal_mech));</span>
                        }
                    } else {
                        // generate SPNEGO token
<span class="nc" id="L428">                        initToken = new NegTokenInit(null, null,</span>
                                                mechToken, null);
<span class="nc bnc" id="L430" title="All 2 branches missed.">                        if (DEBUG) {</span>
<span class="nc" id="L431">                            System.out.println(&quot;SpNegoContext.initSecContext:&quot; +</span>
                                &quot; continue sending token of type = &quot; +
<span class="nc" id="L433">                                SpNegoToken.getTokenName(initToken.getType()));</span>
                        }
                        // get the encoded token
<span class="nc" id="L436">                        retVal = initToken.getEncoded();</span>
                    }
                }

<span class="nc" id="L440">            } else {</span>
                // XXX Use logging API
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L443">                    System.out.println(state);</span>
                }
            }
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (retVal != null) {</span>
<span class="nc" id="L448">                    System.out.println(&quot;SNegoContext.initSecContext: &quot; +</span>
<span class="nc" id="L449">                        &quot;sending token = &quot; + SpNegoToken.getHexBytes(retVal));</span>
                }
            }
<span class="nc" id="L452">        } catch (GSSException e) {</span>
<span class="nc" id="L453">            GSSException gssException =</span>
<span class="nc" id="L454">                        new GSSException(errorCode, -1, e.getMessage());</span>
<span class="nc" id="L455">            gssException.initCause(e);</span>
<span class="nc" id="L456">            throw gssException;</span>
<span class="nc" id="L457">        } catch (IOException e) {</span>
<span class="nc" id="L458">            GSSException gssException =</span>
<span class="nc" id="L459">                new GSSException(GSSException.FAILURE, -1, e.getMessage());</span>
<span class="nc" id="L460">            gssException.initCause(e);</span>
<span class="nc" id="L461">            throw gssException;</span>
<span class="nc" id="L462">        }</span>

<span class="nc" id="L464">        return retVal;</span>
    }


    /**
     * Acceptor's context establishment call. This method may be
     * required to be called several times. A CONTINUE_NEEDED return
     * call indicates that more calls are needed after the next token
     * is received from the peer.
     *
     * @param is contains the token received from the peer.
     * @return any token required to be sent to the peer
     * It is responsibility of the caller to send the token
     * to its peer for processing.
     * @exception GSSException
     */
    public final byte[] acceptSecContext(InputStream is, int mechTokenSize)
        throws GSSException {

<span class="nc" id="L483">        byte[] retVal = null;</span>
        SpNegoToken.NegoResult negoResult;
<span class="nc" id="L485">        boolean valid = true;</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L488">            System.out.println(&quot;Entered SpNegoContext.acceptSecContext with &quot; +</span>
<span class="nc" id="L489">                               &quot;state=&quot; +  printState(state));</span>
        }

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (isInitiator()) {</span>
<span class="nc" id="L493">            throw new GSSException(GSSException.FAILURE, -1,</span>
                                   &quot;acceptSecContext on an initiator &quot; +
                                   &quot;GSSContext&quot;);
        }
        try {
<span class="nc bnc" id="L498" title="All 2 branches missed.">            if (state == STATE_NEW) {</span>
<span class="nc" id="L499">                state = STATE_IN_PROCESS;</span>

                // read data
<span class="nc" id="L502">                byte[] token = new byte[is.available()];</span>
<span class="nc" id="L503">                SpNegoToken.readFully(is, token);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L505">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                        &quot;receiving token = &quot; +
<span class="nc" id="L507">                                        SpNegoToken.getHexBytes(token));</span>
                }

                // read the SPNEGO token
                // token will be validated when parsing
<span class="nc" id="L512">                NegTokenInit initToken = new NegTokenInit(token);</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L515">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                &quot;received token of type = &quot; +
<span class="nc" id="L517">                                SpNegoToken.getTokenName(initToken.getType()));</span>
                }

<span class="nc" id="L520">                Oid[] mechList = initToken.getMechTypeList();</span>
<span class="nc" id="L521">                DER_mechTypes = initToken.getMechTypes();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (DER_mechTypes == null) {</span>
<span class="nc" id="L523">                    valid = false;</span>
                }

                // get the mechanism token
<span class="nc" id="L527">                byte[] mechToken = initToken.getMechToken();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if (mechToken == null) {</span>
<span class="nc" id="L529">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                            &quot;mechToken is missing&quot;);
                }

                /*
                 * Select the best match between the list of mechs
                 * that the initiator requested and the list that
                 * the acceptor will support.
                 */
<span class="nc" id="L538">                Oid[] supported_mechSet = getAvailableMechs();</span>
<span class="nc" id="L539">                Oid mech_wanted =</span>
<span class="nc" id="L540">                        negotiate_mech_type(supported_mechSet, mechList);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (mech_wanted == null) {</span>
<span class="nc" id="L542">                    valid = false;</span>
                }
                // save the desired mechanism
<span class="nc" id="L545">                internal_mech = mech_wanted;</span>

                // get the token for mechanism
<span class="nc" id="L548">                byte[] accept_token = GSS_acceptSecContext(mechToken);</span>

                // verify MIC
<span class="nc bnc" id="L551" title="All 4 branches missed.">                if (!GSSUtil.useMSInterop() &amp;&amp; valid) {</span>
<span class="nc" id="L552">                    valid = verifyMechListMIC(DER_mechTypes,</span>
<span class="nc" id="L553">                                                initToken.getMechListMIC());</span>
                }

                // determine negotiated result status
<span class="nc bnc" id="L557" title="All 2 branches missed.">                if (valid) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                    if (isMechContextEstablished()) {</span>
<span class="nc" id="L559">                        negoResult = SpNegoToken.NegoResult.ACCEPT_COMPLETE;</span>
<span class="nc" id="L560">                        state = STATE_DONE;</span>
                        // now set the context flags for acceptor
<span class="nc" id="L562">                        setContextFlags();</span>
                        // print the negotiated mech info
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if (DEBUG) {</span>
<span class="nc" id="L565">                            System.out.println(&quot;SPNEGO Negotiated Mechanism = &quot;</span>
                                + internal_mech + &quot; &quot; +
<span class="nc" id="L567">                                GSSUtil.getMechStr(internal_mech));</span>
                        }
                    } else {
<span class="nc" id="L570">                        negoResult = SpNegoToken.NegoResult.ACCEPT_INCOMPLETE;</span>
<span class="nc" id="L571">                        state = STATE_IN_PROCESS;</span>
                    }
                } else {
<span class="nc" id="L574">                    negoResult = SpNegoToken.NegoResult.REJECT;</span>
<span class="nc" id="L575">                    state = STATE_DONE;</span>
                }

<span class="nc bnc" id="L578" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L579">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                &quot;mechanism wanted = &quot; + mech_wanted);
<span class="nc" id="L581">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                &quot;negotiated result = &quot; + negoResult);
                }

                // generate SPNEGO token
<span class="nc" id="L586">                NegTokenTarg targToken = new NegTokenTarg(negoResult.ordinal(),</span>
                                mech_wanted, accept_token, null);
<span class="nc bnc" id="L588" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L589">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                &quot;sending token of type = &quot; +
<span class="nc" id="L591">                                SpNegoToken.getTokenName(targToken.getType()));</span>
                }
                // get the encoded token
<span class="nc" id="L594">                retVal = targToken.getEncoded();</span>

<span class="nc bnc" id="L596" title="All 2 branches missed.">            } else if (state == STATE_IN_PROCESS) {</span>
                // read the token
<span class="nc" id="L598">                byte[] client_token = new byte[is.available()];</span>
<span class="nc" id="L599">                SpNegoToken.readFully(is, client_token);</span>
<span class="nc" id="L600">                byte[] accept_token = GSS_acceptSecContext(client_token);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                if (accept_token == null) {</span>
<span class="nc" id="L602">                    valid = false;</span>
                }

                // determine negotiated result status
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (valid) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                    if (isMechContextEstablished()) {</span>
<span class="nc" id="L608">                        negoResult = SpNegoToken.NegoResult.ACCEPT_COMPLETE;</span>
<span class="nc" id="L609">                        state = STATE_DONE;</span>
                    } else {
<span class="nc" id="L611">                        negoResult = SpNegoToken.NegoResult.ACCEPT_INCOMPLETE;</span>
<span class="nc" id="L612">                        state = STATE_IN_PROCESS;</span>
                    }
                } else {
<span class="nc" id="L615">                    negoResult = SpNegoToken.NegoResult.REJECT;</span>
<span class="nc" id="L616">                    state = STATE_DONE;</span>
                }

                // generate SPNEGO token
<span class="nc" id="L620">                NegTokenTarg targToken = new NegTokenTarg(negoResult.ordinal(),</span>
                                null, accept_token, null);
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L623">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
                                &quot;sending token of type = &quot; +
<span class="nc" id="L625">                                SpNegoToken.getTokenName(targToken.getType()));</span>
                }
                // get the encoded token
<span class="nc" id="L628">                retVal = targToken.getEncoded();</span>

<span class="nc" id="L630">            } else {</span>
                // XXX Use logging API
<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L633">                    System.out.println(&quot;AcceptSecContext: state = &quot; + state);</span>
                }
            }
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L637">                    System.out.println(&quot;SpNegoContext.acceptSecContext: &quot; +</span>
<span class="nc" id="L638">                        &quot;sending token = &quot; + SpNegoToken.getHexBytes(retVal));</span>
            }
<span class="nc" id="L640">        } catch (IOException e) {</span>
<span class="nc" id="L641">            GSSException gssException =</span>
<span class="nc" id="L642">                new GSSException(GSSException.FAILURE, -1, e.getMessage());</span>
<span class="nc" id="L643">            gssException.initCause(e);</span>
<span class="nc" id="L644">            throw gssException;</span>
<span class="nc" id="L645">        }</span>

<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (state == STATE_DONE) {</span>
            // now set the context flags for acceptor
<span class="nc" id="L649">            setContextFlags();</span>
        }
<span class="nc" id="L651">        return retVal;</span>
    }

    /**
     * obtain the available mechanisms
     */
    private Oid[] getAvailableMechs() {
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (myCred != null) {</span>
<span class="nc" id="L659">            Oid[] mechs = new Oid[1];</span>
<span class="nc" id="L660">            mechs[0] = myCred.getInternalMech();</span>
<span class="nc" id="L661">            return mechs;</span>
        } else {
<span class="nc" id="L663">            return factory.availableMechs;</span>
        }
    }

    /**
     * get ther DER encoded MechList
     */
    private byte[] getEncodedMechs(Oid[] mechSet)
        throws IOException, GSSException {

<span class="nc" id="L673">        DerOutputStream mech = new DerOutputStream();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">        for (int i = 0; i &lt; mechSet.length; i++) {</span>
<span class="nc" id="L675">            byte[] mechType = mechSet[i].getDER();</span>
<span class="nc" id="L676">            mech.write(mechType);</span>
        }
        // insert in SEQUENCE
<span class="nc" id="L679">        DerOutputStream mechTypeList = new DerOutputStream();</span>
<span class="nc" id="L680">        mechTypeList.write(DerValue.tag_Sequence, mech);</span>
<span class="nc" id="L681">        byte[] encoded = mechTypeList.toByteArray();</span>
<span class="nc" id="L682">        return encoded;</span>
    }

    /**
     * get the context flags
     */
    private BitArray getContextFlags() {
<span class="nc" id="L689">        BitArray out = new BitArray(7);</span>

<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (getCredDelegState()) out.set(0, true);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (getMutualAuthState()) out.set(1, true);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (getReplayDetState()) out.set(2, true);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (getSequenceDetState()) out.set(3, true);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (getConfState()) out.set(5, true);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (getIntegState()) out.set(6, true);</span>

<span class="nc" id="L698">        return out;</span>
    }

    // Only called on acceptor side. On the initiator side, most flags
    // are already set at request. For those that might get chanegd,
    // state from mech below is used.
    private void setContextFlags() {

<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (mechContext != null) {</span>
            // default for cred delegation is false
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (mechContext.getCredDelegState()) {</span>
<span class="nc" id="L709">                credDelegState = true;</span>
            }
            // default for the following are true
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (!mechContext.getMutualAuthState()) {</span>
<span class="nc" id="L713">                mutualAuthState = false;</span>
            }
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (!mechContext.getReplayDetState()) {</span>
<span class="nc" id="L716">                replayDetState = false;</span>
            }
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (!mechContext.getSequenceDetState()) {</span>
<span class="nc" id="L719">                sequenceDetState = false;</span>
            }
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (!mechContext.getIntegState()) {</span>
<span class="nc" id="L722">                integState = false;</span>
            }
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (!mechContext.getConfState()) {</span>
<span class="nc" id="L725">                confState = false;</span>
            }
        }
<span class="nc" id="L728">    }</span>

    /**
     * generate MIC on mechList. Not used at the moment.
     */
    /*private byte[] generateMechListMIC(byte[] mechTypes)
        throws GSSException {

        // sanity check the required input
        if (mechTypes == null) {
            if (DEBUG) {
                System.out.println(&quot;SpNegoContext: no MIC token included&quot;);
            }
            return null;
        }

        // check if mechanism supports integrity
        if (!mechContext.getIntegState()) {
            if (DEBUG) {
                System.out.println(&quot;SpNegoContext: no MIC token included&quot; +
                        &quot; - mechanism does not support integrity&quot;);
            }
            return null;
        }

        // compute MIC on DER encoded mechanism list
        byte[] mic = null;
        try {
            MessageProp prop = new MessageProp(0, true);
            mic = getMIC(mechTypes, 0, mechTypes.length, prop);
            if (DEBUG) {
                System.out.println(&quot;SpNegoContext: getMIC = &quot; +
                                        SpNegoToken.getHexBytes(mic));
            }
        } catch (GSSException e) {
            mic = null;
            if (DEBUG) {
                System.out.println(&quot;SpNegoContext: no MIC token included&quot; +
                        &quot; - getMIC failed : &quot; + e.getMessage());
            }
        }
        return mic;
    }*/

    /**
     * verify MIC on MechList
     */
    private boolean verifyMechListMIC(byte[] mechTypes, byte[] token)
        throws GSSException {

        // sanity check the input
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (token == null) {</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L781">                System.out.println(&quot;SpNegoContext: no MIC token validation&quot;);</span>
            }
<span class="nc" id="L783">            return true;</span>
        }

        // check if mechanism supports integrity
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (!mechContext.getIntegState()) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L789">                System.out.println(&quot;SpNegoContext: no MIC token validation&quot; +</span>
                        &quot; - mechanism does not support integrity&quot;);
            }
<span class="nc" id="L792">            return true;</span>
        }

        // now verify the token
<span class="nc" id="L796">        boolean valid = false;</span>
        try {
<span class="nc" id="L798">            MessageProp prop = new MessageProp(0, true);</span>
<span class="nc" id="L799">            verifyMIC(token, 0, token.length, mechTypes,</span>
                        0, mechTypes.length, prop);
<span class="nc" id="L801">            valid = true;</span>
<span class="nc" id="L802">        } catch (GSSException e) {</span>
<span class="nc" id="L803">            valid = false;</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L805">                System.out.println(&quot;SpNegoContext: MIC validation failed! &quot; +</span>
<span class="nc" id="L806">                                        e.getMessage());</span>
            }
<span class="nc" id="L808">        }</span>
<span class="nc" id="L809">        return valid;</span>
    }

    /**
     * call gss_init_sec_context for the corresponding underlying mechanism
     */
    private byte[] GSS_initSecContext(byte[] token) throws GSSException {
<span class="nc" id="L816">        byte[] tok = null;</span>

<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (mechContext == null) {</span>
            // initialize mech context
<span class="nc" id="L820">            GSSName serverName =</span>
<span class="nc" id="L821">                factory.manager.createName(peerName.toString(),</span>
<span class="nc" id="L822">                    peerName.getStringNameType(), internal_mech);</span>
<span class="nc" id="L823">            GSSCredential cred = null;</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (myCred != null) {</span>
                // create context with provided credential
<span class="nc" id="L826">                cred = new GSSCredentialImpl(factory.manager,</span>
<span class="nc" id="L827">                    myCred.getInternalCred());</span>
            }
<span class="nc" id="L829">            mechContext =</span>
<span class="nc" id="L830">                factory.manager.createContext(serverName,</span>
                    internal_mech, cred, GSSContext.DEFAULT_LIFETIME);
<span class="nc" id="L832">            mechContext.requestConf(confState);</span>
<span class="nc" id="L833">            mechContext.requestInteg(integState);</span>
<span class="nc" id="L834">            mechContext.requestCredDeleg(credDelegState);</span>
<span class="nc" id="L835">            mechContext.requestMutualAuth(mutualAuthState);</span>
<span class="nc" id="L836">            mechContext.requestReplayDet(replayDetState);</span>
<span class="nc" id="L837">            mechContext.requestSequenceDet(sequenceDetState);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (mechContext instanceof ExtendedGSSContext) {</span>
<span class="nc" id="L839">                ((ExtendedGSSContext)mechContext).requestDelegPolicy(</span>
                        delegPolicyState);
            }
        }

        // pass token
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (token != null) {</span>
<span class="nc" id="L846">            tok = token;</span>
        } else {
<span class="nc" id="L848">            tok = new byte[0];</span>
        }

        // pass token to mechanism initSecContext
<span class="nc" id="L852">        byte[] init_token = mechContext.initSecContext(tok, 0, tok.length);</span>

<span class="nc" id="L854">        return init_token;</span>
    }

    /**
     * call gss_accept_sec_context for the corresponding underlying mechanism
     */
    private byte[] GSS_acceptSecContext(byte[] token) throws GSSException {

<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (mechContext == null) {</span>
            // initialize mech context
<span class="nc" id="L864">            GSSCredential cred = null;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (myCred != null) {</span>
                // create context with provided credential
<span class="nc" id="L867">                cred = new GSSCredentialImpl(factory.manager,</span>
<span class="nc" id="L868">                myCred.getInternalCred());</span>
            }
<span class="nc" id="L870">            mechContext =</span>
<span class="nc" id="L871">                factory.manager.createContext(cred);</span>
        }

        // pass token to mechanism acceptSecContext
<span class="nc" id="L875">        byte[] accept_token =</span>
<span class="nc" id="L876">                mechContext.acceptSecContext(token, 0, token.length);</span>

<span class="nc" id="L878">        return accept_token;</span>
    }

    /**
     * This routine compares the recieved mechset to the mechset that
     * this server can support. It looks sequentially through the mechset
     * and the first one that matches what the server can support is
     * chosen as the negotiated mechanism. If one is found, negResult
     * is set to ACCEPT_COMPLETE, otherwise we return NULL and negResult
     * is set to REJECT.
     */
    private static Oid negotiate_mech_type(Oid[] supported_mechSet,
                                        Oid[] mechSet) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">        for (int i = 0; i &lt; supported_mechSet.length; i++) {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            for (int j = 0; j &lt; mechSet.length; j++) {</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                if (mechSet[j].equals(supported_mechSet[i])) {</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                    if (DEBUG) {</span>
<span class="nc" id="L895">                        System.out.println(&quot;SpNegoContext: &quot; +</span>
                                &quot;negotiated mechanism = &quot; + mechSet[j]);
                    }
<span class="nc" id="L898">                    return (mechSet[j]);</span>
                }
            }
        }
<span class="nc" id="L902">        return null;</span>
    }

    public final boolean isEstablished() {
<span class="nc bnc" id="L906" title="All 2 branches missed.">        return (state == STATE_DONE);</span>
    }

    public final boolean isMechContextEstablished() {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L911">            return mechContext.isEstablished();</span>
        } else {
<span class="nc bnc" id="L913" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L914">                System.out.println(&quot;The underlying mechanism context has &quot; +</span>
                                        &quot;not been initialized&quot;);
            }
<span class="nc" id="L917">            return false;</span>
        }
    }

    public final byte [] export() throws GSSException {
<span class="nc" id="L922">        throw new GSSException(GSSException.UNAVAILABLE, -1,</span>
                               &quot;GSS Export Context not available&quot;);
    }

    /**
     * Sets the channel bindings to be used during context
     * establishment.
     */
    public final void setChannelBinding(ChannelBinding channelBinding)
        throws GSSException {
<span class="nc" id="L932">        this.channelBinding = channelBinding;</span>
<span class="nc" id="L933">    }</span>

    final ChannelBinding getChannelBinding() {
<span class="nc" id="L936">        return channelBinding;</span>
    }

    /*
     * Anonymity is a little different in that after an application
     * requests anonymity it will want to know whether the mechanism
     * can support it or not, prior to sending any tokens across for
     * context establishment. Since this is from the initiator's
     * perspective, it essentially requests that the initiator be
     * anonymous.
     */
    public final void requestAnonymity(boolean value) throws GSSException {
        // Ignore silently. Application will check back with
        // getAnonymityState.
<span class="nc" id="L950">    }</span>

    // RFC 2853 actually calls for this to be called after context
    // establishment to get the right answer, but that is
    // incorrect. The application may not want to send over any
    // tokens if anonymity is not available.
    public final boolean getAnonymityState() {
<span class="nc" id="L957">        return false;</span>
    }

    /**
     * Requests the desired lifetime. Can only be used on the context
     * initiator's side.
     */
    public void requestLifetime(int lifetime) throws GSSException {
<span class="nc bnc" id="L965" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L966">            this.lifetime = lifetime;</span>
<span class="nc" id="L967">    }</span>

    /**
     * The lifetime remaining for this context.
     */
    public final int getLifetime() {
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L974">            return mechContext.getLifetime();</span>
        } else {
<span class="nc" id="L976">            return GSSContext.INDEFINITE_LIFETIME;</span>
        }
    }

    public final boolean isTransferable() throws GSSException {
<span class="nc" id="L981">        return false;</span>
    }

    /**
     * Requests that sequence checking be done on the GSS wrap and MIC
     * tokens.
     */
    public final void requestSequenceDet(boolean value) throws GSSException {
<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L990">            sequenceDetState  = value;</span>
<span class="nc" id="L991">    }</span>

    /**
     * Is sequence checking enabled on the GSS Wrap and MIC tokens?
     * We enable sequence checking if replay detection is enabled.
     */
    public final boolean getSequenceDetState() {
<span class="nc bnc" id="L998" title="All 4 branches missed.">        return sequenceDetState || replayDetState;</span>
    }

    /**
     * Requests that replay detection be done on the GSS wrap and MIC
     * tokens.
     */
    public final void requestReplayDet(boolean value) throws GSSException {
<span class="nc bnc" id="L1006" title="All 4 branches missed.">        if (state == STATE_NEW &amp;&amp; isInitiator())</span>
<span class="nc" id="L1007">            replayDetState  = value;</span>
<span class="nc" id="L1008">    }</span>

    /**
     * Is replay detection enabled on the GSS wrap and MIC tokens?
     * We enable replay detection if sequence checking is enabled.
     */
    public final boolean getReplayDetState() {
<span class="nc bnc" id="L1015" title="All 4 branches missed.">        return replayDetState || sequenceDetState;</span>
    }

    public final GSSNameSpi getTargName() throws GSSException {
        // fill-in the GSSName
        // get the peer name for the mechanism
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1022">            GSSNameImpl targName = (GSSNameImpl)mechContext.getTargName();</span>
<span class="nc" id="L1023">            peerName = targName.getElement(internal_mech);</span>
<span class="nc" id="L1024">            return peerName;</span>
        } else {
<span class="nc bnc" id="L1026" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1027">                System.out.println(&quot;The underlying mechanism context has &quot; +</span>
                                        &quot;not been initialized&quot;);
            }
<span class="nc" id="L1030">            return null;</span>
        }
    }

    public final GSSNameSpi getSrcName() throws GSSException {
        // fill-in the GSSName
        // get the src name for the mechanism
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1038">            GSSNameImpl srcName = (GSSNameImpl)mechContext.getSrcName();</span>
<span class="nc" id="L1039">            myName = srcName.getElement(internal_mech);</span>
<span class="nc" id="L1040">            return myName;</span>
        } else {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1043">                System.out.println(&quot;The underlying mechanism context has &quot; +</span>
                                        &quot;not been initialized&quot;);
            }
<span class="nc" id="L1046">            return null;</span>
        }
    }

    /**
     * Returns the delegated credential for the context. This
     * is an optional feature of contexts which not all
     * mechanisms will support. A context can be requested to
     * support credential delegation by using the &lt;b&gt;CRED_DELEG&lt;/b&gt;.
     * This is only valid on the acceptor side of the context.
     * @return GSSCredentialSpi object for the delegated credential
     * @exception GSSException
     * @see GSSContext#getDelegCredState
     */
    public final GSSCredentialSpi getDelegCred() throws GSSException {
<span class="nc bnc" id="L1061" title="All 4 branches missed.">        if (state != STATE_IN_PROCESS &amp;&amp; state != STATE_DONE)</span>
<span class="nc" id="L1062">            throw new GSSException(GSSException.NO_CONTEXT);</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1064">            GSSCredentialImpl delegCred =</span>
<span class="nc" id="L1065">                        (GSSCredentialImpl)mechContext.getDelegCred();</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">            if (delegCred == null) {</span>
<span class="nc" id="L1067">                return null;</span>
            }
            // determine delegated cred element usage
<span class="nc" id="L1070">            boolean initiate = false;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            if (delegCred.getUsage() == GSSCredential.INITIATE_ONLY) {</span>
<span class="nc" id="L1072">                initiate = true;</span>
            }
<span class="nc" id="L1074">            GSSCredentialSpi mechCred =</span>
<span class="nc" id="L1075">                    delegCred.getElement(internal_mech, initiate);</span>
<span class="nc" id="L1076">            SpNegoCredElement cred = new SpNegoCredElement(mechCred);</span>
<span class="nc" id="L1077">            return cred.getInternalCred();</span>
        } else {
<span class="nc" id="L1079">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;getDelegCred called in invalid state!&quot;);
        }
    }

    public final int getWrapSizeLimit(int qop, boolean confReq,
                                       int maxTokSize) throws GSSException {
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1087">            return mechContext.getWrapSizeLimit(qop, confReq, maxTokSize);</span>
        } else {
<span class="nc" id="L1089">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;getWrapSizeLimit called in invalid state!&quot;);
        }
    }

    public final byte[] wrap(byte inBuf[], int offset, int len,
                             MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1097">            return mechContext.wrap(inBuf, offset, len, msgProp);</span>
        } else {
<span class="nc" id="L1099">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;Wrap called in invalid state!&quot;);
        }
    }

    public final void wrap(InputStream is, OutputStream os,
                            MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1107">            mechContext.wrap(is, os, msgProp);</span>
        } else {
<span class="nc" id="L1109">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;Wrap called in invalid state!&quot;);
        }
<span class="nc" id="L1112">    }</span>

    public final byte[] unwrap(byte inBuf[], int offset, int len,
                               MessageProp msgProp)
        throws GSSException {
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1118">            return mechContext.unwrap(inBuf, offset, len, msgProp);</span>
        } else {
<span class="nc" id="L1120">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;UnWrap called in invalid state!&quot;);
        }
    }

    public final void unwrap(InputStream is, OutputStream os,
                             MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1128">            mechContext.unwrap(is, os, msgProp);</span>
        } else {
<span class="nc" id="L1130">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;UnWrap called in invalid state!&quot;);
        }
<span class="nc" id="L1133">    }</span>

    public final byte[] getMIC(byte []inMsg, int offset, int len,
                               MessageProp msgProp)
        throws GSSException {
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1139">            return mechContext.getMIC(inMsg, offset, len, msgProp);</span>
        } else {
<span class="nc" id="L1141">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;getMIC called in invalid state!&quot;);
        }
    }

    public final void getMIC(InputStream is, OutputStream os,
                              MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1149">            mechContext.getMIC(is, os, msgProp);</span>
        } else {
<span class="nc" id="L1151">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;getMIC called in invalid state!&quot;);
        }
<span class="nc" id="L1154">    }</span>

    public final void verifyMIC(byte []inTok, int tokOffset, int tokLen,
                                byte[] inMsg, int msgOffset, int msgLen,
                                MessageProp msgProp)
        throws GSSException {
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1161">            mechContext.verifyMIC(inTok, tokOffset, tokLen, inMsg, msgOffset,</span>
                                msgLen,  msgProp);
        } else {
<span class="nc" id="L1164">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;verifyMIC called in invalid state!&quot;);
        }
<span class="nc" id="L1167">    }</span>

    public final void verifyMIC(InputStream is, InputStream msgStr,
                                 MessageProp msgProp) throws GSSException {
<span class="nc bnc" id="L1171" title="All 2 branches missed.">        if (mechContext != null) {</span>
<span class="nc" id="L1172">            mechContext.verifyMIC(is, msgStr, msgProp);</span>
        } else {
<span class="nc" id="L1174">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                                &quot;verifyMIC called in invalid state!&quot;);
        }
<span class="nc" id="L1177">    }</span>

    private static String printState(int state) {
<span class="nc bnc" id="L1180" title="All 5 branches missed.">        switch (state) {</span>
          case STATE_NEW:
<span class="nc" id="L1182">                return (&quot;STATE_NEW&quot;);</span>
          case STATE_IN_PROCESS:
<span class="nc" id="L1184">                return (&quot;STATE_IN_PROCESS&quot;);</span>
          case STATE_DONE:
<span class="nc" id="L1186">                return (&quot;STATE_DONE&quot;);</span>
          case STATE_DELETED:
<span class="nc" id="L1188">                return (&quot;STATE_DELETED&quot;);</span>
          default:
<span class="nc" id="L1190">                return (&quot;Unknown state &quot; + state);</span>
        }
    }

    /**
     * Retrieve attribute of the context for {@code type}.
     */
    public Object inquireSecContext(InquireType type)
            throws GSSException {
<span class="nc bnc" id="L1199" title="All 2 branches missed.">        if (mechContext == null) {</span>
<span class="nc" id="L1200">            throw new GSSException(GSSException.NO_CONTEXT, -1,</span>
                    &quot;Underlying mech not established.&quot;);
        }
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (mechContext instanceof ExtendedGSSContext) {</span>
<span class="nc" id="L1204">            return ((ExtendedGSSContext)mechContext).inquireSecContext(type);</span>
        } else {
<span class="nc" id="L1206">            throw new GSSException(GSSException.BAD_MECH, -1,</span>
                    &quot;inquireSecContext not supported by underlying mech.&quot;);
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>