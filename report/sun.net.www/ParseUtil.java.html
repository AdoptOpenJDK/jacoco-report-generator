<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ParseUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www</a> &gt; <span class="el_source">ParseUtil.java</span></div><h1>ParseUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www;

import java.util.BitSet;
import java.io.UnsupportedEncodingException;
import java.io.File;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import sun.nio.cs.ThreadLocalCoders;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;

/**
 * A class that contains useful routines common to sun.net.www
 * @author  Mike McCloskey
 */

<span class="fc bfc" id="L48" title="All 2 branches covered.">public class ParseUtil {</span>
    static BitSet encodedInPath;

    static {
<span class="fc" id="L52">        encodedInPath = new BitSet(256);</span>

        // Set the bits corresponding to characters that are encoded in the
        // path component of a URI.

        // These characters are reserved in the path segment as described in
        // RFC2396 section 3.3.
<span class="fc" id="L59">        encodedInPath.set('=');</span>
<span class="fc" id="L60">        encodedInPath.set(';');</span>
<span class="fc" id="L61">        encodedInPath.set('?');</span>
<span class="fc" id="L62">        encodedInPath.set('/');</span>

        // These characters are defined as excluded in RFC2396 section 2.4.3
        // and must be escaped if they occur in the data part of a URI.
<span class="fc" id="L66">        encodedInPath.set('#');</span>
<span class="fc" id="L67">        encodedInPath.set(' ');</span>
<span class="fc" id="L68">        encodedInPath.set('&lt;');</span>
<span class="fc" id="L69">        encodedInPath.set('&gt;');</span>
<span class="fc" id="L70">        encodedInPath.set('%');</span>
<span class="fc" id="L71">        encodedInPath.set('&quot;');</span>
<span class="fc" id="L72">        encodedInPath.set('{');</span>
<span class="fc" id="L73">        encodedInPath.set('}');</span>
<span class="fc" id="L74">        encodedInPath.set('|');</span>
<span class="fc" id="L75">        encodedInPath.set('\\');</span>
<span class="fc" id="L76">        encodedInPath.set('^');</span>
<span class="fc" id="L77">        encodedInPath.set('[');</span>
<span class="fc" id="L78">        encodedInPath.set(']');</span>
<span class="fc" id="L79">        encodedInPath.set('`');</span>

        // US ASCII control characters 00-1F and 7F.
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i=0; i&lt;32; i++)</span>
<span class="fc" id="L83">            encodedInPath.set(i);</span>
<span class="fc" id="L84">        encodedInPath.set(127);</span>
    }

    /**
     * Constructs an encoded version of the specified path string suitable
     * for use in the construction of a URL.
     *
     * A path separator is replaced by a forward slash. The string is UTF8
     * encoded. The % escape sequence is used for characters that are above
     * 0x7F or those defined in RFC2396 as reserved or excluded in the path
     * component of a URL.
     */
    public static String encodePath(String path) {
<span class="fc" id="L97">        return encodePath(path, true);</span>
    }
    /*
     * flag indicates whether path uses platform dependent
     * File.separatorChar or not. True indicates path uses platform
     * dependent File.separatorChar.
     */
    public static String encodePath(String path, boolean flag) {
<span class="fc" id="L105">        char[] retCC = new char[path.length() * 2 + 16];</span>
<span class="fc" id="L106">        int    retLen = 0;</span>
<span class="fc" id="L107">        char[] pathCC = path.toCharArray();</span>

<span class="fc" id="L109">        int n = path.length();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (int i=0; i&lt;n; i++) {</span>
<span class="fc" id="L111">            char c = pathCC[i];</span>
<span class="fc bfc" id="L112" title="All 8 branches covered.">            if ((!flag &amp;&amp; c == '/') || (flag &amp;&amp; c == File.separatorChar))</span>
<span class="fc" id="L113">                retCC[retLen++] = '/';</span>
            else {
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (c &lt;= 0x007F) {</span>
<span class="fc bfc" id="L116" title="All 12 branches covered.">                    if (c &gt;= 'a' &amp;&amp; c &lt;= 'z' ||</span>
                        c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ||
                        c &gt;= '0' &amp;&amp; c &lt;= '9') {
<span class="fc" id="L119">                        retCC[retLen++] = c;</span>
                    } else
<span class="fc bfc" id="L121" title="All 2 branches covered.">                    if (encodedInPath.get(c))</span>
<span class="fc" id="L122">                        retLen = escape(retCC, c, retLen);</span>
                    else
<span class="fc" id="L124">                        retCC[retLen++] = c;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                } else if (c &gt; 0x07FF) {</span>
<span class="fc" id="L126">                    retLen = escape(retCC, (char)(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F)), retLen);</span>
<span class="fc" id="L127">                    retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  6) &amp; 0x3F)), retLen);</span>
<span class="fc" id="L128">                    retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);</span>
                } else {
<span class="fc" id="L130">                    retLen = escape(retCC, (char)(0xC0 | ((c &gt;&gt;  6) &amp; 0x1F)), retLen);</span>
<span class="fc" id="L131">                    retLen = escape(retCC, (char)(0x80 | ((c &gt;&gt;  0) &amp; 0x3F)), retLen);</span>
                }
            }
            //worst case scenario for character [0x7ff-] every single
            //character will be encoded into 9 characters.
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (retLen + 9 &gt; retCC.length) {</span>
<span class="fc" id="L137">                int newLen = retCC.length * 2 + 16;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">                if (newLen &lt; 0) {</span>
<span class="nc" id="L139">                    newLen = Integer.MAX_VALUE;</span>
                }
<span class="fc" id="L141">                char[] buf = new char[newLen];</span>
<span class="fc" id="L142">                System.arraycopy(retCC, 0, buf, 0, retLen);</span>
<span class="fc" id="L143">                retCC = buf;</span>
            }
        }
<span class="fc" id="L146">        return new String(retCC, 0, retLen);</span>
    }

    /**
     * Appends the URL escape sequence for the specified char to the
     * specified StringBuffer.
     */
    private static int escape(char[] cc, char c, int index) {
<span class="fc" id="L154">        cc[index++] = '%';</span>
<span class="fc" id="L155">        cc[index++] = Character.forDigit((c &gt;&gt; 4) &amp; 0xF, 16);</span>
<span class="fc" id="L156">        cc[index++] = Character.forDigit(c &amp; 0xF, 16);</span>
<span class="fc" id="L157">        return index;</span>
    }

    /**
     * Un-escape and return the character at position i in string s.
     */
    private static byte unescape(String s, int i) {
<span class="fc" id="L164">        return (byte) Integer.parseInt(s.substring(i+1,i+3),16);</span>
    }


    /**
     * Returns a new String constructed from the specified String by replacing
     * the URL escape sequences and UTF8 encoding with the characters they
     * represent.
     */
    public static String decode(String s) {
<span class="fc" id="L174">        int n = s.length();</span>
<span class="fc bfc" id="L175" title="All 4 branches covered.">        if ((n == 0) || (s.indexOf('%') &lt; 0))</span>
<span class="fc" id="L176">            return s;</span>

<span class="fc" id="L178">        StringBuilder sb = new StringBuilder(n);</span>
<span class="fc" id="L179">        ByteBuffer bb = ByteBuffer.allocate(n);</span>
<span class="fc" id="L180">        CharBuffer cb = CharBuffer.allocate(n);</span>
<span class="fc" id="L181">        CharsetDecoder dec = ThreadLocalCoders.decoderFor(&quot;UTF-8&quot;)</span>
<span class="fc" id="L182">            .onMalformedInput(CodingErrorAction.REPORT)</span>
<span class="fc" id="L183">            .onUnmappableCharacter(CodingErrorAction.REPORT);</span>

<span class="fc" id="L185">        char c = s.charAt(0);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        for (int i = 0; i &lt; n;) {</span>
<span class="pc bpc" id="L187" title="1 of 4 branches missed.">            assert c == s.charAt(i);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            if (c != '%') {</span>
<span class="fc" id="L189">                sb.append(c);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (++i &gt;= n)</span>
<span class="fc" id="L191">                    break;</span>
<span class="fc" id="L192">                c = s.charAt(i);</span>
<span class="fc" id="L193">                continue;</span>
            }
<span class="fc" id="L195">            bb.clear();</span>
<span class="fc" id="L196">            int ui = i;</span>
            for (;;) {
<span class="pc bpc" id="L198" title="1 of 4 branches missed.">                assert (n - i &gt;= 2);</span>
                try {
<span class="fc" id="L200">                    bb.put(unescape(s, i));</span>
<span class="nc" id="L201">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L202">                    throw new IllegalArgumentException();</span>
<span class="fc" id="L203">                }</span>
<span class="fc" id="L204">                i += 3;</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                if (i &gt;= n)</span>
<span class="nc" id="L206">                    break;</span>
<span class="fc" id="L207">                c = s.charAt(i);</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                if (c != '%')</span>
<span class="fc" id="L209">                    break;</span>
            }
<span class="fc" id="L211">            bb.flip();</span>
<span class="fc" id="L212">            cb.clear();</span>
<span class="fc" id="L213">            dec.reset();</span>
<span class="fc" id="L214">            CoderResult cr = dec.decode(bb, cb, true);</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (cr.isError())</span>
<span class="nc" id="L216">                throw new IllegalArgumentException(&quot;Error decoding percent encoded characters&quot;);</span>
<span class="fc" id="L217">            cr = dec.flush(cb);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            if (cr.isError())</span>
<span class="nc" id="L219">                throw new IllegalArgumentException(&quot;Error decoding percent encoded characters&quot;);</span>
<span class="fc" id="L220">            sb.append(cb.flip().toString());</span>
<span class="fc" id="L221">        }</span>

<span class="fc" id="L223">        return sb.toString();</span>
    }

    /**
     * Returns a canonical version of the specified string.
     */
    public String canonizeString(String file) {
<span class="fc" id="L230">        int i = 0;</span>
<span class="fc" id="L231">        int lim = file.length();</span>

        // Remove embedded /../
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        while ((i = file.indexOf(&quot;/../&quot;)) &gt;= 0) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if ((lim = file.lastIndexOf('/', i - 1)) &gt;= 0) {</span>
<span class="nc" id="L236">                file = file.substring(0, lim) + file.substring(i + 3);</span>
            } else {
<span class="nc" id="L238">                file = file.substring(i + 3);</span>
            }
        }
        // Remove embedded /./
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        while ((i = file.indexOf(&quot;/./&quot;)) &gt;= 0) {</span>
<span class="nc" id="L243">            file = file.substring(0, i) + file.substring(i + 2);</span>
        }
        // Remove trailing ..
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        while (file.endsWith(&quot;/..&quot;)) {</span>
<span class="nc" id="L247">            i = file.indexOf(&quot;/..&quot;);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if ((lim = file.lastIndexOf('/', i - 1)) &gt;= 0) {</span>
<span class="nc" id="L249">                file = file.substring(0, lim+1);</span>
            } else {
<span class="nc" id="L251">                file = file.substring(0, i);</span>
            }
        }
        // Remove trailing .
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (file.endsWith(&quot;/.&quot;))</span>
<span class="nc" id="L256">            file = file.substring(0, file.length() -1);</span>

<span class="fc" id="L258">        return file;</span>
    }

    public static URL fileToEncodedURL(File file)
        throws MalformedURLException
    {
<span class="fc" id="L264">        String path = file.getAbsolutePath();</span>
<span class="fc" id="L265">        path = ParseUtil.encodePath(path);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (!path.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L267">            path = &quot;/&quot; + path;</span>
        }
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">        if (!path.endsWith(&quot;/&quot;) &amp;&amp; file.isDirectory()) {</span>
<span class="fc" id="L270">            path = path + &quot;/&quot;;</span>
        }
<span class="fc" id="L272">        return new URL(&quot;file&quot;, &quot;&quot;, path);</span>
    }

    public static java.net.URI toURI(URL url) {
<span class="fc" id="L276">        String protocol = url.getProtocol();</span>
<span class="fc" id="L277">        String auth = url.getAuthority();</span>
<span class="fc" id="L278">        String path = url.getPath();</span>
<span class="fc" id="L279">        String query = url.getQuery();</span>
<span class="fc" id="L280">        String ref = url.getRef();</span>
<span class="pc bpc" id="L281" title="1 of 4 branches missed.">        if (path != null &amp;&amp; !(path.startsWith(&quot;/&quot;)))</span>
<span class="fc" id="L282">            path = &quot;/&quot; + path;</span>

        //
        // In java.net.URI class, a port number of -1 implies the default
        // port number. So get it stripped off before creating URI instance.
        //
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">        if (auth != null &amp;&amp; auth.endsWith(&quot;:-1&quot;))</span>
<span class="fc" id="L289">            auth = auth.substring(0, auth.length() - 3);</span>

        java.net.URI uri;
        try {
<span class="fc" id="L293">            uri = createURI(protocol, auth, path, query, ref);</span>
<span class="nc" id="L294">        } catch (java.net.URISyntaxException e) {</span>
<span class="nc" id="L295">            uri = null;</span>
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">        return uri;</span>
    }

    //
    // createURI() and its auxiliary code are cloned from java.net.URI.
    // Most of the code are just copy and paste, except that quote()
    // has been modified to avoid double-escape.
    //
    // Usually it is unacceptable, but we're forced to do it because
    // otherwise we need to change public API, namely java.net.URI's
    // multi-argument constructors. It turns out that the changes cause
    // incompatibilities so can't be done.
    //
    private static URI createURI(String scheme,
                                 String authority,
                                 String path,
                                 String query,
                                 String fragment) throws URISyntaxException
    {
<span class="fc" id="L316">        String s = toString(scheme, null,</span>
                            authority, null, null, -1,
                            path, query, fragment);
<span class="fc" id="L319">        checkPath(s, scheme, path);</span>
<span class="fc" id="L320">        return new URI(s);</span>
    }

    private static String toString(String scheme,
                            String opaquePart,
                            String authority,
                            String userInfo,
                            String host,
                            int port,
                            String path,
                            String query,
                            String fragment)
    {
<span class="fc" id="L333">        StringBuffer sb = new StringBuffer();</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (scheme != null) {</span>
<span class="fc" id="L335">            sb.append(scheme);</span>
<span class="fc" id="L336">            sb.append(':');</span>
        }
<span class="fc" id="L338">        appendSchemeSpecificPart(sb, opaquePart,</span>
                                 authority, userInfo, host, port,
                                 path, query);
<span class="fc" id="L341">        appendFragment(sb, fragment);</span>
<span class="fc" id="L342">        return sb.toString();</span>
    }

    private static void appendSchemeSpecificPart(StringBuffer sb,
                                          String opaquePart,
                                          String authority,
                                          String userInfo,
                                          String host,
                                          int port,
                                          String path,
                                          String query)
    {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (opaquePart != null) {</span>
            /* check if SSP begins with an IPv6 address
             * because we must not quote a literal IPv6 address
             */
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (opaquePart.startsWith(&quot;//[&quot;)) {</span>
<span class="nc" id="L359">                int end =  opaquePart.indexOf(&quot;]&quot;);</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">                if (end != -1 &amp;&amp; opaquePart.indexOf(&quot;:&quot;)!=-1) {</span>
                    String doquote, dontquote;
<span class="nc bnc" id="L362" title="All 2 branches missed.">                    if (end == opaquePart.length()) {</span>
<span class="nc" id="L363">                        dontquote = opaquePart;</span>
<span class="nc" id="L364">                        doquote = &quot;&quot;;</span>
                    } else {
<span class="nc" id="L366">                        dontquote = opaquePart.substring(0,end+1);</span>
<span class="nc" id="L367">                        doquote = opaquePart.substring(end+1);</span>
                    }
<span class="nc" id="L369">                    sb.append (dontquote);</span>
<span class="nc" id="L370">                    sb.append(quote(doquote, L_URIC, H_URIC));</span>
                }
<span class="nc" id="L372">            } else {</span>
<span class="nc" id="L373">                sb.append(quote(opaquePart, L_URIC, H_URIC));</span>
            }
        } else {
<span class="fc" id="L376">            appendAuthority(sb, authority, userInfo, host, port);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (path != null)</span>
<span class="fc" id="L378">                sb.append(quote(path, L_PATH, H_PATH));</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (query != null) {</span>
<span class="nc" id="L380">                sb.append('?');</span>
<span class="nc" id="L381">                sb.append(quote(query, L_URIC, H_URIC));</span>
            }
        }
<span class="fc" id="L384">    }</span>

    private static void appendAuthority(StringBuffer sb,
                                 String authority,
                                 String userInfo,
                                 String host,
                                 int port)
    {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (host != null) {</span>
<span class="nc" id="L393">            sb.append(&quot;//&quot;);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (userInfo != null) {</span>
<span class="nc" id="L395">                sb.append(quote(userInfo, L_USERINFO, H_USERINFO));</span>
<span class="nc" id="L396">                sb.append('@');</span>
            }
<span class="nc bnc" id="L398" title="All 2 branches missed.">            boolean needBrackets = ((host.indexOf(':') &gt;= 0)</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                                    &amp;&amp; !host.startsWith(&quot;[&quot;)</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                                    &amp;&amp; !host.endsWith(&quot;]&quot;));</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (needBrackets) sb.append('[');</span>
<span class="nc" id="L402">            sb.append(host);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (needBrackets) sb.append(']');</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (port != -1) {</span>
<span class="nc" id="L405">                sb.append(':');</span>
<span class="nc" id="L406">                sb.append(port);</span>
            }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        } else if (authority != null) {</span>
<span class="fc" id="L409">            sb.append(&quot;//&quot;);</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (authority.startsWith(&quot;[&quot;)) {</span>
<span class="nc" id="L411">                int end = authority.indexOf(&quot;]&quot;);</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">                if (end != -1 &amp;&amp; authority.indexOf(&quot;:&quot;)!=-1) {</span>
                    String doquote, dontquote;
<span class="nc bnc" id="L414" title="All 2 branches missed.">                    if (end == authority.length()) {</span>
<span class="nc" id="L415">                        dontquote = authority;</span>
<span class="nc" id="L416">                        doquote = &quot;&quot;;</span>
                    } else {
<span class="nc" id="L418">                        dontquote = authority.substring(0,end+1);</span>
<span class="nc" id="L419">                        doquote = authority.substring(end+1);</span>
                    }
<span class="nc" id="L421">                    sb.append (dontquote);</span>
<span class="nc" id="L422">                    sb.append(quote(doquote,</span>
                            L_REG_NAME | L_SERVER,
                            H_REG_NAME | H_SERVER));
                }
<span class="nc" id="L426">            } else {</span>
<span class="fc" id="L427">                sb.append(quote(authority,</span>
                            L_REG_NAME | L_SERVER,
                            H_REG_NAME | H_SERVER));
            }
        }
<span class="fc" id="L432">    }</span>

    private static void appendFragment(StringBuffer sb, String fragment) {
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (fragment != null) {</span>
<span class="fc" id="L436">            sb.append('#');</span>
<span class="fc" id="L437">            sb.append(quote(fragment, L_URIC, H_URIC));</span>
        }
<span class="fc" id="L439">    }</span>

    // Quote any characters in s that are not permitted
    // by the given mask pair
    //
    private static String quote(String s, long lowMask, long highMask) {
<span class="fc" id="L445">        int n = s.length();</span>
<span class="fc" id="L446">        StringBuffer sb = null;</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        boolean allowNonASCII = ((lowMask &amp; L_ESCAPED) != 0);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">        for (int i = 0; i &lt; s.length(); i++) {</span>
<span class="fc" id="L449">            char c = s.charAt(i);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">            if (c &lt; '\u0080') {</span>
<span class="fc bfc" id="L451" title="All 4 branches covered.">                if (!match(c, lowMask, highMask) &amp;&amp; !isEscaped(s, i)) {</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">                    if (sb == null) {</span>
<span class="fc" id="L453">                        sb = new StringBuffer();</span>
<span class="fc" id="L454">                        sb.append(s.substring(0, i));</span>
                    }
<span class="fc" id="L456">                    appendEscape(sb, (byte)c);</span>
                } else {
<span class="fc bfc" id="L458" title="All 2 branches covered.">                    if (sb != null)</span>
<span class="fc" id="L459">                        sb.append(c);</span>
                }
<span class="nc bnc" id="L461" title="All 2 branches missed.">            } else if (allowNonASCII</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                       &amp;&amp; (Character.isSpaceChar(c)</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                           || Character.isISOControl(c))) {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (sb == null) {</span>
<span class="nc" id="L465">                    sb = new StringBuffer();</span>
<span class="nc" id="L466">                    sb.append(s.substring(0, i));</span>
                }
<span class="nc" id="L468">                appendEncoded(sb, c);</span>
            } else {
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (sb != null)</span>
<span class="nc" id="L471">                    sb.append(c);</span>
            }
        }
<span class="fc bfc" id="L474" title="All 2 branches covered.">        return (sb == null) ? s : sb.toString();</span>
    }

    //
    // To check if the given string has an escaped triplet
    // at the given position
    //
    private static boolean isEscaped(String s, int pos) {
<span class="pc bpc" id="L482" title="2 of 4 branches missed.">        if (s == null || (s.length() &lt;= (pos + 2)))</span>
<span class="nc" id="L483">            return false;</span>

<span class="fc bfc" id="L485" title="All 2 branches covered.">        return s.charAt(pos) == '%'</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">               &amp;&amp; match(s.charAt(pos + 1), L_HEX, H_HEX)</span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">               &amp;&amp; match(s.charAt(pos + 2), L_HEX, H_HEX);</span>
    }

    private static void appendEncoded(StringBuffer sb, char c) {
<span class="nc" id="L491">        ByteBuffer bb = null;</span>
        try {
<span class="nc" id="L493">            bb = ThreadLocalCoders.encoderFor(&quot;UTF-8&quot;)</span>
<span class="nc" id="L494">                .encode(CharBuffer.wrap(&quot;&quot; + c));</span>
<span class="nc" id="L495">        } catch (CharacterCodingException x) {</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L497">        }</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        while (bb.hasRemaining()) {</span>
<span class="nc" id="L499">            int b = bb.get() &amp; 0xff;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (b &gt;= 0x80)</span>
<span class="nc" id="L501">                appendEscape(sb, (byte)b);</span>
            else
<span class="nc" id="L503">                sb.append((char)b);</span>
<span class="nc" id="L504">        }</span>
<span class="nc" id="L505">    }</span>

<span class="fc" id="L507">    private final static char[] hexDigits = {</span>
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };

    private static void appendEscape(StringBuffer sb, byte b) {
<span class="fc" id="L513">        sb.append('%');</span>
<span class="fc" id="L514">        sb.append(hexDigits[(b &gt;&gt; 4) &amp; 0x0f]);</span>
<span class="fc" id="L515">        sb.append(hexDigits[(b &gt;&gt; 0) &amp; 0x0f]);</span>
<span class="fc" id="L516">    }</span>

    // Tell whether the given character is permitted by the given mask pair
    private static boolean match(char c, long lowMask, long highMask) {
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (c &lt; 64)</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            return ((1L &lt;&lt; c) &amp; lowMask) != 0;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (c &lt; 128)</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            return ((1L &lt;&lt; (c - 64)) &amp; highMask) != 0;</span>
<span class="nc" id="L524">        return false;</span>
    }

    // If a scheme is given then the path, if given, must be absolute
    //
    private static void checkPath(String s, String scheme, String path)
        throws URISyntaxException
    {
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (scheme != null) {</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if ((path != null)</span>
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">                &amp;&amp; ((path.length() &gt; 0) &amp;&amp; (path.charAt(0) != '/')))</span>
<span class="nc" id="L535">                throw new URISyntaxException(s,</span>
                                             &quot;Relative path in absolute URI&quot;);
        }
<span class="fc" id="L538">    }</span>


    // -- Character classes for parsing --

    // Compute a low-order mask for the characters
    // between first and last, inclusive
    private static long lowMask(char first, char last) {
<span class="fc" id="L546">        long m = 0;</span>
<span class="fc" id="L547">        int f = Math.max(Math.min(first, 63), 0);</span>
<span class="fc" id="L548">        int l = Math.max(Math.min(last, 63), 0);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (int i = f; i &lt;= l; i++)</span>
<span class="fc" id="L550">            m |= 1L &lt;&lt; i;</span>
<span class="fc" id="L551">        return m;</span>
    }

    // Compute the low-order mask for the characters in the given string
    private static long lowMask(String chars) {
<span class="fc" id="L556">        int n = chars.length();</span>
<span class="fc" id="L557">        long m = 0;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L559">            char c = chars.charAt(i);</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            if (c &lt; 64)</span>
<span class="fc" id="L561">                m |= (1L &lt;&lt; c);</span>
        }
<span class="fc" id="L563">        return m;</span>
    }

    // Compute a high-order mask for the characters
    // between first and last, inclusive
    private static long highMask(char first, char last) {
<span class="fc" id="L569">        long m = 0;</span>
<span class="fc" id="L570">        int f = Math.max(Math.min(first, 127), 64) - 64;</span>
<span class="fc" id="L571">        int l = Math.max(Math.min(last, 127), 64) - 64;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (int i = f; i &lt;= l; i++)</span>
<span class="fc" id="L573">            m |= 1L &lt;&lt; i;</span>
<span class="fc" id="L574">        return m;</span>
    }

    // Compute the high-order mask for the characters in the given string
    private static long highMask(String chars) {
<span class="fc" id="L579">        int n = chars.length();</span>
<span class="fc" id="L580">        long m = 0;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L582">            char c = chars.charAt(i);</span>
<span class="pc bpc" id="L583" title="1 of 4 branches missed.">            if ((c &gt;= 64) &amp;&amp; (c &lt; 128))</span>
<span class="fc" id="L584">                m |= (1L &lt;&lt; (c - 64));</span>
        }
<span class="fc" id="L586">        return m;</span>
    }


    // Character-class masks

    // digit    = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
    //            &quot;8&quot; | &quot;9&quot;
<span class="fc" id="L594">    private static final long L_DIGIT = lowMask('0', '9');</span>
    private static final long H_DIGIT = 0L;

    // hex           =  digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |
    //                          &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
<span class="fc" id="L599">    private static final long L_HEX = L_DIGIT;</span>
<span class="fc" id="L600">    private static final long H_HEX = highMask('A', 'F') | highMask('a', 'f');</span>

    // upalpha  = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; |
    //            &quot;J&quot; | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; |
    //            &quot;S&quot; | &quot;T&quot; | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;
    private static final long L_UPALPHA = 0L;
<span class="fc" id="L606">    private static final long H_UPALPHA = highMask('A', 'Z');</span>

    // lowalpha = &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; |
    //            &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; |
    //            &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;
    private static final long L_LOWALPHA = 0L;
<span class="fc" id="L612">    private static final long H_LOWALPHA = highMask('a', 'z');</span>

    // alpha         = lowalpha | upalpha
    private static final long L_ALPHA = L_LOWALPHA | L_UPALPHA;
<span class="fc" id="L616">    private static final long H_ALPHA = H_LOWALPHA | H_UPALPHA;</span>

    // alphanum      = alpha | digit
<span class="fc" id="L619">    private static final long L_ALPHANUM = L_DIGIT | L_ALPHA;</span>
<span class="fc" id="L620">    private static final long H_ALPHANUM = H_DIGIT | H_ALPHA;</span>

    // mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; |
    //                 &quot;(&quot; | &quot;)&quot;
<span class="fc" id="L624">    private static final long L_MARK = lowMask(&quot;-_.!~*'()&quot;);</span>
<span class="fc" id="L625">    private static final long H_MARK = highMask(&quot;-_.!~*'()&quot;);</span>

    // unreserved    = alphanum | mark
<span class="fc" id="L628">    private static final long L_UNRESERVED = L_ALPHANUM | L_MARK;</span>
<span class="fc" id="L629">    private static final long H_UNRESERVED = H_ALPHANUM | H_MARK;</span>

    // reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
    //                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot;
    // Added per RFC2732: &quot;[&quot;, &quot;]&quot;
<span class="fc" id="L634">    private static final long L_RESERVED = lowMask(&quot;;/?:@&amp;=+$,[]&quot;);</span>
<span class="fc" id="L635">    private static final long H_RESERVED = highMask(&quot;;/?:@&amp;=+$,[]&quot;);</span>

    // The zero'th bit is used to indicate that escape pairs and non-US-ASCII
    // characters are allowed; this is handled by the scanEscape method below.
    private static final long L_ESCAPED = 1L;
    private static final long H_ESCAPED = 0L;

    // Dash, for use in domainlabel and toplabel
<span class="fc" id="L643">    private static final long L_DASH = lowMask(&quot;-&quot;);</span>
<span class="fc" id="L644">    private static final long H_DASH = highMask(&quot;-&quot;);</span>

    // uric          = reserved | unreserved | escaped
<span class="fc" id="L647">    private static final long L_URIC = L_RESERVED | L_UNRESERVED | L_ESCAPED;</span>
<span class="fc" id="L648">    private static final long H_URIC = H_RESERVED | H_UNRESERVED | H_ESCAPED;</span>

    // pchar         = unreserved | escaped |
    //                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
<span class="fc" id="L652">    private static final long L_PCHAR</span>
<span class="fc" id="L653">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;:@&amp;=+$,&quot;);</span>
<span class="fc" id="L654">    private static final long H_PCHAR</span>
<span class="fc" id="L655">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;:@&amp;=+$,&quot;);</span>

    // All valid path characters
<span class="fc" id="L658">    private static final long L_PATH = L_PCHAR | lowMask(&quot;;/&quot;);</span>
<span class="fc" id="L659">    private static final long H_PATH = H_PCHAR | highMask(&quot;;/&quot;);</span>

    // userinfo      = *( unreserved | escaped |
    //                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
<span class="fc" id="L663">    private static final long L_USERINFO</span>
<span class="fc" id="L664">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;;:&amp;=+$,&quot;);</span>
<span class="fc" id="L665">    private static final long H_USERINFO</span>
<span class="fc" id="L666">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;;:&amp;=+$,&quot;);</span>

    // reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
    //                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
<span class="fc" id="L670">    private static final long L_REG_NAME</span>
<span class="fc" id="L671">        = L_UNRESERVED | L_ESCAPED | lowMask(&quot;$,;:@&amp;=+&quot;);</span>
<span class="fc" id="L672">    private static final long H_REG_NAME</span>
<span class="fc" id="L673">        = H_UNRESERVED | H_ESCAPED | highMask(&quot;$,;:@&amp;=+&quot;);</span>

    // All valid characters for server-based authorities
<span class="fc" id="L676">    private static final long L_SERVER</span>
<span class="fc" id="L677">        = L_USERINFO | L_ALPHANUM | L_DASH | lowMask(&quot;.:@[]&quot;);</span>
<span class="fc" id="L678">    private static final long H_SERVER</span>
<span class="fc" id="L679">        = H_USERINFO | H_ALPHANUM | H_DASH | highMask(&quot;.:@[]&quot;);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>