<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AffineTransform.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.geom</a> &gt; <span class="el_source">AffineTransform.java</span></div><h1>AffineTransform.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.geom;

import java.awt.Shape;
import java.beans.ConstructorProperties;

/**
 * The &lt;code&gt;AffineTransform&lt;/code&gt; class represents a 2D affine transform
 * that performs a linear mapping from 2D coordinates to other 2D
 * coordinates that preserves the &quot;straightness&quot; and
 * &quot;parallelness&quot; of lines.  Affine transformations can be constructed
 * using sequences of translations, scales, flips, rotations, and shears.
 * &lt;p&gt;
 * Such a coordinate transformation can be represented by a 3 row by
 * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
 * transforms source coordinates {@code (x,y)} into
 * destination coordinates {@code (x',y')} by considering
 * them to be a column vector and multiplying the coordinate vector
 * by the matrix according to the following process:
 * &lt;pre&gt;
 *      [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
 *      [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
 *      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;h4&gt;&lt;a name=&quot;quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;&lt;/h4&gt;
 * &lt;p&gt;
 * In some variations of the &lt;code&gt;rotate&lt;/code&gt; methods in the
 * &lt;code&gt;AffineTransform&lt;/code&gt; class, a double-precision argument
 * specifies the angle of rotation in radians.
 * These methods have special handling for rotations of approximately
 * 90 degrees (including multiples such as 180, 270, and 360 degrees),
 * so that the common case of quadrant rotation is handled more
 * efficiently.
 * This special handling can cause angles very close to multiples of
 * 90 degrees to be treated as if they were exact multiples of
 * 90 degrees.
 * For small multiples of 90 degrees the range of angles treated
 * as a quadrant rotation is approximately 0.00000121 degrees wide.
 * This section explains why such special care is needed and how
 * it is implemented.
 * &lt;p&gt;
 * Since 90 degrees is represented as &lt;code&gt;PI/2&lt;/code&gt; in radians,
 * and since PI is a transcendental (and therefore irrational) number,
 * it is not possible to exactly represent a multiple of 90 degrees as
 * an exact double precision value measured in radians.
 * As a result it is theoretically impossible to describe quadrant
 * rotations (90, 180, 270 or 360 degrees) using these values.
 * Double precision floating point values can get very close to
 * non-zero multiples of &lt;code&gt;PI/2&lt;/code&gt; but never close enough
 * for the sine or cosine to be exactly 0.0, 1.0 or -1.0.
 * The implementations of &lt;code&gt;Math.sin()&lt;/code&gt; and
 * &lt;code&gt;Math.cos()&lt;/code&gt; correspondingly never return 0.0
 * for any case other than &lt;code&gt;Math.sin(0.0)&lt;/code&gt;.
 * These same implementations do, however, return exactly 1.0 and
 * -1.0 for some range of numbers around each multiple of 90
 * degrees since the correct answer is so close to 1.0 or -1.0 that
 * the double precision significand cannot represent the difference
 * as accurately as it can for numbers that are near 0.0.
 * &lt;p&gt;
 * The net result of these issues is that if the
 * &lt;code&gt;Math.sin()&lt;/code&gt; and &lt;code&gt;Math.cos()&lt;/code&gt; methods
 * are used to directly generate the values for the matrix modifications
 * during these radian-based rotation operations then the resulting
 * transform is never strictly classifiable as a quadrant rotation
 * even for a simple case like &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt;,
 * due to minor variations in the matrix caused by the non-0.0 values
 * obtained for the sine and cosine.
 * If these transforms are not classified as quadrant rotations then
 * subsequent code which attempts to optimize further operations based
 * upon the type of the transform will be relegated to its most general
 * implementation.
 * &lt;p&gt;
 * Because quadrant rotations are fairly common,
 * this class should handle these cases reasonably quickly, both in
 * applying the rotations to the transform and in applying the resulting
 * transform to the coordinates.
 * To facilitate this optimal handling, the methods which take an angle
 * of rotation measured in radians attempt to detect angles that are
 * intended to be quadrant rotations and treat them as such.
 * These methods therefore treat an angle &lt;em&gt;theta&lt;/em&gt; as a quadrant
 * rotation if either &lt;code&gt;Math.sin(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; or
 * &lt;code&gt;Math.cos(&lt;em&gt;theta&lt;/em&gt;)&lt;/code&gt; returns exactly 1.0 or -1.0.
 * As a rule of thumb, this property holds true for a range of
 * approximately 0.0000000211 radians (or 0.00000121 degrees) around
 * small multiples of &lt;code&gt;Math.PI/2.0&lt;/code&gt;.
 *
 * @author Jim Graham
 * @since 1.2
 */
public class AffineTransform implements Cloneable, java.io.Serializable {

    /*
     * This constant is only useful for the cached type field.
     * It indicates that the type has been decached and must be recalculated.
     */
    private static final int TYPE_UNKNOWN = -1;

    /**
     * This constant indicates that the transform defined by this object
     * is an identity transform.
     * An identity transform is one in which the output coordinates are
     * always the same as the input coordinates.
     * If this transform is anything other than the identity transform,
     * the type will either be the constant GENERAL_TRANSFORM or a
     * combination of the appropriate flag bits for the various coordinate
     * conversions that this transform performs.
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_IDENTITY = 0;

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a translation in addition to the conversions indicated
     * by other flag bits.
     * A translation moves the coordinates by a constant amount in x
     * and y without changing the length or angle of vectors.
     * @see #TYPE_IDENTITY
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_TRANSLATION = 1;

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a uniform scale in addition to the conversions indicated
     * by other flag bits.
     * A uniform scale multiplies the length of vectors by the same amount
     * in both the x and y directions without changing the angle between
     * vectors.
     * This flag bit is mutually exclusive with the TYPE_GENERAL_SCALE flag.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_UNIFORM_SCALE = 2;

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a general scale in addition to the conversions indicated
     * by other flag bits.
     * A general scale multiplies the length of vectors by different
     * amounts in the x and y directions without changing the angle
     * between perpendicular vectors.
     * This flag bit is mutually exclusive with the TYPE_UNIFORM_SCALE flag.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_GENERAL_SCALE = 4;

    /**
     * This constant is a bit mask for any of the scale flag bits.
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @since 1.2
     */
    public static final int TYPE_MASK_SCALE = (TYPE_UNIFORM_SCALE |
                                               TYPE_GENERAL_SCALE);

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a mirror image flip about some axis which changes the
     * normally right handed coordinate system into a left handed
     * system in addition to the conversions indicated by other flag bits.
     * A right handed coordinate system is one where the positive X
     * axis rotates counterclockwise to overlay the positive Y axis
     * similar to the direction that the fingers on your right hand
     * curl when you stare end on at your thumb.
     * A left handed coordinate system is one where the positive X
     * axis rotates clockwise to overlay the positive Y axis similar
     * to the direction that the fingers on your left hand curl.
     * There is no mathematical way to determine the angle of the
     * original flipping or mirroring transformation since all angles
     * of flip are identical given an appropriate adjusting rotation.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_FLIP = 64;
    /* NOTE: TYPE_FLIP was added after GENERAL_TRANSFORM was in public
     * circulation and the flag bits could no longer be conveniently
     * renumbered without introducing binary incompatibility in outside
     * code.
     */

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a quadrant rotation by some multiple of 90 degrees in
     * addition to the conversions indicated by other flag bits.
     * A rotation changes the angles of vectors by the same amount
     * regardless of the original direction of the vector and without
     * changing the length of the vector.
     * This flag bit is mutually exclusive with the TYPE_GENERAL_ROTATION flag.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_QUADRANT_ROTATION = 8;

    /**
     * This flag bit indicates that the transform defined by this object
     * performs a rotation by an arbitrary angle in addition to the
     * conversions indicated by other flag bits.
     * A rotation changes the angles of vectors by the same amount
     * regardless of the original direction of the vector and without
     * changing the length of the vector.
     * This flag bit is mutually exclusive with the
     * TYPE_QUADRANT_ROTATION flag.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_GENERAL_ROTATION = 16;

    /**
     * This constant is a bit mask for any of the rotation flag bits.
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @since 1.2
     */
    public static final int TYPE_MASK_ROTATION = (TYPE_QUADRANT_ROTATION |
                                                  TYPE_GENERAL_ROTATION);

    /**
     * This constant indicates that the transform defined by this object
     * performs an arbitrary conversion of the input coordinates.
     * If this transform can be classified by any of the above constants,
     * the type will either be the constant TYPE_IDENTITY or a
     * combination of the appropriate flag bits for the various coordinate
     * conversions that this transform performs.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #getType
     * @since 1.2
     */
    public static final int TYPE_GENERAL_TRANSFORM = 32;

    /**
     * This constant is used for the internal state variable to indicate
     * that no calculations need to be performed and that the source
     * coordinates only need to be copied to their destinations to
     * complete the transformation equation of this transform.
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_SHEAR
     * @see #state
     */
    static final int APPLY_IDENTITY = 0;

    /**
     * This constant is used for the internal state variable to indicate
     * that the translation components of the matrix (m02 and m12) need
     * to be added to complete the transformation equation of this transform.
     * @see #APPLY_IDENTITY
     * @see #APPLY_SCALE
     * @see #APPLY_SHEAR
     * @see #state
     */
    static final int APPLY_TRANSLATE = 1;

    /**
     * This constant is used for the internal state variable to indicate
     * that the scaling components of the matrix (m00 and m11) need
     * to be factored in to complete the transformation equation of
     * this transform.  If the APPLY_SHEAR bit is also set then it
     * indicates that the scaling components are not both 0.0.  If the
     * APPLY_SHEAR bit is not also set then it indicates that the
     * scaling components are not both 1.0.  If neither the APPLY_SHEAR
     * nor the APPLY_SCALE bits are set then the scaling components
     * are both 1.0, which means that the x and y components contribute
     * to the transformed coordinate, but they are not multiplied by
     * any scaling factor.
     * @see #APPLY_IDENTITY
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SHEAR
     * @see #state
     */
    static final int APPLY_SCALE = 2;

    /**
     * This constant is used for the internal state variable to indicate
     * that the shearing components of the matrix (m01 and m10) need
     * to be factored in to complete the transformation equation of this
     * transform.  The presence of this bit in the state variable changes
     * the interpretation of the APPLY_SCALE bit as indicated in its
     * documentation.
     * @see #APPLY_IDENTITY
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #state
     */
    static final int APPLY_SHEAR = 4;

    /*
     * For methods which combine together the state of two separate
     * transforms and dispatch based upon the combination, these constants
     * specify how far to shift one of the states so that the two states
     * are mutually non-interfering and provide constants for testing the
     * bits of the shifted (HI) state.  The methods in this class use
     * the convention that the state of &quot;this&quot; transform is unshifted and
     * the state of the &quot;other&quot; or &quot;argument&quot; transform is shifted (HI).
     */
    private static final int HI_SHIFT = 3;
    private static final int HI_IDENTITY = APPLY_IDENTITY &lt;&lt; HI_SHIFT;
    private static final int HI_TRANSLATE = APPLY_TRANSLATE &lt;&lt; HI_SHIFT;
    private static final int HI_SCALE = APPLY_SCALE &lt;&lt; HI_SHIFT;
    private static final int HI_SHEAR = APPLY_SHEAR &lt;&lt; HI_SHIFT;

    /**
     * The X coordinate scaling element of the 3x3
     * affine transformation matrix.
     *
     * @serial
     */
    double m00;

    /**
     * The Y coordinate shearing element of the 3x3
     * affine transformation matrix.
     *
     * @serial
     */
     double m10;

    /**
     * The X coordinate shearing element of the 3x3
     * affine transformation matrix.
     *
     * @serial
     */
     double m01;

    /**
     * The Y coordinate scaling element of the 3x3
     * affine transformation matrix.
     *
     * @serial
     */
     double m11;

    /**
     * The X coordinate of the translation element of the
     * 3x3 affine transformation matrix.
     *
     * @serial
     */
     double m02;

    /**
     * The Y coordinate of the translation element of the
     * 3x3 affine transformation matrix.
     *
     * @serial
     */
     double m12;

    /**
     * This field keeps track of which components of the matrix need to
     * be applied when performing a transformation.
     * @see #APPLY_IDENTITY
     * @see #APPLY_TRANSLATE
     * @see #APPLY_SCALE
     * @see #APPLY_SHEAR
     */
    transient int state;

    /**
     * This field caches the current transformation type of the matrix.
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_FLIP
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @see #TYPE_UNKNOWN
     * @see #getType
     */
    private transient int type;

    private AffineTransform(double m00, double m10,
                            double m01, double m11,
                            double m02, double m12,
<span class="nc" id="L459">                            int state) {</span>
<span class="nc" id="L460">        this.m00 = m00;</span>
<span class="nc" id="L461">        this.m10 = m10;</span>
<span class="nc" id="L462">        this.m01 = m01;</span>
<span class="nc" id="L463">        this.m11 = m11;</span>
<span class="nc" id="L464">        this.m02 = m02;</span>
<span class="nc" id="L465">        this.m12 = m12;</span>
<span class="nc" id="L466">        this.state = state;</span>
<span class="nc" id="L467">        this.type = TYPE_UNKNOWN;</span>
<span class="nc" id="L468">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; representing the
     * Identity transformation.
     * @since 1.2
     */
<span class="fc" id="L475">    public AffineTransform() {</span>
<span class="fc" id="L476">        m00 = m11 = 1.0;</span>
        // m01 = m10 = m02 = m12 = 0.0;         /* Not needed. */
        // state = APPLY_IDENTITY;              /* Not needed. */
        // type = TYPE_IDENTITY;                /* Not needed. */
<span class="fc" id="L480">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; that is a copy of
     * the specified &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @param Tx the &lt;code&gt;AffineTransform&lt;/code&gt; object to copy
     * @since 1.2
     */
<span class="nc" id="L488">    public AffineTransform(AffineTransform Tx) {</span>
<span class="nc" id="L489">        this.m00 = Tx.m00;</span>
<span class="nc" id="L490">        this.m10 = Tx.m10;</span>
<span class="nc" id="L491">        this.m01 = Tx.m01;</span>
<span class="nc" id="L492">        this.m11 = Tx.m11;</span>
<span class="nc" id="L493">        this.m02 = Tx.m02;</span>
<span class="nc" id="L494">        this.m12 = Tx.m12;</span>
<span class="nc" id="L495">        this.state = Tx.state;</span>
<span class="nc" id="L496">        this.type = Tx.type;</span>
<span class="nc" id="L497">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from 6 floating point
     * values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
    @ConstructorProperties({ &quot;scaleX&quot;, &quot;shearY&quot;, &quot;shearX&quot;, &quot;scaleY&quot;, &quot;translateX&quot;, &quot;translateY&quot; })
    public AffineTransform(float m00, float m10,
                           float m01, float m11,
<span class="nc" id="L515">                           float m02, float m12) {</span>
<span class="nc" id="L516">        this.m00 = m00;</span>
<span class="nc" id="L517">        this.m10 = m10;</span>
<span class="nc" id="L518">        this.m01 = m01;</span>
<span class="nc" id="L519">        this.m11 = m11;</span>
<span class="nc" id="L520">        this.m02 = m02;</span>
<span class="nc" id="L521">        this.m12 = m12;</span>
<span class="nc" id="L522">        updateState();</span>
<span class="nc" id="L523">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from an array of
     * floating point values representing either the 4 non-translation
     * entries or the 6 specifiable entries of the 3x3 transformation
     * matrix.  The values are retrieved from the array as
     * {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;[m02&amp;nbsp;m12]}.
     * @param flatmatrix the float array containing the values to be set
     * in the new &lt;code&gt;AffineTransform&lt;/code&gt; object. The length of the
     * array is assumed to be at least 4. If the length of the array is
     * less than 6, only the first 4 values are taken. If the length of
     * the array is greater than 6, the first 6 values are taken.
     * @since 1.2
     */
<span class="nc" id="L538">    public AffineTransform(float[] flatmatrix) {</span>
<span class="nc" id="L539">        m00 = flatmatrix[0];</span>
<span class="nc" id="L540">        m10 = flatmatrix[1];</span>
<span class="nc" id="L541">        m01 = flatmatrix[2];</span>
<span class="nc" id="L542">        m11 = flatmatrix[3];</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (flatmatrix.length &gt; 5) {</span>
<span class="nc" id="L544">            m02 = flatmatrix[4];</span>
<span class="nc" id="L545">            m12 = flatmatrix[5];</span>
        }
<span class="nc" id="L547">        updateState();</span>
<span class="nc" id="L548">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from 6 double
     * precision values representing the 6 specifiable entries of the 3x3
     * transformation matrix.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
    public AffineTransform(double m00, double m10,
                           double m01, double m11,
<span class="nc" id="L565">                           double m02, double m12) {</span>
<span class="nc" id="L566">        this.m00 = m00;</span>
<span class="nc" id="L567">        this.m10 = m10;</span>
<span class="nc" id="L568">        this.m01 = m01;</span>
<span class="nc" id="L569">        this.m11 = m11;</span>
<span class="nc" id="L570">        this.m02 = m02;</span>
<span class="nc" id="L571">        this.m12 = m12;</span>
<span class="nc" id="L572">        updateState();</span>
<span class="nc" id="L573">    }</span>

    /**
     * Constructs a new &lt;code&gt;AffineTransform&lt;/code&gt; from an array of
     * double precision values representing either the 4 non-translation
     * entries or the 6 specifiable entries of the 3x3 transformation
     * matrix. The values are retrieved from the array as
     * {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;[m02&amp;nbsp;m12]}.
     * @param flatmatrix the double array containing the values to be set
     * in the new &lt;code&gt;AffineTransform&lt;/code&gt; object. The length of the
     * array is assumed to be at least 4. If the length of the array is
     * less than 6, only the first 4 values are taken. If the length of
     * the array is greater than 6, the first 6 values are taken.
     * @since 1.2
     */
<span class="nc" id="L588">    public AffineTransform(double[] flatmatrix) {</span>
<span class="nc" id="L589">        m00 = flatmatrix[0];</span>
<span class="nc" id="L590">        m10 = flatmatrix[1];</span>
<span class="nc" id="L591">        m01 = flatmatrix[2];</span>
<span class="nc" id="L592">        m11 = flatmatrix[3];</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (flatmatrix.length &gt; 5) {</span>
<span class="nc" id="L594">            m02 = flatmatrix[4];</span>
<span class="nc" id="L595">            m12 = flatmatrix[5];</span>
        }
<span class="nc" id="L597">        updateState();</span>
<span class="nc" id="L598">    }</span>

    /**
     * Returns a transform representing a translation transformation.
     * The matrix representing the returned transform is:
     * &lt;pre&gt;
     *          [   1    0    tx  ]
     *          [   0    1    ty  ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that represents a
     *  translation transformation, created with the specified vector.
     * @since 1.2
     */
    public static AffineTransform getTranslateInstance(double tx, double ty) {
<span class="nc" id="L617">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L618">        Tx.setToTranslation(tx, ty);</span>
<span class="nc" id="L619">        return Tx;</span>
    }

    /**
     * Returns a transform representing a rotation transformation.
     * The matrix representing the returned transform is:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    0   ]
     *          [   sin(theta)     cos(theta)    0   ]
     *          [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     * @param theta the angle of rotation measured in radians
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that is a rotation
     *  transformation, created with the specified angle of rotation.
     * @since 1.2
     */
    public static AffineTransform getRotateInstance(double theta) {
<span class="nc" id="L641">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L642">        Tx.setToRotation(theta);</span>
<span class="nc" id="L643">        return Tx;</span>
    }

    /**
     * Returns a transform that rotates coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * &lt;p&gt;
     * This operation is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *     AffineTransform Tx = new AffineTransform();
     *     Tx.translate(anchorx, anchory);    // S3: final translation
     *     Tx.rotate(theta);                  // S2: rotate around anchor
     *     Tx.translate(-anchorx, -anchory);  // S1: translate anchor to origin
     * &lt;/pre&gt;
     * The matrix representing the returned transform is:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
     *          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
     *          [       0              0               1        ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that rotates
     *  coordinates around the specified point by the specified angle of
     *  rotation.
     * @since 1.2
     */
    public static AffineTransform getRotateInstance(double theta,
                                                    double anchorx,
                                                    double anchory)
    {
<span class="nc" id="L685">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L686">        Tx.setToRotation(theta, anchorx, anchory);</span>
<span class="nc" id="L687">        return Tx;</span>
    }

    /**
     * Returns a transform that rotates coordinates according to
     * a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx));
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that rotates
     *  coordinates according to the specified rotation vector.
     * @since 1.6
     */
    public static AffineTransform getRotateInstance(double vecx, double vecy) {
<span class="nc" id="L711">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L712">        Tx.setToRotation(vecx, vecy);</span>
<span class="nc" id="L713">        return Tx;</span>
    }

    /**
     * Returns a transform that rotates coordinates around an anchor
     * point according to a rotation vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * an identity transform is returned.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     AffineTransform.getRotateInstance(Math.atan2(vecy, vecx),
     *                                       anchorx, anchory);
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that rotates
     *  coordinates around the specified point according to the
     *  specified rotation vector.
     * @since 1.6
     */
    public static AffineTransform getRotateInstance(double vecx,
                                                    double vecy,
                                                    double anchorx,
                                                    double anchory)
    {
<span class="nc" id="L746">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L747">        Tx.setToRotation(vecx, vecy, anchorx, anchory);</span>
<span class="nc" id="L748">        return Tx;</span>
    }

    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that rotates
     *  coordinates by the specified number of quadrants.
     * @since 1.6
     */
    public static AffineTransform getQuadrantRotateInstance(int numquadrants) {
<span class="nc" id="L766">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L767">        Tx.setToQuadrantRotation(numquadrants);</span>
<span class="nc" id="L768">        return Tx;</span>
    }

    /**
     * Returns a transform that rotates coordinates by the specified
     * number of quadrants around the specified anchor point.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     AffineTransform.getRotateInstance(numquadrants * Math.PI / 2.0,
     *                                       anchorx, anchory);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that rotates
     *  coordinates by the specified number of quadrants around the
     *  specified anchor point.
     * @since 1.6
     */
    public static AffineTransform getQuadrantRotateInstance(int numquadrants,
                                                            double anchorx,
                                                            double anchory)
    {
<span class="nc" id="L794">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L795">        Tx.setToQuadrantRotation(numquadrants, anchorx, anchory);</span>
<span class="nc" id="L796">        return Tx;</span>
    }

    /**
     * Returns a transform representing a scaling transformation.
     * The matrix representing the returned transform is:
     * &lt;pre&gt;
     *          [   sx   0    0   ]
     *          [   0    sy   0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that scales
     *  coordinates by the specified factors.
     * @since 1.2
     */
    public static AffineTransform getScaleInstance(double sx, double sy) {
<span class="nc" id="L816">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L817">        Tx.setToScale(sx, sy);</span>
<span class="nc" id="L818">        return Tx;</span>
    }

    /**
     * Returns a transform representing a shearing transformation.
     * The matrix representing the returned transform is:
     * &lt;pre&gt;
     *          [   1   shx   0   ]
     *          [  shy   1    0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @return an &lt;code&gt;AffineTransform&lt;/code&gt; object that shears
     *  coordinates by the specified multipliers.
     * @since 1.2
     */
    public static AffineTransform getShearInstance(double shx, double shy) {
<span class="nc" id="L838">        AffineTransform Tx = new AffineTransform();</span>
<span class="nc" id="L839">        Tx.setToShear(shx, shy);</span>
<span class="nc" id="L840">        return Tx;</span>
    }

    /**
     * Retrieves the flag bits describing the conversion properties of
     * this transform.
     * The return value is either one of the constants TYPE_IDENTITY
     * or TYPE_GENERAL_TRANSFORM, or a combination of the
     * appropriate flag bits.
     * A valid combination of flag bits is an exclusive OR operation
     * that can combine
     * the TYPE_TRANSLATION flag bit
     * in addition to either of the
     * TYPE_UNIFORM_SCALE or TYPE_GENERAL_SCALE flag bits
     * as well as either of the
     * TYPE_QUADRANT_ROTATION or TYPE_GENERAL_ROTATION flag bits.
     * @return the OR combination of any of the indicated flags that
     * apply to this transform
     * @see #TYPE_IDENTITY
     * @see #TYPE_TRANSLATION
     * @see #TYPE_UNIFORM_SCALE
     * @see #TYPE_GENERAL_SCALE
     * @see #TYPE_QUADRANT_ROTATION
     * @see #TYPE_GENERAL_ROTATION
     * @see #TYPE_GENERAL_TRANSFORM
     * @since 1.2
     */
    public int getType() {
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if (type == TYPE_UNKNOWN) {</span>
<span class="nc" id="L869">            calculateType();</span>
        }
<span class="nc" id="L871">        return type;</span>
    }

    /**
     * This is the utility function to calculate the flag bits when
     * they have not been cached.
     * @see #getType
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void calculateType() {
<span class="nc" id="L881">        int ret = TYPE_IDENTITY;</span>
        boolean sgn0, sgn1;
        double M0, M1, M2, M3;
<span class="nc" id="L884">        updateState();</span>
<span class="nc bnc" id="L885" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L887">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L890">            ret = TYPE_TRANSLATION;</span>
            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc bnc" id="L893" title="All 2 branches missed.">            if ((M0 = m00) * (M2 = m01) + (M3 = m10) * (M1 = m11) != 0) {</span>
                // Transformed unit vectors are not perpendicular...
<span class="nc" id="L895">                this.type = TYPE_GENERAL_TRANSFORM;</span>
<span class="nc" id="L896">                return;</span>
            }
<span class="nc bnc" id="L898" title="All 2 branches missed.">            sgn0 = (M0 &gt;= 0.0);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            sgn1 = (M1 &gt;= 0.0);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (sgn0 == sgn1) {</span>
                // sgn(M0) == sgn(M1) therefore sgn(M2) == -sgn(M3)
                // This is the &quot;unflipped&quot; (right-handed) state
<span class="nc bnc" id="L903" title="All 4 branches missed.">                if (M0 != M1 || M2 != -M3) {</span>
<span class="nc" id="L904">                    ret |= (TYPE_GENERAL_ROTATION | TYPE_GENERAL_SCALE);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                } else if (M0 * M1 - M2 * M3 != 1.0) {</span>
<span class="nc" id="L906">                    ret |= (TYPE_GENERAL_ROTATION | TYPE_UNIFORM_SCALE);</span>
                } else {
<span class="nc" id="L908">                    ret |= TYPE_GENERAL_ROTATION;</span>
                }
            } else {
                // sgn(M0) == -sgn(M1) therefore sgn(M2) == sgn(M3)
                // This is the &quot;flipped&quot; (left-handed) state
<span class="nc bnc" id="L913" title="All 4 branches missed.">                if (M0 != -M1 || M2 != M3) {</span>
<span class="nc" id="L914">                    ret |= (TYPE_GENERAL_ROTATION |</span>
                            TYPE_FLIP |
                            TYPE_GENERAL_SCALE);
<span class="nc bnc" id="L917" title="All 2 branches missed.">                } else if (M0 * M1 - M2 * M3 != 1.0) {</span>
<span class="nc" id="L918">                    ret |= (TYPE_GENERAL_ROTATION |</span>
                            TYPE_FLIP |
                            TYPE_UNIFORM_SCALE);
                } else {
<span class="nc" id="L922">                    ret |= (TYPE_GENERAL_ROTATION | TYPE_FLIP);</span>
                }
            }
<span class="nc" id="L925">            break;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L927">            ret = TYPE_TRANSLATION;</span>
            /* NOBREAK */
        case (APPLY_SHEAR):
<span class="nc bnc" id="L930" title="All 2 branches missed.">            sgn0 = ((M0 = m01) &gt;= 0.0);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            sgn1 = ((M1 = m10) &gt;= 0.0);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (sgn0 != sgn1) {</span>
                // Different signs - simple 90 degree rotation
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if (M0 != -M1) {</span>
<span class="nc" id="L935">                    ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);</span>
<span class="nc bnc" id="L936" title="All 4 branches missed.">                } else if (M0 != 1.0 &amp;&amp; M0 != -1.0) {</span>
<span class="nc" id="L937">                    ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);</span>
                } else {
<span class="nc" id="L939">                    ret |= TYPE_QUADRANT_ROTATION;</span>
                }
            } else {
                // Same signs - 90 degree rotation plus an axis flip too
<span class="nc bnc" id="L943" title="All 2 branches missed.">                if (M0 == M1) {</span>
<span class="nc" id="L944">                    ret |= (TYPE_QUADRANT_ROTATION |</span>
                            TYPE_FLIP |
                            TYPE_UNIFORM_SCALE);
                } else {
<span class="nc" id="L948">                    ret |= (TYPE_QUADRANT_ROTATION |</span>
                            TYPE_FLIP |
                            TYPE_GENERAL_SCALE);
                }
            }
<span class="nc" id="L953">            break;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L955">            ret = TYPE_TRANSLATION;</span>
            /* NOBREAK */
        case (APPLY_SCALE):
<span class="nc bnc" id="L958" title="All 2 branches missed.">            sgn0 = ((M0 = m00) &gt;= 0.0);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            sgn1 = ((M1 = m11) &gt;= 0.0);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (sgn0 == sgn1) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">                if (sgn0) {</span>
                    // Both scaling factors non-negative - simple scale
                    // Note: APPLY_SCALE implies M0, M1 are not both 1
<span class="nc bnc" id="L964" title="All 2 branches missed.">                    if (M0 == M1) {</span>
<span class="nc" id="L965">                        ret |= TYPE_UNIFORM_SCALE;</span>
                    } else {
<span class="nc" id="L967">                        ret |= TYPE_GENERAL_SCALE;</span>
                    }
                } else {
                    // Both scaling factors negative - 180 degree rotation
<span class="nc bnc" id="L971" title="All 2 branches missed.">                    if (M0 != M1) {</span>
<span class="nc" id="L972">                        ret |= (TYPE_QUADRANT_ROTATION | TYPE_GENERAL_SCALE);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                    } else if (M0 != -1.0) {</span>
<span class="nc" id="L974">                        ret |= (TYPE_QUADRANT_ROTATION | TYPE_UNIFORM_SCALE);</span>
                    } else {
<span class="nc" id="L976">                        ret |= TYPE_QUADRANT_ROTATION;</span>
                    }
                }
            } else {
                // Scaling factor signs different - flip about some axis
<span class="nc bnc" id="L981" title="All 2 branches missed.">                if (M0 == -M1) {</span>
<span class="nc bnc" id="L982" title="All 4 branches missed.">                    if (M0 == 1.0 || M0 == -1.0) {</span>
<span class="nc" id="L983">                        ret |= TYPE_FLIP;</span>
                    } else {
<span class="nc" id="L985">                        ret |= (TYPE_FLIP | TYPE_UNIFORM_SCALE);</span>
                    }
                } else {
<span class="nc" id="L988">                    ret |= (TYPE_FLIP | TYPE_GENERAL_SCALE);</span>
                }
            }
<span class="nc" id="L991">            break;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L993">            ret = TYPE_TRANSLATION;</span>
<span class="nc" id="L994">            break;</span>
        case (APPLY_IDENTITY):
            break;
        }
<span class="nc" id="L998">        this.type = ret;</span>
<span class="nc" id="L999">    }</span>

    /**
     * Returns the determinant of the matrix representation of the transform.
     * The determinant is useful both to determine if the transform can
     * be inverted and to get a single value representing the
     * combined X and Y scaling of the transform.
     * &lt;p&gt;
     * If the determinant is non-zero, then this transform is
     * invertible and the various methods that depend on the inverse
     * transform do not need to throw a
     * {@link NoninvertibleTransformException}.
     * If the determinant is zero then this transform can not be
     * inverted since the transform maps all input coordinates onto
     * a line or a point.
     * If the determinant is near enough to zero then inverse transform
     * operations might not carry enough precision to produce meaningful
     * results.
     * &lt;p&gt;
     * If this transform represents a uniform scale, as indicated by
     * the &lt;code&gt;getType&lt;/code&gt; method then the determinant also
     * represents the square of the uniform scale factor by which all of
     * the points are expanded from or contracted towards the origin.
     * If this transform represents a non-uniform scale or more general
     * transform then the determinant is not likely to represent a
     * value useful for any purpose other than determining if inverse
     * transforms are possible.
     * &lt;p&gt;
     * Mathematically, the determinant is calculated using the formula:
     * &lt;pre&gt;
     *          |  m00  m01  m02  |
     *          |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
     *          |   0    0    1   |
     * &lt;/pre&gt;
     *
     * @return the determinant of the matrix used to transform the
     * coordinates.
     * @see #getType
     * @see #createInverse
     * @see #inverseTransform
     * @see #TYPE_UNIFORM_SCALE
     * @since 1.2
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public double getDeterminant() {
<span class="nc bnc" id="L1044" title="All 5 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L1046">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L1050">            return m00 * m11 - m01 * m10;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L1053">            return -(m01 * m10);</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L1056">            return m00 * m11;</span>
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
<span class="nc" id="L1059">            return 1.0;</span>
        }
    }

    /**
     * Manually recalculates the state of the transform when the matrix
     * changes too much to predict the effects on the state.
     * The following table specifies what the various settings of the
     * state field say about the values of the corresponding matrix
     * element fields.
     * Note that the rules governing the SCALE fields are slightly
     * different depending on whether the SHEAR flag is also set.
     * &lt;pre&gt;
     *                     SCALE            SHEAR          TRANSLATE
     *                    m00/m11          m01/m10          m02/m12
     *
     * IDENTITY             1.0              0.0              0.0
     * TRANSLATE (TR)       1.0              0.0          not both 0.0
     * SCALE (SC)       not both 1.0         0.0              0.0
     * TR | SC          not both 1.0         0.0          not both 0.0
     * SHEAR (SH)           0.0          not both 0.0         0.0
     * TR | SH              0.0          not both 0.0     not both 0.0
     * SC | SH          not both 0.0     not both 0.0         0.0
     * TR | SC | SH     not both 0.0     not both 0.0     not both 0.0
     * &lt;/pre&gt;
     */
    void updateState() {
<span class="nc bnc" id="L1086" title="All 4 branches missed.">        if (m01 == 0.0 &amp;&amp; m10 == 0.0) {</span>
<span class="nc bnc" id="L1087" title="All 4 branches missed.">            if (m00 == 1.0 &amp;&amp; m11 == 1.0) {</span>
<span class="nc bnc" id="L1088" title="All 4 branches missed.">                if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1089">                    state = APPLY_IDENTITY;</span>
<span class="nc" id="L1090">                    type = TYPE_IDENTITY;</span>
                } else {
<span class="nc" id="L1092">                    state = APPLY_TRANSLATE;</span>
<span class="nc" id="L1093">                    type = TYPE_TRANSLATION;</span>
                }
            } else {
<span class="nc bnc" id="L1096" title="All 4 branches missed.">                if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1097">                    state = APPLY_SCALE;</span>
<span class="nc" id="L1098">                    type = TYPE_UNKNOWN;</span>
                } else {
<span class="nc" id="L1100">                    state = (APPLY_SCALE | APPLY_TRANSLATE);</span>
<span class="nc" id="L1101">                    type = TYPE_UNKNOWN;</span>
                }
            }
        } else {
<span class="nc bnc" id="L1105" title="All 4 branches missed.">            if (m00 == 0.0 &amp;&amp; m11 == 0.0) {</span>
<span class="nc bnc" id="L1106" title="All 4 branches missed.">                if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1107">                    state = APPLY_SHEAR;</span>
<span class="nc" id="L1108">                    type = TYPE_UNKNOWN;</span>
                } else {
<span class="nc" id="L1110">                    state = (APPLY_SHEAR | APPLY_TRANSLATE);</span>
<span class="nc" id="L1111">                    type = TYPE_UNKNOWN;</span>
                }
            } else {
<span class="nc bnc" id="L1114" title="All 4 branches missed.">                if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1115">                    state = (APPLY_SHEAR | APPLY_SCALE);</span>
<span class="nc" id="L1116">                    type = TYPE_UNKNOWN;</span>
                } else {
<span class="nc" id="L1118">                    state = (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE);</span>
<span class="nc" id="L1119">                    type = TYPE_UNKNOWN;</span>
                }
            }
        }
<span class="nc" id="L1123">    }</span>

    /*
     * Convenience method used internally to throw exceptions when
     * a case was forgotten in a switch statement.
     */
    private void stateError() {
<span class="nc" id="L1130">        throw new InternalError(&quot;missing case in transform state switch&quot;);</span>
    }

    /**
     * Retrieves the 6 specifiable values in the 3x3 affine transformation
     * matrix and places them into an array of double precisions values.
     * The values are stored in the array as
     * {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;m02&amp;nbsp;m12&amp;nbsp;}.
     * An array of 4 doubles can also be specified, in which case only the
     * first four elements representing the non-transform
     * parts of the array are retrieved and the values are stored into
     * the array as {&amp;nbsp;m00&amp;nbsp;m10&amp;nbsp;m01&amp;nbsp;m11&amp;nbsp;}
     * @param flatmatrix the double array used to store the returned
     * values.
     * @see #getScaleX
     * @see #getScaleY
     * @see #getShearX
     * @see #getShearY
     * @see #getTranslateX
     * @see #getTranslateY
     * @since 1.2
     */
    public void getMatrix(double[] flatmatrix) {
<span class="nc" id="L1153">        flatmatrix[0] = m00;</span>
<span class="nc" id="L1154">        flatmatrix[1] = m10;</span>
<span class="nc" id="L1155">        flatmatrix[2] = m01;</span>
<span class="nc" id="L1156">        flatmatrix[3] = m11;</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (flatmatrix.length &gt; 5) {</span>
<span class="nc" id="L1158">            flatmatrix[4] = m02;</span>
<span class="nc" id="L1159">            flatmatrix[5] = m12;</span>
        }
<span class="nc" id="L1161">    }</span>

    /**
     * Returns the X coordinate scaling element (m00) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the X coordinate of the scaling
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getScaleX() {
<span class="nc" id="L1172">        return m00;</span>
    }

    /**
     * Returns the Y coordinate scaling element (m11) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the Y coordinate of the scaling
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getScaleY() {
<span class="nc" id="L1184">        return m11;</span>
    }

    /**
     * Returns the X coordinate shearing element (m01) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the X coordinate of the shearing
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getShearX() {
<span class="nc" id="L1196">        return m01;</span>
    }

    /**
     * Returns the Y coordinate shearing element (m10) of the 3x3
     * affine transformation matrix.
     * @return a double value that is the Y coordinate of the shearing
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getShearY() {
<span class="nc" id="L1208">        return m10;</span>
    }

    /**
     * Returns the X coordinate of the translation element (m02) of the
     * 3x3 affine transformation matrix.
     * @return a double value that is the X coordinate of the translation
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getTranslateX() {
<span class="nc" id="L1220">        return m02;</span>
    }

    /**
     * Returns the Y coordinate of the translation element (m12) of the
     * 3x3 affine transformation matrix.
     * @return a double value that is the Y coordinate of the translation
     *  element of the affine transformation matrix.
     * @see #getMatrix
     * @since 1.2
     */
    public double getTranslateY() {
<span class="nc" id="L1232">        return m12;</span>
    }

    /**
     * Concatenates this transform with a translation transformation.
     * This is equivalent to calling concatenate(T), where T is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   1    0    tx  ]
     *          [   0    1    ty  ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
    public void translate(double tx, double ty) {
<span class="nc bnc" id="L1251" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L1253">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L1255">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L1257">            m02 = tx * m00 + ty * m01 + m02;</span>
<span class="nc" id="L1258">            m12 = tx * m10 + ty * m11 + m12;</span>
<span class="nc bnc" id="L1259" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1260">                state = APPLY_SHEAR | APPLY_SCALE;</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">                if (type != TYPE_UNKNOWN) {</span>
<span class="nc" id="L1262">                    type -= TYPE_TRANSLATION;</span>
                }
            }
<span class="nc" id="L1265">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L1267">            m02 = tx * m00 + ty * m01;</span>
<span class="nc" id="L1268">            m12 = tx * m10 + ty * m11;</span>
<span class="nc bnc" id="L1269" title="All 4 branches missed.">            if (m02 != 0.0 || m12 != 0.0) {</span>
<span class="nc" id="L1270">                state = APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE;</span>
<span class="nc" id="L1271">                type |= TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L1273">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L1275">            m02 = ty * m01 + m02;</span>
<span class="nc" id="L1276">            m12 = tx * m10 + m12;</span>
<span class="nc bnc" id="L1277" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1278">                state = APPLY_SHEAR;</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                if (type != TYPE_UNKNOWN) {</span>
<span class="nc" id="L1280">                    type -= TYPE_TRANSLATION;</span>
                }
            }
<span class="nc" id="L1283">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L1285">            m02 = ty * m01;</span>
<span class="nc" id="L1286">            m12 = tx * m10;</span>
<span class="nc bnc" id="L1287" title="All 4 branches missed.">            if (m02 != 0.0 || m12 != 0.0) {</span>
<span class="nc" id="L1288">                state = APPLY_SHEAR | APPLY_TRANSLATE;</span>
<span class="nc" id="L1289">                type |= TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L1291">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L1293">            m02 = tx * m00 + m02;</span>
<span class="nc" id="L1294">            m12 = ty * m11 + m12;</span>
<span class="nc bnc" id="L1295" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1296">                state = APPLY_SCALE;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                if (type != TYPE_UNKNOWN) {</span>
<span class="nc" id="L1298">                    type -= TYPE_TRANSLATION;</span>
                }
            }
<span class="nc" id="L1301">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L1303">            m02 = tx * m00;</span>
<span class="nc" id="L1304">            m12 = ty * m11;</span>
<span class="nc bnc" id="L1305" title="All 4 branches missed.">            if (m02 != 0.0 || m12 != 0.0) {</span>
<span class="nc" id="L1306">                state = APPLY_SCALE | APPLY_TRANSLATE;</span>
<span class="nc" id="L1307">                type |= TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L1309">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L1311">            m02 = tx + m02;</span>
<span class="nc" id="L1312">            m12 = ty + m12;</span>
<span class="nc bnc" id="L1313" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1314">                state = APPLY_IDENTITY;</span>
<span class="nc" id="L1315">                type = TYPE_IDENTITY;</span>
            }
<span class="nc" id="L1317">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc" id="L1319">            m02 = tx;</span>
<span class="nc" id="L1320">            m12 = ty;</span>
<span class="nc bnc" id="L1321" title="All 4 branches missed.">            if (tx != 0.0 || ty != 0.0) {</span>
<span class="nc" id="L1322">                state = APPLY_TRANSLATE;</span>
<span class="nc" id="L1323">                type = TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L1325">            return;</span>
        }
    }

    // Utility methods to optimize rotate methods.
    // These tables translate the flags during predictable quadrant
    // rotations where the shear and scale values are swapped and negated.
<span class="fc" id="L1332">    private static final int rot90conversion[] = {</span>
        /* IDENTITY =&gt; */        APPLY_SHEAR,
        /* TRANSLATE (TR) =&gt; */  APPLY_SHEAR | APPLY_TRANSLATE,
        /* SCALE (SC) =&gt; */      APPLY_SHEAR,
        /* SC | TR =&gt; */         APPLY_SHEAR | APPLY_TRANSLATE,
        /* SHEAR (SH) =&gt; */      APPLY_SCALE,
        /* SH | TR =&gt; */         APPLY_SCALE | APPLY_TRANSLATE,
        /* SH | SC =&gt; */         APPLY_SHEAR | APPLY_SCALE,
        /* SH | SC | TR =&gt; */    APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE,
    };
    private final void rotate90() {
<span class="nc" id="L1343">        double M0 = m00;</span>
<span class="nc" id="L1344">        m00 = m01;</span>
<span class="nc" id="L1345">        m01 = -M0;</span>
<span class="nc" id="L1346">        M0 = m10;</span>
<span class="nc" id="L1347">        m10 = m11;</span>
<span class="nc" id="L1348">        m11 = -M0;</span>
<span class="nc" id="L1349">        int state = rot90conversion[this.state];</span>
<span class="nc bnc" id="L1350" title="All 6 branches missed.">        if ((state &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;</span>
            m00 == 1.0 &amp;&amp; m11 == 1.0)
        {
<span class="nc" id="L1353">            state -= APPLY_SCALE;</span>
        }
<span class="nc" id="L1355">        this.state = state;</span>
<span class="nc" id="L1356">        type = TYPE_UNKNOWN;</span>
<span class="nc" id="L1357">    }</span>
    private final void rotate180() {
<span class="nc" id="L1359">        m00 = -m00;</span>
<span class="nc" id="L1360">        m11 = -m11;</span>
<span class="nc" id="L1361">        int state = this.state;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if ((state &amp; (APPLY_SHEAR)) != 0) {</span>
            // If there was a shear, then this rotation has no
            // effect on the state.
<span class="nc" id="L1365">            m01 = -m01;</span>
<span class="nc" id="L1366">            m10 = -m10;</span>
        } else {
            // No shear means the SCALE state may toggle when
            // m00 and m11 are negated.
<span class="nc bnc" id="L1370" title="All 4 branches missed.">            if (m00 == 1.0 &amp;&amp; m11 == 1.0) {</span>
<span class="nc" id="L1371">                this.state = state &amp; ~APPLY_SCALE;</span>
            } else {
<span class="nc" id="L1373">                this.state = state | APPLY_SCALE;</span>
            }
        }
<span class="nc" id="L1376">        type = TYPE_UNKNOWN;</span>
<span class="nc" id="L1377">    }</span>
    private final void rotate270() {
<span class="nc" id="L1379">        double M0 = m00;</span>
<span class="nc" id="L1380">        m00 = -m01;</span>
<span class="nc" id="L1381">        m01 = M0;</span>
<span class="nc" id="L1382">        M0 = m10;</span>
<span class="nc" id="L1383">        m10 = -m11;</span>
<span class="nc" id="L1384">        m11 = M0;</span>
<span class="nc" id="L1385">        int state = rot90conversion[this.state];</span>
<span class="nc bnc" id="L1386" title="All 6 branches missed.">        if ((state &amp; (APPLY_SHEAR | APPLY_SCALE)) == APPLY_SCALE &amp;&amp;</span>
            m00 == 1.0 &amp;&amp; m11 == 1.0)
        {
<span class="nc" id="L1389">            state -= APPLY_SCALE;</span>
        }
<span class="nc" id="L1391">        this.state = state;</span>
<span class="nc" id="L1392">        type = TYPE_UNKNOWN;</span>
<span class="nc" id="L1393">    }</span>

    /**
     * Concatenates this transform with a rotation transformation.
     * This is equivalent to calling concatenate(R), where R is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    0   ]
     *          [   sin(theta)     cos(theta)    0   ]
     *          [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     * @param theta the angle of rotation measured in radians
     * @since 1.2
     */
    public void rotate(double theta) {
<span class="nc" id="L1413">        double sin = Math.sin(theta);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        if (sin == 1.0) {</span>
<span class="nc" id="L1415">            rotate90();</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        } else if (sin == -1.0) {</span>
<span class="nc" id="L1417">            rotate270();</span>
        } else {
<span class="nc" id="L1419">            double cos = Math.cos(theta);</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">            if (cos == -1.0) {</span>
<span class="nc" id="L1421">                rotate180();</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">            } else if (cos != 1.0) {</span>
                double M0, M1;
<span class="nc" id="L1424">                M0 = m00;</span>
<span class="nc" id="L1425">                M1 = m01;</span>
<span class="nc" id="L1426">                m00 =  cos * M0 + sin * M1;</span>
<span class="nc" id="L1427">                m01 = -sin * M0 + cos * M1;</span>
<span class="nc" id="L1428">                M0 = m10;</span>
<span class="nc" id="L1429">                M1 = m11;</span>
<span class="nc" id="L1430">                m10 =  cos * M0 + sin * M1;</span>
<span class="nc" id="L1431">                m11 = -sin * M0 + cos * M1;</span>
<span class="nc" id="L1432">                updateState();</span>
            }
        }
<span class="nc" id="L1435">    }</span>

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * &lt;p&gt;
     * This operation is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *     translate(anchorx, anchory);      // S3: final translation
     *     rotate(theta);                    // S2: rotate around anchor
     *     translate(-anchorx, -anchory);    // S1: translate anchor to origin
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
    public void rotate(double theta, double anchorx, double anchory) {
        // REMIND: Simple for now - optimize later
<span class="nc" id="L1465">        translate(anchorx, anchory);</span>
<span class="nc" id="L1466">        rotate(theta);</span>
<span class="nc" id="L1467">        translate(-anchorx, -anchory);</span>
<span class="nc" id="L1468">    }</span>

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * no additional rotation is added to this transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *          rotate(Math.atan2(vecy, vecx));
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
    public void rotate(double vecx, double vecy) {
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        if (vecy == 0.0) {</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">            if (vecx &lt; 0.0) {</span>
<span class="nc" id="L1491">                rotate180();</span>
            }
            // If vecx &gt; 0.0 - no rotation
            // If vecx == 0.0 - undefined rotation - treat as no rotation
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        } else if (vecx == 0.0) {</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            if (vecy &gt; 0.0) {</span>
<span class="nc" id="L1497">                rotate90();</span>
            } else {  // vecy must be &lt; 0.0
<span class="nc" id="L1499">                rotate270();</span>
            }
        } else {
<span class="nc" id="L1502">            double len = Math.sqrt(vecx * vecx + vecy * vecy);</span>
<span class="nc" id="L1503">            double sin = vecy / len;</span>
<span class="nc" id="L1504">            double cos = vecx / len;</span>
            double M0, M1;
<span class="nc" id="L1506">            M0 = m00;</span>
<span class="nc" id="L1507">            M1 = m01;</span>
<span class="nc" id="L1508">            m00 =  cos * M0 + sin * M1;</span>
<span class="nc" id="L1509">            m01 = -sin * M0 + cos * M1;</span>
<span class="nc" id="L1510">            M0 = m10;</span>
<span class="nc" id="L1511">            M1 = m11;</span>
<span class="nc" id="L1512">            m10 =  cos * M0 + sin * M1;</span>
<span class="nc" id="L1513">            m11 = -sin * M0 + cos * M1;</span>
<span class="nc" id="L1514">            updateState();</span>
        }
<span class="nc" id="L1516">    }</span>

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is not modified in any way.
     * This method is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(Math.atan2(vecy, vecx), anchorx, anchory);
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    public void rotate(double vecx, double vecy,
                       double anchorx, double anchory)
    {
        // REMIND: Simple for now - optimize later
<span class="nc" id="L1544">        translate(anchorx, anchory);</span>
<span class="nc" id="L1545">        rotate(vecx, vecy);</span>
<span class="nc" id="L1546">        translate(-anchorx, -anchory);</span>
<span class="nc" id="L1547">    }</span>

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants.
     * This is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(numquadrants * Math.PI / 2.0);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
    public void quadrantRotate(int numquadrants) {
<span class="nc bnc" id="L1562" title="All 5 branches missed.">        switch (numquadrants &amp; 3) {</span>
        case 0:
<span class="nc" id="L1564">            break;</span>
        case 1:
<span class="nc" id="L1566">            rotate90();</span>
<span class="nc" id="L1567">            break;</span>
        case 2:
<span class="nc" id="L1569">            rotate180();</span>
<span class="nc" id="L1570">            break;</span>
        case 3:
<span class="nc" id="L1572">            rotate270();</span>
            break;
        }
<span class="nc" id="L1575">    }</span>

    /**
     * Concatenates this transform with a transform that rotates
     * coordinates by the specified number of quadrants around
     * the specified anchor point.
     * This method is equivalent to calling:
     * &lt;pre&gt;
     *     rotate(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    public void quadrantRotate(int numquadrants,
                               double anchorx, double anchory)
    {
<span class="nc bnc" id="L1596" title="All 5 branches missed.">        switch (numquadrants &amp; 3) {</span>
        case 0:
<span class="nc" id="L1598">            return;</span>
        case 1:
<span class="nc" id="L1600">            m02 += anchorx * (m00 - m01) + anchory * (m01 + m00);</span>
<span class="nc" id="L1601">            m12 += anchorx * (m10 - m11) + anchory * (m11 + m10);</span>
<span class="nc" id="L1602">            rotate90();</span>
<span class="nc" id="L1603">            break;</span>
        case 2:
<span class="nc" id="L1605">            m02 += anchorx * (m00 + m00) + anchory * (m01 + m01);</span>
<span class="nc" id="L1606">            m12 += anchorx * (m10 + m10) + anchory * (m11 + m11);</span>
<span class="nc" id="L1607">            rotate180();</span>
<span class="nc" id="L1608">            break;</span>
        case 3:
<span class="nc" id="L1610">            m02 += anchorx * (m00 + m01) + anchory * (m01 - m00);</span>
<span class="nc" id="L1611">            m12 += anchorx * (m10 + m11) + anchory * (m11 - m10);</span>
<span class="nc" id="L1612">            rotate270();</span>
            break;
        }
<span class="nc bnc" id="L1615" title="All 4 branches missed.">        if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L1616">            state &amp;= ~APPLY_TRANSLATE;</span>
        } else {
<span class="nc" id="L1618">            state |= APPLY_TRANSLATE;</span>
        }
<span class="nc" id="L1620">    }</span>

    /**
     * Concatenates this transform with a scaling transformation.
     * This is equivalent to calling concatenate(S), where S is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   sx   0    0   ]
     *          [   0    sy   0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @since 1.2
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public void scale(double sx, double sy) {
<span class="nc" id="L1639">        int state = this.state;</span>
<span class="nc bnc" id="L1640" title="All 5 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L1642">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L1646">            m00 *= sx;</span>
<span class="nc" id="L1647">            m11 *= sy;</span>
            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L1651">            m01 *= sy;</span>
<span class="nc" id="L1652">            m10 *= sx;</span>
<span class="nc bnc" id="L1653" title="All 4 branches missed.">            if (m01 == 0 &amp;&amp; m10 == 0) {</span>
<span class="nc" id="L1654">                state &amp;= APPLY_TRANSLATE;</span>
<span class="nc bnc" id="L1655" title="All 4 branches missed.">                if (m00 == 1.0 &amp;&amp; m11 == 1.0) {</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                    this.type = (state == APPLY_IDENTITY</span>
                                 ? TYPE_IDENTITY
                                 : TYPE_TRANSLATION);
                } else {
<span class="nc" id="L1660">                    state |= APPLY_SCALE;</span>
<span class="nc" id="L1661">                    this.type = TYPE_UNKNOWN;</span>
                }
<span class="nc" id="L1663">                this.state = state;</span>
            }
<span class="nc" id="L1665">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L1668">            m00 *= sx;</span>
<span class="nc" id="L1669">            m11 *= sy;</span>
<span class="nc bnc" id="L1670" title="All 4 branches missed.">            if (m00 == 1.0 &amp;&amp; m11 == 1.0) {</span>
<span class="nc" id="L1671">                this.state = (state &amp;= APPLY_TRANSLATE);</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">                this.type = (state == APPLY_IDENTITY</span>
                             ? TYPE_IDENTITY
                             : TYPE_TRANSLATION);
            } else {
<span class="nc" id="L1676">                this.type = TYPE_UNKNOWN;</span>
            }
<span class="nc" id="L1678">            return;</span>
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
<span class="nc" id="L1681">            m00 = sx;</span>
<span class="nc" id="L1682">            m11 = sy;</span>
<span class="nc bnc" id="L1683" title="All 4 branches missed.">            if (sx != 1.0 || sy != 1.0) {</span>
<span class="nc" id="L1684">                this.state = state | APPLY_SCALE;</span>
<span class="nc" id="L1685">                this.type = TYPE_UNKNOWN;</span>
            }
<span class="nc" id="L1687">            return;</span>
        }
    }

    /**
     * Concatenates this transform with a shearing transformation.
     * This is equivalent to calling concatenate(SH), where SH is an
     * &lt;code&gt;AffineTransform&lt;/code&gt; represented by the following matrix:
     * &lt;pre&gt;
     *          [   1   shx   0   ]
     *          [  shy   1    0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
    public void shear(double shx, double shy) {
<span class="nc" id="L1707">        int state = this.state;</span>
<span class="nc bnc" id="L1708" title="All 5 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L1710">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L1712">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
            double M0, M1;
<span class="nc" id="L1716">            M0 = m00;</span>
<span class="nc" id="L1717">            M1 = m01;</span>
<span class="nc" id="L1718">            m00 = M0 + M1 * shy;</span>
<span class="nc" id="L1719">            m01 = M0 * shx + M1;</span>

<span class="nc" id="L1721">            M0 = m10;</span>
<span class="nc" id="L1722">            M1 = m11;</span>
<span class="nc" id="L1723">            m10 = M0 + M1 * shy;</span>
<span class="nc" id="L1724">            m11 = M0 * shx + M1;</span>
<span class="nc" id="L1725">            updateState();</span>
<span class="nc" id="L1726">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L1729">            m00 = m01 * shy;</span>
<span class="nc" id="L1730">            m11 = m10 * shx;</span>
<span class="nc bnc" id="L1731" title="All 4 branches missed.">            if (m00 != 0.0 || m11 != 0.0) {</span>
<span class="nc" id="L1732">                this.state = state | APPLY_SCALE;</span>
            }
<span class="nc" id="L1734">            this.type = TYPE_UNKNOWN;</span>
<span class="nc" id="L1735">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L1738">            m01 = m00 * shx;</span>
<span class="nc" id="L1739">            m10 = m11 * shy;</span>
<span class="nc bnc" id="L1740" title="All 4 branches missed.">            if (m01 != 0.0 || m10 != 0.0) {</span>
<span class="nc" id="L1741">                this.state = state | APPLY_SHEAR;</span>
            }
<span class="nc" id="L1743">            this.type = TYPE_UNKNOWN;</span>
<span class="nc" id="L1744">            return;</span>
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
<span class="nc" id="L1747">            m01 = shx;</span>
<span class="nc" id="L1748">            m10 = shy;</span>
<span class="nc bnc" id="L1749" title="All 4 branches missed.">            if (m01 != 0.0 || m10 != 0.0) {</span>
<span class="nc" id="L1750">                this.state = state | APPLY_SCALE | APPLY_SHEAR;</span>
<span class="nc" id="L1751">                this.type = TYPE_UNKNOWN;</span>
            }
<span class="nc" id="L1753">            return;</span>
        }
    }

    /**
     * Resets this transform to the Identity transform.
     * @since 1.2
     */
    public void setToIdentity() {
<span class="nc" id="L1762">        m00 = m11 = 1.0;</span>
<span class="nc" id="L1763">        m10 = m01 = m02 = m12 = 0.0;</span>
<span class="nc" id="L1764">        state = APPLY_IDENTITY;</span>
<span class="nc" id="L1765">        type = TYPE_IDENTITY;</span>
<span class="nc" id="L1766">    }</span>

    /**
     * Sets this transform to a translation transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *          [   1    0    tx  ]
     *          [   0    1    ty  ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param tx the distance by which coordinates are translated in the
     * X axis direction
     * @param ty the distance by which coordinates are translated in the
     * Y axis direction
     * @since 1.2
     */
    public void setToTranslation(double tx, double ty) {
<span class="nc" id="L1783">        m00 = 1.0;</span>
<span class="nc" id="L1784">        m10 = 0.0;</span>
<span class="nc" id="L1785">        m01 = 0.0;</span>
<span class="nc" id="L1786">        m11 = 1.0;</span>
<span class="nc" id="L1787">        m02 = tx;</span>
<span class="nc" id="L1788">        m12 = ty;</span>
<span class="nc bnc" id="L1789" title="All 4 branches missed.">        if (tx != 0.0 || ty != 0.0) {</span>
<span class="nc" id="L1790">            state = APPLY_TRANSLATE;</span>
<span class="nc" id="L1791">            type = TYPE_TRANSLATION;</span>
        } else {
<span class="nc" id="L1793">            state = APPLY_IDENTITY;</span>
<span class="nc" id="L1794">            type = TYPE_IDENTITY;</span>
        }
<span class="nc" id="L1796">    }</span>

    /**
     * Sets this transform to a rotation transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    0   ]
     *          [   sin(theta)     cos(theta)    0   ]
     *          [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     * @param theta the angle of rotation measured in radians
     * @since 1.2
     */
    public void setToRotation(double theta) {
<span class="nc" id="L1815">        double sin = Math.sin(theta);</span>
        double cos;
<span class="nc bnc" id="L1817" title="All 4 branches missed.">        if (sin == 1.0 || sin == -1.0) {</span>
<span class="nc" id="L1818">            cos = 0.0;</span>
<span class="nc" id="L1819">            state = APPLY_SHEAR;</span>
<span class="nc" id="L1820">            type = TYPE_QUADRANT_ROTATION;</span>
        } else {
<span class="nc" id="L1822">            cos = Math.cos(theta);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (cos == -1.0) {</span>
<span class="nc" id="L1824">                sin = 0.0;</span>
<span class="nc" id="L1825">                state = APPLY_SCALE;</span>
<span class="nc" id="L1826">                type = TYPE_QUADRANT_ROTATION;</span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">            } else if (cos == 1.0) {</span>
<span class="nc" id="L1828">                sin = 0.0;</span>
<span class="nc" id="L1829">                state = APPLY_IDENTITY;</span>
<span class="nc" id="L1830">                type = TYPE_IDENTITY;</span>
            } else {
<span class="nc" id="L1832">                state = APPLY_SHEAR | APPLY_SCALE;</span>
<span class="nc" id="L1833">                type = TYPE_GENERAL_ROTATION;</span>
            }
        }
<span class="nc" id="L1836">        m00 =  cos;</span>
<span class="nc" id="L1837">        m10 =  sin;</span>
<span class="nc" id="L1838">        m01 = -sin;</span>
<span class="nc" id="L1839">        m11 =  cos;</span>
<span class="nc" id="L1840">        m02 =  0.0;</span>
<span class="nc" id="L1841">        m12 =  0.0;</span>
<span class="nc" id="L1842">    }</span>

    /**
     * Sets this transform to a translated rotation transformation.
     * This operation is equivalent to translating the coordinates so
     * that the anchor point is at the origin (S1), then rotating them
     * about the new origin (S2), and finally translating so that the
     * intermediate origin is restored to the coordinates of the original
     * anchor point (S3).
     * &lt;p&gt;
     * This operation is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *     setToTranslation(anchorx, anchory); // S3: final translation
     *     rotate(theta);                      // S2: rotate around anchor
     *     translate(-anchorx, -anchory);      // S1: translate anchor to origin
     * &lt;/pre&gt;
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
     *          [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
     *          [       0              0               1        ]
     * &lt;/pre&gt;
     * Rotating by a positive angle theta rotates points on the positive
     * X axis toward the positive Y axis.
     * Note also the discussion of
     * &lt;a href=&quot;#quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;
     * above.
     *
     * @param theta the angle of rotation measured in radians
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.2
     */
    public void setToRotation(double theta, double anchorx, double anchory) {
<span class="nc" id="L1876">        setToRotation(theta);</span>
<span class="nc" id="L1877">        double sin = m10;</span>
<span class="nc" id="L1878">        double oneMinusCos = 1.0 - m00;</span>
<span class="nc" id="L1879">        m02 = anchorx * oneMinusCos + anchory * sin;</span>
<span class="nc" id="L1880">        m12 = anchory * oneMinusCos - anchorx * sin;</span>
<span class="nc bnc" id="L1881" title="All 4 branches missed.">        if (m02 != 0.0 || m12 != 0.0) {</span>
<span class="nc" id="L1882">            state |= APPLY_TRANSLATE;</span>
<span class="nc" id="L1883">            type |= TYPE_TRANSLATION;</span>
        }
<span class="nc" id="L1885">    }</span>

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates according to a rotation vector.
     * All coordinates rotate about the origin by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(Math.atan2(vecy, vecx));
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @since 1.6
     */
    public void setToRotation(double vecx, double vecy) {
        double sin, cos;
<span class="nc bnc" id="L1907" title="All 2 branches missed.">        if (vecy == 0) {</span>
<span class="nc" id="L1908">            sin = 0.0;</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            if (vecx &lt; 0.0) {</span>
<span class="nc" id="L1910">                cos = -1.0;</span>
<span class="nc" id="L1911">                state = APPLY_SCALE;</span>
<span class="nc" id="L1912">                type = TYPE_QUADRANT_ROTATION;</span>
            } else {
<span class="nc" id="L1914">                cos = 1.0;</span>
<span class="nc" id="L1915">                state = APPLY_IDENTITY;</span>
<span class="nc" id="L1916">                type = TYPE_IDENTITY;</span>
            }
<span class="nc bnc" id="L1918" title="All 2 branches missed.">        } else if (vecx == 0) {</span>
<span class="nc" id="L1919">            cos = 0.0;</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">            sin = (vecy &gt; 0.0) ? 1.0 : -1.0;</span>
<span class="nc" id="L1921">            state = APPLY_SHEAR;</span>
<span class="nc" id="L1922">            type = TYPE_QUADRANT_ROTATION;</span>
        } else {
<span class="nc" id="L1924">            double len = Math.sqrt(vecx * vecx + vecy * vecy);</span>
<span class="nc" id="L1925">            cos = vecx / len;</span>
<span class="nc" id="L1926">            sin = vecy / len;</span>
<span class="nc" id="L1927">            state = APPLY_SHEAR | APPLY_SCALE;</span>
<span class="nc" id="L1928">            type = TYPE_GENERAL_ROTATION;</span>
        }
<span class="nc" id="L1930">        m00 =  cos;</span>
<span class="nc" id="L1931">        m10 =  sin;</span>
<span class="nc" id="L1932">        m01 = -sin;</span>
<span class="nc" id="L1933">        m11 =  cos;</span>
<span class="nc" id="L1934">        m02 =  0.0;</span>
<span class="nc" id="L1935">        m12 =  0.0;</span>
<span class="nc" id="L1936">    }</span>

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates around an anchor point according to a rotation
     * vector.
     * All coordinates rotate about the specified anchor coordinates
     * by the same amount.
     * The amount of rotation is such that coordinates along the former
     * positive X axis will subsequently align with the vector pointing
     * from the origin to the specified vector coordinates.
     * If both &lt;code&gt;vecx&lt;/code&gt; and &lt;code&gt;vecy&lt;/code&gt; are 0.0,
     * the transform is set to an identity transform.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToTranslation(Math.atan2(vecy, vecx), anchorx, anchory);
     * &lt;/pre&gt;
     *
     * @param vecx the X coordinate of the rotation vector
     * @param vecy the Y coordinate of the rotation vector
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    public void setToRotation(double vecx, double vecy,
                              double anchorx, double anchory)
    {
<span class="nc" id="L1963">        setToRotation(vecx, vecy);</span>
<span class="nc" id="L1964">        double sin = m10;</span>
<span class="nc" id="L1965">        double oneMinusCos = 1.0 - m00;</span>
<span class="nc" id="L1966">        m02 = anchorx * oneMinusCos + anchory * sin;</span>
<span class="nc" id="L1967">        m12 = anchory * oneMinusCos - anchorx * sin;</span>
<span class="nc bnc" id="L1968" title="All 4 branches missed.">        if (m02 != 0.0 || m12 != 0.0) {</span>
<span class="nc" id="L1969">            state |= APPLY_TRANSLATE;</span>
<span class="nc" id="L1970">            type |= TYPE_TRANSLATION;</span>
        }
<span class="nc" id="L1972">    }</span>

    /**
     * Sets this transform to a rotation transformation that rotates
     * coordinates by the specified number of quadrants.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(numquadrants * Math.PI / 2.0);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @since 1.6
     */
    public void setToQuadrantRotation(int numquadrants) {
<span class="nc bnc" id="L1987" title="All 5 branches missed.">        switch (numquadrants &amp; 3) {</span>
        case 0:
<span class="nc" id="L1989">            m00 =  1.0;</span>
<span class="nc" id="L1990">            m10 =  0.0;</span>
<span class="nc" id="L1991">            m01 =  0.0;</span>
<span class="nc" id="L1992">            m11 =  1.0;</span>
<span class="nc" id="L1993">            m02 =  0.0;</span>
<span class="nc" id="L1994">            m12 =  0.0;</span>
<span class="nc" id="L1995">            state = APPLY_IDENTITY;</span>
<span class="nc" id="L1996">            type = TYPE_IDENTITY;</span>
<span class="nc" id="L1997">            break;</span>
        case 1:
<span class="nc" id="L1999">            m00 =  0.0;</span>
<span class="nc" id="L2000">            m10 =  1.0;</span>
<span class="nc" id="L2001">            m01 = -1.0;</span>
<span class="nc" id="L2002">            m11 =  0.0;</span>
<span class="nc" id="L2003">            m02 =  0.0;</span>
<span class="nc" id="L2004">            m12 =  0.0;</span>
<span class="nc" id="L2005">            state = APPLY_SHEAR;</span>
<span class="nc" id="L2006">            type = TYPE_QUADRANT_ROTATION;</span>
<span class="nc" id="L2007">            break;</span>
        case 2:
<span class="nc" id="L2009">            m00 = -1.0;</span>
<span class="nc" id="L2010">            m10 =  0.0;</span>
<span class="nc" id="L2011">            m01 =  0.0;</span>
<span class="nc" id="L2012">            m11 = -1.0;</span>
<span class="nc" id="L2013">            m02 =  0.0;</span>
<span class="nc" id="L2014">            m12 =  0.0;</span>
<span class="nc" id="L2015">            state = APPLY_SCALE;</span>
<span class="nc" id="L2016">            type = TYPE_QUADRANT_ROTATION;</span>
<span class="nc" id="L2017">            break;</span>
        case 3:
<span class="nc" id="L2019">            m00 =  0.0;</span>
<span class="nc" id="L2020">            m10 = -1.0;</span>
<span class="nc" id="L2021">            m01 =  1.0;</span>
<span class="nc" id="L2022">            m11 =  0.0;</span>
<span class="nc" id="L2023">            m02 =  0.0;</span>
<span class="nc" id="L2024">            m12 =  0.0;</span>
<span class="nc" id="L2025">            state = APPLY_SHEAR;</span>
<span class="nc" id="L2026">            type = TYPE_QUADRANT_ROTATION;</span>
            break;
        }
<span class="nc" id="L2029">    }</span>

    /**
     * Sets this transform to a translated rotation transformation
     * that rotates coordinates by the specified number of quadrants
     * around the specified anchor point.
     * This operation is equivalent to calling:
     * &lt;pre&gt;
     *     setToRotation(numquadrants * Math.PI / 2.0, anchorx, anchory);
     * &lt;/pre&gt;
     * Rotating by a positive number of quadrants rotates points on
     * the positive X axis toward the positive Y axis.
     *
     * @param numquadrants the number of 90 degree arcs to rotate by
     * @param anchorx the X coordinate of the rotation anchor point
     * @param anchory the Y coordinate of the rotation anchor point
     * @since 1.6
     */
    public void setToQuadrantRotation(int numquadrants,
                                      double anchorx, double anchory)
    {
<span class="nc bnc" id="L2050" title="All 5 branches missed.">        switch (numquadrants &amp; 3) {</span>
        case 0:
<span class="nc" id="L2052">            m00 =  1.0;</span>
<span class="nc" id="L2053">            m10 =  0.0;</span>
<span class="nc" id="L2054">            m01 =  0.0;</span>
<span class="nc" id="L2055">            m11 =  1.0;</span>
<span class="nc" id="L2056">            m02 =  0.0;</span>
<span class="nc" id="L2057">            m12 =  0.0;</span>
<span class="nc" id="L2058">            state = APPLY_IDENTITY;</span>
<span class="nc" id="L2059">            type = TYPE_IDENTITY;</span>
<span class="nc" id="L2060">            break;</span>
        case 1:
<span class="nc" id="L2062">            m00 =  0.0;</span>
<span class="nc" id="L2063">            m10 =  1.0;</span>
<span class="nc" id="L2064">            m01 = -1.0;</span>
<span class="nc" id="L2065">            m11 =  0.0;</span>
<span class="nc" id="L2066">            m02 =  anchorx + anchory;</span>
<span class="nc" id="L2067">            m12 =  anchory - anchorx;</span>
<span class="nc bnc" id="L2068" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L2069">                state = APPLY_SHEAR;</span>
<span class="nc" id="L2070">                type = TYPE_QUADRANT_ROTATION;</span>
            } else {
<span class="nc" id="L2072">                state = APPLY_SHEAR | APPLY_TRANSLATE;</span>
<span class="nc" id="L2073">                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L2075">            break;</span>
        case 2:
<span class="nc" id="L2077">            m00 = -1.0;</span>
<span class="nc" id="L2078">            m10 =  0.0;</span>
<span class="nc" id="L2079">            m01 =  0.0;</span>
<span class="nc" id="L2080">            m11 = -1.0;</span>
<span class="nc" id="L2081">            m02 =  anchorx + anchorx;</span>
<span class="nc" id="L2082">            m12 =  anchory + anchory;</span>
<span class="nc bnc" id="L2083" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L2084">                state = APPLY_SCALE;</span>
<span class="nc" id="L2085">                type = TYPE_QUADRANT_ROTATION;</span>
            } else {
<span class="nc" id="L2087">                state = APPLY_SCALE | APPLY_TRANSLATE;</span>
<span class="nc" id="L2088">                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;</span>
            }
<span class="nc" id="L2090">            break;</span>
        case 3:
<span class="nc" id="L2092">            m00 =  0.0;</span>
<span class="nc" id="L2093">            m10 = -1.0;</span>
<span class="nc" id="L2094">            m01 =  1.0;</span>
<span class="nc" id="L2095">            m11 =  0.0;</span>
<span class="nc" id="L2096">            m02 =  anchorx - anchory;</span>
<span class="nc" id="L2097">            m12 =  anchory + anchorx;</span>
<span class="nc bnc" id="L2098" title="All 4 branches missed.">            if (m02 == 0.0 &amp;&amp; m12 == 0.0) {</span>
<span class="nc" id="L2099">                state = APPLY_SHEAR;</span>
<span class="nc" id="L2100">                type = TYPE_QUADRANT_ROTATION;</span>
            } else {
<span class="nc" id="L2102">                state = APPLY_SHEAR | APPLY_TRANSLATE;</span>
<span class="nc" id="L2103">                type = TYPE_QUADRANT_ROTATION | TYPE_TRANSLATION;</span>
            }
            break;
        }
<span class="nc" id="L2107">    }</span>

    /**
     * Sets this transform to a scaling transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *          [   sx   0    0   ]
     *          [   0    sy   0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param sx the factor by which coordinates are scaled along the
     * X axis direction
     * @param sy the factor by which coordinates are scaled along the
     * Y axis direction
     * @since 1.2
     */
    public void setToScale(double sx, double sy) {
<span class="nc" id="L2124">        m00 = sx;</span>
<span class="nc" id="L2125">        m10 = 0.0;</span>
<span class="nc" id="L2126">        m01 = 0.0;</span>
<span class="nc" id="L2127">        m11 = sy;</span>
<span class="nc" id="L2128">        m02 = 0.0;</span>
<span class="nc" id="L2129">        m12 = 0.0;</span>
<span class="nc bnc" id="L2130" title="All 4 branches missed.">        if (sx != 1.0 || sy != 1.0) {</span>
<span class="nc" id="L2131">            state = APPLY_SCALE;</span>
<span class="nc" id="L2132">            type = TYPE_UNKNOWN;</span>
        } else {
<span class="nc" id="L2134">            state = APPLY_IDENTITY;</span>
<span class="nc" id="L2135">            type = TYPE_IDENTITY;</span>
        }
<span class="nc" id="L2137">    }</span>

    /**
     * Sets this transform to a shearing transformation.
     * The matrix representing this transform becomes:
     * &lt;pre&gt;
     *          [   1   shx   0   ]
     *          [  shy   1    0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param shx the multiplier by which coordinates are shifted in the
     * direction of the positive X axis as a factor of their Y coordinate
     * @param shy the multiplier by which coordinates are shifted in the
     * direction of the positive Y axis as a factor of their X coordinate
     * @since 1.2
     */
    public void setToShear(double shx, double shy) {
<span class="nc" id="L2154">        m00 = 1.0;</span>
<span class="nc" id="L2155">        m01 = shx;</span>
<span class="nc" id="L2156">        m10 = shy;</span>
<span class="nc" id="L2157">        m11 = 1.0;</span>
<span class="nc" id="L2158">        m02 = 0.0;</span>
<span class="nc" id="L2159">        m12 = 0.0;</span>
<span class="nc bnc" id="L2160" title="All 4 branches missed.">        if (shx != 0.0 || shy != 0.0) {</span>
<span class="nc" id="L2161">            state = (APPLY_SHEAR | APPLY_SCALE);</span>
<span class="nc" id="L2162">            type = TYPE_UNKNOWN;</span>
        } else {
<span class="nc" id="L2164">            state = APPLY_IDENTITY;</span>
<span class="nc" id="L2165">            type = TYPE_IDENTITY;</span>
        }
<span class="nc" id="L2167">    }</span>

    /**
     * Sets this transform to a copy of the transform in the specified
     * &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @param Tx the &lt;code&gt;AffineTransform&lt;/code&gt; object from which to
     * copy the transform
     * @since 1.2
     */
    public void setTransform(AffineTransform Tx) {
<span class="nc" id="L2177">        this.m00 = Tx.m00;</span>
<span class="nc" id="L2178">        this.m10 = Tx.m10;</span>
<span class="nc" id="L2179">        this.m01 = Tx.m01;</span>
<span class="nc" id="L2180">        this.m11 = Tx.m11;</span>
<span class="nc" id="L2181">        this.m02 = Tx.m02;</span>
<span class="nc" id="L2182">        this.m12 = Tx.m12;</span>
<span class="nc" id="L2183">        this.state = Tx.state;</span>
<span class="nc" id="L2184">        this.type = Tx.type;</span>
<span class="nc" id="L2185">    }</span>

    /**
     * Sets this transform to the matrix specified by the 6
     * double precision values.
     *
     * @param m00 the X coordinate scaling element of the 3x3 matrix
     * @param m10 the Y coordinate shearing element of the 3x3 matrix
     * @param m01 the X coordinate shearing element of the 3x3 matrix
     * @param m11 the Y coordinate scaling element of the 3x3 matrix
     * @param m02 the X coordinate translation element of the 3x3 matrix
     * @param m12 the Y coordinate translation element of the 3x3 matrix
     * @since 1.2
     */
    public void setTransform(double m00, double m10,
                             double m01, double m11,
                             double m02, double m12) {
<span class="nc" id="L2202">        this.m00 = m00;</span>
<span class="nc" id="L2203">        this.m10 = m10;</span>
<span class="nc" id="L2204">        this.m01 = m01;</span>
<span class="nc" id="L2205">        this.m11 = m11;</span>
<span class="nc" id="L2206">        this.m02 = m02;</span>
<span class="nc" id="L2207">        this.m12 = m12;</span>
<span class="nc" id="L2208">        updateState();</span>
<span class="nc" id="L2209">    }</span>

    /**
     * Concatenates an &lt;code&gt;AffineTransform&lt;/code&gt; &lt;code&gt;Tx&lt;/code&gt; to
     * this &lt;code&gt;AffineTransform&lt;/code&gt; Cx in the most commonly useful
     * way to provide a new user space
     * that is mapped to the former user space by &lt;code&gt;Tx&lt;/code&gt;.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by &lt;code&gt;Tx&lt;/code&gt; and then
     * transforming the result by the original transform Cx like this:
     * Cx'(p) = Cx(Tx(p))
     * In matrix notation, if this transform Cx is
     * represented by the matrix [this] and &lt;code&gt;Tx&lt;/code&gt; is represented
     * by the matrix [Tx] then this method does the following:
     * &lt;pre&gt;
     *          [this] = [this] x [Tx]
     * &lt;/pre&gt;
     * @param Tx the &lt;code&gt;AffineTransform&lt;/code&gt; object to be
     * concatenated with this &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @see #preConcatenate
     * @since 1.2
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public void concatenate(AffineTransform Tx) {
        double M0, M1;
        double T00, T01, T10, T11;
        double T02, T12;
<span class="nc" id="L2237">        int mystate = state;</span>
<span class="nc" id="L2238">        int txstate = Tx.state;</span>
<span class="nc bnc" id="L2239" title="All 15 branches missed.">        switch ((txstate &lt;&lt; HI_SHIFT) | mystate) {</span>

            /* ---------- Tx == IDENTITY cases ---------- */
        case (HI_IDENTITY | APPLY_IDENTITY):
        case (HI_IDENTITY | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2250">            return;</span>

            /* ---------- this == IDENTITY cases ---------- */
        case (HI_SHEAR | HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
<span class="nc" id="L2254">            m01 = Tx.m01;</span>
<span class="nc" id="L2255">            m10 = Tx.m10;</span>
            /* NOBREAK */
        case (HI_SCALE | HI_TRANSLATE | APPLY_IDENTITY):
<span class="nc" id="L2258">            m00 = Tx.m00;</span>
<span class="nc" id="L2259">            m11 = Tx.m11;</span>
            /* NOBREAK */
        case (HI_TRANSLATE | APPLY_IDENTITY):
<span class="nc" id="L2262">            m02 = Tx.m02;</span>
<span class="nc" id="L2263">            m12 = Tx.m12;</span>
<span class="nc" id="L2264">            state = txstate;</span>
<span class="nc" id="L2265">            type = Tx.type;</span>
<span class="nc" id="L2266">            return;</span>
        case (HI_SHEAR | HI_SCALE | APPLY_IDENTITY):
<span class="nc" id="L2268">            m01 = Tx.m01;</span>
<span class="nc" id="L2269">            m10 = Tx.m10;</span>
            /* NOBREAK */
        case (HI_SCALE | APPLY_IDENTITY):
<span class="nc" id="L2272">            m00 = Tx.m00;</span>
<span class="nc" id="L2273">            m11 = Tx.m11;</span>
<span class="nc" id="L2274">            state = txstate;</span>
<span class="nc" id="L2275">            type = Tx.type;</span>
<span class="nc" id="L2276">            return;</span>
        case (HI_SHEAR | HI_TRANSLATE | APPLY_IDENTITY):
<span class="nc" id="L2278">            m02 = Tx.m02;</span>
<span class="nc" id="L2279">            m12 = Tx.m12;</span>
            /* NOBREAK */
        case (HI_SHEAR | APPLY_IDENTITY):
<span class="nc" id="L2282">            m01 = Tx.m01;</span>
<span class="nc" id="L2283">            m10 = Tx.m10;</span>
<span class="nc" id="L2284">            m00 = m11 = 0.0;</span>
<span class="nc" id="L2285">            state = txstate;</span>
<span class="nc" id="L2286">            type = Tx.type;</span>
<span class="nc" id="L2287">            return;</span>

            /* ---------- Tx == TRANSLATE cases ---------- */
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR):
        case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SCALE):
        case (HI_TRANSLATE | APPLY_TRANSLATE):
<span class="nc" id="L2297">            translate(Tx.m02, Tx.m12);</span>
<span class="nc" id="L2298">            return;</span>

            /* ---------- Tx == SCALE cases ---------- */
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR):
        case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SCALE):
        case (HI_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2308">            scale(Tx.m00, Tx.m11);</span>
<span class="nc" id="L2309">            return;</span>

            /* ---------- Tx == SHEAR cases ---------- */
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2314">            T01 = Tx.m01; T10 = Tx.m10;</span>
<span class="nc" id="L2315">            M0 = m00;</span>
<span class="nc" id="L2316">            m00 = m01 * T10;</span>
<span class="nc" id="L2317">            m01 = M0 * T01;</span>
<span class="nc" id="L2318">            M0 = m10;</span>
<span class="nc" id="L2319">            m10 = m11 * T10;</span>
<span class="nc" id="L2320">            m11 = M0 * T01;</span>
<span class="nc" id="L2321">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2322">            return;</span>
        case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR):
<span class="nc" id="L2325">            m00 = m01 * Tx.m10;</span>
<span class="nc" id="L2326">            m01 = 0.0;</span>
<span class="nc" id="L2327">            m11 = m10 * Tx.m01;</span>
<span class="nc" id="L2328">            m10 = 0.0;</span>
<span class="nc" id="L2329">            state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);</span>
<span class="nc" id="L2330">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2331">            return;</span>
        case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SCALE):
<span class="nc" id="L2334">            m01 = m00 * Tx.m01;</span>
<span class="nc" id="L2335">            m00 = 0.0;</span>
<span class="nc" id="L2336">            m10 = m11 * Tx.m10;</span>
<span class="nc" id="L2337">            m11 = 0.0;</span>
<span class="nc" id="L2338">            state = mystate ^ (APPLY_SHEAR | APPLY_SCALE);</span>
<span class="nc" id="L2339">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2340">            return;</span>
        case (HI_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L2342">            m00 = 0.0;</span>
<span class="nc" id="L2343">            m01 = Tx.m01;</span>
<span class="nc" id="L2344">            m10 = Tx.m10;</span>
<span class="nc" id="L2345">            m11 = 0.0;</span>
<span class="nc" id="L2346">            state = APPLY_TRANSLATE | APPLY_SHEAR;</span>
<span class="nc" id="L2347">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2348">            return;</span>
        }
        // If Tx has more than one attribute, it is not worth optimizing
        // all of those cases...
<span class="nc" id="L2352">        T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;</span>
<span class="nc" id="L2353">        T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;</span>
<span class="nc bnc" id="L2354" title="All 6 branches missed.">        switch (mystate) {</span>
        default:
<span class="nc" id="L2356">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2359">            state = mystate | txstate;</span>
            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2362">            M0 = m00;</span>
<span class="nc" id="L2363">            M1 = m01;</span>
<span class="nc" id="L2364">            m00  = T00 * M0 + T10 * M1;</span>
<span class="nc" id="L2365">            m01  = T01 * M0 + T11 * M1;</span>
<span class="nc" id="L2366">            m02 += T02 * M0 + T12 * M1;</span>

<span class="nc" id="L2368">            M0 = m10;</span>
<span class="nc" id="L2369">            M1 = m11;</span>
<span class="nc" id="L2370">            m10  = T00 * M0 + T10 * M1;</span>
<span class="nc" id="L2371">            m11  = T01 * M0 + T11 * M1;</span>
<span class="nc" id="L2372">            m12 += T02 * M0 + T12 * M1;</span>
<span class="nc" id="L2373">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2374">            return;</span>

        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L2378">            M0 = m01;</span>
<span class="nc" id="L2379">            m00  = T10 * M0;</span>
<span class="nc" id="L2380">            m01  = T11 * M0;</span>
<span class="nc" id="L2381">            m02 += T12 * M0;</span>

<span class="nc" id="L2383">            M0 = m10;</span>
<span class="nc" id="L2384">            m10  = T00 * M0;</span>
<span class="nc" id="L2385">            m11  = T01 * M0;</span>
<span class="nc" id="L2386">            m12 += T02 * M0;</span>
<span class="nc" id="L2387">            break;</span>

        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L2391">            M0 = m00;</span>
<span class="nc" id="L2392">            m00  = T00 * M0;</span>
<span class="nc" id="L2393">            m01  = T01 * M0;</span>
<span class="nc" id="L2394">            m02 += T02 * M0;</span>

<span class="nc" id="L2396">            M0 = m11;</span>
<span class="nc" id="L2397">            m10  = T10 * M0;</span>
<span class="nc" id="L2398">            m11  = T11 * M0;</span>
<span class="nc" id="L2399">            m12 += T12 * M0;</span>
<span class="nc" id="L2400">            break;</span>

        case (APPLY_TRANSLATE):
<span class="nc" id="L2403">            m00  = T00;</span>
<span class="nc" id="L2404">            m01  = T01;</span>
<span class="nc" id="L2405">            m02 += T02;</span>

<span class="nc" id="L2407">            m10  = T10;</span>
<span class="nc" id="L2408">            m11  = T11;</span>
<span class="nc" id="L2409">            m12 += T12;</span>
<span class="nc" id="L2410">            state = txstate | APPLY_TRANSLATE;</span>
<span class="nc" id="L2411">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2412">            return;</span>
        }
<span class="nc" id="L2414">        updateState();</span>
<span class="nc" id="L2415">    }</span>

    /**
     * Concatenates an &lt;code&gt;AffineTransform&lt;/code&gt; &lt;code&gt;Tx&lt;/code&gt; to
     * this &lt;code&gt;AffineTransform&lt;/code&gt; Cx
     * in a less commonly used way such that &lt;code&gt;Tx&lt;/code&gt; modifies the
     * coordinate transformation relative to the absolute pixel
     * space rather than relative to the existing user space.
     * Cx is updated to perform the combined transformation.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by the original transform
     * Cx and then transforming the result by
     * &lt;code&gt;Tx&lt;/code&gt; like this:
     * Cx'(p) = Tx(Cx(p))
     * In matrix notation, if this transform Cx
     * is represented by the matrix [this] and &lt;code&gt;Tx&lt;/code&gt; is
     * represented by the matrix [Tx] then this method does the
     * following:
     * &lt;pre&gt;
     *          [this] = [Tx] x [this]
     * &lt;/pre&gt;
     * @param Tx the &lt;code&gt;AffineTransform&lt;/code&gt; object to be
     * concatenated with this &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @see #concatenate
     * @since 1.2
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public void preConcatenate(AffineTransform Tx) {
        double M0, M1;
        double T00, T01, T10, T11;
        double T02, T12;
<span class="nc" id="L2446">        int mystate = state;</span>
<span class="nc" id="L2447">        int txstate = Tx.state;</span>
<span class="nc bnc" id="L2448" title="All 9 branches missed.">        switch ((txstate &lt;&lt; HI_SHIFT) | mystate) {</span>
        case (HI_IDENTITY | APPLY_IDENTITY):
        case (HI_IDENTITY | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE):
        case (HI_IDENTITY | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            // Tx is IDENTITY...
<span class="nc" id="L2458">            return;</span>

        case (HI_TRANSLATE | APPLY_IDENTITY):
        case (HI_TRANSLATE | APPLY_SCALE):
        case (HI_TRANSLATE | APPLY_SHEAR):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE):
            // Tx is TRANSLATE, this has no TRANSLATE
<span class="nc" id="L2465">            m02 = Tx.m02;</span>
<span class="nc" id="L2466">            m12 = Tx.m12;</span>
<span class="nc" id="L2467">            state = mystate | APPLY_TRANSLATE;</span>
<span class="nc" id="L2468">            type |= TYPE_TRANSLATION;</span>
<span class="nc" id="L2469">            return;</span>

        case (HI_TRANSLATE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_TRANSLATE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
            // Tx is TRANSLATE, this has one too
<span class="nc" id="L2476">            m02 = m02 + Tx.m02;</span>
<span class="nc" id="L2477">            m12 = m12 + Tx.m12;</span>
<span class="nc" id="L2478">            return;</span>

        case (HI_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_IDENTITY):
            // Only these two existing states need a new state
<span class="nc" id="L2483">            state = mystate | APPLY_SCALE;</span>
            /* NOBREAK */
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_SCALE):
        case (HI_SCALE | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SHEAR):
        case (HI_SCALE | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SCALE | APPLY_SCALE):
            // Tx is SCALE, this is anything
<span class="nc" id="L2492">            T00 = Tx.m00;</span>
<span class="nc" id="L2493">            T11 = Tx.m11;</span>
<span class="nc bnc" id="L2494" title="All 2 branches missed.">            if ((mystate &amp; APPLY_SHEAR) != 0) {</span>
<span class="nc" id="L2495">                m01 = m01 * T00;</span>
<span class="nc" id="L2496">                m10 = m10 * T11;</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">                if ((mystate &amp; APPLY_SCALE) != 0) {</span>
<span class="nc" id="L2498">                    m00 = m00 * T00;</span>
<span class="nc" id="L2499">                    m11 = m11 * T11;</span>
                }
            } else {
<span class="nc" id="L2502">                m00 = m00 * T00;</span>
<span class="nc" id="L2503">                m11 = m11 * T11;</span>
            }
<span class="nc bnc" id="L2505" title="All 2 branches missed.">            if ((mystate &amp; APPLY_TRANSLATE) != 0) {</span>
<span class="nc" id="L2506">                m02 = m02 * T00;</span>
<span class="nc" id="L2507">                m12 = m12 * T11;</span>
            }
<span class="nc" id="L2509">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2510">            return;</span>
        case (HI_SHEAR | APPLY_SHEAR | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR):
<span class="nc" id="L2513">            mystate = mystate | APPLY_SCALE;</span>
            /* NOBREAK */
        case (HI_SHEAR | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_IDENTITY):
        case (HI_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SCALE):
<span class="nc" id="L2519">            state = mystate ^ APPLY_SHEAR;</span>
            /* NOBREAK */
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (HI_SHEAR | APPLY_SHEAR | APPLY_SCALE):
            // Tx is SHEAR, this is anything
<span class="nc" id="L2524">            T01 = Tx.m01;</span>
<span class="nc" id="L2525">            T10 = Tx.m10;</span>

<span class="nc" id="L2527">            M0 = m00;</span>
<span class="nc" id="L2528">            m00 = m10 * T01;</span>
<span class="nc" id="L2529">            m10 = M0 * T10;</span>

<span class="nc" id="L2531">            M0 = m01;</span>
<span class="nc" id="L2532">            m01 = m11 * T01;</span>
<span class="nc" id="L2533">            m11 = M0 * T10;</span>

<span class="nc" id="L2535">            M0 = m02;</span>
<span class="nc" id="L2536">            m02 = m12 * T01;</span>
<span class="nc" id="L2537">            m12 = M0 * T10;</span>
<span class="nc" id="L2538">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2539">            return;</span>
        }
        // If Tx has more than one attribute, it is not worth optimizing
        // all of those cases...
<span class="nc" id="L2543">        T00 = Tx.m00; T01 = Tx.m01; T02 = Tx.m02;</span>
<span class="nc" id="L2544">        T10 = Tx.m10; T11 = Tx.m11; T12 = Tx.m12;</span>
<span class="nc bnc" id="L2545" title="All 9 branches missed.">        switch (mystate) {</span>
        default:
<span class="nc" id="L2547">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2550">            M0 = m02;</span>
<span class="nc" id="L2551">            M1 = m12;</span>
<span class="nc" id="L2552">            T02 += M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2553">            T12 += M0 * T10 + M1 * T11;</span>

            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2557">            m02 = T02;</span>
<span class="nc" id="L2558">            m12 = T12;</span>

<span class="nc" id="L2560">            M0 = m00;</span>
<span class="nc" id="L2561">            M1 = m10;</span>
<span class="nc" id="L2562">            m00 = M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2563">            m10 = M0 * T10 + M1 * T11;</span>

<span class="nc" id="L2565">            M0 = m01;</span>
<span class="nc" id="L2566">            M1 = m11;</span>
<span class="nc" id="L2567">            m01 = M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2568">            m11 = M0 * T10 + M1 * T11;</span>
<span class="nc" id="L2569">            break;</span>

        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L2572">            M0 = m02;</span>
<span class="nc" id="L2573">            M1 = m12;</span>
<span class="nc" id="L2574">            T02 += M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2575">            T12 += M0 * T10 + M1 * T11;</span>

            /* NOBREAK */
        case (APPLY_SHEAR):
<span class="nc" id="L2579">            m02 = T02;</span>
<span class="nc" id="L2580">            m12 = T12;</span>

<span class="nc" id="L2582">            M0 = m10;</span>
<span class="nc" id="L2583">            m00 = M0 * T01;</span>
<span class="nc" id="L2584">            m10 = M0 * T11;</span>

<span class="nc" id="L2586">            M0 = m01;</span>
<span class="nc" id="L2587">            m01 = M0 * T00;</span>
<span class="nc" id="L2588">            m11 = M0 * T10;</span>
<span class="nc" id="L2589">            break;</span>

        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2592">            M0 = m02;</span>
<span class="nc" id="L2593">            M1 = m12;</span>
<span class="nc" id="L2594">            T02 += M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2595">            T12 += M0 * T10 + M1 * T11;</span>

            /* NOBREAK */
        case (APPLY_SCALE):
<span class="nc" id="L2599">            m02 = T02;</span>
<span class="nc" id="L2600">            m12 = T12;</span>

<span class="nc" id="L2602">            M0 = m00;</span>
<span class="nc" id="L2603">            m00 = M0 * T00;</span>
<span class="nc" id="L2604">            m10 = M0 * T10;</span>

<span class="nc" id="L2606">            M0 = m11;</span>
<span class="nc" id="L2607">            m01 = M0 * T01;</span>
<span class="nc" id="L2608">            m11 = M0 * T11;</span>
<span class="nc" id="L2609">            break;</span>

        case (APPLY_TRANSLATE):
<span class="nc" id="L2612">            M0 = m02;</span>
<span class="nc" id="L2613">            M1 = m12;</span>
<span class="nc" id="L2614">            T02 += M0 * T00 + M1 * T01;</span>
<span class="nc" id="L2615">            T12 += M0 * T10 + M1 * T11;</span>

            /* NOBREAK */
        case (APPLY_IDENTITY):
<span class="nc" id="L2619">            m02 = T02;</span>
<span class="nc" id="L2620">            m12 = T12;</span>

<span class="nc" id="L2622">            m00 = T00;</span>
<span class="nc" id="L2623">            m10 = T10;</span>

<span class="nc" id="L2625">            m01 = T01;</span>
<span class="nc" id="L2626">            m11 = T11;</span>

<span class="nc" id="L2628">            state = mystate | txstate;</span>
<span class="nc" id="L2629">            type = TYPE_UNKNOWN;</span>
<span class="nc" id="L2630">            return;</span>
        }
<span class="nc" id="L2632">        updateState();</span>
<span class="nc" id="L2633">    }</span>

    /**
     * Returns an &lt;code&gt;AffineTransform&lt;/code&gt; object representing the
     * inverse transformation.
     * The inverse transform Tx' of this transform Tx
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * &lt;p&gt;
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The &lt;code&gt;getDeterminant&lt;/code&gt; method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the &lt;code&gt;createInverse&lt;/code&gt; method is called.
     * @return a new &lt;code&gt;AffineTransform&lt;/code&gt; object representing the
     * inverse transformation.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.2
     */
    public AffineTransform createInverse()
        throws NoninvertibleTransformException
    {
        double det;
<span class="nc bnc" id="L2661" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L2663">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L2665">            return null;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2667">            det = m00 * m11 - m01 * m10;</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L2669">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc" id="L2672">            return new AffineTransform( m11 / det, -m10 / det,</span>
                                       -m01 / det,  m00 / det,
                                       (m01 * m12 - m11 * m02) / det,
                                       (m10 * m02 - m00 * m12) / det,
                                       (APPLY_SHEAR |
                                        APPLY_SCALE |
                                        APPLY_TRANSLATE));
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2680">            det = m00 * m11 - m01 * m10;</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L2682">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc" id="L2685">            return new AffineTransform( m11 / det, -m10 / det,</span>
                                       -m01 / det,  m00 / det,
                                        0.0,        0.0,
                                       (APPLY_SHEAR | APPLY_SCALE));
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc bnc" id="L2690" title="All 4 branches missed.">            if (m01 == 0.0 || m10 == 0.0) {</span>
<span class="nc" id="L2691">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2693">            return new AffineTransform( 0.0,        1.0 / m01,</span>
                                        1.0 / m10,  0.0,
                                       -m12 / m10, -m02 / m01,
                                       (APPLY_SHEAR | APPLY_TRANSLATE));
        case (APPLY_SHEAR):
<span class="nc bnc" id="L2698" title="All 4 branches missed.">            if (m01 == 0.0 || m10 == 0.0) {</span>
<span class="nc" id="L2699">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2701">            return new AffineTransform(0.0,       1.0 / m01,</span>
                                       1.0 / m10, 0.0,
                                       0.0,       0.0,
                                       (APPLY_SHEAR));
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc bnc" id="L2706" title="All 4 branches missed.">            if (m00 == 0.0 || m11 == 0.0) {</span>
<span class="nc" id="L2707">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2709">            return new AffineTransform( 1.0 / m00,  0.0,</span>
                                        0.0,        1.0 / m11,
                                       -m02 / m00, -m12 / m11,
                                       (APPLY_SCALE | APPLY_TRANSLATE));
        case (APPLY_SCALE):
<span class="nc bnc" id="L2714" title="All 4 branches missed.">            if (m00 == 0.0 || m11 == 0.0) {</span>
<span class="nc" id="L2715">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2717">            return new AffineTransform(1.0 / m00, 0.0,</span>
                                       0.0,       1.0 / m11,
                                       0.0,       0.0,
                                       (APPLY_SCALE));
        case (APPLY_TRANSLATE):
<span class="nc" id="L2722">            return new AffineTransform( 1.0,  0.0,</span>
                                        0.0,  1.0,
                                       -m02, -m12,
                                       (APPLY_TRANSLATE));
        case (APPLY_IDENTITY):
<span class="nc" id="L2727">            return new AffineTransform();</span>
        }

        /* NOTREACHED */
    }

    /**
     * Sets this transform to the inverse of itself.
     * The inverse transform Tx' of this transform Tx
     * maps coordinates transformed by Tx back
     * to their original coordinates.
     * In other words, Tx'(Tx(p)) = p = Tx(Tx'(p)).
     * &lt;p&gt;
     * If this transform maps all coordinates onto a point or a line
     * then it will not have an inverse, since coordinates that do
     * not lie on the destination point or line will not have an inverse
     * mapping.
     * The &lt;code&gt;getDeterminant&lt;/code&gt; method can be used to determine if this
     * transform has no inverse, in which case an exception will be
     * thrown if the &lt;code&gt;invert&lt;/code&gt; method is called.
     * @see #getDeterminant
     * @exception NoninvertibleTransformException
     * if the matrix cannot be inverted.
     * @since 1.6
     */
    public void invert()
        throws NoninvertibleTransformException
    {
        double M00, M01, M02;
        double M10, M11, M12;
        double det;
<span class="nc bnc" id="L2758" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L2760">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L2762">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2764">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L2765">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc" id="L2766">            det = M00 * M11 - M01 * M10;</span>
<span class="nc bnc" id="L2767" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L2768">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc" id="L2771">            m00 =  M11 / det;</span>
<span class="nc" id="L2772">            m10 = -M10 / det;</span>
<span class="nc" id="L2773">            m01 = -M01 / det;</span>
<span class="nc" id="L2774">            m11 =  M00 / det;</span>
<span class="nc" id="L2775">            m02 = (M01 * M12 - M11 * M02) / det;</span>
<span class="nc" id="L2776">            m12 = (M10 * M02 - M00 * M12) / det;</span>
<span class="nc" id="L2777">            break;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2779">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L2780">            M10 = m10; M11 = m11;</span>
<span class="nc" id="L2781">            det = M00 * M11 - M01 * M10;</span>
<span class="nc bnc" id="L2782" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L2783">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc" id="L2786">            m00 =  M11 / det;</span>
<span class="nc" id="L2787">            m10 = -M10 / det;</span>
<span class="nc" id="L2788">            m01 = -M01 / det;</span>
<span class="nc" id="L2789">            m11 =  M00 / det;</span>
            // m02 = 0.0;
            // m12 = 0.0;
<span class="nc" id="L2792">            break;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L2794">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L2795">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L2796" title="All 4 branches missed.">            if (M01 == 0.0 || M10 == 0.0) {</span>
<span class="nc" id="L2797">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
            // m00 = 0.0;
<span class="nc" id="L2800">            m10 = 1.0 / M01;</span>
<span class="nc" id="L2801">            m01 = 1.0 / M10;</span>
            // m11 = 0.0;
<span class="nc" id="L2803">            m02 = -M12 / M10;</span>
<span class="nc" id="L2804">            m12 = -M02 / M01;</span>
<span class="nc" id="L2805">            break;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L2807">            M01 = m01;</span>
<span class="nc" id="L2808">            M10 = m10;</span>
<span class="nc bnc" id="L2809" title="All 4 branches missed.">            if (M01 == 0.0 || M10 == 0.0) {</span>
<span class="nc" id="L2810">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
            // m00 = 0.0;
<span class="nc" id="L2813">            m10 = 1.0 / M01;</span>
<span class="nc" id="L2814">            m01 = 1.0 / M10;</span>
            // m11 = 0.0;
            // m02 = 0.0;
            // m12 = 0.0;
<span class="nc" id="L2818">            break;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2820">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L2821">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L2822" title="All 4 branches missed.">            if (M00 == 0.0 || M11 == 0.0) {</span>
<span class="nc" id="L2823">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2825">            m00 = 1.0 / M00;</span>
            // m10 = 0.0;
            // m01 = 0.0;
<span class="nc" id="L2828">            m11 = 1.0 / M11;</span>
<span class="nc" id="L2829">            m02 = -M02 / M00;</span>
<span class="nc" id="L2830">            m12 = -M12 / M11;</span>
<span class="nc" id="L2831">            break;</span>
        case (APPLY_SCALE):
<span class="nc" id="L2833">            M00 = m00;</span>
<span class="nc" id="L2834">            M11 = m11;</span>
<span class="nc bnc" id="L2835" title="All 4 branches missed.">            if (M00 == 0.0 || M11 == 0.0) {</span>
<span class="nc" id="L2836">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L2838">            m00 = 1.0 / M00;</span>
            // m10 = 0.0;
            // m01 = 0.0;
<span class="nc" id="L2841">            m11 = 1.0 / M11;</span>
            // m02 = 0.0;
            // m12 = 0.0;
<span class="nc" id="L2844">            break;</span>
        case (APPLY_TRANSLATE):
            // m00 = 1.0;
            // m10 = 0.0;
            // m01 = 0.0;
            // m11 = 1.0;
<span class="nc" id="L2850">            m02 = -m02;</span>
<span class="nc" id="L2851">            m12 = -m12;</span>
<span class="nc" id="L2852">            break;</span>
        case (APPLY_IDENTITY):
            // m00 = 1.0;
            // m10 = 0.0;
            // m01 = 0.0;
            // m11 = 1.0;
            // m02 = 0.0;
            // m12 = 0.0;
            break;
        }
<span class="nc" id="L2862">    }</span>

    /**
     * Transforms the specified &lt;code&gt;ptSrc&lt;/code&gt; and stores the result
     * in &lt;code&gt;ptDst&lt;/code&gt;.
     * If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new {@link Point2D}
     * object is allocated and then the result of the transformation is
     * stored in this object.
     * In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the
     * transformed point, is returned for convenience.
     * If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same
     * object, the input point is correctly overwritten with
     * the transformed point.
     * @param ptSrc the specified &lt;code&gt;Point2D&lt;/code&gt; to be transformed
     * @param ptDst the specified &lt;code&gt;Point2D&lt;/code&gt; that stores the
     * result of transforming &lt;code&gt;ptSrc&lt;/code&gt;
     * @return the &lt;code&gt;ptDst&lt;/code&gt; after transforming
     * &lt;code&gt;ptSrc&lt;/code&gt; and storing the result in &lt;code&gt;ptDst&lt;/code&gt;.
     * @since 1.2
     */
    public Point2D transform(Point2D ptSrc, Point2D ptDst) {
<span class="nc bnc" id="L2883" title="All 2 branches missed.">        if (ptDst == null) {</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            if (ptSrc instanceof Point2D.Double) {</span>
<span class="nc" id="L2885">                ptDst = new Point2D.Double();</span>
            } else {
<span class="nc" id="L2887">                ptDst = new Point2D.Float();</span>
            }
        }
        // Copy source coords into local variables in case src == dst
<span class="nc" id="L2891">        double x = ptSrc.getX();</span>
<span class="nc" id="L2892">        double y = ptSrc.getY();</span>
<span class="nc bnc" id="L2893" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L2895">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L2897">            return null;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2899">            ptDst.setLocation(x * m00 + y * m01 + m02,</span>
                              x * m10 + y * m11 + m12);
<span class="nc" id="L2901">            return ptDst;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2903">            ptDst.setLocation(x * m00 + y * m01, x * m10 + y * m11);</span>
<span class="nc" id="L2904">            return ptDst;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L2906">            ptDst.setLocation(y * m01 + m02, x * m10 + m12);</span>
<span class="nc" id="L2907">            return ptDst;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L2909">            ptDst.setLocation(y * m01, x * m10);</span>
<span class="nc" id="L2910">            return ptDst;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2912">            ptDst.setLocation(x * m00 + m02, y * m11 + m12);</span>
<span class="nc" id="L2913">            return ptDst;</span>
        case (APPLY_SCALE):
<span class="nc" id="L2915">            ptDst.setLocation(x * m00, y * m11);</span>
<span class="nc" id="L2916">            return ptDst;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L2918">            ptDst.setLocation(x + m02, y + m12);</span>
<span class="nc" id="L2919">            return ptDst;</span>
        case (APPLY_IDENTITY):
<span class="nc" id="L2921">            ptDst.setLocation(x, y);</span>
<span class="nc" id="L2922">            return ptDst;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of point objects by this transform.
     * If any element of the &lt;code&gt;ptDst&lt;/code&gt; array is
     * &lt;code&gt;null&lt;/code&gt;, a new &lt;code&gt;Point2D&lt;/code&gt; object is allocated
     * and stored into that element before storing the results of the
     * transformation.
     * &lt;p&gt;
     * Note that this method does not take any precautions to
     * avoid problems caused by storing results into &lt;code&gt;Point2D&lt;/code&gt;
     * objects that will be used as the source for calculations
     * further down the source array.
     * This method does guarantee that if a specified &lt;code&gt;Point2D&lt;/code&gt;
     * object is both the source and destination for the same single point
     * transform operation then the results will not be stored until
     * the calculations are complete to avoid storing the results on
     * top of the operands.
     * If, however, the destination &lt;code&gt;Point2D&lt;/code&gt; object for one
     * operation is the same object as the source &lt;code&gt;Point2D&lt;/code&gt;
     * object for another operation further down the source array then
     * the original coordinates in that point are overwritten before
     * they can be converted.
     * @param ptSrc the array containing the source point objects
     * @param ptDst the array into which the transform point objects are
     * returned
     * @param srcOff the offset to the first point object to be
     * transformed in the source array
     * @param dstOff the offset to the location of the first
     * transformed point object that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
    public void transform(Point2D[] ptSrc, int srcOff,
                          Point2D[] ptDst, int dstOff,
                          int numPts) {
<span class="nc" id="L2962">        int state = this.state;</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">        while (--numPts &gt;= 0) {</span>
            // Copy source coords into local variables in case src == dst
<span class="nc" id="L2965">            Point2D src = ptSrc[srcOff++];</span>
<span class="nc" id="L2966">            double x = src.getX();</span>
<span class="nc" id="L2967">            double y = src.getY();</span>
<span class="nc" id="L2968">            Point2D dst = ptDst[dstOff++];</span>
<span class="nc bnc" id="L2969" title="All 2 branches missed.">            if (dst == null) {</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                if (src instanceof Point2D.Double) {</span>
<span class="nc" id="L2971">                    dst = new Point2D.Double();</span>
                } else {
<span class="nc" id="L2973">                    dst = new Point2D.Float();</span>
                }
<span class="nc" id="L2975">                ptDst[dstOff - 1] = dst;</span>
            }
<span class="nc bnc" id="L2977" title="All 9 branches missed.">            switch (state) {</span>
            default:
<span class="nc" id="L2979">                stateError();</span>
                /* NOTREACHED */
<span class="nc" id="L2981">                return;</span>
            case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2983">                dst.setLocation(x * m00 + y * m01 + m02,</span>
                                x * m10 + y * m11 + m12);
<span class="nc" id="L2985">                break;</span>
            case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L2987">                dst.setLocation(x * m00 + y * m01, x * m10 + y * m11);</span>
<span class="nc" id="L2988">                break;</span>
            case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L2990">                dst.setLocation(y * m01 + m02, x * m10 + m12);</span>
<span class="nc" id="L2991">                break;</span>
            case (APPLY_SHEAR):
<span class="nc" id="L2993">                dst.setLocation(y * m01, x * m10);</span>
<span class="nc" id="L2994">                break;</span>
            case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L2996">                dst.setLocation(x * m00 + m02, y * m11 + m12);</span>
<span class="nc" id="L2997">                break;</span>
            case (APPLY_SCALE):
<span class="nc" id="L2999">                dst.setLocation(x * m00, y * m11);</span>
<span class="nc" id="L3000">                break;</span>
            case (APPLY_TRANSLATE):
<span class="nc" id="L3002">                dst.setLocation(x + m02, y + m12);</span>
<span class="nc" id="L3003">                break;</span>
            case (APPLY_IDENTITY):
<span class="nc" id="L3005">                dst.setLocation(x, y);</span>
                break;
            }
<span class="nc" id="L3008">        }</span>

        /* NOTREACHED */
<span class="nc" id="L3011">    }</span>

    /**
     * Transforms an array of floating point coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are overwritten by a
     * previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @since 1.2
     */
    public void transform(float[] srcPts, int srcOff,
                          float[] dstPts, int dstOff,
                          int numPts) {
        double M00, M01, M02, M10, M11, M12;    // For caching
<span class="nc bnc" id="L3038" title="All 6 branches missed.">        if (dstPts == srcPts &amp;&amp;</span>
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * 2)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
<span class="nc" id="L3049">            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);</span>
            // srcPts = dstPts;         // They are known to be equal.
<span class="nc" id="L3051">            srcOff = dstOff;</span>
        }
<span class="nc bnc" id="L3053" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3055">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3057">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3059">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L3060">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3062">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3063">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3064">                dstPts[dstOff++] = (float) (M00 * x + M01 * y + M02);</span>
<span class="nc" id="L3065">                dstPts[dstOff++] = (float) (M10 * x + M11 * y + M12);</span>
<span class="nc" id="L3066">            }</span>
<span class="nc" id="L3067">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3069">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3070">            M10 = m10; M11 = m11;</span>
<span class="nc bnc" id="L3071" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3072">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3073">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3074">                dstPts[dstOff++] = (float) (M00 * x + M01 * y);</span>
<span class="nc" id="L3075">                dstPts[dstOff++] = (float) (M10 * x + M11 * y);</span>
<span class="nc" id="L3076">            }</span>
<span class="nc" id="L3077">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3079">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L3080">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L3081" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3082">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3083">                dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3084">                dstPts[dstOff++] = (float) (M10 * x + M12);</span>
<span class="nc" id="L3085">            }</span>
<span class="nc" id="L3086">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L3088">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3090">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3091">                dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++]);</span>
<span class="nc" id="L3092">                dstPts[dstOff++] = (float) (M10 * x);</span>
<span class="nc" id="L3093">            }</span>
<span class="nc" id="L3094">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3096">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L3097">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3099">                dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3100">                dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++] + M12);</span>
            }
<span class="nc" id="L3102">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L3104">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3106">                dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++]);</span>
<span class="nc" id="L3107">                dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++]);</span>
            }
<span class="nc" id="L3109">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3111">            M02 = m02; M12 = m12;</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3113">                dstPts[dstOff++] = (float) (srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3114">                dstPts[dstOff++] = (float) (srcPts[srcOff++] + M12);</span>
            }
<span class="nc" id="L3116">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3118" title="All 4 branches missed.">            if (srcPts != dstPts || srcOff != dstOff) {</span>
<span class="nc" id="L3119">                System.arraycopy(srcPts, srcOff, dstPts, dstOff,</span>
                                 numPts * 2);
            }
<span class="nc" id="L3122">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of double precision coordinates by this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
    public void transform(double[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {
        double M00, M01, M02, M10, M11, M12;    // For caching
<span class="nc bnc" id="L3153" title="All 6 branches missed.">        if (dstPts == srcPts &amp;&amp;</span>
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * 2)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
<span class="nc" id="L3164">            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);</span>
            // srcPts = dstPts;         // They are known to be equal.
<span class="nc" id="L3166">            srcOff = dstOff;</span>
        }
<span class="nc bnc" id="L3168" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3170">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3172">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3174">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L3175">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3176" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3177">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3178">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3179">                dstPts[dstOff++] = M00 * x + M01 * y + M02;</span>
<span class="nc" id="L3180">                dstPts[dstOff++] = M10 * x + M11 * y + M12;</span>
<span class="nc" id="L3181">            }</span>
<span class="nc" id="L3182">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3184">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3185">            M10 = m10; M11 = m11;</span>
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3187">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3188">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3189">                dstPts[dstOff++] = M00 * x + M01 * y;</span>
<span class="nc" id="L3190">                dstPts[dstOff++] = M10 * x + M11 * y;</span>
<span class="nc" id="L3191">            }</span>
<span class="nc" id="L3192">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3194">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L3195">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3197">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3198">                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3199">                dstPts[dstOff++] = M10 * x + M12;</span>
<span class="nc" id="L3200">            }</span>
<span class="nc" id="L3201">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L3203">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3204" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3205">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3206">                dstPts[dstOff++] = M01 * srcPts[srcOff++];</span>
<span class="nc" id="L3207">                dstPts[dstOff++] = M10 * x;</span>
<span class="nc" id="L3208">            }</span>
<span class="nc" id="L3209">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3211">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L3212">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3213" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3214">                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3215">                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;</span>
            }
<span class="nc" id="L3217">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L3219">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3220" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3221">                dstPts[dstOff++] = M00 * srcPts[srcOff++];</span>
<span class="nc" id="L3222">                dstPts[dstOff++] = M11 * srcPts[srcOff++];</span>
            }
<span class="nc" id="L3224">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3226">            M02 = m02; M12 = m12;</span>
<span class="nc bnc" id="L3227" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3228">                dstPts[dstOff++] = srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3229">                dstPts[dstOff++] = srcPts[srcOff++] + M12;</span>
            }
<span class="nc" id="L3231">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3233" title="All 4 branches missed.">            if (srcPts != dstPts || srcOff != dstOff) {</span>
<span class="nc" id="L3234">                System.arraycopy(srcPts, srcOff, dstPts, dstOff,</span>
                                 numPts * 2);
            }
<span class="nc" id="L3237">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of floating point coordinates by this transform
     * and stores the results into an array of doubles.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed point coordinates
     * are returned.  Each point is stored as a pair of x,&amp;nbsp;y
     * coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of points to be transformed
     * @since 1.2
     */
    public void transform(float[] srcPts, int srcOff,
                          double[] dstPts, int dstOff,
                          int numPts) {
        double M00, M01, M02, M10, M11, M12;    // For caching
<span class="nc bnc" id="L3264" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3266">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3268">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3270">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L3271">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3273">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3274">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3275">                dstPts[dstOff++] = M00 * x + M01 * y + M02;</span>
<span class="nc" id="L3276">                dstPts[dstOff++] = M10 * x + M11 * y + M12;</span>
<span class="nc" id="L3277">            }</span>
<span class="nc" id="L3278">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3280">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3281">            M10 = m10; M11 = m11;</span>
<span class="nc bnc" id="L3282" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3283">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3284">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3285">                dstPts[dstOff++] = M00 * x + M01 * y;</span>
<span class="nc" id="L3286">                dstPts[dstOff++] = M10 * x + M11 * y;</span>
<span class="nc" id="L3287">            }</span>
<span class="nc" id="L3288">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3290">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L3291">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L3292" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3293">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3294">                dstPts[dstOff++] = M01 * srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3295">                dstPts[dstOff++] = M10 * x + M12;</span>
<span class="nc" id="L3296">            }</span>
<span class="nc" id="L3297">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L3299">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3300" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3301">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3302">                dstPts[dstOff++] = M01 * srcPts[srcOff++];</span>
<span class="nc" id="L3303">                dstPts[dstOff++] = M10 * x;</span>
<span class="nc" id="L3304">            }</span>
<span class="nc" id="L3305">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3307">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L3308">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3309" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3310">                dstPts[dstOff++] = M00 * srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3311">                dstPts[dstOff++] = M11 * srcPts[srcOff++] + M12;</span>
            }
<span class="nc" id="L3313">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L3315">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3316" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3317">                dstPts[dstOff++] = M00 * srcPts[srcOff++];</span>
<span class="nc" id="L3318">                dstPts[dstOff++] = M11 * srcPts[srcOff++];</span>
            }
<span class="nc" id="L3320">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3322">            M02 = m02; M12 = m12;</span>
<span class="nc bnc" id="L3323" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3324">                dstPts[dstOff++] = srcPts[srcOff++] + M02;</span>
<span class="nc" id="L3325">                dstPts[dstOff++] = srcPts[srcOff++] + M12;</span>
            }
<span class="nc" id="L3327">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3329" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3330">                dstPts[dstOff++] = srcPts[srcOff++];</span>
<span class="nc" id="L3331">                dstPts[dstOff++] = srcPts[srcOff++];</span>
            }
<span class="nc" id="L3333">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of double precision coordinates by this transform
     * and stores the results into an array of floats.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @since 1.2
     */
    public void transform(double[] srcPts, int srcOff,
                          float[] dstPts, int dstOff,
                          int numPts) {
        double M00, M01, M02, M10, M11, M12;    // For caching
<span class="nc bnc" id="L3360" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3362">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3364">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3366">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L3367">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3368" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3369">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3370">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3371">                dstPts[dstOff++] = (float) (M00 * x + M01 * y + M02);</span>
<span class="nc" id="L3372">                dstPts[dstOff++] = (float) (M10 * x + M11 * y + M12);</span>
<span class="nc" id="L3373">            }</span>
<span class="nc" id="L3374">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3376">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3377">            M10 = m10; M11 = m11;</span>
<span class="nc bnc" id="L3378" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3379">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3380">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3381">                dstPts[dstOff++] = (float) (M00 * x + M01 * y);</span>
<span class="nc" id="L3382">                dstPts[dstOff++] = (float) (M10 * x + M11 * y);</span>
<span class="nc" id="L3383">            }</span>
<span class="nc" id="L3384">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3386">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L3387">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L3388" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3389">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3390">                dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3391">                dstPts[dstOff++] = (float) (M10 * x + M12);</span>
<span class="nc" id="L3392">            }</span>
<span class="nc" id="L3393">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L3395">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3396" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3397">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3398">                dstPts[dstOff++] = (float) (M01 * srcPts[srcOff++]);</span>
<span class="nc" id="L3399">                dstPts[dstOff++] = (float) (M10 * x);</span>
<span class="nc" id="L3400">            }</span>
<span class="nc" id="L3401">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3403">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L3404">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3405" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3406">                dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3407">                dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++] + M12);</span>
            }
<span class="nc" id="L3409">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L3411">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3412" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3413">                dstPts[dstOff++] = (float) (M00 * srcPts[srcOff++]);</span>
<span class="nc" id="L3414">                dstPts[dstOff++] = (float) (M11 * srcPts[srcOff++]);</span>
            }
<span class="nc" id="L3416">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3418">            M02 = m02; M12 = m12;</span>
<span class="nc bnc" id="L3419" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3420">                dstPts[dstOff++] = (float) (srcPts[srcOff++] + M02);</span>
<span class="nc" id="L3421">                dstPts[dstOff++] = (float) (srcPts[srcOff++] + M12);</span>
            }
<span class="nc" id="L3423">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3425" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3426">                dstPts[dstOff++] = (float) (srcPts[srcOff++]);</span>
<span class="nc" id="L3427">                dstPts[dstOff++] = (float) (srcPts[srcOff++]);</span>
            }
<span class="nc" id="L3429">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Inverse transforms the specified &lt;code&gt;ptSrc&lt;/code&gt; and stores the
     * result in &lt;code&gt;ptDst&lt;/code&gt;.
     * If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
     * &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the transformed
     * point, is returned for convenience.
     * If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same
     * object, the input point is correctly overwritten with the
     * transformed point.
     * @param ptSrc the point to be inverse transformed
     * @param ptDst the resulting transformed point
     * @return &lt;code&gt;ptDst&lt;/code&gt;, which contains the result of the
     * inverse transform.
     * @exception NoninvertibleTransformException  if the matrix cannot be
     *                                         inverted.
     * @since 1.2
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public Point2D inverseTransform(Point2D ptSrc, Point2D ptDst)
        throws NoninvertibleTransformException
    {
<span class="nc bnc" id="L3458" title="All 2 branches missed.">        if (ptDst == null) {</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">            if (ptSrc instanceof Point2D.Double) {</span>
<span class="nc" id="L3460">                ptDst = new Point2D.Double();</span>
            } else {
<span class="nc" id="L3462">                ptDst = new Point2D.Float();</span>
            }
        }
        // Copy source coords into local variables in case src == dst
<span class="nc" id="L3466">        double x = ptSrc.getX();</span>
<span class="nc" id="L3467">        double y = ptSrc.getY();</span>
<span class="nc bnc" id="L3468" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3470">            stateError();</span>
            /* NOTREACHED */
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3473">            x -= m02;</span>
<span class="nc" id="L3474">            y -= m12;</span>
            /* NOBREAK */
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3477">            double det = m00 * m11 - m01 * m10;</span>
<span class="nc bnc" id="L3478" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L3479">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc" id="L3482">            ptDst.setLocation((x * m11 - y * m01) / det,</span>
                              (y * m00 - x * m10) / det);
<span class="nc" id="L3484">            return ptDst;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3486">            x -= m02;</span>
<span class="nc" id="L3487">            y -= m12;</span>
            /* NOBREAK */
        case (APPLY_SHEAR):
<span class="nc bnc" id="L3490" title="All 4 branches missed.">            if (m01 == 0.0 || m10 == 0.0) {</span>
<span class="nc" id="L3491">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L3493">            ptDst.setLocation(y / m10, x / m01);</span>
<span class="nc" id="L3494">            return ptDst;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3496">            x -= m02;</span>
<span class="nc" id="L3497">            y -= m12;</span>
            /* NOBREAK */
        case (APPLY_SCALE):
<span class="nc bnc" id="L3500" title="All 4 branches missed.">            if (m00 == 0.0 || m11 == 0.0) {</span>
<span class="nc" id="L3501">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc" id="L3503">            ptDst.setLocation(x / m00, y / m11);</span>
<span class="nc" id="L3504">            return ptDst;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3506">            ptDst.setLocation(x - m02, y - m12);</span>
<span class="nc" id="L3507">            return ptDst;</span>
        case (APPLY_IDENTITY):
<span class="nc" id="L3509">            ptDst.setLocation(x, y);</span>
<span class="nc" id="L3510">            return ptDst;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Inverse transforms an array of double precision coordinates by
     * this transform.
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the specified
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source point coordinates.
     * Each point is stored as a pair of x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed point
     * coordinates are returned.  Each point is stored as a pair of
     * x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first point to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed point that is stored in the destination array
     * @param numPts the number of point objects to be transformed
     * @exception NoninvertibleTransformException  if the matrix cannot be
     *                                         inverted.
     * @since 1.2
     */
    public void inverseTransform(double[] srcPts, int srcOff,
                                 double[] dstPts, int dstOff,
                                 int numPts)
        throws NoninvertibleTransformException
    {
        double M00, M01, M02, M10, M11, M12;    // For caching
        double det;
<span class="nc bnc" id="L3547" title="All 6 branches missed.">        if (dstPts == srcPts &amp;&amp;</span>
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * 2)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
<span class="nc" id="L3558">            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);</span>
            // srcPts = dstPts;         // They are known to be equal.
<span class="nc" id="L3560">            srcOff = dstOff;</span>
        }
<span class="nc bnc" id="L3562" title="All 9 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3564">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3566">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3568">            M00 = m00; M01 = m01; M02 = m02;</span>
<span class="nc" id="L3569">            M10 = m10; M11 = m11; M12 = m12;</span>
<span class="nc" id="L3570">            det = M00 * M11 - M01 * M10;</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L3572">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc bnc" id="L3575" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3576">                double x = srcPts[srcOff++] - M02;</span>
<span class="nc" id="L3577">                double y = srcPts[srcOff++] - M12;</span>
<span class="nc" id="L3578">                dstPts[dstOff++] = (x * M11 - y * M01) / det;</span>
<span class="nc" id="L3579">                dstPts[dstOff++] = (y * M00 - x * M10) / det;</span>
<span class="nc" id="L3580">            }</span>
<span class="nc" id="L3581">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3583">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3584">            M10 = m10; M11 = m11;</span>
<span class="nc" id="L3585">            det = M00 * M11 - M01 * M10;</span>
<span class="nc bnc" id="L3586" title="All 2 branches missed.">            if (Math.abs(det) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L3587">                throw new NoninvertibleTransformException(&quot;Determinant is &quot;+</span>
                                                          det);
            }
<span class="nc bnc" id="L3590" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3591">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3592">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3593">                dstPts[dstOff++] = (x * M11 - y * M01) / det;</span>
<span class="nc" id="L3594">                dstPts[dstOff++] = (y * M00 - x * M10) / det;</span>
<span class="nc" id="L3595">            }</span>
<span class="nc" id="L3596">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
<span class="nc" id="L3598">            M01 = m01; M02 = m02;</span>
<span class="nc" id="L3599">            M10 = m10; M12 = m12;</span>
<span class="nc bnc" id="L3600" title="All 4 branches missed.">            if (M01 == 0.0 || M10 == 0.0) {</span>
<span class="nc" id="L3601">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc bnc" id="L3603" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3604">                double x = srcPts[srcOff++] - M02;</span>
<span class="nc" id="L3605">                dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M10;</span>
<span class="nc" id="L3606">                dstPts[dstOff++] = x / M01;</span>
<span class="nc" id="L3607">            }</span>
<span class="nc" id="L3608">            return;</span>
        case (APPLY_SHEAR):
<span class="nc" id="L3610">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3611" title="All 4 branches missed.">            if (M01 == 0.0 || M10 == 0.0) {</span>
<span class="nc" id="L3612">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc bnc" id="L3614" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3615">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3616">                dstPts[dstOff++] = srcPts[srcOff++] / M10;</span>
<span class="nc" id="L3617">                dstPts[dstOff++] = x / M01;</span>
<span class="nc" id="L3618">            }</span>
<span class="nc" id="L3619">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
<span class="nc" id="L3621">            M00 = m00; M02 = m02;</span>
<span class="nc" id="L3622">            M11 = m11; M12 = m12;</span>
<span class="nc bnc" id="L3623" title="All 4 branches missed.">            if (M00 == 0.0 || M11 == 0.0) {</span>
<span class="nc" id="L3624">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc bnc" id="L3626" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3627">                dstPts[dstOff++] = (srcPts[srcOff++] - M02) / M00;</span>
<span class="nc" id="L3628">                dstPts[dstOff++] = (srcPts[srcOff++] - M12) / M11;</span>
            }
<span class="nc" id="L3630">            return;</span>
        case (APPLY_SCALE):
<span class="nc" id="L3632">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3633" title="All 4 branches missed.">            if (M00 == 0.0 || M11 == 0.0) {</span>
<span class="nc" id="L3634">                throw new NoninvertibleTransformException(&quot;Determinant is 0&quot;);</span>
            }
<span class="nc bnc" id="L3636" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3637">                dstPts[dstOff++] = srcPts[srcOff++] / M00;</span>
<span class="nc" id="L3638">                dstPts[dstOff++] = srcPts[srcOff++] / M11;</span>
            }
<span class="nc" id="L3640">            return;</span>
        case (APPLY_TRANSLATE):
<span class="nc" id="L3642">            M02 = m02; M12 = m12;</span>
<span class="nc bnc" id="L3643" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3644">                dstPts[dstOff++] = srcPts[srcOff++] - M02;</span>
<span class="nc" id="L3645">                dstPts[dstOff++] = srcPts[srcOff++] - M12;</span>
            }
<span class="nc" id="L3647">            return;</span>
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3649" title="All 4 branches missed.">            if (srcPts != dstPts || srcOff != dstOff) {</span>
<span class="nc" id="L3650">                System.arraycopy(srcPts, srcOff, dstPts, dstOff,</span>
                                 numPts * 2);
            }
<span class="nc" id="L3653">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms the relative distance vector specified by
     * &lt;code&gt;ptSrc&lt;/code&gt; and stores the result in &lt;code&gt;ptDst&lt;/code&gt;.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * &lt;pre&gt;
     *  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     *  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     *  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * &lt;/pre&gt;
     * If &lt;code&gt;ptDst&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a new
     * &lt;code&gt;Point2D&lt;/code&gt; object is allocated and then the result of the
     * transform is stored in this object.
     * In either case, &lt;code&gt;ptDst&lt;/code&gt;, which contains the
     * transformed point, is returned for convenience.
     * If &lt;code&gt;ptSrc&lt;/code&gt; and &lt;code&gt;ptDst&lt;/code&gt; are the same object,
     * the input point is correctly overwritten with the transformed
     * point.
     * @param ptSrc the distance vector to be delta transformed
     * @param ptDst the resulting transformed distance vector
     * @return &lt;code&gt;ptDst&lt;/code&gt;, which contains the result of the
     * transformation.
     * @since 1.2
     */
    public Point2D deltaTransform(Point2D ptSrc, Point2D ptDst) {
<span class="nc bnc" id="L3685" title="All 2 branches missed.">        if (ptDst == null) {</span>
<span class="nc bnc" id="L3686" title="All 2 branches missed.">            if (ptSrc instanceof Point2D.Double) {</span>
<span class="nc" id="L3687">                ptDst = new Point2D.Double();</span>
            } else {
<span class="nc" id="L3689">                ptDst = new Point2D.Float();</span>
            }
        }
        // Copy source coords into local variables in case src == dst
<span class="nc" id="L3693">        double x = ptSrc.getX();</span>
<span class="nc" id="L3694">        double y = ptSrc.getY();</span>
<span class="nc bnc" id="L3695" title="All 5 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3697">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3699">            return null;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3702">            ptDst.setLocation(x * m00 + y * m01, x * m10 + y * m11);</span>
<span class="nc" id="L3703">            return ptDst;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L3706">            ptDst.setLocation(y * m01, x * m10);</span>
<span class="nc" id="L3707">            return ptDst;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L3710">            ptDst.setLocation(x * m00, y * m11);</span>
<span class="nc" id="L3711">            return ptDst;</span>
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
<span class="nc" id="L3714">            ptDst.setLocation(x, y);</span>
<span class="nc" id="L3715">            return ptDst;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Transforms an array of relative distance vectors by this
     * transform.
     * A relative distance vector is transformed without applying the
     * translation components of the affine transformation matrix
     * using the following equations:
     * &lt;pre&gt;
     *  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
     *  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
     *  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
     * &lt;/pre&gt;
     * The two coordinate array sections can be exactly the same or
     * can be overlapping sections of the same array without affecting the
     * validity of the results.
     * This method ensures that no source coordinates are
     * overwritten by a previous operation before they can be transformed.
     * The coordinates are stored in the arrays starting at the indicated
     * offset in the order &lt;code&gt;[x0, y0, x1, y1, ..., xn, yn]&lt;/code&gt;.
     * @param srcPts the array containing the source distance vectors.
     * Each vector is stored as a pair of relative x,&amp;nbsp;y coordinates.
     * @param dstPts the array into which the transformed distance vectors
     * are returned.  Each vector is stored as a pair of relative
     * x,&amp;nbsp;y coordinates.
     * @param srcOff the offset to the first vector to be transformed
     * in the source array
     * @param dstOff the offset to the location of the first
     * transformed vector that is stored in the destination array
     * @param numPts the number of vector coordinate pairs to be
     * transformed
     * @since 1.2
     */
    public void deltaTransform(double[] srcPts, int srcOff,
                               double[] dstPts, int dstOff,
                               int numPts) {
        double M00, M01, M10, M11;      // For caching
<span class="nc bnc" id="L3756" title="All 6 branches missed.">        if (dstPts == srcPts &amp;&amp;</span>
            dstOff &gt; srcOff &amp;&amp; dstOff &lt; srcOff + numPts * 2)
        {
            // If the arrays overlap partially with the destination higher
            // than the source and we transform the coordinates normally
            // we would overwrite some of the later source coordinates
            // with results of previous transformations.
            // To get around this we use arraycopy to copy the points
            // to their final destination with correct overwrite
            // handling and then transform them in place in the new
            // safer location.
<span class="nc" id="L3767">            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);</span>
            // srcPts = dstPts;         // They are known to be equal.
<span class="nc" id="L3769">            srcOff = dstOff;</span>
        }
<span class="nc bnc" id="L3771" title="All 5 branches missed.">        switch (state) {</span>
        default:
<span class="nc" id="L3773">            stateError();</span>
            /* NOTREACHED */
<span class="nc" id="L3775">            return;</span>
        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SHEAR | APPLY_SCALE):
<span class="nc" id="L3778">            M00 = m00; M01 = m01;</span>
<span class="nc" id="L3779">            M10 = m10; M11 = m11;</span>
<span class="nc bnc" id="L3780" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3781">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3782">                double y = srcPts[srcOff++];</span>
<span class="nc" id="L3783">                dstPts[dstOff++] = x * M00 + y * M01;</span>
<span class="nc" id="L3784">                dstPts[dstOff++] = x * M10 + y * M11;</span>
<span class="nc" id="L3785">            }</span>
<span class="nc" id="L3786">            return;</span>
        case (APPLY_SHEAR | APPLY_TRANSLATE):
        case (APPLY_SHEAR):
<span class="nc" id="L3789">            M01 = m01; M10 = m10;</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3791">                double x = srcPts[srcOff++];</span>
<span class="nc" id="L3792">                dstPts[dstOff++] = srcPts[srcOff++] * M01;</span>
<span class="nc" id="L3793">                dstPts[dstOff++] = x * M10;</span>
<span class="nc" id="L3794">            }</span>
<span class="nc" id="L3795">            return;</span>
        case (APPLY_SCALE | APPLY_TRANSLATE):
        case (APPLY_SCALE):
<span class="nc" id="L3798">            M00 = m00; M11 = m11;</span>
<span class="nc bnc" id="L3799" title="All 2 branches missed.">            while (--numPts &gt;= 0) {</span>
<span class="nc" id="L3800">                dstPts[dstOff++] = srcPts[srcOff++] * M00;</span>
<span class="nc" id="L3801">                dstPts[dstOff++] = srcPts[srcOff++] * M11;</span>
            }
<span class="nc" id="L3803">            return;</span>
        case (APPLY_TRANSLATE):
        case (APPLY_IDENTITY):
<span class="nc bnc" id="L3806" title="All 4 branches missed.">            if (srcPts != dstPts || srcOff != dstOff) {</span>
<span class="nc" id="L3807">                System.arraycopy(srcPts, srcOff, dstPts, dstOff,</span>
                                 numPts * 2);
            }
<span class="nc" id="L3810">            return;</span>
        }

        /* NOTREACHED */
    }

    /**
     * Returns a new {@link Shape} object defined by the geometry of the
     * specified &lt;code&gt;Shape&lt;/code&gt; after it has been transformed by
     * this transform.
     * @param pSrc the specified &lt;code&gt;Shape&lt;/code&gt; object to be
     * transformed by this transform.
     * @return a new &lt;code&gt;Shape&lt;/code&gt; object that defines the geometry
     * of the transformed &lt;code&gt;Shape&lt;/code&gt;, or null if {@code pSrc} is null.
     * @since 1.2
     */
    public Shape createTransformedShape(Shape pSrc) {
<span class="nc bnc" id="L3827" title="All 2 branches missed.">        if (pSrc == null) {</span>
<span class="nc" id="L3828">            return null;</span>
        }
<span class="nc" id="L3830">        return new Path2D.Double(pSrc, this);</span>
    }

    // Round values to sane precision for printing
    // Note that Math.sin(Math.PI) has an error of about 10^-16
    private static double _matround(double matval) {
<span class="nc" id="L3836">        return Math.rint(matval * 1E15) / 1E15;</span>
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; that represents the value of this
     * {@link Object}.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the value of this
     * &lt;code&gt;Object&lt;/code&gt;.
     * @since 1.2
     */
    public String toString() {
<span class="nc" id="L3847">        return (&quot;AffineTransform[[&quot;</span>
<span class="nc" id="L3848">                + _matround(m00) + &quot;, &quot;</span>
<span class="nc" id="L3849">                + _matround(m01) + &quot;, &quot;</span>
<span class="nc" id="L3850">                + _matround(m02) + &quot;], [&quot;</span>
<span class="nc" id="L3851">                + _matround(m10) + &quot;, &quot;</span>
<span class="nc" id="L3852">                + _matround(m11) + &quot;, &quot;</span>
<span class="nc" id="L3853">                + _matround(m12) + &quot;]]&quot;);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;AffineTransform&lt;/code&gt; is
     * an identity transform.
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;AffineTransform&lt;/code&gt; is
     * an identity transform; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public boolean isIdentity() {
<span class="nc bnc" id="L3864" title="All 4 branches missed.">        return (state == APPLY_IDENTITY || (getType() == TYPE_IDENTITY));</span>
    }

    /**
     * Returns a copy of this &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @return an &lt;code&gt;Object&lt;/code&gt; that is a copy of this
     * &lt;code&gt;AffineTransform&lt;/code&gt; object.
     * @since 1.2
     */
    public Object clone() {
        try {
<span class="nc" id="L3875">            return super.clone();</span>
<span class="nc" id="L3876">        } catch (CloneNotSupportedException e) {</span>
            // this shouldn't happen, since we are Cloneable
<span class="nc" id="L3878">            throw new InternalError(e);</span>
        }
    }

    /**
     * Returns the hashcode for this transform.
     * @return      a hash code for this transform.
     * @since 1.2
     */
    public int hashCode() {
<span class="nc" id="L3888">        long bits = Double.doubleToLongBits(m00);</span>
<span class="nc" id="L3889">        bits = bits * 31 + Double.doubleToLongBits(m01);</span>
<span class="nc" id="L3890">        bits = bits * 31 + Double.doubleToLongBits(m02);</span>
<span class="nc" id="L3891">        bits = bits * 31 + Double.doubleToLongBits(m10);</span>
<span class="nc" id="L3892">        bits = bits * 31 + Double.doubleToLongBits(m11);</span>
<span class="nc" id="L3893">        bits = bits * 31 + Double.doubleToLongBits(m12);</span>
<span class="nc" id="L3894">        return (((int) bits) ^ ((int) (bits &gt;&gt; 32)));</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;AffineTransform&lt;/code&gt;
     * represents the same affine coordinate transform as the specified
     * argument.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to test for equality with this
     * &lt;code&gt;AffineTransform&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; equals this
     * &lt;code&gt;AffineTransform&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L3908" title="All 2 branches missed.">        if (!(obj instanceof AffineTransform)) {</span>
<span class="nc" id="L3909">            return false;</span>
        }

<span class="nc" id="L3912">        AffineTransform a = (AffineTransform)obj;</span>

<span class="nc bnc" id="L3914" title="All 12 branches missed.">        return ((m00 == a.m00) &amp;&amp; (m01 == a.m01) &amp;&amp; (m02 == a.m02) &amp;&amp;</span>
                (m10 == a.m10) &amp;&amp; (m11 == a.m11) &amp;&amp; (m12 == a.m12));
    }

    /* Serialization support.  A readObject method is neccessary because
     * the state field is part of the implementation of this particular
     * AffineTransform and not part of the public specification.  The
     * state variable's value needs to be recalculated on the fly by the
     * readObject method as it is in the 6-argument matrix constructor.
     */

    /*
     * JDK 1.2 serialVersionUID
     */
    private static final long serialVersionUID = 1330973210523860834L;

    private void writeObject(java.io.ObjectOutputStream s)
        throws java.lang.ClassNotFoundException, java.io.IOException
    {
<span class="nc" id="L3933">        s.defaultWriteObject();</span>
<span class="nc" id="L3934">    }</span>

    private void readObject(java.io.ObjectInputStream s)
        throws java.lang.ClassNotFoundException, java.io.IOException
    {
<span class="nc" id="L3939">        s.defaultReadObject();</span>
<span class="nc" id="L3940">        updateState();</span>
<span class="nc" id="L3941">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>