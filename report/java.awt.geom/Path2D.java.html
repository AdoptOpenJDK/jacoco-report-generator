<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Path2D.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.geom</a> &gt; <span class="el_source">Path2D.java</span></div><h1>Path2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.geom;

import java.awt.Shape;
import java.awt.Rectangle;
import sun.awt.geom.Curve;
import java.io.Serializable;
import java.io.StreamCorruptedException;
import java.util.Arrays;

/**
 * The {@code Path2D} class provides a simple, yet flexible
 * shape which represents an arbitrary geometric path.
 * It can fully represent any path which can be iterated by the
 * {@link PathIterator} interface including all of its segment
 * types and winding rules and it implements all of the
 * basic hit testing methods of the {@link Shape} interface.
 * &lt;p&gt;
 * Use {@link Path2D.Float} when dealing with data that can be represented
 * and used with floating point precision.  Use {@link Path2D.Double}
 * for data that requires the accuracy or range of double precision.
 * &lt;p&gt;
 * {@code Path2D} provides exactly those facilities required for
 * basic construction and management of a geometric path and
 * implementation of the above interfaces with little added
 * interpretation.
 * If it is useful to manipulate the interiors of closed
 * geometric shapes beyond simple hit testing then the
 * {@link Area} class provides additional capabilities
 * specifically targeted at closed figures.
 * While both classes nominally implement the {@code Shape}
 * interface, they differ in purpose and together they provide
 * two useful views of a geometric shape where {@code Path2D}
 * deals primarily with a trajectory formed by path segments
 * and {@code Area} deals more with interpretation and manipulation
 * of enclosed regions of 2D geometric space.
 * &lt;p&gt;
 * The {@link PathIterator} interface has more detailed descriptions
 * of the types of segments that make up a path and the winding rules
 * that control how to determine which regions are inside or outside
 * the path.
 *
 * @author Jim Graham
 * @since 1.6
 */
public abstract class Path2D implements Shape, Cloneable {
    /**
     * An even-odd winding rule for determining the interior of
     * a path.
     *
     * @see PathIterator#WIND_EVEN_ODD
     * @since 1.6
     */
    public static final int WIND_EVEN_ODD = PathIterator.WIND_EVEN_ODD;

    /**
     * A non-zero winding rule for determining the interior of a
     * path.
     *
     * @see PathIterator#WIND_NON_ZERO
     * @since 1.6
     */
    public static final int WIND_NON_ZERO = PathIterator.WIND_NON_ZERO;

    // For code simplicity, copy these constants to our namespace
    // and cast them to byte constants for easy storage.
    private static final byte SEG_MOVETO  = (byte) PathIterator.SEG_MOVETO;
    private static final byte SEG_LINETO  = (byte) PathIterator.SEG_LINETO;
    private static final byte SEG_QUADTO  = (byte) PathIterator.SEG_QUADTO;
    private static final byte SEG_CUBICTO = (byte) PathIterator.SEG_CUBICTO;
    private static final byte SEG_CLOSE   = (byte) PathIterator.SEG_CLOSE;

    transient byte[] pointTypes;
    transient int numTypes;
    transient int numCoords;
    transient int windingRule;

    static final int INIT_SIZE = 20;
    static final int EXPAND_MAX = 500;

    /**
     * Constructs a new empty {@code Path2D} object.
     * It is assumed that the package sibling subclass that is
     * defaulting to this constructor will fill in all values.
     *
     * @since 1.6
     */
    /* private protected */
<span class="nc" id="L113">    Path2D() {</span>
<span class="nc" id="L114">    }</span>

    /**
     * Constructs a new {@code Path2D} object from the given
     * specified initial values.
     * This method is only intended for internal use and should
     * not be made public if the other constructors for this class
     * are ever exposed.
     *
     * @param rule the winding rule
     * @param initialTypes the size to make the initial array to
     *                     store the path segment types
     * @since 1.6
     */
    /* private protected */
<span class="nc" id="L129">    Path2D(int rule, int initialTypes) {</span>
<span class="nc" id="L130">        setWindingRule(rule);</span>
<span class="nc" id="L131">        this.pointTypes = new byte[initialTypes];</span>
<span class="nc" id="L132">    }</span>

    abstract float[] cloneCoordsFloat(AffineTransform at);
    abstract double[] cloneCoordsDouble(AffineTransform at);
    abstract void append(float x, float y);
    abstract void append(double x, double y);
    abstract Point2D getPoint(int coordindex);
    abstract void needRoom(boolean needMove, int newCoords);
    abstract int pointCrossings(double px, double py);
    abstract int rectCrossings(double rxmin, double rymin,
                               double rxmax, double rymax);

    /**
     * The {@code Float} class defines a geometric path with
     * coordinates stored in single precision floating point.
     *
     * @since 1.6
     */
    public static class Float extends Path2D implements Serializable {
        transient float floatCoords[];

        /**
         * Constructs a new empty single precision {@code Path2D} object
         * with a default winding rule of {@link #WIND_NON_ZERO}.
         *
         * @since 1.6
         */
        public Float() {
<span class="nc" id="L160">            this(WIND_NON_ZERO, INIT_SIZE);</span>
<span class="nc" id="L161">        }</span>

        /**
         * Constructs a new empty single precision {@code Path2D} object
         * with the specified winding rule to control operations that
         * require the interior of the path to be defined.
         *
         * @param rule the winding rule
         * @see #WIND_EVEN_ODD
         * @see #WIND_NON_ZERO
         * @since 1.6
         */
        public Float(int rule) {
<span class="nc" id="L174">            this(rule, INIT_SIZE);</span>
<span class="nc" id="L175">        }</span>

        /**
         * Constructs a new empty single precision {@code Path2D} object
         * with the specified winding rule and the specified initial
         * capacity to store path segments.
         * This number is an initial guess as to how many path segments
         * will be added to the path, but the storage is expanded as
         * needed to store whatever path segments are added.
         *
         * @param rule the winding rule
         * @param initialCapacity the estimate for the number of path segments
         *                        in the path
         * @see #WIND_EVEN_ODD
         * @see #WIND_NON_ZERO
         * @since 1.6
         */
        public Float(int rule, int initialCapacity) {
<span class="nc" id="L193">            super(rule, initialCapacity);</span>
<span class="nc" id="L194">            floatCoords = new float[initialCapacity * 2];</span>
<span class="nc" id="L195">        }</span>

        /**
         * Constructs a new single precision {@code Path2D} object
         * from an arbitrary {@link Shape} object.
         * All of the initial geometry and the winding rule for this path are
         * taken from the specified {@code Shape} object.
         *
         * @param s the specified {@code Shape} object
         * @since 1.6
         */
        public Float(Shape s) {
<span class="nc" id="L207">            this(s, null);</span>
<span class="nc" id="L208">        }</span>

        /**
         * Constructs a new single precision {@code Path2D} object
         * from an arbitrary {@link Shape} object, transformed by an
         * {@link AffineTransform} object.
         * All of the initial geometry and the winding rule for this path are
         * taken from the specified {@code Shape} object and transformed
         * by the specified {@code AffineTransform} object.
         *
         * @param s the specified {@code Shape} object
         * @param at the specified {@code AffineTransform} object
         * @since 1.6
         */
<span class="nc" id="L222">        public Float(Shape s, AffineTransform at) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if (s instanceof Path2D) {</span>
<span class="nc" id="L224">                Path2D p2d = (Path2D) s;</span>
<span class="nc" id="L225">                setWindingRule(p2d.windingRule);</span>
<span class="nc" id="L226">                this.numTypes = p2d.numTypes;</span>
<span class="nc" id="L227">                this.pointTypes = Arrays.copyOf(p2d.pointTypes,</span>
                                                p2d.pointTypes.length);
<span class="nc" id="L229">                this.numCoords = p2d.numCoords;</span>
<span class="nc" id="L230">                this.floatCoords = p2d.cloneCoordsFloat(at);</span>
<span class="nc" id="L231">            } else {</span>
<span class="nc" id="L232">                PathIterator pi = s.getPathIterator(at);</span>
<span class="nc" id="L233">                setWindingRule(pi.getWindingRule());</span>
<span class="nc" id="L234">                this.pointTypes = new byte[INIT_SIZE];</span>
<span class="nc" id="L235">                this.floatCoords = new float[INIT_SIZE * 2];</span>
<span class="nc" id="L236">                append(pi, false);</span>
            }
<span class="nc" id="L238">        }</span>

        float[] cloneCoordsFloat(AffineTransform at) {
            float ret[];
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc" id="L243">                ret = Arrays.copyOf(this.floatCoords, this.floatCoords.length);</span>
            } else {
<span class="nc" id="L245">                ret = new float[floatCoords.length];</span>
<span class="nc" id="L246">                at.transform(floatCoords, 0, ret, 0, numCoords / 2);</span>
            }
<span class="nc" id="L248">            return ret;</span>
        }

        double[] cloneCoordsDouble(AffineTransform at) {
<span class="nc" id="L252">            double ret[] = new double[floatCoords.length];</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                for (int i = 0; i &lt; numCoords; i++) {</span>
<span class="nc" id="L255">                    ret[i] = floatCoords[i];</span>
                }
            } else {
<span class="nc" id="L258">                at.transform(floatCoords, 0, ret, 0, numCoords / 2);</span>
            }
<span class="nc" id="L260">            return ret;</span>
        }

        void append(float x, float y) {
<span class="nc" id="L264">            floatCoords[numCoords++] = x;</span>
<span class="nc" id="L265">            floatCoords[numCoords++] = y;</span>
<span class="nc" id="L266">        }</span>

        void append(double x, double y) {
<span class="nc" id="L269">            floatCoords[numCoords++] = (float) x;</span>
<span class="nc" id="L270">            floatCoords[numCoords++] = (float) y;</span>
<span class="nc" id="L271">        }</span>

        Point2D getPoint(int coordindex) {
<span class="nc" id="L274">            return new Point2D.Float(floatCoords[coordindex],</span>
                                     floatCoords[coordindex+1]);
        }

        void needRoom(boolean needMove, int newCoords) {
<span class="nc bnc" id="L279" title="All 4 branches missed.">            if (needMove &amp;&amp; numTypes == 0) {</span>
<span class="nc" id="L280">                throw new IllegalPathStateException(&quot;missing initial moveto &quot;+</span>
                                                    &quot;in path definition&quot;);
            }
<span class="nc" id="L283">            int size = pointTypes.length;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            if (numTypes &gt;= size) {</span>
<span class="nc" id="L285">                int grow = size;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (grow &gt; EXPAND_MAX) {</span>
<span class="nc" id="L287">                    grow = EXPAND_MAX;</span>
                }
<span class="nc" id="L289">                pointTypes = Arrays.copyOf(pointTypes, size+grow);</span>
            }
<span class="nc" id="L291">            size = floatCoords.length;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (numCoords + newCoords &gt; size) {</span>
<span class="nc" id="L293">                int grow = size;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                if (grow &gt; EXPAND_MAX * 2) {</span>
<span class="nc" id="L295">                    grow = EXPAND_MAX * 2;</span>
                }
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (grow &lt; newCoords) {</span>
<span class="nc" id="L298">                    grow = newCoords;</span>
                }
<span class="nc" id="L300">                floatCoords = Arrays.copyOf(floatCoords, size+grow);</span>
            }
<span class="nc" id="L302">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void moveTo(double x, double y) {
<span class="nc bnc" id="L309" title="All 4 branches missed.">            if (numTypes &gt; 0 &amp;&amp; pointTypes[numTypes - 1] == SEG_MOVETO) {</span>
<span class="nc" id="L310">                floatCoords[numCoords-2] = (float) x;</span>
<span class="nc" id="L311">                floatCoords[numCoords-1] = (float) y;</span>
            } else {
<span class="nc" id="L313">                needRoom(false, 2);</span>
<span class="nc" id="L314">                pointTypes[numTypes++] = SEG_MOVETO;</span>
<span class="nc" id="L315">                floatCoords[numCoords++] = (float) x;</span>
<span class="nc" id="L316">                floatCoords[numCoords++] = (float) y;</span>
            }
<span class="nc" id="L318">        }</span>

        /**
         * Adds a point to the path by moving to the specified
         * coordinates specified in float precision.
         * &lt;p&gt;
         * This method provides a single precision variant of
         * the double precision {@code moveTo()} method on the
         * base {@code Path2D} class.
         *
         * @param x the specified X coordinate
         * @param y the specified Y coordinate
         * @see Path2D#moveTo
         * @since 1.6
         */
        public final synchronized void moveTo(float x, float y) {
<span class="nc bnc" id="L334" title="All 4 branches missed.">            if (numTypes &gt; 0 &amp;&amp; pointTypes[numTypes - 1] == SEG_MOVETO) {</span>
<span class="nc" id="L335">                floatCoords[numCoords-2] = x;</span>
<span class="nc" id="L336">                floatCoords[numCoords-1] = y;</span>
            } else {
<span class="nc" id="L338">                needRoom(false, 2);</span>
<span class="nc" id="L339">                pointTypes[numTypes++] = SEG_MOVETO;</span>
<span class="nc" id="L340">                floatCoords[numCoords++] = x;</span>
<span class="nc" id="L341">                floatCoords[numCoords++] = y;</span>
            }
<span class="nc" id="L343">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void lineTo(double x, double y) {
<span class="nc" id="L350">            needRoom(true, 2);</span>
<span class="nc" id="L351">            pointTypes[numTypes++] = SEG_LINETO;</span>
<span class="nc" id="L352">            floatCoords[numCoords++] = (float) x;</span>
<span class="nc" id="L353">            floatCoords[numCoords++] = (float) y;</span>
<span class="nc" id="L354">        }</span>

        /**
         * Adds a point to the path by drawing a straight line from the
         * current coordinates to the new specified coordinates
         * specified in float precision.
         * &lt;p&gt;
         * This method provides a single precision variant of
         * the double precision {@code lineTo()} method on the
         * base {@code Path2D} class.
         *
         * @param x the specified X coordinate
         * @param y the specified Y coordinate
         * @see Path2D#lineTo
         * @since 1.6
         */
        public final synchronized void lineTo(float x, float y) {
<span class="nc" id="L371">            needRoom(true, 2);</span>
<span class="nc" id="L372">            pointTypes[numTypes++] = SEG_LINETO;</span>
<span class="nc" id="L373">            floatCoords[numCoords++] = x;</span>
<span class="nc" id="L374">            floatCoords[numCoords++] = y;</span>
<span class="nc" id="L375">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void quadTo(double x1, double y1,
                                              double x2, double y2)
        {
<span class="nc" id="L384">            needRoom(true, 4);</span>
<span class="nc" id="L385">            pointTypes[numTypes++] = SEG_QUADTO;</span>
<span class="nc" id="L386">            floatCoords[numCoords++] = (float) x1;</span>
<span class="nc" id="L387">            floatCoords[numCoords++] = (float) y1;</span>
<span class="nc" id="L388">            floatCoords[numCoords++] = (float) x2;</span>
<span class="nc" id="L389">            floatCoords[numCoords++] = (float) y2;</span>
<span class="nc" id="L390">        }</span>

        /**
         * Adds a curved segment, defined by two new points, to the path by
         * drawing a Quadratic curve that intersects both the current
         * coordinates and the specified coordinates {@code (x2,y2)},
         * using the specified point {@code (x1,y1)} as a quadratic
         * parametric control point.
         * All coordinates are specified in float precision.
         * &lt;p&gt;
         * This method provides a single precision variant of
         * the double precision {@code quadTo()} method on the
         * base {@code Path2D} class.
         *
         * @param x1 the X coordinate of the quadratic control point
         * @param y1 the Y coordinate of the quadratic control point
         * @param x2 the X coordinate of the final end point
         * @param y2 the Y coordinate of the final end point
         * @see Path2D#quadTo
         * @since 1.6
         */
        public final synchronized void quadTo(float x1, float y1,
                                              float x2, float y2)
        {
<span class="nc" id="L414">            needRoom(true, 4);</span>
<span class="nc" id="L415">            pointTypes[numTypes++] = SEG_QUADTO;</span>
<span class="nc" id="L416">            floatCoords[numCoords++] = x1;</span>
<span class="nc" id="L417">            floatCoords[numCoords++] = y1;</span>
<span class="nc" id="L418">            floatCoords[numCoords++] = x2;</span>
<span class="nc" id="L419">            floatCoords[numCoords++] = y2;</span>
<span class="nc" id="L420">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void curveTo(double x1, double y1,
                                               double x2, double y2,
                                               double x3, double y3)
        {
<span class="nc" id="L430">            needRoom(true, 6);</span>
<span class="nc" id="L431">            pointTypes[numTypes++] = SEG_CUBICTO;</span>
<span class="nc" id="L432">            floatCoords[numCoords++] = (float) x1;</span>
<span class="nc" id="L433">            floatCoords[numCoords++] = (float) y1;</span>
<span class="nc" id="L434">            floatCoords[numCoords++] = (float) x2;</span>
<span class="nc" id="L435">            floatCoords[numCoords++] = (float) y2;</span>
<span class="nc" id="L436">            floatCoords[numCoords++] = (float) x3;</span>
<span class="nc" id="L437">            floatCoords[numCoords++] = (float) y3;</span>
<span class="nc" id="L438">        }</span>

        /**
         * Adds a curved segment, defined by three new points, to the path by
         * drawing a B&amp;eacute;zier curve that intersects both the current
         * coordinates and the specified coordinates {@code (x3,y3)},
         * using the specified points {@code (x1,y1)} and {@code (x2,y2)} as
         * B&amp;eacute;zier control points.
         * All coordinates are specified in float precision.
         * &lt;p&gt;
         * This method provides a single precision variant of
         * the double precision {@code curveTo()} method on the
         * base {@code Path2D} class.
         *
         * @param x1 the X coordinate of the first B&amp;eacute;zier control point
         * @param y1 the Y coordinate of the first B&amp;eacute;zier control point
         * @param x2 the X coordinate of the second B&amp;eacute;zier control point
         * @param y2 the Y coordinate of the second B&amp;eacute;zier control point
         * @param x3 the X coordinate of the final end point
         * @param y3 the Y coordinate of the final end point
         * @see Path2D#curveTo
         * @since 1.6
         */
        public final synchronized void curveTo(float x1, float y1,
                                               float x2, float y2,
                                               float x3, float y3)
        {
<span class="nc" id="L465">            needRoom(true, 6);</span>
<span class="nc" id="L466">            pointTypes[numTypes++] = SEG_CUBICTO;</span>
<span class="nc" id="L467">            floatCoords[numCoords++] = x1;</span>
<span class="nc" id="L468">            floatCoords[numCoords++] = y1;</span>
<span class="nc" id="L469">            floatCoords[numCoords++] = x2;</span>
<span class="nc" id="L470">            floatCoords[numCoords++] = y2;</span>
<span class="nc" id="L471">            floatCoords[numCoords++] = x3;</span>
<span class="nc" id="L472">            floatCoords[numCoords++] = y3;</span>
<span class="nc" id="L473">        }</span>

        int pointCrossings(double px, double py) {
            double movx, movy, curx, cury, endx, endy;
<span class="nc" id="L477">            float coords[] = floatCoords;</span>
<span class="nc" id="L478">            curx = movx = coords[0];</span>
<span class="nc" id="L479">            cury = movy = coords[1];</span>
<span class="nc" id="L480">            int crossings = 0;</span>
<span class="nc" id="L481">            int ci = 2;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            for (int i = 1; i &lt; numTypes; i++) {</span>
<span class="nc bnc" id="L483" title="All 6 branches missed.">                switch (pointTypes[i]) {</span>
                case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L485" title="All 2 branches missed.">                    if (cury != movy) {</span>
<span class="nc" id="L486">                        crossings +=</span>
<span class="nc" id="L487">                            Curve.pointCrossingsForLine(px, py,</span>
                                                        curx, cury,
                                                        movx, movy);
                    }
<span class="nc" id="L491">                    movx = curx = coords[ci++];</span>
<span class="nc" id="L492">                    movy = cury = coords[ci++];</span>
<span class="nc" id="L493">                    break;</span>
                case PathIterator.SEG_LINETO:
<span class="nc" id="L495">                    crossings +=</span>
<span class="nc" id="L496">                        Curve.pointCrossingsForLine(px, py,</span>
                                                    curx, cury,
                                                    endx = coords[ci++],
                                                    endy = coords[ci++]);
<span class="nc" id="L500">                    curx = endx;</span>
<span class="nc" id="L501">                    cury = endy;</span>
<span class="nc" id="L502">                    break;</span>
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L504">                    crossings +=</span>
<span class="nc" id="L505">                        Curve.pointCrossingsForQuad(px, py,</span>
                                                    curx, cury,
                                                    coords[ci++],
                                                    coords[ci++],
                                                    endx = coords[ci++],
                                                    endy = coords[ci++],
                                                    0);
<span class="nc" id="L512">                    curx = endx;</span>
<span class="nc" id="L513">                    cury = endy;</span>
<span class="nc" id="L514">                    break;</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L516">                    crossings +=</span>
<span class="nc" id="L517">                        Curve.pointCrossingsForCubic(px, py,</span>
                                                     curx, cury,
                                                     coords[ci++],
                                                     coords[ci++],
                                                     coords[ci++],
                                                     coords[ci++],
                                                     endx = coords[ci++],
                                                     endy = coords[ci++],
                                                     0);
<span class="nc" id="L526">                    curx = endx;</span>
<span class="nc" id="L527">                    cury = endy;</span>
<span class="nc" id="L528">                    break;</span>
                case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L530" title="All 2 branches missed.">                    if (cury != movy) {</span>
<span class="nc" id="L531">                        crossings +=</span>
<span class="nc" id="L532">                            Curve.pointCrossingsForLine(px, py,</span>
                                                        curx, cury,
                                                        movx, movy);
                    }
<span class="nc" id="L536">                    curx = movx;</span>
<span class="nc" id="L537">                    cury = movy;</span>
                    break;
                }
            }
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (cury != movy) {</span>
<span class="nc" id="L542">                crossings +=</span>
<span class="nc" id="L543">                    Curve.pointCrossingsForLine(px, py,</span>
                                                curx, cury,
                                                movx, movy);
            }
<span class="nc" id="L547">            return crossings;</span>
        }

        int rectCrossings(double rxmin, double rymin,
                          double rxmax, double rymax)
        {
<span class="nc" id="L553">            float coords[] = floatCoords;</span>
            double curx, cury, movx, movy, endx, endy;
<span class="nc" id="L555">            curx = movx = coords[0];</span>
<span class="nc" id="L556">            cury = movy = coords[1];</span>
<span class="nc" id="L557">            int crossings = 0;</span>
<span class="nc" id="L558">            int ci = 2;</span>
<span class="nc" id="L559">            for (int i = 1;</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">                 crossings != Curve.RECT_INTERSECTS &amp;&amp; i &lt; numTypes;</span>
<span class="nc" id="L561">                 i++)</span>
            {
<span class="nc bnc" id="L563" title="All 6 branches missed.">                switch (pointTypes[i]) {</span>
                case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L565" title="All 4 branches missed.">                    if (curx != movx || cury != movy) {</span>
<span class="nc" id="L566">                        crossings =</span>
<span class="nc" id="L567">                            Curve.rectCrossingsForLine(crossings,</span>
                                                       rxmin, rymin,
                                                       rxmax, rymax,
                                                       curx, cury,
                                                       movx, movy);
                    }
                    // Count should always be a multiple of 2 here.
                    // assert((crossings &amp; 1) != 0);
<span class="nc" id="L575">                    movx = curx = coords[ci++];</span>
<span class="nc" id="L576">                    movy = cury = coords[ci++];</span>
<span class="nc" id="L577">                    break;</span>
                case PathIterator.SEG_LINETO:
<span class="nc" id="L579">                    crossings =</span>
<span class="nc" id="L580">                        Curve.rectCrossingsForLine(crossings,</span>
                                                   rxmin, rymin,
                                                   rxmax, rymax,
                                                   curx, cury,
                                                   endx = coords[ci++],
                                                   endy = coords[ci++]);
<span class="nc" id="L586">                    curx = endx;</span>
<span class="nc" id="L587">                    cury = endy;</span>
<span class="nc" id="L588">                    break;</span>
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L590">                    crossings =</span>
<span class="nc" id="L591">                        Curve.rectCrossingsForQuad(crossings,</span>
                                                   rxmin, rymin,
                                                   rxmax, rymax,
                                                   curx, cury,
                                                   coords[ci++],
                                                   coords[ci++],
                                                   endx = coords[ci++],
                                                   endy = coords[ci++],
                                                   0);
<span class="nc" id="L600">                    curx = endx;</span>
<span class="nc" id="L601">                    cury = endy;</span>
<span class="nc" id="L602">                    break;</span>
                case PathIterator.SEG_CUBICTO:
<span class="nc" id="L604">                    crossings =</span>
<span class="nc" id="L605">                        Curve.rectCrossingsForCubic(crossings,</span>
                                                    rxmin, rymin,
                                                    rxmax, rymax,
                                                    curx, cury,
                                                    coords[ci++],
                                                    coords[ci++],
                                                    coords[ci++],
                                                    coords[ci++],
                                                    endx = coords[ci++],
                                                    endy = coords[ci++],
                                                    0);
<span class="nc" id="L616">                    curx = endx;</span>
<span class="nc" id="L617">                    cury = endy;</span>
<span class="nc" id="L618">                    break;</span>
                case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L620" title="All 4 branches missed.">                    if (curx != movx || cury != movy) {</span>
<span class="nc" id="L621">                        crossings =</span>
<span class="nc" id="L622">                            Curve.rectCrossingsForLine(crossings,</span>
                                                       rxmin, rymin,
                                                       rxmax, rymax,
                                                       curx, cury,
                                                       movx, movy);
                    }
<span class="nc" id="L628">                    curx = movx;</span>
<span class="nc" id="L629">                    cury = movy;</span>
                    // Count should always be a multiple of 2 here.
                    // assert((crossings &amp; 1) != 0);
                    break;
                }
            }
<span class="nc bnc" id="L635" title="All 6 branches missed.">            if (crossings != Curve.RECT_INTERSECTS &amp;&amp;</span>
                (curx != movx || cury != movy))
            {
<span class="nc" id="L638">                crossings =</span>
<span class="nc" id="L639">                    Curve.rectCrossingsForLine(crossings,</span>
                                               rxmin, rymin,
                                               rxmax, rymax,
                                               curx, cury,
                                               movx, movy);
            }
            // Count should always be a multiple of 2 here.
            // assert((crossings &amp; 1) != 0);
<span class="nc" id="L647">            return crossings;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final void append(PathIterator pi, boolean connect) {
<span class="nc" id="L655">            float coords[] = new float[6];</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            while (!pi.isDone()) {</span>
<span class="nc bnc" id="L657" title="All 6 branches missed.">                switch (pi.currentSegment(coords)) {</span>
                case SEG_MOVETO:
<span class="nc bnc" id="L659" title="All 6 branches missed.">                    if (!connect || numTypes &lt; 1 || numCoords &lt; 1) {</span>
<span class="nc" id="L660">                        moveTo(coords[0], coords[1]);</span>
<span class="nc" id="L661">                        break;</span>
                    }
<span class="nc bnc" id="L663" title="All 6 branches missed.">                    if (pointTypes[numTypes - 1] != SEG_CLOSE &amp;&amp;</span>
                        floatCoords[numCoords-2] == coords[0] &amp;&amp;
                        floatCoords[numCoords-1] == coords[1])
                    {
                        // Collapse out initial moveto/lineto
<span class="nc" id="L668">                        break;</span>
                    }
<span class="nc" id="L670">                    lineTo(coords[0], coords[1]);</span>
<span class="nc" id="L671">                    break;</span>
                case SEG_LINETO:
<span class="nc" id="L673">                    lineTo(coords[0], coords[1]);</span>
<span class="nc" id="L674">                    break;</span>
                case SEG_QUADTO:
<span class="nc" id="L676">                    quadTo(coords[0], coords[1],</span>
                           coords[2], coords[3]);
<span class="nc" id="L678">                    break;</span>
                case SEG_CUBICTO:
<span class="nc" id="L680">                    curveTo(coords[0], coords[1],</span>
                            coords[2], coords[3],
                            coords[4], coords[5]);
<span class="nc" id="L683">                    break;</span>
                case SEG_CLOSE:
<span class="nc" id="L685">                    closePath();</span>
                    break;
                }
<span class="nc" id="L688">                pi.next();</span>
<span class="nc" id="L689">                connect = false;</span>
            }
<span class="nc" id="L691">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final void transform(AffineTransform at) {
<span class="nc" id="L698">            at.transform(floatCoords, 0, floatCoords, 0, numCoords / 2);</span>
<span class="nc" id="L699">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized Rectangle2D getBounds2D() {
            float x1, y1, x2, y2;
<span class="nc" id="L707">            int i = numCoords;</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L709">                y1 = y2 = floatCoords[--i];</span>
<span class="nc" id="L710">                x1 = x2 = floatCoords[--i];</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                while (i &gt; 0) {</span>
<span class="nc" id="L712">                    float y = floatCoords[--i];</span>
<span class="nc" id="L713">                    float x = floatCoords[--i];</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    if (x &lt; x1) x1 = x;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                    if (y &lt; y1) y1 = y;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                    if (x &gt; x2) x2 = x;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    if (y &gt; y2) y2 = y;</span>
<span class="nc" id="L718">                }</span>
            } else {
<span class="nc" id="L720">                x1 = y1 = x2 = y2 = 0.0f;</span>
            }
<span class="nc" id="L722">            return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);</span>
        }

        /**
         * {@inheritDoc}
         * &lt;p&gt;
         * The iterator for this class is not multi-threaded safe,
         * which means that the {@code Path2D} class does not
         * guarantee that modifications to the geometry of this
         * {@code Path2D} object do not affect any iterations of
         * that geometry that are already in process.
         *
         * @since 1.6
         */
        public final PathIterator getPathIterator(AffineTransform at) {
<span class="nc bnc" id="L737" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc" id="L738">                return new CopyIterator(this);</span>
            } else {
<span class="nc" id="L740">                return new TxIterator(this, at);</span>
            }
        }

        /**
         * Creates a new object of the same class as this object.
         *
         * @return     a clone of this instance.
         * @exception  OutOfMemoryError    if there is not enough memory.
         * @see        java.lang.Cloneable
         * @since      1.6
         */
        public final Object clone() {
            // Note: It would be nice to have this return Path2D
            // but one of our subclasses (GeneralPath) needs to
            // offer &quot;public Object clone()&quot; for backwards
            // compatibility so we cannot restrict it further.
            // REMIND: Can we do both somehow?
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (this instanceof GeneralPath) {</span>
<span class="nc" id="L759">                return new GeneralPath(this);</span>
            } else {
<span class="nc" id="L761">                return new Path2D.Float(this);</span>
            }
        }

        /*
         * JDK 1.6 serialVersionUID
         */
        private static final long serialVersionUID = 6990832515060788886L;

        /**
         * Writes the default serializable fields to the
         * {@code ObjectOutputStream} followed by an explicit
         * serialization of the path segments stored in this
         * path.
         *
         * @serialData
         * &lt;a name=&quot;Path2DSerialData&quot;&gt;&lt;!-- --&gt;&lt;/a&gt;
         * &lt;ol&gt;
         * &lt;li&gt;The default serializable fields.
         * There are no default serializable fields as of 1.6.
         * &lt;li&gt;followed by
         * a byte indicating the storage type of the original object
         * as a hint (SERIAL_STORAGE_FLT_ARRAY)
         * &lt;li&gt;followed by
         * an integer indicating the number of path segments to follow (NP)
         * or -1 to indicate an unknown number of path segments follows
         * &lt;li&gt;followed by
         * an integer indicating the total number of coordinates to follow (NC)
         * or -1 to indicate an unknown number of coordinates follows
         * (NC should always be even since coordinates always appear in pairs
         *  representing an x,y pair)
         * &lt;li&gt;followed by
         * a byte indicating the winding rule
         * ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or
         *  {@link #WIND_NON_ZERO WIND_NON_ZERO})
         * &lt;li&gt;followed by
         * NP (or unlimited if NP &lt; 0) sets of values consisting of
         * a single byte indicating a path segment type
         * followed by one or more pairs of float or double
         * values representing the coordinates of the path segment
         * &lt;li&gt;followed by
         * a byte indicating the end of the path (SERIAL_PATH_END).
         * &lt;/ol&gt;
         * &lt;p&gt;
         * The following byte value constants are used in the serialized form
         * of {@code Path2D} objects:
         * &lt;table&gt;
         * &lt;tr&gt;
         * &lt;th&gt;Constant Name&lt;/th&gt;
         * &lt;th&gt;Byte Value&lt;/th&gt;
         * &lt;th&gt;Followed by&lt;/th&gt;
         * &lt;th&gt;Description&lt;/th&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_STORAGE_FLT_ARRAY}&lt;/td&gt;
         * &lt;td&gt;0x30&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A hint that the original {@code Path2D} object stored
         * the coordinates in a Java array of floats.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_STORAGE_DBL_ARRAY}&lt;/td&gt;
         * &lt;td&gt;0x31&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A hint that the original {@code Path2D} object stored
         * the coordinates in a Java array of doubles.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_MOVETO}&lt;/td&gt;
         * &lt;td&gt;0x40&lt;/td&gt;
         * &lt;td&gt;2 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_LINETO}&lt;/td&gt;
         * &lt;td&gt;0x41&lt;/td&gt;
         * &lt;td&gt;2 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_QUADTO}&lt;/td&gt;
         * &lt;td&gt;0x42&lt;/td&gt;
         * &lt;td&gt;4 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #quadTo quadTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_CUBICTO}&lt;/td&gt;
         * &lt;td&gt;0x43&lt;/td&gt;
         * &lt;td&gt;6 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_MOVETO}&lt;/td&gt;
         * &lt;td&gt;0x50&lt;/td&gt;
         * &lt;td&gt;2 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_LINETO}&lt;/td&gt;
         * &lt;td&gt;0x51&lt;/td&gt;
         * &lt;td&gt;2 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_QUADTO}&lt;/td&gt;
         * &lt;td&gt;0x52&lt;/td&gt;
         * &lt;td&gt;4 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_CUBICTO}&lt;/td&gt;
         * &lt;td&gt;0x53&lt;/td&gt;
         * &lt;td&gt;6 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_CLOSE}&lt;/td&gt;
         * &lt;td&gt;0x60&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A {@link #closePath closePath} path segment.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_PATH_END}&lt;/td&gt;
         * &lt;td&gt;0x61&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;There are no more path segments following.&lt;/td&gt;
         * &lt;/table&gt;
         *
         * @since 1.6
         */
        private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException
        {
<span class="nc" id="L894">            super.writeObject(s, false);</span>
<span class="nc" id="L895">        }</span>

        /**
         * Reads the default serializable fields from the
         * {@code ObjectInputStream} followed by an explicit
         * serialization of the path segments stored in this
         * path.
         * &lt;p&gt;
         * There are no default serializable fields as of 1.6.
         * &lt;p&gt;
         * The serial data for this object is described in the
         * writeObject method.
         *
         * @since 1.6
         */
        private void readObject(java.io.ObjectInputStream s)
            throws java.lang.ClassNotFoundException, java.io.IOException
        {
<span class="nc" id="L913">            super.readObject(s, false);</span>
<span class="nc" id="L914">        }</span>

        static class CopyIterator extends Path2D.Iterator {
            float floatCoords[];

            CopyIterator(Path2D.Float p2df) {
<span class="nc" id="L920">                super(p2df);</span>
<span class="nc" id="L921">                this.floatCoords = p2df.floatCoords;</span>
<span class="nc" id="L922">            }</span>

            public int currentSegment(float[] coords) {
<span class="nc" id="L925">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L926">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L928">                    System.arraycopy(floatCoords, pointIdx,</span>
                                     coords, 0, numCoords);
                }
<span class="nc" id="L931">                return type;</span>
            }

            public int currentSegment(double[] coords) {
<span class="nc" id="L935">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L936">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    for (int i = 0; i &lt; numCoords; i++) {</span>
<span class="nc" id="L939">                        coords[i] = floatCoords[pointIdx + i];</span>
                    }
                }
<span class="nc" id="L942">                return type;</span>
            }
        }

        static class TxIterator extends Path2D.Iterator {
            float floatCoords[];
            AffineTransform affine;

            TxIterator(Path2D.Float p2df, AffineTransform at) {
<span class="nc" id="L951">                super(p2df);</span>
<span class="nc" id="L952">                this.floatCoords = p2df.floatCoords;</span>
<span class="nc" id="L953">                this.affine = at;</span>
<span class="nc" id="L954">            }</span>

            public int currentSegment(float[] coords) {
<span class="nc" id="L957">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L958">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L960">                    affine.transform(floatCoords, pointIdx,</span>
                                     coords, 0, numCoords / 2);
                }
<span class="nc" id="L963">                return type;</span>
            }

            public int currentSegment(double[] coords) {
<span class="nc" id="L967">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L968">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L970">                    affine.transform(floatCoords, pointIdx,</span>
                                     coords, 0, numCoords / 2);
                }
<span class="nc" id="L973">                return type;</span>
            }
        }

    }

    /**
     * The {@code Double} class defines a geometric path with
     * coordinates stored in double precision floating point.
     *
     * @since 1.6
     */
    public static class Double extends Path2D implements Serializable {
        transient double doubleCoords[];

        /**
         * Constructs a new empty double precision {@code Path2D} object
         * with a default winding rule of {@link #WIND_NON_ZERO}.
         *
         * @since 1.6
         */
        public Double() {
<span class="nc" id="L995">            this(WIND_NON_ZERO, INIT_SIZE);</span>
<span class="nc" id="L996">        }</span>

        /**
         * Constructs a new empty double precision {@code Path2D} object
         * with the specified winding rule to control operations that
         * require the interior of the path to be defined.
         *
         * @param rule the winding rule
         * @see #WIND_EVEN_ODD
         * @see #WIND_NON_ZERO
         * @since 1.6
         */
        public Double(int rule) {
<span class="nc" id="L1009">            this(rule, INIT_SIZE);</span>
<span class="nc" id="L1010">        }</span>

        /**
         * Constructs a new empty double precision {@code Path2D} object
         * with the specified winding rule and the specified initial
         * capacity to store path segments.
         * This number is an initial guess as to how many path segments
         * are in the path, but the storage is expanded as needed to store
         * whatever path segments are added to this path.
         *
         * @param rule the winding rule
         * @param initialCapacity the estimate for the number of path segments
         *                        in the path
         * @see #WIND_EVEN_ODD
         * @see #WIND_NON_ZERO
         * @since 1.6
         */
        public Double(int rule, int initialCapacity) {
<span class="nc" id="L1028">            super(rule, initialCapacity);</span>
<span class="nc" id="L1029">            doubleCoords = new double[initialCapacity * 2];</span>
<span class="nc" id="L1030">        }</span>

        /**
         * Constructs a new double precision {@code Path2D} object
         * from an arbitrary {@link Shape} object.
         * All of the initial geometry and the winding rule for this path are
         * taken from the specified {@code Shape} object.
         *
         * @param s the specified {@code Shape} object
         * @since 1.6
         */
        public Double(Shape s) {
<span class="nc" id="L1042">            this(s, null);</span>
<span class="nc" id="L1043">        }</span>

        /**
         * Constructs a new double precision {@code Path2D} object
         * from an arbitrary {@link Shape} object, transformed by an
         * {@link AffineTransform} object.
         * All of the initial geometry and the winding rule for this path are
         * taken from the specified {@code Shape} object and transformed
         * by the specified {@code AffineTransform} object.
         *
         * @param s the specified {@code Shape} object
         * @param at the specified {@code AffineTransform} object
         * @since 1.6
         */
<span class="nc" id="L1057">        public Double(Shape s, AffineTransform at) {</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            if (s instanceof Path2D) {</span>
<span class="nc" id="L1059">                Path2D p2d = (Path2D) s;</span>
<span class="nc" id="L1060">                setWindingRule(p2d.windingRule);</span>
<span class="nc" id="L1061">                this.numTypes = p2d.numTypes;</span>
<span class="nc" id="L1062">                this.pointTypes = Arrays.copyOf(p2d.pointTypes,</span>
                                                p2d.pointTypes.length);
<span class="nc" id="L1064">                this.numCoords = p2d.numCoords;</span>
<span class="nc" id="L1065">                this.doubleCoords = p2d.cloneCoordsDouble(at);</span>
<span class="nc" id="L1066">            } else {</span>
<span class="nc" id="L1067">                PathIterator pi = s.getPathIterator(at);</span>
<span class="nc" id="L1068">                setWindingRule(pi.getWindingRule());</span>
<span class="nc" id="L1069">                this.pointTypes = new byte[INIT_SIZE];</span>
<span class="nc" id="L1070">                this.doubleCoords = new double[INIT_SIZE * 2];</span>
<span class="nc" id="L1071">                append(pi, false);</span>
            }
<span class="nc" id="L1073">        }</span>

        float[] cloneCoordsFloat(AffineTransform at) {
<span class="nc" id="L1076">            float ret[] = new float[doubleCoords.length];</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                for (int i = 0; i &lt; numCoords; i++) {</span>
<span class="nc" id="L1079">                    ret[i] = (float) doubleCoords[i];</span>
                }
            } else {
<span class="nc" id="L1082">                at.transform(doubleCoords, 0, ret, 0, numCoords / 2);</span>
            }
<span class="nc" id="L1084">            return ret;</span>
        }

        double[] cloneCoordsDouble(AffineTransform at) {
            double ret[];
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc" id="L1090">                ret = Arrays.copyOf(this.doubleCoords,</span>
                                    this.doubleCoords.length);
            } else {
<span class="nc" id="L1093">                ret = new double[doubleCoords.length];</span>
<span class="nc" id="L1094">                at.transform(doubleCoords, 0, ret, 0, numCoords / 2);</span>
            }
<span class="nc" id="L1096">            return ret;</span>
        }

        void append(float x, float y) {
<span class="nc" id="L1100">            doubleCoords[numCoords++] = x;</span>
<span class="nc" id="L1101">            doubleCoords[numCoords++] = y;</span>
<span class="nc" id="L1102">        }</span>

        void append(double x, double y) {
<span class="nc" id="L1105">            doubleCoords[numCoords++] = x;</span>
<span class="nc" id="L1106">            doubleCoords[numCoords++] = y;</span>
<span class="nc" id="L1107">        }</span>

        Point2D getPoint(int coordindex) {
<span class="nc" id="L1110">            return new Point2D.Double(doubleCoords[coordindex],</span>
                                      doubleCoords[coordindex+1]);
        }

        void needRoom(boolean needMove, int newCoords) {
<span class="nc bnc" id="L1115" title="All 4 branches missed.">            if (needMove &amp;&amp; numTypes == 0) {</span>
<span class="nc" id="L1116">                throw new IllegalPathStateException(&quot;missing initial moveto &quot;+</span>
                                                    &quot;in path definition&quot;);
            }
<span class="nc" id="L1119">            int size = pointTypes.length;</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (numTypes &gt;= size) {</span>
<span class="nc" id="L1121">                int grow = size;</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                if (grow &gt; EXPAND_MAX) {</span>
<span class="nc" id="L1123">                    grow = EXPAND_MAX;</span>
                }
<span class="nc" id="L1125">                pointTypes = Arrays.copyOf(pointTypes, size+grow);</span>
            }
<span class="nc" id="L1127">            size = doubleCoords.length;</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if (numCoords + newCoords &gt; size) {</span>
<span class="nc" id="L1129">                int grow = size;</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">                if (grow &gt; EXPAND_MAX * 2) {</span>
<span class="nc" id="L1131">                    grow = EXPAND_MAX * 2;</span>
                }
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                if (grow &lt; newCoords) {</span>
<span class="nc" id="L1134">                    grow = newCoords;</span>
                }
<span class="nc" id="L1136">                doubleCoords = Arrays.copyOf(doubleCoords, size+grow);</span>
            }
<span class="nc" id="L1138">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void moveTo(double x, double y) {
<span class="nc bnc" id="L1145" title="All 4 branches missed.">            if (numTypes &gt; 0 &amp;&amp; pointTypes[numTypes - 1] == SEG_MOVETO) {</span>
<span class="nc" id="L1146">                doubleCoords[numCoords-2] = x;</span>
<span class="nc" id="L1147">                doubleCoords[numCoords-1] = y;</span>
            } else {
<span class="nc" id="L1149">                needRoom(false, 2);</span>
<span class="nc" id="L1150">                pointTypes[numTypes++] = SEG_MOVETO;</span>
<span class="nc" id="L1151">                doubleCoords[numCoords++] = x;</span>
<span class="nc" id="L1152">                doubleCoords[numCoords++] = y;</span>
            }
<span class="nc" id="L1154">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void lineTo(double x, double y) {
<span class="nc" id="L1161">            needRoom(true, 2);</span>
<span class="nc" id="L1162">            pointTypes[numTypes++] = SEG_LINETO;</span>
<span class="nc" id="L1163">            doubleCoords[numCoords++] = x;</span>
<span class="nc" id="L1164">            doubleCoords[numCoords++] = y;</span>
<span class="nc" id="L1165">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void quadTo(double x1, double y1,
                                              double x2, double y2)
        {
<span class="nc" id="L1174">            needRoom(true, 4);</span>
<span class="nc" id="L1175">            pointTypes[numTypes++] = SEG_QUADTO;</span>
<span class="nc" id="L1176">            doubleCoords[numCoords++] = x1;</span>
<span class="nc" id="L1177">            doubleCoords[numCoords++] = y1;</span>
<span class="nc" id="L1178">            doubleCoords[numCoords++] = x2;</span>
<span class="nc" id="L1179">            doubleCoords[numCoords++] = y2;</span>
<span class="nc" id="L1180">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized void curveTo(double x1, double y1,
                                               double x2, double y2,
                                               double x3, double y3)
        {
<span class="nc" id="L1190">            needRoom(true, 6);</span>
<span class="nc" id="L1191">            pointTypes[numTypes++] = SEG_CUBICTO;</span>
<span class="nc" id="L1192">            doubleCoords[numCoords++] = x1;</span>
<span class="nc" id="L1193">            doubleCoords[numCoords++] = y1;</span>
<span class="nc" id="L1194">            doubleCoords[numCoords++] = x2;</span>
<span class="nc" id="L1195">            doubleCoords[numCoords++] = y2;</span>
<span class="nc" id="L1196">            doubleCoords[numCoords++] = x3;</span>
<span class="nc" id="L1197">            doubleCoords[numCoords++] = y3;</span>
<span class="nc" id="L1198">        }</span>

        int pointCrossings(double px, double py) {
            double movx, movy, curx, cury, endx, endy;
<span class="nc" id="L1202">            double coords[] = doubleCoords;</span>
<span class="nc" id="L1203">            curx = movx = coords[0];</span>
<span class="nc" id="L1204">            cury = movy = coords[1];</span>
<span class="nc" id="L1205">            int crossings = 0;</span>
<span class="nc" id="L1206">            int ci = 2;</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">            for (int i = 1; i &lt; numTypes; i++) {</span>
<span class="nc bnc" id="L1208" title="All 6 branches missed.">                switch (pointTypes[i]) {</span>
                case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                    if (cury != movy) {</span>
<span class="nc" id="L1211">                        crossings +=</span>
<span class="nc" id="L1212">                            Curve.pointCrossingsForLine(px, py,</span>
                                                        curx, cury,
                                                        movx, movy);
                    }
<span class="nc" id="L1216">                    movx = curx = coords[ci++];</span>
<span class="nc" id="L1217">                    movy = cury = coords[ci++];</span>
<span class="nc" id="L1218">                    break;</span>
                case PathIterator.SEG_LINETO:
<span class="nc" id="L1220">                    crossings +=</span>
<span class="nc" id="L1221">                        Curve.pointCrossingsForLine(px, py,</span>
                                                    curx, cury,
                                                    endx = coords[ci++],
                                                    endy = coords[ci++]);
<span class="nc" id="L1225">                    curx = endx;</span>
<span class="nc" id="L1226">                    cury = endy;</span>
<span class="nc" id="L1227">                    break;</span>
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L1229">                    crossings +=</span>
<span class="nc" id="L1230">                        Curve.pointCrossingsForQuad(px, py,</span>
                                                    curx, cury,
                                                    coords[ci++],
                                                    coords[ci++],
                                                    endx = coords[ci++],
                                                    endy = coords[ci++],
                                                    0);
<span class="nc" id="L1237">                    curx = endx;</span>
<span class="nc" id="L1238">                    cury = endy;</span>
<span class="nc" id="L1239">                    break;</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L1241">                    crossings +=</span>
<span class="nc" id="L1242">                        Curve.pointCrossingsForCubic(px, py,</span>
                                                     curx, cury,
                                                     coords[ci++],
                                                     coords[ci++],
                                                     coords[ci++],
                                                     coords[ci++],
                                                     endx = coords[ci++],
                                                     endy = coords[ci++],
                                                     0);
<span class="nc" id="L1251">                    curx = endx;</span>
<span class="nc" id="L1252">                    cury = endy;</span>
<span class="nc" id="L1253">                    break;</span>
                case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                    if (cury != movy) {</span>
<span class="nc" id="L1256">                        crossings +=</span>
<span class="nc" id="L1257">                            Curve.pointCrossingsForLine(px, py,</span>
                                                        curx, cury,
                                                        movx, movy);
                    }
<span class="nc" id="L1261">                    curx = movx;</span>
<span class="nc" id="L1262">                    cury = movy;</span>
                    break;
                }
            }
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (cury != movy) {</span>
<span class="nc" id="L1267">                crossings +=</span>
<span class="nc" id="L1268">                    Curve.pointCrossingsForLine(px, py,</span>
                                                curx, cury,
                                                movx, movy);
            }
<span class="nc" id="L1272">            return crossings;</span>
        }

        int rectCrossings(double rxmin, double rymin,
                          double rxmax, double rymax)
        {
<span class="nc" id="L1278">            double coords[] = doubleCoords;</span>
            double curx, cury, movx, movy, endx, endy;
<span class="nc" id="L1280">            curx = movx = coords[0];</span>
<span class="nc" id="L1281">            cury = movy = coords[1];</span>
<span class="nc" id="L1282">            int crossings = 0;</span>
<span class="nc" id="L1283">            int ci = 2;</span>
<span class="nc" id="L1284">            for (int i = 1;</span>
<span class="nc bnc" id="L1285" title="All 4 branches missed.">                 crossings != Curve.RECT_INTERSECTS &amp;&amp; i &lt; numTypes;</span>
<span class="nc" id="L1286">                 i++)</span>
            {
<span class="nc bnc" id="L1288" title="All 6 branches missed.">                switch (pointTypes[i]) {</span>
                case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L1290" title="All 4 branches missed.">                    if (curx != movx || cury != movy) {</span>
<span class="nc" id="L1291">                        crossings =</span>
<span class="nc" id="L1292">                            Curve.rectCrossingsForLine(crossings,</span>
                                                       rxmin, rymin,
                                                       rxmax, rymax,
                                                       curx, cury,
                                                       movx, movy);
                    }
                    // Count should always be a multiple of 2 here.
                    // assert((crossings &amp; 1) != 0);
<span class="nc" id="L1300">                    movx = curx = coords[ci++];</span>
<span class="nc" id="L1301">                    movy = cury = coords[ci++];</span>
<span class="nc" id="L1302">                    break;</span>
                case PathIterator.SEG_LINETO:
<span class="nc" id="L1304">                    endx = coords[ci++];</span>
<span class="nc" id="L1305">                    endy = coords[ci++];</span>
<span class="nc" id="L1306">                    crossings =</span>
<span class="nc" id="L1307">                        Curve.rectCrossingsForLine(crossings,</span>
                                                   rxmin, rymin,
                                                   rxmax, rymax,
                                                   curx, cury,
                                                   endx, endy);
<span class="nc" id="L1312">                    curx = endx;</span>
<span class="nc" id="L1313">                    cury = endy;</span>
<span class="nc" id="L1314">                    break;</span>
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L1316">                    crossings =</span>
<span class="nc" id="L1317">                        Curve.rectCrossingsForQuad(crossings,</span>
                                                   rxmin, rymin,
                                                   rxmax, rymax,
                                                   curx, cury,
                                                   coords[ci++],
                                                   coords[ci++],
                                                   endx = coords[ci++],
                                                   endy = coords[ci++],
                                                   0);
<span class="nc" id="L1326">                    curx = endx;</span>
<span class="nc" id="L1327">                    cury = endy;</span>
<span class="nc" id="L1328">                    break;</span>
                case PathIterator.SEG_CUBICTO:
<span class="nc" id="L1330">                    crossings =</span>
<span class="nc" id="L1331">                        Curve.rectCrossingsForCubic(crossings,</span>
                                                    rxmin, rymin,
                                                    rxmax, rymax,
                                                    curx, cury,
                                                    coords[ci++],
                                                    coords[ci++],
                                                    coords[ci++],
                                                    coords[ci++],
                                                    endx = coords[ci++],
                                                    endy = coords[ci++],
                                                    0);
<span class="nc" id="L1342">                    curx = endx;</span>
<span class="nc" id="L1343">                    cury = endy;</span>
<span class="nc" id="L1344">                    break;</span>
                case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L1346" title="All 4 branches missed.">                    if (curx != movx || cury != movy) {</span>
<span class="nc" id="L1347">                        crossings =</span>
<span class="nc" id="L1348">                            Curve.rectCrossingsForLine(crossings,</span>
                                                       rxmin, rymin,
                                                       rxmax, rymax,
                                                       curx, cury,
                                                       movx, movy);
                    }
<span class="nc" id="L1354">                    curx = movx;</span>
<span class="nc" id="L1355">                    cury = movy;</span>
                    // Count should always be a multiple of 2 here.
                    // assert((crossings &amp; 1) != 0);
                    break;
                }
            }
<span class="nc bnc" id="L1361" title="All 6 branches missed.">            if (crossings != Curve.RECT_INTERSECTS &amp;&amp;</span>
                (curx != movx || cury != movy))
            {
<span class="nc" id="L1364">                crossings =</span>
<span class="nc" id="L1365">                    Curve.rectCrossingsForLine(crossings,</span>
                                               rxmin, rymin,
                                               rxmax, rymax,
                                               curx, cury,
                                               movx, movy);
            }
            // Count should always be a multiple of 2 here.
            // assert((crossings &amp; 1) != 0);
<span class="nc" id="L1373">            return crossings;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final void append(PathIterator pi, boolean connect) {
<span class="nc" id="L1381">            double coords[] = new double[6];</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">            while (!pi.isDone()) {</span>
<span class="nc bnc" id="L1383" title="All 6 branches missed.">                switch (pi.currentSegment(coords)) {</span>
                case SEG_MOVETO:
<span class="nc bnc" id="L1385" title="All 6 branches missed.">                    if (!connect || numTypes &lt; 1 || numCoords &lt; 1) {</span>
<span class="nc" id="L1386">                        moveTo(coords[0], coords[1]);</span>
<span class="nc" id="L1387">                        break;</span>
                    }
<span class="nc bnc" id="L1389" title="All 6 branches missed.">                    if (pointTypes[numTypes - 1] != SEG_CLOSE &amp;&amp;</span>
                        doubleCoords[numCoords-2] == coords[0] &amp;&amp;
                        doubleCoords[numCoords-1] == coords[1])
                    {
                        // Collapse out initial moveto/lineto
<span class="nc" id="L1394">                        break;</span>
                    }
<span class="nc" id="L1396">                    lineTo(coords[0], coords[1]);</span>
<span class="nc" id="L1397">                    break;</span>
                case SEG_LINETO:
<span class="nc" id="L1399">                    lineTo(coords[0], coords[1]);</span>
<span class="nc" id="L1400">                    break;</span>
                case SEG_QUADTO:
<span class="nc" id="L1402">                    quadTo(coords[0], coords[1],</span>
                           coords[2], coords[3]);
<span class="nc" id="L1404">                    break;</span>
                case SEG_CUBICTO:
<span class="nc" id="L1406">                    curveTo(coords[0], coords[1],</span>
                            coords[2], coords[3],
                            coords[4], coords[5]);
<span class="nc" id="L1409">                    break;</span>
                case SEG_CLOSE:
<span class="nc" id="L1411">                    closePath();</span>
                    break;
                }
<span class="nc" id="L1414">                pi.next();</span>
<span class="nc" id="L1415">                connect = false;</span>
            }
<span class="nc" id="L1417">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final void transform(AffineTransform at) {
<span class="nc" id="L1424">            at.transform(doubleCoords, 0, doubleCoords, 0, numCoords / 2);</span>
<span class="nc" id="L1425">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.6
         */
        public final synchronized Rectangle2D getBounds2D() {
            double x1, y1, x2, y2;
<span class="nc" id="L1433">            int i = numCoords;</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L1435">                y1 = y2 = doubleCoords[--i];</span>
<span class="nc" id="L1436">                x1 = x2 = doubleCoords[--i];</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">                while (i &gt; 0) {</span>
<span class="nc" id="L1438">                    double y = doubleCoords[--i];</span>
<span class="nc" id="L1439">                    double x = doubleCoords[--i];</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                    if (x &lt; x1) x1 = x;</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                    if (y &lt; y1) y1 = y;</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                    if (x &gt; x2) x2 = x;</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">                    if (y &gt; y2) y2 = y;</span>
<span class="nc" id="L1444">                }</span>
            } else {
<span class="nc" id="L1446">                x1 = y1 = x2 = y2 = 0.0;</span>
            }
<span class="nc" id="L1448">            return new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);</span>
        }

        /**
         * {@inheritDoc}
         * &lt;p&gt;
         * The iterator for this class is not multi-threaded safe,
         * which means that the {@code Path2D} class does not
         * guarantee that modifications to the geometry of this
         * {@code Path2D} object do not affect any iterations of
         * that geometry that are already in process.
         *
         * @param at an {@code AffineTransform}
         * @return a new {@code PathIterator} that iterates along the boundary
         *         of this {@code Shape} and provides access to the geometry
         *         of this {@code Shape}'s outline
         * @since 1.6
         */
        public final PathIterator getPathIterator(AffineTransform at) {
<span class="nc bnc" id="L1467" title="All 2 branches missed.">            if (at == null) {</span>
<span class="nc" id="L1468">                return new CopyIterator(this);</span>
            } else {
<span class="nc" id="L1470">                return new TxIterator(this, at);</span>
            }
        }

        /**
         * Creates a new object of the same class as this object.
         *
         * @return     a clone of this instance.
         * @exception  OutOfMemoryError    if there is not enough memory.
         * @see        java.lang.Cloneable
         * @since      1.6
         */
        public final Object clone() {
            // Note: It would be nice to have this return Path2D
            // but one of our subclasses (GeneralPath) needs to
            // offer &quot;public Object clone()&quot; for backwards
            // compatibility so we cannot restrict it further.
            // REMIND: Can we do both somehow?
<span class="nc" id="L1488">            return new Path2D.Double(this);</span>
        }

        /*
         * JDK 1.6 serialVersionUID
         */
        private static final long serialVersionUID = 1826762518450014216L;

        /**
         * Writes the default serializable fields to the
         * {@code ObjectOutputStream} followed by an explicit
         * serialization of the path segments stored in this
         * path.
         *
         * @serialData
         * &lt;a name=&quot;Path2DSerialData&quot;&gt;&lt;!-- --&gt;&lt;/a&gt;
         * &lt;ol&gt;
         * &lt;li&gt;The default serializable fields.
         * There are no default serializable fields as of 1.6.
         * &lt;li&gt;followed by
         * a byte indicating the storage type of the original object
         * as a hint (SERIAL_STORAGE_DBL_ARRAY)
         * &lt;li&gt;followed by
         * an integer indicating the number of path segments to follow (NP)
         * or -1 to indicate an unknown number of path segments follows
         * &lt;li&gt;followed by
         * an integer indicating the total number of coordinates to follow (NC)
         * or -1 to indicate an unknown number of coordinates follows
         * (NC should always be even since coordinates always appear in pairs
         *  representing an x,y pair)
         * &lt;li&gt;followed by
         * a byte indicating the winding rule
         * ({@link #WIND_EVEN_ODD WIND_EVEN_ODD} or
         *  {@link #WIND_NON_ZERO WIND_NON_ZERO})
         * &lt;li&gt;followed by
         * NP (or unlimited if NP &lt; 0) sets of values consisting of
         * a single byte indicating a path segment type
         * followed by one or more pairs of float or double
         * values representing the coordinates of the path segment
         * &lt;li&gt;followed by
         * a byte indicating the end of the path (SERIAL_PATH_END).
         * &lt;/ol&gt;
         * &lt;p&gt;
         * The following byte value constants are used in the serialized form
         * of {@code Path2D} objects:
         * &lt;table&gt;
         * &lt;tr&gt;
         * &lt;th&gt;Constant Name&lt;/th&gt;
         * &lt;th&gt;Byte Value&lt;/th&gt;
         * &lt;th&gt;Followed by&lt;/th&gt;
         * &lt;th&gt;Description&lt;/th&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_STORAGE_FLT_ARRAY}&lt;/td&gt;
         * &lt;td&gt;0x30&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A hint that the original {@code Path2D} object stored
         * the coordinates in a Java array of floats.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_STORAGE_DBL_ARRAY}&lt;/td&gt;
         * &lt;td&gt;0x31&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A hint that the original {@code Path2D} object stored
         * the coordinates in a Java array of doubles.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_MOVETO}&lt;/td&gt;
         * &lt;td&gt;0x40&lt;/td&gt;
         * &lt;td&gt;2 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_LINETO}&lt;/td&gt;
         * &lt;td&gt;0x41&lt;/td&gt;
         * &lt;td&gt;2 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_QUADTO}&lt;/td&gt;
         * &lt;td&gt;0x42&lt;/td&gt;
         * &lt;td&gt;4 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #quadTo quadTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_FLT_CUBICTO}&lt;/td&gt;
         * &lt;td&gt;0x43&lt;/td&gt;
         * &lt;td&gt;6 floats&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_MOVETO}&lt;/td&gt;
         * &lt;td&gt;0x50&lt;/td&gt;
         * &lt;td&gt;2 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #moveTo moveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_LINETO}&lt;/td&gt;
         * &lt;td&gt;0x51&lt;/td&gt;
         * &lt;td&gt;2 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #lineTo lineTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_QUADTO}&lt;/td&gt;
         * &lt;td&gt;0x52&lt;/td&gt;
         * &lt;td&gt;4 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_DBL_CUBICTO}&lt;/td&gt;
         * &lt;td&gt;0x53&lt;/td&gt;
         * &lt;td&gt;6 doubles&lt;/td&gt;
         * &lt;td&gt;A {@link #curveTo curveTo} path segment follows.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_SEG_CLOSE}&lt;/td&gt;
         * &lt;td&gt;0x60&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;A {@link #closePath closePath} path segment.&lt;/td&gt;
         * &lt;/tr&gt;
         * &lt;tr&gt;
         * &lt;td&gt;{@code SERIAL_PATH_END}&lt;/td&gt;
         * &lt;td&gt;0x61&lt;/td&gt;
         * &lt;td&gt;&lt;/td&gt;
         * &lt;td&gt;There are no more path segments following.&lt;/td&gt;
         * &lt;/table&gt;
         *
         * @since 1.6
         */
        private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException
        {
<span class="nc" id="L1620">            super.writeObject(s, true);</span>
<span class="nc" id="L1621">        }</span>

        /**
         * Reads the default serializable fields from the
         * {@code ObjectInputStream} followed by an explicit
         * serialization of the path segments stored in this
         * path.
         * &lt;p&gt;
         * There are no default serializable fields as of 1.6.
         * &lt;p&gt;
         * The serial data for this object is described in the
         * writeObject method.
         *
         * @since 1.6
         */
        private void readObject(java.io.ObjectInputStream s)
            throws java.lang.ClassNotFoundException, java.io.IOException
        {
<span class="nc" id="L1639">            super.readObject(s, true);</span>
<span class="nc" id="L1640">        }</span>

        static class CopyIterator extends Path2D.Iterator {
            double doubleCoords[];

            CopyIterator(Path2D.Double p2dd) {
<span class="nc" id="L1646">                super(p2dd);</span>
<span class="nc" id="L1647">                this.doubleCoords = p2dd.doubleCoords;</span>
<span class="nc" id="L1648">            }</span>

            public int currentSegment(float[] coords) {
<span class="nc" id="L1651">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L1652">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                    for (int i = 0; i &lt; numCoords; i++) {</span>
<span class="nc" id="L1655">                        coords[i] = (float) doubleCoords[pointIdx + i];</span>
                    }
                }
<span class="nc" id="L1658">                return type;</span>
            }

            public int currentSegment(double[] coords) {
<span class="nc" id="L1662">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L1663">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L1665">                    System.arraycopy(doubleCoords, pointIdx,</span>
                                     coords, 0, numCoords);
                }
<span class="nc" id="L1668">                return type;</span>
            }
        }

        static class TxIterator extends Path2D.Iterator {
            double doubleCoords[];
            AffineTransform affine;

            TxIterator(Path2D.Double p2dd, AffineTransform at) {
<span class="nc" id="L1677">                super(p2dd);</span>
<span class="nc" id="L1678">                this.doubleCoords = p2dd.doubleCoords;</span>
<span class="nc" id="L1679">                this.affine = at;</span>
<span class="nc" id="L1680">            }</span>

            public int currentSegment(float[] coords) {
<span class="nc" id="L1683">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L1684">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L1686">                    affine.transform(doubleCoords, pointIdx,</span>
                                     coords, 0, numCoords / 2);
                }
<span class="nc" id="L1689">                return type;</span>
            }

            public int currentSegment(double[] coords) {
<span class="nc" id="L1693">                int type = path.pointTypes[typeIdx];</span>
<span class="nc" id="L1694">                int numCoords = curvecoords[type];</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">                if (numCoords &gt; 0) {</span>
<span class="nc" id="L1696">                    affine.transform(doubleCoords, pointIdx,</span>
                                     coords, 0, numCoords / 2);
                }
<span class="nc" id="L1699">                return type;</span>
            }
        }
    }

    /**
     * Adds a point to the path by moving to the specified
     * coordinates specified in double precision.
     *
     * @param x the specified X coordinate
     * @param y the specified Y coordinate
     * @since 1.6
     */
    public abstract void moveTo(double x, double y);

    /**
     * Adds a point to the path by drawing a straight line from the
     * current coordinates to the new specified coordinates
     * specified in double precision.
     *
     * @param x the specified X coordinate
     * @param y the specified Y coordinate
     * @since 1.6
     */
    public abstract void lineTo(double x, double y);

    /**
     * Adds a curved segment, defined by two new points, to the path by
     * drawing a Quadratic curve that intersects both the current
     * coordinates and the specified coordinates {@code (x2,y2)},
     * using the specified point {@code (x1,y1)} as a quadratic
     * parametric control point.
     * All coordinates are specified in double precision.
     *
     * @param x1 the X coordinate of the quadratic control point
     * @param y1 the Y coordinate of the quadratic control point
     * @param x2 the X coordinate of the final end point
     * @param y2 the Y coordinate of the final end point
     * @since 1.6
     */
    public abstract void quadTo(double x1, double y1,
                                double x2, double y2);

    /**
     * Adds a curved segment, defined by three new points, to the path by
     * drawing a B&amp;eacute;zier curve that intersects both the current
     * coordinates and the specified coordinates {@code (x3,y3)},
     * using the specified points {@code (x1,y1)} and {@code (x2,y2)} as
     * B&amp;eacute;zier control points.
     * All coordinates are specified in double precision.
     *
     * @param x1 the X coordinate of the first B&amp;eacute;zier control point
     * @param y1 the Y coordinate of the first B&amp;eacute;zier control point
     * @param x2 the X coordinate of the second B&amp;eacute;zier control point
     * @param y2 the Y coordinate of the second B&amp;eacute;zier control point
     * @param x3 the X coordinate of the final end point
     * @param y3 the Y coordinate of the final end point
     * @since 1.6
     */
    public abstract void curveTo(double x1, double y1,
                                 double x2, double y2,
                                 double x3, double y3);

    /**
     * Closes the current subpath by drawing a straight line back to
     * the coordinates of the last {@code moveTo}.  If the path is already
     * closed then this method has no effect.
     *
     * @since 1.6
     */
    public final synchronized void closePath() {
<span class="nc bnc" id="L1770" title="All 4 branches missed.">        if (numTypes == 0 || pointTypes[numTypes - 1] != SEG_CLOSE) {</span>
<span class="nc" id="L1771">            needRoom(true, 0);</span>
<span class="nc" id="L1772">            pointTypes[numTypes++] = SEG_CLOSE;</span>
        }
<span class="nc" id="L1774">    }</span>

    /**
     * Appends the geometry of the specified {@code Shape} object to the
     * path, possibly connecting the new geometry to the existing path
     * segments with a line segment.
     * If the {@code connect} parameter is {@code true} and the
     * path is not empty then any initial {@code moveTo} in the
     * geometry of the appended {@code Shape}
     * is turned into a {@code lineTo} segment.
     * If the destination coordinates of such a connecting {@code lineTo}
     * segment match the ending coordinates of a currently open
     * subpath then the segment is omitted as superfluous.
     * The winding rule of the specified {@code Shape} is ignored
     * and the appended geometry is governed by the winding
     * rule specified for this path.
     *
     * @param s the {@code Shape} whose geometry is appended
     *          to this path
     * @param connect a boolean to control whether or not to turn an initial
     *                {@code moveTo} segment into a {@code lineTo} segment
     *                to connect the new geometry to the existing path
     * @since 1.6
     */
    public final void append(Shape s, boolean connect) {
<span class="nc" id="L1799">        append(s.getPathIterator(null), connect);</span>
<span class="nc" id="L1800">    }</span>

    /**
     * Appends the geometry of the specified
     * {@link PathIterator} object
     * to the path, possibly connecting the new geometry to the existing
     * path segments with a line segment.
     * If the {@code connect} parameter is {@code true} and the
     * path is not empty then any initial {@code moveTo} in the
     * geometry of the appended {@code Shape} is turned into a
     * {@code lineTo} segment.
     * If the destination coordinates of such a connecting {@code lineTo}
     * segment match the ending coordinates of a currently open
     * subpath then the segment is omitted as superfluous.
     * The winding rule of the specified {@code Shape} is ignored
     * and the appended geometry is governed by the winding
     * rule specified for this path.
     *
     * @param pi the {@code PathIterator} whose geometry is appended to
     *           this path
     * @param connect a boolean to control whether or not to turn an initial
     *                {@code moveTo} segment into a {@code lineTo} segment
     *                to connect the new geometry to the existing path
     * @since 1.6
     */
    public abstract void append(PathIterator pi, boolean connect);

    /**
     * Returns the fill style winding rule.
     *
     * @return an integer representing the current winding rule.
     * @see #WIND_EVEN_ODD
     * @see #WIND_NON_ZERO
     * @see #setWindingRule
     * @since 1.6
     */
    public final synchronized int getWindingRule() {
<span class="nc" id="L1837">        return windingRule;</span>
    }

    /**
     * Sets the winding rule for this path to the specified value.
     *
     * @param rule an integer representing the specified
     *             winding rule
     * @exception IllegalArgumentException if
     *          {@code rule} is not either
     *          {@link #WIND_EVEN_ODD} or
     *          {@link #WIND_NON_ZERO}
     * @see #getWindingRule
     * @since 1.6
     */
    public final void setWindingRule(int rule) {
<span class="nc bnc" id="L1853" title="All 4 branches missed.">        if (rule != WIND_EVEN_ODD &amp;&amp; rule != WIND_NON_ZERO) {</span>
<span class="nc" id="L1854">            throw new IllegalArgumentException(&quot;winding rule must be &quot;+</span>
                                               &quot;WIND_EVEN_ODD or &quot;+
                                               &quot;WIND_NON_ZERO&quot;);
        }
<span class="nc" id="L1858">        windingRule = rule;</span>
<span class="nc" id="L1859">    }</span>

    /**
     * Returns the coordinates most recently added to the end of the path
     * as a {@link Point2D} object.
     *
     * @return a {@code Point2D} object containing the ending coordinates of
     *         the path or {@code null} if there are no points in the path.
     * @since 1.6
     */
    public final synchronized Point2D getCurrentPoint() {
<span class="nc" id="L1870">        int index = numCoords;</span>
<span class="nc bnc" id="L1871" title="All 4 branches missed.">        if (numTypes &lt; 1 || index &lt; 1) {</span>
<span class="nc" id="L1872">            return null;</span>
        }
<span class="nc bnc" id="L1874" title="All 2 branches missed.">        if (pointTypes[numTypes - 1] == SEG_CLOSE) {</span>
        loop:
<span class="nc bnc" id="L1876" title="All 2 branches missed.">            for (int i = numTypes - 2; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L1877" title="All 5 branches missed.">                switch (pointTypes[i]) {</span>
                case SEG_MOVETO:
<span class="nc" id="L1879">                    break loop;</span>
                case SEG_LINETO:
<span class="nc" id="L1881">                    index -= 2;</span>
<span class="nc" id="L1882">                    break;</span>
                case SEG_QUADTO:
<span class="nc" id="L1884">                    index -= 4;</span>
<span class="nc" id="L1885">                    break;</span>
                case SEG_CUBICTO:
<span class="nc" id="L1887">                    index -= 6;</span>
<span class="nc" id="L1888">                    break;</span>
                case SEG_CLOSE:
                    break;
                }
            }
        }
<span class="nc" id="L1894">        return getPoint(index - 2);</span>
    }

    /**
     * Resets the path to empty.  The append position is set back to the
     * beginning of the path and all coordinates and point types are
     * forgotten.
     *
     * @since 1.6
     */
    public final synchronized void reset() {
<span class="nc" id="L1905">        numTypes = numCoords = 0;</span>
<span class="nc" id="L1906">    }</span>

    /**
     * Transforms the geometry of this path using the specified
     * {@link AffineTransform}.
     * The geometry is transformed in place, which permanently changes the
     * boundary defined by this object.
     *
     * @param at the {@code AffineTransform} used to transform the area
     * @since 1.6
     */
    public abstract void transform(AffineTransform at);

    /**
     * Returns a new {@code Shape} representing a transformed version
     * of this {@code Path2D}.
     * Note that the exact type and coordinate precision of the return
     * value is not specified for this method.
     * The method will return a Shape that contains no less precision
     * for the transformed geometry than this {@code Path2D} currently
     * maintains, but it may contain no more precision either.
     * If the tradeoff of precision vs. storage size in the result is
     * important then the convenience constructors in the
     * {@link Path2D.Float#Path2D.Float(Shape, AffineTransform) Path2D.Float}
     * and
     * {@link Path2D.Double#Path2D.Double(Shape, AffineTransform) Path2D.Double}
     * subclasses should be used to make the choice explicit.
     *
     * @param at the {@code AffineTransform} used to transform a
     *           new {@code Shape}.
     * @return a new {@code Shape}, transformed with the specified
     *         {@code AffineTransform}.
     * @since 1.6
     */
    public final synchronized Shape createTransformedShape(AffineTransform at) {
<span class="nc" id="L1941">        Path2D p2d = (Path2D) clone();</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">        if (at != null) {</span>
<span class="nc" id="L1943">            p2d.transform(at);</span>
        }
<span class="nc" id="L1945">        return p2d;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.6
     */
    public final Rectangle getBounds() {
<span class="nc" id="L1953">        return getBounds2D().getBounds();</span>
    }

    /**
     * Tests if the specified coordinates are inside the closed
     * boundary of the specified {@link PathIterator}.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#contains(double, double)} method.
     *
     * @param pi the specified {@code PathIterator}
     * @param x the specified X coordinate
     * @param y the specified Y coordinate
     * @return {@code true} if the specified coordinates are inside the
     *         specified {@code PathIterator}; {@code false} otherwise
     * @since 1.6
     */
    public static boolean contains(PathIterator pi, double x, double y) {
<span class="nc bnc" id="L1972" title="All 2 branches missed.">        if (x * 0.0 + y * 0.0 == 0.0) {</span>
            /* N * 0.0 is 0.0 only if N is finite.
             * Here we know that both x and y are finite.
             */
<span class="nc bnc" id="L1976" title="All 2 branches missed.">            int mask = (pi.getWindingRule() == WIND_NON_ZERO ? -1 : 1);</span>
<span class="nc" id="L1977">            int cross = Curve.pointCrossingsForPath(pi, x, y);</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">            return ((cross &amp; mask) != 0);</span>
        } else {
            /* Either x or y was infinite or NaN.
             * A NaN always produces a negative response to any test
             * and Infinity values cannot be &quot;inside&quot; any path so
             * they should return false as well.
             */
<span class="nc" id="L1985">            return false;</span>
        }
    }

    /**
     * Tests if the specified {@link Point2D} is inside the closed
     * boundary of the specified {@link PathIterator}.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#contains(Point2D)} method.
     *
     * @param pi the specified {@code PathIterator}
     * @param p the specified {@code Point2D}
     * @return {@code true} if the specified coordinates are inside the
     *         specified {@code PathIterator}; {@code false} otherwise
     * @since 1.6
     */
    public static boolean contains(PathIterator pi, Point2D p) {
<span class="nc" id="L2004">        return contains(pi, p.getX(), p.getY());</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.6
     */
    public final boolean contains(double x, double y) {
<span class="nc bnc" id="L2012" title="All 2 branches missed.">        if (x * 0.0 + y * 0.0 == 0.0) {</span>
            /* N * 0.0 is 0.0 only if N is finite.
             * Here we know that both x and y are finite.
             */
<span class="nc bnc" id="L2016" title="All 2 branches missed.">            if (numTypes &lt; 2) {</span>
<span class="nc" id="L2017">                return false;</span>
            }
<span class="nc bnc" id="L2019" title="All 2 branches missed.">            int mask = (windingRule == WIND_NON_ZERO ? -1 : 1);</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">            return ((pointCrossings(x, y) &amp; mask) != 0);</span>
        } else {
            /* Either x or y was infinite or NaN.
             * A NaN always produces a negative response to any test
             * and Infinity values cannot be &quot;inside&quot; any path so
             * they should return false as well.
             */
<span class="nc" id="L2027">            return false;</span>
        }
    }

    /**
     * {@inheritDoc}
     * @since 1.6
     */
    public final boolean contains(Point2D p) {
<span class="nc" id="L2036">        return contains(p.getX(), p.getY());</span>
    }

    /**
     * Tests if the specified rectangular area is entirely inside the
     * closed boundary of the specified {@link PathIterator}.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#contains(double, double, double, double)} method.
     * &lt;p&gt;
     * This method object may conservatively return false in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO}
     * winding rule or if the segments are retraced in the reverse
     * direction such that the two sets of segments cancel each
     * other out without any exterior area falling between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param pi the specified {@code PathIterator}
     * @param x the specified X coordinate
     * @param y the specified Y coordinate
     * @param w the width of the specified rectangular area
     * @param h the height of the specified rectangular area
     * @return {@code true} if the specified {@code PathIterator} contains
     *         the specified rectangular area; {@code false} otherwise.
     * @since 1.6
     */
    public static boolean contains(PathIterator pi,
                                   double x, double y, double w, double h)
    {
<span class="nc bnc" id="L2073" title="All 4 branches missed.">        if (java.lang.Double.isNaN(x+w) || java.lang.Double.isNaN(y+h)) {</span>
            /* [xy]+[wh] is NaN if any of those values are NaN,
             * or if adding the two together would produce NaN
             * by virtue of adding opposing Infinte values.
             * Since we need to add them below, their sum must
             * not be NaN.
             * We return false because NaN always produces a
             * negative response to tests
             */
<span class="nc" id="L2082">            return false;</span>
        }
<span class="nc bnc" id="L2084" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2085">            return false;</span>
        }
<span class="nc bnc" id="L2087" title="All 2 branches missed.">        int mask = (pi.getWindingRule() == WIND_NON_ZERO ? -1 : 2);</span>
<span class="nc" id="L2088">        int crossings = Curve.rectCrossingsForPath(pi, x, y, x+w, y+h);</span>
<span class="nc bnc" id="L2089" title="All 4 branches missed.">        return (crossings != Curve.RECT_INTERSECTS &amp;&amp;</span>
                (crossings &amp; mask) != 0);
    }

    /**
     * Tests if the specified {@link Rectangle2D} is entirely inside the
     * closed boundary of the specified {@link PathIterator}.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#contains(Rectangle2D)} method.
     * &lt;p&gt;
     * This method object may conservatively return false in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO}
     * winding rule or if the segments are retraced in the reverse
     * direction such that the two sets of segments cancel each
     * other out without any exterior area falling between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param pi the specified {@code PathIterator}
     * @param r a specified {@code Rectangle2D}
     * @return {@code true} if the specified {@code PathIterator} contains
     *         the specified {@code Rectangle2D}; {@code false} otherwise.
     * @since 1.6
     */
    public static boolean contains(PathIterator pi, Rectangle2D r) {
<span class="nc" id="L2122">        return contains(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This method object may conservatively return false in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO}
     * winding rule or if the segments are retraced in the reverse
     * direction such that the two sets of segments cancel each
     * other out without any exterior area falling between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     */
    public final boolean contains(double x, double y, double w, double h) {
<span class="nc bnc" id="L2145" title="All 4 branches missed.">        if (java.lang.Double.isNaN(x+w) || java.lang.Double.isNaN(y+h)) {</span>
            /* [xy]+[wh] is NaN if any of those values are NaN,
             * or if adding the two together would produce NaN
             * by virtue of adding opposing Infinte values.
             * Since we need to add them below, their sum must
             * not be NaN.
             * We return false because NaN always produces a
             * negative response to tests
             */
<span class="nc" id="L2154">            return false;</span>
        }
<span class="nc bnc" id="L2156" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2157">            return false;</span>
        }
<span class="nc bnc" id="L2159" title="All 2 branches missed.">        int mask = (windingRule == WIND_NON_ZERO ? -1 : 2);</span>
<span class="nc" id="L2160">        int crossings = rectCrossings(x, y, x+w, y+h);</span>
<span class="nc bnc" id="L2161" title="All 4 branches missed.">        return (crossings != Curve.RECT_INTERSECTS &amp;&amp;</span>
                (crossings &amp; mask) != 0);
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This method object may conservatively return false in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such segments could lie entirely within the interior of the
     * path if they are part of a path with a {@link #WIND_NON_ZERO}
     * winding rule or if the segments are retraced in the reverse
     * direction such that the two sets of segments cancel each
     * other out without any exterior area falling between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     */
    public final boolean contains(Rectangle2D r) {
<span class="nc" id="L2185">        return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * Tests if the interior of the specified {@link PathIterator}
     * intersects the interior of a specified set of rectangular
     * coordinates.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#intersects(double, double, double, double)} method.
     * &lt;p&gt;
     * This method object may conservatively return true in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such a case may occur if some set of segments of the
     * path are retraced in the reverse direction such that the
     * two sets of segments cancel each other out without any
     * interior area between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param pi the specified {@code PathIterator}
     * @param x the specified X coordinate
     * @param y the specified Y coordinate
     * @param w the width of the specified rectangular coordinates
     * @param h the height of the specified rectangular coordinates
     * @return {@code true} if the specified {@code PathIterator} and
     *         the interior of the specified set of rectangular
     *         coordinates intersect each other; {@code false} otherwise.
     * @since 1.6
     */
    public static boolean intersects(PathIterator pi,
                                     double x, double y, double w, double h)
    {
<span class="nc bnc" id="L2223" title="All 4 branches missed.">        if (java.lang.Double.isNaN(x+w) || java.lang.Double.isNaN(y+h)) {</span>
            /* [xy]+[wh] is NaN if any of those values are NaN,
             * or if adding the two together would produce NaN
             * by virtue of adding opposing Infinte values.
             * Since we need to add them below, their sum must
             * not be NaN.
             * We return false because NaN always produces a
             * negative response to tests
             */
<span class="nc" id="L2232">            return false;</span>
        }
<span class="nc bnc" id="L2234" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2235">            return false;</span>
        }
<span class="nc bnc" id="L2237" title="All 2 branches missed.">        int mask = (pi.getWindingRule() == WIND_NON_ZERO ? -1 : 2);</span>
<span class="nc" id="L2238">        int crossings = Curve.rectCrossingsForPath(pi, x, y, x+w, y+h);</span>
<span class="nc bnc" id="L2239" title="All 4 branches missed.">        return (crossings == Curve.RECT_INTERSECTS ||</span>
                (crossings &amp; mask) != 0);
    }

    /**
     * Tests if the interior of the specified {@link PathIterator}
     * intersects the interior of a specified {@link Rectangle2D}.
     * &lt;p&gt;
     * This method provides a basic facility for implementors of
     * the {@link Shape} interface to implement support for the
     * {@link Shape#intersects(Rectangle2D)} method.
     * &lt;p&gt;
     * This method object may conservatively return true in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such a case may occur if some set of segments of the
     * path are retraced in the reverse direction such that the
     * two sets of segments cancel each other out without any
     * interior area between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @param pi the specified {@code PathIterator}
     * @param r the specified {@code Rectangle2D}
     * @return {@code true} if the specified {@code PathIterator} and
     *         the interior of the specified {@code Rectangle2D}
     *         intersect each other; {@code false} otherwise.
     * @since 1.6
     */
    public static boolean intersects(PathIterator pi, Rectangle2D r) {
<span class="nc" id="L2272">        return intersects(pi, r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This method object may conservatively return true in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such a case may occur if some set of segments of the
     * path are retraced in the reverse direction such that the
     * two sets of segments cancel each other out without any
     * interior area between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     */
    public final boolean intersects(double x, double y, double w, double h) {
<span class="nc bnc" id="L2294" title="All 4 branches missed.">        if (java.lang.Double.isNaN(x+w) || java.lang.Double.isNaN(y+h)) {</span>
            /* [xy]+[wh] is NaN if any of those values are NaN,
             * or if adding the two together would produce NaN
             * by virtue of adding opposing Infinte values.
             * Since we need to add them below, their sum must
             * not be NaN.
             * We return false because NaN always produces a
             * negative response to tests
             */
<span class="nc" id="L2303">            return false;</span>
        }
<span class="nc bnc" id="L2305" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2306">            return false;</span>
        }
<span class="nc bnc" id="L2308" title="All 2 branches missed.">        int mask = (windingRule == WIND_NON_ZERO ? -1 : 2);</span>
<span class="nc" id="L2309">        int crossings = rectCrossings(x, y, x+w, y+h);</span>
<span class="nc bnc" id="L2310" title="All 4 branches missed.">        return (crossings == Curve.RECT_INTERSECTS ||</span>
                (crossings &amp; mask) != 0);
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This method object may conservatively return true in
     * cases where the specified rectangular area intersects a
     * segment of the path, but that segment does not represent a
     * boundary between the interior and exterior of the path.
     * Such a case may occur if some set of segments of the
     * path are retraced in the reverse direction such that the
     * two sets of segments cancel each other out without any
     * interior area between them.
     * To determine whether segments represent true boundaries of
     * the interior of the path would require extensive calculations
     * involving all of the segments of the path and the winding
     * rule and are thus beyond the scope of this implementation.
     *
     * @since 1.6
     */
    public final boolean intersects(Rectangle2D r) {
<span class="nc" id="L2333">        return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The iterator for this class is not multi-threaded safe,
     * which means that this {@code Path2D} class does not
     * guarantee that modifications to the geometry of this
     * {@code Path2D} object do not affect any iterations of
     * that geometry that are already in process.
     *
     * @since 1.6
     */
    public final PathIterator getPathIterator(AffineTransform at,
                                              double flatness)
    {
<span class="nc" id="L2350">        return new FlatteningPathIterator(getPathIterator(at), flatness);</span>
    }

    /**
     * Creates a new object of the same class as this object.
     *
     * @return     a clone of this instance.
     * @exception  OutOfMemoryError            if there is not enough memory.
     * @see        java.lang.Cloneable
     * @since      1.6
     */
    public abstract Object clone();
        // Note: It would be nice to have this return Path2D
        // but one of our subclasses (GeneralPath) needs to
        // offer &quot;public Object clone()&quot; for backwards
        // compatibility so we cannot restrict it further.
        // REMIND: Can we do both somehow?

    /*
     * Support fields and methods for serializing the subclasses.
     */
    private static final byte SERIAL_STORAGE_FLT_ARRAY = 0x30;
    private static final byte SERIAL_STORAGE_DBL_ARRAY = 0x31;

    private static final byte SERIAL_SEG_FLT_MOVETO    = 0x40;
    private static final byte SERIAL_SEG_FLT_LINETO    = 0x41;
    private static final byte SERIAL_SEG_FLT_QUADTO    = 0x42;
    private static final byte SERIAL_SEG_FLT_CUBICTO   = 0x43;

    private static final byte SERIAL_SEG_DBL_MOVETO    = 0x50;
    private static final byte SERIAL_SEG_DBL_LINETO    = 0x51;
    private static final byte SERIAL_SEG_DBL_QUADTO    = 0x52;
    private static final byte SERIAL_SEG_DBL_CUBICTO   = 0x53;

    private static final byte SERIAL_SEG_CLOSE         = 0x60;
    private static final byte SERIAL_PATH_END          = 0x61;

    final void writeObject(java.io.ObjectOutputStream s, boolean isdbl)
        throws java.io.IOException
    {
<span class="nc" id="L2390">        s.defaultWriteObject();</span>

        float fCoords[];
        double dCoords[];

<span class="nc bnc" id="L2395" title="All 2 branches missed.">        if (isdbl) {</span>
<span class="nc" id="L2396">            dCoords = ((Path2D.Double) this).doubleCoords;</span>
<span class="nc" id="L2397">            fCoords = null;</span>
        } else {
<span class="nc" id="L2399">            fCoords = ((Path2D.Float) this).floatCoords;</span>
<span class="nc" id="L2400">            dCoords = null;</span>
        }

<span class="nc" id="L2403">        int numTypes = this.numTypes;</span>

<span class="nc bnc" id="L2405" title="All 2 branches missed.">        s.writeByte(isdbl</span>
                    ? SERIAL_STORAGE_DBL_ARRAY
                    : SERIAL_STORAGE_FLT_ARRAY);
<span class="nc" id="L2408">        s.writeInt(numTypes);</span>
<span class="nc" id="L2409">        s.writeInt(numCoords);</span>
<span class="nc" id="L2410">        s.writeByte((byte) windingRule);</span>

<span class="nc" id="L2412">        int cindex = 0;</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">        for (int i = 0; i &lt; numTypes; i++) {</span>
            int npoints;
            byte serialtype;
<span class="nc bnc" id="L2416" title="All 6 branches missed.">            switch (pointTypes[i]) {</span>
            case SEG_MOVETO:
<span class="nc" id="L2418">                npoints = 1;</span>
<span class="nc bnc" id="L2419" title="All 2 branches missed.">                serialtype = (isdbl</span>
                              ? SERIAL_SEG_DBL_MOVETO
                              : SERIAL_SEG_FLT_MOVETO);
<span class="nc" id="L2422">                break;</span>
            case SEG_LINETO:
<span class="nc" id="L2424">                npoints = 1;</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">                serialtype = (isdbl</span>
                              ? SERIAL_SEG_DBL_LINETO
                              : SERIAL_SEG_FLT_LINETO);
<span class="nc" id="L2428">                break;</span>
            case SEG_QUADTO:
<span class="nc" id="L2430">                npoints = 2;</span>
<span class="nc bnc" id="L2431" title="All 2 branches missed.">                serialtype = (isdbl</span>
                              ? SERIAL_SEG_DBL_QUADTO
                              : SERIAL_SEG_FLT_QUADTO);
<span class="nc" id="L2434">                break;</span>
            case SEG_CUBICTO:
<span class="nc" id="L2436">                npoints = 3;</span>
<span class="nc bnc" id="L2437" title="All 2 branches missed.">                serialtype = (isdbl</span>
                              ? SERIAL_SEG_DBL_CUBICTO
                              : SERIAL_SEG_FLT_CUBICTO);
<span class="nc" id="L2440">                break;</span>
            case SEG_CLOSE:
<span class="nc" id="L2442">                npoints = 0;</span>
<span class="nc" id="L2443">                serialtype = SERIAL_SEG_CLOSE;</span>
<span class="nc" id="L2444">                break;</span>

            default:
                // Should never happen
<span class="nc" id="L2448">                throw new InternalError(&quot;unrecognized path type&quot;);</span>
            }
<span class="nc" id="L2450">            s.writeByte(serialtype);</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">            while (--npoints &gt;= 0) {</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">                if (isdbl) {</span>
<span class="nc" id="L2453">                    s.writeDouble(dCoords[cindex++]);</span>
<span class="nc" id="L2454">                    s.writeDouble(dCoords[cindex++]);</span>
                } else {
<span class="nc" id="L2456">                    s.writeFloat(fCoords[cindex++]);</span>
<span class="nc" id="L2457">                    s.writeFloat(fCoords[cindex++]);</span>
                }
            }
        }
<span class="nc" id="L2461">        s.writeByte(SERIAL_PATH_END);</span>
<span class="nc" id="L2462">    }</span>

    final void readObject(java.io.ObjectInputStream s, boolean storedbl)
        throws java.lang.ClassNotFoundException, java.io.IOException
    {
<span class="nc" id="L2467">        s.defaultReadObject();</span>

        // The subclass calls this method with the storage type that
        // they want us to use (storedbl) so we ignore the storage
        // method hint from the stream.
<span class="nc" id="L2472">        s.readByte();</span>
<span class="nc" id="L2473">        int nT = s.readInt();</span>
<span class="nc" id="L2474">        int nC = s.readInt();</span>
        try {
<span class="nc" id="L2476">            setWindingRule(s.readByte());</span>
<span class="nc" id="L2477">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L2478">            throw new java.io.InvalidObjectException(iae.getMessage());</span>
<span class="nc" id="L2479">        }</span>

<span class="nc bnc" id="L2481" title="All 2 branches missed.">        pointTypes = new byte[(nT &lt; 0) ? INIT_SIZE : nT];</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">        if (nC &lt; 0) {</span>
<span class="nc" id="L2483">            nC = INIT_SIZE * 2;</span>
        }
<span class="nc bnc" id="L2485" title="All 2 branches missed.">        if (storedbl) {</span>
<span class="nc" id="L2486">            ((Path2D.Double) this).doubleCoords = new double[nC];</span>
        } else {
<span class="nc" id="L2488">            ((Path2D.Float) this).floatCoords = new float[nC];</span>
        }

    PATHDONE:
<span class="nc bnc" id="L2492" title="All 4 branches missed.">        for (int i = 0; nT &lt; 0 || i &lt; nT; i++) {</span>
            boolean isdbl;
            int npoints;
            byte segtype;

<span class="nc" id="L2497">            byte serialtype = s.readByte();</span>
<span class="nc bnc" id="L2498" title="All 11 branches missed.">            switch (serialtype) {</span>
            case SERIAL_SEG_FLT_MOVETO:
<span class="nc" id="L2500">                isdbl = false;</span>
<span class="nc" id="L2501">                npoints = 1;</span>
<span class="nc" id="L2502">                segtype = SEG_MOVETO;</span>
<span class="nc" id="L2503">                break;</span>
            case SERIAL_SEG_FLT_LINETO:
<span class="nc" id="L2505">                isdbl = false;</span>
<span class="nc" id="L2506">                npoints = 1;</span>
<span class="nc" id="L2507">                segtype = SEG_LINETO;</span>
<span class="nc" id="L2508">                break;</span>
            case SERIAL_SEG_FLT_QUADTO:
<span class="nc" id="L2510">                isdbl = false;</span>
<span class="nc" id="L2511">                npoints = 2;</span>
<span class="nc" id="L2512">                segtype = SEG_QUADTO;</span>
<span class="nc" id="L2513">                break;</span>
            case SERIAL_SEG_FLT_CUBICTO:
<span class="nc" id="L2515">                isdbl = false;</span>
<span class="nc" id="L2516">                npoints = 3;</span>
<span class="nc" id="L2517">                segtype = SEG_CUBICTO;</span>
<span class="nc" id="L2518">                break;</span>

            case SERIAL_SEG_DBL_MOVETO:
<span class="nc" id="L2521">                isdbl = true;</span>
<span class="nc" id="L2522">                npoints = 1;</span>
<span class="nc" id="L2523">                segtype = SEG_MOVETO;</span>
<span class="nc" id="L2524">                break;</span>
            case SERIAL_SEG_DBL_LINETO:
<span class="nc" id="L2526">                isdbl = true;</span>
<span class="nc" id="L2527">                npoints = 1;</span>
<span class="nc" id="L2528">                segtype = SEG_LINETO;</span>
<span class="nc" id="L2529">                break;</span>
            case SERIAL_SEG_DBL_QUADTO:
<span class="nc" id="L2531">                isdbl = true;</span>
<span class="nc" id="L2532">                npoints = 2;</span>
<span class="nc" id="L2533">                segtype = SEG_QUADTO;</span>
<span class="nc" id="L2534">                break;</span>
            case SERIAL_SEG_DBL_CUBICTO:
<span class="nc" id="L2536">                isdbl = true;</span>
<span class="nc" id="L2537">                npoints = 3;</span>
<span class="nc" id="L2538">                segtype = SEG_CUBICTO;</span>
<span class="nc" id="L2539">                break;</span>

            case SERIAL_SEG_CLOSE:
<span class="nc" id="L2542">                isdbl = false;</span>
<span class="nc" id="L2543">                npoints = 0;</span>
<span class="nc" id="L2544">                segtype = SEG_CLOSE;</span>
<span class="nc" id="L2545">                break;</span>

            case SERIAL_PATH_END:
<span class="nc bnc" id="L2548" title="All 2 branches missed.">                if (nT &lt; 0) {</span>
<span class="nc" id="L2549">                    break PATHDONE;</span>
                }
<span class="nc" id="L2551">                throw new StreamCorruptedException(&quot;unexpected PATH_END&quot;);</span>

            default:
<span class="nc" id="L2554">                throw new StreamCorruptedException(&quot;unrecognized path type&quot;);</span>
            }
<span class="nc bnc" id="L2556" title="All 2 branches missed.">            needRoom(segtype != SEG_MOVETO, npoints * 2);</span>
<span class="nc bnc" id="L2557" title="All 2 branches missed.">            if (isdbl) {</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">                while (--npoints &gt;= 0) {</span>
<span class="nc" id="L2559">                    append(s.readDouble(), s.readDouble());</span>
                }
            } else {
<span class="nc bnc" id="L2562" title="All 2 branches missed.">                while (--npoints &gt;= 0) {</span>
<span class="nc" id="L2563">                    append(s.readFloat(), s.readFloat());</span>
                }
            }
<span class="nc" id="L2566">            pointTypes[numTypes++] = segtype;</span>
        }
<span class="nc bnc" id="L2568" title="All 4 branches missed.">        if (nT &gt;= 0 &amp;&amp; s.readByte() != SERIAL_PATH_END) {</span>
<span class="nc" id="L2569">            throw new StreamCorruptedException(&quot;missing PATH_END&quot;);</span>
        }
<span class="nc" id="L2571">    }</span>

    static abstract class Iterator implements PathIterator {
        int typeIdx;
        int pointIdx;
        Path2D path;

<span class="nc" id="L2578">        static final int curvecoords[] = {2, 2, 4, 6, 0};</span>

<span class="nc" id="L2580">        Iterator(Path2D path) {</span>
<span class="nc" id="L2581">            this.path = path;</span>
<span class="nc" id="L2582">        }</span>

        public int getWindingRule() {
<span class="nc" id="L2585">            return path.getWindingRule();</span>
        }

        public boolean isDone() {
<span class="nc bnc" id="L2589" title="All 2 branches missed.">            return (typeIdx &gt;= path.numTypes);</span>
        }

        public void next() {
<span class="nc" id="L2593">            int type = path.pointTypes[typeIdx++];</span>
<span class="nc" id="L2594">            pointIdx += curvecoords[type];</span>
<span class="nc" id="L2595">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>