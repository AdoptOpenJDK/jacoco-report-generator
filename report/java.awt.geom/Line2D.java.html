<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Line2D.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.geom</a> &gt; <span class="el_source">Line2D.java</span></div><h1>Line2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.geom;

import java.awt.Shape;
import java.awt.Rectangle;
import java.io.Serializable;

/**
 * This &lt;code&gt;Line2D&lt;/code&gt; represents a line segment in {@code (x,y)}
 * coordinate space.  This class, like all of the Java 2D API, uses a
 * default coordinate system called &lt;i&gt;user space&lt;/i&gt; in which the y-axis
 * values increase downward and x-axis values increase to the right.  For
 * more information on the user space coordinate system, see the
 * &lt;a href=&quot;http://docs.oracle.com/javase/1.3/docs/guide/2d/spec/j2d-intro.fm2.html#61857&quot;&gt;
 * Coordinate Systems&lt;/a&gt; section of the Java 2D Programmer's Guide.
 * &lt;p&gt;
 * This class is only the abstract superclass for all objects that
 * store a 2D line segment.
 * The actual storage representation of the coordinates is left to
 * the subclass.
 *
 * @author      Jim Graham
 * @since 1.2
 */
public abstract class Line2D implements Shape, Cloneable {

    /**
     * A line segment specified with float coordinates.
     * @since 1.2
     */
    public static class Float extends Line2D implements Serializable {
        /**
         * The X coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
         */
        public float x1;

        /**
         * The Y coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
         */
        public float y1;

        /**
         * The X coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
         */
        public float x2;

        /**
         * The Y coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
         */
        public float y2;

        /**
         * Constructs and initializes a Line with coordinates (0, 0) &amp;rarr; (0, 0).
         * @since 1.2
         */
<span class="nc" id="L88">        public Float() {</span>
<span class="nc" id="L89">        }</span>

        /**
         * Constructs and initializes a Line from the specified coordinates.
         * @param x1 the X coordinate of the start point
         * @param y1 the Y coordinate of the start point
         * @param x2 the X coordinate of the end point
         * @param y2 the Y coordinate of the end point
         * @since 1.2
         */
<span class="nc" id="L99">        public Float(float x1, float y1, float x2, float y2) {</span>
<span class="nc" id="L100">            setLine(x1, y1, x2, y2);</span>
<span class="nc" id="L101">        }</span>

        /**
         * Constructs and initializes a &lt;code&gt;Line2D&lt;/code&gt; from the
         * specified &lt;code&gt;Point2D&lt;/code&gt; objects.
         * @param p1 the start &lt;code&gt;Point2D&lt;/code&gt; of this line segment
         * @param p2 the end &lt;code&gt;Point2D&lt;/code&gt; of this line segment
         * @since 1.2
         */
<span class="nc" id="L110">        public Float(Point2D p1, Point2D p2) {</span>
<span class="nc" id="L111">            setLine(p1, p2);</span>
<span class="nc" id="L112">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getX1() {
<span class="nc" id="L119">            return (double) x1;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getY1() {
<span class="nc" id="L127">            return (double) y1;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Point2D getP1() {
<span class="nc" id="L135">            return new Point2D.Float(x1, y1);</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getX2() {
<span class="nc" id="L143">            return (double) x2;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getY2() {
<span class="nc" id="L151">            return (double) y2;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Point2D getP2() {
<span class="nc" id="L159">            return new Point2D.Float(x2, y2);</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public void setLine(double x1, double y1, double x2, double y2) {
<span class="nc" id="L167">            this.x1 = (float) x1;</span>
<span class="nc" id="L168">            this.y1 = (float) y1;</span>
<span class="nc" id="L169">            this.x2 = (float) x2;</span>
<span class="nc" id="L170">            this.y2 = (float) y2;</span>
<span class="nc" id="L171">        }</span>

        /**
         * Sets the location of the end points of this &lt;code&gt;Line2D&lt;/code&gt;
         * to the specified float coordinates.
         * @param x1 the X coordinate of the start point
         * @param y1 the Y coordinate of the start point
         * @param x2 the X coordinate of the end point
         * @param y2 the Y coordinate of the end point
         * @since 1.2
         */
        public void setLine(float x1, float y1, float x2, float y2) {
<span class="nc" id="L183">            this.x1 = x1;</span>
<span class="nc" id="L184">            this.y1 = y1;</span>
<span class="nc" id="L185">            this.x2 = x2;</span>
<span class="nc" id="L186">            this.y2 = y2;</span>
<span class="nc" id="L187">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Rectangle2D getBounds2D() {
            float x, y, w, h;
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (x1 &lt; x2) {</span>
<span class="nc" id="L196">                x = x1;</span>
<span class="nc" id="L197">                w = x2 - x1;</span>
            } else {
<span class="nc" id="L199">                x = x2;</span>
<span class="nc" id="L200">                w = x1 - x2;</span>
            }
<span class="nc bnc" id="L202" title="All 2 branches missed.">            if (y1 &lt; y2) {</span>
<span class="nc" id="L203">                y = y1;</span>
<span class="nc" id="L204">                h = y2 - y1;</span>
            } else {
<span class="nc" id="L206">                y = y2;</span>
<span class="nc" id="L207">                h = y1 - y2;</span>
            }
<span class="nc" id="L209">            return new Rectangle2D.Float(x, y, w, h);</span>
        }

        /*
         * JDK 1.6 serialVersionUID
         */
        private static final long serialVersionUID = 6161772511649436349L;
    }

    /**
     * A line segment specified with double coordinates.
     * @since 1.2
     */
    public static class Double extends Line2D implements Serializable {
        /**
         * The X coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
         */
        public double x1;

        /**
         * The Y coordinate of the start point of the line segment.
         * @since 1.2
         * @serial
         */
        public double y1;

        /**
         * The X coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
         */
        public double x2;

        /**
         * The Y coordinate of the end point of the line segment.
         * @since 1.2
         * @serial
         */
        public double y2;

        /**
         * Constructs and initializes a Line with coordinates (0, 0) &amp;rarr; (0, 0).
         * @since 1.2
         */
<span class="nc" id="L255">        public Double() {</span>
<span class="nc" id="L256">        }</span>

        /**
         * Constructs and initializes a &lt;code&gt;Line2D&lt;/code&gt; from the
         * specified coordinates.
         * @param x1 the X coordinate of the start point
         * @param y1 the Y coordinate of the start point
         * @param x2 the X coordinate of the end point
         * @param y2 the Y coordinate of the end point
         * @since 1.2
         */
<span class="nc" id="L267">        public Double(double x1, double y1, double x2, double y2) {</span>
<span class="nc" id="L268">            setLine(x1, y1, x2, y2);</span>
<span class="nc" id="L269">        }</span>

        /**
         * Constructs and initializes a &lt;code&gt;Line2D&lt;/code&gt; from the
         * specified &lt;code&gt;Point2D&lt;/code&gt; objects.
         * @param p1 the start &lt;code&gt;Point2D&lt;/code&gt; of this line segment
         * @param p2 the end &lt;code&gt;Point2D&lt;/code&gt; of this line segment
         * @since 1.2
         */
<span class="nc" id="L278">        public Double(Point2D p1, Point2D p2) {</span>
<span class="nc" id="L279">            setLine(p1, p2);</span>
<span class="nc" id="L280">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getX1() {
<span class="nc" id="L287">            return x1;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getY1() {
<span class="nc" id="L295">            return y1;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Point2D getP1() {
<span class="nc" id="L303">            return new Point2D.Double(x1, y1);</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getX2() {
<span class="nc" id="L311">            return x2;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public double getY2() {
<span class="nc" id="L319">            return y2;</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Point2D getP2() {
<span class="nc" id="L327">            return new Point2D.Double(x2, y2);</span>
        }

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public void setLine(double x1, double y1, double x2, double y2) {
<span class="nc" id="L335">            this.x1 = x1;</span>
<span class="nc" id="L336">            this.y1 = y1;</span>
<span class="nc" id="L337">            this.x2 = x2;</span>
<span class="nc" id="L338">            this.y2 = y2;</span>
<span class="nc" id="L339">        }</span>

        /**
         * {@inheritDoc}
         * @since 1.2
         */
        public Rectangle2D getBounds2D() {
            double x, y, w, h;
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (x1 &lt; x2) {</span>
<span class="nc" id="L348">                x = x1;</span>
<span class="nc" id="L349">                w = x2 - x1;</span>
            } else {
<span class="nc" id="L351">                x = x2;</span>
<span class="nc" id="L352">                w = x1 - x2;</span>
            }
<span class="nc bnc" id="L354" title="All 2 branches missed.">            if (y1 &lt; y2) {</span>
<span class="nc" id="L355">                y = y1;</span>
<span class="nc" id="L356">                h = y2 - y1;</span>
            } else {
<span class="nc" id="L358">                y = y2;</span>
<span class="nc" id="L359">                h = y1 - y2;</span>
            }
<span class="nc" id="L361">            return new Rectangle2D.Double(x, y, w, h);</span>
        }

        /*
         * JDK 1.6 serialVersionUID
         */
        private static final long serialVersionUID = 7979627399746467499L;
    }

    /**
     * This is an abstract class that cannot be instantiated directly.
     * Type-specific implementation subclasses are available for
     * instantiation and provide a number of formats for storing
     * the information necessary to satisfy the various accessory
     * methods below.
     *
     * @see java.awt.geom.Line2D.Float
     * @see java.awt.geom.Line2D.Double
     * @since 1.2
     */
<span class="nc" id="L381">    protected Line2D() {</span>
<span class="nc" id="L382">    }</span>

    /**
     * Returns the X coordinate of the start point in double precision.
     * @return the X coordinate of the start point of this
     *         {@code Line2D} object.
     * @since 1.2
     */
    public abstract double getX1();

    /**
     * Returns the Y coordinate of the start point in double precision.
     * @return the Y coordinate of the start point of this
     *         {@code Line2D} object.
     * @since 1.2
     */
    public abstract double getY1();

    /**
     * Returns the start &lt;code&gt;Point2D&lt;/code&gt; of this &lt;code&gt;Line2D&lt;/code&gt;.
     * @return the start &lt;code&gt;Point2D&lt;/code&gt; of this &lt;code&gt;Line2D&lt;/code&gt;.
     * @since 1.2
     */
    public abstract Point2D getP1();

    /**
     * Returns the X coordinate of the end point in double precision.
     * @return the X coordinate of the end point of this
     *         {@code Line2D} object.
     * @since 1.2
     */
    public abstract double getX2();

    /**
     * Returns the Y coordinate of the end point in double precision.
     * @return the Y coordinate of the end point of this
     *         {@code Line2D} object.
     * @since 1.2
     */
    public abstract double getY2();

    /**
     * Returns the end &lt;code&gt;Point2D&lt;/code&gt; of this &lt;code&gt;Line2D&lt;/code&gt;.
     * @return the end &lt;code&gt;Point2D&lt;/code&gt; of this &lt;code&gt;Line2D&lt;/code&gt;.
     * @since 1.2
     */
    public abstract Point2D getP2();

    /**
     * Sets the location of the end points of this &lt;code&gt;Line2D&lt;/code&gt; to
     * the specified double coordinates.
     * @param x1 the X coordinate of the start point
     * @param y1 the Y coordinate of the start point
     * @param x2 the X coordinate of the end point
     * @param y2 the Y coordinate of the end point
     * @since 1.2
     */
    public abstract void setLine(double x1, double y1, double x2, double y2);

    /**
     * Sets the location of the end points of this &lt;code&gt;Line2D&lt;/code&gt; to
     * the specified &lt;code&gt;Point2D&lt;/code&gt; coordinates.
     * @param p1 the start &lt;code&gt;Point2D&lt;/code&gt; of the line segment
     * @param p2 the end &lt;code&gt;Point2D&lt;/code&gt; of the line segment
     * @since 1.2
     */
    public void setLine(Point2D p1, Point2D p2) {
<span class="nc" id="L449">        setLine(p1.getX(), p1.getY(), p2.getX(), p2.getY());</span>
<span class="nc" id="L450">    }</span>

    /**
     * Sets the location of the end points of this &lt;code&gt;Line2D&lt;/code&gt; to
     * the same as those end points of the specified &lt;code&gt;Line2D&lt;/code&gt;.
     * @param l the specified &lt;code&gt;Line2D&lt;/code&gt;
     * @since 1.2
     */
    public void setLine(Line2D l) {
<span class="nc" id="L459">        setLine(l.getX1(), l.getY1(), l.getX2(), l.getY2());</span>
<span class="nc" id="L460">    }</span>

    /**
     * Returns an indicator of where the specified point
     * {@code (px,py)} lies with respect to the line segment from
     * {@code (x1,y1)} to {@code (x2,y2)}.
     * The return value can be either 1, -1, or 0 and indicates
     * in which direction the specified line must pivot around its
     * first end point, {@code (x1,y1)}, in order to point at the
     * specified point {@code (px,py)}.
     * &lt;p&gt;A return value of 1 indicates that the line segment must
     * turn in the direction that takes the positive X axis towards
     * the negative Y axis.  In the default coordinate system used by
     * Java 2D, this direction is counterclockwise.
     * &lt;p&gt;A return value of -1 indicates that the line segment must
     * turn in the direction that takes the positive X axis towards
     * the positive Y axis.  In the default coordinate system, this
     * direction is clockwise.
     * &lt;p&gt;A return value of 0 indicates that the point lies
     * exactly on the line segment.  Note that an indicator value
     * of 0 is rare and not useful for determining collinearity
     * because of floating point rounding issues.
     * &lt;p&gt;If the point is colinear with the line segment, but
     * not between the end points, then the value will be -1 if the point
     * lies &quot;beyond {@code (x1,y1)}&quot; or 1 if the point lies
     * &quot;beyond {@code (x2,y2)}&quot;.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point to be
     *           compared with the specified line segment
     * @param py the Y coordinate of the specified point to be
     *           compared with the specified line segment
     * @return an integer that indicates the position of the third specified
     *                  coordinates with respect to the line segment formed
     *                  by the first two specified coordinates.
     * @since 1.2
     */
    public static int relativeCCW(double x1, double y1,
                                  double x2, double y2,
                                  double px, double py)
    {
<span class="nc" id="L508">        x2 -= x1;</span>
<span class="nc" id="L509">        y2 -= y1;</span>
<span class="nc" id="L510">        px -= x1;</span>
<span class="nc" id="L511">        py -= y1;</span>
<span class="nc" id="L512">        double ccw = px * y2 - py * x2;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (ccw == 0.0) {</span>
            // The point is colinear, classify based on which side of
            // the segment the point falls on.  We can calculate a
            // relative value using the projection of px,py onto the
            // segment - a negative value indicates the point projects
            // outside of the segment in the direction of the particular
            // endpoint used as the origin for the projection.
<span class="nc" id="L520">            ccw = px * x2 + py * y2;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (ccw &gt; 0.0) {</span>
                // Reverse the projection to be relative to the original x2,y2
                // x2 and y2 are simply negated.
                // px and py need to have (x2 - x1) or (y2 - y1) subtracted
                //    from them (based on the original values)
                // Since we really want to get a positive answer when the
                //    point is &quot;beyond (x2,y2)&quot;, then we want to calculate
                //    the inverse anyway - thus we leave x2 &amp; y2 negated.
<span class="nc" id="L529">                px -= x2;</span>
<span class="nc" id="L530">                py -= y2;</span>
<span class="nc" id="L531">                ccw = px * x2 + py * y2;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                if (ccw &lt; 0.0) {</span>
<span class="nc" id="L533">                    ccw = 0.0;</span>
                }
            }
        }
<span class="nc bnc" id="L537" title="All 4 branches missed.">        return (ccw &lt; 0.0) ? -1 : ((ccw &gt; 0.0) ? 1 : 0);</span>
    }

    /**
     * Returns an indicator of where the specified point
     * {@code (px,py)} lies with respect to this line segment.
     * See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)}
     * to interpret the return value.
     * @param px the X coordinate of the specified point
     *           to be compared with this &lt;code&gt;Line2D&lt;/code&gt;
     * @param py the Y coordinate of the specified point
     *           to be compared with this &lt;code&gt;Line2D&lt;/code&gt;
     * @return an integer that indicates the position of the specified
     *         coordinates with respect to this &lt;code&gt;Line2D&lt;/code&gt;
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    public int relativeCCW(double px, double py) {
<span class="nc" id="L556">        return relativeCCW(getX1(), getY1(), getX2(), getY2(), px, py);</span>
    }

    /**
     * Returns an indicator of where the specified &lt;code&gt;Point2D&lt;/code&gt;
     * lies with respect to this line segment.
     * See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)}
     * to interpret the return value.
     * @param p the specified &lt;code&gt;Point2D&lt;/code&gt; to be compared
     *          with this &lt;code&gt;Line2D&lt;/code&gt;
     * @return an integer that indicates the position of the specified
     *         &lt;code&gt;Point2D&lt;/code&gt; with respect to this &lt;code&gt;Line2D&lt;/code&gt;
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    public int relativeCCW(Point2D p) {
<span class="nc" id="L573">        return relativeCCW(getX1(), getY1(), getX2(), getY2(),</span>
<span class="nc" id="L574">                           p.getX(), p.getY());</span>
    }

    /**
     * Tests if the line segment from {@code (x1,y1)} to
     * {@code (x2,y2)} intersects the line segment from {@code (x3,y3)}
     * to {@code (x4,y4)}.
     *
     * @param x1 the X coordinate of the start point of the first
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the first
     *           specified line segment
     * @param x2 the X coordinate of the end point of the first
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the first
     *           specified line segment
     * @param x3 the X coordinate of the start point of the second
     *           specified line segment
     * @param y3 the Y coordinate of the start point of the second
     *           specified line segment
     * @param x4 the X coordinate of the end point of the second
     *           specified line segment
     * @param y4 the Y coordinate of the end point of the second
     *           specified line segment
     * @return &lt;code&gt;true&lt;/code&gt; if the first specified line segment
     *                  and the second specified line segment intersect
     *                  each other; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public static boolean linesIntersect(double x1, double y1,
                                         double x2, double y2,
                                         double x3, double y3,
                                         double x4, double y4)
    {
<span class="nc" id="L608">        return ((relativeCCW(x1, y1, x2, y2, x3, y3) *</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                 relativeCCW(x1, y1, x2, y2, x4, y4) &lt;= 0)</span>
<span class="nc" id="L610">                &amp;&amp; (relativeCCW(x3, y3, x4, y4, x1, y1) *</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    relativeCCW(x3, y3, x4, y4, x2, y2) &lt;= 0));</span>
    }

    /**
     * Tests if the line segment from {@code (x1,y1)} to
     * {@code (x2,y2)} intersects this line segment.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @return {@code &lt;true&gt;} if this line segment and the specified line segment
     *                  intersect each other; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public boolean intersectsLine(double x1, double y1, double x2, double y2) {
<span class="nc" id="L631">        return linesIntersect(x1, y1, x2, y2,</span>
<span class="nc" id="L632">                              getX1(), getY1(), getX2(), getY2());</span>
    }

    /**
     * Tests if the specified line segment intersects this line segment.
     * @param l the specified &lt;code&gt;Line2D&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if this line segment and the specified line
     *                  segment intersect each other;
     *                  &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.2
     */
    public boolean intersectsLine(Line2D l) {
<span class="nc" id="L644">        return linesIntersect(l.getX1(), l.getY1(), l.getX2(), l.getY2(),</span>
<span class="nc" id="L645">                              getX1(), getY1(), getX2(), getY2());</span>
    }

    /**
     * Returns the square of the distance from a point to a line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the specified end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point being
     *           measured against the specified line segment
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line segment
     * @return a double value that is the square of the distance from the
     *                  specified point to the specified line segment.
     * @see #ptLineDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
    public static double ptSegDistSq(double x1, double y1,
                                     double x2, double y2,
                                     double px, double py)
    {
        // Adjust vectors relative to x1,y1
        // x2,y2 becomes relative vector from x1,y1 to end of segment
<span class="nc" id="L678">        x2 -= x1;</span>
<span class="nc" id="L679">        y2 -= y1;</span>
        // px,py becomes relative vector from x1,y1 to test point
<span class="nc" id="L681">        px -= x1;</span>
<span class="nc" id="L682">        py -= y1;</span>
<span class="nc" id="L683">        double dotprod = px * x2 + py * y2;</span>
        double projlenSq;
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (dotprod &lt;= 0.0) {</span>
            // px,py is on the side of x1,y1 away from x2,y2
            // distance to segment is length of px,py vector
            // &quot;length of its (clipped) projection&quot; is now 0.0
<span class="nc" id="L689">            projlenSq = 0.0;</span>
        } else {
            // switch to backwards vectors relative to x2,y2
            // x2,y2 are already the negative of x1,y1=&gt;x2,y2
            // to get px,py to be the negative of px,py=&gt;x2,y2
            // the dot product of two negated vectors is the same
            // as the dot product of the two normal vectors
<span class="nc" id="L696">            px = x2 - px;</span>
<span class="nc" id="L697">            py = y2 - py;</span>
<span class="nc" id="L698">            dotprod = px * x2 + py * y2;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if (dotprod &lt;= 0.0) {</span>
                // px,py is on the side of x2,y2 away from x1,y1
                // distance to segment is length of (backwards) px,py vector
                // &quot;length of its (clipped) projection&quot; is now 0.0
<span class="nc" id="L703">                projlenSq = 0.0;</span>
            } else {
                // px,py is between x1,y1 and x2,y2
                // dotprod is the length of the px,py vector
                // projected on the x2,y2=&gt;x1,y1 vector times the
                // length of the x2,y2=&gt;x1,y1 vector
<span class="nc" id="L709">                projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);</span>
            }
        }
        // Distance to line is now the length of the relative point
        // vector minus the length of its projection onto the line
        // (which is zero if the projection falls outside the range
        //  of the line segment).
<span class="nc" id="L716">        double lenSq = px * px + py * py - projlenSq;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (lenSq &lt; 0) {</span>
<span class="nc" id="L718">            lenSq = 0;</span>
        }
<span class="nc" id="L720">        return lenSq;</span>
    }

    /**
     * Returns the distance from a point to a line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the specified end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the
     *           specified line segment
     * @param y1 the Y coordinate of the start point of the
     *           specified line segment
     * @param x2 the X coordinate of the end point of the
     *           specified line segment
     * @param y2 the Y coordinate of the end point of the
     *           specified line segment
     * @param px the X coordinate of the specified point being
     *           measured against the specified line segment
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line segment
     * @return a double value that is the distance from the specified point
     *                          to the specified line segment.
     * @see #ptLineDist(double, double, double, double, double, double)
     * @since 1.2
     */
    public static double ptSegDist(double x1, double y1,
                                   double x2, double y2,
                                   double px, double py)
    {
<span class="nc" id="L751">        return Math.sqrt(ptSegDistSq(x1, y1, x2, y2, px, py));</span>
    }

    /**
     * Returns the square of the distance from a point to this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line segment
     * @param py the Y coordinate of the specified point being
     *           measured against this line segment
     * @return a double value that is the square of the distance from the
     *                  specified point to the current line segment.
     * @see #ptLineDistSq(double, double)
     * @since 1.2
     */
    public double ptSegDistSq(double px, double py) {
<span class="nc" id="L771">        return ptSegDistSq(getX1(), getY1(), getX2(), getY2(), px, py);</span>
    }

    /**
     * Returns the square of the distance from a &lt;code&gt;Point2D&lt;/code&gt; to
     * this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     * @param pt the specified &lt;code&gt;Point2D&lt;/code&gt; being measured against
     *           this line segment.
     * @return a double value that is the square of the distance from the
     *                  specified &lt;code&gt;Point2D&lt;/code&gt; to the current
     *                  line segment.
     * @see #ptLineDistSq(Point2D)
     * @since 1.2
     */
    public double ptSegDistSq(Point2D pt) {
<span class="nc" id="L790">        return ptSegDistSq(getX1(), getY1(), getX2(), getY2(),</span>
<span class="nc" id="L791">                           pt.getX(), pt.getY());</span>
    }

    /**
     * Returns the distance from a point to this line segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line segment
     * @param py the Y coordinate of the specified point being
     *           measured against this line segment
     * @return a double value that is the distance from the specified
     *                  point to the current line segment.
     * @see #ptLineDist(double, double)
     * @since 1.2
     */
    public double ptSegDist(double px, double py) {
<span class="nc" id="L811">        return ptSegDist(getX1(), getY1(), getX2(), getY2(), px, py);</span>
    }

    /**
     * Returns the distance from a &lt;code&gt;Point2D&lt;/code&gt; to this line
     * segment.
     * The distance measured is the distance between the specified
     * point and the closest point between the current line's end points.
     * If the specified point intersects the line segment in between the
     * end points, this method returns 0.0.
     * @param pt the specified &lt;code&gt;Point2D&lt;/code&gt; being measured
     *          against this line segment
     * @return a double value that is the distance from the specified
     *                          &lt;code&gt;Point2D&lt;/code&gt; to the current line
     *                          segment.
     * @see #ptLineDist(Point2D)
     * @since 1.2
     */
    public double ptSegDist(Point2D pt) {
<span class="nc" id="L830">        return ptSegDist(getX1(), getY1(), getX2(), getY2(),</span>
<span class="nc" id="L831">                         pt.getX(), pt.getY());</span>
    }

    /**
     * Returns the square of the distance from a point to a line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by the specified coordinates.  If the specified point
     * intersects the line, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the specified line
     * @param y1 the Y coordinate of the start point of the specified line
     * @param x2 the X coordinate of the end point of the specified line
     * @param y2 the Y coordinate of the end point of the specified line
     * @param px the X coordinate of the specified point being
     *           measured against the specified line
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line
     * @return a double value that is the square of the distance from the
     *                  specified point to the specified line.
     * @see #ptSegDistSq(double, double, double, double, double, double)
     * @since 1.2
     */
    public static double ptLineDistSq(double x1, double y1,
                                      double x2, double y2,
                                      double px, double py)
    {
        // Adjust vectors relative to x1,y1
        // x2,y2 becomes relative vector from x1,y1 to end of segment
<span class="nc" id="L860">        x2 -= x1;</span>
<span class="nc" id="L861">        y2 -= y1;</span>
        // px,py becomes relative vector from x1,y1 to test point
<span class="nc" id="L863">        px -= x1;</span>
<span class="nc" id="L864">        py -= y1;</span>
<span class="nc" id="L865">        double dotprod = px * x2 + py * y2;</span>
        // dotprod is the length of the px,py vector
        // projected on the x1,y1=&gt;x2,y2 vector times the
        // length of the x1,y1=&gt;x2,y2 vector
<span class="nc" id="L869">        double projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);</span>
        // Distance to line is now the length of the relative point
        // vector minus the length of its projection onto the line
<span class="nc" id="L872">        double lenSq = px * px + py * py - projlenSq;</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (lenSq &lt; 0) {</span>
<span class="nc" id="L874">            lenSq = 0;</span>
        }
<span class="nc" id="L876">        return lenSq;</span>
    }

    /**
     * Returns the distance from a point to a line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by the specified coordinates.  If the specified point
     * intersects the line, this method returns 0.0.
     *
     * @param x1 the X coordinate of the start point of the specified line
     * @param y1 the Y coordinate of the start point of the specified line
     * @param x2 the X coordinate of the end point of the specified line
     * @param y2 the Y coordinate of the end point of the specified line
     * @param px the X coordinate of the specified point being
     *           measured against the specified line
     * @param py the Y coordinate of the specified point being
     *           measured against the specified line
     * @return a double value that is the distance from the specified
     *                   point to the specified line.
     * @see #ptSegDist(double, double, double, double, double, double)
     * @since 1.2
     */
    public static double ptLineDist(double x1, double y1,
                                    double x2, double y2,
                                    double px, double py)
    {
<span class="nc" id="L903">        return Math.sqrt(ptLineDistSq(x1, y1, x2, y2, px, py));</span>
    }

    /**
     * Returns the square of the distance from a point to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this &lt;code&gt;Line2D&lt;/code&gt;.  If the specified point
     * intersects the line, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line
     * @param py the Y coordinate of the specified point being
     *           measured against this line
     * @return a double value that is the square of the distance from a
     *                  specified point to the current line.
     * @see #ptSegDistSq(double, double)
     * @since 1.2
     */
    public double ptLineDistSq(double px, double py) {
<span class="nc" id="L923">        return ptLineDistSq(getX1(), getY1(), getX2(), getY2(), px, py);</span>
    }

    /**
     * Returns the square of the distance from a specified
     * &lt;code&gt;Point2D&lt;/code&gt; to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this &lt;code&gt;Line2D&lt;/code&gt;.  If the specified point
     * intersects the line, this method returns 0.0.
     * @param pt the specified &lt;code&gt;Point2D&lt;/code&gt; being measured
     *           against this line
     * @return a double value that is the square of the distance from a
     *                  specified &lt;code&gt;Point2D&lt;/code&gt; to the current
     *                  line.
     * @see #ptSegDistSq(Point2D)
     * @since 1.2
     */
    public double ptLineDistSq(Point2D pt) {
<span class="nc" id="L942">        return ptLineDistSq(getX1(), getY1(), getX2(), getY2(),</span>
<span class="nc" id="L943">                            pt.getX(), pt.getY());</span>
    }

    /**
     * Returns the distance from a point to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this &lt;code&gt;Line2D&lt;/code&gt;.  If the specified point
     * intersects the line, this method returns 0.0.
     *
     * @param px the X coordinate of the specified point being
     *           measured against this line
     * @param py the Y coordinate of the specified point being
     *           measured against this line
     * @return a double value that is the distance from a specified point
     *                  to the current line.
     * @see #ptSegDist(double, double)
     * @since 1.2
     */
    public double ptLineDist(double px, double py) {
<span class="nc" id="L963">        return ptLineDist(getX1(), getY1(), getX2(), getY2(), px, py);</span>
    }

    /**
     * Returns the distance from a &lt;code&gt;Point2D&lt;/code&gt; to this line.
     * The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line
     * defined by this &lt;code&gt;Line2D&lt;/code&gt;.  If the specified point
     * intersects the line, this method returns 0.0.
     * @param pt the specified &lt;code&gt;Point2D&lt;/code&gt; being measured
     * @return a double value that is the distance from a specified
     *                  &lt;code&gt;Point2D&lt;/code&gt; to the current line.
     * @see #ptSegDist(Point2D)
     * @since 1.2
     */
    public double ptLineDist(Point2D pt) {
<span class="nc" id="L979">        return ptLineDist(getX1(), getY1(), getX2(), getY2(),</span>
<span class="nc" id="L980">                         pt.getX(), pt.getY());</span>
    }

    /**
     * Tests if a specified coordinate is inside the boundary of this
     * &lt;code&gt;Line2D&lt;/code&gt;.  This method is required to implement the
     * {@link Shape} interface, but in the case of &lt;code&gt;Line2D&lt;/code&gt;
     * objects it always returns &lt;code&gt;false&lt;/code&gt; since a line contains
     * no area.
     * @param x the X coordinate of the specified point to be tested
     * @param y the Y coordinate of the specified point to be tested
     * @return &lt;code&gt;false&lt;/code&gt; because a &lt;code&gt;Line2D&lt;/code&gt; contains
     * no area.
     * @since 1.2
     */
    public boolean contains(double x, double y) {
<span class="nc" id="L996">        return false;</span>
    }

    /**
     * Tests if a given &lt;code&gt;Point2D&lt;/code&gt; is inside the boundary of
     * this &lt;code&gt;Line2D&lt;/code&gt;.
     * This method is required to implement the {@link Shape} interface,
     * but in the case of &lt;code&gt;Line2D&lt;/code&gt; objects it always returns
     * &lt;code&gt;false&lt;/code&gt; since a line contains no area.
     * @param p the specified &lt;code&gt;Point2D&lt;/code&gt; to be tested
     * @return &lt;code&gt;false&lt;/code&gt; because a &lt;code&gt;Line2D&lt;/code&gt; contains
     * no area.
     * @since 1.2
     */
    public boolean contains(Point2D p) {
<span class="nc" id="L1011">        return false;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean intersects(double x, double y, double w, double h) {
<span class="nc" id="L1019">        return intersects(new Rectangle2D.Double(x, y, w, h));</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public boolean intersects(Rectangle2D r) {
<span class="nc" id="L1027">        return r.intersectsLine(getX1(), getY1(), getX2(), getY2());</span>
    }

    /**
     * Tests if the interior of this &lt;code&gt;Line2D&lt;/code&gt; entirely contains
     * the specified set of rectangular coordinates.
     * This method is required to implement the &lt;code&gt;Shape&lt;/code&gt; interface,
     * but in the case of &lt;code&gt;Line2D&lt;/code&gt; objects it always returns
     * false since a line contains no area.
     * @param x the X coordinate of the upper-left corner of the
     *          specified rectangular area
     * @param y the Y coordinate of the upper-left corner of the
     *          specified rectangular area
     * @param w the width of the specified rectangular area
     * @param h the height of the specified rectangular area
     * @return &lt;code&gt;false&lt;/code&gt; because a &lt;code&gt;Line2D&lt;/code&gt; contains
     * no area.
     * @since 1.2
     */
    public boolean contains(double x, double y, double w, double h) {
<span class="nc" id="L1047">        return false;</span>
    }

    /**
     * Tests if the interior of this &lt;code&gt;Line2D&lt;/code&gt; entirely contains
     * the specified &lt;code&gt;Rectangle2D&lt;/code&gt;.
     * This method is required to implement the &lt;code&gt;Shape&lt;/code&gt; interface,
     * but in the case of &lt;code&gt;Line2D&lt;/code&gt; objects it always returns
     * &lt;code&gt;false&lt;/code&gt; since a line contains no area.
     * @param r the specified &lt;code&gt;Rectangle2D&lt;/code&gt; to be tested
     * @return &lt;code&gt;false&lt;/code&gt; because a &lt;code&gt;Line2D&lt;/code&gt; contains
     * no area.
     * @since 1.2
     */
    public boolean contains(Rectangle2D r) {
<span class="nc" id="L1062">        return false;</span>
    }

    /**
     * {@inheritDoc}
     * @since 1.2
     */
    public Rectangle getBounds() {
<span class="nc" id="L1070">        return getBounds2D().getBounds();</span>
    }

    /**
     * Returns an iteration object that defines the boundary of this
     * &lt;code&gt;Line2D&lt;/code&gt;.
     * The iterator for this class is not multi-threaded safe,
     * which means that this &lt;code&gt;Line2D&lt;/code&gt; class does not
     * guarantee that modifications to the geometry of this
     * &lt;code&gt;Line2D&lt;/code&gt; object do not affect any iterations of that
     * geometry that are already in process.
     * @param at the specified {@link AffineTransform}
     * @return a {@link PathIterator} that defines the boundary of this
     *          &lt;code&gt;Line2D&lt;/code&gt;.
     * @since 1.2
     */
    public PathIterator getPathIterator(AffineTransform at) {
<span class="nc" id="L1087">        return new LineIterator(this, at);</span>
    }

    /**
     * Returns an iteration object that defines the boundary of this
     * flattened &lt;code&gt;Line2D&lt;/code&gt;.
     * The iterator for this class is not multi-threaded safe,
     * which means that this &lt;code&gt;Line2D&lt;/code&gt; class does not
     * guarantee that modifications to the geometry of this
     * &lt;code&gt;Line2D&lt;/code&gt; object do not affect any iterations of that
     * geometry that are already in process.
     * @param at the specified &lt;code&gt;AffineTransform&lt;/code&gt;
     * @param flatness the maximum amount that the control points for a
     *          given curve can vary from colinear before a subdivided
     *          curve is replaced by a straight line connecting the
     *          end points.  Since a &lt;code&gt;Line2D&lt;/code&gt; object is
     *          always flat, this parameter is ignored.
     * @return a &lt;code&gt;PathIterator&lt;/code&gt; that defines the boundary of the
     *                  flattened &lt;code&gt;Line2D&lt;/code&gt;
     * @since 1.2
     */
    public PathIterator getPathIterator(AffineTransform at, double flatness) {
<span class="nc" id="L1109">        return new LineIterator(this, at);</span>
    }

    /**
     * Creates a new object of the same class as this object.
     *
     * @return     a clone of this instance.
     * @exception  OutOfMemoryError            if there is not enough memory.
     * @see        java.lang.Cloneable
     * @since      1.2
     */
    public Object clone() {
        try {
<span class="nc" id="L1122">            return super.clone();</span>
<span class="nc" id="L1123">        } catch (CloneNotSupportedException e) {</span>
            // this shouldn't happen, since we are Cloneable
<span class="nc" id="L1125">            throw new InternalError(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>