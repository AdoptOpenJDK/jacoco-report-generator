<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HierMemDirCtx.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.toolkit.dir</a> &gt; <span class="el_source">HierMemDirCtx.java</span></div><h1>HierMemDirCtx.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.jndi.toolkit.dir;

import javax.naming.*;
import javax.naming.directory.*;
import javax.naming.spi.*;
import java.util.*;

/**
 * A sample service provider that implements a hierarchical directory in memory.
 * Every operation begins by doing a lookup on the name passed to it and then
 * calls a corresponding &quot;do&lt;OperationName&gt;&quot; on the result of the lookup. The
 * &quot;do&lt;OperationName&gt;&quot; does the work without any further resolution (it assumes
 * that it is the target context).
 */

public class HierMemDirCtx implements DirContext {

    static private final boolean debug = false;
<span class="fc" id="L43">    private static final NameParser defaultParser = new HierarchicalNameParser();</span>

    protected Hashtable&lt;String, Object&gt; myEnv;
    protected Hashtable&lt;Name, Object&gt; bindings;
    protected Attributes attrs;
<span class="fc" id="L48">    protected boolean ignoreCase = false;</span>
<span class="fc" id="L49">    protected NamingException readOnlyEx = null;</span>
<span class="fc" id="L50">    protected NameParser myParser = defaultParser;</span>

    private boolean alwaysUseFactory;

    public void close() throws NamingException {
<span class="nc" id="L55">        myEnv = null;</span>
<span class="nc" id="L56">        bindings = null;</span>
<span class="nc" id="L57">        attrs = null;</span>
<span class="nc" id="L58">    }</span>

    public String getNameInNamespace() throws NamingException {
<span class="nc" id="L61">        throw new OperationNotSupportedException(</span>
            &quot;Cannot determine full name&quot;);
    }

    public HierMemDirCtx() {
<span class="fc" id="L66">        this(null, false, false);</span>
<span class="fc" id="L67">    }</span>

    public HierMemDirCtx(boolean ignoreCase) {
<span class="nc" id="L70">        this(null, ignoreCase, false);</span>
<span class="nc" id="L71">    }</span>

    public HierMemDirCtx(Hashtable&lt;String, Object&gt; environment, boolean ignoreCase) {
<span class="nc" id="L74">        this(environment, ignoreCase, false);</span>
<span class="nc" id="L75">    }</span>

    protected HierMemDirCtx(Hashtable&lt;String, Object&gt; environment,
<span class="fc" id="L78">        boolean ignoreCase, boolean useFac) {</span>
<span class="fc" id="L79">        myEnv = environment;</span>
<span class="fc" id="L80">        this.ignoreCase = ignoreCase;</span>
<span class="fc" id="L81">        init();</span>
<span class="fc" id="L82">        this.alwaysUseFactory = useFac;</span>
<span class="fc" id="L83">    }</span>

    private void init() {
<span class="fc" id="L86">        attrs = new BasicAttributes(ignoreCase);</span>
<span class="fc" id="L87">        bindings = new Hashtable&lt;&gt;(11, 0.75f);</span>
<span class="fc" id="L88">    }</span>

    public Object lookup(String name) throws NamingException {
<span class="nc" id="L91">        return lookup(myParser.parse(name));</span>
    }

    public Object lookup(Name name) throws NamingException {
<span class="nc" id="L95">        return doLookup(name, alwaysUseFactory);</span>
    }

    public Object doLookup(Name name, boolean useFactory)
        throws NamingException {

<span class="nc" id="L101">        Object target = null;</span>
<span class="nc" id="L102">        name = canonizeName(name);</span>

<span class="nc bnc" id="L104" title="All 3 branches missed.">        switch(name.size()) {</span>
        case 0:
            // name is empty, caller wants this object
<span class="nc" id="L107">            target = this;</span>
<span class="nc" id="L108">            break;</span>

        case 1:
            // name is atomic, caller wants one of this object's bindings
<span class="nc" id="L112">            target = bindings.get(name);</span>
<span class="nc" id="L113">            break;</span>

        default:
            // name is compound, delegate to child context
<span class="nc" id="L117">            HierMemDirCtx ctx = (HierMemDirCtx)bindings.get(name.getPrefix(1));</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if(ctx == null) {</span>
<span class="nc" id="L119">                target = null;</span>
            } else {
<span class="nc" id="L121">                target = ctx.doLookup(name.getSuffix(1), false);</span>
            }
            break;
        }

<span class="nc bnc" id="L126" title="All 2 branches missed.">        if(target == null) {</span>
<span class="nc" id="L127">            throw new NameNotFoundException(name.toString());</span>
        }

<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (useFactory) {</span>
            try {
<span class="nc bnc" id="L132" title="All 2 branches missed.">                return DirectoryManager.getObjectInstance(target,</span>
                    name, this, myEnv,
                    (target instanceof HierMemDirCtx) ?
                    ((HierMemDirCtx)target).attrs : null);
<span class="nc" id="L136">            } catch (NamingException e) {</span>
<span class="nc" id="L137">                throw e;</span>
<span class="nc" id="L138">            } catch (Exception e) {</span>
<span class="nc" id="L139">                NamingException e2 = new NamingException(</span>
                    &quot;Problem calling getObjectInstance&quot;);
<span class="nc" id="L141">                e2.setRootCause(e);</span>
<span class="nc" id="L142">                throw e2;</span>
            }
        } else {
<span class="nc" id="L145">            return target;</span>
        }
    }

    public void bind(String name, Object obj) throws NamingException {
<span class="nc" id="L150">        bind(myParser.parse(name), obj);</span>
<span class="nc" id="L151">    }</span>

    public void bind(Name name, Object obj) throws NamingException {
<span class="nc" id="L154">        doBind(name, obj, null, alwaysUseFactory);</span>
<span class="nc" id="L155">    }</span>

    public void bind(String name, Object obj, Attributes attrs)
            throws NamingException {
<span class="nc" id="L159">        bind(myParser.parse(name), obj, attrs);</span>
<span class="nc" id="L160">    }</span>

    public void bind(Name name, Object obj, Attributes attrs)
            throws NamingException {
<span class="nc" id="L164">        doBind(name, obj, attrs, alwaysUseFactory);</span>
<span class="nc" id="L165">    }</span>

    protected void doBind(Name name, Object obj, Attributes attrs,
        boolean useFactory) throws NamingException {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L170">            throw new InvalidNameException(&quot;Cannot bind empty name&quot;);</span>
        }

<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (useFactory) {</span>
<span class="nc" id="L174">            DirStateFactory.Result res = DirectoryManager.getStateToBind(</span>
                obj, name, this, myEnv, attrs);
<span class="nc" id="L176">            obj = res.getObject();</span>
<span class="nc" id="L177">            attrs = res.getAttributes();</span>
        }

<span class="nc" id="L180">        HierMemDirCtx ctx= (HierMemDirCtx) doLookup(getInternalName(name), false);</span>
<span class="nc" id="L181">        ctx.doBindAux(getLeafName(name), obj);</span>

<span class="nc bnc" id="L183" title="All 4 branches missed.">        if (attrs != null &amp;&amp; attrs.size() &gt; 0) {</span>
<span class="nc" id="L184">            modifyAttributes(name, ADD_ATTRIBUTE, attrs);</span>
        }
<span class="nc" id="L186">    }</span>

    protected void doBindAux(Name name, Object obj) throws NamingException {
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L190">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }

<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (bindings.get(name) != null) {</span>
<span class="nc" id="L194">            throw new NameAlreadyBoundException(name.toString());</span>
        }
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if(obj instanceof HierMemDirCtx) {</span>
<span class="nc" id="L197">            bindings.put(name, obj);</span>
        } else {
<span class="nc" id="L199">            throw new SchemaViolationException(</span>
                &quot;This context only supports binding objects of it's own kind&quot;);
        }
<span class="nc" id="L202">    }</span>

    public void rebind(String name, Object obj) throws NamingException {
<span class="nc" id="L205">        rebind(myParser.parse(name), obj);</span>
<span class="nc" id="L206">    }</span>

    public void rebind(Name name, Object obj) throws NamingException {
<span class="nc" id="L209">        doRebind(name, obj, null, alwaysUseFactory);</span>
<span class="nc" id="L210">    }</span>

    public void rebind(String name, Object obj, Attributes attrs)
            throws NamingException {
<span class="nc" id="L214">        rebind(myParser.parse(name), obj, attrs);</span>
<span class="nc" id="L215">    }</span>

    public void rebind(Name name, Object obj, Attributes attrs)
            throws NamingException {
<span class="nc" id="L219">        doRebind(name, obj, attrs, alwaysUseFactory);</span>
<span class="nc" id="L220">    }</span>

    protected void doRebind(Name name, Object obj, Attributes attrs,
        boolean useFactory) throws NamingException {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L225">            throw new InvalidNameException(&quot;Cannot rebind empty name&quot;);</span>
        }

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (useFactory) {</span>
<span class="nc" id="L229">            DirStateFactory.Result res = DirectoryManager.getStateToBind(</span>
                obj, name, this, myEnv, attrs);
<span class="nc" id="L231">            obj = res.getObject();</span>
<span class="nc" id="L232">            attrs = res.getAttributes();</span>
        }

<span class="nc" id="L235">        HierMemDirCtx ctx= (HierMemDirCtx) doLookup(getInternalName(name), false);</span>
<span class="nc" id="L236">        ctx.doRebindAux(getLeafName(name), obj);</span>

        //
        // attrs == null -&gt; use attrs from obj
        // attrs != null -&gt; use attrs
        //
        // %%% Strictly speaking, when attrs is non-null, we should
        // take the explicit step of removing obj's attrs.
        // We don't do that currently.

<span class="nc bnc" id="L246" title="All 4 branches missed.">        if (attrs != null &amp;&amp; attrs.size() &gt; 0) {</span>
<span class="nc" id="L247">            modifyAttributes(name, ADD_ATTRIBUTE, attrs);</span>
        }
<span class="nc" id="L249">    }</span>

    protected void doRebindAux(Name name, Object obj) throws NamingException {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L253">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if(obj instanceof HierMemDirCtx) {</span>
<span class="nc" id="L256">            bindings.put(name, obj);</span>

        } else {
<span class="nc" id="L259">            throw new SchemaViolationException(</span>
                &quot;This context only supports binding objects of it's own kind&quot;);
        }
<span class="nc" id="L262">    }</span>

    public void unbind(String name) throws NamingException {
<span class="nc" id="L265">        unbind(myParser.parse(name));</span>
<span class="nc" id="L266">    }</span>

    public void unbind(Name name) throws NamingException {
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (name.isEmpty()) {</span>
<span class="nc" id="L270">            throw new InvalidNameException(&quot;Cannot unbind empty name&quot;);</span>
        } else {
<span class="nc" id="L272">            HierMemDirCtx ctx=</span>
<span class="nc" id="L273">                (HierMemDirCtx) doLookup(getInternalName(name), false);</span>
<span class="nc" id="L274">            ctx.doUnbind(getLeafName(name));</span>
        }
<span class="nc" id="L276">    }</span>

    protected void doUnbind(Name name) throws NamingException {
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L280">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }

<span class="nc" id="L283">        bindings.remove(name);  // attrs will also be removed along with ctx</span>
<span class="nc" id="L284">    }</span>

    public void rename(String oldname, String newname)
            throws NamingException {
<span class="nc" id="L288">         rename(myParser.parse(oldname), myParser.parse(newname));</span>
<span class="nc" id="L289">    }</span>

    public void rename(Name oldname, Name newname)
            throws NamingException {

<span class="nc bnc" id="L294" title="All 4 branches missed.">        if(newname.isEmpty() || oldname.isEmpty()) {</span>
<span class="nc" id="L295">            throw new InvalidNameException(&quot;Cannot rename empty name&quot;);</span>
        }

<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (!getInternalName(newname).equals(getInternalName(oldname))) {</span>
<span class="nc" id="L299">            throw new InvalidNameException(&quot;Cannot rename across contexts&quot;);</span>
        }

<span class="nc" id="L302">        HierMemDirCtx ctx =</span>
<span class="nc" id="L303">            (HierMemDirCtx) doLookup(getInternalName(newname), false);</span>
<span class="nc" id="L304">        ctx.doRename(getLeafName(oldname), getLeafName(newname));</span>
<span class="nc" id="L305">    }</span>

    protected void doRename(Name oldname, Name newname) throws NamingException {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L309">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }

<span class="nc" id="L312">        oldname = canonizeName(oldname);</span>
<span class="nc" id="L313">        newname = canonizeName(newname);</span>

        // Check if new name exists
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (bindings.get(newname) != null) {</span>
<span class="nc" id="L317">            throw new NameAlreadyBoundException(newname.toString());</span>
        }

        // Check if old name is bound
<span class="nc" id="L321">        Object oldBinding = bindings.remove(oldname);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (oldBinding == null) {</span>
<span class="nc" id="L323">            throw new NameNotFoundException(oldname.toString());</span>
        }

<span class="nc" id="L326">        bindings.put(newname, oldBinding);</span>
<span class="nc" id="L327">    }</span>

    public NamingEnumeration&lt;NameClassPair&gt; list(String name) throws NamingException {
<span class="nc" id="L330">        return list(myParser.parse(name));</span>
    }

    public NamingEnumeration&lt;NameClassPair&gt; list(Name name) throws NamingException {
<span class="nc" id="L334">        HierMemDirCtx ctx = (HierMemDirCtx) doLookup(name, false);</span>
<span class="nc" id="L335">        return ctx.doList();</span>
    }

    protected NamingEnumeration&lt;NameClassPair&gt; doList () throws NamingException {
<span class="nc" id="L339">        return new FlatNames(bindings.keys());</span>
    }


    public NamingEnumeration&lt;Binding&gt; listBindings(String name) throws NamingException {
<span class="nc" id="L344">        return listBindings(myParser.parse(name));</span>
    }

    public NamingEnumeration&lt;Binding&gt; listBindings(Name name) throws NamingException {
<span class="nc" id="L348">        HierMemDirCtx ctx = (HierMemDirCtx)doLookup(name, false);</span>
<span class="nc" id="L349">        return ctx.doListBindings(alwaysUseFactory);</span>
    }

    protected NamingEnumeration&lt;Binding&gt; doListBindings(boolean useFactory)
        throws NamingException {
<span class="nc" id="L354">        return new FlatBindings(bindings, myEnv, useFactory);</span>
    }

    public void destroySubcontext(String name) throws NamingException {
<span class="nc" id="L358">        destroySubcontext(myParser.parse(name));</span>
<span class="nc" id="L359">    }</span>

    public void destroySubcontext(Name name) throws NamingException {
<span class="nc" id="L362">        HierMemDirCtx ctx =</span>
<span class="nc" id="L363">            (HierMemDirCtx) doLookup(getInternalName(name), false);</span>
<span class="nc" id="L364">        ctx.doDestroySubcontext(getLeafName(name));</span>
<span class="nc" id="L365">    }</span>

    protected void doDestroySubcontext(Name name) throws NamingException {

<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L370">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }
<span class="nc" id="L372">        name = canonizeName(name);</span>
<span class="nc" id="L373">        bindings.remove(name);</span>
<span class="nc" id="L374">    }</span>

    public Context createSubcontext(String name) throws NamingException {
<span class="nc" id="L377">        return createSubcontext(myParser.parse(name));</span>
    }

    public Context createSubcontext(Name name) throws NamingException {
<span class="nc" id="L381">        return createSubcontext(name, null);</span>
    }

    public DirContext createSubcontext(String name, Attributes attrs)
            throws NamingException {
<span class="nc" id="L386">        return createSubcontext(myParser.parse(name), attrs);</span>
    }

    public DirContext createSubcontext(Name name, Attributes attrs)
            throws NamingException {
<span class="nc" id="L391">        HierMemDirCtx ctx =</span>
<span class="nc" id="L392">            (HierMemDirCtx) doLookup(getInternalName(name), false);</span>
<span class="nc" id="L393">        return ctx.doCreateSubcontext(getLeafName(name), attrs);</span>
    }

    protected DirContext doCreateSubcontext(Name name, Attributes attrs)
        throws NamingException {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L399">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }

<span class="nc" id="L402">        name = canonizeName(name);</span>

<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (bindings.get(name) != null) {</span>
<span class="nc" id="L405">            throw new NameAlreadyBoundException(name.toString());</span>
        }
<span class="nc" id="L407">        HierMemDirCtx newCtx = createNewCtx();</span>
<span class="nc" id="L408">        bindings.put(name, newCtx);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if(attrs != null) {</span>
<span class="nc" id="L410">            newCtx.modifyAttributes(&quot;&quot;, ADD_ATTRIBUTE, attrs);</span>
        }
<span class="nc" id="L412">        return newCtx;</span>
    }


    public Object lookupLink(String name) throws NamingException {
        // This context does not treat links specially
<span class="nc" id="L418">        return lookupLink(myParser.parse(name));</span>
    }

    public Object lookupLink(Name name) throws NamingException {
        // Flat namespace; no federation; just call string version
<span class="nc" id="L423">        return lookup(name);</span>
    }

    public NameParser getNameParser(String name) throws NamingException {
<span class="nc" id="L427">        return myParser;</span>
    }

    public NameParser getNameParser(Name name) throws NamingException {
<span class="nc" id="L431">        return myParser;</span>
    }

    public String composeName(String name, String prefix)
            throws NamingException {
<span class="nc" id="L436">        Name result = composeName(new CompositeName(name),</span>
                                  new CompositeName(prefix));
<span class="nc" id="L438">        return result.toString();</span>
    }

    public Name composeName(Name name, Name prefix)
            throws NamingException {
<span class="nc" id="L443">        name = canonizeName(name);</span>
<span class="nc" id="L444">        prefix = canonizeName(prefix);</span>
<span class="nc" id="L445">        Name result = (Name)(prefix.clone());</span>
<span class="nc" id="L446">        result.addAll(name);</span>
<span class="nc" id="L447">        return result;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) // clone()
    public Object addToEnvironment(String propName, Object propVal)
            throws NamingException {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        myEnv = (myEnv == null)</span>
                ? new Hashtable&lt;String, Object&gt;(11, 0.75f)
<span class="nc" id="L455">                : (Hashtable&lt;String, Object&gt;)myEnv.clone();</span>

<span class="nc" id="L457">        return myEnv.put(propName, propVal);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) // clone()
    public Object removeFromEnvironment(String propName)
            throws NamingException {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (myEnv == null)</span>
<span class="nc" id="L464">            return null;</span>

<span class="nc" id="L466">        myEnv = (Hashtable&lt;String, Object&gt;)myEnv.clone();</span>
<span class="nc" id="L467">        return myEnv.remove(propName);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) // clone()
    public Hashtable&lt;String, Object&gt; getEnvironment() throws NamingException {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (myEnv == null) {</span>
<span class="nc" id="L473">            return new Hashtable&lt;&gt;(5, 0.75f);</span>
        } else {
<span class="nc" id="L475">            return (Hashtable&lt;String, Object&gt;)myEnv.clone();</span>
        }
    }

    public Attributes getAttributes(String name)
       throws NamingException {
<span class="nc" id="L481">       return getAttributes(myParser.parse(name));</span>
    }

    public Attributes getAttributes(Name name)
        throws NamingException {
<span class="nc" id="L486">        HierMemDirCtx ctx = (HierMemDirCtx) doLookup(name, false);</span>
<span class="nc" id="L487">        return ctx.doGetAttributes();</span>
    }

    protected Attributes doGetAttributes() throws NamingException {
<span class="nc" id="L491">        return (Attributes)attrs.clone();</span>
    }

    public Attributes getAttributes(String name, String[] attrIds)
        throws NamingException {
<span class="nc" id="L496">        return getAttributes(myParser.parse(name), attrIds);</span>
    }

    public Attributes getAttributes(Name name, String[] attrIds)
        throws NamingException {
<span class="nc" id="L501">        HierMemDirCtx ctx = (HierMemDirCtx) doLookup(name, false);</span>
<span class="nc" id="L502">        return ctx.doGetAttributes(attrIds);</span>
    }

    protected Attributes doGetAttributes(String[] attrIds)
        throws NamingException {

<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (attrIds == null) {</span>
<span class="nc" id="L509">            return doGetAttributes();</span>
        }
<span class="nc" id="L511">        Attributes attrs = new BasicAttributes(ignoreCase);</span>
<span class="nc" id="L512">        Attribute attr = null;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            for(int i=0; i&lt;attrIds.length; i++) {</span>
<span class="nc" id="L514">                attr = this.attrs.get(attrIds[i]);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                if (attr != null) {</span>
<span class="nc" id="L516">                    attrs.put(attr);</span>
                }
            }
<span class="nc" id="L519">        return attrs;</span>
    }

    public void modifyAttributes(String name, int mod_op, Attributes attrs)
        throws NamingException   {
<span class="nc" id="L524">        modifyAttributes(myParser.parse(name), mod_op, attrs);</span>
<span class="nc" id="L525">    }</span>

    public void modifyAttributes(Name name, int mod_op, Attributes attrs)
        throws NamingException {

<span class="nc bnc" id="L530" title="All 4 branches missed.">        if (attrs == null || attrs.size() == 0) {</span>
<span class="nc" id="L531">            throw new IllegalArgumentException(</span>
                &quot;Cannot modify without an attribute&quot;);
        }

        // turn it into a modification Enumeration and pass it on
<span class="nc" id="L536">        NamingEnumeration&lt;? extends Attribute&gt; attrEnum = attrs.getAll();</span>
<span class="nc" id="L537">        ModificationItem[] mods = new ModificationItem[attrs.size()];</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">        for (int i = 0; i &lt; mods.length &amp;&amp; attrEnum.hasMoreElements(); i++) {</span>
<span class="nc" id="L539">            mods[i] = new ModificationItem(mod_op, attrEnum.next());</span>
        }

<span class="nc" id="L542">        modifyAttributes(name, mods);</span>
<span class="nc" id="L543">    }</span>

    public void modifyAttributes(String name, ModificationItem[] mods)
        throws NamingException   {
<span class="nc" id="L547">        modifyAttributes(myParser.parse(name), mods);</span>
<span class="nc" id="L548">    }</span>

    public void modifyAttributes(Name name, ModificationItem[] mods)
        throws NamingException {
<span class="nc" id="L552">        HierMemDirCtx ctx = (HierMemDirCtx) doLookup(name, false);</span>
<span class="nc" id="L553">        ctx.doModifyAttributes(mods);</span>
<span class="nc" id="L554">    }</span>

    protected void doModifyAttributes(ModificationItem[] mods)
        throws NamingException {

<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (readOnlyEx != null) {</span>
<span class="nc" id="L560">            throw (NamingException) readOnlyEx.fillInStackTrace();</span>
        }

<span class="nc" id="L563">        applyMods(mods, attrs);</span>
<span class="nc" id="L564">    }</span>

    protected static Attributes applyMods(ModificationItem[] mods,
        Attributes orig) throws NamingException {

        ModificationItem mod;
        Attribute existingAttr, modAttr;
        NamingEnumeration&lt;?&gt; modVals;

<span class="nc bnc" id="L573" title="All 2 branches missed.">        for (int i = 0; i &lt; mods.length; i++) {</span>
<span class="nc" id="L574">            mod = mods[i];</span>
<span class="nc" id="L575">            modAttr = mod.getAttribute();</span>

<span class="nc bnc" id="L577" title="All 4 branches missed.">            switch(mod.getModificationOp()) {</span>
            case ADD_ATTRIBUTE:
                if (debug) {
                    System.out.println(&quot;HierMemDSCtx: adding &quot; +
                                       mod.getAttribute().toString());
                }
<span class="nc" id="L583">                existingAttr = orig.get(modAttr.getID());</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (existingAttr == null) {</span>
<span class="nc" id="L585">                    orig.put((Attribute)modAttr.clone());</span>
                } else {
                    // Add new attribute values to existing attribute
<span class="nc" id="L588">                    modVals = modAttr.getAll();</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                    while (modVals.hasMore()) {</span>
<span class="nc" id="L590">                        existingAttr.add(modVals.next());</span>
                    }
                }
                break;
            case REPLACE_ATTRIBUTE:
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (modAttr.size() == 0) {</span>
<span class="nc" id="L596">                    orig.remove(modAttr.getID());</span>
                } else {
<span class="nc" id="L598">                    orig.put((Attribute)modAttr.clone());</span>
                }
<span class="nc" id="L600">                break;</span>
            case REMOVE_ATTRIBUTE:
<span class="nc" id="L602">                existingAttr = orig.get(modAttr.getID());</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                if (existingAttr != null) {</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    if (modAttr.size() == 0) {</span>
<span class="nc" id="L605">                        orig.remove(modAttr.getID());</span>
                    } else {
                        // Remove attribute values from existing attribute
<span class="nc" id="L608">                        modVals = modAttr.getAll();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                        while (modVals.hasMore()) {</span>
<span class="nc" id="L610">                            existingAttr.remove(modVals.next());</span>
                        }
<span class="nc bnc" id="L612" title="All 2 branches missed.">                        if (existingAttr.size() == 0) {</span>
<span class="nc" id="L613">                            orig.remove(modAttr.getID());</span>
                        }
                    }
                }
                break;
            default:
<span class="nc" id="L619">                throw new AttributeModificationException(&quot;Unknown mod_op&quot;);</span>
            }
        }

<span class="nc" id="L623">        return orig;</span>
    }

    public NamingEnumeration&lt;SearchResult&gt; search(String name,
                                                  Attributes matchingAttributes)
        throws NamingException {
<span class="nc" id="L629">        return search(name, matchingAttributes, null);</span>
    }

    public NamingEnumeration&lt;SearchResult&gt; search(Name name,
                                                  Attributes matchingAttributes)
        throws NamingException {
<span class="nc" id="L635">            return search(name, matchingAttributes, null);</span>
    }

     public NamingEnumeration&lt;SearchResult&gt; search(String name,
                                                   Attributes matchingAttributes,
                                                   String[] attributesToReturn)
        throws NamingException {
<span class="nc" id="L642">        return search(myParser.parse(name), matchingAttributes,</span>
            attributesToReturn);
    }

     public NamingEnumeration&lt;SearchResult&gt; search(Name name,
                                                   Attributes matchingAttributes,
                                                   String[] attributesToReturn)
         throws NamingException {

<span class="nc" id="L651">        HierMemDirCtx target = (HierMemDirCtx) doLookup(name, false);</span>

<span class="nc" id="L653">        SearchControls cons = new SearchControls();</span>
<span class="nc" id="L654">        cons.setReturningAttributes(attributesToReturn);</span>

<span class="nc" id="L656">        return new LazySearchEnumerationImpl(</span>
<span class="nc" id="L657">            target.doListBindings(false),</span>
            new ContainmentFilter(matchingAttributes),
            cons, this, myEnv,
            false); // alwaysUseFactory ignored because objReturnFlag == false
    }

    public NamingEnumeration&lt;SearchResult&gt; search(Name name,
                                                  String filter,
                                                  SearchControls cons)
        throws NamingException {
<span class="nc" id="L667">        DirContext target = (DirContext) doLookup(name, false);</span>

<span class="nc" id="L669">        SearchFilter stringfilter = new SearchFilter(filter);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        return new LazySearchEnumerationImpl(</span>
            new HierContextEnumerator(target,
<span class="nc" id="L672">                (cons != null) ? cons.getSearchScope() :</span>
                SearchControls.ONELEVEL_SCOPE),
            stringfilter,
            cons, this, myEnv, alwaysUseFactory);
    }

     public NamingEnumeration&lt;SearchResult&gt; search(Name name,
                                                   String filterExpr,
                                                   Object[] filterArgs,
                                                   SearchControls cons)
            throws NamingException {

<span class="nc" id="L684">        String strfilter = SearchFilter.format(filterExpr, filterArgs);</span>
<span class="nc" id="L685">        return search(name, strfilter, cons);</span>
    }

    public NamingEnumeration&lt;SearchResult&gt; search(String name,
                                                  String filter,
                                                  SearchControls cons)
        throws NamingException {
<span class="nc" id="L692">        return search(myParser.parse(name), filter, cons);</span>
    }

    public NamingEnumeration&lt;SearchResult&gt; search(String name,
                                                  String filterExpr,
                                                  Object[] filterArgs,
                                                  SearchControls cons)
            throws NamingException {
<span class="nc" id="L700">        return search(myParser.parse(name), filterExpr, filterArgs, cons);</span>
    }

    // This function is called whenever a new object needs to be created.
    // this is used so that if anyone subclasses us, they can override this
    // and return object of their own kind.
    protected HierMemDirCtx createNewCtx() throws NamingException {
<span class="nc" id="L707">        return new HierMemDirCtx(myEnv, ignoreCase);</span>
    }

    // If the supplied name is a composite name, return the name that
    // is its first component.
    protected Name canonizeName(Name name) throws NamingException {
<span class="nc" id="L713">        Name canonicalName = name;</span>

<span class="nc bnc" id="L715" title="All 2 branches missed.">        if(!(name instanceof HierarchicalName)) {</span>
            // If name is not of the correct type, make copy
<span class="nc" id="L717">            canonicalName = new HierarchicalName();</span>
<span class="nc" id="L718">            int n = name.size();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            for(int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L720">                canonicalName.add(i, name.get(i));</span>
            }
        }

<span class="nc" id="L724">        return canonicalName;</span>
    }

     protected Name getInternalName(Name name) throws NamingException {
<span class="nc" id="L728">         return (name.getPrefix(name.size() - 1));</span>
     }

     protected Name getLeafName(Name name) throws NamingException {
<span class="nc" id="L732">         return (name.getSuffix(name.size() - 1));</span>
     }


     public DirContext getSchema(String name) throws NamingException {
<span class="nc" id="L737">        throw new OperationNotSupportedException();</span>
    }

     public DirContext getSchema(Name name) throws NamingException {
<span class="nc" id="L741">        throw new OperationNotSupportedException();</span>
    }

     public DirContext getSchemaClassDefinition(String name)
        throws NamingException {
<span class="nc" id="L746">        throw new OperationNotSupportedException();</span>
    }

    public DirContext getSchemaClassDefinition(Name name)
            throws NamingException {
<span class="nc" id="L751">        throw new OperationNotSupportedException();</span>
    }

    // Set context in readonly mode; throw e when update operation attempted.
    public void setReadOnly(NamingException e) {
<span class="fc" id="L756">        readOnlyEx = e;</span>
<span class="fc" id="L757">    }</span>

    // Set context to support case-insensitive names
    public void setIgnoreCase(boolean ignoreCase) {
<span class="nc" id="L761">        this.ignoreCase = ignoreCase;</span>
<span class="nc" id="L762">    }</span>

    public void setNameParser(NameParser parser) {
<span class="nc" id="L765">        myParser = parser;</span>
<span class="nc" id="L766">    }</span>

    /*
     * Common base class for FlatNames and FlatBindings.
     */
    private abstract class BaseFlatNames&lt;T&gt; implements NamingEnumeration&lt;T&gt; {
        Enumeration&lt;Name&gt; names;

<span class="nc" id="L774">        BaseFlatNames (Enumeration&lt;Name&gt; names) {</span>
<span class="nc" id="L775">            this.names = names;</span>
<span class="nc" id="L776">        }</span>

        public final boolean hasMoreElements() {
            try {
<span class="nc" id="L780">                return hasMore();</span>
<span class="nc" id="L781">            } catch (NamingException e) {</span>
<span class="nc" id="L782">                return false;</span>
            }
        }

        public final boolean hasMore() throws NamingException {
<span class="nc" id="L787">            return names.hasMoreElements();</span>
        }

        public final T nextElement() {
            try {
<span class="nc" id="L792">                return next();</span>
<span class="nc" id="L793">            } catch (NamingException e) {</span>
<span class="nc" id="L794">                throw new NoSuchElementException(e.toString());</span>
            }
        }

        public abstract T next() throws NamingException;

        public final void close() {
<span class="nc" id="L801">            names = null;</span>
<span class="nc" id="L802">        }</span>
    }

    // Class for enumerating name/class pairs
    private final class FlatNames extends BaseFlatNames&lt;NameClassPair&gt; {
<span class="nc" id="L807">        FlatNames (Enumeration&lt;Name&gt; names) {</span>
<span class="nc" id="L808">            super(names);</span>
<span class="nc" id="L809">        }</span>

        @Override
        public NameClassPair next() throws NamingException {
<span class="nc" id="L813">            Name name = names.nextElement();</span>
<span class="nc" id="L814">            String className = bindings.get(name).getClass().getName();</span>
<span class="nc" id="L815">            return new NameClassPair(name.toString(), className);</span>
        }
    }

    // Class for enumerating bindings
    private final class FlatBindings extends BaseFlatNames&lt;Binding&gt; {
        private Hashtable&lt;Name, Object&gt; bds;
        private Hashtable&lt;String, Object&gt; env;
        private boolean useFactory;

        FlatBindings(Hashtable&lt;Name, Object&gt; bindings,
                     Hashtable&lt;String, Object&gt; env,
<span class="nc" id="L827">                     boolean useFactory) {</span>
<span class="nc" id="L828">            super(bindings.keys());</span>
<span class="nc" id="L829">            this.env = env;</span>
<span class="nc" id="L830">            this.bds = bindings;</span>
<span class="nc" id="L831">            this.useFactory = useFactory;</span>
<span class="nc" id="L832">        }</span>

        @Override
        public Binding next() throws NamingException {
<span class="nc" id="L836">            Name name = names.nextElement();</span>

<span class="nc" id="L838">            HierMemDirCtx obj = (HierMemDirCtx)bds.get(name);</span>

<span class="nc" id="L840">            Object answer = obj;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">            if (useFactory) {</span>
<span class="nc" id="L842">                Attributes attrs = obj.getAttributes(&quot;&quot;); // only method available</span>
                try {
<span class="nc" id="L844">                    answer = DirectoryManager.getObjectInstance(obj,</span>
                        name, HierMemDirCtx.this, env, attrs);
<span class="nc" id="L846">                } catch (NamingException e) {</span>
<span class="nc" id="L847">                    throw e;</span>
<span class="nc" id="L848">                } catch (Exception e) {</span>
<span class="nc" id="L849">                    NamingException e2 = new NamingException(</span>
                        &quot;Problem calling getObjectInstance&quot;);
<span class="nc" id="L851">                    e2.setRootCause(e);</span>
<span class="nc" id="L852">                    throw e2;</span>
<span class="nc" id="L853">                }</span>
            }

<span class="nc" id="L856">            return new Binding(name.toString(), answer);</span>
        }
    }

    public class HierContextEnumerator extends ContextEnumerator {
        public HierContextEnumerator(Context context, int scope)
<span class="nc" id="L862">            throws NamingException {</span>
<span class="nc" id="L863">                super(context, scope);</span>
<span class="nc" id="L864">        }</span>

        protected HierContextEnumerator(Context context, int scope,
<span class="nc" id="L867">            String contextName, boolean returnSelf) throws NamingException {</span>
<span class="nc" id="L868">            super(context, scope, contextName, returnSelf);</span>
<span class="nc" id="L869">        }</span>

        protected NamingEnumeration&lt;Binding&gt; getImmediateChildren(Context ctx)
            throws NamingException {
<span class="nc" id="L873">                return ((HierMemDirCtx)ctx).doListBindings(false);</span>
        }

        protected ContextEnumerator newEnumerator(Context ctx, int scope,
            String contextName, boolean returnSelf) throws NamingException {
<span class="nc" id="L878">                return new HierContextEnumerator(ctx, scope, contextName,</span>
                    returnSelf);
        }
    }
}

    // CompundNames's HashCode() method isn't good enough for many string.
    // The only prupose of this subclass is to have a more discerning
    // hash function. We'll make up for the performance hit by caching
    // the hash value.

final class HierarchicalName extends CompoundName {
<span class="nc" id="L890">    private int hashValue = -1;</span>

    // Creates an empty name
    HierarchicalName() {
<span class="nc" id="L894">        super(new Enumeration&lt;String&gt;() {</span>
<span class="nc" id="L895">                  public boolean hasMoreElements() {return false;}</span>
<span class="nc" id="L896">                  public String nextElement() {throw new NoSuchElementException();}</span>
              },
              HierarchicalNameParser.mySyntax);
<span class="nc" id="L899">    }</span>

    HierarchicalName(Enumeration&lt;String&gt; comps, Properties syntax) {
<span class="nc" id="L902">        super(comps, syntax);</span>
<span class="nc" id="L903">    }</span>

    HierarchicalName(String n, Properties syntax) throws InvalidNameException {
<span class="nc" id="L906">        super(n, syntax);</span>
<span class="nc" id="L907">    }</span>

    // just like String.hashCode, only it pays no attention to length
    public int hashCode() {
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (hashValue == -1) {</span>

<span class="nc" id="L913">            String name = toString().toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L914">            int len = name.length();</span>
<span class="nc" id="L915">            int off = 0;</span>
<span class="nc" id="L916">            char val[] = new char[len];</span>

<span class="nc" id="L918">            name.getChars(0, len, val, 0);</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">            for (int i = len; i &gt; 0; i--) {</span>
<span class="nc" id="L921">                hashValue = (hashValue * 37) + val[off++];</span>
            }
        }

<span class="nc" id="L925">        return hashValue;</span>
    }

    public Name getPrefix(int posn) {
<span class="nc" id="L929">        Enumeration&lt;String&gt; comps = super.getPrefix(posn).getAll();</span>
<span class="nc" id="L930">        return (new HierarchicalName(comps, mySyntax));</span>
    }

    public Name getSuffix(int posn) {
<span class="nc" id="L934">        Enumeration&lt;String&gt; comps = super.getSuffix(posn).getAll();</span>
<span class="nc" id="L935">        return (new HierarchicalName(comps, mySyntax));</span>
    }

    public Object clone() {
<span class="nc" id="L939">        return (new HierarchicalName(getAll(), mySyntax));</span>
    }

    private static final long serialVersionUID = -6717336834584573168L;
}

// This is the default name parser (used if setNameParser is not called)
<span class="fc" id="L946">final class HierarchicalNameParser implements NameParser {</span>
<span class="fc" id="L947">    static final Properties mySyntax = new Properties();</span>
    static {
<span class="fc" id="L949">        mySyntax.put(&quot;jndi.syntax.direction&quot;, &quot;left_to_right&quot;);</span>
<span class="fc" id="L950">        mySyntax.put(&quot;jndi.syntax.separator&quot;, &quot;/&quot;);</span>
<span class="fc" id="L951">        mySyntax.put(&quot;jndi.syntax.ignorecase&quot;, &quot;true&quot;);</span>
<span class="fc" id="L952">        mySyntax.put(&quot;jndi.syntax.escape&quot;, &quot;\\&quot;);</span>
<span class="fc" id="L953">        mySyntax.put(&quot;jndi.syntax.beginquote&quot;, &quot;\&quot;&quot;);</span>
        //mySyntax.put(&quot;jndi.syntax.separator.ava&quot;, &quot;+&quot;);
        //mySyntax.put(&quot;jndi.syntax.separator.typeval&quot;, &quot;=&quot;);
<span class="fc" id="L956">        mySyntax.put(&quot;jndi.syntax.trimblanks&quot;, &quot;false&quot;);</span>
<span class="fc" id="L957">    };</span>

    public Name parse(String name) throws NamingException {
<span class="nc" id="L960">        return new HierarchicalName(name, mySyntax);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>