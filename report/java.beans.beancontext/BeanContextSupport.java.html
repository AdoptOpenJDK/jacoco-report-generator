<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BeanContextSupport.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.beans.beancontext</a> &gt; <span class="el_source">BeanContextSupport.java</span></div><h1>BeanContextSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.beans.beancontext;

import java.awt.Component;
import java.awt.Container;

import java.beans.Beans;
import java.beans.AppletInitializer;

import java.beans.DesignMode;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;

import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import java.beans.PropertyVetoException;

import java.beans.Visibility;

import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

import java.net.URL;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;


/**
 * This helper class provides a utility implementation of the
 * java.beans.beancontext.BeanContext interface.
 * &lt;p&gt;
 * Since this class directly implements the BeanContext interface, the class
 * can, and is intended to be used either by subclassing this implementation,
 * or via ad-hoc delegation of an instance of this class from another.
 * &lt;/p&gt;
 *
 * @author Laurence P. G. Cable
 * @since 1.2
 */
public class      BeanContextSupport extends BeanContextChildSupport
       implements BeanContext,
                  Serializable,
                  PropertyChangeListener,
                  VetoableChangeListener {

    // Fix for bug 4282900 to pass JCK regression test
    static final long serialVersionUID = -4879613978649577204L;

    /**
     *
     * Construct a BeanContextSupport instance
     *
     *
     * @param peer      The peer &lt;tt&gt;BeanContext&lt;/tt&gt; we are
     *                  supplying an implementation for,
     *                  or &lt;tt&gt;null&lt;/tt&gt;
     *                  if this object is its own peer
     * @param lcle      The current Locale for this BeanContext. If
     *                  &lt;tt&gt;lcle&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, the default locale
     *                  is assigned to the &lt;tt&gt;BeanContext&lt;/tt&gt; instance.
     * @param dTime     The initial state,
     *                  &lt;tt&gt;true&lt;/tt&gt; if in design mode,
     *                  &lt;tt&gt;false&lt;/tt&gt; if runtime.
     * @param visible   The initial visibility.
     * @see java.util.Locale#getDefault()
     * @see java.util.Locale#setDefault(java.util.Locale)
     */
    public BeanContextSupport(BeanContext peer, Locale lcle, boolean dTime, boolean visible) {
<span class="nc" id="L103">        super(peer);</span>

<span class="nc bnc" id="L105" title="All 2 branches missed.">        locale          = lcle != null ? lcle : Locale.getDefault();</span>
<span class="nc" id="L106">        designTime      = dTime;</span>
<span class="nc" id="L107">        okToUseGui      = visible;</span>

<span class="nc" id="L109">        initialize();</span>
<span class="nc" id="L110">    }</span>

    /**
     * Create an instance using the specified Locale and design mode.
     *
     * @param peer      The peer &lt;tt&gt;BeanContext&lt;/tt&gt; we
     *                  are supplying an implementation for,
     *                  or &lt;tt&gt;null&lt;/tt&gt; if this object is its own peer
     * @param lcle      The current Locale for this &lt;tt&gt;BeanContext&lt;/tt&gt;. If
     *                  &lt;tt&gt;lcle&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, the default locale
     *                  is assigned to the &lt;tt&gt;BeanContext&lt;/tt&gt; instance.
     * @param dtime     The initial state, &lt;tt&gt;true&lt;/tt&gt;
     *                  if in design mode,
     *                  &lt;tt&gt;false&lt;/tt&gt; if runtime.
     * @see java.util.Locale#getDefault()
     * @see java.util.Locale#setDefault(java.util.Locale)
     */
    public BeanContextSupport(BeanContext peer, Locale lcle, boolean dtime) {
<span class="nc" id="L128">        this (peer, lcle, dtime, true);</span>
<span class="nc" id="L129">    }</span>

    /**
     * Create an instance using the specified locale
     *
     * @param peer      The peer BeanContext we are
     *                  supplying an implementation for,
     *                  or &lt;tt&gt;null&lt;/tt&gt; if this object
     *                  is its own peer
     * @param lcle      The current Locale for this
     *                  &lt;tt&gt;BeanContext&lt;/tt&gt;. If
     *                  &lt;tt&gt;lcle&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;,
     *                  the default locale
     *                  is assigned to the &lt;tt&gt;BeanContext&lt;/tt&gt;
     *                  instance.
     * @see java.util.Locale#getDefault()
     * @see java.util.Locale#setDefault(java.util.Locale)
     */
    public BeanContextSupport(BeanContext peer, Locale lcle) {
<span class="nc" id="L148">        this (peer, lcle, false, true);</span>
<span class="nc" id="L149">    }</span>

    /**
     * Create an instance using with a default locale
     *
     * @param peer      The peer &lt;tt&gt;BeanContext&lt;/tt&gt; we are
     *                  supplying an implementation for,
     *                  or &lt;tt&gt;null&lt;/tt&gt; if this object
     *                  is its own peer
     */
    public BeanContextSupport(BeanContext peer) {
<span class="nc" id="L160">        this (peer, null, false, true);</span>
<span class="nc" id="L161">    }</span>

    /**
     * Create an instance that is not a delegate of another object
     */

    public BeanContextSupport() {
<span class="nc" id="L168">        this (null, null, false, true);</span>
<span class="nc" id="L169">    }</span>

    /**
     * Gets the instance of &lt;tt&gt;BeanContext&lt;/tt&gt; that
     * this object is providing the implementation for.
     * @return the BeanContext instance
     */
<span class="nc" id="L176">    public BeanContext getBeanContextPeer() { return (BeanContext)getBeanContextChildPeer(); }</span>

    /**
     * &lt;p&gt;
     * The instantiateChild method is a convenience hook
     * in BeanContext to simplify
     * the task of instantiating a Bean, nested,
     * into a &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The semantics of the beanName parameter are defined by java.beans.Beans.instantiate.
     * &lt;/p&gt;
     *
     * @param beanName the name of the Bean to instantiate within this BeanContext
     * @throws IOException if there is an I/O error when the bean is being deserialized
     * @throws ClassNotFoundException if the class
     * identified by the beanName parameter is not found
     * @return the new object
     */
    public Object instantiateChild(String beanName)
           throws IOException, ClassNotFoundException {
<span class="nc" id="L197">        BeanContext bc = getBeanContextPeer();</span>

<span class="nc" id="L199">        return Beans.instantiate(bc.getClass().getClassLoader(), beanName, bc);</span>
    }

    /**
     * Gets the number of children currently nested in
     * this BeanContext.
     *
     * @return number of children
     */
    public int size() {
<span class="nc" id="L209">        synchronized(children) {</span>
<span class="nc" id="L210">            return children.size();</span>
<span class="nc" id="L211">        }</span>
    }

    /**
     * Reports whether or not this
     * &lt;tt&gt;BeanContext&lt;/tt&gt; is empty.
     * A &lt;tt&gt;BeanContext&lt;/tt&gt; is considered
     * empty when it contains zero
     * nested children.
     * @return if there are not children
     */
    public boolean isEmpty() {
<span class="nc" id="L223">        synchronized(children) {</span>
<span class="nc" id="L224">            return children.isEmpty();</span>
<span class="nc" id="L225">        }</span>
    }

    /**
     * Determines whether or not the specified object
     * is currently a child of this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @param o the Object in question
     * @return if this object is a child
     */
    public boolean contains(Object o) {
<span class="nc" id="L235">        synchronized(children) {</span>
<span class="nc" id="L236">            return children.containsKey(o);</span>
<span class="nc" id="L237">        }</span>
    }

    /**
     * Determines whether or not the specified object
     * is currently a child of this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @param o the Object in question
     * @return if this object is a child
     */
    public boolean containsKey(Object o) {
<span class="nc" id="L247">        synchronized(children) {</span>
<span class="nc" id="L248">            return children.containsKey(o);</span>
<span class="nc" id="L249">        }</span>
    }

    /**
     * Gets all JavaBean or &lt;tt&gt;BeanContext&lt;/tt&gt; instances
     * currently nested in this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @return an &lt;tt&gt;Iterator&lt;/tt&gt; of the nested children
     */
    public Iterator iterator() {
<span class="nc" id="L258">        synchronized(children) {</span>
<span class="nc" id="L259">            return new BCSIterator(children.keySet().iterator());</span>
<span class="nc" id="L260">        }</span>
    }

    /**
     * Gets all JavaBean or &lt;tt&gt;BeanContext&lt;/tt&gt;
     * instances currently nested in this BeanContext.
     */
    public Object[] toArray() {
<span class="nc" id="L268">        synchronized(children) {</span>
<span class="nc" id="L269">            return children.keySet().toArray();</span>
<span class="nc" id="L270">        }</span>
    }

    /**
     * Gets an array containing all children of
     * this &lt;tt&gt;BeanContext&lt;/tt&gt; that match
     * the types contained in arry.
     * @param arry The array of object
     * types that are of interest.
     * @return an array of children
     */
    public Object[] toArray(Object[] arry) {
<span class="nc" id="L282">        synchronized(children) {</span>
<span class="nc" id="L283">            return children.keySet().toArray(arry);</span>
<span class="nc" id="L284">        }</span>
    }


    /************************************************************************/

    /**
     * protected final subclass that encapsulates an iterator but implements
     * a noop remove() method.
     */

    protected static final class BCSIterator implements Iterator {
<span class="nc" id="L296">        BCSIterator(Iterator i) { super(); src = i; }</span>

<span class="nc" id="L298">        public boolean hasNext() { return src.hasNext(); }</span>
<span class="nc" id="L299">        public Object  next()    { return src.next();    }</span>
<span class="nc" id="L300">        public void    remove()  { /* do nothing */      }</span>

        private Iterator src;
    }

    /************************************************************************/

    /*
     * protected nested class containing per child information, an instance
     * of which is associated with each child in the &quot;children&quot; hashtable.
     * subclasses can extend this class to include their own per-child state.
     *
     * Note that this 'value' is serialized with the corresponding child 'key'
     * when the BeanContextSupport is serialized.
     */

    protected class BCSChild implements Serializable {

    private static final long serialVersionUID = -5815286101609939109L;

<span class="nc" id="L320">        BCSChild(Object bcc, Object peer) {</span>
<span class="nc" id="L321">            super();</span>

<span class="nc" id="L323">            child     = bcc;</span>
<span class="nc" id="L324">            proxyPeer = peer;</span>
<span class="nc" id="L325">        }</span>

<span class="nc" id="L327">        Object  getChild()                  { return child; }</span>

<span class="nc" id="L329">        void    setRemovePending(boolean v) { removePending = v; }</span>

<span class="nc" id="L331">        boolean isRemovePending()           { return removePending; }</span>

<span class="nc bnc" id="L333" title="All 2 branches missed.">        boolean isProxyPeer()               { return proxyPeer != null; }</span>

<span class="nc" id="L335">        Object  getProxyPeer()              { return proxyPeer; }</span>
        /*
         * fields
         */


        private           Object   child;
        private           Object   proxyPeer;

        private transient boolean  removePending;
    }

    /**
     * &lt;p&gt;
     * Subclasses can override this method to insert their own subclass
     * of Child without having to override add() or the other Collection
     * methods that add children to the set.
     * &lt;/p&gt;
     * @param targetChild the child to create the Child on behalf of
     * @param peer        the peer if the tragetChild and the peer are related by an implementation of BeanContextProxy     * @return Subtype-specific subclass of Child without overriding collection methods
     */

    protected BCSChild createBCSChild(Object targetChild, Object peer) {
<span class="nc" id="L358">        return new BCSChild(targetChild, peer);</span>
    }

    /************************************************************************/

    /**
     * Adds/nests a child within this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * &lt;p&gt;
     * Invoked as a side effect of java.beans.Beans.instantiate().
     * If the child object is not valid for adding then this method
     * throws an IllegalStateException.
     * &lt;/p&gt;
     *
     *
     * @param targetChild The child objects to nest
     * within this &lt;tt&gt;BeanContext&lt;/tt&gt;
     * @return true if the child was added successfully.
     * @see #validatePendingAdd
     */
    public boolean add(Object targetChild) {

<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (targetChild == null) throw new IllegalArgumentException();</span>

        // The specification requires that we do nothing if the child
        // is already nested herein.

<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (children.containsKey(targetChild)) return false; // test before locking</span>

<span class="nc" id="L386">        synchronized(BeanContext.globalHierarchyLock) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (children.containsKey(targetChild)) return false; // check again</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (!validatePendingAdd(targetChild)) {</span>
<span class="nc" id="L390">                throw new IllegalStateException();</span>
            }


            // The specification requires that we invoke setBeanContext() on the
            // newly added child if it implements the java.beans.beancontext.BeanContextChild interface

<span class="nc" id="L397">            BeanContextChild cbcc  = getChildBeanContextChild(targetChild);</span>
<span class="nc" id="L398">            BeanContextChild  bccp = null;</span>

<span class="nc" id="L400">            synchronized(targetChild) {</span>

<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (targetChild instanceof BeanContextProxy) {</span>
<span class="nc" id="L403">                    bccp = ((BeanContextProxy)targetChild).getBeanContextProxy();</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">                    if (bccp == null) throw new NullPointerException(&quot;BeanContextPeer.getBeanContextProxy()&quot;);</span>
                }

<span class="nc" id="L408">                BCSChild bcsc  = createBCSChild(targetChild, bccp);</span>
<span class="nc" id="L409">                BCSChild pbcsc = null;</span>

<span class="nc" id="L411">                synchronized (children) {</span>
<span class="nc" id="L412">                    children.put(targetChild, bcsc);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">                    if (bccp != null) children.put(bccp, pbcsc = createBCSChild(bccp, targetChild));</span>
<span class="nc" id="L415">                }</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">                if (cbcc != null) synchronized(cbcc) {</span>
                    try {
<span class="nc" id="L419">                        cbcc.setBeanContext(getBeanContextPeer());</span>
<span class="nc" id="L420">                    } catch (PropertyVetoException pve) {</span>

<span class="nc" id="L422">                        synchronized (children) {</span>
<span class="nc" id="L423">                            children.remove(targetChild);</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">                            if (bccp != null) children.remove(bccp);</span>
<span class="nc" id="L426">                        }</span>

<span class="nc" id="L428">                        throw new IllegalStateException();</span>
<span class="nc" id="L429">                    }</span>

<span class="nc" id="L431">                    cbcc.addPropertyChangeListener(&quot;beanContext&quot;, childPCL);</span>
<span class="nc" id="L432">                    cbcc.addVetoableChangeListener(&quot;beanContext&quot;, childVCL);</span>
<span class="nc" id="L433">                }</span>

<span class="nc" id="L435">                Visibility v = getChildVisibility(targetChild);</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">                if (v != null) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">                    if (okToUseGui)</span>
<span class="nc" id="L439">                        v.okToUseGui();</span>
                    else
<span class="nc" id="L441">                        v.dontUseGui();</span>
                }

<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (getChildSerializable(targetChild) != null) serializable++;</span>

<span class="nc" id="L446">                childJustAddedHook(targetChild, bcsc);</span>

<span class="nc bnc" id="L448" title="All 2 branches missed.">                if (bccp != null) {</span>
<span class="nc" id="L449">                    v = getChildVisibility(bccp);</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">                    if (v != null) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                        if (okToUseGui)</span>
<span class="nc" id="L453">                            v.okToUseGui();</span>
                        else
<span class="nc" id="L455">                            v.dontUseGui();</span>
                    }

<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (getChildSerializable(bccp) != null) serializable++;</span>

<span class="nc" id="L460">                    childJustAddedHook(bccp, pbcsc);</span>
                }


<span class="nc" id="L464">            }</span>

            // The specification requires that we fire a notification of the change

<span class="nc bnc" id="L468" title="All 2 branches missed.">            fireChildrenAdded(new BeanContextMembershipEvent(getBeanContextPeer(), bccp == null ? new Object[] { targetChild } : new Object[] { targetChild, bccp } ));</span>

<span class="nc" id="L470">        }</span>

<span class="nc" id="L472">        return true;</span>
    }

    /**
     * Removes a child from this BeanContext.  If the child object is not
     * for adding then this method throws an IllegalStateException.
     * @param targetChild The child objects to remove
     * @see #validatePendingRemove
     */
    public boolean remove(Object targetChild) {
<span class="nc" id="L482">        return remove(targetChild, true);</span>
    }

    /**
     * internal remove used when removal caused by
     * unexpected &lt;tt&gt;setBeanContext&lt;/tt&gt; or
     * by &lt;tt&gt;remove()&lt;/tt&gt; invocation.
     * @param targetChild the JavaBean, BeanContext, or Object to be removed
     * @param callChildSetBC used to indicate that
     * the child should be notified that it is no
     * longer nested in this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @return whether or not was present before being removed
     */
    protected boolean remove(Object targetChild, boolean callChildSetBC) {

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (targetChild == null) throw new IllegalArgumentException();</span>

<span class="nc" id="L499">        synchronized(BeanContext.globalHierarchyLock) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (!containsKey(targetChild)) return false;</span>

<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (!validatePendingRemove(targetChild)) {</span>
<span class="nc" id="L503">                throw new IllegalStateException();</span>
            }

<span class="nc" id="L506">            BCSChild bcsc  = (BCSChild)children.get(targetChild);</span>
<span class="nc" id="L507">            BCSChild pbcsc = null;</span>
<span class="nc" id="L508">            Object   peer  = null;</span>

            // we are required to notify the child that it is no longer nested here if
            // it implements java.beans.beancontext.BeanContextChild

<span class="nc" id="L513">            synchronized(targetChild) {</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (callChildSetBC) {</span>
<span class="nc" id="L515">                    BeanContextChild cbcc = getChildBeanContextChild(targetChild);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                    if (cbcc != null) synchronized(cbcc) {</span>
<span class="nc" id="L517">                        cbcc.removePropertyChangeListener(&quot;beanContext&quot;, childPCL);</span>
<span class="nc" id="L518">                        cbcc.removeVetoableChangeListener(&quot;beanContext&quot;, childVCL);</span>

                        try {
<span class="nc" id="L521">                            cbcc.setBeanContext(null);</span>
<span class="nc" id="L522">                        } catch (PropertyVetoException pve1) {</span>
<span class="nc" id="L523">                            cbcc.addPropertyChangeListener(&quot;beanContext&quot;, childPCL);</span>
<span class="nc" id="L524">                            cbcc.addVetoableChangeListener(&quot;beanContext&quot;, childVCL);</span>
<span class="nc" id="L525">                            throw new IllegalStateException();</span>
<span class="nc" id="L526">                        }</span>

<span class="nc" id="L528">                    }</span>
                }

<span class="nc" id="L531">                synchronized (children) {</span>
<span class="nc" id="L532">                    children.remove(targetChild);</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">                    if (bcsc.isProxyPeer()) {</span>
<span class="nc" id="L535">                        pbcsc = (BCSChild)children.get(peer = bcsc.getProxyPeer());</span>
<span class="nc" id="L536">                        children.remove(peer);</span>
                    }
<span class="nc" id="L538">                }</span>

<span class="nc bnc" id="L540" title="All 2 branches missed.">                if (getChildSerializable(targetChild) != null) serializable--;</span>

<span class="nc" id="L542">                childJustRemovedHook(targetChild, bcsc);</span>

<span class="nc bnc" id="L544" title="All 2 branches missed.">                if (peer != null) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">                    if (getChildSerializable(peer) != null) serializable--;</span>

<span class="nc" id="L547">                    childJustRemovedHook(peer, pbcsc);</span>
                }
<span class="nc" id="L549">            }</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">            fireChildrenRemoved(new BeanContextMembershipEvent(getBeanContextPeer(), peer == null ? new Object[] { targetChild } : new Object[] { targetChild, peer } ));</span>

<span class="nc" id="L553">        }</span>

<span class="nc" id="L555">        return true;</span>
    }

    /**
     * Tests to see if all objects in the
     * specified &lt;tt&gt;Collection&lt;/tt&gt; are children of
     * this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @param c the specified &lt;tt&gt;Collection&lt;/tt&gt;
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if all objects
     * in the collection are children of
     * this &lt;tt&gt;BeanContext&lt;/tt&gt;, false if not.
     */
    public boolean containsAll(Collection c) {
<span class="nc" id="L569">        synchronized(children) {</span>
<span class="nc" id="L570">            Iterator i = c.iterator();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            while (i.hasNext())</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                if(!contains(i.next()))</span>
<span class="nc" id="L573">                    return false;</span>

<span class="nc" id="L575">            return true;</span>
<span class="nc" id="L576">        }</span>
    }

    /**
     * add Collection to set of Children (Unsupported)
     * implementations must synchronized on the hierarchy lock and &quot;children&quot; protected field
     * @throws UnsupportedOperationException thrown unconditionally by this implementation
     * @return this implementation unconditionally throws {@code UnsupportedOperationException}
     */
    public boolean addAll(Collection c) {
<span class="nc" id="L586">        throw new UnsupportedOperationException();</span>
    }

    /**
     * remove all specified children (Unsupported)
     * implementations must synchronized on the hierarchy lock and &quot;children&quot; protected field
     * @throws UnsupportedOperationException thrown unconditionally by this implementation
     * @return this implementation unconditionally throws {@code UnsupportedOperationException}

     */
    public boolean removeAll(Collection c) {
<span class="nc" id="L597">        throw new UnsupportedOperationException();</span>
    }


    /**
     * retain only specified children (Unsupported)
     * implementations must synchronized on the hierarchy lock and &quot;children&quot; protected field
     * @throws UnsupportedOperationException thrown unconditionally by this implementation
     * @return this implementation unconditionally throws {@code UnsupportedOperationException}
     */
    public boolean retainAll(Collection c) {
<span class="nc" id="L608">        throw new UnsupportedOperationException();</span>
    }

    /**
     * clear the children (Unsupported)
     * implementations must synchronized on the hierarchy lock and &quot;children&quot; protected field
     * @throws UnsupportedOperationException thrown unconditionally by this implementation
     */
    public void clear() {
<span class="nc" id="L617">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Adds a BeanContextMembershipListener
     *
     * @param  bcml the BeanContextMembershipListener to add
     * @throws NullPointerException if the argument is null
     */

    public void addBeanContextMembershipListener(BeanContextMembershipListener bcml) {
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (bcml == null) throw new NullPointerException(&quot;listener&quot;);</span>

<span class="nc" id="L630">        synchronized(bcmListeners) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (bcmListeners.contains(bcml))</span>
<span class="nc" id="L632">                return;</span>
            else
<span class="nc" id="L634">                bcmListeners.add(bcml);</span>
<span class="nc" id="L635">        }</span>
<span class="nc" id="L636">    }</span>

    /**
     * Removes a BeanContextMembershipListener
     *
     * @param  bcml the BeanContextMembershipListener to remove
     * @throws NullPointerException if the argument is null
     */

    public void removeBeanContextMembershipListener(BeanContextMembershipListener bcml) {
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (bcml == null) throw new NullPointerException(&quot;listener&quot;);</span>

<span class="nc" id="L648">        synchronized(bcmListeners) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (!bcmListeners.contains(bcml))</span>
<span class="nc" id="L650">                return;</span>
            else
<span class="nc" id="L652">                bcmListeners.remove(bcml);</span>
<span class="nc" id="L653">        }</span>
<span class="nc" id="L654">    }</span>

    /**
     * @param name the name of the resource requested.
     * @param bcc  the child object making the request.
     *
     * @return  the requested resource as an InputStream
     * @throws  NullPointerException if the argument is null
     */

    public InputStream getResourceAsStream(String name, BeanContextChild bcc) {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (name == null) throw new NullPointerException(&quot;name&quot;);</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (bcc  == null) throw new NullPointerException(&quot;bcc&quot;);</span>

<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (containsKey(bcc)) {</span>
<span class="nc" id="L669">            ClassLoader cl = bcc.getClass().getClassLoader();</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">            return cl != null ? cl.getResourceAsStream(name)</span>
<span class="nc" id="L672">                              : ClassLoader.getSystemResourceAsStream(name);</span>
<span class="nc" id="L673">        } else throw new IllegalArgumentException(&quot;Not a valid child&quot;);</span>
    }

    /**
     * @param name the name of the resource requested.
     * @param bcc  the child object making the request.
     *
     * @return the requested resource as an InputStream
     */

    public URL getResource(String name, BeanContextChild bcc) {
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (name == null) throw new NullPointerException(&quot;name&quot;);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (bcc  == null) throw new NullPointerException(&quot;bcc&quot;);</span>

<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (containsKey(bcc)) {</span>
<span class="nc" id="L688">            ClassLoader cl = bcc.getClass().getClassLoader();</span>

<span class="nc bnc" id="L690" title="All 2 branches missed.">            return cl != null ? cl.getResource(name)</span>
<span class="nc" id="L691">                              : ClassLoader.getSystemResource(name);</span>
<span class="nc" id="L692">        } else throw new IllegalArgumentException(&quot;Not a valid child&quot;);</span>
    }

    /**
     * Sets the new design time value for this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @param dTime the new designTime value
     */
    public synchronized void setDesignTime(boolean dTime) {
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (designTime != dTime) {</span>
<span class="nc" id="L701">            designTime = dTime;</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">            firePropertyChange(&quot;designMode&quot;, Boolean.valueOf(!dTime), Boolean.valueOf(dTime));</span>
        }
<span class="nc" id="L705">    }</span>


    /**
     * Reports whether or not this object is in
     * currently in design time mode.
     * @return &lt;tt&gt;true&lt;/tt&gt; if in design time mode,
     * &lt;tt&gt;false&lt;/tt&gt; if not
     */
<span class="nc" id="L714">    public synchronized boolean isDesignTime() { return designTime; }</span>

    /**
     * Sets the locale of this BeanContext.
     * @param newLocale the new locale. This method call will have
     *        no effect if newLocale is &lt;CODE&gt;null&lt;/CODE&gt;.
     * @throws PropertyVetoException if the new value is rejected
     */
    public synchronized void setLocale(Locale newLocale) throws PropertyVetoException {

<span class="nc bnc" id="L724" title="All 6 branches missed.">        if ((locale != null &amp;&amp; !locale.equals(newLocale)) &amp;&amp; newLocale != null) {</span>
<span class="nc" id="L725">            Locale old = locale;</span>

<span class="nc" id="L727">            fireVetoableChange(&quot;locale&quot;, old, newLocale); // throws</span>

<span class="nc" id="L729">            locale = newLocale;</span>

<span class="nc" id="L731">            firePropertyChange(&quot;locale&quot;, old, newLocale);</span>
        }
<span class="nc" id="L733">    }</span>

    /**
     * Gets the locale for this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     *
     * @return the current Locale of the &lt;tt&gt;BeanContext&lt;/tt&gt;
     */
<span class="nc" id="L740">    public synchronized Locale getLocale() { return locale; }</span>

    /**
     * &lt;p&gt;
     * This method is typically called from the environment in order to determine
     * if the implementor &quot;needs&quot; a GUI.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The algorithm used herein tests the BeanContextPeer, and its current children
     * to determine if they are either Containers, Components, or if they implement
     * Visibility and return needsGui() == true.
     * &lt;/p&gt;
     * @return &lt;tt&gt;true&lt;/tt&gt; if the implementor needs a GUI
     */
    public synchronized boolean needsGui() {
<span class="nc" id="L755">        BeanContext bc = getBeanContextPeer();</span>

<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (bc != this) {</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (bc instanceof Visibility) return ((Visibility)bc).needsGui();</span>

<span class="nc bnc" id="L760" title="All 4 branches missed.">            if (bc instanceof Container || bc instanceof Component)</span>
<span class="nc" id="L761">                return true;</span>
        }

<span class="nc" id="L764">        synchronized(children) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            for (Iterator i = children.keySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L766">                Object c = i.next();</span>

                try {
<span class="nc" id="L769">                        return ((Visibility)c).needsGui();</span>
<span class="nc" id="L770">                    } catch (ClassCastException cce) {</span>
                        // do nothing ...
                    }

<span class="nc bnc" id="L774" title="All 4 branches missed.">                    if (c instanceof Container || c instanceof Component)</span>
<span class="nc" id="L775">                        return true;</span>
<span class="nc" id="L776">            }</span>
<span class="nc" id="L777">        }</span>

<span class="nc" id="L779">        return false;</span>
    }

    /**
     * notify this instance that it may no longer render a GUI.
     */

    public synchronized void dontUseGui() {
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (okToUseGui) {</span>
<span class="nc" id="L788">            okToUseGui = false;</span>

            // lets also tell the Children that can that they may not use their GUI's
<span class="nc" id="L791">            synchronized(children) {</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                for (Iterator i = children.keySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L793">                    Visibility v = getChildVisibility(i.next());</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">                    if (v != null) v.dontUseGui();</span>
<span class="nc" id="L796">               }</span>
<span class="nc" id="L797">            }</span>
        }
<span class="nc" id="L799">    }</span>

    /**
     * Notify this instance that it may now render a GUI
     */

    public synchronized void okToUseGui() {
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (!okToUseGui) {</span>
<span class="nc" id="L807">            okToUseGui = true;</span>

            // lets also tell the Children that can that they may use their GUI's
<span class="nc" id="L810">            synchronized(children) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                for (Iterator i = children.keySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L812">                    Visibility v = getChildVisibility(i.next());</span>

<span class="nc bnc" id="L814" title="All 2 branches missed.">                    if (v != null) v.okToUseGui();</span>
<span class="nc" id="L815">                }</span>
<span class="nc" id="L816">            }</span>
        }
<span class="nc" id="L818">    }</span>

    /**
     * Used to determine if the &lt;tt&gt;BeanContext&lt;/tt&gt;
     * child is avoiding using its GUI.
     * @return is this instance avoiding using its GUI?
     * @see Visibility
     */
    public boolean avoidingGui() {
<span class="nc bnc" id="L827" title="All 4 branches missed.">        return !okToUseGui &amp;&amp; needsGui();</span>
    }

    /**
     * Is this &lt;tt&gt;BeanContext&lt;/tt&gt; in the
     * process of being serialized?
     * @return if this &lt;tt&gt;BeanContext&lt;/tt&gt; is
     * currently being serialized
     */
<span class="nc" id="L836">    public boolean isSerializing() { return serializing; }</span>

    /**
     * Returns an iterator of all children
     * of this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @return an iterator for all the current BCSChild values
     */
<span class="nc" id="L843">    protected Iterator bcsChildren() { synchronized(children) { return children.values().iterator();  } }</span>

    /**
     * called by writeObject after defaultWriteObject() but prior to
     * serialization of currently serializable children.
     *
     * This method may be overridden by subclasses to perform custom
     * serialization of their state prior to this superclass serializing
     * the children.
     *
     * This method should not however be used by subclasses to replace their
     * own implementation (if any) of writeObject().
     * @param oos the {@code ObjectOutputStream} to use during serialization
     * @throws IOException if serialization failed
     */

    protected void bcsPreSerializationHook(ObjectOutputStream oos) throws IOException {
<span class="nc" id="L860">    }</span>

    /**
     * called by readObject after defaultReadObject() but prior to
     * deserialization of any children.
     *
     * This method may be overridden by subclasses to perform custom
     * deserialization of their state prior to this superclass deserializing
     * the children.
     *
     * This method should not however be used by subclasses to replace their
     * own implementation (if any) of readObject().
     * @param ois the {@code ObjectInputStream} to use during deserialization
     * @throws IOException if deserialization failed
     * @throws ClassNotFoundException if needed classes are not found
     */

    protected void bcsPreDeserializationHook(ObjectInputStream ois) throws IOException, ClassNotFoundException {
<span class="nc" id="L878">    }</span>

    /**
     * Called by readObject with the newly deserialized child and BCSChild.
     * @param child the newly deserialized child
     * @param bcsc the newly deserialized BCSChild
     */
    protected void childDeserializedHook(Object child, BCSChild bcsc) {
<span class="nc" id="L886">        synchronized(children) {</span>
<span class="nc" id="L887">            children.put(child, bcsc);</span>
<span class="nc" id="L888">        }</span>
<span class="nc" id="L889">    }</span>

    /**
     * Used by writeObject to serialize a Collection.
     * @param oos the &lt;tt&gt;ObjectOutputStream&lt;/tt&gt;
     * to use during serialization
     * @param coll the &lt;tt&gt;Collection&lt;/tt&gt; to serialize
     * @throws IOException if serialization failed
     */
    protected final void serialize(ObjectOutputStream oos, Collection coll) throws IOException {
<span class="nc" id="L899">        int      count   = 0;</span>
<span class="nc" id="L900">        Object[] objects = coll.toArray();</span>

<span class="nc bnc" id="L902" title="All 2 branches missed.">        for (int i = 0; i &lt; objects.length; i++) {</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">            if (objects[i] instanceof Serializable)</span>
<span class="nc" id="L904">                count++;</span>
            else
<span class="nc" id="L906">                objects[i] = null;</span>
        }

<span class="nc" id="L909">        oos.writeInt(count); // number of subsequent objects</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (int i = 0; count &gt; 0; i++) {</span>
<span class="nc" id="L912">            Object o = objects[i];</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L915">                oos.writeObject(o);</span>
<span class="nc" id="L916">                count--;</span>
            }
        }
<span class="nc" id="L919">    }</span>

    /**
     * used by readObject to deserialize a collection.
     * @param ois the ObjectInputStream to use
     * @param coll the Collection
     * @throws IOException if deserialization failed
     * @throws ClassNotFoundException if needed classes are not found
     */
    protected final void deserialize(ObjectInputStream ois, Collection coll) throws IOException, ClassNotFoundException {
<span class="nc" id="L929">        int count = 0;</span>

<span class="nc" id="L931">        count = ois.readInt();</span>

<span class="nc bnc" id="L933" title="All 2 branches missed.">        while (count-- &gt; 0) {</span>
<span class="nc" id="L934">            coll.add(ois.readObject());</span>
        }
<span class="nc" id="L936">    }</span>

    /**
     * Used to serialize all children of
     * this &lt;tt&gt;BeanContext&lt;/tt&gt;.
     * @param oos the &lt;tt&gt;ObjectOutputStream&lt;/tt&gt;
     * to use during serialization
     * @throws IOException if serialization failed
     */
    public final void writeChildren(ObjectOutputStream oos) throws IOException {
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (serializable &lt;= 0) return;</span>

<span class="nc" id="L948">        boolean prev = serializing;</span>

<span class="nc" id="L950">        serializing = true;</span>

<span class="nc" id="L952">        int count = 0;</span>

<span class="nc" id="L954">        synchronized(children) {</span>
<span class="nc" id="L955">            Iterator i = children.entrySet().iterator();</span>

<span class="nc bnc" id="L957" title="All 4 branches missed.">            while (i.hasNext() &amp;&amp; count &lt; serializable) {</span>
<span class="nc" id="L958">                Map.Entry entry = (Map.Entry)i.next();</span>

<span class="nc bnc" id="L960" title="All 2 branches missed.">                if (entry.getKey() instanceof Serializable) {</span>
                    try {
<span class="nc" id="L962">                        oos.writeObject(entry.getKey());   // child</span>
<span class="nc" id="L963">                        oos.writeObject(entry.getValue()); // BCSChild</span>
<span class="nc" id="L964">                    } catch (IOException ioe) {</span>
<span class="nc" id="L965">                        serializing = prev;</span>
<span class="nc" id="L966">                        throw ioe;</span>
<span class="nc" id="L967">                    }</span>
<span class="nc" id="L968">                    count++;</span>
                }
<span class="nc" id="L970">            }</span>
<span class="nc" id="L971">        }</span>

<span class="nc" id="L973">        serializing = prev;</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">        if (count != serializable) {</span>
<span class="nc" id="L976">            throw new IOException(&quot;wrote different number of children than expected&quot;);</span>
        }

<span class="nc" id="L979">    }</span>

    /**
     * Serialize the BeanContextSupport, if this instance has a distinct
     * peer (that is this object is acting as a delegate for another) then
     * the children of this instance are not serialized here due to a
     * 'chicken and egg' problem that occurs on deserialization of the
     * children at the same time as this instance.
     *
     * Therefore in situations where there is a distinct peer to this instance
     * it should always call writeObject() followed by writeChildren() and
     * readObject() followed by readChildren().
     *
     * @param oos the ObjectOutputStream
     */

    private synchronized void writeObject(ObjectOutputStream oos) throws IOException, ClassNotFoundException {
<span class="nc" id="L996">        serializing = true;</span>

<span class="nc" id="L998">        synchronized (BeanContext.globalHierarchyLock) {</span>
            try {
<span class="nc" id="L1000">                oos.defaultWriteObject(); // serialize the BeanContextSupport object</span>

<span class="nc" id="L1002">                bcsPreSerializationHook(oos);</span>

<span class="nc bnc" id="L1004" title="All 4 branches missed.">                if (serializable &gt; 0 &amp;&amp; this.equals(getBeanContextPeer()))</span>
<span class="nc" id="L1005">                    writeChildren(oos);</span>

<span class="nc" id="L1007">                serialize(oos, (Collection)bcmListeners);</span>
            } finally {
<span class="nc" id="L1009">                serializing = false;</span>
<span class="nc" id="L1010">            }</span>
<span class="nc" id="L1011">        }</span>
<span class="nc" id="L1012">    }</span>

    /**
     * When an instance of this class is used as a delegate for the
     * implementation of the BeanContext protocols (and its subprotocols)
     * there exists a 'chicken and egg' problem during deserialization
     * @param ois the ObjectInputStream to use
     * @throws IOException if deserialization failed
     * @throws ClassNotFoundException if needed classes are not found
     */

    public final void readChildren(ObjectInputStream ois) throws IOException, ClassNotFoundException {
<span class="nc" id="L1024">        int count = serializable;</span>

<span class="nc bnc" id="L1026" title="All 2 branches missed.">        while (count-- &gt; 0) {</span>
<span class="nc" id="L1027">            Object                      child = null;</span>
<span class="nc" id="L1028">            BeanContextSupport.BCSChild bscc  = null;</span>

            try {
<span class="nc" id="L1031">                child = ois.readObject();</span>
<span class="nc" id="L1032">                bscc  = (BeanContextSupport.BCSChild)ois.readObject();</span>
<span class="nc" id="L1033">            } catch (IOException ioe) {</span>
<span class="nc" id="L1034">                continue;</span>
<span class="nc" id="L1035">            } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L1036">                continue;</span>
<span class="nc" id="L1037">            }</span>


<span class="nc" id="L1040">            synchronized(child) {</span>
<span class="nc" id="L1041">                BeanContextChild bcc = null;</span>

                try {
<span class="nc" id="L1044">                    bcc = (BeanContextChild)child;</span>
<span class="nc" id="L1045">                } catch (ClassCastException cce) {</span>
                    // do nothing;
<span class="nc" id="L1047">                }</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (bcc != null) {</span>
                    try {
<span class="nc" id="L1051">                        bcc.setBeanContext(getBeanContextPeer());</span>

<span class="nc" id="L1053">                       bcc.addPropertyChangeListener(&quot;beanContext&quot;, childPCL);</span>
<span class="nc" id="L1054">                       bcc.addVetoableChangeListener(&quot;beanContext&quot;, childVCL);</span>

<span class="nc" id="L1056">                    } catch (PropertyVetoException pve) {</span>
<span class="nc" id="L1057">                        continue;</span>
<span class="nc" id="L1058">                    }</span>
                }

<span class="nc" id="L1061">                childDeserializedHook(child, bscc);</span>
<span class="nc" id="L1062">            }</span>
<span class="nc" id="L1063">        }</span>
<span class="nc" id="L1064">    }</span>

    /**
     * deserialize contents ... if this instance has a distinct peer the
     * children are *not* serialized here, the peer's readObject() must call
     * readChildren() after deserializing this instance.
     */

    private synchronized void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {

<span class="nc" id="L1074">        synchronized(BeanContext.globalHierarchyLock) {</span>
<span class="nc" id="L1075">            ois.defaultReadObject();</span>

<span class="nc" id="L1077">            initialize();</span>

<span class="nc" id="L1079">            bcsPreDeserializationHook(ois);</span>

<span class="nc bnc" id="L1081" title="All 4 branches missed.">            if (serializable &gt; 0 &amp;&amp; this.equals(getBeanContextPeer()))</span>
<span class="nc" id="L1082">                readChildren(ois);</span>

<span class="nc" id="L1084">            deserialize(ois, bcmListeners = new ArrayList(1));</span>
<span class="nc" id="L1085">        }</span>
<span class="nc" id="L1086">    }</span>

    /**
     * subclasses may envelope to monitor veto child property changes.
     */

    public void vetoableChange(PropertyChangeEvent pce) throws PropertyVetoException {
<span class="nc" id="L1093">        String propertyName = pce.getPropertyName();</span>
<span class="nc" id="L1094">        Object source       = pce.getSource();</span>

<span class="nc" id="L1096">        synchronized(children) {</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            if (&quot;beanContext&quot;.equals(propertyName) &amp;&amp;</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                containsKey(source)                    &amp;&amp;</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                !getBeanContextPeer().equals(pce.getNewValue())</span>
            ) {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                if (!validatePendingRemove(source)) {</span>
<span class="nc" id="L1102">                    throw new PropertyVetoException(&quot;current BeanContext vetoes setBeanContext()&quot;, pce);</span>
<span class="nc" id="L1103">                } else ((BCSChild)children.get(source)).setRemovePending(true);</span>
            }
<span class="nc" id="L1105">        }</span>
<span class="nc" id="L1106">    }</span>

    /**
     * subclasses may envelope to monitor child property changes.
     */

    public void propertyChange(PropertyChangeEvent pce) {
<span class="nc" id="L1113">        String propertyName = pce.getPropertyName();</span>
<span class="nc" id="L1114">        Object source       = pce.getSource();</span>

<span class="nc" id="L1116">        synchronized(children) {</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (&quot;beanContext&quot;.equals(propertyName) &amp;&amp;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                containsKey(source)                    &amp;&amp;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                ((BCSChild)children.get(source)).isRemovePending()) {</span>
<span class="nc" id="L1120">                BeanContext bc = getBeanContextPeer();</span>

<span class="nc bnc" id="L1122" title="All 4 branches missed.">                if (bc.equals(pce.getOldValue()) &amp;&amp; !bc.equals(pce.getNewValue())) {</span>
<span class="nc" id="L1123">                    remove(source, false);</span>
                } else {
<span class="nc" id="L1125">                    ((BCSChild)children.get(source)).setRemovePending(false);</span>
                }
            }
<span class="nc" id="L1128">        }</span>
<span class="nc" id="L1129">    }</span>

    /**
     * &lt;p&gt;
     * Subclasses of this class may override, or envelope, this method to
     * add validation behavior for the BeanContext to examine child objects
     * immediately prior to their being added to the BeanContext.
     * &lt;/p&gt;
     *
     * @param targetChild the child to create the Child on behalf of
     * @return true iff the child may be added to this BeanContext, otherwise false.
     */

    protected boolean validatePendingAdd(Object targetChild) {
<span class="nc" id="L1143">        return true;</span>
    }

    /**
     * &lt;p&gt;
     * Subclasses of this class may override, or envelope, this method to
     * add validation behavior for the BeanContext to examine child objects
     * immediately prior to their being removed from the BeanContext.
     * &lt;/p&gt;
     *
     * @param targetChild the child to create the Child on behalf of
     * @return true iff the child may be removed from this BeanContext, otherwise false.
     */

    protected boolean validatePendingRemove(Object targetChild) {
<span class="nc" id="L1158">        return true;</span>
    }

    /**
     * subclasses may override this method to simply extend add() semantics
     * after the child has been added and before the event notification has
     * occurred. The method is called with the child synchronized.
     * @param child the child
     * @param bcsc the BCSChild
     */

    protected void childJustAddedHook(Object child, BCSChild bcsc) {
<span class="nc" id="L1170">    }</span>

    /**
     * subclasses may override this method to simply extend remove() semantics
     * after the child has been removed and before the event notification has
     * occurred. The method is called with the child synchronized.
     * @param child the child
     * @param bcsc the BCSChild
     */

    protected void childJustRemovedHook(Object child, BCSChild bcsc) {
<span class="nc" id="L1181">    }</span>

    /**
     * Gets the Component (if any) associated with the specified child.
     * @param child the specified child
     * @return the Component (if any) associated with the specified child.
     */
    protected static final Visibility getChildVisibility(Object child) {
        try {
<span class="nc" id="L1190">            return (Visibility)child;</span>
<span class="nc" id="L1191">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1192">            return null;</span>
        }
    }

    /**
     * Gets the Serializable (if any) associated with the specified Child
     * @param child the specified child
     * @return the Serializable (if any) associated with the specified Child
     */
    protected static final Serializable getChildSerializable(Object child) {
        try {
<span class="nc" id="L1203">            return (Serializable)child;</span>
<span class="nc" id="L1204">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1205">            return null;</span>
        }
    }

    /**
     * Gets the PropertyChangeListener
     * (if any) of the specified child
     * @param child the specified child
     * @return the PropertyChangeListener (if any) of the specified child
     */
    protected static final PropertyChangeListener getChildPropertyChangeListener(Object child) {
        try {
<span class="nc" id="L1217">            return (PropertyChangeListener)child;</span>
<span class="nc" id="L1218">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1219">            return null;</span>
        }
    }

    /**
     * Gets the VetoableChangeListener
     * (if any) of the specified child
     * @param child the specified child
     * @return the VetoableChangeListener (if any) of the specified child
     */
    protected static final VetoableChangeListener getChildVetoableChangeListener(Object child) {
        try {
<span class="nc" id="L1231">            return (VetoableChangeListener)child;</span>
<span class="nc" id="L1232">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1233">            return null;</span>
        }
    }

    /**
     * Gets the BeanContextMembershipListener
     * (if any) of the specified child
     * @param child the specified child
     * @return the BeanContextMembershipListener (if any) of the specified child
     */
    protected static final BeanContextMembershipListener getChildBeanContextMembershipListener(Object child) {
        try {
<span class="nc" id="L1245">            return (BeanContextMembershipListener)child;</span>
<span class="nc" id="L1246">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1247">            return null;</span>
        }
    }

    /**
     * Gets the BeanContextChild (if any) of the specified child
     * @param child the specified child
     * @return  the BeanContextChild (if any) of the specified child
     * @throws  IllegalArgumentException if child implements both BeanContextChild and BeanContextProxy
     */
    protected static final BeanContextChild getChildBeanContextChild(Object child) {
        try {
<span class="nc" id="L1259">            BeanContextChild bcc = (BeanContextChild)child;</span>

<span class="nc bnc" id="L1261" title="All 4 branches missed.">            if (child instanceof BeanContextChild &amp;&amp; child instanceof BeanContextProxy)</span>
<span class="nc" id="L1262">                throw new IllegalArgumentException(&quot;child cannot implement both BeanContextChild and BeanContextProxy&quot;);</span>
            else
<span class="nc" id="L1264">                return bcc;</span>
<span class="nc" id="L1265">        } catch (ClassCastException cce) {</span>
            try {
<span class="nc" id="L1267">                return ((BeanContextProxy)child).getBeanContextProxy();</span>
<span class="nc" id="L1268">            } catch (ClassCastException cce1) {</span>
<span class="nc" id="L1269">                return null;</span>
            }
        }
    }

    /**
     * Fire a BeanContextshipEvent on the BeanContextMembershipListener interface
     * @param bcme the event to fire
     */

    protected final void fireChildrenAdded(BeanContextMembershipEvent bcme) {
        Object[] copy;

<span class="nc" id="L1282">        synchronized(bcmListeners) { copy = bcmListeners.toArray(); }</span>

<span class="nc bnc" id="L1284" title="All 2 branches missed.">        for (int i = 0; i &lt; copy.length; i++)</span>
<span class="nc" id="L1285">            ((BeanContextMembershipListener)copy[i]).childrenAdded(bcme);</span>
<span class="nc" id="L1286">    }</span>

    /**
     * Fire a BeanContextshipEvent on the BeanContextMembershipListener interface
     * @param bcme the event to fire
     */

    protected final void fireChildrenRemoved(BeanContextMembershipEvent bcme) {
        Object[] copy;

<span class="nc" id="L1296">        synchronized(bcmListeners) { copy = bcmListeners.toArray(); }</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">        for (int i = 0; i &lt; copy.length; i++)</span>
<span class="nc" id="L1299">            ((BeanContextMembershipListener)copy[i]).childrenRemoved(bcme);</span>
<span class="nc" id="L1300">    }</span>

    /**
     * protected method called from constructor and readObject to initialize
     * transient state of BeanContextSupport instance.
     *
     * This class uses this method to instantiate inner class listeners used
     * to monitor PropertyChange and VetoableChange events on children.
     *
     * subclasses may envelope this method to add their own initialization
     * behavior
     */

    protected synchronized void initialize() {
<span class="nc" id="L1314">        children     = new HashMap(serializable + 1);</span>
<span class="nc" id="L1315">        bcmListeners = new ArrayList(1);</span>

<span class="nc" id="L1317">        childPCL = new PropertyChangeListener() {</span>

            /*
             * this adaptor is used by the BeanContextSupport class to forward
             * property changes from a child to the BeanContext, avoiding
             * accidential serialization of the BeanContext by a badly
             * behaved Serializable child.
             */

            public void propertyChange(PropertyChangeEvent pce) {
<span class="nc" id="L1327">                BeanContextSupport.this.propertyChange(pce);</span>
<span class="nc" id="L1328">            }</span>
        };

<span class="nc" id="L1331">        childVCL = new VetoableChangeListener() {</span>

            /*
             * this adaptor is used by the BeanContextSupport class to forward
             * vetoable changes from a child to the BeanContext, avoiding
             * accidential serialization of the BeanContext by a badly
             * behaved Serializable child.
             */

            public void vetoableChange(PropertyChangeEvent pce) throws PropertyVetoException {
<span class="nc" id="L1341">                BeanContextSupport.this.vetoableChange(pce);</span>
<span class="nc" id="L1342">             }</span>
        };
<span class="nc" id="L1344">    }</span>

    /**
     * Gets a copy of the this BeanContext's children.
     * @return a copy of the current nested children
     */
    protected final Object[] copyChildren() {
<span class="nc" id="L1351">        synchronized(children) { return children.keySet().toArray(); }</span>
    }

    /**
     * Tests to see if two class objects,
     * or their names are equal.
     * @param first the first object
     * @param second the second object
     * @return true if equal, false if not
     */
    protected static final boolean classEquals(Class first, Class second) {
<span class="nc bnc" id="L1362" title="All 4 branches missed.">        return first.equals(second) || first.getName().equals(second.getName());</span>
    }


    /*
     * fields
     */


    /**
     * all accesses to the &lt;code&gt; protected HashMap children &lt;/code&gt; field
     * shall be synchronized on that object.
     */
    protected transient HashMap         children;

<span class="nc" id="L1377">    private             int             serializable  = 0; // children serializable</span>

    /**
     * all accesses to the &lt;code&gt; protected ArrayList bcmListeners &lt;/code&gt; field
     * shall be synchronized on that object.
     */
    protected transient ArrayList       bcmListeners;

    //

    /**
     * The current locale of this BeanContext.
     */
    protected           Locale          locale;

    /**
     * A &lt;tt&gt;boolean&lt;/tt&gt; indicating if this
     * instance may now render a GUI.
     */
    protected           boolean         okToUseGui;


    /**
     * A &lt;tt&gt;boolean&lt;/tt&gt; indicating whether or not
     * this object is currently in design time mode.
     */
    protected           boolean         designTime;

    /*
     * transient
     */

    private transient PropertyChangeListener childPCL;

    private transient VetoableChangeListener childVCL;

    private transient boolean                serializing;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>