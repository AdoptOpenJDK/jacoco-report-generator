<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ProxyClient.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.jconsole</a> &gt; <span class="el_source">ProxyClient.java</span></div><h1>ProxyClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.jconsole;

import com.sun.management.HotSpotDiagnosticMXBean;
import com.sun.tools.jconsole.JConsoleContext;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.io.IOException;
import java.lang.management.*;
import static java.lang.management.ManagementFactory.*;
import java.lang.ref.WeakReference;
import java.lang.reflect.*;
import java.rmi.*;
import java.rmi.registry.*;
import java.rmi.server.*;
import java.util.*;
import javax.management.*;
import javax.management.remote.*;
import javax.management.remote.rmi.*;
import javax.rmi.ssl.SslRMIClientSocketFactory;
import javax.swing.event.SwingPropertyChangeSupport;
import sun.rmi.server.UnicastRef2;
import sun.rmi.transport.LiveRef;

<span class="nc bnc" id="L49" title="All 2 branches missed.">public class ProxyClient implements JConsoleContext {</span>

<span class="nc" id="L51">    private ConnectionState connectionState = ConnectionState.DISCONNECTED;</span>

    // The SwingPropertyChangeSupport will fire events on the EDT
<span class="nc" id="L54">    private SwingPropertyChangeSupport propertyChangeSupport =</span>
                                new SwingPropertyChangeSupport(this, true);

<span class="nc" id="L57">    private static Map&lt;String, ProxyClient&gt; cache =</span>
<span class="nc" id="L58">        Collections.synchronizedMap(new HashMap&lt;String, ProxyClient&gt;());</span>

<span class="nc" id="L60">    private volatile boolean isDead = true;</span>
<span class="nc" id="L61">    private String hostName = null;</span>
<span class="nc" id="L62">    private int port = 0;</span>
<span class="nc" id="L63">    private String userName = null;</span>
<span class="nc" id="L64">    private String password = null;</span>
<span class="nc" id="L65">    private boolean hasPlatformMXBeans = false;</span>
<span class="nc" id="L66">    private boolean hasHotSpotDiagnosticMXBean= false;</span>
<span class="nc" id="L67">    private boolean hasCompilationMXBean = false;</span>
<span class="nc" id="L68">    private boolean supportsLockUsage = false;</span>

    // REVISIT: VMPanel and other places relying using getUrl().

    // set only if it's created for local monitoring
    private LocalVirtualMachine lvm;

    // set only if it's created from a given URL via the Advanced tab
<span class="nc" id="L76">    private String advancedUrl = null;</span>

<span class="nc" id="L78">    private JMXServiceURL jmxUrl = null;</span>
<span class="nc" id="L79">    private MBeanServerConnection mbsc = null;</span>
<span class="nc" id="L80">    private SnapshotMBeanServerConnection server = null;</span>
<span class="nc" id="L81">    private JMXConnector jmxc = null;</span>
<span class="nc" id="L82">    private RMIServer stub = null;</span>
<span class="nc" id="L83">    private static final SslRMIClientSocketFactory sslRMIClientSocketFactory =</span>
            new SslRMIClientSocketFactory();
<span class="nc" id="L85">    private String registryHostName = null;</span>
<span class="nc" id="L86">    private int registryPort = 0;</span>
<span class="nc" id="L87">    private boolean vmConnector = false;</span>
<span class="nc" id="L88">    private boolean sslRegistry = false;</span>
<span class="nc" id="L89">    private boolean sslStub = false;</span>
    final private String connectionName;
    final private String displayName;

<span class="nc" id="L93">    private ClassLoadingMXBean    classLoadingMBean = null;</span>
<span class="nc" id="L94">    private CompilationMXBean     compilationMBean = null;</span>
<span class="nc" id="L95">    private MemoryMXBean          memoryMBean = null;</span>
<span class="nc" id="L96">    private OperatingSystemMXBean operatingSystemMBean = null;</span>
<span class="nc" id="L97">    private RuntimeMXBean         runtimeMBean = null;</span>
<span class="nc" id="L98">    private ThreadMXBean          threadMBean = null;</span>

<span class="nc" id="L100">    private com.sun.management.OperatingSystemMXBean sunOperatingSystemMXBean = null;</span>
<span class="nc" id="L101">    private HotSpotDiagnosticMXBean                  hotspotDiagnosticMXBean = null;</span>

<span class="nc" id="L103">    private List&lt;MemoryPoolProxy&gt;           memoryPoolProxies = null;</span>
<span class="nc" id="L104">    private List&lt;GarbageCollectorMXBean&gt;    garbageCollectorMBeans = null;</span>

    final static private String HOTSPOT_DIAGNOSTIC_MXBEAN_NAME =
        &quot;com.sun.management:type=HotSpotDiagnostic&quot;;

    private ProxyClient(String hostName, int port,
<span class="nc" id="L110">                        String userName, String password) throws IOException {</span>
<span class="nc" id="L111">        this.connectionName = getConnectionName(hostName, port, userName);</span>
<span class="nc" id="L112">        this.displayName = connectionName;</span>
<span class="nc bnc" id="L113" title="All 4 branches missed.">        if (hostName.equals(&quot;localhost&quot;) &amp;&amp; port == 0) {</span>
            // Monitor self
<span class="nc" id="L115">            this.hostName = hostName;</span>
<span class="nc" id="L116">            this.port = port;</span>
        } else {
            // Create an RMI connector client and connect it to
            // the RMI connector server
<span class="nc" id="L120">            final String urlPath = &quot;/jndi/rmi://&quot; + hostName + &quot;:&quot; + port +</span>
                                   &quot;/jmxrmi&quot;;
<span class="nc" id="L122">            JMXServiceURL url = new JMXServiceURL(&quot;rmi&quot;, &quot;&quot;, 0, urlPath);</span>
<span class="nc" id="L123">            setParameters(url, userName, password);</span>
<span class="nc" id="L124">            vmConnector = true;</span>
<span class="nc" id="L125">            registryHostName = hostName;</span>
<span class="nc" id="L126">            registryPort = port;</span>
<span class="nc" id="L127">            checkSslConfig();</span>
        }
<span class="nc" id="L129">    }</span>

    private ProxyClient(String url,
<span class="nc" id="L132">                        String userName, String password) throws IOException {</span>
<span class="nc" id="L133">        this.advancedUrl = url;</span>
<span class="nc" id="L134">        this.connectionName = getConnectionName(url, userName);</span>
<span class="nc" id="L135">        this.displayName = connectionName;</span>
<span class="nc" id="L136">        setParameters(new JMXServiceURL(url), userName, password);</span>
<span class="nc" id="L137">    }</span>

<span class="nc" id="L139">    private ProxyClient(LocalVirtualMachine lvm) throws IOException {</span>
<span class="nc" id="L140">        this.lvm = lvm;</span>
<span class="nc" id="L141">        this.connectionName = getConnectionName(lvm);</span>
<span class="nc" id="L142">        this.displayName = &quot;pid: &quot; + lvm.vmid() + &quot; &quot; + lvm.displayName();</span>
<span class="nc" id="L143">    }</span>

    private void setParameters(JMXServiceURL url, String userName, String password) {
<span class="nc" id="L146">        this.jmxUrl = url;</span>
<span class="nc" id="L147">        this.hostName = jmxUrl.getHost();</span>
<span class="nc" id="L148">        this.port = jmxUrl.getPort();</span>
<span class="nc" id="L149">        this.userName = userName;</span>
<span class="nc" id="L150">        this.password = password;</span>
<span class="nc" id="L151">    }</span>

    private static void checkStub(Remote stub,
                                  Class&lt;? extends Remote&gt; stubClass) {
        // Check remote stub is from the expected class.
        //
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (stub.getClass() != stubClass) {</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (!Proxy.isProxyClass(stub.getClass())) {</span>
<span class="nc" id="L159">                throw new SecurityException(</span>
<span class="nc" id="L160">                    &quot;Expecting a &quot; + stubClass.getName() + &quot; stub!&quot;);</span>
            } else {
<span class="nc" id="L162">                InvocationHandler handler = Proxy.getInvocationHandler(stub);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                if (handler.getClass() != RemoteObjectInvocationHandler.class) {</span>
<span class="nc" id="L164">                    throw new SecurityException(</span>
                        &quot;Expecting a dynamic proxy instance with a &quot; +
<span class="nc" id="L166">                        RemoteObjectInvocationHandler.class.getName() +</span>
                        &quot; invocation handler!&quot;);
                } else {
<span class="nc" id="L169">                    stub = (Remote) handler;</span>
                }
            }
        }
        // Check RemoteRef in stub is from the expected class
        // &quot;sun.rmi.server.UnicastRef2&quot;.
        //
<span class="nc" id="L176">        RemoteRef ref = ((RemoteObject)stub).getRef();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (ref.getClass() != UnicastRef2.class) {</span>
<span class="nc" id="L178">            throw new SecurityException(</span>
<span class="nc" id="L179">                &quot;Expecting a &quot; + UnicastRef2.class.getName() +</span>
                &quot; remote reference in stub!&quot;);
        }
        // Check RMIClientSocketFactory in stub is from the expected class
        // &quot;javax.rmi.ssl.SslRMIClientSocketFactory&quot;.
        //
<span class="nc" id="L185">        LiveRef liveRef = ((UnicastRef2)ref).getLiveRef();</span>
<span class="nc" id="L186">        RMIClientSocketFactory csf = liveRef.getClientSocketFactory();</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">        if (csf == null || csf.getClass() != SslRMIClientSocketFactory.class) {</span>
<span class="nc" id="L188">            throw new SecurityException(</span>
<span class="nc" id="L189">                &quot;Expecting a &quot; + SslRMIClientSocketFactory.class.getName() +</span>
                &quot; RMI client socket factory in stub!&quot;);
        }
<span class="nc" id="L192">    }</span>

    private static final String rmiServerImplStubClassName =
        &quot;javax.management.remote.rmi.RMIServerImpl_Stub&quot;;
    private static final Class&lt;? extends Remote&gt; rmiServerImplStubClass;

    static {
        // FIXME: RMIServerImpl_Stub is generated at build time
        // after jconsole is built.  We need to investigate if
        // the Makefile can be fixed to build jconsole in the
        // right order.  As a workaround for now, we dynamically
        // load RMIServerImpl_Stub class instead of statically
        // referencing it.
<span class="nc" id="L205">        Class&lt;? extends Remote&gt; serverStubClass = null;</span>
        try {
<span class="nc" id="L207">            serverStubClass = Class.forName(rmiServerImplStubClassName).asSubclass(Remote.class);</span>
<span class="nc" id="L208">        } catch (ClassNotFoundException e) {</span>
            // should never reach here
<span class="nc" id="L210">            throw new InternalError(e.getMessage(), e);</span>
<span class="nc" id="L211">        }</span>
<span class="nc" id="L212">        rmiServerImplStubClass = serverStubClass;</span>
<span class="nc" id="L213">    }</span>

    private void checkSslConfig() throws IOException {
        // Get the reference to the RMI Registry and lookup RMIServer stub
        //
        Registry registry;
        try {
<span class="nc" id="L220">            registry =</span>
<span class="nc" id="L221">                LocateRegistry.getRegistry(registryHostName, registryPort,</span>
                                           sslRMIClientSocketFactory);
            try {
<span class="nc" id="L224">                stub = (RMIServer) registry.lookup(&quot;jmxrmi&quot;);</span>
<span class="nc" id="L225">            } catch (NotBoundException nbe) {</span>
<span class="nc" id="L226">                throw (IOException)</span>
<span class="nc" id="L227">                    new IOException(nbe.getMessage()).initCause(nbe);</span>
<span class="nc" id="L228">            }</span>
<span class="nc" id="L229">            sslRegistry = true;</span>
<span class="nc" id="L230">        } catch (IOException e) {</span>
<span class="nc" id="L231">            registry =</span>
<span class="nc" id="L232">                LocateRegistry.getRegistry(registryHostName, registryPort);</span>
            try {
<span class="nc" id="L234">                stub = (RMIServer) registry.lookup(&quot;jmxrmi&quot;);</span>
<span class="nc" id="L235">            } catch (NotBoundException nbe) {</span>
<span class="nc" id="L236">                throw (IOException)</span>
<span class="nc" id="L237">                    new IOException(nbe.getMessage()).initCause(nbe);</span>
<span class="nc" id="L238">            }</span>
<span class="nc" id="L239">            sslRegistry = false;</span>
<span class="nc" id="L240">        }</span>
        // Perform the checks for secure stub
        //
        try {
<span class="nc" id="L244">            checkStub(stub, rmiServerImplStubClass);</span>
<span class="nc" id="L245">            sslStub = true;</span>
<span class="nc" id="L246">        } catch (SecurityException e) {</span>
<span class="nc" id="L247">            sslStub = false;</span>
<span class="nc" id="L248">        }</span>
<span class="nc" id="L249">    }</span>

    /**
     * Returns true if the underlying RMI registry is SSL-protected.
     *
     * @exception UnsupportedOperationException If this {@code ProxyClient}
     * does not denote a JMX connector for a JMX VM agent.
     */
    public boolean isSslRmiRegistry() {
        // Check for VM connector
        //
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (!isVmConnector()) {</span>
<span class="nc" id="L261">            throw new UnsupportedOperationException(</span>
                &quot;ProxyClient.isSslRmiRegistry() is only supported if this &quot; +
                &quot;ProxyClient is a JMX connector for a JMX VM agent&quot;);
        }
<span class="nc" id="L265">        return sslRegistry;</span>
    }

    /**
     * Returns true if the retrieved RMI stub is SSL-protected.
     *
     * @exception UnsupportedOperationException If this {@code ProxyClient}
     * does not denote a JMX connector for a JMX VM agent.
     */
    public boolean isSslRmiStub() {
        // Check for VM connector
        //
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (!isVmConnector()) {</span>
<span class="nc" id="L278">            throw new UnsupportedOperationException(</span>
                &quot;ProxyClient.isSslRmiStub() is only supported if this &quot; +
                &quot;ProxyClient is a JMX connector for a JMX VM agent&quot;);
        }
<span class="nc" id="L282">        return sslStub;</span>
    }

    /**
     * Returns true if this {@code ProxyClient} denotes
     * a JMX connector for a JMX VM agent.
     */
    public boolean isVmConnector() {
<span class="nc" id="L290">        return vmConnector;</span>
    }

    private void setConnectionState(ConnectionState state) {
<span class="nc" id="L294">        ConnectionState oldState = this.connectionState;</span>
<span class="nc" id="L295">        this.connectionState = state;</span>
<span class="nc" id="L296">        propertyChangeSupport.firePropertyChange(CONNECTION_STATE_PROPERTY,</span>
                                                 oldState, state);
<span class="nc" id="L298">    }</span>

    public ConnectionState getConnectionState() {
<span class="nc" id="L301">        return this.connectionState;</span>
    }

    void flush() {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (server != null) {</span>
<span class="nc" id="L306">            server.flush();</span>
        }
<span class="nc" id="L308">    }</span>

    void connect(boolean requireSSL) {
<span class="nc" id="L311">        setConnectionState(ConnectionState.CONNECTING);</span>
        try {
<span class="nc" id="L313">            tryConnect(requireSSL);</span>
<span class="nc" id="L314">            setConnectionState(ConnectionState.CONNECTED);</span>
<span class="nc" id="L315">        } catch (Exception e) {</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (JConsole.isDebug()) {</span>
<span class="nc" id="L317">                e.printStackTrace();</span>
            }
<span class="nc" id="L319">            setConnectionState(ConnectionState.DISCONNECTED);</span>
<span class="nc" id="L320">        }</span>
<span class="nc" id="L321">    }</span>

    private void tryConnect(boolean requireRemoteSSL) throws IOException {
<span class="nc bnc" id="L324" title="All 6 branches missed.">        if (jmxUrl == null &amp;&amp; &quot;localhost&quot;.equals(hostName) &amp;&amp; port == 0) {</span>
            // Monitor self
<span class="nc" id="L326">            this.jmxc = null;</span>
<span class="nc" id="L327">            this.mbsc = ManagementFactory.getPlatformMBeanServer();</span>
<span class="nc" id="L328">            this.server = Snapshot.newSnapshot(mbsc);</span>
        } else {
            // Monitor another process
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (lvm != null) {</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (!lvm.isManageable()) {</span>
<span class="nc" id="L333">                    lvm.startManagementAgent();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    if (!lvm.isManageable()) {</span>
                        // FIXME: what to throw
<span class="nc" id="L336">                        throw new IOException(lvm + &quot;not manageable&quot;);</span>
                    }
                }
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (this.jmxUrl == null) {</span>
<span class="nc" id="L340">                    this.jmxUrl = new JMXServiceURL(lvm.connectorAddress());</span>
                }
            }
<span class="nc" id="L343">            Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (requireRemoteSSL) {</span>
<span class="nc" id="L345">                env.put(&quot;jmx.remote.x.check.stub&quot;, &quot;true&quot;);</span>
            }
            // Need to pass in credentials ?
<span class="nc bnc" id="L348" title="All 4 branches missed.">            if (userName == null &amp;&amp; password == null) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (isVmConnector()) {</span>
                    // Check for SSL config on reconnection only
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (stub == null) {</span>
<span class="nc" id="L352">                        checkSslConfig();</span>
                    }
<span class="nc" id="L354">                    this.jmxc = new RMIConnector(stub, null);</span>
<span class="nc" id="L355">                    jmxc.connect(env);</span>
                } else {
<span class="nc" id="L357">                    this.jmxc = JMXConnectorFactory.connect(jmxUrl, env);</span>
                }
            } else {
<span class="nc" id="L360">                env.put(JMXConnector.CREDENTIALS,</span>
                        new String[] {userName, password});
<span class="nc bnc" id="L362" title="All 2 branches missed.">                if (isVmConnector()) {</span>
                    // Check for SSL config on reconnection only
<span class="nc bnc" id="L364" title="All 2 branches missed.">                    if (stub == null) {</span>
<span class="nc" id="L365">                        checkSslConfig();</span>
                    }
<span class="nc" id="L367">                    this.jmxc = new RMIConnector(stub, null);</span>
<span class="nc" id="L368">                    jmxc.connect(env);</span>
                } else {
<span class="nc" id="L370">                    this.jmxc = JMXConnectorFactory.connect(jmxUrl, env);</span>
                }
            }
<span class="nc" id="L373">            this.mbsc = jmxc.getMBeanServerConnection();</span>
<span class="nc" id="L374">            this.server = Snapshot.newSnapshot(mbsc);</span>
        }
<span class="nc" id="L376">        this.isDead = false;</span>

        try {
<span class="nc" id="L379">            ObjectName on = new ObjectName(THREAD_MXBEAN_NAME);</span>
<span class="nc" id="L380">            this.hasPlatformMXBeans = server.isRegistered(on);</span>
<span class="nc" id="L381">            this.hasHotSpotDiagnosticMXBean =</span>
<span class="nc" id="L382">                server.isRegistered(new ObjectName(HOTSPOT_DIAGNOSTIC_MXBEAN_NAME));</span>
            // check if it has 6.0 new APIs
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if (this.hasPlatformMXBeans) {</span>
<span class="nc" id="L385">                MBeanOperationInfo[] mopis = server.getMBeanInfo(on).getOperations();</span>
                // look for findDeadlockedThreads operations;
<span class="nc bnc" id="L387" title="All 2 branches missed.">                for (MBeanOperationInfo op : mopis) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                    if (op.getName().equals(&quot;findDeadlockedThreads&quot;)) {</span>
<span class="nc" id="L389">                        this.supportsLockUsage = true;</span>
<span class="nc" id="L390">                        break;</span>
                    }
                }

<span class="nc" id="L394">                on = new ObjectName(COMPILATION_MXBEAN_NAME);</span>
<span class="nc" id="L395">                this.hasCompilationMXBean = server.isRegistered(on);</span>
            }
<span class="nc" id="L397">        } catch (MalformedObjectNameException e) {</span>
            // should not reach here
<span class="nc" id="L399">            throw new InternalError(e.getMessage());</span>
<span class="nc" id="L400">        } catch (IntrospectionException |</span>
                 InstanceNotFoundException |
                 ReflectionException e) {
<span class="nc" id="L403">            throw new InternalError(e.getMessage(), e);</span>
<span class="nc" id="L404">        }</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (hasPlatformMXBeans) {</span>
            // WORKAROUND for bug 5056632
            // Check if the access role is correct by getting a RuntimeMXBean
<span class="nc" id="L409">            getRuntimeMXBean();</span>
        }
<span class="nc" id="L411">    }</span>

    /**
     * Gets a proxy client for a given local virtual machine.
     */
    public static ProxyClient getProxyClient(LocalVirtualMachine lvm)
        throws IOException {
<span class="nc" id="L418">        final String key = getCacheKey(lvm);</span>
<span class="nc" id="L419">        ProxyClient proxyClient = cache.get(key);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (proxyClient == null) {</span>
<span class="nc" id="L421">            proxyClient = new ProxyClient(lvm);</span>
<span class="nc" id="L422">            cache.put(key, proxyClient);</span>
        }
<span class="nc" id="L424">        return proxyClient;</span>
    }

    public static String getConnectionName(LocalVirtualMachine lvm) {
<span class="nc" id="L428">        return Integer.toString(lvm.vmid());</span>
    }

    private static String getCacheKey(LocalVirtualMachine lvm) {
<span class="nc" id="L432">        return Integer.toString(lvm.vmid());</span>
    }

    /**
     * Gets a proxy client for a given JMXServiceURL.
     */
    public static ProxyClient getProxyClient(String url,
                                             String userName, String password)
        throws IOException {
<span class="nc" id="L441">        final String key = getCacheKey(url, userName, password);</span>
<span class="nc" id="L442">        ProxyClient proxyClient = cache.get(key);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (proxyClient == null) {</span>
<span class="nc" id="L444">            proxyClient = new ProxyClient(url, userName, password);</span>
<span class="nc" id="L445">            cache.put(key, proxyClient);</span>
        }
<span class="nc" id="L447">        return proxyClient;</span>
    }

    public static String getConnectionName(String url,
                                           String userName) {
<span class="nc bnc" id="L452" title="All 4 branches missed.">        if (userName != null &amp;&amp; userName.length() &gt; 0) {</span>
<span class="nc" id="L453">            return userName + &quot;@&quot; + url;</span>
        } else {
<span class="nc" id="L455">            return url;</span>
        }
    }

    private static String getCacheKey(String url,
                                      String userName, String password) {
<span class="nc bnc" id="L461" title="All 6 branches missed.">        return (url == null ? &quot;&quot; : url) + &quot;:&quot; +</span>
               (userName == null ? &quot;&quot; : userName) + &quot;:&quot; +
               (password == null ? &quot;&quot; : password);
    }

    /**
     * Gets a proxy client for a given &quot;hostname:port&quot;.
     */
    public static ProxyClient getProxyClient(String hostName, int port,
                                             String userName, String password)
        throws IOException {
<span class="nc" id="L472">        final String key = getCacheKey(hostName, port, userName, password);</span>
<span class="nc" id="L473">        ProxyClient proxyClient = cache.get(key);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (proxyClient == null) {</span>
<span class="nc" id="L475">            proxyClient = new ProxyClient(hostName, port, userName, password);</span>
<span class="nc" id="L476">            cache.put(key, proxyClient);</span>
        }
<span class="nc" id="L478">        return proxyClient;</span>
    }

    public static String getConnectionName(String hostName, int port,
                                           String userName) {
<span class="nc" id="L483">        String name = hostName + &quot;:&quot; + port;</span>
<span class="nc bnc" id="L484" title="All 4 branches missed.">        if (userName != null &amp;&amp; userName.length() &gt; 0) {</span>
<span class="nc" id="L485">            return userName + &quot;@&quot; + name;</span>
        } else {
<span class="nc" id="L487">            return name;</span>
        }
    }

    private static String getCacheKey(String hostName, int port,
                                      String userName, String password) {
<span class="nc bnc" id="L493" title="All 6 branches missed.">        return (hostName == null ? &quot;&quot; : hostName) + &quot;:&quot; +</span>
               port + &quot;:&quot; +
               (userName == null ? &quot;&quot; : userName) + &quot;:&quot; +
               (password == null ? &quot;&quot; : password);
    }

    public String connectionName() {
<span class="nc" id="L500">        return connectionName;</span>
    }

    public String getDisplayName() {
<span class="nc" id="L504">        return displayName;</span>
    }

    public String toString() {
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (!isConnected()) {</span>
<span class="nc" id="L509">            return Resources.format(Messages.CONNECTION_NAME__DISCONNECTED_, displayName);</span>
        } else {
<span class="nc" id="L511">            return displayName;</span>
        }
    }

   public MBeanServerConnection getMBeanServerConnection() {
<span class="nc" id="L516">       return mbsc;</span>
   }

    public SnapshotMBeanServerConnection getSnapshotMBeanServerConnection() {
<span class="nc" id="L520">        return server;</span>
    }

    public String getUrl() {
<span class="nc" id="L524">        return advancedUrl;</span>
    }

    public String getHostName() {
<span class="nc" id="L528">        return hostName;</span>
    }

    public int getPort() {
<span class="nc" id="L532">        return port;</span>
    }

    public int getVmid() {
<span class="nc bnc" id="L536" title="All 2 branches missed.">        return (lvm != null) ? lvm.vmid() : 0;</span>
    }

    public String getUserName() {
<span class="nc" id="L540">        return userName;</span>
    }

    public String getPassword() {
<span class="nc" id="L544">        return password;</span>
    }

    public void disconnect() {
        // Reset remote stub
<span class="nc" id="L549">        stub = null;</span>
        // Close MBeanServer connection
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (jmxc != null) {</span>
            try {
<span class="nc" id="L553">                jmxc.close();</span>
<span class="nc" id="L554">            } catch (IOException e) {</span>
                // Ignore ???
<span class="nc" id="L556">            }</span>
        }
        // Reset platform MBean references
<span class="nc" id="L559">        classLoadingMBean = null;</span>
<span class="nc" id="L560">        compilationMBean = null;</span>
<span class="nc" id="L561">        memoryMBean = null;</span>
<span class="nc" id="L562">        operatingSystemMBean = null;</span>
<span class="nc" id="L563">        runtimeMBean = null;</span>
<span class="nc" id="L564">        threadMBean = null;</span>
<span class="nc" id="L565">        sunOperatingSystemMXBean = null;</span>
<span class="nc" id="L566">        garbageCollectorMBeans = null;</span>
        // Set connection state to DISCONNECTED
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (!isDead) {</span>
<span class="nc" id="L569">            isDead = true;</span>
<span class="nc" id="L570">            setConnectionState(ConnectionState.DISCONNECTED);</span>
        }
<span class="nc" id="L572">    }</span>

    /**
     * Returns the list of domains in which any MBean is
     * currently registered.
     */
    public String[] getDomains() throws IOException {
<span class="nc" id="L579">        return server.getDomains();</span>
    }

    /**
     * Returns a map of MBeans with ObjectName as the key and MBeanInfo value
     * of a given domain.  If domain is &lt;tt&gt;null&lt;/tt&gt;, all MBeans
     * are returned.  If no MBean found, an empty map is returned.
     *
     */
    public Map&lt;ObjectName, MBeanInfo&gt; getMBeans(String domain)
        throws IOException {

<span class="nc" id="L591">        ObjectName name = null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (domain != null) {</span>
            try {
<span class="nc" id="L594">                name = new ObjectName(domain + &quot;:*&quot;);</span>
<span class="nc" id="L595">            } catch (MalformedObjectNameException e) {</span>
                // should not reach here
<span class="nc bnc" id="L597" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L598">            }</span>
        }
<span class="nc" id="L600">        Set&lt;ObjectName&gt; mbeans = server.queryNames(name, null);</span>
<span class="nc" id="L601">        Map&lt;ObjectName,MBeanInfo&gt; result =</span>
<span class="nc" id="L602">            new HashMap&lt;ObjectName,MBeanInfo&gt;(mbeans.size());</span>
<span class="nc" id="L603">        Iterator&lt;ObjectName&gt; iterator = mbeans.iterator();</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">        while (iterator.hasNext()) {</span>
<span class="nc" id="L605">            Object object = iterator.next();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">            if (object instanceof ObjectName) {</span>
<span class="nc" id="L607">                ObjectName o = (ObjectName)object;</span>
                try {
<span class="nc" id="L609">                    MBeanInfo info = server.getMBeanInfo(o);</span>
<span class="nc" id="L610">                    result.put(o, info);</span>
<span class="nc" id="L611">                } catch (IntrospectionException e) {</span>
                    // TODO: should log the error
<span class="nc" id="L613">                } catch (InstanceNotFoundException e) {</span>
                    // TODO: should log the error
<span class="nc" id="L615">                } catch (ReflectionException e) {</span>
                    // TODO: should log the error
<span class="nc" id="L617">                }</span>
            }
<span class="nc" id="L619">        }</span>
<span class="nc" id="L620">        return result;</span>
    }

    /**
     * Returns a list of attributes of a named MBean.
     *
     */
    public AttributeList getAttributes(ObjectName name, String[] attributes)
        throws IOException {
<span class="nc" id="L629">        AttributeList list = null;</span>
        try {
<span class="nc" id="L631">            list = server.getAttributes(name, attributes);</span>
<span class="nc" id="L632">        } catch (InstanceNotFoundException e) {</span>
            // TODO: A MBean may have been unregistered.
            // need to set up listener to listen for MBeanServerNotification.
<span class="nc" id="L635">        } catch (ReflectionException e) {</span>
            // TODO: should log the error
<span class="nc" id="L637">        }</span>
<span class="nc" id="L638">        return list;</span>
    }

    /**
     * Set the value of a specific attribute of a named MBean.
     */
    public void setAttribute(ObjectName name, Attribute attribute)
        throws InvalidAttributeValueException,
               MBeanException,
               IOException {
        try {
<span class="nc" id="L649">            server.setAttribute(name, attribute);</span>
<span class="nc" id="L650">        } catch (InstanceNotFoundException e) {</span>
            // TODO: A MBean may have been unregistered.
<span class="nc" id="L652">        } catch (AttributeNotFoundException e) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">            assert(false);</span>
<span class="nc" id="L654">        } catch (ReflectionException e) {</span>
            // TODO: should log the error
<span class="nc" id="L656">        }</span>
<span class="nc" id="L657">    }</span>

    /**
     * Invokes an operation of a named MBean.
     *
     * @throws MBeanException Wraps an exception thrown by
     *      the MBean's invoked method.
     */
    public Object invoke(ObjectName name, String operationName,
                         Object[] params, String[] signature)
        throws IOException, MBeanException {
<span class="nc" id="L668">        Object result = null;</span>
        try {
<span class="nc" id="L670">            result = server.invoke(name, operationName, params, signature);</span>
<span class="nc" id="L671">        } catch (InstanceNotFoundException e) {</span>
            // TODO: A MBean may have been unregistered.
<span class="nc" id="L673">        } catch (ReflectionException e) {</span>
            // TODO: should log the error
<span class="nc" id="L675">        }</span>
<span class="nc" id="L676">        return result;</span>
    }

    public synchronized ClassLoadingMXBean getClassLoadingMXBean() throws IOException {
<span class="nc bnc" id="L680" title="All 4 branches missed.">        if (hasPlatformMXBeans &amp;&amp; classLoadingMBean == null) {</span>
<span class="nc" id="L681">            classLoadingMBean =</span>
<span class="nc" id="L682">                newPlatformMXBeanProxy(server, CLASS_LOADING_MXBEAN_NAME,</span>
                                       ClassLoadingMXBean.class);
        }
<span class="nc" id="L685">        return classLoadingMBean;</span>
    }

    public synchronized CompilationMXBean getCompilationMXBean() throws IOException {
<span class="nc bnc" id="L689" title="All 4 branches missed.">        if (hasCompilationMXBean &amp;&amp; compilationMBean == null) {</span>
<span class="nc" id="L690">            compilationMBean =</span>
<span class="nc" id="L691">                newPlatformMXBeanProxy(server, COMPILATION_MXBEAN_NAME,</span>
                                       CompilationMXBean.class);
        }
<span class="nc" id="L694">        return compilationMBean;</span>
    }

    public Collection&lt;MemoryPoolProxy&gt; getMemoryPoolProxies()
        throws IOException {

        // TODO: How to deal with changes to the list??
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (memoryPoolProxies == null) {</span>
<span class="nc" id="L702">            ObjectName poolName = null;</span>
            try {
<span class="nc" id="L704">                poolName = new ObjectName(MEMORY_POOL_MXBEAN_DOMAIN_TYPE + &quot;,*&quot;);</span>
<span class="nc" id="L705">            } catch (MalformedObjectNameException e) {</span>
                // should not reach here
<span class="nc bnc" id="L707" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L708">            }</span>
<span class="nc" id="L709">            Set&lt;ObjectName&gt; mbeans = server.queryNames(poolName, null);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (mbeans != null) {</span>
<span class="nc" id="L711">                memoryPoolProxies = new ArrayList&lt;MemoryPoolProxy&gt;();</span>
<span class="nc" id="L712">                Iterator&lt;ObjectName&gt; iterator = mbeans.iterator();</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L714">                    ObjectName objName = (ObjectName) iterator.next();</span>
<span class="nc" id="L715">                    MemoryPoolProxy p = new MemoryPoolProxy(this, objName);</span>
<span class="nc" id="L716">                    memoryPoolProxies.add(p);</span>
<span class="nc" id="L717">                }</span>
            }
        }
<span class="nc" id="L720">        return memoryPoolProxies;</span>
    }

    public synchronized Collection&lt;GarbageCollectorMXBean&gt; getGarbageCollectorMXBeans()
        throws IOException {

        // TODO: How to deal with changes to the list??
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (garbageCollectorMBeans == null) {</span>
<span class="nc" id="L728">            ObjectName gcName = null;</span>
            try {
<span class="nc" id="L730">                gcName = new ObjectName(GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + &quot;,*&quot;);</span>
<span class="nc" id="L731">            } catch (MalformedObjectNameException e) {</span>
                // should not reach here
<span class="nc bnc" id="L733" title="All 2 branches missed.">                assert(false);</span>
<span class="nc" id="L734">            }</span>
<span class="nc" id="L735">            Set&lt;ObjectName&gt; mbeans = server.queryNames(gcName, null);</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (mbeans != null) {</span>
<span class="nc" id="L737">                garbageCollectorMBeans = new ArrayList&lt;GarbageCollectorMXBean&gt;();</span>
<span class="nc" id="L738">                Iterator&lt;ObjectName&gt; iterator = mbeans.iterator();</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                while (iterator.hasNext()) {</span>
<span class="nc" id="L740">                    ObjectName on = (ObjectName) iterator.next();</span>
<span class="nc" id="L741">                    String name = GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE +</span>
<span class="nc" id="L742">                        &quot;,name=&quot; + on.getKeyProperty(&quot;name&quot;);</span>

<span class="nc" id="L744">                    GarbageCollectorMXBean mBean =</span>
<span class="nc" id="L745">                        newPlatformMXBeanProxy(server, name,</span>
                                               GarbageCollectorMXBean.class);
<span class="nc" id="L747">                        garbageCollectorMBeans.add(mBean);</span>
<span class="nc" id="L748">                }</span>
            }
        }
<span class="nc" id="L751">        return garbageCollectorMBeans;</span>
    }

    public synchronized MemoryMXBean getMemoryMXBean() throws IOException {
<span class="nc bnc" id="L755" title="All 4 branches missed.">        if (hasPlatformMXBeans &amp;&amp; memoryMBean == null) {</span>
<span class="nc" id="L756">            memoryMBean =</span>
<span class="nc" id="L757">                newPlatformMXBeanProxy(server, MEMORY_MXBEAN_NAME,</span>
                                       MemoryMXBean.class);
        }
<span class="nc" id="L760">        return memoryMBean;</span>
    }

    public synchronized RuntimeMXBean getRuntimeMXBean() throws IOException {
<span class="nc bnc" id="L764" title="All 4 branches missed.">        if (hasPlatformMXBeans &amp;&amp; runtimeMBean == null) {</span>
<span class="nc" id="L765">            runtimeMBean =</span>
<span class="nc" id="L766">                newPlatformMXBeanProxy(server, RUNTIME_MXBEAN_NAME,</span>
                                       RuntimeMXBean.class);
        }
<span class="nc" id="L769">        return runtimeMBean;</span>
    }


    public synchronized ThreadMXBean getThreadMXBean() throws IOException {
<span class="nc bnc" id="L774" title="All 4 branches missed.">        if (hasPlatformMXBeans &amp;&amp; threadMBean == null) {</span>
<span class="nc" id="L775">            threadMBean =</span>
<span class="nc" id="L776">                newPlatformMXBeanProxy(server, THREAD_MXBEAN_NAME,</span>
                                       ThreadMXBean.class);
        }
<span class="nc" id="L779">        return threadMBean;</span>
    }

    public synchronized OperatingSystemMXBean getOperatingSystemMXBean() throws IOException {
<span class="nc bnc" id="L783" title="All 4 branches missed.">        if (hasPlatformMXBeans &amp;&amp; operatingSystemMBean == null) {</span>
<span class="nc" id="L784">            operatingSystemMBean =</span>
<span class="nc" id="L785">                newPlatformMXBeanProxy(server, OPERATING_SYSTEM_MXBEAN_NAME,</span>
                                       OperatingSystemMXBean.class);
        }
<span class="nc" id="L788">        return operatingSystemMBean;</span>
    }

    public synchronized com.sun.management.OperatingSystemMXBean
        getSunOperatingSystemMXBean() throws IOException {

        try {
<span class="nc" id="L795">            ObjectName on = new ObjectName(OPERATING_SYSTEM_MXBEAN_NAME);</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">            if (sunOperatingSystemMXBean == null) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                if (server.isInstanceOf(on,</span>
                        &quot;com.sun.management.OperatingSystemMXBean&quot;)) {
<span class="nc" id="L799">                    sunOperatingSystemMXBean =</span>
<span class="nc" id="L800">                        newPlatformMXBeanProxy(server,</span>
                            OPERATING_SYSTEM_MXBEAN_NAME,
                            com.sun.management.OperatingSystemMXBean.class);
                }
            }
<span class="nc" id="L805">        } catch (InstanceNotFoundException e) {</span>
<span class="nc" id="L806">             return null;</span>
<span class="nc" id="L807">        } catch (MalformedObjectNameException e) {</span>
<span class="nc" id="L808">             return null; // should never reach here</span>
<span class="nc" id="L809">        }</span>
<span class="nc" id="L810">        return sunOperatingSystemMXBean;</span>
    }

    public synchronized HotSpotDiagnosticMXBean getHotSpotDiagnosticMXBean() throws IOException {
<span class="nc bnc" id="L814" title="All 4 branches missed.">        if (hasHotSpotDiagnosticMXBean &amp;&amp; hotspotDiagnosticMXBean == null) {</span>
<span class="nc" id="L815">            hotspotDiagnosticMXBean =</span>
<span class="nc" id="L816">                newPlatformMXBeanProxy(server, HOTSPOT_DIAGNOSTIC_MXBEAN_NAME,</span>
                                       HotSpotDiagnosticMXBean.class);
        }
<span class="nc" id="L819">        return hotspotDiagnosticMXBean;</span>
    }

    public &lt;T&gt; T getMXBean(ObjectName objName, Class&lt;T&gt; interfaceClass)
        throws IOException {
<span class="nc" id="L824">        return newPlatformMXBeanProxy(server,</span>
<span class="nc" id="L825">                                      objName.toString(),</span>
                                      interfaceClass);

    }

    // Return thread IDs of deadlocked threads or null if any.
    // It finds deadlocks involving only monitors if it's a Tiger VM.
    // Otherwise, it finds deadlocks involving both monitors and
    // the concurrent locks.
    public long[] findDeadlockedThreads() throws IOException {
<span class="nc" id="L835">        ThreadMXBean tm = getThreadMXBean();</span>
<span class="nc bnc" id="L836" title="All 4 branches missed.">        if (supportsLockUsage &amp;&amp; tm.isSynchronizerUsageSupported()) {</span>
<span class="nc" id="L837">            return tm.findDeadlockedThreads();</span>
        } else {
<span class="nc" id="L839">            return tm.findMonitorDeadlockedThreads();</span>
        }
    }

    public synchronized void markAsDead() {
<span class="nc" id="L844">        disconnect();</span>
<span class="nc" id="L845">    }</span>

    public boolean isDead() {
<span class="nc" id="L848">        return isDead;</span>
    }

    boolean isConnected() {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        return !isDead();</span>
    }

    boolean hasPlatformMXBeans() {
<span class="nc" id="L856">        return this.hasPlatformMXBeans;</span>
    }

    boolean hasHotSpotDiagnosticMXBean() {
<span class="nc" id="L860">        return this.hasHotSpotDiagnosticMXBean;</span>
    }

    boolean isLockUsageSupported() {
<span class="nc" id="L864">        return supportsLockUsage;</span>
    }

    public boolean isRegistered(ObjectName name) throws IOException {
<span class="nc" id="L868">        return server.isRegistered(name);</span>
    }

    public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc" id="L872">        propertyChangeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L873">    }</span>

    public void addWeakPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (!(listener instanceof WeakPCL)) {</span>
<span class="nc" id="L877">            listener = new WeakPCL(listener);</span>
        }
<span class="nc" id="L879">        propertyChangeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L880">    }</span>

    public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (!(listener instanceof WeakPCL)) {</span>
            // Search for the WeakPCL holding this listener (if any)
<span class="nc bnc" id="L885" title="All 2 branches missed.">            for (PropertyChangeListener pcl : propertyChangeSupport.getPropertyChangeListeners()) {</span>
<span class="nc bnc" id="L886" title="All 4 branches missed.">                if (pcl instanceof WeakPCL &amp;&amp; ((WeakPCL)pcl).get() == listener) {</span>
<span class="nc" id="L887">                    listener = pcl;</span>
<span class="nc" id="L888">                    break;</span>
                }
            }
        }
<span class="nc" id="L892">        propertyChangeSupport.removePropertyChangeListener(listener);</span>
<span class="nc" id="L893">    }</span>

    /**
     * The PropertyChangeListener is handled via a WeakReference
     * so as not to pin down the listener.
     */
    private class WeakPCL extends WeakReference&lt;PropertyChangeListener&gt;
                          implements PropertyChangeListener {
<span class="nc" id="L901">        WeakPCL(PropertyChangeListener referent) {</span>
<span class="nc" id="L902">            super(referent);</span>
<span class="nc" id="L903">        }</span>

        public void propertyChange(PropertyChangeEvent pce) {
<span class="nc" id="L906">            PropertyChangeListener pcl = get();</span>

<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (pcl == null) {</span>
                // The referent listener was GC'ed, we're no longer
                // interested in PropertyChanges, remove the listener.
<span class="nc" id="L911">                dispose();</span>
            } else {
<span class="nc" id="L913">                pcl.propertyChange(pce);</span>
            }
<span class="nc" id="L915">        }</span>

        private void dispose() {
<span class="nc" id="L918">            removePropertyChangeListener(this);</span>
<span class="nc" id="L919">        }</span>
    }

    //
    // Snapshot MBeanServerConnection:
    //
    // This is an object that wraps an existing MBeanServerConnection and adds
    // caching to it, as follows:
    //
    // - The first time an attribute is called in a given MBean, the result is
    //   cached. Every subsequent time getAttribute is called for that attribute
    //   the cached result is returned.
    //
    // - Before every call to VMPanel.update() or when the Refresh button in the
    //   Attributes table is pressed down the attributes cache is flushed. Then
    //   any subsequent call to getAttribute will retrieve all the values for
    //   the attributes that are known to the cache.
    //
    // - The attributes cache uses a learning approach and only the attributes
    //   that are in the cache will be retrieved between two subsequent updates.
    //

    public interface SnapshotMBeanServerConnection
            extends MBeanServerConnection {
        /**
         * Flush all cached values of attributes.
         */
        public void flush();
    }

    public static class Snapshot {
<span class="nc" id="L950">        private Snapshot() {</span>
<span class="nc" id="L951">        }</span>
        public static SnapshotMBeanServerConnection
                newSnapshot(MBeanServerConnection mbsc) {
<span class="nc" id="L954">            final InvocationHandler ih = new SnapshotInvocationHandler(mbsc);</span>
<span class="nc" id="L955">            return (SnapshotMBeanServerConnection) Proxy.newProxyInstance(</span>
<span class="nc" id="L956">                    Snapshot.class.getClassLoader(),</span>
                    new Class[] {SnapshotMBeanServerConnection.class},
                    ih);
        }
    }

    static class SnapshotInvocationHandler implements InvocationHandler {

        private final MBeanServerConnection conn;
<span class="nc" id="L965">        private Map&lt;ObjectName, NameValueMap&gt; cachedValues = newMap();</span>
<span class="nc" id="L966">        private Map&lt;ObjectName, Set&lt;String&gt;&gt; cachedNames = newMap();</span>

        @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L969">        private static final class NameValueMap</span>
                extends HashMap&lt;String, Object&gt; {}

<span class="nc" id="L972">        SnapshotInvocationHandler(MBeanServerConnection conn) {</span>
<span class="nc" id="L973">            this.conn = conn;</span>
<span class="nc" id="L974">        }</span>

        synchronized void flush() {
<span class="nc" id="L977">            cachedValues = newMap();</span>
<span class="nc" id="L978">        }</span>

        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable {
<span class="nc" id="L982">            final String methodName = method.getName();</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            if (methodName.equals(&quot;getAttribute&quot;)) {</span>
<span class="nc" id="L984">                return getAttribute((ObjectName) args[0], (String) args[1]);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">            } else if (methodName.equals(&quot;getAttributes&quot;)) {</span>
<span class="nc" id="L986">                return getAttributes((ObjectName) args[0], (String[]) args[1]);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            } else if (methodName.equals(&quot;flush&quot;)) {</span>
<span class="nc" id="L988">                flush();</span>
<span class="nc" id="L989">                return null;</span>
            } else {
                try {
<span class="nc" id="L992">                    return method.invoke(conn, args);</span>
<span class="nc" id="L993">                } catch (InvocationTargetException e) {</span>
<span class="nc" id="L994">                    throw e.getCause();</span>
                }
            }
        }

        private Object getAttribute(ObjectName objName, String attrName)
                throws MBeanException, InstanceNotFoundException,
                AttributeNotFoundException, ReflectionException, IOException {
<span class="nc" id="L1002">            final NameValueMap values = getCachedAttributes(</span>
<span class="nc" id="L1003">                    objName, Collections.singleton(attrName));</span>
<span class="nc" id="L1004">            Object value = values.get(attrName);</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">            if (value != null || values.containsKey(attrName)) {</span>
<span class="nc" id="L1006">                return value;</span>
            }
            // Not in cache, presumably because it was omitted from the
            // getAttributes result because of an exception.  Following
            // call will probably provoke the same exception.
<span class="nc" id="L1011">            return conn.getAttribute(objName, attrName);</span>
        }

        private AttributeList getAttributes(
                ObjectName objName, String[] attrNames) throws
                InstanceNotFoundException, ReflectionException, IOException {
<span class="nc" id="L1017">            final NameValueMap values = getCachedAttributes(</span>
                    objName,
<span class="nc" id="L1019">                    new TreeSet&lt;String&gt;(Arrays.asList(attrNames)));</span>
<span class="nc" id="L1020">            final AttributeList list = new AttributeList();</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            for (String attrName : attrNames) {</span>
<span class="nc" id="L1022">                final Object value = values.get(attrName);</span>
<span class="nc bnc" id="L1023" title="All 4 branches missed.">                if (value != null || values.containsKey(attrName)) {</span>
<span class="nc" id="L1024">                    list.add(new Attribute(attrName, value));</span>
                }
            }
<span class="nc" id="L1027">            return list;</span>
        }

        private synchronized NameValueMap getCachedAttributes(
                ObjectName objName, Set&lt;String&gt; attrNames) throws
                InstanceNotFoundException, ReflectionException, IOException {
<span class="nc" id="L1033">            NameValueMap values = cachedValues.get(objName);</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">            if (values != null &amp;&amp; values.keySet().containsAll(attrNames)) {</span>
<span class="nc" id="L1035">                return values;</span>
            }
<span class="nc" id="L1037">            attrNames = new TreeSet&lt;String&gt;(attrNames);</span>
<span class="nc" id="L1038">            Set&lt;String&gt; oldNames = cachedNames.get(objName);</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (oldNames != null) {</span>
<span class="nc" id="L1040">                attrNames.addAll(oldNames);</span>
            }
<span class="nc" id="L1042">            values = new NameValueMap();</span>
<span class="nc" id="L1043">            final AttributeList attrs = conn.getAttributes(</span>
                    objName,
<span class="nc" id="L1045">                    attrNames.toArray(new String[attrNames.size()]));</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            for (Attribute attr : attrs.asList()) {</span>
<span class="nc" id="L1047">                values.put(attr.getName(), attr.getValue());</span>
<span class="nc" id="L1048">            }</span>
<span class="nc" id="L1049">            cachedValues.put(objName, values);</span>
<span class="nc" id="L1050">            cachedNames.put(objName, attrNames);</span>
<span class="nc" id="L1051">            return values;</span>
        }

        // See http://www.artima.com/weblogs/viewpost.jsp?thread=79394
        private static &lt;K, V&gt; Map&lt;K, V&gt; newMap() {
<span class="nc" id="L1056">            return new HashMap&lt;K, V&gt;();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>