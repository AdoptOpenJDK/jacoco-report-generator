<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IntHashtable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text</a> &gt; <span class="el_source">IntHashtable.java</span></div><h1>IntHashtable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996,1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996, 1997 - All Rights Reserved
 */

package sun.text;

/** Simple internal class for doing hash mapping. Much, much faster than the
 * standard Hashtable for integer to integer mappings,
 * and doesn't require object creation.&lt;br&gt;
 * If a key is not found, the defaultValue is returned.
 * Note: the keys are limited to values above Integer.MIN_VALUE+1.&lt;br&gt;
 */
public final class IntHashtable {

<span class="nc" id="L41">    public IntHashtable () {</span>
<span class="nc" id="L42">        initialize(3);</span>
<span class="nc" id="L43">    }</span>

<span class="fc" id="L45">    public IntHashtable (int initialSize) {</span>
<span class="fc" id="L46">        initialize(leastGreaterPrimeIndex((int)(initialSize/HIGH_WATER_FACTOR)));</span>
<span class="fc" id="L47">    }</span>

    public int size() {
<span class="nc" id="L50">        return count;</span>
    }

    public boolean isEmpty() {
<span class="nc bnc" id="L54" title="All 2 branches missed.">        return count == 0;</span>
    }

    public void put(int key, int value) {
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (count &gt; highWaterMark) {</span>
<span class="nc" id="L59">            rehash();</span>
        }
<span class="nc" id="L61">        int index = find(key);</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (keyList[index] &lt;= MAX_UNUSED) {      // deleted or empty</span>
<span class="nc" id="L63">            keyList[index] = key;</span>
<span class="nc" id="L64">            ++count;</span>
        }
<span class="nc" id="L66">        values[index] = value;                   // reset value</span>
<span class="nc" id="L67">    }</span>

    public int get(int key) {
<span class="nc" id="L70">        return values[find(key)];</span>
    }

    public void remove(int key) {
<span class="nc" id="L74">        int index = find(key);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">        if (keyList[index] &gt; MAX_UNUSED) {       // neither deleted nor empty</span>
<span class="nc" id="L76">            keyList[index] = DELETED;            // set to deleted</span>
<span class="nc" id="L77">            values[index] = defaultValue;        // set to default</span>
<span class="nc" id="L78">            --count;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (count &lt; lowWaterMark) {</span>
<span class="nc" id="L80">                rehash();</span>
            }
        }
<span class="nc" id="L83">    }</span>

    public int getDefaultValue() {
<span class="nc" id="L86">        return defaultValue;</span>
    }

    public void setDefaultValue(int newValue) {
<span class="nc" id="L90">        defaultValue = newValue;</span>
<span class="nc" id="L91">        rehash();</span>
<span class="nc" id="L92">    }</span>

    public boolean equals (Object that) {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (that.getClass() != this.getClass()) return false;</span>

<span class="nc" id="L97">        IntHashtable other = (IntHashtable) that;</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if (other.size() != count || other.defaultValue != defaultValue) {</span>
<span class="nc" id="L99">                return false;</span>
        }
<span class="nc bnc" id="L101" title="All 2 branches missed.">        for (int i = 0; i &lt; keyList.length; ++i) {</span>
<span class="nc" id="L102">            int key = keyList[i];</span>
<span class="nc bnc" id="L103" title="All 4 branches missed.">            if (key &gt; MAX_UNUSED &amp;&amp; other.get(key) != values[i])</span>
<span class="nc" id="L104">                return false;</span>
        }
<span class="nc" id="L106">        return true;</span>
    }

    public int hashCode() {
        // NOTE:  This function isn't actually used anywhere in this package, but it's here
        // in case this class is ever used to make sure we uphold the invariants about
        // hashCode() and equals()

        // WARNING:  This function hasn't undergone rigorous testing to make sure it actually
        // gives good distribution.  We've eyeballed the results, and they appear okay, but
        // you copy this algorithm (or these seed and multiplier values) at your own risk.
        //                                        --rtg 8/17/99

<span class="nc" id="L119">        int result = 465;   // an arbitrary seed value</span>
<span class="nc" id="L120">        int scrambler = 1362796821; // an arbitrary multiplier.</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (int i = 0; i &lt; keyList.length; ++i) {</span>
            // this line just scrambles the bits as each value is added into the
            // has value.  This helps to make sure we affect all the bits and that
            // the same values in a different order will produce a different hash value
<span class="nc" id="L125">            result = result * scrambler + 1;</span>
<span class="nc" id="L126">            result += keyList[i];</span>
        }
<span class="nc bnc" id="L128" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; ++i) {</span>
<span class="nc" id="L129">            result = result * scrambler + 1;</span>
<span class="nc" id="L130">            result += values[i];</span>
        }
<span class="nc" id="L132">        return result;</span>
    }

    public Object clone ()
                    throws CloneNotSupportedException {
<span class="nc" id="L137">        IntHashtable result = (IntHashtable) super.clone();</span>
<span class="nc" id="L138">        values = values.clone();</span>
<span class="nc" id="L139">        keyList = keyList.clone();</span>
<span class="nc" id="L140">        return result;</span>
    }

    // =======================PRIVATES============================
<span class="pc" id="L144">    private int defaultValue = 0;</span>

    // the tables have to have prime-number lengths. Rather than compute
    // primes, we just keep a table, with the current index we are using.
    private int primeIndex;

    // highWaterFactor determines the maximum number of elements before
    // a rehash. Can be tuned for different performance/storage characteristics.
    private static final float HIGH_WATER_FACTOR = 0.4F;
    private int highWaterMark;

    // lowWaterFactor determines the minimum number of elements before
    // a rehash. Can be tuned for different performance/storage characteristics.
    private static final float LOW_WATER_FACTOR = 0.0F;
    private int lowWaterMark;

    private int count;

    // we use two arrays to minimize allocations
    private int[] values;
    private int[] keyList;

    private static final int EMPTY   = Integer.MIN_VALUE;
    private static final int DELETED = EMPTY + 1;
    private static final int MAX_UNUSED = DELETED;

    private void initialize (int primeIndex) {
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (primeIndex &lt; 0) {</span>
<span class="nc" id="L172">            primeIndex = 0;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        } else if (primeIndex &gt;= PRIMES.length) {</span>
<span class="nc" id="L174">            System.out.println(&quot;TOO BIG&quot;);</span>
<span class="nc" id="L175">            primeIndex = PRIMES.length - 1;</span>
            // throw new java.util.IllegalArgumentError();
        }
<span class="fc" id="L178">        this.primeIndex = primeIndex;</span>
<span class="fc" id="L179">        int initialSize = PRIMES[primeIndex];</span>
<span class="fc" id="L180">        values = new int[initialSize];</span>
<span class="fc" id="L181">        keyList = new int[initialSize];</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (int i = 0; i &lt; initialSize; ++i) {</span>
<span class="fc" id="L183">            keyList[i] = EMPTY;</span>
<span class="fc" id="L184">            values[i] = defaultValue;</span>
        }
<span class="fc" id="L186">        count = 0;</span>
<span class="fc" id="L187">        lowWaterMark = (int)(initialSize * LOW_WATER_FACTOR);</span>
<span class="fc" id="L188">        highWaterMark = (int)(initialSize * HIGH_WATER_FACTOR);</span>
<span class="fc" id="L189">    }</span>

    private void rehash() {
<span class="nc" id="L192">        int[] oldValues = values;</span>
<span class="nc" id="L193">        int[] oldkeyList = keyList;</span>
<span class="nc" id="L194">        int newPrimeIndex = primeIndex;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (count &gt; highWaterMark) {</span>
<span class="nc" id="L196">            ++newPrimeIndex;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        } else if (count &lt; lowWaterMark) {</span>
<span class="nc" id="L198">            newPrimeIndex -= 2;</span>
        }
<span class="nc" id="L200">        initialize(newPrimeIndex);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (int i = oldValues.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L202">            int key = oldkeyList[i];</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (key &gt; MAX_UNUSED) {</span>
<span class="nc" id="L204">                    putInternal(key, oldValues[i]);</span>
            }
        }
<span class="nc" id="L207">    }</span>

    public void putInternal (int key, int value) {
<span class="nc" id="L210">        int index = find(key);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (keyList[index] &lt; MAX_UNUSED) {      // deleted or empty</span>
<span class="nc" id="L212">            keyList[index] = key;</span>
<span class="nc" id="L213">            ++count;</span>
        }
<span class="nc" id="L215">        values[index] = value;                  // reset value</span>
<span class="nc" id="L216">    }</span>

    private int find (int key) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (key &lt;= MAX_UNUSED)</span>
<span class="nc" id="L220">            throw new IllegalArgumentException(&quot;key can't be less than 0xFFFFFFFE&quot;);</span>
<span class="nc" id="L221">        int firstDeleted = -1;  // assume invalid index</span>
<span class="nc" id="L222">        int index = (key ^ 0x4000000) % keyList.length;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (index &lt; 0) index = -index; // positive only</span>
<span class="nc" id="L224">        int jump = 0; // lazy evaluate</span>
        while (true) {
<span class="nc" id="L226">            int tableHash = keyList[index];</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (tableHash == key) {                 // quick check</span>
<span class="nc" id="L228">                return index;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            } else if (tableHash &gt; MAX_UNUSED) {    // neither correct nor unused</span>
                // ignore
<span class="nc bnc" id="L231" title="All 2 branches missed.">            } else if (tableHash == EMPTY) {        // empty, end o' the line</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                if (firstDeleted &gt;= 0) {</span>
<span class="nc" id="L233">                    index = firstDeleted;           // reset if had deleted slot</span>
                }
<span class="nc" id="L235">                return index;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            } else if (firstDeleted &lt; 0) {          // remember first deleted</span>
<span class="nc" id="L237">                    firstDeleted = index;</span>
            }
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (jump == 0) {                        // lazy compute jump</span>
<span class="nc" id="L240">                jump = (key % (keyList.length - 1));</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (jump &lt; 0) jump = -jump;</span>
<span class="nc" id="L242">                ++jump;</span>
            }

<span class="nc" id="L245">            index = (index + jump) % keyList.length;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (index == firstDeleted) {</span>
                // We've searched all entries for the given key.
<span class="nc" id="L248">                return index;</span>
            }
<span class="nc" id="L250">        }</span>
    }

    private static int leastGreaterPrimeIndex(int source) {
        int i;
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        for (i = 0; i &lt; PRIMES.length; ++i) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (source &lt; PRIMES[i]) {</span>
<span class="fc" id="L257">                break;</span>
            }
        }
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        return (i == 0) ? 0 : (i - 1);</span>
    }

    // This list is the result of buildList below. Can be tuned for different
    // performance/storage characteristics.
<span class="fc" id="L265">    private static final int[] PRIMES = {</span>
        17, 37, 67, 131, 257,
        521, 1031, 2053, 4099, 8209, 16411, 32771, 65537,
        131101, 262147, 524309, 1048583, 2097169, 4194319, 8388617, 16777259,
        33554467, 67108879, 134217757, 268435459, 536870923, 1073741827, 2147483647
    };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>