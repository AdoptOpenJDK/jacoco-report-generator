<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CompactByteArray.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.text</a> &gt; <span class="el_source">CompactByteArray.java</span></div><h1>CompactByteArray.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package sun.text;


/**
 * class CompactATypeArray : use only on primitive data types
 * Provides a compact way to store information that is indexed by Unicode
 * values, such as character properties, types, keyboard values, etc.This
 * is very useful when you have a block of Unicode data that contains
 * significant values while the rest of the Unicode data is unused in the
 * application or when you have a lot of redundance, such as where all 21,000
 * Han ideographs have the same value.  However, lookup is much faster than a
 * hash table.
 * A compact array of any primitive data type serves two purposes:
 * &lt;UL type = round&gt;
 *     &lt;LI&gt;Fast access of the indexed values.
 *     &lt;LI&gt;Smaller memory footprint.
 * &lt;/UL&gt;
 * A compact array is composed of a index array and value array.  The index
 * array contains the indicies of Unicode characters to the value array.
 *
 * @see                CompactIntArray
 * @see                CompactShortArray
 * @author             Helena Shih
 */
public final class CompactByteArray implements Cloneable {

    /**
     * The total number of Unicode characters.
     */
    public static  final int UNICODECOUNT =65536;

    /**
     * Constructor for CompactByteArray.
     * @param defaultValue the default value of the compact array.
     */
    public CompactByteArray(byte defaultValue)
<span class="nc" id="L75">    {</span>
        int i;
<span class="nc" id="L77">        values = new byte[UNICODECOUNT];</span>
<span class="nc" id="L78">        indices = new short[INDEXCOUNT];</span>
<span class="nc" id="L79">        hashes = new int[INDEXCOUNT];</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (i = 0; i &lt; UNICODECOUNT; ++i) {</span>
<span class="nc" id="L81">            values[i] = defaultValue;</span>
        }
<span class="nc bnc" id="L83" title="All 2 branches missed.">        for (i = 0; i &lt; INDEXCOUNT; ++i) {</span>
<span class="nc" id="L84">            indices[i] = (short)(i&lt;&lt;BLOCKSHIFT);</span>
<span class="nc" id="L85">            hashes[i] = 0;</span>
        }
<span class="nc" id="L87">        isCompact = false;</span>
<span class="nc" id="L88">    }</span>

    /**
     * Constructor for CompactByteArray.
     * @param indexArray the indicies of the compact array.
     * @param newValues the values of the compact array.
     * @exception IllegalArgumentException If index is out of range.
     */
     public CompactByteArray(short indexArray[],
                            byte newValues[])
<span class="nc" id="L98">    {</span>
        int i;
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (indexArray.length != INDEXCOUNT)</span>
<span class="nc" id="L101">            throw new IllegalArgumentException(&quot;Index out of bounds!&quot;);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        for (i = 0; i &lt; INDEXCOUNT; ++i) {</span>
<span class="nc" id="L103">            short index = indexArray[i];</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">            if ((index &lt; 0) || (index &gt;= newValues.length+BLOCKCOUNT))</span>
<span class="nc" id="L105">                throw new IllegalArgumentException(&quot;Index out of bounds!&quot;);</span>
        }
<span class="nc" id="L107">        indices = indexArray;</span>
<span class="nc" id="L108">        values = newValues;</span>
<span class="nc" id="L109">        isCompact = true;</span>
<span class="nc" id="L110">    }</span>

    /**
     * Get the mapped value of a Unicode character.
     * @param index the character to get the mapped value with
     * @return the mapped value of the given character
     */
    public byte elementAt(char index)
    {
<span class="nc" id="L119">        return (values[(indices[index &gt;&gt; BLOCKSHIFT] &amp; 0xFFFF)</span>
                       + (index &amp; BLOCKMASK)]);
    }
    /**
     * Set a new value for a Unicode character.
     * Set automatically expands the array if it is compacted.
     * @param index the character to set the mapped value with
     * @param value the new mapped value
     */
    public void setElementAt(char index, byte value)
    {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (isCompact)</span>
<span class="nc" id="L131">            expand();</span>
<span class="nc" id="L132">        values[(int)index] = value;</span>
<span class="nc" id="L133">        touchBlock(index &gt;&gt; BLOCKSHIFT, value);</span>
<span class="nc" id="L134">    }</span>

    /**
     * Set new values for a range of Unicode character.
     * @param start the starting offset o of the range
     * @param end the ending offset of the range
     * @param value the new mapped value
     */
    public void setElementAt(char start, char end, byte value)
    {
        int i;
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (isCompact) {</span>
<span class="nc" id="L146">            expand();</span>
        }
<span class="nc bnc" id="L148" title="All 2 branches missed.">        for (i = start; i &lt;= end; ++i) {</span>
<span class="nc" id="L149">            values[i] = value;</span>
<span class="nc" id="L150">            touchBlock(i &gt;&gt; BLOCKSHIFT, value);</span>
        }
<span class="nc" id="L152">    }</span>

    /**
      *Compact the array.
      */
    public void compact()
    {
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (!isCompact) {</span>
<span class="nc" id="L160">            int limitCompacted = 0;</span>
<span class="nc" id="L161">            int iBlockStart = 0;</span>
<span class="nc" id="L162">            short iUntouched = -1;</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">            for (int i = 0; i &lt; indices.length; ++i, iBlockStart += BLOCKCOUNT) {</span>
<span class="nc" id="L165">                indices[i] = -1;</span>
<span class="nc" id="L166">                boolean touched = blockTouched(i);</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">                if (!touched &amp;&amp; iUntouched != -1) {</span>
                    // If no values in this block were set, we can just set its
                    // index to be the same as some other block with no values
                    // set, assuming we've seen one yet.
<span class="nc" id="L171">                    indices[i] = iUntouched;</span>
                } else {
<span class="nc" id="L173">                    int jBlockStart = 0;</span>
<span class="nc" id="L174">                    int j = 0;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    for (j = 0; j &lt; limitCompacted;</span>
<span class="nc" id="L176">                            ++j, jBlockStart += BLOCKCOUNT) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if (hashes[i] == hashes[j] &amp;&amp;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                                arrayRegionMatches(values, iBlockStart,</span>
                                values, jBlockStart, BLOCKCOUNT)) {
<span class="nc" id="L180">                            indices[i] = (short)jBlockStart;</span>
<span class="nc" id="L181">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L184" title="All 2 branches missed.">                    if (indices[i] == -1) {</span>
                        // we didn't match, so copy &amp; update
<span class="nc" id="L186">                        System.arraycopy(values, iBlockStart,</span>
                            values, jBlockStart, BLOCKCOUNT);
<span class="nc" id="L188">                        indices[i] = (short)jBlockStart;</span>
<span class="nc" id="L189">                        hashes[j] = hashes[i];</span>
<span class="nc" id="L190">                        ++limitCompacted;</span>

<span class="nc bnc" id="L192" title="All 2 branches missed.">                        if (!touched) {</span>
                            // If this is the first untouched block we've seen,
                            // remember its index.
<span class="nc" id="L195">                            iUntouched = (short)jBlockStart;</span>
                        }
                    }
                }
            }
            // we are done compacting, so now make the array shorter
<span class="nc" id="L201">            int newSize = limitCompacted*BLOCKCOUNT;</span>
<span class="nc" id="L202">            byte[] result = new byte[newSize];</span>
<span class="nc" id="L203">            System.arraycopy(values, 0, result, 0, newSize);</span>
<span class="nc" id="L204">            values = result;</span>
<span class="nc" id="L205">            isCompact = true;</span>
<span class="nc" id="L206">            hashes = null;</span>
        }
<span class="nc" id="L208">    }</span>

    /**
     * Convenience utility to compare two arrays of doubles.
     * @param len the length to compare.
     * The start indices and start+len must be valid.
     */
    final static boolean arrayRegionMatches(byte[] source, int sourceStart,
                                            byte[] target, int targetStart,
                                            int len)
    {
<span class="nc" id="L219">        int sourceEnd = sourceStart + len;</span>
<span class="nc" id="L220">        int delta = targetStart - sourceStart;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (int i = sourceStart; i &lt; sourceEnd; i++) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (source[i] != target[i + delta])</span>
<span class="nc" id="L223">            return false;</span>
        }
<span class="nc" id="L225">        return true;</span>
    }

    /**
     * Remember that a specified block was &quot;touched&quot;, i.e. had a value set.
     * Untouched blocks can be skipped when compacting the array
     */
    private final void touchBlock(int i, int value) {
<span class="nc" id="L233">        hashes[i] = (hashes[i] + (value&lt;&lt;1)) | 1;</span>
<span class="nc" id="L234">    }</span>

    /**
     * Query whether a specified block was &quot;touched&quot;, i.e. had a value set.
     * Untouched blocks can be skipped when compacting the array
     */
    private final boolean blockTouched(int i) {
<span class="nc bnc" id="L241" title="All 2 branches missed.">        return hashes[i] != 0;</span>
    }

    /** For internal use only.  Do not modify the result, the behavior of
      * modified results are undefined.
      */
    public short getIndexArray()[]
    {
<span class="nc" id="L249">        return indices;</span>
    }

    /** For internal use only.  Do not modify the result, the behavior of
      * modified results are undefined.
      */
    public byte getStringArray()[]
    {
<span class="nc" id="L257">        return values;</span>
    }

    /**
     * Overrides Cloneable
     */
    public Object clone()
    {
        try {
<span class="nc" id="L266">            CompactByteArray other = (CompactByteArray) super.clone();</span>
<span class="nc" id="L267">            other.values = values.clone();</span>
<span class="nc" id="L268">            other.indices = indices.clone();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (hashes != null) other.hashes = hashes.clone();</span>
<span class="nc" id="L270">            return other;</span>
<span class="nc" id="L271">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L272">            throw new InternalError(e);</span>
        }
    }

    /**
     * Compares the equality of two compact array objects.
     * @param obj the compact array object to be compared with this.
     * @return true if the current compact array object is the same
     * as the compact array object obj; false otherwise.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (obj == null) return false;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (this == obj)                      // quick check</span>
<span class="nc" id="L285">            return true;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (getClass() != obj.getClass())         // same class?</span>
<span class="nc" id="L287">            return false;</span>
<span class="nc" id="L288">        CompactByteArray other = (CompactByteArray) obj;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (int i = 0; i &lt; UNICODECOUNT; i++) {</span>
            // could be sped up later
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (elementAt((char)i) != other.elementAt((char)i))</span>
<span class="nc" id="L292">                return false;</span>
        }
<span class="nc" id="L294">        return true; // we made it through the guantlet.</span>
    }

    /**
     * Generates the hash code for the compact array object
     */

    public int hashCode() {
<span class="nc" id="L302">        int result = 0;</span>
<span class="nc" id="L303">        int increment = Math.min(3, values.length/16);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; i+= increment) {</span>
<span class="nc" id="L305">            result = result * 37 + values[i];</span>
        }
<span class="nc" id="L307">        return result;</span>
    }

    // --------------------------------------------------------------
    // package private
    // --------------------------------------------------------------
    /**
      * Expanding takes the array back to a 65536 element array.
      */
    private void expand()
    {
        int i;
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (isCompact) {</span>
            byte[]  tempArray;
<span class="nc" id="L321">            hashes = new int[INDEXCOUNT];</span>
<span class="nc" id="L322">            tempArray = new byte[UNICODECOUNT];</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            for (i = 0; i &lt; UNICODECOUNT; ++i) {</span>
<span class="nc" id="L324">                byte value = elementAt((char)i);</span>
<span class="nc" id="L325">                tempArray[i] = value;</span>
<span class="nc" id="L326">                touchBlock(i &gt;&gt; BLOCKSHIFT, value);</span>
            }
<span class="nc bnc" id="L328" title="All 2 branches missed.">            for (i = 0; i &lt; INDEXCOUNT; ++i) {</span>
<span class="nc" id="L329">                indices[i] = (short)(i&lt;&lt;BLOCKSHIFT);</span>
            }
<span class="nc" id="L331">            values = null;</span>
<span class="nc" id="L332">            values = tempArray;</span>
<span class="nc" id="L333">            isCompact = false;</span>
        }
<span class="nc" id="L335">    }</span>

    private byte[] getArray()
    {
<span class="nc" id="L339">        return values;</span>
    }

    private static  final int BLOCKSHIFT =7;
    private static  final int BLOCKCOUNT =(1&lt;&lt;BLOCKSHIFT);
    private static  final int INDEXSHIFT =(16-BLOCKSHIFT);
    private static  final int INDEXCOUNT =(1&lt;&lt;INDEXSHIFT);
    private static  final int BLOCKMASK = BLOCKCOUNT - 1;

    private byte[] values;  // char -&gt; short (char parameterized short)
    private short indices[];
    private boolean isCompact;
    private int[] hashes;
};
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>