<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MethodNode.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.tree</a> &gt; <span class="el_source">MethodNode.java</span></div><h1>MethodNode.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.tree;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import jdk.internal.org.objectweb.asm.AnnotationVisitor;
import jdk.internal.org.objectweb.asm.Attribute;
import jdk.internal.org.objectweb.asm.ClassVisitor;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.TypePath;

/**
 * A node that represents a method.
 *
 * @author Eric Bruneton
 */
public class MethodNode extends MethodVisitor {

    /**
     * The method's access flags (see {@link Opcodes}). This field also
     * indicates if the method is synthetic and/or deprecated.
     */
    public int access;

    /**
     * The method's name.
     */
    public String name;

    /**
     * The method's descriptor (see {@link Type}).
     */
    public String desc;

    /**
     * The method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    public String signature;

    /**
     * The internal names of the method's exception classes (see
     * {@link Type#getInternalName() getInternalName}). This list is a list of
     * {@link String} objects.
     */
    public List&lt;String&gt; exceptions;

    /**
     * The method parameter info (access flags and name)
     */
    public List&lt;ParameterNode&gt; parameters;

    /**
     * The runtime visible annotations of this method. This list is a list of
     * {@link AnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.AnnotationNode
     * @label visible
     */
    public List&lt;AnnotationNode&gt; visibleAnnotations;

    /**
     * The runtime invisible annotations of this method. This list is a list of
     * {@link AnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.AnnotationNode
     * @label invisible
     */
    public List&lt;AnnotationNode&gt; invisibleAnnotations;

    /**
     * The runtime visible type annotations of this method. This list is a list
     * of {@link TypeAnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode
     * @label visible
     */
    public List&lt;TypeAnnotationNode&gt; visibleTypeAnnotations;

    /**
     * The runtime invisible type annotations of this method. This list is a
     * list of {@link TypeAnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.TypeAnnotationNode
     * @label invisible
     */
    public List&lt;TypeAnnotationNode&gt; invisibleTypeAnnotations;

    /**
     * The non standard attributes of this method. This list is a list of
     * {@link Attribute} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.Attribute
     */
    public List&lt;Attribute&gt; attrs;

    /**
     * The default value of this annotation interface method. This field must be
     * a {@link Byte}, {@link Boolean}, {@link Character}, {@link Short},
     * {@link Integer}, {@link Long}, {@link Float}, {@link Double},
     * {@link String} or {@link Type}, or an two elements String array (for
     * enumeration values), a {@link AnnotationNode}, or a {@link List} of
     * values of one of the preceding types. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    public Object annotationDefault;

    /**
     * The runtime visible parameter annotations of this method. These lists are
     * lists of {@link AnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.AnnotationNode
     * @label invisible parameters
     */
    public List&lt;AnnotationNode&gt;[] visibleParameterAnnotations;

    /**
     * The runtime invisible parameter annotations of this method. These lists
     * are lists of {@link AnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.AnnotationNode
     * @label visible parameters
     */
    public List&lt;AnnotationNode&gt;[] invisibleParameterAnnotations;

    /**
     * The instructions of this method. This list is a list of
     * {@link AbstractInsnNode} objects.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.AbstractInsnNode
     * @label instructions
     */
    public InsnList instructions;

    /**
     * The try catch blocks of this method. This list is a list of
     * {@link TryCatchBlockNode} objects.
     *
     * @associates jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode
     */
    public List&lt;TryCatchBlockNode&gt; tryCatchBlocks;

    /**
     * The maximum stack size of this method.
     */
    public int maxStack;

    /**
     * The maximum number of local variables of this method.
     */
    public int maxLocals;

    /**
     * The local variables of this method. This list is a list of
     * {@link LocalVariableNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;
     *
     * @associates jdk.internal.org.objectweb.asm.tree.LocalVariableNode
     */
    public List&lt;LocalVariableNode&gt; localVariables;

    /**
     * The visible local variable annotations of this method. This list is a
     * list of {@link LocalVariableAnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;
     *
     * @associates jdk.internal.org.objectweb.asm.tree.LocalVariableAnnotationNode
     */
    public List&lt;LocalVariableAnnotationNode&gt; visibleLocalVariableAnnotations;

    /**
     * The invisible local variable annotations of this method. This list is a
     * list of {@link LocalVariableAnnotationNode} objects. May be &lt;tt&gt;null&lt;/tt&gt;
     *
     * @associates jdk.internal.org.objectweb.asm.tree.LocalVariableAnnotationNode
     */
    public List&lt;LocalVariableAnnotationNode&gt; invisibleLocalVariableAnnotations;

    /**
     * If the accept method has been called on this object.
     */
    private boolean visited;

    /**
     * Constructs an uninitialized {@link MethodNode}. &lt;i&gt;Subclasses must not
     * use this constructor&lt;/i&gt;. Instead, they must use the
     * {@link #MethodNode(int)} version.
     *
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public MethodNode() {
<span class="nc" id="L252">        this(Opcodes.ASM5);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (getClass() != MethodNode.class) {</span>
<span class="nc" id="L254">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L256">    }</span>

    /**
     * Constructs an uninitialized {@link MethodNode}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     */
    public MethodNode(final int api) {
<span class="nc" id="L266">        super(api);</span>
<span class="nc" id="L267">        this.instructions = new InsnList();</span>
<span class="nc" id="L268">    }</span>

    /**
     * Constructs a new {@link MethodNode}. &lt;i&gt;Subclasses must not use this
     * constructor&lt;/i&gt;. Instead, they must use the
     * {@link #MethodNode(int, int, String, String, String, String[])} version.
     *
     * @param access
     *            the method's access flags (see {@link Opcodes}). This
     *            parameter also indicates if the method is synthetic and/or
     *            deprecated.
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type}).
     * @param signature
     *            the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions
     *            the internal names of the method's exception classes (see
     *            {@link Type#getInternalName() getInternalName}). May be
     *            &lt;tt&gt;null&lt;/tt&gt;.
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public MethodNode(final int access, final String name, final String desc,
            final String signature, final String[] exceptions) {
<span class="nc" id="L294">        this(Opcodes.ASM5, access, name, desc, signature, exceptions);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (getClass() != MethodNode.class) {</span>
<span class="nc" id="L296">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L298">    }</span>

    /**
     * Constructs a new {@link MethodNode}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param access
     *            the method's access flags (see {@link Opcodes}). This
     *            parameter also indicates if the method is synthetic and/or
     *            deprecated.
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type}).
     * @param signature
     *            the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions
     *            the internal names of the method's exception classes (see
     *            {@link Type#getInternalName() getInternalName}). May be
     *            &lt;tt&gt;null&lt;/tt&gt;.
     */
    public MethodNode(final int api, final int access, final String name,
            final String desc, final String signature, final String[] exceptions) {
<span class="nc" id="L323">        super(api);</span>
<span class="nc" id="L324">        this.access = access;</span>
<span class="nc" id="L325">        this.name = name;</span>
<span class="nc" id="L326">        this.desc = desc;</span>
<span class="nc" id="L327">        this.signature = signature;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        this.exceptions = new ArrayList&lt;String&gt;(exceptions == null ? 0</span>
                : exceptions.length);
<span class="nc bnc" id="L330" title="All 2 branches missed.">        boolean isAbstract = (access &amp; Opcodes.ACC_ABSTRACT) != 0;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (!isAbstract) {</span>
<span class="nc" id="L332">            this.localVariables = new ArrayList&lt;LocalVariableNode&gt;(5);</span>
        }
<span class="nc" id="L334">        this.tryCatchBlocks = new ArrayList&lt;TryCatchBlockNode&gt;();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (exceptions != null) {</span>
<span class="nc" id="L336">            this.exceptions.addAll(Arrays.asList(exceptions));</span>
        }
<span class="nc" id="L338">        this.instructions = new InsnList();</span>
<span class="nc" id="L339">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the MethodVisitor abstract class
    // ------------------------------------------------------------------------

    @Override
    public void visitParameter(String name, int access) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (parameters == null) {</span>
<span class="nc" id="L348">            parameters = new ArrayList&lt;ParameterNode&gt;(5);</span>
        }
<span class="nc" id="L350">        parameters.add(new ParameterNode(name, access));</span>
<span class="nc" id="L351">    }</span>

    @Override
    public AnnotationVisitor visitAnnotationDefault() {
<span class="nc" id="L355">        return new AnnotationNode(new ArrayList&lt;Object&gt;(0) {</span>
            @Override
            public boolean add(final Object o) {
<span class="nc" id="L358">                annotationDefault = o;</span>
<span class="nc" id="L359">                return super.add(o);</span>
            }
        });
    }

    @Override
    public AnnotationVisitor visitAnnotation(final String desc,
            final boolean visible) {
<span class="nc" id="L367">        AnnotationNode an = new AnnotationNode(desc);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (visibleAnnotations == null) {</span>
<span class="nc" id="L370">                visibleAnnotations = new ArrayList&lt;AnnotationNode&gt;(1);</span>
            }
<span class="nc" id="L372">            visibleAnnotations.add(an);</span>
        } else {
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (invisibleAnnotations == null) {</span>
<span class="nc" id="L375">                invisibleAnnotations = new ArrayList&lt;AnnotationNode&gt;(1);</span>
            }
<span class="nc" id="L377">            invisibleAnnotations.add(an);</span>
        }
<span class="nc" id="L379">        return an;</span>
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(int typeRef,
            TypePath typePath, String desc, boolean visible) {
<span class="nc" id="L385">        TypeAnnotationNode an = new TypeAnnotationNode(typeRef, typePath, desc);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (visibleTypeAnnotations == null) {</span>
<span class="nc" id="L388">                visibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(1);</span>
            }
<span class="nc" id="L390">            visibleTypeAnnotations.add(an);</span>
        } else {
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (invisibleTypeAnnotations == null) {</span>
<span class="nc" id="L393">                invisibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(1);</span>
            }
<span class="nc" id="L395">            invisibleTypeAnnotations.add(an);</span>
        }
<span class="nc" id="L397">        return an;</span>
    }

    @Override
    public AnnotationVisitor visitParameterAnnotation(final int parameter,
            final String desc, final boolean visible) {
<span class="nc" id="L403">        AnnotationNode an = new AnnotationNode(desc);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (visibleParameterAnnotations == null) {</span>
<span class="nc" id="L406">                int params = Type.getArgumentTypes(this.desc).length;</span>
<span class="nc" id="L407">                visibleParameterAnnotations = (List&lt;AnnotationNode&gt;[]) new List&lt;?&gt;[params];</span>
            }
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (visibleParameterAnnotations[parameter] == null) {</span>
<span class="nc" id="L410">                visibleParameterAnnotations[parameter] = new ArrayList&lt;AnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L413">            visibleParameterAnnotations[parameter].add(an);</span>
        } else {
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (invisibleParameterAnnotations == null) {</span>
<span class="nc" id="L416">                int params = Type.getArgumentTypes(this.desc).length;</span>
<span class="nc" id="L417">                invisibleParameterAnnotations = (List&lt;AnnotationNode&gt;[]) new List&lt;?&gt;[params];</span>
            }
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (invisibleParameterAnnotations[parameter] == null) {</span>
<span class="nc" id="L420">                invisibleParameterAnnotations[parameter] = new ArrayList&lt;AnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L423">            invisibleParameterAnnotations[parameter].add(an);</span>
        }
<span class="nc" id="L425">        return an;</span>
    }

    @Override
    public void visitAttribute(final Attribute attr) {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (attrs == null) {</span>
<span class="nc" id="L431">            attrs = new ArrayList&lt;Attribute&gt;(1);</span>
        }
<span class="nc" id="L433">        attrs.add(attr);</span>
<span class="nc" id="L434">    }</span>

    @Override
    public void visitCode() {
<span class="nc" id="L438">    }</span>

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
<span class="nc bnc" id="L443" title="All 2 branches missed.">        instructions.add(new FrameNode(type, nLocal, local == null ? null</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                : getLabelNodes(local), nStack, stack == null ? null</span>
<span class="nc" id="L445">                : getLabelNodes(stack)));</span>
<span class="nc" id="L446">    }</span>

    @Override
    public void visitInsn(final int opcode) {
<span class="nc" id="L450">        instructions.add(new InsnNode(opcode));</span>
<span class="nc" id="L451">    }</span>

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
<span class="nc" id="L455">        instructions.add(new IntInsnNode(opcode, operand));</span>
<span class="nc" id="L456">    }</span>

    @Override
    public void visitVarInsn(final int opcode, final int var) {
<span class="nc" id="L460">        instructions.add(new VarInsnNode(opcode, var));</span>
<span class="nc" id="L461">    }</span>

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
<span class="nc" id="L465">        instructions.add(new TypeInsnNode(opcode, type));</span>
<span class="nc" id="L466">    }</span>

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc" id="L471">        instructions.add(new FieldInsnNode(opcode, owner, name, desc));</span>
<span class="nc" id="L472">    }</span>

    @Deprecated
    @Override
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc) {
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (api &gt;= Opcodes.ASM5) {</span>
<span class="nc" id="L479">            super.visitMethodInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L480">            return;</span>
        }
<span class="nc" id="L482">        instructions.add(new MethodInsnNode(opcode, owner, name, desc));</span>
<span class="nc" id="L483">    }</span>

    @Override
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc, boolean itf) {
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L489">            super.visitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L490">            return;</span>
        }
<span class="nc" id="L492">        instructions.add(new MethodInsnNode(opcode, owner, name, desc, itf));</span>
<span class="nc" id="L493">    }</span>

    @Override
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
            Object... bsmArgs) {
<span class="nc" id="L498">        instructions.add(new InvokeDynamicInsnNode(name, desc, bsm, bsmArgs));</span>
<span class="nc" id="L499">    }</span>

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
<span class="nc" id="L503">        instructions.add(new JumpInsnNode(opcode, getLabelNode(label)));</span>
<span class="nc" id="L504">    }</span>

    @Override
    public void visitLabel(final Label label) {
<span class="nc" id="L508">        instructions.add(getLabelNode(label));</span>
<span class="nc" id="L509">    }</span>

    @Override
    public void visitLdcInsn(final Object cst) {
<span class="nc" id="L513">        instructions.add(new LdcInsnNode(cst));</span>
<span class="nc" id="L514">    }</span>

    @Override
    public void visitIincInsn(final int var, final int increment) {
<span class="nc" id="L518">        instructions.add(new IincInsnNode(var, increment));</span>
<span class="nc" id="L519">    }</span>

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels) {
<span class="nc" id="L524">        instructions.add(new TableSwitchInsnNode(min, max, getLabelNode(dflt),</span>
<span class="nc" id="L525">                getLabelNodes(labels)));</span>
<span class="nc" id="L526">    }</span>

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
            final Label[] labels) {
<span class="nc" id="L531">        instructions.add(new LookupSwitchInsnNode(getLabelNode(dflt), keys,</span>
<span class="nc" id="L532">                getLabelNodes(labels)));</span>
<span class="nc" id="L533">    }</span>

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L537">        instructions.add(new MultiANewArrayInsnNode(desc, dims));</span>
<span class="nc" id="L538">    }</span>

    @Override
    public AnnotationVisitor visitInsnAnnotation(int typeRef,
            TypePath typePath, String desc, boolean visible) {
        // Finds the last real instruction, i.e. the instruction targeted by
        // this annotation.
<span class="nc" id="L545">        AbstractInsnNode insn = instructions.getLast();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        while (insn.getOpcode() == -1) {</span>
<span class="nc" id="L547">            insn = insn.getPrevious();</span>
        }
        // Adds the annotation to this instruction.
<span class="nc" id="L550">        TypeAnnotationNode an = new TypeAnnotationNode(typeRef, typePath, desc);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (insn.visibleTypeAnnotations == null) {</span>
<span class="nc" id="L553">                insn.visibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L556">            insn.visibleTypeAnnotations.add(an);</span>
        } else {
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (insn.invisibleTypeAnnotations == null) {</span>
<span class="nc" id="L559">                insn.invisibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L562">            insn.invisibleTypeAnnotations.add(an);</span>
        }
<span class="nc" id="L564">        return an;</span>
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end,
            final Label handler, final String type) {
<span class="nc" id="L570">        tryCatchBlocks.add(new TryCatchBlockNode(getLabelNode(start),</span>
<span class="nc" id="L571">                getLabelNode(end), getLabelNode(handler), type));</span>
<span class="nc" id="L572">    }</span>

    @Override
    public AnnotationVisitor visitTryCatchAnnotation(int typeRef,
            TypePath typePath, String desc, boolean visible) {
<span class="nc" id="L577">        TryCatchBlockNode tcb = tryCatchBlocks.get((typeRef &amp; 0x00FFFF00) &gt;&gt; 8);</span>
<span class="nc" id="L578">        TypeAnnotationNode an = new TypeAnnotationNode(typeRef, typePath, desc);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            if (tcb.visibleTypeAnnotations == null) {</span>
<span class="nc" id="L581">                tcb.visibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L584">            tcb.visibleTypeAnnotations.add(an);</span>
        } else {
<span class="nc bnc" id="L586" title="All 2 branches missed.">            if (tcb.invisibleTypeAnnotations == null) {</span>
<span class="nc" id="L587">                tcb.invisibleTypeAnnotations = new ArrayList&lt;TypeAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L590">            tcb.invisibleTypeAnnotations.add(an);</span>
        }
<span class="nc" id="L592">        return an;</span>
    }

    @Override
    public void visitLocalVariable(final String name, final String desc,
            final String signature, final Label start, final Label end,
            final int index) {
<span class="nc" id="L599">        localVariables.add(new LocalVariableNode(name, desc, signature,</span>
<span class="nc" id="L600">                getLabelNode(start), getLabelNode(end), index));</span>
<span class="nc" id="L601">    }</span>

    @Override
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
            TypePath typePath, Label[] start, Label[] end, int[] index,
            String desc, boolean visible) {
<span class="nc" id="L607">        LocalVariableAnnotationNode an = new LocalVariableAnnotationNode(</span>
<span class="nc" id="L608">                typeRef, typePath, getLabelNodes(start), getLabelNodes(end),</span>
                index, desc);
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (visibleLocalVariableAnnotations == null) {</span>
<span class="nc" id="L612">                visibleLocalVariableAnnotations = new ArrayList&lt;LocalVariableAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L615">            visibleLocalVariableAnnotations.add(an);</span>
        } else {
<span class="nc bnc" id="L617" title="All 2 branches missed.">            if (invisibleLocalVariableAnnotations == null) {</span>
<span class="nc" id="L618">                invisibleLocalVariableAnnotations = new ArrayList&lt;LocalVariableAnnotationNode&gt;(</span>
                        1);
            }
<span class="nc" id="L621">            invisibleLocalVariableAnnotations.add(an);</span>
        }
<span class="nc" id="L623">        return an;</span>
    }

    @Override
    public void visitLineNumber(final int line, final Label start) {
<span class="nc" id="L628">        instructions.add(new LineNumberNode(line, getLabelNode(start)));</span>
<span class="nc" id="L629">    }</span>

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="nc" id="L633">        this.maxStack = maxStack;</span>
<span class="nc" id="L634">        this.maxLocals = maxLocals;</span>
<span class="nc" id="L635">    }</span>

    @Override
    public void visitEnd() {
<span class="nc" id="L639">    }</span>

    /**
     * Returns the LabelNode corresponding to the given Label. Creates a new
     * LabelNode if necessary. The default implementation of this method uses
     * the {@link Label#info} field to store associations between labels and
     * label nodes.
     *
     * @param l
     *            a Label.
     * @return the LabelNode corresponding to l.
     */
    protected LabelNode getLabelNode(final Label l) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (!(l.info instanceof LabelNode)) {</span>
<span class="nc" id="L653">            l.info = new LabelNode();</span>
        }
<span class="nc" id="L655">        return (LabelNode) l.info;</span>
    }

    private LabelNode[] getLabelNodes(final Label[] l) {
<span class="nc" id="L659">        LabelNode[] nodes = new LabelNode[l.length];</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">        for (int i = 0; i &lt; l.length; ++i) {</span>
<span class="nc" id="L661">            nodes[i] = getLabelNode(l[i]);</span>
        }
<span class="nc" id="L663">        return nodes;</span>
    }

    private Object[] getLabelNodes(final Object[] objs) {
<span class="nc" id="L667">        Object[] nodes = new Object[objs.length];</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">        for (int i = 0; i &lt; objs.length; ++i) {</span>
<span class="nc" id="L669">            Object o = objs[i];</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (o instanceof Label) {</span>
<span class="nc" id="L671">                o = getLabelNode((Label) o);</span>
            }
<span class="nc" id="L673">            nodes[i] = o;</span>
        }
<span class="nc" id="L675">        return nodes;</span>
    }

    // ------------------------------------------------------------------------
    // Accept method
    // ------------------------------------------------------------------------

    /**
     * Checks that this method node is compatible with the given ASM API
     * version. This methods checks that this node, and all its nodes
     * recursively, do not contain elements that were introduced in more recent
     * versions of the ASM API than the given version.
     *
     * @param api
     *            an ASM API version. Must be one of {@link Opcodes#ASM4} or
     *            {@link Opcodes#ASM5}.
     */
    public void check(final int api) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (api == Opcodes.ASM4) {</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if (visibleTypeAnnotations != null</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    &amp;&amp; visibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L696">                throw new RuntimeException();</span>
            }
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (invisibleTypeAnnotations != null</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                    &amp;&amp; invisibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L700">                throw new RuntimeException();</span>
            }
<span class="nc bnc" id="L702" title="All 2 branches missed.">            int n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L704">                TryCatchBlockNode tcb = tryCatchBlocks.get(i);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                if (tcb.visibleTypeAnnotations != null</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                        &amp;&amp; tcb.visibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L707">                    throw new RuntimeException();</span>
                }
<span class="nc bnc" id="L709" title="All 2 branches missed.">                if (tcb.invisibleTypeAnnotations != null</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                        &amp;&amp; tcb.invisibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L711">                    throw new RuntimeException();</span>
                }
            }
<span class="nc bnc" id="L714" title="All 2 branches missed.">            for (int i = 0; i &lt; instructions.size(); ++i) {</span>
<span class="nc" id="L715">                AbstractInsnNode insn = instructions.get(i);</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (insn.visibleTypeAnnotations != null</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                        &amp;&amp; insn.visibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L718">                    throw new RuntimeException();</span>
                }
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (insn.invisibleTypeAnnotations != null</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                        &amp;&amp; insn.invisibleTypeAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L722">                    throw new RuntimeException();</span>
                }
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (insn instanceof MethodInsnNode) {</span>
<span class="nc" id="L725">                    boolean itf = ((MethodInsnNode) insn).itf;</span>
<span class="nc bnc" id="L726" title="All 4 branches missed.">                    if (itf != (insn.opcode == Opcodes.INVOKEINTERFACE)) {</span>
<span class="nc" id="L727">                        throw new RuntimeException();</span>
                    }
                }
            }
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (visibleLocalVariableAnnotations != null</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                    &amp;&amp; visibleLocalVariableAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L733">                throw new RuntimeException();</span>
            }
<span class="nc bnc" id="L735" title="All 2 branches missed.">            if (invisibleLocalVariableAnnotations != null</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">                    &amp;&amp; invisibleLocalVariableAnnotations.size() &gt; 0) {</span>
<span class="nc" id="L737">                throw new RuntimeException();</span>
            }
        }
<span class="nc" id="L740">    }</span>

    /**
     * Makes the given class visitor visit this method.
     *
     * @param cv
     *            a class visitor.
     */
    public void accept(final ClassVisitor cv) {
<span class="nc" id="L749">        String[] exceptions = new String[this.exceptions.size()];</span>
<span class="nc" id="L750">        this.exceptions.toArray(exceptions);</span>
<span class="nc" id="L751">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,</span>
                exceptions);
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L754">            accept(mv);</span>
        }
<span class="nc" id="L756">    }</span>

    /**
     * Makes the given method visitor visit this method.
     *
     * @param mv
     *            a method visitor.
     */
    public void accept(final MethodVisitor mv) {
        // visits the method parameters
        int i, j, n;
<span class="nc bnc" id="L767" title="All 2 branches missed.">        n = parameters == null ? 0 : parameters.size();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L769">            ParameterNode parameter = parameters.get(i);</span>
<span class="nc" id="L770">            mv.visitParameter(parameter.name, parameter.access);</span>
        }
        // visits the method attributes
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (annotationDefault != null) {</span>
<span class="nc" id="L774">            AnnotationVisitor av = mv.visitAnnotationDefault();</span>
<span class="nc" id="L775">            AnnotationNode.accept(av, null, annotationDefault);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (av != null) {</span>
<span class="nc" id="L777">                av.visitEnd();</span>
            }
        }
<span class="nc bnc" id="L780" title="All 2 branches missed.">        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L782">            AnnotationNode an = visibleAnnotations.get(i);</span>
<span class="nc" id="L783">            an.accept(mv.visitAnnotation(an.desc, true));</span>
        }
<span class="nc bnc" id="L785" title="All 2 branches missed.">        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L787">            AnnotationNode an = invisibleAnnotations.get(i);</span>
<span class="nc" id="L788">            an.accept(mv.visitAnnotation(an.desc, false));</span>
        }
<span class="nc bnc" id="L790" title="All 2 branches missed.">        n = visibleTypeAnnotations == null ? 0 : visibleTypeAnnotations.size();</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L792">            TypeAnnotationNode an = visibleTypeAnnotations.get(i);</span>
<span class="nc" id="L793">            an.accept(mv.visitTypeAnnotation(an.typeRef, an.typePath, an.desc,</span>
                    true));
        }
<span class="nc bnc" id="L796" title="All 2 branches missed.">        n = invisibleTypeAnnotations == null ? 0 : invisibleTypeAnnotations</span>
<span class="nc" id="L797">                .size();</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L799">            TypeAnnotationNode an = invisibleTypeAnnotations.get(i);</span>
<span class="nc" id="L800">            an.accept(mv.visitTypeAnnotation(an.typeRef, an.typePath, an.desc,</span>
                    false));
        }
<span class="nc bnc" id="L803" title="All 2 branches missed.">        n = visibleParameterAnnotations == null ? 0</span>
                : visibleParameterAnnotations.length;
<span class="nc bnc" id="L805" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L806">            List&lt;?&gt; l = visibleParameterAnnotations[i];</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (l == null) {</span>
<span class="nc" id="L808">                continue;</span>
            }
<span class="nc bnc" id="L810" title="All 2 branches missed.">            for (j = 0; j &lt; l.size(); ++j) {</span>
<span class="nc" id="L811">                AnnotationNode an = (AnnotationNode) l.get(j);</span>
<span class="nc" id="L812">                an.accept(mv.visitParameterAnnotation(i, an.desc, true));</span>
            }
        }
<span class="nc bnc" id="L815" title="All 2 branches missed.">        n = invisibleParameterAnnotations == null ? 0</span>
                : invisibleParameterAnnotations.length;
<span class="nc bnc" id="L817" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L818">            List&lt;?&gt; l = invisibleParameterAnnotations[i];</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (l == null) {</span>
<span class="nc" id="L820">                continue;</span>
            }
<span class="nc bnc" id="L822" title="All 2 branches missed.">            for (j = 0; j &lt; l.size(); ++j) {</span>
<span class="nc" id="L823">                AnnotationNode an = (AnnotationNode) l.get(j);</span>
<span class="nc" id="L824">                an.accept(mv.visitParameterAnnotation(i, an.desc, false));</span>
            }
        }
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (visited) {</span>
<span class="nc" id="L828">            instructions.resetLabels();</span>
        }
<span class="nc bnc" id="L830" title="All 2 branches missed.">        n = attrs == null ? 0 : attrs.size();</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L832">            mv.visitAttribute(attrs.get(i));</span>
        }
        // visits the method's code
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (instructions.size() &gt; 0) {</span>
<span class="nc" id="L836">            mv.visitCode();</span>
            // visits try catch blocks
<span class="nc bnc" id="L838" title="All 2 branches missed.">            n = tryCatchBlocks == null ? 0 : tryCatchBlocks.size();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L840">                tryCatchBlocks.get(i).updateIndex(i);</span>
<span class="nc" id="L841">                tryCatchBlocks.get(i).accept(mv);</span>
            }
            // visits instructions
<span class="nc" id="L844">            instructions.accept(mv);</span>
            // visits local variables
<span class="nc bnc" id="L846" title="All 2 branches missed.">            n = localVariables == null ? 0 : localVariables.size();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L848">                localVariables.get(i).accept(mv);</span>
            }
            // visits local variable annotations
<span class="nc bnc" id="L851" title="All 2 branches missed.">            n = visibleLocalVariableAnnotations == null ? 0</span>
<span class="nc" id="L852">                    : visibleLocalVariableAnnotations.size();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L854">                visibleLocalVariableAnnotations.get(i).accept(mv, true);</span>
            }
<span class="nc bnc" id="L856" title="All 2 branches missed.">            n = invisibleLocalVariableAnnotations == null ? 0</span>
<span class="nc" id="L857">                    : invisibleLocalVariableAnnotations.size();</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            for (i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L859">                invisibleLocalVariableAnnotations.get(i).accept(mv, false);</span>
            }
            // visits maxs
<span class="nc" id="L862">            mv.visitMaxs(maxStack, maxLocals);</span>
<span class="nc" id="L863">            visited = true;</span>
        }
<span class="nc" id="L865">        mv.visitEnd();</span>
<span class="nc" id="L866">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>