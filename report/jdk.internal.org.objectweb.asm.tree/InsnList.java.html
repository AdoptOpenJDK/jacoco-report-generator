<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InsnList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.tree</a> &gt; <span class="el_source">InsnList.java</span></div><h1>InsnList.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.tree;

import java.util.ListIterator;
import java.util.NoSuchElementException;

import jdk.internal.org.objectweb.asm.MethodVisitor;

/**
 * A doubly linked list of {@link AbstractInsnNode} objects. &lt;i&gt;This
 * implementation is not thread safe&lt;/i&gt;.
 */
<span class="nc" id="L70">public class InsnList {</span>

    /**
     * The number of instructions in this list.
     */
    private int size;

    /**
     * The first instruction in this list. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AbstractInsnNode first;

    /**
     * The last instruction in this list. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AbstractInsnNode last;

    /**
     * A cache of the instructions of this list. This cache is used to improve
     * the performance of the {@link #get} method.
     */
    AbstractInsnNode[] cache;

    /**
     * Returns the number of instructions in this list.
     *
     * @return the number of instructions in this list.
     */
    public int size() {
<span class="nc" id="L99">        return size;</span>
    }

    /**
     * Returns the first instruction in this list.
     *
     * @return the first instruction in this list, or &lt;tt&gt;null&lt;/tt&gt; if the list
     *         is empty.
     */
    public AbstractInsnNode getFirst() {
<span class="nc" id="L109">        return first;</span>
    }

    /**
     * Returns the last instruction in this list.
     *
     * @return the last instruction in this list, or &lt;tt&gt;null&lt;/tt&gt; if the list
     *         is empty.
     */
    public AbstractInsnNode getLast() {
<span class="nc" id="L119">        return last;</span>
    }

    /**
     * Returns the instruction whose index is given. This method builds a cache
     * of the instructions in this list to avoid scanning the whole list each
     * time it is called. Once the cache is built, this method run in constant
     * time. This cache is invalidated by all the methods that modify the list.
     *
     * @param index
     *            the index of the instruction that must be returned.
     * @return the instruction whose index is given.
     * @throws IndexOutOfBoundsException
     *             if (index &amp;lt; 0 || index &amp;gt;= size()).
     */
    public AbstractInsnNode get(final int index) {
<span class="nc bnc" id="L135" title="All 4 branches missed.">        if (index &lt; 0 || index &gt;= size) {</span>
<span class="nc" id="L136">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L139">            cache = toArray();</span>
        }
<span class="nc" id="L141">        return cache[index];</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if the given instruction belongs to this list. This
     * method always scans the instructions of this list until it finds the
     * given instruction or reaches the end of the list.
     *
     * @param insn
     *            an instruction.
     * @return &lt;tt&gt;true&lt;/tt&gt; if the given instruction belongs to this list.
     */
    public boolean contains(final AbstractInsnNode insn) {
<span class="nc" id="L154">        AbstractInsnNode i = first;</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">        while (i != null &amp;&amp; i != insn) {</span>
<span class="nc" id="L156">            i = i.next;</span>
        }
<span class="nc bnc" id="L158" title="All 2 branches missed.">        return i != null;</span>
    }

    /**
     * Returns the index of the given instruction in this list. This method
     * builds a cache of the instruction indexes to avoid scanning the whole
     * list each time it is called. Once the cache is built, this method run in
     * constant time. The cache is invalidated by all the methods that modify
     * the list.
     *
     * @param insn
     *            an instruction &lt;i&gt;of this list&lt;/i&gt;.
     * @return the index of the given instruction in this list. &lt;i&gt;The result of
     *         this method is undefined if the given instruction does not belong
     *         to this list&lt;/i&gt;. Use {@link #contains contains} to test if an
     *         instruction belongs to an instruction list or not.
     */
    public int indexOf(final AbstractInsnNode insn) {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L177">            cache = toArray();</span>
        }
<span class="nc" id="L179">        return insn.index;</span>
    }

    /**
     * Makes the given visitor visit all of the instructions in this list.
     *
     * @param mv
     *            the method visitor that must visit the instructions.
     */
    public void accept(final MethodVisitor mv) {
<span class="nc" id="L189">        AbstractInsnNode insn = first;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        while (insn != null) {</span>
<span class="nc" id="L191">            insn.accept(mv);</span>
<span class="nc" id="L192">            insn = insn.next;</span>
        }
<span class="nc" id="L194">    }</span>

    /**
     * Returns an iterator over the instructions in this list.
     *
     * @return an iterator over the instructions in this list.
     */
    public ListIterator&lt;AbstractInsnNode&gt; iterator() {
<span class="nc" id="L202">        return iterator(0);</span>
    }

    /**
     * Returns an iterator over the instructions in this list.
     *
     * @return an iterator over the instructions in this list.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public ListIterator&lt;AbstractInsnNode&gt; iterator(int index) {
<span class="nc" id="L212">        return new InsnListIterator(index);</span>
    }

    /**
     * Returns an array containing all of the instructions in this list.
     *
     * @return an array containing all of the instructions in this list.
     */
    public AbstractInsnNode[] toArray() {
<span class="nc" id="L221">        int i = 0;</span>
<span class="nc" id="L222">        AbstractInsnNode elem = first;</span>
<span class="nc" id="L223">        AbstractInsnNode[] insns = new AbstractInsnNode[size];</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        while (elem != null) {</span>
<span class="nc" id="L225">            insns[i] = elem;</span>
<span class="nc" id="L226">            elem.index = i++;</span>
<span class="nc" id="L227">            elem = elem.next;</span>
        }
<span class="nc" id="L229">        return insns;</span>
    }

    /**
     * Replaces an instruction of this list with another instruction.
     *
     * @param location
     *            an instruction &lt;i&gt;of this list&lt;/i&gt;.
     * @param insn
     *            another instruction, &lt;i&gt;which must not belong to any
     *            {@link InsnList}&lt;/i&gt;.
     */
    public void set(final AbstractInsnNode location, final AbstractInsnNode insn) {
<span class="nc" id="L242">        AbstractInsnNode next = location.next;</span>
<span class="nc" id="L243">        insn.next = next;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (next != null) {</span>
<span class="nc" id="L245">            next.prev = insn;</span>
        } else {
<span class="nc" id="L247">            last = insn;</span>
        }
<span class="nc" id="L249">        AbstractInsnNode prev = location.prev;</span>
<span class="nc" id="L250">        insn.prev = prev;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (prev != null) {</span>
<span class="nc" id="L252">            prev.next = insn;</span>
        } else {
<span class="nc" id="L254">            first = insn;</span>
        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (cache != null) {</span>
<span class="nc" id="L257">            int index = location.index;</span>
<span class="nc" id="L258">            cache[index] = insn;</span>
<span class="nc" id="L259">            insn.index = index;</span>
<span class="nc" id="L260">        } else {</span>
<span class="nc" id="L261">            insn.index = 0; // insn now belongs to an InsnList</span>
        }
<span class="nc" id="L263">        location.index = -1; // i no longer belongs to an InsnList</span>
<span class="nc" id="L264">        location.prev = null;</span>
<span class="nc" id="L265">        location.next = null;</span>
<span class="nc" id="L266">    }</span>

    /**
     * Adds the given instruction to the end of this list.
     *
     * @param insn
     *            an instruction, &lt;i&gt;which must not belong to any
     *            {@link InsnList}&lt;/i&gt;.
     */
    public void add(final AbstractInsnNode insn) {
<span class="nc" id="L276">        ++size;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (last == null) {</span>
<span class="nc" id="L278">            first = insn;</span>
<span class="nc" id="L279">            last = insn;</span>
        } else {
<span class="nc" id="L281">            last.next = insn;</span>
<span class="nc" id="L282">            insn.prev = last;</span>
        }
<span class="nc" id="L284">        last = insn;</span>
<span class="nc" id="L285">        cache = null;</span>
<span class="nc" id="L286">        insn.index = 0; // insn now belongs to an InsnList</span>
<span class="nc" id="L287">    }</span>

    /**
     * Adds the given instructions to the end of this list.
     *
     * @param insns
     *            an instruction list, which is cleared during the process. This
     *            list must be different from 'this'.
     */
    public void add(final InsnList insns) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (insns.size == 0) {</span>
<span class="nc" id="L298">            return;</span>
        }
<span class="nc" id="L300">        size += insns.size;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (last == null) {</span>
<span class="nc" id="L302">            first = insns.first;</span>
<span class="nc" id="L303">            last = insns.last;</span>
        } else {
<span class="nc" id="L305">            AbstractInsnNode elem = insns.first;</span>
<span class="nc" id="L306">            last.next = elem;</span>
<span class="nc" id="L307">            elem.prev = last;</span>
<span class="nc" id="L308">            last = insns.last;</span>
        }
<span class="nc" id="L310">        cache = null;</span>
<span class="nc" id="L311">        insns.removeAll(false);</span>
<span class="nc" id="L312">    }</span>

    /**
     * Inserts the given instruction at the begining of this list.
     *
     * @param insn
     *            an instruction, &lt;i&gt;which must not belong to any
     *            {@link InsnList}&lt;/i&gt;.
     */
    public void insert(final AbstractInsnNode insn) {
<span class="nc" id="L322">        ++size;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (first == null) {</span>
<span class="nc" id="L324">            first = insn;</span>
<span class="nc" id="L325">            last = insn;</span>
        } else {
<span class="nc" id="L327">            first.prev = insn;</span>
<span class="nc" id="L328">            insn.next = first;</span>
        }
<span class="nc" id="L330">        first = insn;</span>
<span class="nc" id="L331">        cache = null;</span>
<span class="nc" id="L332">        insn.index = 0; // insn now belongs to an InsnList</span>
<span class="nc" id="L333">    }</span>

    /**
     * Inserts the given instructions at the begining of this list.
     *
     * @param insns
     *            an instruction list, which is cleared during the process. This
     *            list must be different from 'this'.
     */
    public void insert(final InsnList insns) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (insns.size == 0) {</span>
<span class="nc" id="L344">            return;</span>
        }
<span class="nc" id="L346">        size += insns.size;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (first == null) {</span>
<span class="nc" id="L348">            first = insns.first;</span>
<span class="nc" id="L349">            last = insns.last;</span>
        } else {
<span class="nc" id="L351">            AbstractInsnNode elem = insns.last;</span>
<span class="nc" id="L352">            first.prev = elem;</span>
<span class="nc" id="L353">            elem.next = first;</span>
<span class="nc" id="L354">            first = insns.first;</span>
        }
<span class="nc" id="L356">        cache = null;</span>
<span class="nc" id="L357">        insns.removeAll(false);</span>
<span class="nc" id="L358">    }</span>

    /**
     * Inserts the given instruction after the specified instruction.
     *
     * @param location
     *            an instruction &lt;i&gt;of this list&lt;/i&gt; after which insn must be
     *            inserted.
     * @param insn
     *            the instruction to be inserted, &lt;i&gt;which must not belong to
     *            any {@link InsnList}&lt;/i&gt;.
     */
    public void insert(final AbstractInsnNode location,
            final AbstractInsnNode insn) {
<span class="nc" id="L372">        ++size;</span>
<span class="nc" id="L373">        AbstractInsnNode next = location.next;</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (next == null) {</span>
<span class="nc" id="L375">            last = insn;</span>
        } else {
<span class="nc" id="L377">            next.prev = insn;</span>
        }
<span class="nc" id="L379">        location.next = insn;</span>
<span class="nc" id="L380">        insn.next = next;</span>
<span class="nc" id="L381">        insn.prev = location;</span>
<span class="nc" id="L382">        cache = null;</span>
<span class="nc" id="L383">        insn.index = 0; // insn now belongs to an InsnList</span>
<span class="nc" id="L384">    }</span>

    /**
     * Inserts the given instructions after the specified instruction.
     *
     * @param location
     *            an instruction &lt;i&gt;of this list&lt;/i&gt; after which the
     *            instructions must be inserted.
     * @param insns
     *            the instruction list to be inserted, which is cleared during
     *            the process. This list must be different from 'this'.
     */
    public void insert(final AbstractInsnNode location, final InsnList insns) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (insns.size == 0) {</span>
<span class="nc" id="L398">            return;</span>
        }
<span class="nc" id="L400">        size += insns.size;</span>
<span class="nc" id="L401">        AbstractInsnNode ifirst = insns.first;</span>
<span class="nc" id="L402">        AbstractInsnNode ilast = insns.last;</span>
<span class="nc" id="L403">        AbstractInsnNode next = location.next;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (next == null) {</span>
<span class="nc" id="L405">            last = ilast;</span>
        } else {
<span class="nc" id="L407">            next.prev = ilast;</span>
        }
<span class="nc" id="L409">        location.next = ifirst;</span>
<span class="nc" id="L410">        ilast.next = next;</span>
<span class="nc" id="L411">        ifirst.prev = location;</span>
<span class="nc" id="L412">        cache = null;</span>
<span class="nc" id="L413">        insns.removeAll(false);</span>
<span class="nc" id="L414">    }</span>

    /**
     * Inserts the given instruction before the specified instruction.
     *
     * @param location
     *            an instruction &lt;i&gt;of this list&lt;/i&gt; before which insn must be
     *            inserted.
     * @param insn
     *            the instruction to be inserted, &lt;i&gt;which must not belong to
     *            any {@link InsnList}&lt;/i&gt;.
     */
    public void insertBefore(final AbstractInsnNode location,
            final AbstractInsnNode insn) {
<span class="nc" id="L428">        ++size;</span>
<span class="nc" id="L429">        AbstractInsnNode prev = location.prev;</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (prev == null) {</span>
<span class="nc" id="L431">            first = insn;</span>
        } else {
<span class="nc" id="L433">            prev.next = insn;</span>
        }
<span class="nc" id="L435">        location.prev = insn;</span>
<span class="nc" id="L436">        insn.next = location;</span>
<span class="nc" id="L437">        insn.prev = prev;</span>
<span class="nc" id="L438">        cache = null;</span>
<span class="nc" id="L439">        insn.index = 0; // insn now belongs to an InsnList</span>
<span class="nc" id="L440">    }</span>

    /**
     * Inserts the given instructions before the specified instruction.
     *
     * @param location
     *            an instruction &lt;i&gt;of this list&lt;/i&gt; before which the
     *            instructions must be inserted.
     * @param insns
     *            the instruction list to be inserted, which is cleared during
     *            the process. This list must be different from 'this'.
     */
    public void insertBefore(final AbstractInsnNode location,
            final InsnList insns) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (insns.size == 0) {</span>
<span class="nc" id="L455">            return;</span>
        }
<span class="nc" id="L457">        size += insns.size;</span>
<span class="nc" id="L458">        AbstractInsnNode ifirst = insns.first;</span>
<span class="nc" id="L459">        AbstractInsnNode ilast = insns.last;</span>
<span class="nc" id="L460">        AbstractInsnNode prev = location.prev;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (prev == null) {</span>
<span class="nc" id="L462">            first = ifirst;</span>
        } else {
<span class="nc" id="L464">            prev.next = ifirst;</span>
        }
<span class="nc" id="L466">        location.prev = ilast;</span>
<span class="nc" id="L467">        ilast.next = location;</span>
<span class="nc" id="L468">        ifirst.prev = prev;</span>
<span class="nc" id="L469">        cache = null;</span>
<span class="nc" id="L470">        insns.removeAll(false);</span>
<span class="nc" id="L471">    }</span>

    /**
     * Removes the given instruction from this list.
     *
     * @param insn
     *            the instruction &lt;i&gt;of this list&lt;/i&gt; that must be removed.
     */
    public void remove(final AbstractInsnNode insn) {
<span class="nc" id="L480">        --size;</span>
<span class="nc" id="L481">        AbstractInsnNode next = insn.next;</span>
<span class="nc" id="L482">        AbstractInsnNode prev = insn.prev;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (next == null) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (prev == null) {</span>
<span class="nc" id="L485">                first = null;</span>
<span class="nc" id="L486">                last = null;</span>
            } else {
<span class="nc" id="L488">                prev.next = null;</span>
<span class="nc" id="L489">                last = prev;</span>
            }
        } else {
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (prev == null) {</span>
<span class="nc" id="L493">                first = next;</span>
<span class="nc" id="L494">                next.prev = null;</span>
            } else {
<span class="nc" id="L496">                prev.next = next;</span>
<span class="nc" id="L497">                next.prev = prev;</span>
            }
        }
<span class="nc" id="L500">        cache = null;</span>
<span class="nc" id="L501">        insn.index = -1; // insn no longer belongs to an InsnList</span>
<span class="nc" id="L502">        insn.prev = null;</span>
<span class="nc" id="L503">        insn.next = null;</span>
<span class="nc" id="L504">    }</span>

    /**
     * Removes all of the instructions of this list.
     *
     * @param mark
     *            if the instructions must be marked as no longer belonging to
     *            any {@link InsnList}.
     */
    void removeAll(final boolean mark) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (mark) {</span>
<span class="nc" id="L515">            AbstractInsnNode insn = first;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            while (insn != null) {</span>
<span class="nc" id="L517">                AbstractInsnNode next = insn.next;</span>
<span class="nc" id="L518">                insn.index = -1; // insn no longer belongs to an InsnList</span>
<span class="nc" id="L519">                insn.prev = null;</span>
<span class="nc" id="L520">                insn.next = null;</span>
<span class="nc" id="L521">                insn = next;</span>
<span class="nc" id="L522">            }</span>
        }
<span class="nc" id="L524">        size = 0;</span>
<span class="nc" id="L525">        first = null;</span>
<span class="nc" id="L526">        last = null;</span>
<span class="nc" id="L527">        cache = null;</span>
<span class="nc" id="L528">    }</span>

    /**
     * Removes all of the instructions of this list.
     */
    public void clear() {
<span class="nc" id="L534">        removeAll(false);</span>
<span class="nc" id="L535">    }</span>

    /**
     * Reset all labels in the instruction list. This method should be called
     * before reusing same instructions list between several
     * &lt;code&gt;ClassWriter&lt;/code&gt;s.
     */
    public void resetLabels() {
<span class="nc" id="L543">        AbstractInsnNode insn = first;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        while (insn != null) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (insn instanceof LabelNode) {</span>
<span class="nc" id="L546">                ((LabelNode) insn).resetLabel();</span>
            }
<span class="nc" id="L548">            insn = insn.next;</span>
        }
<span class="nc" id="L550">    }</span>

    // this class is not generified because it will create bridges
<span class="nc" id="L553">    private final class InsnListIterator implements ListIterator {</span>

        AbstractInsnNode next;

        AbstractInsnNode prev;

<span class="nc" id="L559">        InsnListIterator(int index) {</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (index == size()) {</span>
<span class="nc" id="L561">                next = null;</span>
<span class="nc" id="L562">                prev = getLast();</span>
            } else {
<span class="nc" id="L564">                next = get(index);</span>
<span class="nc" id="L565">                prev = next.prev;</span>
            }
<span class="nc" id="L567">        }</span>

        public boolean hasNext() {
<span class="nc bnc" id="L570" title="All 2 branches missed.">            return next != null;</span>
        }

        public Object next() {
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L575">                throw new NoSuchElementException();</span>
            }
<span class="nc" id="L577">            AbstractInsnNode result = next;</span>
<span class="nc" id="L578">            prev = result;</span>
<span class="nc" id="L579">            next = result.next;</span>
<span class="nc" id="L580">            return result;</span>
        }

        public void remove() {
<span class="nc" id="L584">            InsnList.this.remove(prev);</span>
<span class="nc" id="L585">            prev = prev.prev;</span>
<span class="nc" id="L586">        }</span>

        public boolean hasPrevious() {
<span class="nc bnc" id="L589" title="All 2 branches missed.">            return prev != null;</span>
        }

        public Object previous() {
<span class="nc" id="L593">            AbstractInsnNode result = prev;</span>
<span class="nc" id="L594">            next = result;</span>
<span class="nc" id="L595">            prev = result.prev;</span>
<span class="nc" id="L596">            return result;</span>
        }

        public int nextIndex() {
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (next == null) {</span>
<span class="nc" id="L601">                return size();</span>
            }
<span class="nc bnc" id="L603" title="All 2 branches missed.">            if (cache == null) {</span>
<span class="nc" id="L604">                cache = toArray();</span>
            }
<span class="nc" id="L606">            return next.index;</span>
        }

        public int previousIndex() {
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (prev == null) {</span>
<span class="nc" id="L611">                return -1;</span>
            }
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (cache == null) {</span>
<span class="nc" id="L614">                cache = toArray();</span>
            }
<span class="nc" id="L616">            return prev.index;</span>
        }

        public void add(Object o) {
<span class="nc" id="L620">            InsnList.this.insertBefore(next, (AbstractInsnNode) o);</span>
<span class="nc" id="L621">            prev = (AbstractInsnNode) o;</span>
<span class="nc" id="L622">        }</span>

        public void set(Object o) {
<span class="nc" id="L625">            InsnList.this.set(next.prev, (AbstractInsnNode) o);</span>
<span class="nc" id="L626">            prev = (AbstractInsnNode) o;</span>
<span class="nc" id="L627">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>