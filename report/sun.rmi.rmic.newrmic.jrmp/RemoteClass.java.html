<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RemoteClass.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.rmic.newrmic.jrmp</a> &gt; <span class="el_source">RemoteClass.java</span></div><h1>RemoteClass.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.rmic.newrmic.jrmp;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Parameter;
import com.sun.javadoc.Type;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.security.MessageDigest;
import java.security.DigestOutputStream;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import sun.rmi.rmic.newrmic.BatchEnvironment;

import static sun.rmi.rmic.newrmic.Constants.*;
import static sun.rmi.rmic.newrmic.jrmp.Constants.*;

/**
 * Encapsulates RMI-specific information about a remote implementation
 * class (a class that implements one or more remote interfaces).
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author Peter Jones
 **/
final class RemoteClass {

    /** rmic environment for this object */
    private final BatchEnvironment env;

    /** the remote implementation class this object represents */
    private final ClassDoc implClass;

    /** remote interfaces implemented by this class */
    private ClassDoc[] remoteInterfaces;

    /** the remote methods of this class */
    private Method[] remoteMethods;

    /** stub/skeleton &quot;interface hash&quot; for this class */
    private long interfaceHash;

    /**
     * Creates a RemoteClass instance that represents the RMI-specific
     * information about the specified remote implementation class.
     *
     * If the class is not a valid remote implementation class or if
     * some other error occurs, the return value will be null, and
     * errors will have been reported to the supplied
     * BatchEnvironment.
     **/
    static RemoteClass forClass(BatchEnvironment env, ClassDoc implClass) {
<span class="nc" id="L86">        RemoteClass remoteClass = new RemoteClass(env, implClass);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (remoteClass.init()) {</span>
<span class="nc" id="L88">            return remoteClass;</span>
        } else {
<span class="nc" id="L90">            return null;</span>
        }
    }

    /**
     * Creates a RemoteClass instance for the specified class.  The
     * resulting object is not yet initialized.
     **/
<span class="nc" id="L98">    private RemoteClass(BatchEnvironment env, ClassDoc implClass) {</span>
<span class="nc" id="L99">        this.env = env;</span>
<span class="nc" id="L100">        this.implClass = implClass;</span>
<span class="nc" id="L101">    }</span>

    /**
     * Returns the ClassDoc for this remote implementation class.
     **/
    ClassDoc classDoc() {
<span class="nc" id="L107">        return implClass;</span>
    }

    /**
     * Returns the remote interfaces implemented by this remote
     * implementation class.
     *
     * A remote interface is an interface that is a subinterface of
     * java.rmi.Remote.  The remote interfaces of a class are the
     * direct superinterfaces of the class and all of its superclasses
     * that are remote interfaces.
     *
     * The order of the array returned is arbitrary, and some elements
     * may be superfluous (i.e., superinterfaces of other interfaces
     * in the array).
     **/
    ClassDoc[] remoteInterfaces() {
<span class="nc" id="L124">        return remoteInterfaces.clone();</span>
    }

    /**
     * Returns an array of RemoteClass.Method objects representing all
     * of the remote methods of this remote implementation class (all
     * of the member methods of the class's remote interfaces).
     *
     * The methods in the array are ordered according to a comparison
     * of strings consisting of their name followed by their
     * descriptor, so each method's index in the array corresponds to
     * its &quot;operation number&quot; in the JDK 1.1 version of the JRMP
     * stub/skeleton protocol.
     **/
    Method[] remoteMethods() {
<span class="nc" id="L139">        return remoteMethods.clone();</span>
    }

    /**
     * Returns the &quot;interface hash&quot; used to match a stub/skeleton pair
     * for this remote implementation class in the JDK 1.1 version of
     * the JRMP stub/skeleton protocol.
     **/
    long interfaceHash() {
<span class="nc" id="L148">        return interfaceHash;</span>
    }

    /**
     * Validates this remote implementation class and computes the
     * RMI-specific information.  Returns true if successful, or false
     * if an error occurred.
     **/
    private boolean init() {
        /*
         * Verify that it is really a class, not an interface.
         */
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (implClass.isInterface()) {</span>
<span class="nc" id="L161">            env.error(&quot;rmic.cant.make.stubs.for.interface&quot;,</span>
<span class="nc" id="L162">                      implClass.qualifiedName());</span>
<span class="nc" id="L163">            return false;</span>
        }

        /*
         * Find all of the remote interfaces of our remote
         * implementation class-- for each class up the superclass
         * chain, add each directly-implemented interface that somehow
         * extends Remote to a list.
         */
<span class="nc" id="L172">        List&lt;ClassDoc&gt; remotesImplemented = new ArrayList&lt;ClassDoc&gt;();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (ClassDoc cl = implClass; cl != null; cl = cl.superclass()) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            for (ClassDoc intf : cl.interfaces()) {</span>
                /*
                 * Add interface to the list if it extends Remote and
                 * it is not already there.
                 */
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (!remotesImplemented.contains(intf) &amp;&amp;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    intf.subclassOf(env.docRemote()))</span>
                {
<span class="nc" id="L182">                    remotesImplemented.add(intf);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                    if (env.verbose()) {</span>
<span class="nc" id="L184">                        env.output(&quot;[found remote interface: &quot; +</span>
<span class="nc" id="L185">                                   intf.qualifiedName() + &quot;]&quot;);</span>
                    }
                }
            }

            /*
             * Verify that the candidate remote implementation class
             * implements at least one remote interface directly.
             */
<span class="nc bnc" id="L194" title="All 4 branches missed.">            if (cl == implClass &amp;&amp; remotesImplemented.isEmpty()) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (implClass.subclassOf(env.docRemote())) {</span>
                    /*
                     * This error message is used if the class does
                     * implement a remote interface through one of its
                     * superclasses, but not directly.
                     */
<span class="nc" id="L201">                    env.error(&quot;rmic.must.implement.remote.directly&quot;,</span>
<span class="nc" id="L202">                              implClass.qualifiedName());</span>
                } else {
                    /*
                     * This error message is used if the class does
                     * not implement a remote interface at all.
                     */
<span class="nc" id="L208">                    env.error(&quot;rmic.must.implement.remote&quot;,</span>
<span class="nc" id="L209">                              implClass.qualifiedName());</span>
                }
<span class="nc" id="L211">                return false;</span>
            }
        }

        /*
         * Convert list of remote interfaces to an array
         * (order is not important for this array).
         */
<span class="nc" id="L219">        remoteInterfaces =</span>
<span class="nc" id="L220">            remotesImplemented.toArray(</span>
<span class="nc" id="L221">                new ClassDoc[remotesImplemented.size()]);</span>

        /*
         * Collect the methods from all of the remote interfaces into
         * a table, which maps from method name-and-descriptor string
         * to Method object.
         */
<span class="nc" id="L228">        Map&lt;String,Method&gt; methods = new HashMap&lt;String,Method&gt;();</span>
<span class="nc" id="L229">        boolean errors = false;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (ClassDoc intf : remotesImplemented) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (!collectRemoteMethods(intf, methods)) {</span>
                /*
                 * Continue iterating despite errors in order to
                 * generate more complete error report.
                 */
<span class="nc" id="L236">                errors = true;</span>
            }
<span class="nc" id="L238">        }</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (errors) {</span>
<span class="nc" id="L240">            return false;</span>
        }

        /*
         * Sort table of remote methods into an array.  The elements
         * are sorted in ascending order of the string of the method's
         * name and descriptor, so that each elements index is equal
         * to its operation number in the JDK 1.1 version of the JRMP
         * stub/skeleton protocol.
         */
<span class="nc" id="L250">        String[] orderedKeys =</span>
<span class="nc" id="L251">            methods.keySet().toArray(new String[methods.size()]);</span>
<span class="nc" id="L252">        Arrays.sort(orderedKeys);</span>
<span class="nc" id="L253">        remoteMethods = new Method[methods.size()];</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        for (int i = 0; i &lt; remoteMethods.length; i++) {</span>
<span class="nc" id="L255">            remoteMethods[i] = methods.get(orderedKeys[i]);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (env.verbose()) {</span>
<span class="nc" id="L257">                String msg = &quot;[found remote method &lt;&quot; + i + &quot;&gt;: &quot; +</span>
<span class="nc" id="L258">                    remoteMethods[i].operationString();</span>
<span class="nc" id="L259">                ClassDoc[] exceptions = remoteMethods[i].exceptionTypes();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (exceptions.length &gt; 0) {</span>
<span class="nc" id="L261">                    msg += &quot; throws &quot;;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    for (int j = 0; j &lt; exceptions.length; j++) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                        if (j &gt; 0) {</span>
<span class="nc" id="L264">                            msg += &quot;, &quot;;</span>
                        }
<span class="nc" id="L266">                        msg +=  exceptions[j].qualifiedName();</span>
                    }
                }
<span class="nc" id="L269">                msg += &quot;\n\tname and descriptor = \&quot;&quot; +</span>
<span class="nc" id="L270">                    remoteMethods[i].nameAndDescriptor();</span>
<span class="nc" id="L271">                msg += &quot;\n\tmethod hash = &quot; +</span>
<span class="nc" id="L272">                    remoteMethods[i].methodHash() + &quot;]&quot;;</span>
<span class="nc" id="L273">                env.output(msg);</span>
            }
        }

        /*
         * Finally, pre-compute the interface hash to be used by
         * stubs/skeletons for this remote class in the JDK 1.1
         * version of the JRMP stub/skeleton protocol.
         */
<span class="nc" id="L282">        interfaceHash = computeInterfaceHash();</span>

<span class="nc" id="L284">        return true;</span>
    }

    /**
     * Collects and validates all methods from the specified interface
     * and all of its superinterfaces as remote methods.  Remote
     * methods are added to the supplied table.  Returns true if
     * successful, or false if an error occurred.
     **/
    private boolean collectRemoteMethods(ClassDoc intf,
                                         Map&lt;String,Method&gt; table)
    {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (!intf.isInterface()) {</span>
<span class="nc" id="L297">            throw new AssertionError(</span>
<span class="nc" id="L298">                intf.qualifiedName() + &quot; not an interface&quot;);</span>
        }

<span class="nc" id="L301">        boolean errors = false;</span>

        /*
         * Search interface's declared methods.
         */
    nextMethod:
<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (MethodDoc method : intf.methods()) {</span>

            /*
             * Verify that each method throws RemoteException (or a
             * superclass of RemoteException).
             */
<span class="nc" id="L313">            boolean hasRemoteException = false;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">            for (ClassDoc ex : method.thrownExceptions()) {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (env.docRemoteException().subclassOf(ex)) {</span>
<span class="nc" id="L316">                    hasRemoteException = true;</span>
<span class="nc" id="L317">                    break;</span>
                }
            }

            /*
             * If this method did not throw RemoteException as required,
             * generate the error but continue, so that multiple such
             * errors can be reported.
             */
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (!hasRemoteException) {</span>
<span class="nc" id="L327">                env.error(&quot;rmic.must.throw.remoteexception&quot;,</span>
<span class="nc" id="L328">                          intf.qualifiedName(),</span>
<span class="nc" id="L329">                          method.name() + method.signature());</span>
<span class="nc" id="L330">                errors = true;</span>
<span class="nc" id="L331">                continue nextMethod;</span>
            }

            /*
             * Verify that the implementation of this method throws only
             * java.lang.Exception or its subclasses (fix bugid 4092486).
             * JRMP does not support remote methods throwing
             * java.lang.Throwable or other subclasses.
             */
<span class="nc" id="L340">            MethodDoc implMethod = findImplMethod(method);</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (implMethod != null) {           // should not be null</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                for (ClassDoc ex : implMethod.thrownExceptions()) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                    if (!ex.subclassOf(env.docException())) {</span>
<span class="nc" id="L344">                        env.error(&quot;rmic.must.only.throw.exception&quot;,</span>
<span class="nc" id="L345">                                  implMethod.name() + implMethod.signature(),</span>
<span class="nc" id="L346">                                  ex.qualifiedName());</span>
<span class="nc" id="L347">                        errors = true;</span>
<span class="nc" id="L348">                        continue nextMethod;</span>
                    }
                }
            }

            /*
             * Create RemoteClass.Method object to represent this method
             * found in a remote interface.
             */
<span class="nc" id="L357">            Method newMethod = new Method(method);</span>

            /*
             * Store remote method's representation in the table of
             * remote methods found, keyed by its name and descriptor.
             *
             * If the table already contains an entry with the same
             * method name and descriptor, then we must replace the
             * old entry with a Method object that represents a legal
             * combination of the old and the new methods;
             * specifically, the combined method must have a throws
             * clause that contains (only) all of the checked
             * exceptions that can be thrown by both the old and the
             * new method (see bugid 4070653).
             */
<span class="nc" id="L372">            String key = newMethod.nameAndDescriptor();</span>
<span class="nc" id="L373">            Method oldMethod = table.get(key);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (oldMethod != null) {</span>
<span class="nc" id="L375">                newMethod = newMethod.mergeWith(oldMethod);</span>
            }
<span class="nc" id="L377">            table.put(key, newMethod);</span>
        }

        /*
         * Recursively collect methods for all superinterfaces.
         */
<span class="nc bnc" id="L383" title="All 2 branches missed.">        for (ClassDoc superintf : intf.interfaces()) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if (!collectRemoteMethods(superintf, table)) {</span>
<span class="nc" id="L385">                errors = true;</span>
            }
        }

<span class="nc bnc" id="L389" title="All 2 branches missed.">        return !errors;</span>
    }

    /**
     * Returns the MethodDoc for the method of this remote
     * implementation class that implements the specified remote
     * method of a remote interface.  Returns null if no matching
     * method was found in this remote implementation class.
     **/
    private MethodDoc findImplMethod(MethodDoc interfaceMethod) {
<span class="nc" id="L399">        String name = interfaceMethod.name();</span>
<span class="nc" id="L400">        String desc = Util.methodDescriptorOf(interfaceMethod);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        for (MethodDoc implMethod : implClass.methods()) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (name.equals(implMethod.name()) &amp;&amp;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                desc.equals(Util.methodDescriptorOf(implMethod)))</span>
            {
<span class="nc" id="L405">                return implMethod;</span>
            }
        }
<span class="nc" id="L408">        return null;</span>
    }

    /**
     * Computes the &quot;interface hash&quot; of the stub/skeleton pair for
     * this remote implementation class.  This is the 64-bit value
     * used to enforce compatibility between a stub class and a
     * skeleton class in the JDK 1.1 version of the JRMP stub/skeleton
     * protocol.
     *
     * It is calculated using the first 64 bits of an SHA digest.  The
     * digest is of a stream consisting of the following data:
     *     (int) stub version number, always 1
     *     for each remote method, in order of operation number:
     *         (UTF-8) method name
     *         (UTF-8) method descriptor
     *         for each declared exception, in alphabetical name order:
     *             (UTF-8) name of exception class
     * (where &quot;UTF-8&quot; includes a 16-bit length prefix as written by
     * java.io.DataOutput.writeUTF).
     **/
    private long computeInterfaceHash() {
<span class="nc" id="L430">        long hash = 0;</span>
<span class="nc" id="L431">        ByteArrayOutputStream sink = new ByteArrayOutputStream(512);</span>
        try {
<span class="nc" id="L433">            MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L434">            DataOutputStream out = new DataOutputStream(</span>
                new DigestOutputStream(sink, md));

<span class="nc" id="L437">            out.writeInt(INTERFACE_HASH_STUB_VERSION);</span>

<span class="nc bnc" id="L439" title="All 2 branches missed.">            for (Method method : remoteMethods) {</span>
<span class="nc" id="L440">                MethodDoc methodDoc = method.methodDoc();</span>

<span class="nc" id="L442">                out.writeUTF(methodDoc.name());</span>
<span class="nc" id="L443">                out.writeUTF(Util.methodDescriptorOf(methodDoc));</span>
                                // descriptors already use binary names

<span class="nc" id="L446">                ClassDoc exceptions[] = methodDoc.thrownExceptions();</span>
<span class="nc" id="L447">                Arrays.sort(exceptions, new ClassDocComparator());</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                for (ClassDoc ex : exceptions) {</span>
<span class="nc" id="L449">                    out.writeUTF(Util.binaryNameOf(ex));</span>
                }
            }
<span class="nc" id="L452">            out.flush();</span>

            // use only the first 64 bits of the digest for the hash
<span class="nc" id="L455">            byte hashArray[] = md.digest();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            for (int i = 0; i &lt; Math.min(8, hashArray.length); i++) {</span>
<span class="nc" id="L457">                hash += ((long) (hashArray[i] &amp; 0xFF)) &lt;&lt; (i * 8);</span>
            }
<span class="nc" id="L459">        } catch (IOException e) {</span>
<span class="nc" id="L460">            throw new AssertionError(e);</span>
<span class="nc" id="L461">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L462">            throw new AssertionError(e);</span>
<span class="nc" id="L463">        }</span>

<span class="nc" id="L465">        return hash;</span>
    }

    /**
     * Compares ClassDoc instances according to the lexicographic
     * order of their binary names.
     **/
<span class="nc" id="L472">    private static class ClassDocComparator implements Comparator&lt;ClassDoc&gt; {</span>
        public int compare(ClassDoc o1, ClassDoc o2) {
<span class="nc" id="L474">            return Util.binaryNameOf(o1).compareTo(Util.binaryNameOf(o2));</span>
        }
    }

    /**
     * Encapsulates RMI-specific information about a particular remote
     * method in the remote implementation class represented by the
     * enclosing RemoteClass.
     **/
    final class Method implements Cloneable {

        /**
         * MethodDoc for this remove method, from one of the remote
         * interfaces that this method was found in.
         *
         * Note that this MethodDoc may be only one of multiple that
         * correspond to this remote method object, if multiple of
         * this class's remote interfaces contain methods with the
         * same name and descriptor.  Therefore, this MethodDoc may
         * declare more exceptions thrown that this remote method
         * does.
         **/
        private final MethodDoc methodDoc;

        /** java.rmi.server.Operation string for this remote method */
        private final String operationString;

        /** name and descriptor of this remote method */
        private final String nameAndDescriptor;

        /** JRMP &quot;method hash&quot; for this remote method */
        private final long methodHash;

        /**
         * Exceptions declared to be thrown by this remote method.
         *
         * This list may include superfluous entries, such as
         * unchecked exceptions and subclasses of other entries.
         **/
        private ClassDoc[] exceptionTypes;

        /**
         * Creates a new Method instance for the specified method.
         **/
<span class="nc" id="L518">        Method(MethodDoc methodDoc) {</span>
<span class="nc" id="L519">            this.methodDoc = methodDoc;</span>
<span class="nc" id="L520">            exceptionTypes = methodDoc.thrownExceptions();</span>
            /*
             * Sort exception types to improve consistency with
             * previous implementations.
             */
<span class="nc" id="L525">            Arrays.sort(exceptionTypes, new ClassDocComparator());</span>
<span class="nc" id="L526">            operationString = computeOperationString();</span>
<span class="nc" id="L527">            nameAndDescriptor =</span>
<span class="nc" id="L528">                methodDoc.name() + Util.methodDescriptorOf(methodDoc);</span>
<span class="nc" id="L529">            methodHash = computeMethodHash();</span>
<span class="nc" id="L530">        }</span>

        /**
         * Returns the MethodDoc object corresponding to this method
         * of a remote interface.
         **/
        MethodDoc methodDoc() {
<span class="nc" id="L537">            return methodDoc;</span>
        }

        /**
         * Returns the parameter types declared by this method.
         **/
        Type[] parameterTypes() {
<span class="nc" id="L544">            Parameter[] parameters = methodDoc.parameters();</span>
<span class="nc" id="L545">            Type[] paramTypes = new Type[parameters.length];</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="nc" id="L547">                paramTypes[i] = parameters[i].type();</span>
            }
<span class="nc" id="L549">            return paramTypes;</span>
        }

        /**
         * Returns the exception types declared to be thrown by this
         * remote method.
         *
         * For methods with the same name and descriptor inherited
         * from multiple remote interfaces, the array will contain the
         * set of exceptions declared in all of the interfaces'
         * methods that can be legally thrown by all of them.
         **/
        ClassDoc[] exceptionTypes() {
<span class="nc" id="L562">            return exceptionTypes.clone();</span>
        }

        /**
         * Returns the JRMP &quot;method hash&quot; used to identify this remote
         * method in the JDK 1.2 version of the stub protocol.
         **/
        long methodHash() {
<span class="nc" id="L570">            return methodHash;</span>
        }

        /**
         * Returns the string representation of this method
         * appropriate for the construction of a
         * java.rmi.server.Operation object.
         **/
        String operationString() {
<span class="nc" id="L579">            return operationString;</span>
        }

        /**
         * Returns a string consisting of this method's name followed
         * by its descriptor.
         **/
        String nameAndDescriptor() {
<span class="nc" id="L587">            return nameAndDescriptor;</span>
        }

        /**
         * Returns a new Method object that is a legal combination of
         * this Method object and another one.
         *
         * Doing this requires determining the exceptions declared by
         * the combined method, which must be (only) all of the
         * exceptions declared in both old Methods that may thrown in
         * either of them.
         **/
        Method mergeWith(Method other) {
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (!nameAndDescriptor().equals(other.nameAndDescriptor())) {</span>
<span class="nc" id="L601">                throw new AssertionError(</span>
                    &quot;attempt to merge method \&quot;&quot; +
<span class="nc" id="L603">                    other.nameAndDescriptor() + &quot;\&quot; with \&quot;&quot; +</span>
<span class="nc" id="L604">                    nameAndDescriptor());</span>
            }

<span class="nc" id="L607">            List&lt;ClassDoc&gt; legalExceptions = new ArrayList&lt;ClassDoc&gt;();</span>
<span class="nc" id="L608">            collectCompatibleExceptions(</span>
                other.exceptionTypes, exceptionTypes, legalExceptions);
<span class="nc" id="L610">            collectCompatibleExceptions(</span>
                exceptionTypes, other.exceptionTypes, legalExceptions);

<span class="nc" id="L613">            Method merged = clone();</span>
<span class="nc" id="L614">            merged.exceptionTypes =</span>
<span class="nc" id="L615">                legalExceptions.toArray(new ClassDoc[legalExceptions.size()]);</span>

<span class="nc" id="L617">            return merged;</span>
        }

        /**
         * Cloning is supported by returning a shallow copy of this
         * object.
         **/
        protected Method clone() {
            try {
<span class="nc" id="L626">                return (Method) super.clone();</span>
<span class="nc" id="L627">            } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L628">                throw new AssertionError(e);</span>
            }
        }

        /**
         * Adds to the supplied list all exceptions in the &quot;froms&quot;
         * array that are subclasses of an exception in the &quot;withs&quot;
         * array.
         **/
        private void collectCompatibleExceptions(ClassDoc[] froms,
                                                 ClassDoc[] withs,
                                                 List&lt;ClassDoc&gt; list)
        {
<span class="nc bnc" id="L641" title="All 2 branches missed.">            for (ClassDoc from : froms) {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (!list.contains(from)) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                    for (ClassDoc with : withs) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                        if (from.subclassOf(with)) {</span>
<span class="nc" id="L645">                            list.add(from);</span>
<span class="nc" id="L646">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L651">        }</span>

        /**
         * Computes the JRMP &quot;method hash&quot; of this remote method.  The
         * method hash is a long containing the first 64 bits of the
         * SHA digest from the UTF-8 encoded string of the method name
         * and descriptor.
         **/
        private long computeMethodHash() {
<span class="nc" id="L660">            long hash = 0;</span>
<span class="nc" id="L661">            ByteArrayOutputStream sink = new ByteArrayOutputStream(512);</span>
            try {
<span class="nc" id="L663">                MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L664">                DataOutputStream out = new DataOutputStream(</span>
                    new DigestOutputStream(sink, md));

<span class="nc" id="L667">                String methodString = nameAndDescriptor();</span>
<span class="nc" id="L668">                out.writeUTF(methodString);</span>

                // use only the first 64 bits of the digest for the hash
<span class="nc" id="L671">                out.flush();</span>
<span class="nc" id="L672">                byte hashArray[] = md.digest();</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                for (int i = 0; i &lt; Math.min(8, hashArray.length); i++) {</span>
<span class="nc" id="L674">                    hash += ((long) (hashArray[i] &amp; 0xFF)) &lt;&lt; (i * 8);</span>
                }
<span class="nc" id="L676">            } catch (IOException e) {</span>
<span class="nc" id="L677">                throw new AssertionError(e);</span>
<span class="nc" id="L678">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L679">                throw new AssertionError(e);</span>
<span class="nc" id="L680">            }</span>

<span class="nc" id="L682">            return hash;</span>
        }

        /**
         * Computes the string representation of this method
         * appropriate for the construction of a
         * java.rmi.server.Operation object.
         **/
        private String computeOperationString() {
            /*
             * To be consistent with previous implementations, we use
             * the deprecated style of placing the &quot;[]&quot; for the return
             * type (if any) after the parameter list.
             */
<span class="nc" id="L696">            Type returnType = methodDoc.returnType();</span>
<span class="nc" id="L697">            String op = returnType.qualifiedTypeName() + &quot; &quot; +</span>
<span class="nc" id="L698">                methodDoc.name() + &quot;(&quot;;</span>
<span class="nc" id="L699">            Parameter[] parameters = methodDoc.parameters();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L702">                    op += &quot;, &quot;;</span>
                }
<span class="nc" id="L704">                op += parameters[i].type().toString();</span>
            }
<span class="nc" id="L706">            op += &quot;)&quot; + returnType.dimension();</span>
<span class="nc" id="L707">            return op;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>