<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StubSkeletonWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.rmi.rmic.newrmic.jrmp</a> &gt; <span class="el_source">StubSkeletonWriter.java</span></div><h1>StubSkeletonWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.rmic.newrmic.jrmp;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.MethodDoc;
import com.sun.javadoc.Type;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import sun.rmi.rmic.newrmic.BatchEnvironment;
import sun.rmi.rmic.newrmic.IndentingWriter;

import static sun.rmi.rmic.newrmic.Constants.*;
import static sun.rmi.rmic.newrmic.jrmp.Constants.*;

/**
 * Writes the source code for the stub class and (optionally) skeleton
 * class for a particular remote implementation class.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author Peter Jones
 **/
<span class="nc bnc" id="L51" title="All 2 branches missed.">class StubSkeletonWriter {</span>

    /** rmic environment for this object */
    private final BatchEnvironment env;

    /** the remote implementation class to generate code for */
    private final RemoteClass remoteClass;

    /** version of the JRMP stub protocol to generate code for */
    private final StubVersion version;

    /*
     * binary names of the stub and skeleton classes to generate for
     * the remote class
     */
    private final String stubClassName;
    private final String skeletonClassName;

    /* package name and simple names of the stub and skeleton classes */
    private final String packageName;
    private final String stubClassSimpleName;
    private final String skeletonClassSimpleName;

    /** remote methods of class, indexed by operation number */
    private final RemoteClass.Method[] remoteMethods;

    /**
     * Names to use for the java.lang.reflect.Method static fields in
     * the generated stub class corresponding to each remote method.
     **/
    private final String[] methodFieldNames;

    /**
     * Creates a StubSkeletonWriter instance for the specified remote
     * implementation class.  The generated code will implement the
     * specified JRMP stub protocol version.
     **/
    StubSkeletonWriter(BatchEnvironment env,
                       RemoteClass remoteClass,
                       StubVersion version)
<span class="nc" id="L91">    {</span>
<span class="nc" id="L92">        this.env = env;</span>
<span class="nc" id="L93">        this.remoteClass = remoteClass;</span>
<span class="nc" id="L94">        this.version = version;</span>

<span class="nc" id="L96">        stubClassName = Util.binaryNameOf(remoteClass.classDoc()) + &quot;_Stub&quot;;</span>
<span class="nc" id="L97">        skeletonClassName =</span>
<span class="nc" id="L98">            Util.binaryNameOf(remoteClass.classDoc()) + &quot;_Skel&quot;;</span>

<span class="nc" id="L100">        int i = stubClassName.lastIndexOf('.');</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        packageName = (i != -1 ? stubClassName.substring(0, i) : &quot;&quot;);</span>
<span class="nc" id="L102">        stubClassSimpleName = stubClassName.substring(i + 1);</span>
<span class="nc" id="L103">        skeletonClassSimpleName = skeletonClassName.substring(i + 1);</span>

<span class="nc" id="L105">        remoteMethods = remoteClass.remoteMethods();</span>
<span class="nc" id="L106">        methodFieldNames = nameMethodFields(remoteMethods);</span>
<span class="nc" id="L107">    }</span>

    /**
     * Returns the binary name of the stub class to generate for the
     * remote implementation class.
     **/
    String stubClassName() {
<span class="nc" id="L114">        return stubClassName;</span>
    }

    /**
     * Returns the binary name of the skeleton class to generate for
     * the remote implementation class.
     **/
    String skeletonClassName() {
<span class="nc" id="L122">        return skeletonClassName;</span>
    }

    /**
     * Writes the stub class for the remote class to a stream.
     **/
    void writeStub(IndentingWriter p) throws IOException {

        /*
         * Write boiler plate comment.
         */
<span class="nc" id="L133">        p.pln(&quot;// Stub class generated by rmic, do not edit.&quot;);</span>
<span class="nc" id="L134">        p.pln(&quot;// Contents subject to change without notice.&quot;);</span>
<span class="nc" id="L135">        p.pln();</span>

        /*
         * If remote implementation class was in a particular package,
         * declare the stub class to be in the same package.
         */
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (!packageName.equals(&quot;&quot;)) {</span>
<span class="nc" id="L142">            p.pln(&quot;package &quot; + packageName + &quot;;&quot;);</span>
<span class="nc" id="L143">            p.pln();</span>
        }

        /*
         * Declare the stub class; implement all remote interfaces.
         */
<span class="nc" id="L149">        p.plnI(&quot;public final class &quot; + stubClassSimpleName);</span>
<span class="nc" id="L150">        p.pln(&quot;extends &quot; + REMOTE_STUB);</span>
<span class="nc" id="L151">        ClassDoc[] remoteInterfaces = remoteClass.remoteInterfaces();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (remoteInterfaces.length &gt; 0) {</span>
<span class="nc" id="L153">            p.p(&quot;implements &quot;);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            for (int i = 0; i &lt; remoteInterfaces.length; i++) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L156">                    p.p(&quot;, &quot;);</span>
                }
<span class="nc" id="L158">                p.p(remoteInterfaces[i].qualifiedName());</span>
            }
<span class="nc" id="L160">            p.pln();</span>
        }
<span class="nc" id="L162">        p.pOlnI(&quot;{&quot;);</span>

<span class="nc bnc" id="L164" title="All 4 branches missed.">        if (version == StubVersion.V1_1 ||</span>
            version == StubVersion.VCOMPAT)
        {
<span class="nc" id="L167">            writeOperationsArray(p);</span>
<span class="nc" id="L168">            p.pln();</span>
<span class="nc" id="L169">            writeInterfaceHash(p);</span>
<span class="nc" id="L170">            p.pln();</span>
        }

<span class="nc bnc" id="L173" title="All 4 branches missed.">        if (version == StubVersion.VCOMPAT ||</span>
            version == StubVersion.V1_2)
        {
<span class="nc" id="L176">            p.pln(&quot;private static final long serialVersionUID = &quot; +</span>
                STUB_SERIAL_VERSION_UID + &quot;;&quot;);
<span class="nc" id="L178">            p.pln();</span>

            /*
             * We only need to declare and initialize the static fields of
             * Method objects for each remote method if there are any remote
             * methods; otherwise, skip this code entirely, to avoid generating
             * a try/catch block for a checked exception that cannot occur
             * (see bugid 4125181).
             */
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (methodFieldNames.length &gt; 0) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L189">                    p.pln(&quot;private static boolean useNewInvoke;&quot;);</span>
                }
<span class="nc" id="L191">                writeMethodFieldDeclarations(p);</span>
<span class="nc" id="L192">                p.pln();</span>

                /*
                 * Initialize java.lang.reflect.Method fields for each remote
                 * method in a static initializer.
                 */
<span class="nc" id="L198">                p.plnI(&quot;static {&quot;);</span>
<span class="nc" id="L199">                p.plnI(&quot;try {&quot;);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (version == StubVersion.VCOMPAT) {</span>
                    /*
                     * Fat stubs must determine whether the API required for
                     * the JDK 1.2 stub protocol is supported in the current
                     * runtime, so that it can use it if supported.  This is
                     * determined by using the Reflection API to test if the
                     * new invoke method on RemoteRef exists, and setting the
                     * static boolean &quot;useNewInvoke&quot; to true if it does, or
                     * to false if a NoSuchMethodException is thrown.
                     */
<span class="nc" id="L210">                    p.plnI(REMOTE_REF + &quot;.class.getMethod(\&quot;invoke\&quot;,&quot;);</span>
<span class="nc" id="L211">                    p.plnI(&quot;new java.lang.Class[] {&quot;);</span>
<span class="nc" id="L212">                    p.pln(REMOTE + &quot;.class,&quot;);</span>
<span class="nc" id="L213">                    p.pln(&quot;java.lang.reflect.Method.class,&quot;);</span>
<span class="nc" id="L214">                    p.pln(&quot;java.lang.Object[].class,&quot;);</span>
<span class="nc" id="L215">                    p.pln(&quot;long.class&quot;);</span>
<span class="nc" id="L216">                    p.pOln(&quot;});&quot;);</span>
<span class="nc" id="L217">                    p.pO();</span>
<span class="nc" id="L218">                    p.pln(&quot;useNewInvoke = true;&quot;);</span>
                }
<span class="nc" id="L220">                writeMethodFieldInitializers(p);</span>
<span class="nc" id="L221">                p.pOlnI(&quot;} catch (java.lang.NoSuchMethodException e) {&quot;);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L223">                    p.pln(&quot;useNewInvoke = false;&quot;);</span>
                } else {
<span class="nc" id="L225">                    p.plnI(&quot;throw new java.lang.NoSuchMethodError(&quot;);</span>
<span class="nc" id="L226">                    p.pln(&quot;\&quot;stub class initialization failed\&quot;);&quot;);</span>
<span class="nc" id="L227">                    p.pO();</span>
                }
<span class="nc" id="L229">                p.pOln(&quot;}&quot;);            // end try/catch block</span>
<span class="nc" id="L230">                p.pOln(&quot;}&quot;);            // end static initializer</span>
<span class="nc" id="L231">                p.pln();</span>
            }
        }

<span class="nc" id="L235">        writeStubConstructors(p);</span>
<span class="nc" id="L236">        p.pln();</span>

        /*
         * Write each stub method.
         */
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (remoteMethods.length &gt; 0) {</span>
<span class="nc" id="L242">            p.pln(&quot;// methods from remote interfaces&quot;);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (int i = 0; i &lt; remoteMethods.length; ++i) {</span>
<span class="nc" id="L244">                p.pln();</span>
<span class="nc" id="L245">                writeStubMethod(p, i);</span>
            }
        }

<span class="nc" id="L249">        p.pOln(&quot;}&quot;);                    // end stub class</span>
<span class="nc" id="L250">    }</span>

    /**
     * Writes the constructors for the stub class.
     **/
    private void writeStubConstructors(IndentingWriter p)
        throws IOException
    {
<span class="nc" id="L258">        p.pln(&quot;// constructors&quot;);</span>

        /*
         * Only stubs compatible with the JDK 1.1 stub protocol need
         * a no-arg constructor; later versions use reflection to find
         * the constructor that directly takes a RemoteRef argument.
         */
<span class="nc bnc" id="L265" title="All 4 branches missed.">        if (version == StubVersion.V1_1 ||</span>
            version == StubVersion.VCOMPAT)
        {
<span class="nc" id="L268">            p.plnI(&quot;public &quot; + stubClassSimpleName + &quot;() {&quot;);</span>
<span class="nc" id="L269">            p.pln(&quot;super();&quot;);</span>
<span class="nc" id="L270">            p.pOln(&quot;}&quot;);</span>
        }

<span class="nc" id="L273">        p.plnI(&quot;public &quot; + stubClassSimpleName + &quot;(&quot; + REMOTE_REF + &quot; ref) {&quot;);</span>
<span class="nc" id="L274">        p.pln(&quot;super(ref);&quot;);</span>
<span class="nc" id="L275">        p.pOln(&quot;}&quot;);</span>
<span class="nc" id="L276">    }</span>

    /**
     * Writes the stub method for the remote method with the given
     * operation number.
     **/
    private void writeStubMethod(IndentingWriter p, int opnum)
        throws IOException
    {
<span class="nc" id="L285">        RemoteClass.Method method = remoteMethods[opnum];</span>
<span class="nc" id="L286">        MethodDoc methodDoc = method.methodDoc();</span>
<span class="nc" id="L287">        String methodName = methodDoc.name();</span>
<span class="nc" id="L288">        Type[] paramTypes = method.parameterTypes();</span>
<span class="nc" id="L289">        String paramNames[] = nameParameters(paramTypes);</span>
<span class="nc" id="L290">        Type returnType = methodDoc.returnType();</span>
<span class="nc" id="L291">        ClassDoc[] exceptions = method.exceptionTypes();</span>

        /*
         * Declare stub method; throw exceptions declared in remote
         * interface(s).
         */
<span class="nc" id="L297">        p.pln(&quot;// implementation of &quot; +</span>
<span class="nc" id="L298">              Util.getFriendlyUnqualifiedSignature(methodDoc));</span>
<span class="nc" id="L299">        p.p(&quot;public &quot; + returnType.toString() + &quot; &quot; + methodName + &quot;(&quot;);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L302">                p.p(&quot;, &quot;);</span>
            }
<span class="nc" id="L304">            p.p(paramTypes[i].toString() + &quot; &quot; + paramNames[i]);</span>
        }
<span class="nc" id="L306">        p.plnI(&quot;)&quot;);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (exceptions.length &gt; 0) {</span>
<span class="nc" id="L308">            p.p(&quot;throws &quot;);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (int i = 0; i &lt; exceptions.length; i++) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L311">                    p.p(&quot;, &quot;);</span>
                }
<span class="nc" id="L313">                p.p(exceptions[i].qualifiedName());</span>
            }
<span class="nc" id="L315">            p.pln();</span>
        }
<span class="nc" id="L317">        p.pOlnI(&quot;{&quot;);</span>

        /*
         * The RemoteRef.invoke methods throw Exception, but unless
         * this stub method throws Exception as well, we must catch
         * Exceptions thrown from the invocation.  So we must catch
         * Exception and rethrow something we can throw:
         * UnexpectedException, which is a subclass of
         * RemoteException.  But for any subclasses of Exception that
         * we can throw, like RemoteException, RuntimeException, and
         * any of the exceptions declared by this stub method, we want
         * them to pass through unmodified, so first we must catch any
         * such exceptions and rethrow them directly.
         *
         * We have to be careful generating the rethrowing catch
         * blocks here, because javac will flag an error if there are
         * any unreachable catch blocks, i.e. if the catch of an
         * exception class follows a previous catch of it or of one of
         * its superclasses.  The following method invocation takes
         * care of these details.
         */
<span class="nc" id="L338">        List&lt;ClassDoc&gt; catchList = computeUniqueCatchList(exceptions);</span>

        /*
         * If we need to catch any particular exceptions (i.e. this method
         * does not declare java.lang.Exception), put the entire stub
         * method in a try block.
         */
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (catchList.size() &gt; 0) {</span>
<span class="nc" id="L346">            p.plnI(&quot;try {&quot;);</span>
        }

<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L350">            p.plnI(&quot;if (useNewInvoke) {&quot;);</span>
        }
<span class="nc bnc" id="L352" title="All 4 branches missed.">        if (version == StubVersion.VCOMPAT ||</span>
            version == StubVersion.V1_2)
        {
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (!Util.isVoid(returnType)) {</span>
<span class="nc" id="L356">                p.p(&quot;Object $result = &quot;);               // REMIND: why $?</span>
            }
<span class="nc" id="L358">            p.p(&quot;ref.invoke(this, &quot; + methodFieldNames[opnum] + &quot;, &quot;);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (paramTypes.length &gt; 0) {</span>
<span class="nc" id="L360">                p.p(&quot;new java.lang.Object[] {&quot;);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">                    if (i &gt; 0)</span>
<span class="nc" id="L363">                        p.p(&quot;, &quot;);</span>
<span class="nc" id="L364">                    p.p(wrapArgumentCode(paramTypes[i], paramNames[i]));</span>
                }
<span class="nc" id="L366">                p.p(&quot;}&quot;);</span>
            } else {
<span class="nc" id="L368">                p.p(&quot;null&quot;);</span>
            }
<span class="nc" id="L370">            p.pln(&quot;, &quot; + method.methodHash() + &quot;L);&quot;);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (!Util.isVoid(returnType)) {</span>
<span class="nc" id="L372">                p.pln(&quot;return &quot; +</span>
<span class="nc" id="L373">                    unwrapArgumentCode(returnType, &quot;$result&quot;) + &quot;;&quot;);</span>
            }
        }
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L377">            p.pOlnI(&quot;} else {&quot;);</span>
        }
<span class="nc bnc" id="L379" title="All 4 branches missed.">        if (version == StubVersion.V1_1 ||</span>
            version == StubVersion.VCOMPAT)
        {
<span class="nc" id="L382">            p.pln(REMOTE_CALL + &quot; call = ref.newCall((&quot; + REMOTE_OBJECT +</span>
                &quot;) this, operations, &quot; + opnum + &quot;, interfaceHash);&quot;);

<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (paramTypes.length &gt; 0) {</span>
<span class="nc" id="L386">                p.plnI(&quot;try {&quot;);</span>
<span class="nc" id="L387">                p.pln(&quot;java.io.ObjectOutput out = call.getOutputStream();&quot;);</span>
<span class="nc" id="L388">                writeMarshalArguments(p, &quot;out&quot;, paramTypes, paramNames);</span>
<span class="nc" id="L389">                p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);</span>
<span class="nc" id="L390">                p.pln(&quot;throw new &quot; + MARSHAL_EXCEPTION +</span>
                    &quot;(\&quot;error marshalling arguments\&quot;, e);&quot;);
<span class="nc" id="L392">                p.pOln(&quot;}&quot;);</span>
            }

<span class="nc" id="L395">            p.pln(&quot;ref.invoke(call);&quot;);</span>

<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (Util.isVoid(returnType)) {</span>
<span class="nc" id="L398">                p.pln(&quot;ref.done(call);&quot;);</span>
            } else {
<span class="nc" id="L400">                p.pln(returnType.toString() + &quot; $result;&quot;);</span>
                                                        // REMIND: why $?
<span class="nc" id="L402">                p.plnI(&quot;try {&quot;);</span>
<span class="nc" id="L403">                p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);</span>
<span class="nc" id="L404">                boolean objectRead =</span>
<span class="nc" id="L405">                    writeUnmarshalArgument(p, &quot;in&quot;, returnType, &quot;$result&quot;);</span>
<span class="nc" id="L406">                p.pln(&quot;;&quot;);</span>
<span class="nc" id="L407">                p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);</span>
<span class="nc" id="L408">                p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +</span>
                    &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
                /*
                 * If any only if readObject has been invoked, we must catch
                 * ClassNotFoundException as well as IOException.
                 */
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (objectRead) {</span>
<span class="nc" id="L415">                    p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);</span>
<span class="nc" id="L416">                    p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +</span>
                        &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
                }
<span class="nc" id="L419">                p.pOlnI(&quot;} finally {&quot;);</span>
<span class="nc" id="L420">                p.pln(&quot;ref.done(call);&quot;);</span>
<span class="nc" id="L421">                p.pOln(&quot;}&quot;);</span>
<span class="nc" id="L422">                p.pln(&quot;return $result;&quot;);</span>
            }
        }
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L426">            p.pOln(&quot;}&quot;);                // end if/else (useNewInvoke) block</span>
        }

        /*
         * If we need to catch any particular exceptions, finally write
         * the catch blocks for them, rethrow any other Exceptions with an
         * UnexpectedException, and end the try block.
         */
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (catchList.size() &gt; 0) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            for (ClassDoc catchClass : catchList) {</span>
<span class="nc" id="L436">                p.pOlnI(&quot;} catch (&quot; + catchClass.qualifiedName() + &quot; e) {&quot;);</span>
<span class="nc" id="L437">                p.pln(&quot;throw e;&quot;);</span>
<span class="nc" id="L438">            }</span>
<span class="nc" id="L439">            p.pOlnI(&quot;} catch (java.lang.Exception e) {&quot;);</span>
<span class="nc" id="L440">            p.pln(&quot;throw new &quot; + UNEXPECTED_EXCEPTION +</span>
                &quot;(\&quot;undeclared checked exception\&quot;, e);&quot;);
<span class="nc" id="L442">            p.pOln(&quot;}&quot;);                // end try/catch block</span>
        }

<span class="nc" id="L445">        p.pOln(&quot;}&quot;);                    // end stub method</span>
<span class="nc" id="L446">    }</span>

    /**
     * Computes the exceptions that need to be caught and rethrown in
     * a stub method before wrapping Exceptions in
     * UnexpectedExceptions, given the exceptions declared in the
     * throws clause of the method.  Returns a list containing the
     * exception to catch.  Each exception is guaranteed to be unique,
     * i.e. not a subclass of any of the other exceptions in the list,
     * so the catch blocks for these exceptions may be generated in
     * any order relative to each other.
     *
     * RemoteException and RuntimeException are each automatically
     * placed in the returned list (unless any of their superclasses
     * are already present), since those exceptions should always be
     * directly rethrown by a stub method.
     *
     * The returned list will be empty if java.lang.Exception or one
     * of its superclasses is in the throws clause of the method,
     * indicating that no exceptions need to be caught.
     **/
    private List&lt;ClassDoc&gt; computeUniqueCatchList(ClassDoc[] exceptions) {
<span class="nc" id="L468">        List&lt;ClassDoc&gt; uniqueList = new ArrayList&lt;ClassDoc&gt;();</span>

<span class="nc" id="L470">        uniqueList.add(env.docRuntimeException());</span>
<span class="nc" id="L471">        uniqueList.add(env.docRemoteException()); // always catch/rethrow these</span>

        /* For each exception declared by the stub method's throws clause: */
    nextException:
<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (ClassDoc ex : exceptions) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (env.docException().subclassOf(ex)) {</span>
                /*
                 * If java.lang.Exception (or a superclass) was declared
                 * in the throws clause of this stub method, then we don't
                 * have to bother catching anything; clear the list and
                 * return.
                 */
<span class="nc" id="L483">                uniqueList.clear();</span>
<span class="nc" id="L484">                break;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            } else if (!ex.subclassOf(env.docException())) {</span>
                /*
                 * Ignore other Throwables that do not extend Exception,
                 * because they cannot be thrown by the invoke methods.
                 */
<span class="nc" id="L490">                continue;</span>
            }
            /*
             * Compare this exception against the current list of
             * exceptions that need to be caught:
             */
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (Iterator&lt;ClassDoc&gt; i = uniqueList.iterator(); i.hasNext();) {</span>
<span class="nc" id="L497">                ClassDoc ex2 = i.next();</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (ex.subclassOf(ex2)) {</span>
                    /*
                     * If a superclass of this exception is already on
                     * the list to catch, then ignore this one and continue;
                     */
<span class="nc" id="L503">                    continue nextException;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                } else if (ex2.subclassOf(ex)) {</span>
                    /*
                     * If a subclass of this exception is on the list
                     * to catch, then remove it;
                     */
<span class="nc" id="L509">                    i.remove();</span>
                }
<span class="nc" id="L511">            }</span>
            /* This exception is unique: add it to the list to catch. */
<span class="nc" id="L513">            uniqueList.add(ex);</span>
        }
<span class="nc" id="L515">        return uniqueList;</span>
    }

    /**
     * Writes the skeleton for the remote class to a stream.
     **/
    void writeSkeleton(IndentingWriter p) throws IOException {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (version == StubVersion.V1_2) {</span>
<span class="nc" id="L523">            throw new AssertionError(</span>
                &quot;should not generate skeleton for version &quot; + version);
        }

        /*
         * Write boiler plate comment.
         */
<span class="nc" id="L530">        p.pln(&quot;// Skeleton class generated by rmic, do not edit.&quot;);</span>
<span class="nc" id="L531">        p.pln(&quot;// Contents subject to change without notice.&quot;);</span>
<span class="nc" id="L532">        p.pln();</span>

        /*
         * If remote implementation class was in a particular package,
         * declare the skeleton class to be in the same package.
         */
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (!packageName.equals(&quot;&quot;)) {</span>
<span class="nc" id="L539">            p.pln(&quot;package &quot; + packageName + &quot;;&quot;);</span>
<span class="nc" id="L540">            p.pln();</span>
        }

        /*
         * Declare the skeleton class.
         */
<span class="nc" id="L546">        p.plnI(&quot;public final class &quot; + skeletonClassSimpleName);</span>
<span class="nc" id="L547">        p.pln(&quot;implements &quot; + SKELETON);</span>
<span class="nc" id="L548">        p.pOlnI(&quot;{&quot;);</span>

<span class="nc" id="L550">        writeOperationsArray(p);</span>
<span class="nc" id="L551">        p.pln();</span>

<span class="nc" id="L553">        writeInterfaceHash(p);</span>
<span class="nc" id="L554">        p.pln();</span>

        /*
         * Define the getOperations() method.
         */
<span class="nc" id="L559">        p.plnI(&quot;public &quot; + OPERATION + &quot;[] getOperations() {&quot;);</span>
<span class="nc" id="L560">        p.pln(&quot;return (&quot; + OPERATION + &quot;[]) operations.clone();&quot;);</span>
<span class="nc" id="L561">        p.pOln(&quot;}&quot;);</span>
<span class="nc" id="L562">        p.pln();</span>

        /*
         * Define the dispatch() method.
         */
<span class="nc" id="L567">        p.plnI(&quot;public void dispatch(&quot; + REMOTE + &quot; obj, &quot; +</span>
            REMOTE_CALL + &quot; call, int opnum, long hash)&quot;);
<span class="nc" id="L569">        p.pln(&quot;throws java.lang.Exception&quot;);</span>
<span class="nc" id="L570">        p.pOlnI(&quot;{&quot;);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L573">            p.plnI(&quot;if (opnum &lt; 0) {&quot;);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (remoteMethods.length &gt; 0) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                    if (opnum &gt; 0)</span>
<span class="nc" id="L577">                        p.pO(&quot;} else &quot;);</span>
<span class="nc" id="L578">                    p.plnI(&quot;if (hash == &quot; +</span>
<span class="nc" id="L579">                        remoteMethods[opnum].methodHash() + &quot;L) {&quot;);</span>
<span class="nc" id="L580">                    p.pln(&quot;opnum = &quot; + opnum + &quot;;&quot;);</span>
                }
<span class="nc" id="L582">                p.pOlnI(&quot;} else {&quot;);</span>
            }
            /*
             * Skeleton throws UnmarshalException if it does not recognize
             * the method hash; this is what UnicastServerRef.dispatch()
             * would do.
             */
<span class="nc" id="L589">            p.pln(&quot;throw new &quot; +</span>
                UNMARSHAL_EXCEPTION + &quot;(\&quot;invalid method hash\&quot;);&quot;);
<span class="nc bnc" id="L591" title="All 2 branches missed.">            if (remoteMethods.length &gt; 0) {</span>
<span class="nc" id="L592">                p.pOln(&quot;}&quot;);</span>
            }
            /*
             * Ignore the validation of the interface hash if the
             * operation number was negative, since it is really a
             * method hash instead.
             */
<span class="nc" id="L599">            p.pOlnI(&quot;} else {&quot;);</span>
        }

<span class="nc" id="L602">        p.plnI(&quot;if (hash != interfaceHash)&quot;);</span>
<span class="nc" id="L603">        p.pln(&quot;throw new &quot; +</span>
            SKELETON_MISMATCH_EXCEPTION + &quot;(\&quot;interface hash mismatch\&quot;);&quot;);
<span class="nc" id="L605">        p.pO();</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (version == StubVersion.VCOMPAT) {</span>
<span class="nc" id="L608">            p.pOln(&quot;}&quot;);                // end if/else (opnum &lt; 0) block</span>
        }
<span class="nc" id="L610">        p.pln();</span>

        /*
         * Cast remote object reference to the remote implementation
         * class, if it's not private.  We don't use the binary name
         * of the class like previous implementations did because that
         * would not compile with javac (since 1.4.1).  If the remote
         * implementation class is private, then we can't cast to it
         * like previous implementations did because that also would
         * not compile with javac-- so instead, we'll have to try to
         * cast to the remote interface for each remote method.
         */
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (!remoteClass.classDoc().isPrivate()) {</span>
<span class="nc" id="L623">            p.pln(remoteClass.classDoc().qualifiedName() + &quot; server = (&quot; +</span>
<span class="nc" id="L624">                  remoteClass.classDoc().qualifiedName() + &quot;) obj;&quot;);</span>
        }

        /*
         * Process call according to the operation number.
         */
<span class="nc" id="L630">        p.plnI(&quot;switch (opnum) {&quot;);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">        for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {</span>
<span class="nc" id="L632">            writeSkeletonDispatchCase(p, opnum);</span>
        }
<span class="nc" id="L634">        p.pOlnI(&quot;default:&quot;);</span>
        /*
         * Skeleton throws UnmarshalException if it does not recognize
         * the operation number; this is consistent with the case of an
         * unrecognized method hash.
         */
<span class="nc" id="L640">        p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +</span>
            &quot;(\&quot;invalid method number\&quot;);&quot;);
<span class="nc" id="L642">        p.pOln(&quot;}&quot;);                    // end switch statement</span>

<span class="nc" id="L644">        p.pOln(&quot;}&quot;);                    // end dispatch() method</span>

<span class="nc" id="L646">        p.pOln(&quot;}&quot;);                    // end skeleton class</span>
<span class="nc" id="L647">    }</span>

    /**
     * Writes the case block for the skeleton's dispatch method for
     * the remote method with the given &quot;opnum&quot;.
     **/
    private void writeSkeletonDispatchCase(IndentingWriter p, int opnum)
        throws IOException
    {
<span class="nc" id="L656">        RemoteClass.Method method = remoteMethods[opnum];</span>
<span class="nc" id="L657">        MethodDoc methodDoc = method.methodDoc();</span>
<span class="nc" id="L658">        String methodName = methodDoc.name();</span>
<span class="nc" id="L659">        Type paramTypes[] = method.parameterTypes();</span>
<span class="nc" id="L660">        String paramNames[] = nameParameters(paramTypes);</span>
<span class="nc" id="L661">        Type returnType = methodDoc.returnType();</span>

<span class="nc" id="L663">        p.pOlnI(&quot;case &quot; + opnum + &quot;: // &quot; +</span>
<span class="nc" id="L664">            Util.getFriendlyUnqualifiedSignature(methodDoc));</span>
        /*
         * Use nested block statement inside case to provide an independent
         * namespace for local variables used to unmarshal parameters for
         * this remote method.
         */
<span class="nc" id="L670">        p.pOlnI(&quot;{&quot;);</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (paramTypes.length &gt; 0) {</span>
            /*
             * Declare local variables to hold arguments.
             */
<span class="nc bnc" id="L676" title="All 2 branches missed.">            for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="nc" id="L677">                p.pln(paramTypes[i].toString() + &quot; &quot; + paramNames[i] + &quot;;&quot;);</span>
            }

            /*
             * Unmarshal arguments from call stream.
             */
<span class="nc" id="L683">            p.plnI(&quot;try {&quot;);</span>
<span class="nc" id="L684">            p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);</span>
<span class="nc" id="L685">            boolean objectsRead = writeUnmarshalArguments(p, &quot;in&quot;,</span>
                paramTypes, paramNames);
<span class="nc" id="L687">            p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);</span>
<span class="nc" id="L688">            p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +</span>
                &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
            /*
             * If any only if readObject has been invoked, we must catch
             * ClassNotFoundException as well as IOException.
             */
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if (objectsRead) {</span>
<span class="nc" id="L695">                p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);</span>
<span class="nc" id="L696">                p.pln(&quot;throw new &quot; + UNMARSHAL_EXCEPTION +</span>
                    &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
            }
<span class="nc" id="L699">            p.pOlnI(&quot;} finally {&quot;);</span>
<span class="nc" id="L700">            p.pln(&quot;call.releaseInputStream();&quot;);</span>
<span class="nc" id="L701">            p.pOln(&quot;}&quot;);</span>
<span class="nc" id="L702">        } else {</span>
<span class="nc" id="L703">            p.pln(&quot;call.releaseInputStream();&quot;);</span>
        }

<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (!Util.isVoid(returnType)) {</span>
            /*
             * Declare variable to hold return type, if not void.
             */
<span class="nc" id="L710">            p.p(returnType.toString() + &quot; $result = &quot;);</span>
                                                        // REMIND: why $?
        }

        /*
         * Invoke the method on the server object.  If the remote
         * implementation class is private, then we don't have a
         * reference cast to it, and so we try to cast to the remote
         * object reference to the method's declaring interface here.
         */
<span class="nc bnc" id="L720" title="All 2 branches missed.">        String target = remoteClass.classDoc().isPrivate() ?</span>
<span class="nc" id="L721">            &quot;((&quot; + methodDoc.containingClass().qualifiedName() + &quot;) obj)&quot; :</span>
            &quot;server&quot;;
<span class="nc" id="L723">        p.p(target + &quot;.&quot; + methodName + &quot;(&quot;);</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (int i = 0; i &lt; paramNames.length; i++) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L726">                p.p(&quot;, &quot;);</span>
<span class="nc" id="L727">            p.p(paramNames[i]);</span>
        }
<span class="nc" id="L729">        p.pln(&quot;);&quot;);</span>

        /*
         * Always invoke getResultStream(true) on the call object to send
         * the indication of a successful invocation to the caller.  If
         * the return type is not void, keep the result stream and marshal
         * the return value.
         */
<span class="nc" id="L737">        p.plnI(&quot;try {&quot;);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (!Util.isVoid(returnType)) {</span>
<span class="nc" id="L739">            p.p(&quot;java.io.ObjectOutput out = &quot;);</span>
        }
<span class="nc" id="L741">        p.pln(&quot;call.getResultStream(true);&quot;);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (!Util.isVoid(returnType)) {</span>
<span class="nc" id="L743">            writeMarshalArgument(p, &quot;out&quot;, returnType, &quot;$result&quot;);</span>
<span class="nc" id="L744">            p.pln(&quot;;&quot;);</span>
        }
<span class="nc" id="L746">        p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);</span>
<span class="nc" id="L747">        p.pln(&quot;throw new &quot; +</span>
            MARSHAL_EXCEPTION + &quot;(\&quot;error marshalling return\&quot;, e);&quot;);
<span class="nc" id="L749">        p.pOln(&quot;}&quot;);</span>

<span class="nc" id="L751">        p.pln(&quot;break;&quot;);                // break from switch statement</span>

<span class="nc" id="L753">        p.pOlnI(&quot;}&quot;);                   // end nested block statement</span>
<span class="nc" id="L754">        p.pln();</span>
<span class="nc" id="L755">    }</span>

    /**
     * Writes declaration and initializer for &quot;operations&quot; static array.
     **/
    private void writeOperationsArray(IndentingWriter p)
        throws IOException
    {
<span class="nc" id="L763">        p.plnI(&quot;private static final &quot; + OPERATION + &quot;[] operations = {&quot;);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        for (int i = 0; i &lt; remoteMethods.length; i++) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L766">                p.pln(&quot;,&quot;);</span>
<span class="nc" id="L767">            p.p(&quot;new &quot; + OPERATION + &quot;(\&quot;&quot; +</span>
<span class="nc" id="L768">                remoteMethods[i].operationString() + &quot;\&quot;)&quot;);</span>
        }
<span class="nc" id="L770">        p.pln();</span>
<span class="nc" id="L771">        p.pOln(&quot;};&quot;);</span>
<span class="nc" id="L772">    }</span>

    /**
     * Writes declaration and initializer for &quot;interfaceHash&quot; static field.
     **/
    private void writeInterfaceHash(IndentingWriter p)
        throws IOException
    {
<span class="nc" id="L780">        p.pln(&quot;private static final long interfaceHash = &quot; +</span>
<span class="nc" id="L781">            remoteClass.interfaceHash() + &quot;L;&quot;);</span>
<span class="nc" id="L782">    }</span>

    /**
     * Writes declaration for java.lang.reflect.Method static fields
     * corresponding to each remote method in a stub.
     **/
    private void writeMethodFieldDeclarations(IndentingWriter p)
        throws IOException
    {
<span class="nc bnc" id="L791" title="All 2 branches missed.">        for (String name : methodFieldNames) {</span>
<span class="nc" id="L792">            p.pln(&quot;private static java.lang.reflect.Method &quot; + name + &quot;;&quot;);</span>
        }
<span class="nc" id="L794">    }</span>

    /**
     * Writes code to initialize the static fields for each method
     * using the Java Reflection API.
     **/
    private void writeMethodFieldInitializers(IndentingWriter p)
        throws IOException
    {
<span class="nc bnc" id="L803" title="All 2 branches missed.">        for (int i = 0; i &lt; methodFieldNames.length; i++) {</span>
<span class="nc" id="L804">            p.p(methodFieldNames[i] + &quot; = &quot;);</span>
            /*
             * Look up the Method object in the somewhat arbitrary
             * interface that we find in the Method object.
             */
<span class="nc" id="L809">            RemoteClass.Method method = remoteMethods[i];</span>
<span class="nc" id="L810">            MethodDoc methodDoc = method.methodDoc();</span>
<span class="nc" id="L811">            String methodName = methodDoc.name();</span>
<span class="nc" id="L812">            Type paramTypes[] = method.parameterTypes();</span>

<span class="nc" id="L814">            p.p(methodDoc.containingClass().qualifiedName() + &quot;.class.getMethod(\&quot;&quot; +</span>
                methodName + &quot;\&quot;, new java.lang.Class[] {&quot;);
<span class="nc bnc" id="L816" title="All 2 branches missed.">            for (int j = 0; j &lt; paramTypes.length; j++) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (j &gt; 0)</span>
<span class="nc" id="L818">                    p.p(&quot;, &quot;);</span>
<span class="nc" id="L819">                p.p(paramTypes[j].toString() + &quot;.class&quot;);</span>
            }
<span class="nc" id="L821">            p.pln(&quot;});&quot;);</span>
        }
<span class="nc" id="L823">    }</span>


    /*
     * Following are a series of static utility methods useful during
     * the code generation process:
     */

    /**
     * Generates an array of names for fields correspondins to the
     * given array of remote methods.  Each name in the returned array
     * is guaranteed to be unique.
     *
     * The name of a method is included in its corresponding field
     * name to enhance readability of the generated code.
     **/
    private static String[] nameMethodFields(RemoteClass.Method[] methods) {
<span class="nc" id="L840">        String[] names = new String[methods.length];</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc" id="L842">            names[i] = &quot;$method_&quot; + methods[i].methodDoc().name() + &quot;_&quot; + i;</span>
        }
<span class="nc" id="L844">        return names;</span>
    }

    /**
     * Generates an array of names for parameters corresponding to the
     * given array of types for the parameters.  Each name in the
     * returned array is guaranteed to be unique.
     *
     * A representation of the type of a parameter is included in its
     * corresponding parameter name to enhance the readability of the
     * generated code.
     **/
    private static String[] nameParameters(Type[] types) {
<span class="nc" id="L857">        String[] names = new String[types.length];</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc" id="L859">            names[i] = &quot;$param_&quot; +</span>
<span class="nc" id="L860">                generateNameFromType(types[i]) + &quot;_&quot; + (i + 1);</span>
        }
<span class="nc" id="L862">        return names;</span>
    }

    /**
     * Generates a readable string representing the given type
     * suitable for embedding within a Java identifier.
     **/
    private static String generateNameFromType(Type type) {
<span class="nc" id="L870">        String name = type.typeName().replace('.', '$');</span>
<span class="nc" id="L871">        int dimensions = type.dimension().length() / 2;</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">        for (int i = 0; i &lt; dimensions; i++) {</span>
<span class="nc" id="L873">            name = &quot;arrayOf_&quot; + name;</span>
        }
<span class="nc" id="L875">        return name;</span>
    }

    /**
     * Writes a snippet of Java code to marshal a value named &quot;name&quot;
     * of type &quot;type&quot; to the java.io.ObjectOutput stream named
     * &quot;stream&quot;.
     *
     * Primitive types are marshalled with their corresponding methods
     * in the java.io.DataOutput interface, and objects (including
     * arrays) are marshalled using the writeObject method.
     **/
    private static void writeMarshalArgument(IndentingWriter p,
                                             String streamName,
                                             Type type, String name)
        throws IOException
    {
<span class="nc bnc" id="L892" title="All 4 branches missed.">        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {</span>
<span class="nc" id="L893">            p.p(streamName + &quot;.writeObject(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;boolean&quot;)) {</span>
<span class="nc" id="L895">            p.p(streamName + &quot;.writeBoolean(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;byte&quot;)) {</span>
<span class="nc" id="L897">            p.p(streamName + &quot;.writeByte(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;char&quot;)) {</span>
<span class="nc" id="L899">            p.p(streamName + &quot;.writeChar(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;short&quot;)) {</span>
<span class="nc" id="L901">            p.p(streamName + &quot;.writeShort(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;int&quot;)) {</span>
<span class="nc" id="L903">            p.p(streamName + &quot;.writeInt(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;long&quot;)) {</span>
<span class="nc" id="L905">            p.p(streamName + &quot;.writeLong(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;float&quot;)) {</span>
<span class="nc" id="L907">            p.p(streamName + &quot;.writeFloat(&quot; + name + &quot;)&quot;);</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;double&quot;)) {</span>
<span class="nc" id="L909">            p.p(streamName + &quot;.writeDouble(&quot; + name + &quot;)&quot;);</span>
        } else {
<span class="nc" id="L911">            throw new AssertionError(type);</span>
        }
<span class="nc" id="L913">    }</span>

    /**
     * Writes Java statements to marshal a series of values in order
     * as named in the &quot;names&quot; array, with types as specified in the
     * &quot;types&quot; array, to the java.io.ObjectOutput stream named
     * &quot;stream&quot;.
     **/
    private static void writeMarshalArguments(IndentingWriter p,
                                              String streamName,
                                              Type[] types, String[] names)
        throws IOException
    {
<span class="nc bnc" id="L926" title="All 4 branches missed.">        assert types.length == names.length;</span>

<span class="nc bnc" id="L928" title="All 2 branches missed.">        for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L929">            writeMarshalArgument(p, streamName, types[i], names[i]);</span>
<span class="nc" id="L930">            p.pln(&quot;;&quot;);</span>
        }
<span class="nc" id="L932">    }</span>

    /**
     * Writes a snippet of Java code to unmarshal a value of type
     * &quot;type&quot; from the java.io.ObjectInput stream named &quot;stream&quot; into
     * a variable named &quot;name&quot; (if &quot;name&quot; is null, the value is
     * unmarshalled and discarded).
     *
     * Primitive types are unmarshalled with their corresponding
     * methods in the java.io.DataInput interface, and objects
     * (including arrays) are unmarshalled using the readObject
     * method.
     *
     * Returns true if code to invoke readObject was written, and
     * false otherwise.
     **/
    private static boolean writeUnmarshalArgument(IndentingWriter p,
                                                  String streamName,
                                                  Type type, String name)
        throws IOException
    {
<span class="nc" id="L953">        boolean readObject = false;</span>

<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L956">            p.p(name + &quot; = &quot;);</span>
        }

<span class="nc bnc" id="L959" title="All 4 branches missed.">        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {</span>
<span class="nc" id="L960">            p.p(&quot;(&quot; + type.toString() + &quot;) &quot; + streamName + &quot;.readObject()&quot;);</span>
<span class="nc" id="L961">            readObject = true;</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;boolean&quot;)) {</span>
<span class="nc" id="L963">            p.p(streamName + &quot;.readBoolean()&quot;);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;byte&quot;)) {</span>
<span class="nc" id="L965">            p.p(streamName + &quot;.readByte()&quot;);</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;char&quot;)) {</span>
<span class="nc" id="L967">            p.p(streamName + &quot;.readChar()&quot;);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;short&quot;)) {</span>
<span class="nc" id="L969">            p.p(streamName + &quot;.readShort()&quot;);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;int&quot;)) {</span>
<span class="nc" id="L971">            p.p(streamName + &quot;.readInt()&quot;);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;long&quot;)) {</span>
<span class="nc" id="L973">            p.p(streamName + &quot;.readLong()&quot;);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;float&quot;)) {</span>
<span class="nc" id="L975">            p.p(streamName + &quot;.readFloat()&quot;);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;double&quot;)) {</span>
<span class="nc" id="L977">            p.p(streamName + &quot;.readDouble()&quot;);</span>
        } else {
<span class="nc" id="L979">            throw new AssertionError(type);</span>
        }

<span class="nc" id="L982">        return readObject;</span>
    }

    /**
     * Writes Java statements to unmarshal a series of values in order
     * of types as in the &quot;types&quot; array from the java.io.ObjectInput
     * stream named &quot;stream&quot; into variables as named in &quot;names&quot; (for
     * any element of &quot;names&quot; that is null, the corresponding value is
     * unmarshalled and discarded).
     **/
    private static boolean writeUnmarshalArguments(IndentingWriter p,
                                                   String streamName,
                                                   Type[] types,
                                                   String[] names)
        throws IOException
    {
<span class="nc bnc" id="L998" title="All 4 branches missed.">        assert types.length == names.length;</span>

<span class="nc" id="L1000">        boolean readObject = false;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">            if (writeUnmarshalArgument(p, streamName, types[i], names[i])) {</span>
<span class="nc" id="L1003">                readObject = true;</span>
            }
<span class="nc" id="L1005">            p.pln(&quot;;&quot;);</span>
        }
<span class="nc" id="L1007">        return readObject;</span>
    }

    /**
     * Returns a snippet of Java code to wrap a value named &quot;name&quot; of
     * type &quot;type&quot; into an object as appropriate for use by the Java
     * Reflection API.
     *
     * For primitive types, an appropriate wrapper class is
     * instantiated with the primitive value.  For object types
     * (including arrays), no wrapping is necessary, so the value is
     * named directly.
     **/
    private static String wrapArgumentCode(Type type, String name) {
<span class="nc bnc" id="L1021" title="All 4 branches missed.">        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {</span>
<span class="nc" id="L1022">            return name;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;boolean&quot;)) {</span>
<span class="nc" id="L1024">            return (&quot;(&quot; + name +</span>
                    &quot; ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE)&quot;);
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;byte&quot;)) {</span>
<span class="nc" id="L1027">            return &quot;new java.lang.Byte(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;char&quot;)) {</span>
<span class="nc" id="L1029">            return &quot;new java.lang.Character(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;short&quot;)) {</span>
<span class="nc" id="L1031">            return &quot;new java.lang.Short(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;int&quot;)) {</span>
<span class="nc" id="L1033">            return &quot;new java.lang.Integer(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;long&quot;)) {</span>
<span class="nc" id="L1035">            return &quot;new java.lang.Long(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;float&quot;)) {</span>
<span class="nc" id="L1037">            return &quot;new java.lang.Float(&quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;double&quot;)) {</span>
<span class="nc" id="L1039">            return &quot;new java.lang.Double(&quot; + name + &quot;)&quot;;</span>
        } else {
<span class="nc" id="L1041">            throw new AssertionError(type);</span>
        }
    }

    /**
     * Returns a snippet of Java code to unwrap a value named &quot;name&quot;
     * into a value of type &quot;type&quot;, as appropriate for the Java
     * Reflection API.
     *
     * For primitive types, the value is assumed to be of the
     * corresponding wrapper class, and a method is called on the
     * wrapper to retrieve the primitive value.  For object types
     * (include arrays), no unwrapping is necessary; the value is
     * simply cast to the expected real object type.
     **/
    private static String unwrapArgumentCode(Type type, String name) {
<span class="nc bnc" id="L1057" title="All 4 branches missed.">        if (type.dimension().length() &gt; 0 || type.asClassDoc() != null) {</span>
<span class="nc" id="L1058">            return &quot;((&quot; + type.toString() + &quot;) &quot; + name + &quot;)&quot;;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;boolean&quot;)) {</span>
<span class="nc" id="L1060">            return &quot;((java.lang.Boolean) &quot; + name + &quot;).booleanValue()&quot;;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;byte&quot;)) {</span>
<span class="nc" id="L1062">            return &quot;((java.lang.Byte) &quot; + name + &quot;).byteValue()&quot;;</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;char&quot;)) {</span>
<span class="nc" id="L1064">            return &quot;((java.lang.Character) &quot; + name + &quot;).charValue()&quot;;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;short&quot;)) {</span>
<span class="nc" id="L1066">            return &quot;((java.lang.Short) &quot; + name + &quot;).shortValue()&quot;;</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;int&quot;)) {</span>
<span class="nc" id="L1068">            return &quot;((java.lang.Integer) &quot; + name + &quot;).intValue()&quot;;</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;long&quot;)) {</span>
<span class="nc" id="L1070">            return &quot;((java.lang.Long) &quot; + name + &quot;).longValue()&quot;;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;float&quot;)) {</span>
<span class="nc" id="L1072">            return &quot;((java.lang.Float) &quot; + name + &quot;).floatValue()&quot;;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">        } else if (type.typeName().equals(&quot;double&quot;)) {</span>
<span class="nc" id="L1074">            return &quot;((java.lang.Double) &quot; + name + &quot;).doubleValue()&quot;;</span>
        } else {
<span class="nc" id="L1076">            throw new AssertionError(type);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>