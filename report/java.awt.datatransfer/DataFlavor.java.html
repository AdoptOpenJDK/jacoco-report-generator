<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DataFlavor.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.datatransfer</a> &gt; <span class="el_source">DataFlavor.java</span></div><h1>DataFlavor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.datatransfer;

import java.io.*;
import java.nio.*;
import java.util.*;

import sun.awt.datatransfer.DataTransferer;
import sun.reflect.misc.ReflectUtil;

import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;

/**
 * A {@code DataFlavor} provides meta information about data. {@code DataFlavor}
 * is typically used to access data on the clipboard, or during
 * a drag and drop operation.
 * &lt;p&gt;
 * An instance of {@code DataFlavor} encapsulates a content type as
 * defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
 * and &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;.
 * A content type is typically referred to as a MIME type.
 * &lt;p&gt;
 * A content type consists of a media type (referred
 * to as the primary type), a subtype, and optional parameters. See
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt;
 * for details on the syntax of a MIME type.
 * &lt;p&gt;
 * The JRE data transfer implementation interprets the parameter &amp;quot;class&amp;quot;
 * of a MIME type as &lt;B&gt;a representation class&lt;/b&gt;.
 * The representation class reflects the class of the object being
 * transferred. In other words, the representation class is the type of
 * object returned by {@link Transferable#getTransferData}.
 * For example, the MIME type of {@link #imageFlavor} is
 * {@code &quot;image/x-java-image;class=java.awt.Image&quot;},
 * the primary type is {@code image}, the subtype is
 * {@code x-java-image}, and the representation class is
 * {@code java.awt.Image}. When {@code getTransferData} is invoked
 * with a {@code DataFlavor} of {@code imageFlavor}, an instance of
 * {@code java.awt.Image} is returned.
 * It's important to note that {@code DataFlavor} does no error checking
 * against the representation class. It is up to consumers of
 * {@code DataFlavor}, such as {@code Transferable}, to honor the representation
 * class.
 * &lt;br&gt;
 * Note, if you do not specify a representation class when
 * creating a {@code DataFlavor}, the default
 * representation class is used. See appropriate documentation for
 * {@code DataFlavor}'s constructors.
 * &lt;p&gt;
 * Also, {@code DataFlavor} instances with the &amp;quot;text&amp;quot; primary
 * MIME type may have a &amp;quot;charset&amp;quot; parameter. Refer to
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt; and
 * {@link #selectBestTextFlavor} for details on &amp;quot;text&amp;quot; MIME types
 * and the &amp;quot;charset&amp;quot; parameter.
 * &lt;p&gt;
 * Equality of {@code DataFlavors} is determined by the primary type,
 * subtype, and representation class. Refer to {@link #equals(DataFlavor)} for
 * details. When determining equality, any optional parameters are ignored.
 * For example, the following produces two {@code DataFlavors} that
 * are considered identical:
 * &lt;pre&gt;
 *   DataFlavor flavor1 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; foo=bar&amp;quot;);
 *   DataFlavor flavor2 = new DataFlavor(Object.class, &amp;quot;X-test/test; class=&amp;lt;java.lang.Object&amp;gt;; x=y&amp;quot;);
 *   // The following returns true.
 *   flavor1.equals(flavor2);
 * &lt;/pre&gt;
 * As mentioned, {@code flavor1} and {@code flavor2} are considered identical.
 * As such, asking a {@code Transferable} for either {@code DataFlavor} returns
 * the same results.
 * &lt;p&gt;
 * For more information on the using data transfer with Swing see
 * the &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html&quot;&gt;
 * How to Use Drag and Drop and Data Transfer&lt;/a&gt;,
 * section in &lt;em&gt;Java Tutorial&lt;/em&gt;.
 *
 * @author      Blake Sullivan
 * @author      Laurence P. G. Cable
 * @author      Jeff Dunn
 */
public class DataFlavor implements Externalizable, Cloneable {

    private static final long serialVersionUID = 8367026044764648243L;
<span class="nc" id="L107">    private static final Class&lt;InputStream&gt; ioInputStreamClass = InputStream.class;</span>

    /**
     * Tries to load a class from: the bootstrap loader, the system loader,
     * the context loader (if one is present) and finally the loader specified.
     *
     * @param className the name of the class to be loaded
     * @param fallback the fallback loader
     * @return the class loaded
     * @exception ClassNotFoundException if class is not found
     */
    protected final static Class&lt;?&gt; tryToLoadClass(String className,
                                                   ClassLoader fallback)
        throws ClassNotFoundException
    {
<span class="nc" id="L122">        ReflectUtil.checkPackageAccess(className);</span>
        try {
<span class="nc" id="L124">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L126">                sm.checkPermission(GET_CLASSLOADER_PERMISSION);</span>
            }
<span class="nc" id="L128">            ClassLoader loader = ClassLoader.getSystemClassLoader();</span>
            try {
                // bootstrap class loader and system class loader if present
<span class="nc" id="L131">                return Class.forName(className, true, loader);</span>
            }
<span class="nc" id="L133">            catch (ClassNotFoundException exception) {</span>
                // thread context class loader if and only if present
<span class="nc" id="L135">                loader = Thread.currentThread().getContextClassLoader();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">                if (loader != null) {</span>
                    try {
<span class="nc" id="L138">                        return Class.forName(className, true, loader);</span>
                    }
<span class="nc" id="L140">                    catch (ClassNotFoundException e) {</span>
                        // fallback to user's class loader
                    }
                }
            }
<span class="nc" id="L145">        } catch (SecurityException exception) {</span>
            // ignore secured class loaders
<span class="nc" id="L147">        }</span>
<span class="nc" id="L148">        return Class.forName(className, true, fallback);</span>
    }

    /*
     * private initializer
     */
    static private DataFlavor createConstant(Class&lt;?&gt; rc, String prn) {
        try {
<span class="nc" id="L156">            return new DataFlavor(rc, prn);</span>
<span class="nc" id="L157">        } catch (Exception e) {</span>
<span class="nc" id="L158">            return null;</span>
        }
    }

    /*
     * private initializer
     */
    static private DataFlavor createConstant(String mt, String prn) {
        try {
<span class="nc" id="L167">            return new DataFlavor(mt, prn);</span>
<span class="nc" id="L168">        } catch (Exception e) {</span>
<span class="nc" id="L169">            return null;</span>
        }
    }

    /*
     * private initializer
     */
    static private DataFlavor initHtmlDataFlavor(String htmlFlavorType) {
        try {
<span class="nc" id="L178">            return new DataFlavor (&quot;text/html; class=java.lang.String;document=&quot; +</span>
                                       htmlFlavorType + &quot;;charset=Unicode&quot;);
<span class="nc" id="L180">        } catch (Exception e) {</span>
<span class="nc" id="L181">            return null;</span>
        }
    }

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Unicode String class,
     * where:
     * &lt;pre&gt;
     *     representationClass = java.lang.String
     *     mimeType           = &quot;application/x-java-serialized-object&quot;
     * &lt;/pre&gt;
     */
<span class="nc" id="L193">    public static final DataFlavor stringFlavor = createConstant(java.lang.String.class, &quot;Unicode String&quot;);</span>

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing a Java Image class,
     * where:
     * &lt;pre&gt;
     *     representationClass = java.awt.Image
     *     mimeType            = &quot;image/x-java-image&quot;
     * &lt;/pre&gt;
     */
<span class="nc" id="L203">    public static final DataFlavor imageFlavor = createConstant(&quot;image/x-java-image; class=java.awt.Image&quot;, &quot;Image&quot;);</span>

    /**
     * The &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
     * encoding, where:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = &quot;text/plain; charset=unicode&quot;
     * &lt;/pre&gt;
     * This &lt;code&gt;DataFlavor&lt;/code&gt; has been &lt;b&gt;deprecated&lt;/b&gt; because
     * (1) Its representation is an InputStream, an 8-bit based representation,
     * while Unicode is a 16-bit character set; and (2) The charset &quot;unicode&quot;
     * is not well-defined. &quot;unicode&quot; implies a particular platform's
     * implementation of Unicode, not a cross-platform implementation.
     *
     * @deprecated as of 1.3. Use &lt;code&gt;DataFlavor.getReaderForText(Transferable)&lt;/code&gt;
     *             instead of &lt;code&gt;Transferable.getTransferData(DataFlavor.plainTextFlavor)&lt;/code&gt;.
     */
    @Deprecated
<span class="nc" id="L222">    public static final DataFlavor plainTextFlavor = createConstant(&quot;text/plain; charset=unicode; class=java.io.InputStream&quot;, &quot;Plain Text&quot;);</span>

    /**
     * A MIME Content-Type of application/x-java-serialized-object represents
     * a graph of Java object(s) that have been made persistent.
     *
     * The representation class associated with this &lt;code&gt;DataFlavor&lt;/code&gt;
     * identifies the Java type of an object returned as a reference
     * from an invocation &lt;code&gt;java.awt.datatransfer.getTransferData&lt;/code&gt;.
     */
    public static final String javaSerializedObjectMimeType = &quot;application/x-java-serialized-object&quot;;

    /**
     * To transfer a list of files to/from Java (and the underlying
     * platform) a &lt;code&gt;DataFlavor&lt;/code&gt; of this type/subtype and
     * representation class of &lt;code&gt;java.util.List&lt;/code&gt; is used.
     * Each element of the list is required/guaranteed to be of type
     * &lt;code&gt;java.io.File&lt;/code&gt;.
     */
<span class="nc" id="L241">    public static final DataFlavor javaFileListFlavor = createConstant(&quot;application/x-java-file-list;class=java.util.List&quot;, null);</span>

    /**
     * To transfer a reference to an arbitrary Java object reference that
     * has no associated MIME Content-type, across a &lt;code&gt;Transferable&lt;/code&gt;
     * interface WITHIN THE SAME JVM, a &lt;code&gt;DataFlavor&lt;/code&gt;
     * with this type/subtype is used, with a &lt;code&gt;representationClass&lt;/code&gt;
     * equal to the type of the class/interface being passed across the
     * &lt;code&gt;Transferable&lt;/code&gt;.
     * &lt;p&gt;
     * The object reference returned from
     * &lt;code&gt;Transferable.getTransferData&lt;/code&gt; for a &lt;code&gt;DataFlavor&lt;/code&gt;
     * with this MIME Content-Type is required to be
     * an instance of the representation Class of the &lt;code&gt;DataFlavor&lt;/code&gt;.
     */
    public static final String javaJVMLocalObjectMimeType = &quot;application/x-java-jvm-local-objectref&quot;;

    /**
     * In order to pass a live link to a Remote object via a Drag and Drop
     * &lt;code&gt;ACTION_LINK&lt;/code&gt; operation a Mime Content Type of
     * application/x-java-remote-object should be used,
     * where the representation class of the &lt;code&gt;DataFlavor&lt;/code&gt;
     * represents the type of the &lt;code&gt;Remote&lt;/code&gt; interface to be
     * transferred.
     */
    public static final String javaRemoteObjectMimeType = &quot;application/x-java-remote-object&quot;;

    /**
     * Represents a piece of an HTML markup. The markup consists of the part
     * selected on the source side. Therefore some tags in the markup may be
     * unpaired. If the flavor is used to represent the data in
     * a {@link Transferable} instance, no additional changes will be made.
     * This DataFlavor instance represents the same HTML markup as DataFlavor
     * instances which content MIME type does not contain document parameter
     * and representation class is the String class.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
<span class="nc" id="L281">    public static DataFlavor selectionHtmlFlavor = initHtmlDataFlavor(&quot;selection&quot;);</span>

    /**
     * Represents a piece of an HTML markup. If possible, the markup received
     * from a native system is supplemented with pair tags to be
     * a well-formed HTML markup. If the flavor is used to represent the data in
     * a {@link Transferable} instance, no additional changes will be made.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
<span class="nc" id="L293">    public static DataFlavor fragmentHtmlFlavor = initHtmlDataFlavor(&quot;fragment&quot;);</span>

    /**
     * Represents a piece of an HTML markup. If possible, the markup
     * received from a native system is supplemented with additional
     * tags to make up a well-formed HTML document. If the flavor is used to
     * represent the data in a {@link Transferable} instance,
     * no additional changes will be made.
     * &lt;pre&gt;
     *     representationClass = String
     *     mimeType           = &quot;text/html&quot;
     * &lt;/pre&gt;
     */
<span class="nc" id="L306">    public static  DataFlavor allHtmlFlavor = initHtmlDataFlavor(&quot;all&quot;);</span>

    /**
     * Constructs a new &lt;code&gt;DataFlavor&lt;/code&gt;.  This constructor is
     * provided only for the purpose of supporting the
     * &lt;code&gt;Externalizable&lt;/code&gt; interface.  It is not
     * intended for public (client) use.
     *
     * @since 1.2
     */
    public DataFlavor() {
<span class="nc" id="L317">        super();</span>
<span class="nc" id="L318">    }</span>

    /**
     * Constructs a fully specified &lt;code&gt;DataFlavor&lt;/code&gt;.
     *
     * @exception NullPointerException if either &lt;code&gt;primaryType&lt;/code&gt;,
     *            &lt;code&gt;subType&lt;/code&gt; or &lt;code&gt;representationClass&lt;/code&gt; is null
     */
    private DataFlavor(String primaryType, String subType, MimeTypeParameterList params, Class&lt;?&gt; representationClass, String humanPresentableName) {
<span class="nc" id="L327">        super();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (primaryType == null) {</span>
<span class="nc" id="L329">            throw new NullPointerException(&quot;primaryType&quot;);</span>
        }
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (subType == null) {</span>
<span class="nc" id="L332">            throw new NullPointerException(&quot;subType&quot;);</span>
        }
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (representationClass == null) {</span>
<span class="nc" id="L335">            throw new NullPointerException(&quot;representationClass&quot;);</span>
        }

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (params == null) params = new MimeTypeParameterList();</span>

<span class="nc" id="L340">        params.set(&quot;class&quot;, representationClass.getName());</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (humanPresentableName == null) {</span>
<span class="nc" id="L343">            humanPresentableName = params.get(&quot;humanPresentableName&quot;);</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (humanPresentableName == null)</span>
<span class="nc" id="L346">                humanPresentableName = primaryType + &quot;/&quot; + subType;</span>
        }

        try {
<span class="nc" id="L350">            mimeType = new MimeType(primaryType, subType, params);</span>
<span class="nc" id="L351">        } catch (MimeTypeParseException mtpe) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;MimeType Parse Exception: &quot; + mtpe.getMessage());</span>
<span class="nc" id="L353">        }</span>

<span class="nc" id="L355">        this.representationClass  = representationClass;</span>
<span class="nc" id="L356">        this.humanPresentableName = humanPresentableName;</span>

<span class="nc" id="L358">        mimeType.removeParameter(&quot;humanPresentableName&quot;);</span>
<span class="nc" id="L359">    }</span>

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a Java class.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;pre&gt;
     *    representationClass = representationClass
     *    mimeType            = application/x-java-serialized-object
     * &lt;/pre&gt;
     * @param representationClass the class used to transfer data in this flavor
     * @param humanPresentableName the human-readable string used to identify
     *                 this flavor; if this parameter is &lt;code&gt;null&lt;/code&gt;
     *                 then the value of the the MIME Content Type is used
     * @exception NullPointerException if &lt;code&gt;representationClass&lt;/code&gt; is null
     */
    public DataFlavor(Class&lt;?&gt; representationClass, String humanPresentableName) {
<span class="nc" id="L377">        this(&quot;application&quot;, &quot;x-java-serialized-object&quot;, null, representationClass, humanPresentableName);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (representationClass == null) {</span>
<span class="nc" id="L379">            throw new NullPointerException(&quot;representationClass&quot;);</span>
        }
<span class="nc" id="L381">    }</span>

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
     * &lt;code&gt;MimeType&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;p&gt;
     * If the &lt;code&gt;mimeType&lt;/code&gt; is
     * &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
     * the result is the same as calling
     * &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
     * &lt;p&gt;
     * Otherwise:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = mimeType
     * &lt;/pre&gt;
     * @param mimeType the string used to identify the MIME type for this flavor;
     *                 if the the &lt;code&gt;mimeType&lt;/code&gt; does not specify a
     *                 &quot;class=&quot; parameter, or if the class is not successfully
     *                 loaded, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     *                 is thrown
     * @param humanPresentableName the human-readable string used to identify
     *                 this flavor; if this parameter is &lt;code&gt;null&lt;/code&gt;
     *                 then the value of the the MIME Content Type is used
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid or if the class is not successfully loaded
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType, String humanPresentableName) {
<span class="nc" id="L413">        super();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L415">            throw new NullPointerException(&quot;mimeType&quot;);</span>
        }
        try {
<span class="nc" id="L418">            initialize(mimeType, humanPresentableName, this.getClass().getClassLoader());</span>
<span class="nc" id="L419">        } catch (MimeTypeParseException mtpe) {</span>
<span class="nc" id="L420">            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);</span>
<span class="nc" id="L421">        } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;can't find specified class: &quot; + cnfe.getMessage());</span>
<span class="nc" id="L423">        }</span>
<span class="nc" id="L424">    }</span>

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; that represents a
     * &lt;code&gt;MimeType&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;DataFlavor&lt;/code&gt; will have the following
     * characteristics:
     * &lt;p&gt;
     * If the mimeType is
     * &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;,
     * the result is the same as calling
     * &lt;code&gt;new DataFlavor(Class:forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.
     * &lt;p&gt;
     * Otherwise:
     * &lt;pre&gt;
     *     representationClass = InputStream
     *     mimeType            = mimeType
     * &lt;/pre&gt;
     * @param mimeType the string used to identify the MIME type for this flavor
     * @param humanPresentableName the human-readable string used to
     *          identify this flavor
     * @param classLoader the class loader to use
     * @exception ClassNotFoundException if the class is not loaded
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType, String humanPresentableName, ClassLoader classLoader) throws ClassNotFoundException {
<span class="nc" id="L453">        super();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L455">            throw new NullPointerException(&quot;mimeType&quot;);</span>
        }
        try {
<span class="nc" id="L458">            initialize(mimeType, humanPresentableName, classLoader);</span>
<span class="nc" id="L459">        } catch (MimeTypeParseException mtpe) {</span>
<span class="nc" id="L460">            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);</span>
<span class="nc" id="L461">        }</span>
<span class="nc" id="L462">    }</span>

    /**
     * Constructs a &lt;code&gt;DataFlavor&lt;/code&gt; from a &lt;code&gt;mimeType&lt;/code&gt; string.
     * The string can specify a &quot;class=&amp;lt;fully specified Java class name&amp;gt;&quot;
     * parameter to create a &lt;code&gt;DataFlavor&lt;/code&gt; with the desired
     * representation class. If the string does not contain &quot;class=&quot; parameter,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; is used as default.
     *
     * @param mimeType the string used to identify the MIME type for this flavor;
     *                 if the class specified by &quot;class=&quot; parameter is not
     *                 successfully loaded, then an
     *                 &lt;code&gt;ClassNotFoundException&lt;/code&gt; is thrown
     * @exception ClassNotFoundException if the class is not loaded
     * @exception IllegalArgumentException if &lt;code&gt;mimeType&lt;/code&gt; is
     *                 invalid
     * @exception NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
     */
    public DataFlavor(String mimeType) throws ClassNotFoundException {
<span class="nc" id="L481">        super();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L483">            throw new NullPointerException(&quot;mimeType&quot;);</span>
        }
        try {
<span class="nc" id="L486">            initialize(mimeType, null, this.getClass().getClassLoader());</span>
<span class="nc" id="L487">        } catch (MimeTypeParseException mtpe) {</span>
<span class="nc" id="L488">            throw new IllegalArgumentException(&quot;failed to parse:&quot; + mimeType);</span>
<span class="nc" id="L489">        }</span>
<span class="nc" id="L490">    }</span>

   /**
    * Common initialization code called from various constructors.
    *
    * @param mimeType the MIME Content Type (must have a class= param)
    * @param humanPresentableName the human Presentable Name or
    *                 &lt;code&gt;null&lt;/code&gt;
    * @param classLoader the fallback class loader to resolve against
    *
    * @throws MimeTypeParseException
    * @throws ClassNotFoundException
    * @throws  NullPointerException if &lt;code&gt;mimeType&lt;/code&gt; is null
    *
    * @see tryToLoadClass
    */
    private void initialize(String mimeType, String humanPresentableName, ClassLoader classLoader) throws MimeTypeParseException, ClassNotFoundException {
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L508">            throw new NullPointerException(&quot;mimeType&quot;);</span>
        }

<span class="nc" id="L511">        this.mimeType = new MimeType(mimeType); // throws</span>

<span class="nc" id="L513">        String rcn = getParameter(&quot;class&quot;);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (rcn == null) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (&quot;application/x-java-serialized-object&quot;.equals(this.mimeType.getBaseType()))</span>

<span class="nc" id="L518">                throw new IllegalArgumentException(&quot;no representation class specified for:&quot; + mimeType);</span>
            else
<span class="nc" id="L520">                representationClass = java.io.InputStream.class; // default</span>
        } else { // got a class name
<span class="nc" id="L522">            representationClass = DataFlavor.tryToLoadClass(rcn, classLoader);</span>
        }

<span class="nc" id="L525">        this.mimeType.setParameter(&quot;class&quot;, representationClass.getName());</span>

<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (humanPresentableName == null) {</span>
<span class="nc" id="L528">            humanPresentableName = this.mimeType.getParameter(&quot;humanPresentableName&quot;);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (humanPresentableName == null)</span>
<span class="nc" id="L530">                humanPresentableName = this.mimeType.getPrimaryType() + &quot;/&quot; + this.mimeType.getSubType();</span>
        }

<span class="nc" id="L533">        this.humanPresentableName = humanPresentableName; // set it.</span>

<span class="nc" id="L535">        this.mimeType.removeParameter(&quot;humanPresentableName&quot;); // just in case</span>
<span class="nc" id="L536">    }</span>

    /**
     * String representation of this &lt;code&gt;DataFlavor&lt;/code&gt; and its
     * parameters. The resulting &lt;code&gt;String&lt;/code&gt; contains the name of
     * the &lt;code&gt;DataFlavor&lt;/code&gt; class, this flavor's MIME type, and its
     * representation class. If this flavor has a primary MIME type of &quot;text&quot;,
     * supports the charset parameter, and has an encoded representation, the
     * flavor's charset is also included. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt;
     * for a list of text flavors which support the charset parameter.
     *
     * @return  string representation of this &lt;code&gt;DataFlavor&lt;/code&gt;
     * @see #selectBestTextFlavor
     */
    public String toString() {
<span class="nc" id="L551">        String string = getClass().getName();</span>
<span class="nc" id="L552">        string += &quot;[&quot;+paramString()+&quot;]&quot;;</span>
<span class="nc" id="L553">        return string;</span>
    }

    private String paramString() {
<span class="nc" id="L557">        String params = &quot;&quot;;</span>
<span class="nc" id="L558">        params += &quot;mimetype=&quot;;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L560">            params += &quot;null&quot;;</span>
        } else {
<span class="nc" id="L562">            params += mimeType.getBaseType();</span>
        }
<span class="nc" id="L564">        params += &quot;;representationclass=&quot;;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (representationClass == null) {</span>
<span class="nc" id="L566">           params += &quot;null&quot;;</span>
        } else {
<span class="nc" id="L568">           params += representationClass.getName();</span>
        }
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (DataTransferer.isFlavorCharsetTextType(this) &amp;&amp;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            (isRepresentationClassInputStream() ||</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">             isRepresentationClassByteBuffer() ||</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">             DataTransferer.byteArrayClass.equals(representationClass)))</span>
        {
<span class="nc" id="L575">            params += &quot;;charset=&quot; + DataTransferer.getTextCharset(this);</span>
        }
<span class="nc" id="L577">        return params;</span>
    }

    /**
     * Returns a &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text with Unicode
     * encoding, where:
     * &lt;pre&gt;
     *     representationClass = java.io.InputStream
     *     mimeType            = &quot;text/plain;
     *                            charset=&amp;lt;platform default Unicode encoding&amp;gt;&quot;
     * &lt;/pre&gt;
     * Sun's implementation for Microsoft Windows uses the encoding &lt;code&gt;utf-16le&lt;/code&gt;.
     * Sun's implementation for Solaris and Linux uses the encoding
     * &lt;code&gt;iso-10646-ucs-2&lt;/code&gt;.
     *
     * @return a &lt;code&gt;DataFlavor&lt;/code&gt; representing plain text
     *    with Unicode encoding
     * @since 1.3
     */
    public static final DataFlavor getTextPlainUnicodeFlavor() {
<span class="nc" id="L597">        String encoding = null;</span>
<span class="nc" id="L598">        DataTransferer transferer = DataTransferer.getInstance();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (transferer != null) {</span>
<span class="nc" id="L600">            encoding = transferer.getDefaultUnicodeEncoding();</span>
        }
<span class="nc" id="L602">        return new DataFlavor(</span>
            &quot;text/plain;charset=&quot;+encoding
            +&quot;;class=java.io.InputStream&quot;, &quot;Plain Text&quot;);
    }

    /**
     * Selects the best text &lt;code&gt;DataFlavor&lt;/code&gt; from an array of &lt;code&gt;
     * DataFlavor&lt;/code&gt;s. Only &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, and
     * equivalent flavors, and flavors that have a primary MIME type of &quot;text&quot;,
     * are considered for selection.
     * &lt;p&gt;
     * Flavors are first sorted by their MIME types in the following order:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/sgml&quot;
     * &lt;li&gt;&quot;text/xml&quot;
     * &lt;li&gt;&quot;text/html&quot;
     * &lt;li&gt;&quot;text/rtf&quot;
     * &lt;li&gt;&quot;text/enriched&quot;
     * &lt;li&gt;&quot;text/richtext&quot;
     * &lt;li&gt;&quot;text/uri-list&quot;
     * &lt;li&gt;&quot;text/tab-separated-values&quot;
     * &lt;li&gt;&quot;text/t140&quot;
     * &lt;li&gt;&quot;text/rfc822-headers&quot;
     * &lt;li&gt;&quot;text/parityfec&quot;
     * &lt;li&gt;&quot;text/directory&quot;
     * &lt;li&gt;&quot;text/css&quot;
     * &lt;li&gt;&quot;text/calendar&quot;
     * &lt;li&gt;&quot;application/x-java-serialized-object&quot;
     * &lt;li&gt;&quot;text/plain&quot;
     * &lt;li&gt;&quot;text/&amp;lt;other&amp;gt;&quot;
     * &lt;/ul&gt;
     * &lt;p&gt;For example, &quot;text/sgml&quot; will be selected over
     * &quot;text/html&quot;, and &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; will be chosen
     * over &lt;code&gt;DataFlavor.plainTextFlavor&lt;/code&gt;.
     * &lt;p&gt;
     * If two or more flavors share the best MIME type in the array, then that
     * MIME type will be checked to see if it supports the charset parameter.
     * &lt;p&gt;
     * The following MIME types support, or are treated as though they support,
     * the charset parameter:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/sgml&quot;
     * &lt;li&gt;&quot;text/xml&quot;
     * &lt;li&gt;&quot;text/html&quot;
     * &lt;li&gt;&quot;text/enriched&quot;
     * &lt;li&gt;&quot;text/richtext&quot;
     * &lt;li&gt;&quot;text/uri-list&quot;
     * &lt;li&gt;&quot;text/directory&quot;
     * &lt;li&gt;&quot;text/css&quot;
     * &lt;li&gt;&quot;text/calendar&quot;
     * &lt;li&gt;&quot;application/x-java-serialized-object&quot;
     * &lt;li&gt;&quot;text/plain&quot;
     * &lt;/ul&gt;
     * The following MIME types do not support, or are treated as though they
     * do not support, the charset parameter:
     * &lt;ul&gt;
     * &lt;li&gt;&quot;text/rtf&quot;
     * &lt;li&gt;&quot;text/tab-separated-values&quot;
     * &lt;li&gt;&quot;text/t140&quot;
     * &lt;li&gt;&quot;text/rfc822-headers&quot;
     * &lt;li&gt;&quot;text/parityfec&quot;
     * &lt;/ul&gt;
     * For &quot;text/&amp;lt;other&amp;gt;&quot; MIME types, the first time the JRE needs to
     * determine whether the MIME type supports the charset parameter, it will
     * check whether the parameter is explicitly listed in an arbitrarily
     * chosen &lt;code&gt;DataFlavor&lt;/code&gt; which uses that MIME type. If so, the JRE
     * will assume from that point on that the MIME type supports the charset
     * parameter and will not check again. If the parameter is not explicitly
     * listed, the JRE will assume from that point on that the MIME type does
     * not support the charset parameter and will not check again. Because
     * this check is performed on an arbitrarily chosen
     * &lt;code&gt;DataFlavor&lt;/code&gt;, developers must ensure that all
     * &lt;code&gt;DataFlavor&lt;/code&gt;s with a &quot;text/&amp;lt;other&amp;gt;&quot; MIME type specify
     * the charset parameter if it is supported by that MIME type. Developers
     * should never rely on the JRE to substitute the platform's default
     * charset for a &quot;text/&amp;lt;other&amp;gt;&quot; DataFlavor. Failure to adhere to this
     * restriction will lead to undefined behavior.
     * &lt;p&gt;
     * If the best MIME type in the array does not support the charset
     * parameter, the flavors which share that MIME type will then be sorted by
     * their representation classes in the following order:
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, or if no
     * flavor has one of the three specified representations, then one of those
     * flavors will be chosen non-deterministically.
     * &lt;p&gt;
     * If the best MIME type in the array does support the charset parameter,
     * the flavors which share that MIME type will then be sorted by their
     * representation classes in the following order:
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, and that
     * representation is one of the four explicitly listed, then one of those
     * flavors will be chosen non-deterministically. If, however, no flavor has
     * one of the four specified representations, the flavors will then be
     * sorted by their charsets. Unicode charsets, such as &quot;UTF-16&quot;, &quot;UTF-8&quot;,
     * &quot;UTF-16BE&quot;, &quot;UTF-16LE&quot;, and their aliases, are considered best. After
     * them, the platform default charset and its aliases are selected.
     * &quot;US-ASCII&quot; and its aliases are worst. All other charsets are chosen in
     * alphabetical order, but only charsets supported by this implementation
     * of the Java platform will be considered.
     * &lt;p&gt;
     * If two or more flavors share the best charset, the flavors will then
     * again be sorted by their representation classes in the following order:
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * &lt;code&gt;[B&lt;/code&gt;, &amp;lt;all others&amp;gt;.
     * &lt;p&gt;
     * If two or more flavors share the best representation class, or if no
     * flavor has one of the three specified representations, then one of those
     * flavors will be chosen non-deterministically.
     *
     * @param availableFlavors an array of available &lt;code&gt;DataFlavor&lt;/code&gt;s
     * @return the best (highest fidelity) flavor according to the rules
     *         specified above, or &lt;code&gt;null&lt;/code&gt;,
     *         if &lt;code&gt;availableFlavors&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     *         has zero length, or contains no text flavors
     * @since 1.3
     */
    public static final DataFlavor selectBestTextFlavor(
                                       DataFlavor[] availableFlavors) {
<span class="nc bnc" id="L725" title="All 4 branches missed.">        if (availableFlavors == null || availableFlavors.length == 0) {</span>
<span class="nc" id="L726">            return null;</span>
        }

<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (textFlavorComparator == null) {</span>
<span class="nc" id="L730">            textFlavorComparator = new TextFlavorComparator();</span>
        }

<span class="nc" id="L733">        DataFlavor bestFlavor =</span>
<span class="nc" id="L734">            (DataFlavor)Collections.max(Arrays.asList(availableFlavors),</span>
                                        textFlavorComparator);

<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (!bestFlavor.isFlavorTextType()) {</span>
<span class="nc" id="L738">            return null;</span>
        }

<span class="nc" id="L741">        return bestFlavor;</span>
    }

    private static Comparator&lt;DataFlavor&gt; textFlavorComparator;

<span class="nc" id="L746">    static class TextFlavorComparator</span>
        extends DataTransferer.DataFlavorComparator {

        /**
         * Compares two &lt;code&gt;DataFlavor&lt;/code&gt; objects. Returns a negative
         * integer, zero, or a positive integer as the first
         * &lt;code&gt;DataFlavor&lt;/code&gt; is worse than, equal to, or better than the
         * second.
         * &lt;p&gt;
         * &lt;code&gt;DataFlavor&lt;/code&gt;s are ordered according to the rules outlined
         * for &lt;code&gt;selectBestTextFlavor&lt;/code&gt;.
         *
         * @param obj1 the first &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
         * @param obj2 the second &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
         * @return a negative integer, zero, or a positive integer as the first
         *         argument is worse, equal to, or better than the second
         * @throws ClassCastException if either of the arguments is not an
         *         instance of &lt;code&gt;DataFlavor&lt;/code&gt;
         * @throws NullPointerException if either of the arguments is
         *         &lt;code&gt;null&lt;/code&gt;
         *
         * @see #selectBestTextFlavor
         */
        public int compare(Object obj1, Object obj2) {
<span class="nc" id="L770">            DataFlavor flavor1 = (DataFlavor)obj1;</span>
<span class="nc" id="L771">            DataFlavor flavor2 = (DataFlavor)obj2;</span>

<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (flavor1.isFlavorTextType()) {</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (flavor2.isFlavorTextType()) {</span>
<span class="nc" id="L775">                    return super.compare(obj1, obj2);</span>
                } else {
<span class="nc" id="L777">                    return 1;</span>
                }
<span class="nc bnc" id="L779" title="All 2 branches missed.">            } else if (flavor2.isFlavorTextType()) {</span>
<span class="nc" id="L780">                return -1;</span>
            } else {
<span class="nc" id="L782">                return 0;</span>
            }
        }
    }

    /**
     * Gets a Reader for a text flavor, decoded, if necessary, for the expected
     * charset (encoding). The supported representation classes are
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;,
     * and &lt;code&gt;[B&lt;/code&gt;.
     * &lt;p&gt;
     * Because text flavors which do not support the charset parameter are
     * encoded in a non-standard format, this method should not be called for
     * such flavors. However, in order to maintain backward-compatibility,
     * if this method is called for such a flavor, this method will treat the
     * flavor as though it supports the charset parameter and attempt to
     * decode it accordingly. See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list
     * of text flavors which do not support the charset parameter.
     *
     * @param transferable the &lt;code&gt;Transferable&lt;/code&gt; whose data will be
     *        requested in this flavor
     *
     * @return a &lt;code&gt;Reader&lt;/code&gt; to read the &lt;code&gt;Transferable&lt;/code&gt;'s
     *         data
     *
     * @exception IllegalArgumentException if the representation class
     *            is not one of the seven listed above
     * @exception IllegalArgumentException if the &lt;code&gt;Transferable&lt;/code&gt;
     *            has &lt;code&gt;null&lt;/code&gt; data
     * @exception NullPointerException if the &lt;code&gt;Transferable&lt;/code&gt; is
     *            &lt;code&gt;null&lt;/code&gt;
     * @exception UnsupportedEncodingException if this flavor's representation
     *            is &lt;code&gt;java.io.InputStream&lt;/code&gt;,
     *            &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or &lt;code&gt;[B&lt;/code&gt; and
     *            this flavor's encoding is not supported by this
     *            implementation of the Java platform
     * @exception UnsupportedFlavorException if the &lt;code&gt;Transferable&lt;/code&gt;
     *            does not support this flavor
     * @exception IOException if the data cannot be read because of an
     *            I/O error
     * @see #selectBestTextFlavor
     * @since 1.3
     */
    public Reader getReaderForText(Transferable transferable)
        throws UnsupportedFlavorException, IOException
    {
<span class="nc" id="L830">        Object transferObject = transferable.getTransferData(this);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (transferObject == null) {</span>
<span class="nc" id="L832">            throw new IllegalArgumentException</span>
                (&quot;getTransferData() returned null&quot;);
        }

<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (transferObject instanceof Reader) {</span>
<span class="nc" id="L837">            return (Reader)transferObject;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        } else if (transferObject instanceof String) {</span>
<span class="nc" id="L839">            return new StringReader((String)transferObject);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        } else if (transferObject instanceof CharBuffer) {</span>
<span class="nc" id="L841">            CharBuffer buffer = (CharBuffer)transferObject;</span>
<span class="nc" id="L842">            int size = buffer.remaining();</span>
<span class="nc" id="L843">            char[] chars = new char[size];</span>
<span class="nc" id="L844">            buffer.get(chars, 0, size);</span>
<span class="nc" id="L845">            return new CharArrayReader(chars);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        } else if (transferObject instanceof char[]) {</span>
<span class="nc" id="L847">            return new CharArrayReader((char[])transferObject);</span>
        }

<span class="nc" id="L850">        InputStream stream = null;</span>

<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (transferObject instanceof InputStream) {</span>
<span class="nc" id="L853">            stream = (InputStream)transferObject;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">        } else if (transferObject instanceof ByteBuffer) {</span>
<span class="nc" id="L855">            ByteBuffer buffer = (ByteBuffer)transferObject;</span>
<span class="nc" id="L856">            int size = buffer.remaining();</span>
<span class="nc" id="L857">            byte[] bytes = new byte[size];</span>
<span class="nc" id="L858">            buffer.get(bytes, 0, size);</span>
<span class="nc" id="L859">            stream = new ByteArrayInputStream(bytes);</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        } else if (transferObject instanceof byte[]) {</span>
<span class="nc" id="L861">            stream = new ByteArrayInputStream((byte[])transferObject);</span>
        }

<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L865">            throw new IllegalArgumentException(&quot;transfer data is not Reader, String, CharBuffer, char array, InputStream, ByteBuffer, or byte array&quot;);</span>
        }

<span class="nc" id="L868">        String encoding = getParameter(&quot;charset&quot;);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        return (encoding == null)</span>
            ? new InputStreamReader(stream)
            : new InputStreamReader(stream, encoding);
    }

    /**
     * Returns the MIME type string for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the MIME type string for this flavor
     */
    public String getMimeType() {
<span class="nc bnc" id="L879" title="All 2 branches missed.">        return (mimeType != null) ? mimeType.toString() : null;</span>
    }

    /**
     * Returns the &lt;code&gt;Class&lt;/code&gt; which objects supporting this
     * &lt;code&gt;DataFlavor&lt;/code&gt; will return when this &lt;code&gt;DataFlavor&lt;/code&gt;
     * is requested.
     * @return the &lt;code&gt;Class&lt;/code&gt; which objects supporting this
     * &lt;code&gt;DataFlavor&lt;/code&gt; will return when this &lt;code&gt;DataFlavor&lt;/code&gt;
     * is requested
     */
    public Class&lt;?&gt; getRepresentationClass() {
<span class="nc" id="L891">        return representationClass;</span>
    }

    /**
     * Returns the human presentable name for the data format that this
     * &lt;code&gt;DataFlavor&lt;/code&gt; represents.  This name would be localized
     * for different countries.
     * @return the human presentable name for the data format that this
     *    &lt;code&gt;DataFlavor&lt;/code&gt; represents
     */
    public String getHumanPresentableName() {
<span class="nc" id="L902">        return humanPresentableName;</span>
    }

    /**
     * Returns the primary MIME type for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the primary MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public String getPrimaryType() {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        return (mimeType != null) ? mimeType.getPrimaryType() : null;</span>
    }

    /**
     * Returns the sub MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * @return the Sub MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public String getSubType() {
<span class="nc bnc" id="L918" title="All 2 branches missed.">        return (mimeType != null) ? mimeType.getSubType() : null;</span>
    }

    /**
     * Returns the human presentable name for this &lt;code&gt;DataFlavor&lt;/code&gt;
     * if &lt;code&gt;paramName&lt;/code&gt; equals &quot;humanPresentableName&quot;.  Otherwise
     * returns the MIME type value associated with &lt;code&gt;paramName&lt;/code&gt;.
     *
     * @param paramName the parameter name requested
     * @return the value of the name parameter, or &lt;code&gt;null&lt;/code&gt;
     *  if there is no associated value
     */
    public String getParameter(String paramName) {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        if (paramName.equals(&quot;humanPresentableName&quot;)) {</span>
<span class="nc" id="L932">            return humanPresentableName;</span>
        } else {
<span class="nc bnc" id="L934" title="All 2 branches missed.">            return (mimeType != null)</span>
<span class="nc" id="L935">                ? mimeType.getParameter(paramName) : null;</span>
        }
    }

    /**
     * Sets the human presentable name for the data format that this
     * &lt;code&gt;DataFlavor&lt;/code&gt; represents. This name would be localized
     * for different countries.
     * @param humanPresentableName the new human presentable name
     */
    public void setHumanPresentableName(String humanPresentableName) {
<span class="nc" id="L946">        this.humanPresentableName = humanPresentableName;</span>
<span class="nc" id="L947">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * The equals comparison for the {@code DataFlavor} class is implemented
     * as follows: Two &lt;code&gt;DataFlavor&lt;/code&gt;s are considered equal if and
     * only if their MIME primary type and subtype and representation class are
     * equal. Additionally, if the primary type is &quot;text&quot;, the subtype denotes
     * a text flavor which supports the charset parameter, and the
     * representation class is not &lt;code&gt;java.io.Reader&lt;/code&gt;,
     * &lt;code&gt;java.lang.String&lt;/code&gt;, &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, or
     * &lt;code&gt;[C&lt;/code&gt;, the &lt;code&gt;charset&lt;/code&gt; parameter must also be equal.
     * If a charset is not explicitly specified for one or both
     * &lt;code&gt;DataFlavor&lt;/code&gt;s, the platform default encoding is assumed. See
     * &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
     * support the charset parameter.
     *
     * @param o the &lt;code&gt;Object&lt;/code&gt; to compare with &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L971" title="All 4 branches missed.">        return ((o instanceof DataFlavor) &amp;&amp; equals((DataFlavor)o));</span>
    }

    /**
     * This method has the same behavior as {@link #equals(Object)}.
     * The only difference being that it takes a {@code DataFlavor} instance
     * as a parameter.
     *
     * @param that the &lt;code&gt;DataFlavor&lt;/code&gt; to compare with
     *        &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     */
    public boolean equals(DataFlavor that) {
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (that == null) {</span>
<span class="nc" id="L987">            return false;</span>
        }
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (this == that) {</span>
<span class="nc" id="L990">            return true;</span>
        }

<span class="nc bnc" id="L993" title="All 2 branches missed.">        if (representationClass == null) {</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (that.getRepresentationClass() != null) {</span>
<span class="nc" id="L995">                return false;</span>
            }
        } else {
<span class="nc bnc" id="L998" title="All 2 branches missed.">            if (!representationClass.equals(that.getRepresentationClass())) {</span>
<span class="nc" id="L999">                return false;</span>
            }
        }

<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">            if (that.mimeType != null) {</span>
<span class="nc" id="L1005">                return false;</span>
            }
        } else {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (!mimeType.match(that.mimeType)) {</span>
<span class="nc" id="L1009">                return false;</span>
            }

<span class="nc bnc" id="L1012" title="All 2 branches missed.">            if (&quot;text&quot;.equals(getPrimaryType())) {</span>
<span class="nc bnc" id="L1013" title="All 4 branches missed.">                if (DataTransferer.doesSubtypeSupportCharset(this) &amp;&amp;</span>
                    representationClass != null &amp;&amp;
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                    !(isRepresentationClassReader() ||</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                        String.class.equals(representationClass) ||</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                        isRepresentationClassCharBuffer() ||</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                        DataTransferer.charArrayClass.equals(representationClass)))</span>
                {
<span class="nc" id="L1020">                    String thisCharset =</span>
<span class="nc" id="L1021">                        DataTransferer.canonicalName(getParameter(&quot;charset&quot;));</span>
<span class="nc" id="L1022">                    String thatCharset =</span>
<span class="nc" id="L1023">                        DataTransferer.canonicalName(that.getParameter(&quot;charset&quot;));</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    if (thisCharset == null) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                        if (thatCharset != null) {</span>
<span class="nc" id="L1026">                            return false;</span>
                        }
                    } else {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                        if (!thisCharset.equals(thatCharset)) {</span>
<span class="nc" id="L1030">                            return false;</span>
                        }
                    }
                }

<span class="nc bnc" id="L1035" title="All 2 branches missed.">                if (&quot;html&quot;.equals(getSubType()) &amp;&amp;</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                        this.getParameter(&quot;document&quot;) != null )</span>
                {
<span class="nc" id="L1038">                   if (!this.getParameter(&quot;document&quot;).</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                            equals(that.getParameter(&quot;document&quot;)))</span>
                    {
<span class="nc" id="L1041">                        return false;</span>
                    }
                }
            }
        }

<span class="nc" id="L1047">        return true;</span>
    }

    /**
     * Compares only the &lt;code&gt;mimeType&lt;/code&gt; against the passed in
     * &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;representationClass&lt;/code&gt; is
     * not considered in the comparison.
     *
     * If &lt;code&gt;representationClass&lt;/code&gt; needs to be compared, then
     * &lt;code&gt;equals(new DataFlavor(s))&lt;/code&gt; may be used.
     * @deprecated As inconsistent with &lt;code&gt;hashCode()&lt;/code&gt; contract,
     *             use &lt;code&gt;isMimeTypeEqual(String)&lt;/code&gt; instead.
     * @param s the {@code mimeType} to compare.
     * @return true if the String (MimeType) is equal; false otherwise or if
     *         {@code s} is {@code null}
     */
    @Deprecated
    public boolean equals(String s) {
<span class="nc bnc" id="L1065" title="All 4 branches missed.">        if (s == null || mimeType == null)</span>
<span class="nc" id="L1066">            return false;</span>
<span class="nc" id="L1067">        return isMimeTypeEqual(s);</span>
    }

    /**
     * Returns hash code for this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * For two equal &lt;code&gt;DataFlavor&lt;/code&gt;s, hash codes are equal.
     * For the &lt;code&gt;String&lt;/code&gt;
     * that matches &lt;code&gt;DataFlavor.equals(String)&lt;/code&gt;, it is not
     * guaranteed that &lt;code&gt;DataFlavor&lt;/code&gt;'s hash code is equal
     * to the hash code of the &lt;code&gt;String&lt;/code&gt;.
     *
     * @return a hash code for this &lt;code&gt;DataFlavor&lt;/code&gt;
     */
    public int hashCode() {
<span class="nc" id="L1081">        int total = 0;</span>

<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (representationClass != null) {</span>
<span class="nc" id="L1084">            total += representationClass.hashCode();</span>
        }

<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (mimeType != null) {</span>
<span class="nc" id="L1088">            String primaryType = mimeType.getPrimaryType();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (primaryType != null) {</span>
<span class="nc" id="L1090">                total += primaryType.hashCode();</span>
            }

            // Do not add subType.hashCode() to the total. equals uses
            // MimeType.match which reports a match if one or both of the
            // subTypes is '*', regardless of the other subType.

<span class="nc bnc" id="L1097" title="All 2 branches missed.">            if (&quot;text&quot;.equals(primaryType) &amp;&amp;</span>
<span class="nc bnc" id="L1098" title="All 4 branches missed.">                DataTransferer.doesSubtypeSupportCharset(this) &amp;&amp;</span>
                representationClass != null &amp;&amp;
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                !(isRepresentationClassReader() ||</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                  String.class.equals(representationClass) ||</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                  isRepresentationClassCharBuffer() ||</span>
                  DataTransferer.charArrayClass.equals
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                  (representationClass)))</span>
            {
<span class="nc" id="L1106">                String charset =</span>
<span class="nc" id="L1107">                    DataTransferer.canonicalName(getParameter(&quot;charset&quot;));</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                if (charset != null) {</span>
<span class="nc" id="L1109">                    total += charset.hashCode();</span>
                }
            }
        }

<span class="nc" id="L1114">        return total;</span>
    }

    /**
     * Identical to {@link #equals(DataFlavor)}.
     *
     * @param that the &lt;code&gt;DataFlavor&lt;/code&gt; to compare with
     *        &lt;code&gt;this&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;that&lt;/code&gt; is equivalent to this
     *         &lt;code&gt;DataFlavor&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     * @since 1.3
     */
    public boolean match(DataFlavor that) {
<span class="nc" id="L1128">        return equals(that);</span>
    }

    /**
     * Returns whether the string representation of the MIME type passed in
     * is equivalent to the MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;.
     * Parameters are not included in the comparison.
     *
     * @param mimeType the string representation of the MIME type
     * @return true if the string representation of the MIME type passed in is
     *         equivalent to the MIME type of this &lt;code&gt;DataFlavor&lt;/code&gt;;
     *         false otherwise
     * @throws NullPointerException if mimeType is &lt;code&gt;null&lt;/code&gt;
     */
    public boolean isMimeTypeEqual(String mimeType) {
        // JCK Test DataFlavor0117: if 'mimeType' is null, throw NPE
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (mimeType == null) {</span>
<span class="nc" id="L1145">            throw new NullPointerException(&quot;mimeType&quot;);</span>
        }
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (this.mimeType == null) {</span>
<span class="nc" id="L1148">            return false;</span>
        }
        try {
<span class="nc" id="L1151">            return this.mimeType.match(new MimeType(mimeType));</span>
<span class="nc" id="L1152">        } catch (MimeTypeParseException mtpe) {</span>
<span class="nc" id="L1153">            return false;</span>
        }
    }

    /**
     * Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
     * objects. No parameters are considered.
     *
     * @param dataFlavor the &lt;code&gt;DataFlavor&lt;/code&gt; to be compared
     * @return true if the &lt;code&gt;MimeType&lt;/code&gt;s are equal,
     *  otherwise false
     */

    public final boolean isMimeTypeEqual(DataFlavor dataFlavor) {
<span class="nc" id="L1167">        return isMimeTypeEqual(dataFlavor.mimeType);</span>
    }

    /**
     * Compares the &lt;code&gt;mimeType&lt;/code&gt; of two &lt;code&gt;DataFlavor&lt;/code&gt;
     * objects.  No parameters are considered.
     *
     * @return true if the &lt;code&gt;MimeType&lt;/code&gt;s are equal,
     *  otherwise false
     */

    private boolean isMimeTypeEqual(MimeType mtype) {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (this.mimeType == null) {</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            return (mtype == null);</span>
        }
<span class="nc" id="L1182">        return mimeType.match(mtype);</span>
    }

   /**
    * Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a serialized object?
    */

    public boolean isMimeTypeSerializedObject() {
<span class="nc" id="L1190">        return isMimeTypeEqual(javaSerializedObjectMimeType);</span>
    }

    public final Class&lt;?&gt; getDefaultRepresentationClass() {
<span class="nc" id="L1194">        return ioInputStreamClass;</span>
    }

    public final String getDefaultRepresentationClassAsString() {
<span class="nc" id="L1198">        return getDefaultRepresentationClass().getName();</span>
    }

   /**
    * Does the &lt;code&gt;DataFlavor&lt;/code&gt; represent a
    * &lt;code&gt;java.io.InputStream&lt;/code&gt;?
    */

    public boolean isRepresentationClassInputStream() {
<span class="nc" id="L1207">        return ioInputStreamClass.isAssignableFrom(representationClass);</span>
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.io.Reader&lt;/code&gt; or a subclass
     * thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassReader() {
<span class="nc" id="L1218">        return java.io.Reader.class.isAssignableFrom(representationClass);</span>
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.CharBuffer&lt;/code&gt; or a
     * subclass thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassCharBuffer() {
<span class="nc" id="L1229">        return java.nio.CharBuffer.class.isAssignableFrom(representationClass);</span>
    }

    /**
     * Returns whether the representation class for this
     * &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt; or a
     * subclass thereof.
     *
     * @since 1.4
     */
    public boolean isRepresentationClassByteBuffer() {
<span class="nc" id="L1240">        return java.nio.ByteBuffer.class.isAssignableFrom(representationClass);</span>
    }

   /**
    * Returns true if the representation class can be serialized.
    * @return true if the representation class can be serialized
    */

    public boolean isRepresentationClassSerializable() {
<span class="nc" id="L1249">        return java.io.Serializable.class.isAssignableFrom(representationClass);</span>
    }

   /**
    * Returns true if the representation class is &lt;code&gt;Remote&lt;/code&gt;.
    * @return true if the representation class is &lt;code&gt;Remote&lt;/code&gt;
    */

    public boolean isRepresentationClassRemote() {
<span class="nc" id="L1258">        return DataTransferer.isRemote(representationClass);</span>
    }

   /**
    * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    * a serialized object.
    * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    *   a Serialized Object
    */

    public boolean isFlavorSerializedObjectType() {
<span class="nc bnc" id="L1269" title="All 4 branches missed.">        return isRepresentationClassSerializable() &amp;&amp; isMimeTypeEqual(javaSerializedObjectMimeType);</span>
    }

    /**
     * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
     * a remote object.
     * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
     *  a Remote Object
     */

    public boolean isFlavorRemoteObjectType() {
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        return isRepresentationClassRemote()</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">            &amp;&amp; isRepresentationClassSerializable()</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            &amp;&amp; isMimeTypeEqual(javaRemoteObjectMimeType);</span>
    }


   /**
    * Returns true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    * a list of file objects.
    * @return true if the &lt;code&gt;DataFlavor&lt;/code&gt; specified represents
    *   a List of File objects
    */

   public boolean isFlavorJavaFileListType() {
<span class="nc bnc" id="L1294" title="All 4 branches missed.">        if (mimeType == null || representationClass == null)</span>
<span class="nc" id="L1295">            return false;</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">        return java.util.List.class.isAssignableFrom(representationClass) &amp;&amp;</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">               mimeType.match(javaFileListFlavor.mimeType);</span>

   }

    /**
     * Returns whether this &lt;code&gt;DataFlavor&lt;/code&gt; is a valid text flavor for
     * this implementation of the Java platform. Only flavors equivalent to
     * &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt; and &lt;code&gt;DataFlavor&lt;/code&gt;s with
     * a primary MIME type of &quot;text&quot; can be valid text flavors.
     * &lt;p&gt;
     * If this flavor supports the charset parameter, it must be equivalent to
     * &lt;code&gt;DataFlavor.stringFlavor&lt;/code&gt;, or its representation must be
     * &lt;code&gt;java.io.Reader&lt;/code&gt;, &lt;code&gt;java.lang.String&lt;/code&gt;,
     * &lt;code&gt;java.nio.CharBuffer&lt;/code&gt;, &lt;code&gt;[C&lt;/code&gt;,
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
     * &lt;code&gt;[B&lt;/code&gt;. If the representation is
     * &lt;code&gt;java.io.InputStream&lt;/code&gt;, &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or
     * &lt;code&gt;[B&lt;/code&gt;, then this flavor's &lt;code&gt;charset&lt;/code&gt; parameter must
     * be supported by this implementation of the Java platform. If a charset
     * is not specified, then the platform default charset, which is always
     * supported, is assumed.
     * &lt;p&gt;
     * If this flavor does not support the charset parameter, its
     * representation must be &lt;code&gt;java.io.InputStream&lt;/code&gt;,
     * &lt;code&gt;java.nio.ByteBuffer&lt;/code&gt;, or &lt;code&gt;[B&lt;/code&gt;.
     * &lt;p&gt;
     * See &lt;code&gt;selectBestTextFlavor&lt;/code&gt; for a list of text flavors which
     * support the charset parameter.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;DataFlavor&lt;/code&gt; is a valid
     *         text flavor as described above; &lt;code&gt;false&lt;/code&gt; otherwise
     * @see #selectBestTextFlavor
     * @since 1.4
     */
    public boolean isFlavorTextType() {
<span class="nc bnc" id="L1332" title="All 2 branches missed.">        return (DataTransferer.isFlavorCharsetTextType(this) ||</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                DataTransferer.isFlavorNoncharsetTextType(this));</span>
    }

   /**
    * Serializes this &lt;code&gt;DataFlavor&lt;/code&gt;.
    */

   public synchronized void writeExternal(ObjectOutput os) throws IOException {
<span class="nc bnc" id="L1341" title="All 2 branches missed.">       if (mimeType != null) {</span>
<span class="nc" id="L1342">           mimeType.setParameter(&quot;humanPresentableName&quot;, humanPresentableName);</span>
<span class="nc" id="L1343">           os.writeObject(mimeType);</span>
<span class="nc" id="L1344">           mimeType.removeParameter(&quot;humanPresentableName&quot;);</span>
       } else {
<span class="nc" id="L1346">           os.writeObject(null);</span>
       }

<span class="nc" id="L1349">       os.writeObject(representationClass);</span>
<span class="nc" id="L1350">   }</span>

   /**
    * Restores this &lt;code&gt;DataFlavor&lt;/code&gt; from a Serialized state.
    */

   public synchronized void readExternal(ObjectInput is) throws IOException , ClassNotFoundException {
<span class="nc" id="L1357">       String rcn = null;</span>
<span class="nc" id="L1358">        mimeType = (MimeType)is.readObject();</span>

<span class="nc bnc" id="L1360" title="All 2 branches missed.">        if (mimeType != null) {</span>
<span class="nc" id="L1361">            humanPresentableName =</span>
<span class="nc" id="L1362">                mimeType.getParameter(&quot;humanPresentableName&quot;);</span>
<span class="nc" id="L1363">            mimeType.removeParameter(&quot;humanPresentableName&quot;);</span>
<span class="nc" id="L1364">            rcn = mimeType.getParameter(&quot;class&quot;);</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if (rcn == null) {</span>
<span class="nc" id="L1366">                throw new IOException(&quot;no class parameter specified in: &quot; +</span>
                                      mimeType);
            }
        }

        try {
<span class="nc" id="L1372">            representationClass = (Class)is.readObject();</span>
<span class="nc" id="L1373">        } catch (OptionalDataException ode) {</span>
<span class="nc bnc" id="L1374" title="All 4 branches missed.">            if (!ode.eof || ode.length != 0) {</span>
<span class="nc" id="L1375">                throw ode;</span>
            }
            // Ensure backward compatibility.
            // Old versions didn't write the representation class to the stream.
<span class="nc bnc" id="L1379" title="All 2 branches missed.">            if (rcn != null) {</span>
<span class="nc" id="L1380">                representationClass =</span>
<span class="nc" id="L1381">                    DataFlavor.tryToLoadClass(rcn, getClass().getClassLoader());</span>
            }
<span class="nc" id="L1383">        }</span>
<span class="nc" id="L1384">   }</span>

   /**
    * Returns a clone of this &lt;code&gt;DataFlavor&lt;/code&gt;.
    * @return a clone of this &lt;code&gt;DataFlavor&lt;/code&gt;
    */

    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L1392">        Object newObj = super.clone();</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">        if (mimeType != null) {</span>
<span class="nc" id="L1394">            ((DataFlavor)newObj).mimeType = (MimeType)mimeType.clone();</span>
        }
<span class="nc" id="L1396">        return newObj;</span>
    } // clone()

   /**
    * Called on &lt;code&gt;DataFlavor&lt;/code&gt; for every MIME Type parameter
    * to allow &lt;code&gt;DataFlavor&lt;/code&gt; subclasses to handle special
    * parameters like the text/plain &lt;code&gt;charset&lt;/code&gt;
    * parameters, whose values are case insensitive.  (MIME type parameter
    * values are supposed to be case sensitive.
    * &lt;p&gt;
    * This method is called for each parameter name/value pair and should
    * return the normalized representation of the &lt;code&gt;parameterValue&lt;/code&gt;.
    *
    * This method is never invoked by this implementation from 1.1 onwards.
    *
    * @deprecated
    */
    @Deprecated
    protected String normalizeMimeTypeParameter(String parameterName, String parameterValue) {
<span class="nc" id="L1415">        return parameterValue;</span>
    }

   /**
    * Called for each MIME type string to give &lt;code&gt;DataFlavor&lt;/code&gt; subtypes
    * the opportunity to change how the normalization of MIME types is
    * accomplished.  One possible use would be to add default
    * parameter/value pairs in cases where none are present in the MIME
    * type string passed in.
    *
    * This method is never invoked by this implementation from 1.1 onwards.
    *
    * @deprecated
    */
    @Deprecated
    protected String normalizeMimeType(String mimeType) {
<span class="nc" id="L1431">        return mimeType;</span>
    }

    /*
     * fields
     */

    /* placeholder for caching any platform-specific data for flavor */

    transient int       atom;

    /* Mime Type of DataFlavor */

    MimeType            mimeType;

    private String      humanPresentableName;

    /** Java class of objects this DataFlavor represents **/

    private Class&lt;?&gt;       representationClass;

} // class DataFlavor
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>