<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SystemFlavorMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.datatransfer</a> &gt; <span class="el_source">SystemFlavorMap.java</span></div><h1>SystemFlavorMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.datatransfer;

import java.awt.Toolkit;

import java.lang.ref.SoftReference;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.io.IOException;

import java.net.URL;
import java.net.MalformedURLException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import sun.awt.datatransfer.DataTransferer;

/**
 * The SystemFlavorMap is a configurable map between &quot;natives&quot; (Strings), which
 * correspond to platform-specific data formats, and &quot;flavors&quot; (DataFlavors),
 * which correspond to platform-independent MIME types. This mapping is used
 * by the data transfer subsystem to transfer data between Java and native
 * applications, and between Java applications in separate VMs.
 * &lt;p&gt;
 *
 * @since 1.2
 */
<span class="nc bnc" id="L61" title="All 2 branches missed.">public final class SystemFlavorMap implements FlavorMap, FlavorTable {</span>

    /**
     * Constant prefix used to tag Java types converted to native platform
     * type.
     */
<span class="nc" id="L67">    private static String JavaMIME = &quot;JAVA_DATAFLAVOR:&quot;;</span>

    /**
     * System singleton which maps a thread's ClassLoader to a SystemFlavorMap.
     */
<span class="nc" id="L72">    private static final WeakHashMap&lt;ClassLoader, FlavorMap&gt; flavorMaps = new WeakHashMap&lt;&gt;();</span>

    /**
     * Copied from java.util.Properties.
     */
    private static final String keyValueSeparators = &quot;=: \t\r\n\f&quot;;
    private static final String strictKeyValueSeparators = &quot;=:&quot;;
    private static final String whiteSpaceChars = &quot; \t\r\n\f&quot;;

    /**
     * The list of valid, decoded text flavor representation classes, in order
     * from best to worst.
     */
<span class="nc" id="L85">    private static final String[] UNICODE_TEXT_CLASSES = {</span>
        &quot;java.io.Reader&quot;, &quot;java.lang.String&quot;, &quot;java.nio.CharBuffer&quot;, &quot;\&quot;[C\&quot;&quot;
    };

    /**
     * The list of valid, encoded text flavor representation classes, in order
     * from best to worst.
     */
<span class="nc" id="L93">    private static final String[] ENCODED_TEXT_CLASSES = {</span>
        &quot;java.io.InputStream&quot;, &quot;java.nio.ByteBuffer&quot;, &quot;\&quot;[B\&quot;&quot;
    };

    /**
     * A String representing text/plain MIME type.
     */
    private static final String TEXT_PLAIN_BASE_TYPE = &quot;text/plain&quot;;

    /**
     * A String representing text/html MIME type.
     */
    private static final String HTML_TEXT_BASE_TYPE = &quot;text/html&quot;;

    /**
     * This constant is passed to flavorToNativeLookup() to indicate that a
     * a native should be synthesized, stored, and returned by encoding the
     * DataFlavor's MIME type in case if the DataFlavor is not found in
     * 'flavorToNative' map.
     */
    private static final boolean SYNTHESIZE_IF_NOT_FOUND = true;

    /**
     * Maps native Strings to Lists of DataFlavors (or base type Strings for
     * text DataFlavors).
     * Do not use the field directly, use getNativeToFlavor() instead.
     */
<span class="nc" id="L120">    private final Map&lt;String, List&lt;DataFlavor&gt;&gt; nativeToFlavor = new HashMap&lt;&gt;();</span>

    /**
     * Accessor to nativeToFlavor map.  Since we use lazy initialization we must
     * use this accessor instead of direct access to the field which may not be
     * initialized yet.  This method will initialize the field if needed.
     *
     * @return nativeToFlavor
     */
    private Map&lt;String, List&lt;DataFlavor&gt;&gt; getNativeToFlavor() {
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (!isMapInitialized) {</span>
<span class="nc" id="L131">            initSystemFlavorMap();</span>
        }
<span class="nc" id="L133">        return nativeToFlavor;</span>
    }

    /**
     * Maps DataFlavors (or base type Strings for text DataFlavors) to Lists of
     * native Strings.
     * Do not use the field directly, use getFlavorToNative() instead.
     */
<span class="nc" id="L141">    private final Map&lt;DataFlavor, List&lt;String&gt;&gt; flavorToNative = new HashMap&lt;&gt;();</span>

    /**
     * Accessor to flavorToNative map.  Since we use lazy initialization we must
     * use this accessor instead of direct access to the field which may not be
     * initialized yet.  This method will initialize the field if needed.
     *
     * @return flavorToNative
     */
    private synchronized Map&lt;DataFlavor, List&lt;String&gt;&gt; getFlavorToNative() {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (!isMapInitialized) {</span>
<span class="nc" id="L152">            initSystemFlavorMap();</span>
        }
<span class="nc" id="L154">        return flavorToNative;</span>
    }

    /**
     * Shows if the object has been initialized.
     */
<span class="nc" id="L160">    private boolean isMapInitialized = false;</span>

    /**
     * Caches the result of getNativesForFlavor(). Maps DataFlavors to
     * SoftReferences which reference Lists of String natives.
     */
<span class="nc" id="L166">    private Map&lt;DataFlavor, SoftReference&lt;List&lt;String&gt;&gt;&gt; getNativesForFlavorCache = new HashMap&lt;&gt;();</span>

    /**
     * Caches the result getFlavorsForNative(). Maps String natives to
     * SoftReferences which reference Lists of DataFlavors.
     */
<span class="nc" id="L172">    private Map&lt;String, SoftReference&lt;List&lt;DataFlavor&gt;&gt;&gt; getFlavorsForNativeCache = new HashMap&lt;&gt;();</span>

    /**
     * Dynamic mapping generation used for text mappings should not be applied
     * to the DataFlavors and String natives for which the mappings have been
     * explicitly specified with setFlavorsForNative() or
     * setNativesForFlavor(). This keeps all such keys.
     */
<span class="nc" id="L180">    private Set disabledMappingGenerationKeys = new HashSet();</span>

    /**
     * Returns the default FlavorMap for this thread's ClassLoader.
     */
    public static FlavorMap getDefaultFlavorMap() {
        ClassLoader contextClassLoader =
<span class="nc" id="L187">            Thread.currentThread().getContextClassLoader();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (contextClassLoader == null) {</span>
<span class="nc" id="L189">            contextClassLoader = ClassLoader.getSystemClassLoader();</span>
        }

        FlavorMap fm;

<span class="nc" id="L194">        synchronized(flavorMaps) {</span>
<span class="nc" id="L195">            fm = flavorMaps.get(contextClassLoader);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (fm == null) {</span>
<span class="nc" id="L197">                fm = new SystemFlavorMap();</span>
<span class="nc" id="L198">                flavorMaps.put(contextClassLoader, fm);</span>
            }
<span class="nc" id="L200">        }</span>

<span class="nc" id="L202">        return fm;</span>
    }

<span class="nc" id="L205">    private SystemFlavorMap() {</span>
<span class="nc" id="L206">    }</span>

    /**
     * Initializes a SystemFlavorMap by reading flavormap.properties and
     * AWT.DnD.flavorMapFileURL.
     * For thread-safety must be called under lock on this.
     */
    private void initSystemFlavorMap() {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (isMapInitialized) {</span>
<span class="nc" id="L215">            return;</span>
        }

<span class="nc" id="L218">        isMapInitialized = true;</span>
<span class="nc" id="L219">        BufferedReader flavormapDotProperties =</span>
<span class="nc" id="L220">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L221">                new java.security.PrivilegedAction&lt;BufferedReader&gt;() {</span>
                    public BufferedReader run() {
<span class="nc" id="L223">                        String fileName =</span>
<span class="nc" id="L224">                            System.getProperty(&quot;java.home&quot;) +</span>
                            File.separator +
                            &quot;lib&quot; +
                            File.separator +
                            &quot;flavormap.properties&quot;;
                        try {
<span class="nc" id="L230">                            return new BufferedReader</span>
                                (new InputStreamReader
<span class="nc" id="L232">                                    (new File(fileName).toURI().toURL().openStream(), &quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L233">                        } catch (MalformedURLException e) {</span>
<span class="nc" id="L234">                            System.err.println(&quot;MalformedURLException:&quot; + e + &quot; while loading default flavormap.properties file:&quot; + fileName);</span>
<span class="nc" id="L235">                        } catch (IOException e) {</span>
<span class="nc" id="L236">                            System.err.println(&quot;IOException:&quot; + e + &quot; while loading default flavormap.properties file:&quot; + fileName);</span>
<span class="nc" id="L237">                        }</span>
<span class="nc" id="L238">                        return null;</span>
                    }
                });

<span class="nc" id="L242">        BufferedReader flavormapURL =</span>
<span class="nc" id="L243">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L244">                new java.security.PrivilegedAction&lt;BufferedReader&gt;() {</span>
                    public BufferedReader run() {
<span class="nc" id="L246">                        String url = Toolkit.getProperty(&quot;AWT.DnD.flavorMapFileURL&quot;, null);</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">                        if (url == null) {</span>
<span class="nc" id="L249">                            return null;</span>
                        }

                        try {
<span class="nc" id="L253">                            return new BufferedReader</span>
                                (new InputStreamReader
<span class="nc" id="L255">                                    (new URL(url).openStream(), &quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L256">                        } catch (MalformedURLException e) {</span>
<span class="nc" id="L257">                            System.err.println(&quot;MalformedURLException:&quot; + e + &quot; while reading AWT.DnD.flavorMapFileURL:&quot; + url);</span>
<span class="nc" id="L258">                        } catch (IOException e) {</span>
<span class="nc" id="L259">                            System.err.println(&quot;IOException:&quot; + e + &quot; while reading AWT.DnD.flavorMapFileURL:&quot; + url);</span>
<span class="nc" id="L260">                        }</span>
<span class="nc" id="L261">                        return null;</span>
                    }
                });

<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (flavormapDotProperties != null) {</span>
            try {
<span class="nc" id="L267">                parseAndStoreReader(flavormapDotProperties);</span>
<span class="nc" id="L268">            } catch (IOException e) {</span>
<span class="nc" id="L269">                System.err.println(&quot;IOException:&quot; + e + &quot; while parsing default flavormap.properties file&quot;);</span>
<span class="nc" id="L270">            }</span>
        }

<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (flavormapURL != null) {</span>
            try {
<span class="nc" id="L275">                parseAndStoreReader(flavormapURL);</span>
<span class="nc" id="L276">            } catch (IOException e) {</span>
<span class="nc" id="L277">                System.err.println(&quot;IOException:&quot; + e + &quot; while parsing AWT.DnD.flavorMapFileURL&quot;);</span>
<span class="nc" id="L278">            }</span>
        }
<span class="nc" id="L280">    }</span>
    /**
     * Copied code from java.util.Properties. Parsing the data ourselves is the
     * only way to handle duplicate keys and values.
     */
    private void parseAndStoreReader(BufferedReader in) throws IOException {
        while (true) {
            // Get next line
<span class="nc" id="L288">            String line = in.readLine();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (line == null) {</span>
<span class="nc" id="L290">                return;</span>
            }

<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (line.length() &gt; 0) {</span>
                // Continue lines that end in slashes if they are not comments
<span class="nc" id="L295">                char firstChar = line.charAt(0);</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">                if (firstChar != '#' &amp;&amp; firstChar != '!') {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                    while (continueLine(line)) {</span>
<span class="nc" id="L298">                        String nextLine = in.readLine();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                        if (nextLine == null) {</span>
<span class="nc" id="L300">                            nextLine = &quot;&quot;;</span>
                        }
<span class="nc" id="L302">                        String loppedLine =</span>
<span class="nc" id="L303">                            line.substring(0, line.length() - 1);</span>
                        // Advance beyond whitespace on new line
<span class="nc" id="L305">                        int startIndex = 0;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                        for(; startIndex &lt; nextLine.length(); startIndex++) {</span>
<span class="nc" id="L307">                            if (whiteSpaceChars.</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                                    indexOf(nextLine.charAt(startIndex)) == -1)</span>
                            {
<span class="nc" id="L310">                                break;</span>
                            }
                        }
<span class="nc" id="L313">                        nextLine = nextLine.substring(startIndex,</span>
<span class="nc" id="L314">                                                      nextLine.length());</span>
<span class="nc" id="L315">                        line = loppedLine+nextLine;</span>
<span class="nc" id="L316">                    }</span>

                    // Find start of key
<span class="nc" id="L319">                    int len = line.length();</span>
<span class="nc" id="L320">                    int keyStart = 0;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    for(; keyStart &lt; len; keyStart++) {</span>
<span class="nc" id="L322">                        if(whiteSpaceChars.</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                               indexOf(line.charAt(keyStart)) == -1) {</span>
<span class="nc" id="L324">                            break;</span>
                        }
                    }

                    // Blank lines are ignored
<span class="nc bnc" id="L329" title="All 2 branches missed.">                    if (keyStart == len) {</span>
<span class="nc" id="L330">                        continue;</span>
                    }

                    // Find separation between key and value
<span class="nc" id="L334">                    int separatorIndex = keyStart;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                    for(; separatorIndex &lt; len; separatorIndex++) {</span>
<span class="nc" id="L336">                        char currentChar = line.charAt(separatorIndex);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                        if (currentChar == '\\') {</span>
<span class="nc" id="L338">                            separatorIndex++;</span>
<span class="nc" id="L339">                        } else if (keyValueSeparators.</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                                       indexOf(currentChar) != -1) {</span>
<span class="nc" id="L341">                            break;</span>
                        }
                    }

                    // Skip over whitespace after key if any
<span class="nc" id="L346">                    int valueIndex = separatorIndex;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                    for (; valueIndex &lt; len; valueIndex++) {</span>
<span class="nc" id="L348">                        if (whiteSpaceChars.</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                                indexOf(line.charAt(valueIndex)) == -1) {</span>
<span class="nc" id="L350">                            break;</span>
                        }
                    }

                    // Skip over one non whitespace key value separators if any
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (valueIndex &lt; len) {</span>
<span class="nc" id="L356">                        if (strictKeyValueSeparators.</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">                                indexOf(line.charAt(valueIndex)) != -1) {</span>
<span class="nc" id="L358">                            valueIndex++;</span>
                        }
                    }

                    // Skip over white space after other separators if any
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    while (valueIndex &lt; len) {</span>
<span class="nc" id="L364">                        if (whiteSpaceChars.</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                                indexOf(line.charAt(valueIndex)) == -1) {</span>
<span class="nc" id="L366">                            break;</span>
                        }
<span class="nc" id="L368">                        valueIndex++;</span>
                    }

<span class="nc" id="L371">                    String key = line.substring(keyStart, separatorIndex);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                    String value = (separatorIndex &lt; len)</span>
<span class="nc" id="L373">                        ? line.substring(valueIndex, len)</span>
                        : &quot;&quot;;

                    // Convert then store key and value
<span class="nc" id="L377">                    key = loadConvert(key);</span>
<span class="nc" id="L378">                    value = loadConvert(value);</span>

                    try {
<span class="nc" id="L381">                        MimeType mime = new MimeType(value);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                        if (&quot;text&quot;.equals(mime.getPrimaryType())) {</span>
<span class="nc" id="L383">                            String charset = mime.getParameter(&quot;charset&quot;);</span>
<span class="nc" id="L384">                            if (DataTransferer.doesSubtypeSupportCharset</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                                    (mime.getSubType(), charset))</span>
                            {
                                // We need to store the charset and eoln
                                // parameters, if any, so that the
                                // DataTransferer will have this information
                                // for conversion into the native format.
                                DataTransferer transferer =
<span class="nc" id="L392">                                    DataTransferer.getInstance();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                                if (transferer != null) {</span>
<span class="nc" id="L394">                                    transferer.registerTextFlavorProperties</span>
<span class="nc" id="L395">                                        (key, charset,</span>
<span class="nc" id="L396">                                         mime.getParameter(&quot;eoln&quot;),</span>
<span class="nc" id="L397">                                         mime.getParameter(&quot;terminators&quot;));</span>
                                }
                            }

                            // But don't store any of these parameters in the
                            // DataFlavor itself for any text natives (even
                            // non-charset ones). The SystemFlavorMap will
                            // synthesize the appropriate mappings later.
<span class="nc" id="L405">                            mime.removeParameter(&quot;charset&quot;);</span>
<span class="nc" id="L406">                            mime.removeParameter(&quot;class&quot;);</span>
<span class="nc" id="L407">                            mime.removeParameter(&quot;eoln&quot;);</span>
<span class="nc" id="L408">                            mime.removeParameter(&quot;terminators&quot;);</span>
<span class="nc" id="L409">                            value = mime.toString();</span>
                        }
<span class="nc" id="L411">                    } catch (MimeTypeParseException e) {</span>
<span class="nc" id="L412">                        e.printStackTrace();</span>
<span class="nc" id="L413">                        continue;</span>
<span class="nc" id="L414">                    }</span>

                    DataFlavor flavor;
                    try {
<span class="nc" id="L418">                        flavor = new DataFlavor(value);</span>
<span class="nc" id="L419">                    } catch (Exception e) {</span>
                        try {
<span class="nc" id="L421">                            flavor = new DataFlavor(value, (String)null);</span>
<span class="nc" id="L422">                        } catch (Exception ee) {</span>
<span class="nc" id="L423">                            ee.printStackTrace();</span>
<span class="nc" id="L424">                            continue;</span>
<span class="nc" id="L425">                        }</span>
<span class="nc" id="L426">                    }</span>

<span class="nc" id="L428">                    final LinkedHashSet&lt;DataFlavor&gt; dfs = new LinkedHashSet&lt;&gt;();</span>

<span class="nc" id="L430">                    dfs.add(flavor);</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (&quot;text&quot;.equals(flavor.getPrimaryType())) {</span>
<span class="nc" id="L433">                        dfs.addAll(convertMimeTypeToDataFlavors(value));</span>
                    }

<span class="nc bnc" id="L436" title="All 2 branches missed.">                    for (DataFlavor df : dfs) {</span>
<span class="nc" id="L437">                        store(df, key, getFlavorToNative());</span>
<span class="nc" id="L438">                        store(key, df, getNativeToFlavor());</span>
<span class="nc" id="L439">                    }</span>
                }
            }
<span class="nc" id="L442">        }</span>
    }

    /**
     * Copied from java.util.Properties.
     */
    private boolean continueLine (String line) {
<span class="nc" id="L449">        int slashCount = 0;</span>
<span class="nc" id="L450">        int index = line.length() - 1;</span>
<span class="nc bnc" id="L451" title="All 4 branches missed.">        while((index &gt;= 0) &amp;&amp; (line.charAt(index--) == '\\')) {</span>
<span class="nc" id="L452">            slashCount++;</span>
        }
<span class="nc bnc" id="L454" title="All 2 branches missed.">        return (slashCount % 2 == 1);</span>
    }

    /**
     * Copied from java.util.Properties.
     */
    private String loadConvert(String theString) {
        char aChar;
<span class="nc" id="L462">        int len = theString.length();</span>
<span class="nc" id="L463">        StringBuilder outBuffer = new StringBuilder(len);</span>

<span class="nc bnc" id="L465" title="All 2 branches missed.">        for (int x = 0; x &lt; len; ) {</span>
<span class="nc" id="L466">            aChar = theString.charAt(x++);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (aChar == '\\') {</span>
<span class="nc" id="L468">                aChar = theString.charAt(x++);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if (aChar == 'u') {</span>
                    // Read the xxxx
<span class="nc" id="L471">                    int value = 0;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                    for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L473">                        aChar = theString.charAt(x++);</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                        switch (aChar) {</span>
                          case '0': case '1': case '2': case '3': case '4':
                          case '5': case '6': case '7': case '8': case '9': {
<span class="nc" id="L477">                             value = (value &lt;&lt; 4) + aChar - '0';</span>
<span class="nc" id="L478">                             break;</span>
                          }
                          case 'a': case 'b': case 'c':
                          case 'd': case 'e': case 'f': {
<span class="nc" id="L482">                             value = (value &lt;&lt; 4) + 10 + aChar - 'a';</span>
<span class="nc" id="L483">                             break;</span>
                          }
                          case 'A': case 'B': case 'C':
                          case 'D': case 'E': case 'F': {
<span class="nc" id="L487">                             value = (value &lt;&lt; 4) + 10 + aChar - 'A';</span>
<span class="nc" id="L488">                             break;</span>
                          }
                          default: {
<span class="nc" id="L491">                              throw new IllegalArgumentException(</span>
                                           &quot;Malformed \\uxxxx encoding.&quot;);
                          }
                        }
                    }
<span class="nc" id="L496">                    outBuffer.append((char)value);</span>
<span class="nc" id="L497">                } else {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (aChar == 't') {</span>
<span class="nc" id="L499">                        aChar = '\t';</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                    } else if (aChar == 'r') {</span>
<span class="nc" id="L501">                        aChar = '\r';</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                    } else if (aChar == 'n') {</span>
<span class="nc" id="L503">                        aChar = '\n';</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                    } else if (aChar == 'f') {</span>
<span class="nc" id="L505">                        aChar = '\f';</span>
                    }
<span class="nc" id="L507">                    outBuffer.append(aChar);</span>
                }
            } else {
<span class="nc" id="L510">                outBuffer.append(aChar);</span>
            }
        }
<span class="nc" id="L513">        return outBuffer.toString();</span>
    }

    /**
     * Stores the listed object under the specified hash key in map. Unlike a
     * standard map, the listed object will not replace any object already at
     * the appropriate Map location, but rather will be appended to a List
     * stored in that location.
     */
    private &lt;H, L&gt; void store(H hashed, L listed, Map&lt;H, List&lt;L&gt;&gt; map) {
<span class="nc" id="L523">        List&lt;L&gt; list = map.get(hashed);</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L525">            list = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L526">            map.put(hashed, list);</span>
        }
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (!list.contains(listed)) {</span>
<span class="nc" id="L529">            list.add(listed);</span>
        }
<span class="nc" id="L531">    }</span>

    /**
     * Semantically equivalent to 'nativeToFlavor.get(nat)'. This method
     * handles the case where 'nat' is not found in 'nativeToFlavor'. In that
     * case, a new DataFlavor is synthesized, stored, and returned, if and
     * only if the specified native is encoded as a Java MIME type.
     */
    private List&lt;DataFlavor&gt; nativeToFlavorLookup(String nat) {
<span class="nc" id="L540">        List&lt;DataFlavor&gt; flavors = getNativeToFlavor().get(nat);</span>

<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (nat != null &amp;&amp; !disabledMappingGenerationKeys.contains(nat)) {</span>
<span class="nc" id="L543">            DataTransferer transferer = DataTransferer.getInstance();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (transferer != null) {</span>
<span class="nc" id="L545">                List&lt;DataFlavor&gt; platformFlavors =</span>
<span class="nc" id="L546">                    transferer.getPlatformMappingsForNative(nat);</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (!platformFlavors.isEmpty()) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                    if (flavors != null) {</span>
<span class="nc" id="L549">                        platformFlavors.removeAll(new HashSet&lt;&gt;(flavors));</span>
                        // Prepending the platform-specific mappings ensures
                        // that the flavors added with
                        // addFlavorForUnencodedNative() are at the end of
                        // list.
<span class="nc" id="L554">                        platformFlavors.addAll(flavors);</span>
                    }
<span class="nc" id="L556">                    flavors = platformFlavors;</span>
                }
            }
        }

<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (flavors == null &amp;&amp; isJavaMIMEType(nat)) {</span>
<span class="nc" id="L562">            String decoded = decodeJavaMIMEType(nat);</span>
<span class="nc" id="L563">            DataFlavor flavor = null;</span>

            try {
<span class="nc" id="L566">                flavor = new DataFlavor(decoded);</span>
<span class="nc" id="L567">            } catch (Exception e) {</span>
<span class="nc" id="L568">                System.err.println(&quot;Exception \&quot;&quot; + e.getClass().getName() +</span>
<span class="nc" id="L569">                                   &quot;: &quot; + e.getMessage()  +</span>
                                   &quot;\&quot;while constructing DataFlavor for: &quot; +
                                   decoded);
<span class="nc" id="L572">            }</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (flavor != null) {</span>
<span class="nc" id="L575">                flavors = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L576">                getNativeToFlavor().put(nat, flavors);</span>
<span class="nc" id="L577">                flavors.add(flavor);</span>
<span class="nc" id="L578">                getFlavorsForNativeCache.remove(nat);</span>
<span class="nc" id="L579">                getFlavorsForNativeCache.remove(null);</span>

<span class="nc" id="L581">                List&lt;String&gt; natives = getFlavorToNative().get(flavor);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (natives == null) {</span>
<span class="nc" id="L583">                    natives = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L584">                    getFlavorToNative().put(flavor, natives);</span>
                }
<span class="nc" id="L586">                natives.add(nat);</span>
<span class="nc" id="L587">                getNativesForFlavorCache.remove(flavor);</span>
<span class="nc" id="L588">                getNativesForFlavorCache.remove(null);</span>
            }
        }

<span class="nc bnc" id="L592" title="All 2 branches missed.">        return (flavors != null) ? flavors : new ArrayList&lt;&gt;(0);</span>
    }

    /**
     * Semantically equivalent to 'flavorToNative.get(flav)'. This method
     * handles the case where 'flav' is not found in 'flavorToNative' depending
     * on the value of passes 'synthesize' parameter. If 'synthesize' is
     * SYNTHESIZE_IF_NOT_FOUND a native is synthesized, stored, and returned by
     * encoding the DataFlavor's MIME type. Otherwise an empty List is returned
     * and 'flavorToNative' remains unaffected.
     */
    private List&lt;String&gt; flavorToNativeLookup(final DataFlavor flav,
                                              final boolean synthesize) {
<span class="nc" id="L605">        List&lt;String&gt; natives = getFlavorToNative().get(flav);</span>

<span class="nc bnc" id="L607" title="All 4 branches missed.">        if (flav != null &amp;&amp; !disabledMappingGenerationKeys.contains(flav)) {</span>
<span class="nc" id="L608">            DataTransferer transferer = DataTransferer.getInstance();</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (transferer != null) {</span>
<span class="nc" id="L610">                List&lt;String&gt; platformNatives =</span>
<span class="nc" id="L611">                    transferer.getPlatformMappingsForFlavor(flav);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                if (!platformNatives.isEmpty()) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                    if (natives != null) {</span>
<span class="nc" id="L614">                        platformNatives.removeAll(new HashSet&lt;&gt;(natives));</span>
                        // Prepend the platform-specific mappings to ensure
                        // that the natives added with
                        // addUnencodedNativeForFlavor() are at the end of
                        // list.
<span class="nc" id="L619">                        platformNatives.addAll(natives);</span>
                    }
<span class="nc" id="L621">                    natives = platformNatives;</span>
                }
            }
        }

<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (natives == null) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (synthesize) {</span>
<span class="nc" id="L628">                String encoded = encodeDataFlavor(flav);</span>
<span class="nc" id="L629">                natives = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L630">                getFlavorToNative().put(flav, natives);</span>
<span class="nc" id="L631">                natives.add(encoded);</span>
<span class="nc" id="L632">                getNativesForFlavorCache.remove(flav);</span>
<span class="nc" id="L633">                getNativesForFlavorCache.remove(null);</span>

<span class="nc" id="L635">                List&lt;DataFlavor&gt; flavors = getNativeToFlavor().get(encoded);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                if (flavors == null) {</span>
<span class="nc" id="L637">                    flavors = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L638">                    getNativeToFlavor().put(encoded, flavors);</span>
                }
<span class="nc" id="L640">                flavors.add(flav);</span>
<span class="nc" id="L641">                getFlavorsForNativeCache.remove(encoded);</span>
<span class="nc" id="L642">                getFlavorsForNativeCache.remove(null);</span>
<span class="nc" id="L643">            } else {</span>
<span class="nc" id="L644">                natives = new ArrayList&lt;&gt;(0);</span>
            }
        }

<span class="nc" id="L648">        return natives;</span>
    }

    /**
     * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; natives to which the
     * specified &lt;code&gt;DataFlavor&lt;/code&gt; can be translated by the data transfer
     * subsystem. The &lt;code&gt;List&lt;/code&gt; will be sorted from best native to
     * worst. That is, the first native will best reflect data in the specified
     * flavor to the underlying native platform.
     * &lt;p&gt;
     * If the specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the
     * data transfer subsystem and the data transfer subsystem is unable to
     * translate this &lt;code&gt;DataFlavor&lt;/code&gt; to any existing native, then
     * invoking this method will establish a
     * mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt;
     * and an encoded version of its MIME type as its native.
     *
     * @param flav the &lt;code&gt;DataFlavor&lt;/code&gt; whose corresponding natives
     *        should be returned. If &lt;code&gt;null&lt;/code&gt; is specified, all
     *        natives currently known to the data transfer subsystem are
     *        returned in a non-deterministic order.
     * @return a &lt;code&gt;java.util.List&lt;/code&gt; of &lt;code&gt;java.lang.String&lt;/code&gt;
     *         objects which are platform-specific representations of platform-
     *         specific data formats
     *
     * @see #encodeDataFlavor
     * @since 1.4
     */
    public synchronized List&lt;String&gt; getNativesForFlavor(DataFlavor flav) {
<span class="nc" id="L677">        List&lt;String&gt; retval = null;</span>

        // Check cache, even for null flav
<span class="nc" id="L680">        SoftReference&lt;List&lt;String&gt;&gt; ref = getNativesForFlavorCache.get(flav);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if (ref != null) {</span>
<span class="nc" id="L682">            retval = ref.get();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (retval != null) {</span>
                // Create a copy, because client code can modify the returned
                // list.
<span class="nc" id="L686">                return new ArrayList&lt;&gt;(retval);</span>
            }
        }

<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (flav == null) {</span>
<span class="nc" id="L691">            retval = new ArrayList&lt;&gt;(getNativeToFlavor().keySet());</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        } else if (disabledMappingGenerationKeys.contains(flav)) {</span>
            // In this case we shouldn't synthesize a native for this flavor,
            // since its mappings were explicitly specified.
<span class="nc" id="L695">            retval = flavorToNativeLookup(flav, !SYNTHESIZE_IF_NOT_FOUND);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (DataTransferer.isFlavorCharsetTextType(flav)) {</span>

            // For text/* flavors, flavor-to-native mappings specified in
            // flavormap.properties are stored per flavor's base type.
<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (&quot;text&quot;.equals(flav.getPrimaryType())) {</span>
<span class="nc" id="L701">                retval = getAllNativesForType(flav.mimeType.getBaseType());</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (retval != null) {</span>
                    // To prevent the List stored in the map from modification.
<span class="nc" id="L704">                    retval = new ArrayList(retval);</span>
                }
            }

            // Also include text/plain natives, but don't duplicate Strings
<span class="nc" id="L709">            List&lt;String&gt; textPlainList = getAllNativesForType(TEXT_PLAIN_BASE_TYPE);</span>

<span class="nc bnc" id="L711" title="All 4 branches missed.">            if (textPlainList != null &amp;&amp; !textPlainList.isEmpty()) {</span>
                // To prevent the List stored in the map from modification.
                // This also guarantees that removeAll() is supported.
<span class="nc" id="L714">                textPlainList = new ArrayList&lt;&gt;(textPlainList);</span>
<span class="nc bnc" id="L715" title="All 4 branches missed.">                if (retval != null &amp;&amp; !retval.isEmpty()) {</span>
                    // Use HashSet to get constant-time performance for search.
<span class="nc" id="L717">                    textPlainList.removeAll(new HashSet&lt;&gt;(retval));</span>
<span class="nc" id="L718">                    retval.addAll(textPlainList);</span>
                } else {
<span class="nc" id="L720">                    retval = textPlainList;</span>
                }
            }

<span class="nc bnc" id="L724" title="All 4 branches missed.">            if (retval == null || retval.isEmpty()) {</span>
<span class="nc" id="L725">                retval = flavorToNativeLookup(flav, SYNTHESIZE_IF_NOT_FOUND);</span>
            } else {
                // In this branch it is guaranteed that natives explicitly
                // listed for flav's MIME type were added with
                // addUnencodedNativeForFlavor(), so they have lower priority.
<span class="nc" id="L730">                List&lt;String&gt; explicitList =</span>
<span class="nc" id="L731">                    flavorToNativeLookup(flav, !SYNTHESIZE_IF_NOT_FOUND);</span>

                // flavorToNativeLookup() never returns null.
                // It can return an empty List, however.
<span class="nc bnc" id="L735" title="All 2 branches missed.">                if (!explicitList.isEmpty()) {</span>
                    // To prevent the List stored in the map from modification.
                    // This also guarantees that removeAll() is supported.
<span class="nc" id="L738">                    explicitList = new ArrayList&lt;&gt;(explicitList);</span>
                    // Use HashSet to get constant-time performance for search.
<span class="nc" id="L740">                    explicitList.removeAll(new HashSet&lt;&gt;(retval));</span>
<span class="nc" id="L741">                    retval.addAll(explicitList);</span>
                }
            }
<span class="nc bnc" id="L744" title="All 2 branches missed.">        } else if (DataTransferer.isFlavorNoncharsetTextType(flav)) {</span>
<span class="nc" id="L745">            retval = getAllNativesForType(flav.mimeType.getBaseType());</span>

<span class="nc bnc" id="L747" title="All 4 branches missed.">            if (retval == null || retval.isEmpty()) {</span>
<span class="nc" id="L748">                retval = flavorToNativeLookup(flav, SYNTHESIZE_IF_NOT_FOUND);</span>
            } else {
                // In this branch it is guaranteed that natives explicitly
                // listed for flav's MIME type were added with
                // addUnencodedNativeForFlavor(), so they have lower priority.
<span class="nc" id="L753">                List&lt;String&gt; explicitList =</span>
<span class="nc" id="L754">                    flavorToNativeLookup(flav, !SYNTHESIZE_IF_NOT_FOUND);</span>

                // flavorToNativeLookup() never returns null.
                // It can return an empty List, however.
<span class="nc bnc" id="L758" title="All 2 branches missed.">                if (!explicitList.isEmpty()) {</span>
                    // To prevent the List stored in the map from modification.
                    // This also guarantees that add/removeAll() are supported.
<span class="nc" id="L761">                    retval = new ArrayList&lt;&gt;(retval);</span>
<span class="nc" id="L762">                    explicitList = new ArrayList&lt;&gt;(explicitList);</span>
                    // Use HashSet to get constant-time performance for search.
<span class="nc" id="L764">                    explicitList.removeAll(new HashSet&lt;&gt;(retval));</span>
<span class="nc" id="L765">                    retval.addAll(explicitList);</span>
                }
<span class="nc" id="L767">            }</span>
        } else {
<span class="nc" id="L769">            retval = flavorToNativeLookup(flav, SYNTHESIZE_IF_NOT_FOUND);</span>
        }

<span class="nc" id="L772">        getNativesForFlavorCache.put(flav, new SoftReference&lt;&gt;(retval));</span>
        // Create a copy, because client code can modify the returned list.
<span class="nc" id="L774">        return new ArrayList&lt;&gt;(retval);</span>
    }

    /**
     * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;DataFlavor&lt;/code&gt;s to which the
     * specified &lt;code&gt;String&lt;/code&gt; native can be translated by the data
     * transfer subsystem. The &lt;code&gt;List&lt;/code&gt; will be sorted from best
     * &lt;code&gt;DataFlavor&lt;/code&gt; to worst. That is, the first
     * &lt;code&gt;DataFlavor&lt;/code&gt; will best reflect data in the specified
     * native to a Java application.
     * &lt;p&gt;
     * If the specified native is previously unknown to the data transfer
     * subsystem, and that native has been properly encoded, then invoking this
     * method will establish a mapping in both directions between the specified
     * native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded
     * version of the native.
     * &lt;p&gt;
     * If the specified native is not a properly encoded native and the
     * mappings for this native have not been altered with
     * &lt;code&gt;setFlavorsForNative&lt;/code&gt;, then the contents of the
     * &lt;code&gt;List&lt;/code&gt; is platform dependent, but &lt;code&gt;null&lt;/code&gt;
     * cannot be returned.
     *
     * @param nat the native whose corresponding &lt;code&gt;DataFlavor&lt;/code&gt;s
     *        should be returned. If &lt;code&gt;null&lt;/code&gt; is specified, all
     *        &lt;code&gt;DataFlavor&lt;/code&gt;s currently known to the data transfer
     *        subsystem are returned in a non-deterministic order.
     * @return a &lt;code&gt;java.util.List&lt;/code&gt; of &lt;code&gt;DataFlavor&lt;/code&gt;
     *         objects into which platform-specific data in the specified,
     *         platform-specific native can be translated
     *
     * @see #encodeJavaMIMEType
     * @since 1.4
     */
    public synchronized List&lt;DataFlavor&gt; getFlavorsForNative(String nat) {

        // Check cache, even for null nat
<span class="nc" id="L811">        SoftReference&lt;List&lt;DataFlavor&gt;&gt; ref = getFlavorsForNativeCache.get(nat);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (ref != null) {</span>
<span class="nc" id="L813">            List&lt;DataFlavor&gt; retval = ref.get();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (retval != null) {</span>
<span class="nc" id="L815">                return new ArrayList&lt;&gt;(retval);</span>
            }
        }

<span class="nc" id="L819">        final LinkedHashSet &lt;DataFlavor&gt; returnValue =</span>
            new LinkedHashSet&lt;&gt;();

<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (nat == null) {</span>
<span class="nc" id="L823">            final List&lt;String&gt; natives = getNativesForFlavor(null);</span>

<span class="nc bnc" id="L825" title="All 2 branches missed.">            for (String n : natives)</span>
            {
<span class="nc" id="L827">                final List&lt;DataFlavor&gt; flavors = getFlavorsForNative(n);</span>

<span class="nc bnc" id="L829" title="All 2 branches missed.">                for (DataFlavor df : flavors)</span>
                {
<span class="nc" id="L831">                    returnValue.add(df);</span>
<span class="nc" id="L832">                }</span>
<span class="nc" id="L833">            }</span>
<span class="nc" id="L834">        } else {</span>

<span class="nc" id="L836">            final List&lt;DataFlavor&gt; flavors = nativeToFlavorLookup(nat);</span>

<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (disabledMappingGenerationKeys.contains(nat)) {</span>
<span class="nc" id="L839">                return flavors;</span>
            }

<span class="nc" id="L842">            final List&lt;DataFlavor&gt; flavorsAndBaseTypes =</span>
<span class="nc" id="L843">                nativeToFlavorLookup(nat);</span>

<span class="nc bnc" id="L845" title="All 2 branches missed.">            for (DataFlavor df : flavorsAndBaseTypes) {</span>
<span class="nc" id="L846">                returnValue.add(df);</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">                if (&quot;text&quot;.equals(df.getPrimaryType())) {</span>
                    try {
<span class="nc" id="L849">                        returnValue.addAll(</span>
<span class="nc" id="L850">                                convertMimeTypeToDataFlavors(</span>
<span class="nc" id="L851">                                        new MimeType(df.getMimeType()</span>
<span class="nc" id="L852">                                        ).getBaseType()));</span>
<span class="nc" id="L853">                    } catch (MimeTypeParseException e) {</span>
<span class="nc" id="L854">                        e.printStackTrace();</span>
<span class="nc" id="L855">                    }</span>
                }
<span class="nc" id="L857">            }</span>

        }

<span class="nc" id="L861">        final List&lt;DataFlavor&gt; arrayList = new ArrayList&lt;&gt;(returnValue);</span>
<span class="nc" id="L862">        getFlavorsForNativeCache.put(nat, new SoftReference&lt;&gt;(arrayList));</span>
<span class="nc" id="L863">        return new ArrayList&lt;&gt;(arrayList);</span>
    }

    private static Set&lt;DataFlavor&gt; convertMimeTypeToDataFlavors(
        final String baseType) {

<span class="nc" id="L869">        final Set&lt;DataFlavor&gt; returnValue = new LinkedHashSet&lt;&gt;();</span>

<span class="nc" id="L871">        String subType = null;</span>

        try {
<span class="nc" id="L874">            final MimeType mimeType = new MimeType(baseType);</span>
<span class="nc" id="L875">            subType = mimeType.getSubType();</span>
<span class="nc" id="L876">        } catch (MimeTypeParseException mtpe) {</span>
            // Cannot happen, since we checked all mappings
            // on load from flavormap.properties.
<span class="nc bnc" id="L879" title="All 2 branches missed.">            assert(false);</span>
<span class="nc" id="L880">        }</span>

<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (DataTransferer.doesSubtypeSupportCharset(subType, null)) {</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (TEXT_PLAIN_BASE_TYPE.equals(baseType))</span>
            {
<span class="nc" id="L885">                returnValue.add(DataFlavor.stringFlavor);</span>
            }

<span class="nc bnc" id="L888" title="All 2 branches missed.">            for (String unicodeClassName : UNICODE_TEXT_CLASSES) {</span>
<span class="nc" id="L889">                final String mimeType = baseType + &quot;;charset=Unicode;class=&quot; +</span>
                                            unicodeClassName;

<span class="nc" id="L892">                final LinkedHashSet&lt;String&gt; mimeTypes =</span>
<span class="nc" id="L893">                    handleHtmlMimeTypes(baseType, mimeType);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                for (String mt : mimeTypes) {</span>
<span class="nc" id="L895">                    DataFlavor toAdd = null;</span>
                    try {
<span class="nc" id="L897">                        toAdd = new DataFlavor(mt);</span>
<span class="nc" id="L898">                    } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L899">                    }</span>
<span class="nc" id="L900">                    returnValue.add(toAdd);</span>
<span class="nc" id="L901">                }</span>
            }

<span class="nc bnc" id="L904" title="All 2 branches missed.">            for (String charset : DataTransferer.standardEncodings()) {</span>

<span class="nc bnc" id="L906" title="All 2 branches missed.">                for (String encodedTextClass : ENCODED_TEXT_CLASSES) {</span>
<span class="nc" id="L907">                    final String mimeType =</span>
                            baseType + &quot;;charset=&quot; + charset +
                            &quot;;class=&quot; + encodedTextClass;

<span class="nc" id="L911">                    final LinkedHashSet&lt;String&gt; mimeTypes =</span>
<span class="nc" id="L912">                        handleHtmlMimeTypes(baseType, mimeType);</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">                    for (String mt : mimeTypes) {</span>

<span class="nc" id="L916">                        DataFlavor df = null;</span>

                        try {
<span class="nc" id="L919">                            df = new DataFlavor(mt);</span>
                            // Check for equality to plainTextFlavor so
                            // that we can ensure that the exact charset of
                            // plainTextFlavor, not the canonical charset
                            // or another equivalent charset with a
                            // different name, is used.
<span class="nc bnc" id="L925" title="All 2 branches missed.">                            if (df.equals(DataFlavor.plainTextFlavor)) {</span>
<span class="nc" id="L926">                                df = DataFlavor.plainTextFlavor;</span>
                            }
<span class="nc" id="L928">                        } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L929">                        }</span>

<span class="nc" id="L931">                        returnValue.add(df);</span>
<span class="nc" id="L932">                    }</span>
                }
<span class="nc" id="L934">            }</span>

<span class="nc bnc" id="L936" title="All 2 branches missed.">            if (TEXT_PLAIN_BASE_TYPE.equals(baseType))</span>
            {
<span class="nc" id="L938">                returnValue.add(DataFlavor.plainTextFlavor);</span>
            }
        } else {
            // Non-charset text natives should be treated as
            // opaque, 8-bit data in any of its various
            // representations.
<span class="nc bnc" id="L944" title="All 2 branches missed.">            for (String encodedTextClassName : ENCODED_TEXT_CLASSES) {</span>
<span class="nc" id="L945">                DataFlavor toAdd = null;</span>
                try {
<span class="nc" id="L947">                    toAdd = new DataFlavor(baseType +</span>
                         &quot;;class=&quot; + encodedTextClassName);
<span class="nc" id="L949">                } catch (ClassNotFoundException cannotHappen) {</span>
<span class="nc" id="L950">                }</span>
<span class="nc" id="L951">                returnValue.add(toAdd);</span>
            }
        }
<span class="nc" id="L954">        return returnValue;</span>
    }

<span class="nc" id="L957">    private static final String [] htmlDocumntTypes =</span>
        new String [] {&quot;all&quot;, &quot;selection&quot;, &quot;fragment&quot;};

    private static LinkedHashSet&lt;String&gt; handleHtmlMimeTypes(
        String baseType, String mimeType) {

<span class="nc" id="L963">        LinkedHashSet&lt;String&gt; returnValues = new LinkedHashSet&lt;&gt;();</span>

<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (HTML_TEXT_BASE_TYPE.equals(baseType)) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">            for (String documentType : htmlDocumntTypes) {</span>
<span class="nc" id="L967">                returnValues.add(mimeType + &quot;;document=&quot; + documentType);</span>
            }
        } else {
<span class="nc" id="L970">            returnValues.add(mimeType);</span>
        }

<span class="nc" id="L973">        return returnValues;</span>
    }

    /**
     * Returns a &lt;code&gt;Map&lt;/code&gt; of the specified &lt;code&gt;DataFlavor&lt;/code&gt;s to
     * their most preferred &lt;code&gt;String&lt;/code&gt; native. Each native value will
     * be the same as the first native in the List returned by
     * &lt;code&gt;getNativesForFlavor&lt;/code&gt; for the specified flavor.
     * &lt;p&gt;
     * If a specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the
     * data transfer subsystem, then invoking this method will establish a
     * mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt;
     * and an encoded version of its MIME type as its native.
     *
     * @param flavors an array of &lt;code&gt;DataFlavor&lt;/code&gt;s which will be the
     *        key set of the returned &lt;code&gt;Map&lt;/code&gt;. If &lt;code&gt;null&lt;/code&gt; is
     *        specified, a mapping of all &lt;code&gt;DataFlavor&lt;/code&gt;s known to the
     *        data transfer subsystem to their most preferred
     *        &lt;code&gt;String&lt;/code&gt; natives will be returned.
     * @return a &lt;code&gt;java.util.Map&lt;/code&gt; of &lt;code&gt;DataFlavor&lt;/code&gt;s to
     *         &lt;code&gt;String&lt;/code&gt; natives
     *
     * @see #getNativesForFlavor
     * @see #encodeDataFlavor
     */
    public synchronized Map&lt;DataFlavor,String&gt;
        getNativesForFlavors(DataFlavor[] flavors)
    {
        // Use getNativesForFlavor to generate extra natives for text flavors
        // and stringFlavor

<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (flavors == null) {</span>
<span class="nc" id="L1005">            List flavor_list = getFlavorsForNative(null);</span>
<span class="nc" id="L1006">            flavors = new DataFlavor[flavor_list.size()];</span>
<span class="nc" id="L1007">            flavor_list.toArray(flavors);</span>
        }

<span class="nc" id="L1010">        Map&lt;DataFlavor, String&gt; retval = new HashMap&lt;&gt;(flavors.length, 1.0f);</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        for (DataFlavor flavor : flavors) {</span>
<span class="nc" id="L1012">            List&lt;String&gt; natives = getNativesForFlavor(flavor);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            String nat = (natives.isEmpty()) ? null : natives.get(0);</span>
<span class="nc" id="L1014">            retval.put(flavor, nat);</span>
        }

<span class="nc" id="L1017">        return retval;</span>
    }

    /**
     * Returns a &lt;code&gt;Map&lt;/code&gt; of the specified &lt;code&gt;String&lt;/code&gt; natives
     * to their most preferred &lt;code&gt;DataFlavor&lt;/code&gt;. Each
     * &lt;code&gt;DataFlavor&lt;/code&gt; value will be the same as the first
     * &lt;code&gt;DataFlavor&lt;/code&gt; in the List returned by
     * &lt;code&gt;getFlavorsForNative&lt;/code&gt; for the specified native.
     * &lt;p&gt;
     * If a specified native is previously unknown to the data transfer
     * subsystem, and that native has been properly encoded, then invoking this
     * method will establish a mapping in both directions between the specified
     * native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded
     * version of the native.
     *
     * @param natives an array of &lt;code&gt;String&lt;/code&gt;s which will be the
     *        key set of the returned &lt;code&gt;Map&lt;/code&gt;. If &lt;code&gt;null&lt;/code&gt; is
     *        specified, a mapping of all supported &lt;code&gt;String&lt;/code&gt; natives
     *        to their most preferred &lt;code&gt;DataFlavor&lt;/code&gt;s will be
     *        returned.
     * @return a &lt;code&gt;java.util.Map&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; natives to
     *         &lt;code&gt;DataFlavor&lt;/code&gt;s
     *
     * @see #getFlavorsForNative
     * @see #encodeJavaMIMEType
     */
    public synchronized Map&lt;String,DataFlavor&gt;
        getFlavorsForNatives(String[] natives)
    {
        // Use getFlavorsForNative to generate extra flavors for text natives

<span class="nc bnc" id="L1049" title="All 2 branches missed.">        if (natives == null) {</span>
<span class="nc" id="L1050">            List native_list = getNativesForFlavor(null);</span>
<span class="nc" id="L1051">            natives = new String[native_list.size()];</span>
<span class="nc" id="L1052">            native_list.toArray(natives);</span>
        }

<span class="nc" id="L1055">        Map&lt;String, DataFlavor&gt; retval = new HashMap&lt;&gt;(natives.length, 1.0f);</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        for (String aNative : natives) {</span>
<span class="nc" id="L1057">            List&lt;DataFlavor&gt; flavors = getFlavorsForNative(aNative);</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            DataFlavor flav = (flavors.isEmpty())? null : flavors.get(0);</span>
<span class="nc" id="L1059">            retval.put(aNative, flav);</span>
        }

<span class="nc" id="L1062">        return retval;</span>
    }

    /**
     * Adds a mapping from the specified &lt;code&gt;DataFlavor&lt;/code&gt; (and all
     * &lt;code&gt;DataFlavor&lt;/code&gt;s equal to the specified &lt;code&gt;DataFlavor&lt;/code&gt;)
     * to the specified &lt;code&gt;String&lt;/code&gt; native.
     * Unlike &lt;code&gt;getNativesForFlavor&lt;/code&gt;, the mapping will only be
     * established in one direction, and the native will not be encoded. To
     * establish a two-way mapping, call
     * &lt;code&gt;addFlavorForUnencodedNative&lt;/code&gt; as well. The new mapping will
     * be of lower priority than any existing mapping.
     * This method has no effect if a mapping from the specified or equal
     * &lt;code&gt;DataFlavor&lt;/code&gt; to the specified &lt;code&gt;String&lt;/code&gt; native
     * already exists.
     *
     * @param flav the &lt;code&gt;DataFlavor&lt;/code&gt; key for the mapping
     * @param nat the &lt;code&gt;String&lt;/code&gt; native value for the mapping
     * @throws NullPointerException if flav or nat is &lt;code&gt;null&lt;/code&gt;
     *
     * @see #addFlavorForUnencodedNative
     * @since 1.4
     */
    public synchronized void addUnencodedNativeForFlavor(DataFlavor flav,
                                                         String nat) {
<span class="nc bnc" id="L1087" title="All 4 branches missed.">        if (flav == null || nat == null) {</span>
<span class="nc" id="L1088">            throw new NullPointerException(&quot;null arguments not permitted&quot;);</span>
        }

<span class="nc" id="L1091">        List&lt;String&gt; natives = getFlavorToNative().get(flav);</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (natives == null) {</span>
<span class="nc" id="L1093">            natives = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L1094">            getFlavorToNative().put(flav, natives);</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        } else if (natives.contains(nat)) {</span>
<span class="nc" id="L1096">            return;</span>
        }
<span class="nc" id="L1098">        natives.add(nat);</span>
<span class="nc" id="L1099">        getNativesForFlavorCache.remove(flav);</span>
<span class="nc" id="L1100">        getNativesForFlavorCache.remove(null);</span>
<span class="nc" id="L1101">    }</span>

    /**
     * Discards the current mappings for the specified &lt;code&gt;DataFlavor&lt;/code&gt;
     * and all &lt;code&gt;DataFlavor&lt;/code&gt;s equal to the specified
     * &lt;code&gt;DataFlavor&lt;/code&gt;, and creates new mappings to the
     * specified &lt;code&gt;String&lt;/code&gt; natives.
     * Unlike &lt;code&gt;getNativesForFlavor&lt;/code&gt;, the mappings will only be
     * established in one direction, and the natives will not be encoded. To
     * establish two-way mappings, call &lt;code&gt;setFlavorsForNative&lt;/code&gt;
     * as well. The first native in the array will represent the highest
     * priority mapping. Subsequent natives will represent mappings of
     * decreasing priority.
     * &lt;p&gt;
     * If the array contains several elements that reference equal
     * &lt;code&gt;String&lt;/code&gt; natives, this method will establish new mappings
     * for the first of those elements and ignore the rest of them.
     * &lt;p&gt;
     * It is recommended that client code not reset mappings established by the
     * data transfer subsystem. This method should only be used for
     * application-level mappings.
     *
     * @param flav the &lt;code&gt;DataFlavor&lt;/code&gt; key for the mappings
     * @param natives the &lt;code&gt;String&lt;/code&gt; native values for the mappings
     * @throws NullPointerException if flav or natives is &lt;code&gt;null&lt;/code&gt;
     *         or if natives contains &lt;code&gt;null&lt;/code&gt; elements
     *
     * @see #setFlavorsForNative
     * @since 1.4
     */
    public synchronized void setNativesForFlavor(DataFlavor flav,
                                                 String[] natives) {
<span class="nc bnc" id="L1133" title="All 4 branches missed.">        if (flav == null || natives == null) {</span>
<span class="nc" id="L1134">            throw new NullPointerException(&quot;null arguments not permitted&quot;);</span>
        }

<span class="nc" id="L1137">        getFlavorToNative().remove(flav);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">        for (String aNative : natives) {</span>
<span class="nc" id="L1139">            addUnencodedNativeForFlavor(flav, aNative);</span>
        }
<span class="nc" id="L1141">        disabledMappingGenerationKeys.add(flav);</span>
        // Clear the cache to handle the case of empty natives.
<span class="nc" id="L1143">        getNativesForFlavorCache.remove(flav);</span>
<span class="nc" id="L1144">        getNativesForFlavorCache.remove(null);</span>
<span class="nc" id="L1145">    }</span>

    /**
     * Adds a mapping from a single &lt;code&gt;String&lt;/code&gt; native to a single
     * &lt;code&gt;DataFlavor&lt;/code&gt;. Unlike &lt;code&gt;getFlavorsForNative&lt;/code&gt;, the
     * mapping will only be established in one direction, and the native will
     * not be encoded. To establish a two-way mapping, call
     * &lt;code&gt;addUnencodedNativeForFlavor&lt;/code&gt; as well. The new mapping will
     * be of lower priority than any existing mapping.
     * This method has no effect if a mapping from the specified
     * &lt;code&gt;String&lt;/code&gt; native to the specified or equal
     * &lt;code&gt;DataFlavor&lt;/code&gt; already exists.
     *
     * @param nat the &lt;code&gt;String&lt;/code&gt; native key for the mapping
     * @param flav the &lt;code&gt;DataFlavor&lt;/code&gt; value for the mapping
     * @throws NullPointerException if nat or flav is &lt;code&gt;null&lt;/code&gt;
     *
     * @see #addUnencodedNativeForFlavor
     * @since 1.4
     */
    public synchronized void addFlavorForUnencodedNative(String nat,
                                                         DataFlavor flav) {
<span class="nc bnc" id="L1167" title="All 4 branches missed.">        if (nat == null || flav == null) {</span>
<span class="nc" id="L1168">            throw new NullPointerException(&quot;null arguments not permitted&quot;);</span>
        }

<span class="nc" id="L1171">        List&lt;DataFlavor&gt; flavors = getNativeToFlavor().get(nat);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (flavors == null) {</span>
<span class="nc" id="L1173">            flavors = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L1174">            getNativeToFlavor().put(nat, flavors);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">        } else if (flavors.contains(flav)) {</span>
<span class="nc" id="L1176">            return;</span>
        }
<span class="nc" id="L1178">        flavors.add(flav);</span>
<span class="nc" id="L1179">        getFlavorsForNativeCache.remove(nat);</span>
<span class="nc" id="L1180">        getFlavorsForNativeCache.remove(null);</span>
<span class="nc" id="L1181">    }</span>

    /**
     * Discards the current mappings for the specified &lt;code&gt;String&lt;/code&gt;
     * native, and creates new mappings to the specified
     * &lt;code&gt;DataFlavor&lt;/code&gt;s. Unlike &lt;code&gt;getFlavorsForNative&lt;/code&gt;, the
     * mappings will only be established in one direction, and the natives need
     * not be encoded. To establish two-way mappings, call
     * &lt;code&gt;setNativesForFlavor&lt;/code&gt; as well. The first
     * &lt;code&gt;DataFlavor&lt;/code&gt; in the array will represent the highest priority
     * mapping. Subsequent &lt;code&gt;DataFlavor&lt;/code&gt;s will represent mappings of
     * decreasing priority.
     * &lt;p&gt;
     * If the array contains several elements that reference equal
     * &lt;code&gt;DataFlavor&lt;/code&gt;s, this method will establish new mappings
     * for the first of those elements and ignore the rest of them.
     * &lt;p&gt;
     * It is recommended that client code not reset mappings established by the
     * data transfer subsystem. This method should only be used for
     * application-level mappings.
     *
     * @param nat the &lt;code&gt;String&lt;/code&gt; native key for the mappings
     * @param flavors the &lt;code&gt;DataFlavor&lt;/code&gt; values for the mappings
     * @throws NullPointerException if nat or flavors is &lt;code&gt;null&lt;/code&gt;
     *         or if flavors contains &lt;code&gt;null&lt;/code&gt; elements
     *
     * @see #setNativesForFlavor
     * @since 1.4
     */
    public synchronized void setFlavorsForNative(String nat,
                                                 DataFlavor[] flavors) {
<span class="nc bnc" id="L1212" title="All 4 branches missed.">        if (nat == null || flavors == null) {</span>
<span class="nc" id="L1213">            throw new NullPointerException(&quot;null arguments not permitted&quot;);</span>
        }

<span class="nc" id="L1216">        getNativeToFlavor().remove(nat);</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        for (DataFlavor flavor : flavors) {</span>
<span class="nc" id="L1218">            addFlavorForUnencodedNative(nat, flavor);</span>
        }
<span class="nc" id="L1220">        disabledMappingGenerationKeys.add(nat);</span>
        // Clear the cache to handle the case of empty flavors.
<span class="nc" id="L1222">        getFlavorsForNativeCache.remove(nat);</span>
<span class="nc" id="L1223">        getFlavorsForNativeCache.remove(null);</span>
<span class="nc" id="L1224">    }</span>

    /**
     * Encodes a MIME type for use as a &lt;code&gt;String&lt;/code&gt; native. The format
     * of an encoded representation of a MIME type is implementation-dependent.
     * The only restrictions are:
     * &lt;ul&gt;
     * &lt;li&gt;The encoded representation is &lt;code&gt;null&lt;/code&gt; if and only if the
     * MIME type &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;The encoded representations for two non-&lt;code&gt;null&lt;/code&gt; MIME type
     * &lt;code&gt;String&lt;/code&gt;s are equal if and only if these &lt;code&gt;String&lt;/code&gt;s
     * are equal according to &lt;code&gt;String.equals(Object)&lt;/code&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The reference implementation of this method returns the specified MIME
     * type &lt;code&gt;String&lt;/code&gt; prefixed with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.
     *
     * @param mimeType the MIME type to encode
     * @return the encoded &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if
     *         mimeType is &lt;code&gt;null&lt;/code&gt;
     */
    public static String encodeJavaMIMEType(String mimeType) {
<span class="nc bnc" id="L1246" title="All 2 branches missed.">        return (mimeType != null)</span>
            ? JavaMIME + mimeType
            : null;
    }

    /**
     * Encodes a &lt;code&gt;DataFlavor&lt;/code&gt; for use as a &lt;code&gt;String&lt;/code&gt;
     * native. The format of an encoded &lt;code&gt;DataFlavor&lt;/code&gt; is
     * implementation-dependent. The only restrictions are:
     * &lt;ul&gt;
     * &lt;li&gt;The encoded representation is &lt;code&gt;null&lt;/code&gt; if and only if the
     * specified &lt;code&gt;DataFlavor&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or its MIME type
     * &lt;code&gt;String&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;The encoded representations for two non-&lt;code&gt;null&lt;/code&gt;
     * &lt;code&gt;DataFlavor&lt;/code&gt;s with non-&lt;code&gt;null&lt;/code&gt; MIME type
     * &lt;code&gt;String&lt;/code&gt;s are equal if and only if the MIME type
     * &lt;code&gt;String&lt;/code&gt;s of these &lt;code&gt;DataFlavor&lt;/code&gt;s are equal
     * according to &lt;code&gt;String.equals(Object)&lt;/code&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The reference implementation of this method returns the MIME type
     * &lt;code&gt;String&lt;/code&gt; of the specified &lt;code&gt;DataFlavor&lt;/code&gt; prefixed
     * with &lt;code&gt;JAVA_DATAFLAVOR:&lt;/code&gt;.
     *
     * @param flav the &lt;code&gt;DataFlavor&lt;/code&gt; to encode
     * @return the encoded &lt;code&gt;String&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if
     *         flav is &lt;code&gt;null&lt;/code&gt; or has a &lt;code&gt;null&lt;/code&gt; MIME type
     */
    public static String encodeDataFlavor(DataFlavor flav) {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        return (flav != null)</span>
<span class="nc" id="L1276">            ? SystemFlavorMap.encodeJavaMIMEType(flav.getMimeType())</span>
            : null;
    }

    /**
     * Returns whether the specified &lt;code&gt;String&lt;/code&gt; is an encoded Java
     * MIME type.
     *
     * @param str the &lt;code&gt;String&lt;/code&gt; to test
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;String&lt;/code&gt; is encoded;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public static boolean isJavaMIMEType(String str) {
<span class="nc bnc" id="L1289" title="All 4 branches missed.">        return (str != null &amp;&amp; str.startsWith(JavaMIME, 0));</span>
    }

    /**
     * Decodes a &lt;code&gt;String&lt;/code&gt; native for use as a Java MIME type.
     *
     * @param nat the &lt;code&gt;String&lt;/code&gt; to decode
     * @return the decoded Java MIME type, or &lt;code&gt;null&lt;/code&gt; if nat is not
     *         an encoded &lt;code&gt;String&lt;/code&gt; native
     */
    public static String decodeJavaMIMEType(String nat) {
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        return (isJavaMIMEType(nat))</span>
<span class="nc" id="L1301">            ? nat.substring(JavaMIME.length(), nat.length()).trim()</span>
            : null;
    }

    /**
     * Decodes a &lt;code&gt;String&lt;/code&gt; native for use as a
     * &lt;code&gt;DataFlavor&lt;/code&gt;.
     *
     * @param nat the &lt;code&gt;String&lt;/code&gt; to decode
     * @return the decoded &lt;code&gt;DataFlavor&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if
     *         nat is not an encoded &lt;code&gt;String&lt;/code&gt; native
     */
    public static DataFlavor decodeDataFlavor(String nat)
        throws ClassNotFoundException
    {
<span class="nc" id="L1316">        String retval_str = SystemFlavorMap.decodeJavaMIMEType(nat);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        return (retval_str != null)</span>
            ? new DataFlavor(retval_str)
            : null;
    }

    private List&lt;String&gt; getAllNativesForType(String type) {
<span class="nc" id="L1323">        Set&lt;String&gt; retval = null;</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">        for (DataFlavor dataFlavor : convertMimeTypeToDataFlavors(type)) {</span>
<span class="nc" id="L1325">            List&lt;String&gt; natives = getFlavorToNative().get(dataFlavor);</span>
<span class="nc bnc" id="L1326" title="All 4 branches missed.">            if (natives != null &amp;&amp; !natives.isEmpty()) {</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                if (retval == null) {</span>
<span class="nc" id="L1328">                    retval = new LinkedHashSet&lt;&gt;();</span>
                }
<span class="nc" id="L1330">                retval.addAll(natives);</span>
            }
<span class="nc" id="L1332">        }</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        return retval == null ? null : new ArrayList&lt;&gt;(retval);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>