<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RMIConnector.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.remote.rmi</a> &gt; <span class="el_source">RMIConnector.java</span></div><h1>RMIConnector.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.remote.rmi;

import com.sun.jmx.mbeanserver.Util;
import com.sun.jmx.remote.internal.ClientCommunicatorAdmin;
import com.sun.jmx.remote.internal.ClientListenerInfo;
import com.sun.jmx.remote.internal.ClientNotifForwarder;
import com.sun.jmx.remote.internal.ProxyRef;
import com.sun.jmx.remote.internal.IIOPHelper;
import com.sun.jmx.remote.util.ClassLogger;
import com.sun.jmx.remote.util.EnvHelp;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InvalidObjectException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.io.Serializable;
import java.io.WriteAbortedException;
import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Proxy;
import java.net.MalformedURLException;
import java.rmi.MarshalException;
import java.rmi.MarshalledObject;
import java.rmi.NoSuchObjectException;
import java.rmi.Remote;
import java.rmi.ServerException;
import java.rmi.UnmarshalException;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.rmi.server.RemoteRef;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.security.ProtectionDomain;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.WeakHashMap;
import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.AttributeNotFoundException;
import javax.management.InstanceAlreadyExistsException;
import javax.management.InstanceNotFoundException;
import javax.management.IntrospectionException;
import javax.management.InvalidAttributeValueException;
import javax.management.ListenerNotFoundException;
import javax.management.MBeanException;
import javax.management.MBeanInfo;
import javax.management.MBeanRegistrationException;
import javax.management.MBeanServerConnection;
import javax.management.MBeanServerDelegate;
import javax.management.MBeanServerNotification;
import javax.management.NotCompliantMBeanException;
import javax.management.Notification;
import javax.management.NotificationBroadcasterSupport;
import javax.management.NotificationFilter;
import javax.management.NotificationFilterSupport;
import javax.management.NotificationListener;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.QueryExp;
import javax.management.ReflectionException;
import javax.management.remote.JMXConnectionNotification;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import javax.management.remote.NotificationResult;
import javax.management.remote.JMXAddressable;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.rmi.ssl.SslRMIClientSocketFactory;
import javax.security.auth.Subject;
import sun.reflect.misc.ReflectUtil;
import sun.rmi.server.UnicastRef2;
import sun.rmi.transport.LiveRef;

/**
 * &lt;p&gt;A connection to a remote RMI connector.  Usually, such
 * connections are made using {@link
 * javax.management.remote.JMXConnectorFactory JMXConnectorFactory}.
 * However, specialized applications can use this class directly, for
 * example with an {@link RMIServer} stub obtained without going
 * through JNDI.&lt;/p&gt;
 *
 * @since 1.5
 */
public class RMIConnector implements JMXConnector, Serializable, JMXAddressable {

<span class="nc" id="L123">    private static final ClassLogger logger =</span>
            new ClassLogger(&quot;javax.management.remote.rmi&quot;, &quot;RMIConnector&quot;);

    private static final long serialVersionUID = 817323035842634473L;

    private RMIConnector(RMIServer rmiServer, JMXServiceURL address,
<span class="nc" id="L129">            Map&lt;String, ?&gt; environment) {</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">        if (rmiServer == null &amp;&amp; address == null) throw new</span>
                IllegalArgumentException(&quot;rmiServer and jmxServiceURL both null&quot;);
<span class="nc" id="L132">        initTransients();</span>

<span class="nc" id="L134">        this.rmiServer = rmiServer;</span>
<span class="nc" id="L135">        this.jmxServiceURL = address;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (environment == null) {</span>
<span class="nc" id="L137">            this.env = Collections.emptyMap();</span>
        } else {
<span class="nc" id="L139">            EnvHelp.checkAttributes(environment);</span>
<span class="nc" id="L140">            this.env = Collections.unmodifiableMap(environment);</span>
        }
<span class="nc" id="L142">    }</span>

    /**
     * &lt;p&gt;Constructs an &lt;code&gt;RMIConnector&lt;/code&gt; that will connect
     * the RMI connector server with the given address.&lt;/p&gt;
     *
     * &lt;p&gt;The address can refer directly to the connector server,
     * using one of the following syntaxes:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * service:jmx:rmi://&lt;em&gt;[host[:port]]&lt;/em&gt;/stub/&lt;em&gt;encoded-stub&lt;/em&gt;
     * service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/ior/&lt;em&gt;encoded-IOR&lt;/em&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;(Here, the square brackets &lt;code&gt;[]&lt;/code&gt; are not part of the
     * address but indicate that the host and port are optional.)&lt;/p&gt;
     *
     * &lt;p&gt;The address can instead indicate where to find an RMI stub
     * through JNDI, using one of the following syntaxes:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * service:jmx:rmi://&lt;em&gt;[host[:port]]&lt;/em&gt;/jndi/&lt;em&gt;jndi-name&lt;/em&gt;
     * service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/jndi/&lt;em&gt;jndi-name&lt;/em&gt;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;An implementation may also recognize additional address
     * syntaxes, for example:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * service:jmx:iiop://&lt;em&gt;[host[:port]]&lt;/em&gt;/stub/&lt;em&gt;encoded-stub&lt;/em&gt;
     * &lt;/pre&gt;
     *
     * @param url the address of the RMI connector server.
     *
     * @param environment additional attributes specifying how to make
     * the connection.  For JNDI-based addresses, these attributes can
     * usefully include JNDI attributes recognized by {@link
     * InitialContext#InitialContext(Hashtable) InitialContext}.  This
     * parameter can be null, which is equivalent to an empty Map.
     *
     * @exception IllegalArgumentException if &lt;code&gt;url&lt;/code&gt;
     * is null.
     */
    public RMIConnector(JMXServiceURL url, Map&lt;String,?&gt; environment) {
<span class="nc" id="L186">        this(null, url, environment);</span>
<span class="nc" id="L187">    }</span>

    /**
     * &lt;p&gt;Constructs an &lt;code&gt;RMIConnector&lt;/code&gt; using the given RMI stub.
     *
     * @param rmiServer an RMI stub representing the RMI connector server.
     * @param environment additional attributes specifying how to make
     * the connection.  This parameter can be null, which is
     * equivalent to an empty Map.
     *
     * @exception IllegalArgumentException if &lt;code&gt;rmiServer&lt;/code&gt;
     * is null.
     */
    public RMIConnector(RMIServer rmiServer, Map&lt;String,?&gt; environment) {
<span class="nc" id="L201">        this(rmiServer, null, environment);</span>
<span class="nc" id="L202">    }</span>

    /**
     * &lt;p&gt;Returns a string representation of this object.  In general,
     * the &lt;code&gt;toString&lt;/code&gt; method returns a string that
     * &quot;textually represents&quot; this object. The result should be a
     * concise but informative representation that is easy for a
     * person to read.&lt;/p&gt;
     *
     * @return a String representation of this object.
     **/
    @Override
    public String toString() {
<span class="nc" id="L215">        final StringBuilder b = new StringBuilder(this.getClass().getName());</span>
<span class="nc" id="L216">        b.append(&quot;:&quot;);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        if (rmiServer != null) {</span>
<span class="nc" id="L218">            b.append(&quot; rmiServer=&quot;).append(rmiServer.toString());</span>
        }
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (jmxServiceURL != null) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (rmiServer!=null) b.append(&quot;,&quot;);</span>
<span class="nc" id="L222">            b.append(&quot; jmxServiceURL=&quot;).append(jmxServiceURL.toString());</span>
        }
<span class="nc" id="L224">        return b.toString();</span>
    }

    /**
     * &lt;p&gt;The address of this connector.&lt;/p&gt;
     *
     * @return the address of this connector, or null if it
     * does not have one.
     *
     * @since 1.6
     */
    public JMXServiceURL getAddress() {
<span class="nc" id="L236">        return jmxServiceURL;</span>
    }

    //--------------------------------------------------------------------
    // implements JMXConnector interface
    //--------------------------------------------------------------------

    /**
     * @throws IOException if the connection could not be made because of a
     *   communication problem, or in the case of the {@code iiop} protocol,
     *   that RMI/IIOP is not supported
     */
    public void connect() throws IOException {
<span class="nc" id="L249">        connect(null);</span>
<span class="nc" id="L250">    }</span>

    /**
     * @throws IOException if the connection could not be made because of a
     *   communication problem, or in the case of the {@code iiop} protocol,
     *   that RMI/IIOP is not supported
     */
    public synchronized void connect(Map&lt;String,?&gt; environment)
    throws IOException {
<span class="nc" id="L259">        final boolean tracing = logger.traceOn();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        String        idstr   = (tracing?&quot;[&quot;+this.toString()+&quot;]&quot;:null);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (terminated) {</span>
<span class="nc" id="L263">            logger.trace(&quot;connect&quot;,idstr + &quot; already closed.&quot;);</span>
<span class="nc" id="L264">            throw new IOException(&quot;Connector closed&quot;);</span>
        }
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (connected) {</span>
<span class="nc" id="L267">            logger.trace(&quot;connect&quot;,idstr + &quot; already connected.&quot;);</span>
<span class="nc" id="L268">            return;</span>
        }

        try {
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;connect&quot;,idstr + &quot; connecting...&quot;);</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">            final Map&lt;String, Object&gt; usemap =</span>
                    new HashMap&lt;String, Object&gt;((this.env==null) ?
<span class="nc" id="L276">                        Collections.&lt;String, Object&gt;emptyMap() : this.env);</span>


<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (environment != null) {</span>
<span class="nc" id="L280">                EnvHelp.checkAttributes(environment);</span>
<span class="nc" id="L281">                usemap.putAll(environment);</span>
            }

            // Get RMIServer stub from directory or URL encoding if needed.
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;connect&quot;,idstr + &quot; finding stub...&quot;);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            RMIServer stub = (rmiServer!=null)?rmiServer:</span>
<span class="nc" id="L287">                findRMIServer(jmxServiceURL, usemap);</span>

            // Check for secure RMIServer stub if the corresponding
            // client-side environment property is set to &quot;true&quot;.
            //
<span class="nc" id="L292">            String stringBoolean =  (String) usemap.get(&quot;jmx.remote.x.check.stub&quot;);</span>
<span class="nc" id="L293">            boolean checkStub = EnvHelp.computeBooleanFromString(stringBoolean);</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (checkStub) checkStub(stub, rmiServerImplStubClass);</span>

            // Connect IIOP Stub if needed.
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;connect&quot;,idstr + &quot; connecting stub...&quot;);</span>
<span class="nc" id="L299">            stub = connectStub(stub,usemap);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            idstr = (tracing?&quot;[&quot;+this.toString()+&quot;]&quot;:null);</span>

            // Calling newClient on the RMIServer stub.
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (tracing)</span>
<span class="nc" id="L304">                logger.trace(&quot;connect&quot;,idstr + &quot; getting connection...&quot;);</span>
<span class="nc" id="L305">            Object credentials = usemap.get(CREDENTIALS);</span>

            try {
<span class="nc" id="L308">                connection = getConnection(stub, credentials, checkStub);</span>
<span class="nc" id="L309">            } catch (java.rmi.RemoteException re) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (jmxServiceURL != null) {</span>
<span class="nc" id="L311">                    final String pro = jmxServiceURL.getProtocol();</span>
<span class="nc" id="L312">                    final String path = jmxServiceURL.getURLPath();</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">                    if (&quot;rmi&quot;.equals(pro) &amp;&amp;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                        path.startsWith(&quot;/jndi/iiop:&quot;)) {</span>
<span class="nc" id="L316">                        MalformedURLException mfe = new MalformedURLException(</span>
                              &quot;Protocol is rmi but JNDI scheme is iiop: &quot; + jmxServiceURL);
<span class="nc" id="L318">                        mfe.initCause(re);</span>
<span class="nc" id="L319">                        throw mfe;</span>
                    }
                }
<span class="nc" id="L322">                throw re;</span>
<span class="nc" id="L323">            }</span>

            // Always use one of:
            //   ClassLoader provided in Map at connect time,
            //   or contextClassLoader at connect time.
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (tracing)</span>
<span class="nc" id="L329">                logger.trace(&quot;connect&quot;,idstr + &quot; getting class loader...&quot;);</span>
<span class="nc" id="L330">            defaultClassLoader = EnvHelp.resolveClientClassLoader(usemap);</span>

<span class="nc" id="L332">            usemap.put(JMXConnectorFactory.DEFAULT_CLASS_LOADER,</span>
                    defaultClassLoader);

<span class="nc" id="L335">            rmiNotifClient = new RMINotifClient(defaultClassLoader, usemap);</span>

<span class="nc" id="L337">            env = usemap;</span>
<span class="nc" id="L338">            final long checkPeriod = EnvHelp.getConnectionCheckPeriod(usemap);</span>
<span class="nc" id="L339">            communicatorAdmin = new RMIClientCommunicatorAdmin(checkPeriod);</span>

<span class="nc" id="L341">            connected = true;</span>

            // The connectionId variable is used in doStart(), when
            // reconnecting, to identify the &quot;old&quot; connection.
            //
<span class="nc" id="L346">            connectionId = getConnectionId();</span>

<span class="nc" id="L348">            Notification connectedNotif =</span>
                    new JMXConnectionNotification(JMXConnectionNotification.OPENED,
                    this,
                    connectionId,
                    clientNotifSeqNo++,
                    &quot;Successful connection&quot;,
                    null);
<span class="nc" id="L355">            sendNotification(connectedNotif);</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;connect&quot;,idstr + &quot; done...&quot;);</span>
<span class="nc" id="L358">        } catch (IOException e) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (tracing)</span>
<span class="nc" id="L360">                logger.trace(&quot;connect&quot;,idstr + &quot; failed to connect: &quot; + e);</span>
<span class="nc" id="L361">            throw e;</span>
<span class="nc" id="L362">        } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (tracing)</span>
<span class="nc" id="L364">                logger.trace(&quot;connect&quot;,idstr + &quot; failed to connect: &quot; + e);</span>
<span class="nc" id="L365">            throw e;</span>
<span class="nc" id="L366">        } catch (NamingException e) {</span>
<span class="nc" id="L367">            final String msg = &quot;Failed to retrieve RMIServer stub: &quot; + e;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;connect&quot;,idstr + &quot; &quot; + msg);</span>
<span class="nc" id="L369">            throw EnvHelp.initCause(new IOException(msg),e);</span>
<span class="nc" id="L370">        }</span>
<span class="nc" id="L371">    }</span>

    public synchronized String getConnectionId() throws IOException {
<span class="nc bnc" id="L374" title="All 4 branches missed.">        if (terminated || !connected) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (logger.traceOn())</span>
<span class="nc" id="L376">                logger.trace(&quot;getConnectionId&quot;,&quot;[&quot;+this.toString()+</span>
                        &quot;] not connected.&quot;);

<span class="nc" id="L379">            throw new IOException(&quot;Not connected&quot;);</span>
        }

        // we do a remote call to have an IOException if the connection is broken.
        // see the bug 4939578
<span class="nc" id="L384">        return connection.getConnectionId();</span>
    }

    public synchronized MBeanServerConnection getMBeanServerConnection()
    throws IOException {
<span class="nc" id="L389">        return getMBeanServerConnection(null);</span>
    }

    public synchronized MBeanServerConnection
            getMBeanServerConnection(Subject delegationSubject)
            throws IOException {

<span class="nc bnc" id="L396" title="All 2 branches missed.">        if (terminated) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (logger.traceOn())</span>
<span class="nc" id="L398">                logger.trace(&quot;getMBeanServerConnection&quot;,&quot;[&quot; + this.toString() +</span>
                        &quot;] already closed.&quot;);
<span class="nc" id="L400">            throw new IOException(&quot;Connection closed&quot;);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        } else if (!connected) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (logger.traceOn())</span>
<span class="nc" id="L403">                logger.trace(&quot;getMBeanServerConnection&quot;,&quot;[&quot; + this.toString() +</span>
                        &quot;] is not connected.&quot;);
<span class="nc" id="L405">            throw new IOException(&quot;Not connected&quot;);</span>
        }

<span class="nc" id="L408">        return getConnectionWithSubject(delegationSubject);</span>
    }

    public void
            addConnectionNotificationListener(NotificationListener listener,
            NotificationFilter filter,
            Object handback) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (listener == null)</span>
<span class="nc" id="L416">            throw new NullPointerException(&quot;listener&quot;);</span>
<span class="nc" id="L417">        connectionBroadcaster.addNotificationListener(listener, filter,</span>
                handback);
<span class="nc" id="L419">    }</span>

    public void
            removeConnectionNotificationListener(NotificationListener listener)
            throws ListenerNotFoundException {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (listener == null)</span>
<span class="nc" id="L425">            throw new NullPointerException(&quot;listener&quot;);</span>
<span class="nc" id="L426">        connectionBroadcaster.removeNotificationListener(listener);</span>
<span class="nc" id="L427">    }</span>

    public void
            removeConnectionNotificationListener(NotificationListener listener,
            NotificationFilter filter,
            Object handback)
            throws ListenerNotFoundException {
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (listener == null)</span>
<span class="nc" id="L435">            throw new NullPointerException(&quot;listener&quot;);</span>
<span class="nc" id="L436">        connectionBroadcaster.removeNotificationListener(listener, filter,</span>
                handback);
<span class="nc" id="L438">    }</span>

    private void sendNotification(Notification n) {
<span class="nc" id="L441">        connectionBroadcaster.sendNotification(n);</span>
<span class="nc" id="L442">    }</span>

    public synchronized void close() throws IOException {
<span class="nc" id="L445">        close(false);</span>
<span class="nc" id="L446">    }</span>

    // allows to do close after setting the flag &quot;terminated&quot; to true.
    // It is necessary to avoid a deadlock, see 6296324
    private synchronized void close(boolean intern) throws IOException {
<span class="nc" id="L451">        final boolean tracing = logger.traceOn();</span>
<span class="nc" id="L452">        final boolean debug   = logger.debugOn();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        final String  idstr   = (tracing?&quot;[&quot;+this.toString()+&quot;]&quot;:null);</span>

<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (!intern) {</span>
            // Return if already cleanly closed.
            //
<span class="nc bnc" id="L458" title="All 2 branches missed.">            if (terminated) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (closeException == null) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    if (tracing) logger.trace(&quot;close&quot;,idstr + &quot; already closed.&quot;);</span>
<span class="nc" id="L461">                    return;</span>
                }
            } else {
<span class="nc" id="L464">                terminated = true;</span>
            }
        }

<span class="nc bnc" id="L468" title="All 4 branches missed.">        if (closeException != null &amp;&amp; tracing) {</span>
            // Already closed, but not cleanly. Attempt again.
            //
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (tracing) {</span>
<span class="nc" id="L472">                logger.trace(&quot;close&quot;,idstr + &quot; had failed: &quot; + closeException);</span>
<span class="nc" id="L473">                logger.trace(&quot;close&quot;,idstr + &quot; attempting to close again.&quot;);</span>
            }
        }

<span class="nc" id="L477">        String savedConnectionId = null;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (connected) {</span>
<span class="nc" id="L479">            savedConnectionId = connectionId;</span>
        }

<span class="nc" id="L482">        closeException = null;</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (tracing) logger.trace(&quot;close&quot;,idstr + &quot; closing.&quot;);</span>

<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (communicatorAdmin != null) {</span>
<span class="nc" id="L487">            communicatorAdmin.terminate();</span>
        }

<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (rmiNotifClient != null) {</span>
            try {
<span class="nc" id="L492">                rmiNotifClient.terminate();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (tracing) logger.trace(&quot;close&quot;,idstr +</span>
                        &quot; RMI Notification client terminated.&quot;);
<span class="nc" id="L495">            } catch (RuntimeException x) {</span>
<span class="nc" id="L496">                closeException = x;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (tracing) logger.trace(&quot;close&quot;,idstr +</span>
                        &quot; Failed to terminate RMI Notification client: &quot; + x);
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (debug) logger.debug(&quot;close&quot;,x);</span>
<span class="nc" id="L500">            }</span>
        }

<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (connection != null) {</span>
            try {
<span class="nc" id="L505">                connection.close();</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (tracing) logger.trace(&quot;close&quot;,idstr + &quot; closed.&quot;);</span>
<span class="nc" id="L507">            } catch (NoSuchObjectException nse) {</span>
                // OK, the server maybe closed itself.
<span class="nc" id="L509">            } catch (IOException e) {</span>
<span class="nc" id="L510">                closeException = e;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (tracing) logger.trace(&quot;close&quot;,idstr +</span>
                        &quot; Failed to close RMIServer: &quot; + e);
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if (debug) logger.debug(&quot;close&quot;,e);</span>
<span class="nc" id="L514">            }</span>
        }

        // Clean up MBeanServerConnection table
        //
<span class="nc" id="L519">        rmbscMap.clear();</span>

        /* Send notification of closure.  We don't do this if the user
         * never called connect() on the connector, because there's no
         * connection id in that case.  */

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (savedConnectionId != null) {</span>
<span class="nc" id="L526">            Notification closedNotif =</span>
                    new JMXConnectionNotification(JMXConnectionNotification.CLOSED,
                    this,
                    savedConnectionId,
                    clientNotifSeqNo++,
                    &quot;Client has been closed&quot;,
                    null);
<span class="nc" id="L533">            sendNotification(closedNotif);</span>
        }

        // throw exception if needed
        //
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (closeException != null) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (tracing) logger.trace(&quot;close&quot;,idstr + &quot; failed to close: &quot; +</span>
                    closeException);
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (closeException instanceof IOException)</span>
<span class="nc" id="L542">                throw (IOException) closeException;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (closeException instanceof RuntimeException)</span>
<span class="nc" id="L544">                throw (RuntimeException) closeException;</span>
<span class="nc" id="L545">            final IOException x =</span>
                    new IOException(&quot;Failed to close: &quot; + closeException);
<span class="nc" id="L547">            throw EnvHelp.initCause(x,closeException);</span>
        }
<span class="nc" id="L549">    }</span>

    // added for re-connection
    private Integer addListenerWithSubject(ObjectName name,
                                           MarshalledObject&lt;NotificationFilter&gt; filter,
                                           Subject delegationSubject,
                                           boolean reconnect)
        throws InstanceNotFoundException, IOException {

<span class="nc" id="L558">        final boolean debug = logger.debugOn();</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (debug)</span>
<span class="nc" id="L560">            logger.debug(&quot;addListenerWithSubject&quot;,</span>
                    &quot;(ObjectName,MarshalledObject,Subject)&quot;);

<span class="nc" id="L563">        final ObjectName[] names = new ObjectName[] {name};</span>
<span class="nc" id="L564">        final MarshalledObject&lt;NotificationFilter&gt;[] filters =</span>
<span class="nc" id="L565">                Util.cast(new MarshalledObject&lt;?&gt;[] {filter});</span>
<span class="nc" id="L566">        final Subject[] delegationSubjects = new Subject[] {</span>
            delegationSubject
        };

<span class="nc" id="L570">        final Integer[] listenerIDs =</span>
<span class="nc" id="L571">                addListenersWithSubjects(names,filters,delegationSubjects,</span>
                reconnect);

<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (debug) logger.debug(&quot;addListenerWithSubject&quot;,&quot;listenerID=&quot;</span>
                + listenerIDs[0]);
<span class="nc" id="L576">        return listenerIDs[0];</span>
    }

    // added for re-connection
    private Integer[] addListenersWithSubjects(ObjectName[]       names,
                             MarshalledObject&lt;NotificationFilter&gt;[] filters,
                             Subject[]          delegationSubjects,
                             boolean            reconnect)
        throws InstanceNotFoundException, IOException {

<span class="nc" id="L586">        final boolean debug = logger.debugOn();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (debug)</span>
<span class="nc" id="L588">            logger.debug(&quot;addListenersWithSubjects&quot;,</span>
                    &quot;(ObjectName[],MarshalledObject[],Subject[])&quot;);

<span class="nc" id="L591">        final ClassLoader old = pushDefaultClassLoader();</span>
<span class="nc" id="L592">        Integer[] listenerIDs = null;</span>

        try {
<span class="nc" id="L595">            listenerIDs = connection.addNotificationListeners(names,</span>
                    filters,
                    delegationSubjects);
<span class="nc" id="L598">        } catch (NoSuchObjectException noe) {</span>
            // maybe reconnect
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (reconnect) {</span>
<span class="nc" id="L601">                communicatorAdmin.gotIOException(noe);</span>

<span class="nc" id="L603">                listenerIDs = connection.addNotificationListeners(names,</span>
                        filters,
                        delegationSubjects);
            } else {
<span class="nc" id="L607">                throw noe;</span>
            }
<span class="nc" id="L609">        } catch (IOException ioe) {</span>
            // send a failed notif if necessary
<span class="nc" id="L611">            communicatorAdmin.gotIOException(ioe);</span>
        } finally {
<span class="nc" id="L613">            popDefaultClassLoader(old);</span>
<span class="nc" id="L614">        }</span>

<span class="nc bnc" id="L616" title="All 4 branches missed.">        if (debug) logger.debug(&quot;addListenersWithSubjects&quot;,&quot;registered &quot;</span>
                + ((listenerIDs==null)?0:listenerIDs.length)
                + &quot; listener(s)&quot;);
<span class="nc" id="L619">        return listenerIDs;</span>
    }

    //--------------------------------------------------------------------
    // Implementation of MBeanServerConnection
    //--------------------------------------------------------------------
    private class RemoteMBeanServerConnection implements MBeanServerConnection {
        private Subject delegationSubject;

        public RemoteMBeanServerConnection() {
<span class="nc" id="L629">            this(null);</span>
<span class="nc" id="L630">        }</span>

<span class="nc" id="L632">        public RemoteMBeanServerConnection(Subject delegationSubject) {</span>
<span class="nc" id="L633">            this.delegationSubject = delegationSubject;</span>
<span class="nc" id="L634">        }</span>

        public ObjectInstance createMBean(String className,
                ObjectName name)
                throws ReflectionException,
                InstanceAlreadyExistsException,
                MBeanRegistrationException,
                MBeanException,
                NotCompliantMBeanException,
                IOException {
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L645">                logger.debug(&quot;createMBean(String,ObjectName)&quot;,</span>
                        &quot;className=&quot; + className + &quot;, name=&quot; +
                        name);

<span class="nc" id="L649">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L651">                return connection.createMBean(className,</span>
                        name,
                        delegationSubject);
<span class="nc" id="L654">            } catch (IOException ioe) {</span>
<span class="nc" id="L655">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L657">                return connection.createMBean(className,</span>
                        name,
                        delegationSubject);
            } finally {
<span class="nc" id="L661">                popDefaultClassLoader(old);</span>
            }
        }

        public ObjectInstance createMBean(String className,
                ObjectName name,
                ObjectName loaderName)
                throws ReflectionException,
                InstanceAlreadyExistsException,
                MBeanRegistrationException,
                MBeanException,
                NotCompliantMBeanException,
                InstanceNotFoundException,
                IOException {

<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L677">                logger.debug(&quot;createMBean(String,ObjectName,ObjectName)&quot;,</span>
                        &quot;className=&quot; + className + &quot;, name=&quot;
                        + name + &quot;, loaderName=&quot;
                        + loaderName + &quot;)&quot;);

<span class="nc" id="L682">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L684">                return connection.createMBean(className,</span>
                        name,
                        loaderName,
                        delegationSubject);

<span class="nc" id="L689">            } catch (IOException ioe) {</span>
<span class="nc" id="L690">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L692">                return connection.createMBean(className,</span>
                        name,
                        loaderName,
                        delegationSubject);

            } finally {
<span class="nc" id="L698">                popDefaultClassLoader(old);</span>
            }
        }

        public ObjectInstance createMBean(String className,
                ObjectName name,
                Object params[],
                String signature[])
                throws ReflectionException,
                InstanceAlreadyExistsException,
                MBeanRegistrationException,
                MBeanException,
                NotCompliantMBeanException,
                IOException {
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L713">                logger.debug(&quot;createMBean(String,ObjectName,Object[],String[])&quot;,</span>
                        &quot;className=&quot; + className + &quot;, name=&quot;
                        + name + &quot;, params=&quot;
<span class="nc" id="L716">                        + objects(params) + &quot;, signature=&quot;</span>
<span class="nc" id="L717">                        + strings(signature));</span>

<span class="nc" id="L719">            final MarshalledObject&lt;Object[]&gt; sParams =</span>
                    new MarshalledObject&lt;Object[]&gt;(params);
<span class="nc" id="L721">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L723">                return connection.createMBean(className,</span>
                        name,
                        sParams,
                        signature,
                        delegationSubject);
<span class="nc" id="L728">            } catch (IOException ioe) {</span>
<span class="nc" id="L729">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L731">                return connection.createMBean(className,</span>
                        name,
                        sParams,
                        signature,
                        delegationSubject);
            } finally {
<span class="nc" id="L737">                popDefaultClassLoader(old);</span>
            }
        }

        public ObjectInstance createMBean(String className,
                ObjectName name,
                ObjectName loaderName,
                Object params[],
                String signature[])
                throws ReflectionException,
                InstanceAlreadyExistsException,
                MBeanRegistrationException,
                MBeanException,
                NotCompliantMBeanException,
                InstanceNotFoundException,
                IOException {
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(</span>
                    &quot;createMBean(String,ObjectName,ObjectName,Object[],String[])&quot;,
                    &quot;className=&quot; + className + &quot;, name=&quot; + name + &quot;, loaderName=&quot;
<span class="nc" id="L756">                    + loaderName + &quot;, params=&quot; + objects(params)</span>
<span class="nc" id="L757">                    + &quot;, signature=&quot; + strings(signature));</span>

<span class="nc" id="L759">            final MarshalledObject&lt;Object[]&gt; sParams =</span>
                    new MarshalledObject&lt;Object[]&gt;(params);
<span class="nc" id="L761">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L763">                return connection.createMBean(className,</span>
                        name,
                        loaderName,
                        sParams,
                        signature,
                        delegationSubject);
<span class="nc" id="L769">            } catch (IOException ioe) {</span>
<span class="nc" id="L770">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L772">                return connection.createMBean(className,</span>
                        name,
                        loaderName,
                        sParams,
                        signature,
                        delegationSubject);
            } finally {
<span class="nc" id="L779">                popDefaultClassLoader(old);</span>
            }
        }

        public void unregisterMBean(ObjectName name)
        throws InstanceNotFoundException,
                MBeanRegistrationException,
                IOException {
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L788">                logger.debug(&quot;unregisterMBean&quot;, &quot;name=&quot; + name);</span>

<span class="nc" id="L790">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L792">                connection.unregisterMBean(name, delegationSubject);</span>
<span class="nc" id="L793">            } catch (IOException ioe) {</span>
<span class="nc" id="L794">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L796">                connection.unregisterMBean(name, delegationSubject);</span>
            } finally {
<span class="nc" id="L798">                popDefaultClassLoader(old);</span>
<span class="nc" id="L799">            }</span>
<span class="nc" id="L800">        }</span>

        public ObjectInstance getObjectInstance(ObjectName name)
        throws InstanceNotFoundException,
                IOException {
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L806">                logger.debug(&quot;getObjectInstance&quot;, &quot;name=&quot; + name);</span>

<span class="nc" id="L808">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L810">                return connection.getObjectInstance(name, delegationSubject);</span>
<span class="nc" id="L811">            } catch (IOException ioe) {</span>
<span class="nc" id="L812">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L814">                return connection.getObjectInstance(name, delegationSubject);</span>
            } finally {
<span class="nc" id="L816">                popDefaultClassLoader(old);</span>
            }
        }

        public Set&lt;ObjectInstance&gt; queryMBeans(ObjectName name,
                QueryExp query)
                throws IOException {
<span class="nc bnc" id="L823" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;queryMBeans&quot;,</span>
                    &quot;name=&quot; + name + &quot;, query=&quot; + query);

<span class="nc" id="L826">            final MarshalledObject&lt;QueryExp&gt; sQuery =</span>
                    new MarshalledObject&lt;QueryExp&gt;(query);
<span class="nc" id="L828">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L830">                return connection.queryMBeans(name, sQuery, delegationSubject);</span>
<span class="nc" id="L831">            } catch (IOException ioe) {</span>
<span class="nc" id="L832">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L834">                return connection.queryMBeans(name, sQuery, delegationSubject);</span>
            } finally {
<span class="nc" id="L836">                popDefaultClassLoader(old);</span>
            }
        }

        public Set&lt;ObjectName&gt; queryNames(ObjectName name,
                QueryExp query)
                throws IOException {
<span class="nc bnc" id="L843" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;queryNames&quot;,</span>
                    &quot;name=&quot; + name + &quot;, query=&quot; + query);

<span class="nc" id="L846">            final MarshalledObject&lt;QueryExp&gt; sQuery =</span>
                    new MarshalledObject&lt;QueryExp&gt;(query);
<span class="nc" id="L848">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L850">                return connection.queryNames(name, sQuery, delegationSubject);</span>
<span class="nc" id="L851">            } catch (IOException ioe) {</span>
<span class="nc" id="L852">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L854">                return connection.queryNames(name, sQuery, delegationSubject);</span>
            } finally {
<span class="nc" id="L856">                popDefaultClassLoader(old);</span>
            }
        }

        public boolean isRegistered(ObjectName name)
        throws IOException {
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L863">                logger.debug(&quot;isRegistered&quot;, &quot;name=&quot; + name);</span>

<span class="nc" id="L865">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L867">                return connection.isRegistered(name, delegationSubject);</span>
<span class="nc" id="L868">            } catch (IOException ioe) {</span>
<span class="nc" id="L869">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L871">                return connection.isRegistered(name, delegationSubject);</span>
            } finally {
<span class="nc" id="L873">                popDefaultClassLoader(old);</span>
            }
        }

        public Integer getMBeanCount()
        throws IOException {
<span class="nc bnc" id="L879" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getMBeanCount&quot;, &quot;&quot;);</span>

<span class="nc" id="L881">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L883">                return connection.getMBeanCount(delegationSubject);</span>
<span class="nc" id="L884">            } catch (IOException ioe) {</span>
<span class="nc" id="L885">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L887">                return connection.getMBeanCount(delegationSubject);</span>
            } finally {
<span class="nc" id="L889">                popDefaultClassLoader(old);</span>
            }
        }

        public Object getAttribute(ObjectName name,
                String attribute)
                throws MBeanException,
                AttributeNotFoundException,
                InstanceNotFoundException,
                ReflectionException,
                IOException {
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getAttribute&quot;,</span>
                    &quot;name=&quot; + name + &quot;, attribute=&quot;
                    + attribute);

<span class="nc" id="L904">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L906">                return connection.getAttribute(name,</span>
                        attribute,
                        delegationSubject);
<span class="nc" id="L909">            } catch (IOException ioe) {</span>
<span class="nc" id="L910">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L912">                return connection.getAttribute(name,</span>
                        attribute,
                        delegationSubject);
            } finally {
<span class="nc" id="L916">                popDefaultClassLoader(old);</span>
            }
        }

        public AttributeList getAttributes(ObjectName name,
                String[] attributes)
                throws InstanceNotFoundException,
                ReflectionException,
                IOException {
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getAttributes&quot;,</span>
                    &quot;name=&quot; + name + &quot;, attributes=&quot;
<span class="nc" id="L927">                    + strings(attributes));</span>

<span class="nc" id="L929">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L931">                return connection.getAttributes(name,</span>
                        attributes,
                        delegationSubject);

<span class="nc" id="L935">            } catch (IOException ioe) {</span>
<span class="nc" id="L936">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L938">                return connection.getAttributes(name,</span>
                        attributes,
                        delegationSubject);
            } finally {
<span class="nc" id="L942">                popDefaultClassLoader(old);</span>
            }
        }


        public void setAttribute(ObjectName name,
                Attribute attribute)
                throws InstanceNotFoundException,
                AttributeNotFoundException,
                InvalidAttributeValueException,
                MBeanException,
                ReflectionException,
                IOException {

<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;setAttribute&quot;,</span>
                    &quot;name=&quot; + name + &quot;, attribute=&quot;
                    + attribute);

<span class="nc" id="L960">            final MarshalledObject&lt;Attribute&gt; sAttribute =</span>
                    new MarshalledObject&lt;Attribute&gt;(attribute);
<span class="nc" id="L962">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L964">                connection.setAttribute(name, sAttribute, delegationSubject);</span>
<span class="nc" id="L965">            } catch (IOException ioe) {</span>
<span class="nc" id="L966">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L968">                connection.setAttribute(name, sAttribute, delegationSubject);</span>
            } finally {
<span class="nc" id="L970">                popDefaultClassLoader(old);</span>
<span class="nc" id="L971">            }</span>
<span class="nc" id="L972">        }</span>

        public AttributeList setAttributes(ObjectName name,
                AttributeList attributes)
                throws InstanceNotFoundException,
                ReflectionException,
                IOException {

<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;setAttributes&quot;,</span>
                    &quot;name=&quot; + name + &quot;, attributes=&quot;
                    + attributes);

<span class="nc" id="L984">            final MarshalledObject&lt;AttributeList&gt; sAttributes =</span>
                    new MarshalledObject&lt;AttributeList&gt;(attributes);
<span class="nc" id="L986">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L988">                return connection.setAttributes(name,</span>
                        sAttributes,
                        delegationSubject);
<span class="nc" id="L991">            } catch (IOException ioe) {</span>
<span class="nc" id="L992">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L994">                return connection.setAttributes(name,</span>
                        sAttributes,
                        delegationSubject);
            } finally {
<span class="nc" id="L998">                popDefaultClassLoader(old);</span>
            }
        }


        public Object invoke(ObjectName name,
                String operationName,
                Object params[],
                String signature[])
                throws InstanceNotFoundException,
                MBeanException,
                ReflectionException,
                IOException {

<span class="nc bnc" id="L1012" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;invoke&quot;,</span>
                    &quot;name=&quot; + name
                    + &quot;, operationName=&quot; + operationName
<span class="nc" id="L1015">                    + &quot;, params=&quot; + objects(params)</span>
<span class="nc" id="L1016">                    + &quot;, signature=&quot; + strings(signature));</span>

<span class="nc" id="L1018">            final MarshalledObject&lt;Object[]&gt; sParams =</span>
                    new MarshalledObject&lt;Object[]&gt;(params);
<span class="nc" id="L1020">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1022">                return connection.invoke(name,</span>
                        operationName,
                        sParams,
                        signature,
                        delegationSubject);
<span class="nc" id="L1027">            } catch (IOException ioe) {</span>
<span class="nc" id="L1028">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1030">                return connection.invoke(name,</span>
                        operationName,
                        sParams,
                        signature,
                        delegationSubject);
            } finally {
<span class="nc" id="L1036">                popDefaultClassLoader(old);</span>
            }
        }


        public String getDefaultDomain()
        throws IOException {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getDefaultDomain&quot;, &quot;&quot;);</span>

<span class="nc" id="L1045">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1047">                return connection.getDefaultDomain(delegationSubject);</span>
<span class="nc" id="L1048">            } catch (IOException ioe) {</span>
<span class="nc" id="L1049">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1051">                return connection.getDefaultDomain(delegationSubject);</span>
            } finally {
<span class="nc" id="L1053">                popDefaultClassLoader(old);</span>
            }
        }

        public String[] getDomains() throws IOException {
<span class="nc bnc" id="L1058" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getDomains&quot;, &quot;&quot;);</span>

<span class="nc" id="L1060">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1062">                return connection.getDomains(delegationSubject);</span>
<span class="nc" id="L1063">            } catch (IOException ioe) {</span>
<span class="nc" id="L1064">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1066">                return connection.getDomains(delegationSubject);</span>
            } finally {
<span class="nc" id="L1068">                popDefaultClassLoader(old);</span>
            }
        }

        public MBeanInfo getMBeanInfo(ObjectName name)
        throws InstanceNotFoundException,
                IntrospectionException,
                ReflectionException,
                IOException {

<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;getMBeanInfo&quot;, &quot;name=&quot; + name);</span>
<span class="nc" id="L1079">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1081">                return connection.getMBeanInfo(name, delegationSubject);</span>
<span class="nc" id="L1082">            } catch (IOException ioe) {</span>
<span class="nc" id="L1083">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1085">                return connection.getMBeanInfo(name, delegationSubject);</span>
            } finally {
<span class="nc" id="L1087">                popDefaultClassLoader(old);</span>
            }
        }


        public boolean isInstanceOf(ObjectName name,
                String className)
                throws InstanceNotFoundException,
                IOException {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L1097">                logger.debug(&quot;isInstanceOf&quot;, &quot;name=&quot; + name +</span>
                        &quot;, className=&quot; + className);

<span class="nc" id="L1100">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1102">                return connection.isInstanceOf(name,</span>
                        className,
                        delegationSubject);
<span class="nc" id="L1105">            } catch (IOException ioe) {</span>
<span class="nc" id="L1106">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1108">                return connection.isInstanceOf(name,</span>
                        className,
                        delegationSubject);
            } finally {
<span class="nc" id="L1112">                popDefaultClassLoader(old);</span>
            }
        }

        public void addNotificationListener(ObjectName name,
                ObjectName listener,
                NotificationFilter filter,
                Object handback)
                throws InstanceNotFoundException,
                IOException {

<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L1124">                logger.debug(&quot;addNotificationListener&quot; +</span>
                        &quot;(ObjectName,ObjectName,NotificationFilter,Object)&quot;,
                        &quot;name=&quot; + name + &quot;, listener=&quot; + listener
                        + &quot;, filter=&quot; + filter + &quot;, handback=&quot; + handback);

<span class="nc" id="L1129">            final MarshalledObject&lt;NotificationFilter&gt; sFilter =</span>
                    new MarshalledObject&lt;NotificationFilter&gt;(filter);
<span class="nc" id="L1131">            final MarshalledObject&lt;Object&gt; sHandback =</span>
                    new MarshalledObject&lt;Object&gt;(handback);
<span class="nc" id="L1133">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1135">                connection.addNotificationListener(name,</span>
                        listener,
                        sFilter,
                        sHandback,
                        delegationSubject);
<span class="nc" id="L1140">            } catch (IOException ioe) {</span>
<span class="nc" id="L1141">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1143">                connection.addNotificationListener(name,</span>
                        listener,
                        sFilter,
                        sHandback,
                        delegationSubject);
            } finally {
<span class="nc" id="L1149">                popDefaultClassLoader(old);</span>
<span class="nc" id="L1150">            }</span>
<span class="nc" id="L1151">        }</span>

        public void removeNotificationListener(ObjectName name,
                ObjectName listener)
                throws InstanceNotFoundException,
                ListenerNotFoundException,
                IOException {

<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;removeNotificationListener&quot; +</span>
                    &quot;(ObjectName,ObjectName)&quot;,
                    &quot;name=&quot; + name
                    + &quot;, listener=&quot; + listener);

<span class="nc" id="L1164">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1166">                connection.removeNotificationListener(name,</span>
                        listener,
                        delegationSubject);
<span class="nc" id="L1169">            } catch (IOException ioe) {</span>
<span class="nc" id="L1170">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1172">                connection.removeNotificationListener(name,</span>
                        listener,
                        delegationSubject);
            } finally {
<span class="nc" id="L1176">                popDefaultClassLoader(old);</span>
<span class="nc" id="L1177">            }</span>
<span class="nc" id="L1178">        }</span>

        public void removeNotificationListener(ObjectName name,
                ObjectName listener,
                NotificationFilter filter,
                Object handback)
                throws InstanceNotFoundException,
                ListenerNotFoundException,
                IOException {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L1188">                logger.debug(&quot;removeNotificationListener&quot; +</span>
                        &quot;(ObjectName,ObjectName,NotificationFilter,Object)&quot;,
                        &quot;name=&quot; + name
                        + &quot;, listener=&quot; + listener
                        + &quot;, filter=&quot; + filter
                        + &quot;, handback=&quot; + handback);

<span class="nc" id="L1195">            final MarshalledObject&lt;NotificationFilter&gt; sFilter =</span>
                    new MarshalledObject&lt;NotificationFilter&gt;(filter);
<span class="nc" id="L1197">            final MarshalledObject&lt;Object&gt; sHandback =</span>
                    new MarshalledObject&lt;Object&gt;(handback);
<span class="nc" id="L1199">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1201">                connection.removeNotificationListener(name,</span>
                        listener,
                        sFilter,
                        sHandback,
                        delegationSubject);
<span class="nc" id="L1206">            } catch (IOException ioe) {</span>
<span class="nc" id="L1207">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1209">                connection.removeNotificationListener(name,</span>
                        listener,
                        sFilter,
                        sHandback,
                        delegationSubject);
            } finally {
<span class="nc" id="L1215">                popDefaultClassLoader(old);</span>
<span class="nc" id="L1216">            }</span>
<span class="nc" id="L1217">        }</span>

        // Specific Notification Handle ----------------------------------

        public void addNotificationListener(ObjectName name,
                NotificationListener listener,
                NotificationFilter filter,
                Object handback)
                throws InstanceNotFoundException,
                IOException {

<span class="nc" id="L1228">            final boolean debug = logger.debugOn();</span>

<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if (debug)</span>
<span class="nc" id="L1231">                logger.debug(&quot;addNotificationListener&quot; +</span>
                        &quot;(ObjectName,NotificationListener,&quot;+
                        &quot;NotificationFilter,Object)&quot;,
                        &quot;name=&quot; + name
                        + &quot;, listener=&quot; + listener
                        + &quot;, filter=&quot; + filter
                        + &quot;, handback=&quot; + handback);

<span class="nc" id="L1239">            final Integer listenerID =</span>
<span class="nc" id="L1240">                    addListenerWithSubject(name,</span>
                    new MarshalledObject&lt;NotificationFilter&gt;(filter),
                    delegationSubject,true);
<span class="nc" id="L1243">            rmiNotifClient.addNotificationListener(listenerID, name, listener,</span>
                    filter, handback,
                    delegationSubject);
<span class="nc" id="L1246">        }</span>

        public void removeNotificationListener(ObjectName name,
                NotificationListener listener)
                throws InstanceNotFoundException,
                ListenerNotFoundException,
                IOException {

<span class="nc" id="L1254">            final boolean debug = logger.debugOn();</span>

<span class="nc bnc" id="L1256" title="All 2 branches missed.">            if (debug) logger.debug(&quot;removeNotificationListener&quot;+</span>
                    &quot;(ObjectName,NotificationListener)&quot;,
                    &quot;name=&quot; + name
                    + &quot;, listener=&quot; + listener);

<span class="nc" id="L1261">            final Integer[] ret =</span>
<span class="nc" id="L1262">                    rmiNotifClient.removeNotificationListener(name, listener);</span>

<span class="nc bnc" id="L1264" title="All 2 branches missed.">            if (debug) logger.debug(&quot;removeNotificationListener&quot;,</span>
<span class="nc" id="L1265">                    &quot;listenerIDs=&quot; + objects(ret));</span>

<span class="nc" id="L1267">            final ClassLoader old = pushDefaultClassLoader();</span>

            try {
<span class="nc" id="L1270">                connection.removeNotificationListeners(name,</span>
                        ret,
                        delegationSubject);
<span class="nc" id="L1273">            } catch (IOException ioe) {</span>
<span class="nc" id="L1274">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1276">                connection.removeNotificationListeners(name,</span>
                        ret,
                        delegationSubject);
            } finally {
<span class="nc" id="L1280">                popDefaultClassLoader(old);</span>
<span class="nc" id="L1281">            }</span>

<span class="nc" id="L1283">        }</span>

        public void removeNotificationListener(ObjectName name,
                NotificationListener listener,
                NotificationFilter filter,
                Object handback)
                throws InstanceNotFoundException,
                ListenerNotFoundException,
                IOException {
<span class="nc" id="L1292">            final boolean debug = logger.debugOn();</span>

<span class="nc bnc" id="L1294" title="All 2 branches missed.">            if (debug)</span>
<span class="nc" id="L1295">                logger.debug(&quot;removeNotificationListener&quot;+</span>
                        &quot;(ObjectName,NotificationListener,&quot;+
                        &quot;NotificationFilter,Object)&quot;,
                        &quot;name=&quot; + name
                        + &quot;, listener=&quot; + listener
                        + &quot;, filter=&quot; + filter
                        + &quot;, handback=&quot; + handback);

<span class="nc" id="L1303">            final Integer ret =</span>
<span class="nc" id="L1304">                    rmiNotifClient.removeNotificationListener(name, listener,</span>
                    filter, handback);

<span class="nc bnc" id="L1307" title="All 2 branches missed.">            if (debug) logger.debug(&quot;removeNotificationListener&quot;,</span>
                    &quot;listenerID=&quot; + ret);

<span class="nc" id="L1310">            final ClassLoader old = pushDefaultClassLoader();</span>
            try {
<span class="nc" id="L1312">                connection.removeNotificationListeners(name,</span>
                        new Integer[] {ret},
                        delegationSubject);
<span class="nc" id="L1315">            } catch (IOException ioe) {</span>
<span class="nc" id="L1316">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1318">                connection.removeNotificationListeners(name,</span>
                        new Integer[] {ret},
                        delegationSubject);
            } finally {
<span class="nc" id="L1322">                popDefaultClassLoader(old);</span>
<span class="nc" id="L1323">            }</span>

<span class="nc" id="L1325">        }</span>
    }

    //--------------------------------------------------------------------
    private class RMINotifClient extends ClientNotifForwarder {
<span class="nc" id="L1330">        public RMINotifClient(ClassLoader cl, Map&lt;String, ?&gt; env) {</span>
<span class="nc" id="L1331">            super(cl, env);</span>
<span class="nc" id="L1332">        }</span>

        protected NotificationResult fetchNotifs(long clientSequenceNumber,
                int maxNotifications,
                long timeout)
                throws IOException, ClassNotFoundException {
            IOException org;

            while (true) { // used for a successful re-connection
                try {
<span class="nc" id="L1342">                    return connection.fetchNotifications(clientSequenceNumber,</span>
                            maxNotifications,
                            timeout);
<span class="nc" id="L1345">                } catch (IOException ioe) {</span>
<span class="nc" id="L1346">                    org = ioe;</span>

                    // inform of IOException
                    try {
<span class="nc" id="L1350">                        communicatorAdmin.gotIOException(ioe);</span>

                        // The connection should be re-established.
<span class="nc" id="L1353">                        continue;</span>
<span class="nc" id="L1354">                    } catch (IOException ee) {</span>
                        // No more fetch, the Exception will be re-thrown.
<span class="nc" id="L1356">                        break;</span>
                    } // never reached
                } // never reached
            }

            // specially treating for an UnmarshalException
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (org instanceof UnmarshalException) {</span>
<span class="nc" id="L1363">                UnmarshalException ume = (UnmarshalException)org;</span>

<span class="nc bnc" id="L1365" title="All 2 branches missed.">                if (ume.detail instanceof ClassNotFoundException)</span>
<span class="nc" id="L1366">                    throw (ClassNotFoundException) ume.detail;</span>

                /* In Sun's RMI implementation, if a method return
                   contains an unserializable object, then we get
                   UnmarshalException wrapping WriteAbortedException
                   wrapping NotSerializableException.  In that case we
                   extract the NotSerializableException so that our
                   caller can realize it should try to skip past the
                   notification that presumably caused it.  It's not
                   certain that every other RMI implementation will
                   generate this exact exception sequence.  If not, we
                   will not detect that the problem is due to an
                   unserializable object, and we will stop trying to
                   receive notifications from the server.  It's not
                   clear we can do much better.  */
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                if (ume.detail instanceof WriteAbortedException) {</span>
<span class="nc" id="L1382">                    WriteAbortedException wae =</span>
                            (WriteAbortedException) ume.detail;
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                    if (wae.detail instanceof IOException)</span>
<span class="nc" id="L1385">                        throw (IOException) wae.detail;</span>
                }
<span class="nc bnc" id="L1387" title="All 2 branches missed.">            } else if (org instanceof MarshalException) {</span>
                // IIOP will throw MarshalException wrapping a NotSerializableException
                // when a server fails to serialize a response.
<span class="nc" id="L1390">                MarshalException me = (MarshalException)org;</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">                if (me.detail instanceof NotSerializableException) {</span>
<span class="nc" id="L1392">                    throw (NotSerializableException)me.detail;</span>
                }
            }

            // Not serialization problem, simply re-throw the orginal exception
<span class="nc" id="L1397">            throw org;</span>
        }

        protected Integer addListenerForMBeanRemovedNotif()
        throws IOException, InstanceNotFoundException {
<span class="nc" id="L1402">            NotificationFilterSupport clientFilter =</span>
                    new NotificationFilterSupport();
<span class="nc" id="L1404">            clientFilter.enableType(</span>
                    MBeanServerNotification.UNREGISTRATION_NOTIFICATION);
<span class="nc" id="L1406">            MarshalledObject&lt;NotificationFilter&gt; sFilter =</span>
                new MarshalledObject&lt;NotificationFilter&gt;(clientFilter);

            Integer[] listenerIDs;
<span class="nc" id="L1410">            final ObjectName[] names =</span>
                new ObjectName[] {MBeanServerDelegate.DELEGATE_NAME};
<span class="nc" id="L1412">            final MarshalledObject&lt;NotificationFilter&gt;[] filters =</span>
<span class="nc" id="L1413">                Util.cast(new MarshalledObject&lt;?&gt;[] {sFilter});</span>
<span class="nc" id="L1414">            final Subject[] subjects = new Subject[] {null};</span>
            try {
<span class="nc" id="L1416">                listenerIDs =</span>
<span class="nc" id="L1417">                        connection.addNotificationListeners(names,</span>
                        filters,
                        subjects);

<span class="nc" id="L1421">            } catch (IOException ioe) {</span>
<span class="nc" id="L1422">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1424">                listenerIDs =</span>
<span class="nc" id="L1425">                        connection.addNotificationListeners(names,</span>
                        filters,
                        subjects);
<span class="nc" id="L1428">            }</span>
<span class="nc" id="L1429">            return listenerIDs[0];</span>
        }

        protected void removeListenerForMBeanRemovedNotif(Integer id)
        throws IOException, InstanceNotFoundException,
                ListenerNotFoundException {
            try {
<span class="nc" id="L1436">                connection.removeNotificationListeners(</span>
                        MBeanServerDelegate.DELEGATE_NAME,
                        new Integer[] {id},
                        null);
<span class="nc" id="L1440">            } catch (IOException ioe) {</span>
<span class="nc" id="L1441">                communicatorAdmin.gotIOException(ioe);</span>

<span class="nc" id="L1443">                connection.removeNotificationListeners(</span>
                        MBeanServerDelegate.DELEGATE_NAME,
                        new Integer[] {id},
                        null);
<span class="nc" id="L1447">            }</span>

<span class="nc" id="L1449">        }</span>

        protected void lostNotifs(String message, long number) {
            final String notifType = JMXConnectionNotification.NOTIFS_LOST;

<span class="nc" id="L1454">            final JMXConnectionNotification n =</span>
                new JMXConnectionNotification(notifType,
                                              RMIConnector.this,
<span class="nc" id="L1457">                                              connectionId,</span>
<span class="nc" id="L1458">                                              clientNotifCounter++,</span>
                                              message,
<span class="nc" id="L1460">                                              Long.valueOf(number));</span>
<span class="nc" id="L1461">            sendNotification(n);</span>
<span class="nc" id="L1462">        }</span>
    }

    private class RMIClientCommunicatorAdmin extends ClientCommunicatorAdmin {
<span class="nc" id="L1466">        public RMIClientCommunicatorAdmin(long period) {</span>
<span class="nc" id="L1467">            super(period);</span>
<span class="nc" id="L1468">        }</span>

        @Override
        public void gotIOException(IOException ioe) throws IOException {
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if (ioe instanceof NoSuchObjectException) {</span>
                // need to restart
<span class="nc" id="L1474">                super.gotIOException(ioe);</span>

<span class="nc" id="L1476">                return;</span>
            }

            // check if the connection is broken
            try {
<span class="nc" id="L1481">                connection.getDefaultDomain(null);</span>
<span class="nc" id="L1482">            } catch (IOException ioexc) {</span>
<span class="nc" id="L1483">                boolean toClose = false;</span>

<span class="nc" id="L1485">                synchronized(this) {</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">                    if (!terminated) {</span>
<span class="nc" id="L1487">                        terminated = true;</span>

<span class="nc" id="L1489">                        toClose = true;</span>
                    }
<span class="nc" id="L1491">                }</span>

<span class="nc bnc" id="L1493" title="All 2 branches missed.">                if (toClose) {</span>
                    // we should close the connection,
                    // but send a failed notif at first
<span class="nc" id="L1496">                    final Notification failedNotif =</span>
                            new JMXConnectionNotification(
                            JMXConnectionNotification.FAILED,
                            this,
<span class="nc" id="L1500">                            connectionId,</span>
<span class="nc" id="L1501">                            clientNotifSeqNo++,</span>
<span class="nc" id="L1502">                            &quot;Failed to communicate with the server: &quot;+ioe.toString(),</span>
                            ioe);

<span class="nc" id="L1505">                    sendNotification(failedNotif);</span>

                    try {
<span class="nc" id="L1508">                        close(true);</span>
<span class="nc" id="L1509">                    } catch (Exception e) {</span>
                        // OK.
                        // We are closing
<span class="nc" id="L1512">                    }</span>
                }
<span class="nc" id="L1514">            }</span>

            // forward the exception
<span class="nc bnc" id="L1517" title="All 2 branches missed.">            if (ioe instanceof ServerException) {</span>
                /* Need to unwrap the exception.
                   Some user-thrown exception at server side will be wrapped by
                   rmi into a ServerException.
                   For example, a RMIConnnectorServer will wrap a
                   ClassNotFoundException into a UnmarshalException, and rmi
                   will throw a ServerException at client side which wraps this
                   UnmarshalException.
                   No failed notif here.
                 */
<span class="nc" id="L1527">                Throwable tt = ((ServerException)ioe).detail;</span>

<span class="nc bnc" id="L1529" title="All 2 branches missed.">                if (tt instanceof IOException) {</span>
<span class="nc" id="L1530">                    throw (IOException)tt;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                } else if (tt instanceof RuntimeException) {</span>
<span class="nc" id="L1532">                    throw (RuntimeException)tt;</span>
                }
            }

<span class="nc" id="L1536">            throw ioe;</span>
        }

        public void reconnectNotificationListeners(ClientListenerInfo[] old) throws IOException {
<span class="nc" id="L1540">            final int len  = old.length;</span>
            int i;

<span class="nc" id="L1543">            ClientListenerInfo[] clis = new ClientListenerInfo[len];</span>

<span class="nc" id="L1545">            final Subject[] subjects = new Subject[len];</span>
<span class="nc" id="L1546">            final ObjectName[] names = new ObjectName[len];</span>
<span class="nc" id="L1547">            final NotificationListener[] listeners = new NotificationListener[len];</span>
<span class="nc" id="L1548">            final NotificationFilter[] filters = new NotificationFilter[len];</span>
<span class="nc" id="L1549">            final MarshalledObject&lt;NotificationFilter&gt;[] mFilters =</span>
<span class="nc" id="L1550">                    Util.cast(new MarshalledObject&lt;?&gt;[len]);</span>
<span class="nc" id="L1551">            final Object[] handbacks = new Object[len];</span>

<span class="nc bnc" id="L1553" title="All 2 branches missed.">            for (i=0;i&lt;len;i++) {</span>
<span class="nc" id="L1554">                subjects[i]  = old[i].getDelegationSubject();</span>
<span class="nc" id="L1555">                names[i]     = old[i].getObjectName();</span>
<span class="nc" id="L1556">                listeners[i] = old[i].getListener();</span>
<span class="nc" id="L1557">                filters[i]   = old[i].getNotificationFilter();</span>
<span class="nc" id="L1558">                mFilters[i]  = new MarshalledObject&lt;NotificationFilter&gt;(filters[i]);</span>
<span class="nc" id="L1559">                handbacks[i] = old[i].getHandback();</span>
            }

            try {
<span class="nc" id="L1563">                Integer[] ids = addListenersWithSubjects(names,mFilters,subjects,false);</span>

<span class="nc bnc" id="L1565" title="All 2 branches missed.">                for (i=0;i&lt;len;i++) {</span>
<span class="nc" id="L1566">                    clis[i] = new ClientListenerInfo(ids[i],</span>
                            names[i],
                            listeners[i],
                            filters[i],
                            handbacks[i],
                            subjects[i]);
                }

<span class="nc" id="L1574">                rmiNotifClient.postReconnection(clis);</span>

<span class="nc" id="L1576">                return;</span>
<span class="nc" id="L1577">            } catch (InstanceNotFoundException infe) {</span>
                // OK, we will do one by one
            }

<span class="nc" id="L1581">            int j = 0;</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            for (i=0;i&lt;len;i++) {</span>
                try {
<span class="nc" id="L1584">                    Integer id = addListenerWithSubject(names[i],</span>
                            new MarshalledObject&lt;NotificationFilter&gt;(filters[i]),
                            subjects[i],
                            false);

<span class="nc" id="L1589">                    clis[j++] = new ClientListenerInfo(id,</span>
                            names[i],
                            listeners[i],
                            filters[i],
                            handbacks[i],
                            subjects[i]);
<span class="nc" id="L1595">                } catch (InstanceNotFoundException infe) {</span>
<span class="nc" id="L1596">                    logger.warning(&quot;reconnectNotificationListeners&quot;,</span>
                            &quot;Can't reconnect listener for &quot; +
                            names[i]);
<span class="nc" id="L1599">                }</span>
            }

<span class="nc bnc" id="L1602" title="All 2 branches missed.">            if (j != len) {</span>
<span class="nc" id="L1603">                ClientListenerInfo[] tmp = clis;</span>
<span class="nc" id="L1604">                clis = new ClientListenerInfo[j];</span>
<span class="nc" id="L1605">                System.arraycopy(tmp, 0, clis, 0, j);</span>
            }

<span class="nc" id="L1608">            rmiNotifClient.postReconnection(clis);</span>
<span class="nc" id="L1609">        }</span>

        protected void checkConnection() throws IOException {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            if (logger.debugOn())</span>
<span class="nc" id="L1613">                logger.debug(&quot;RMIClientCommunicatorAdmin-checkConnection&quot;,</span>
                        &quot;Calling the method getDefaultDomain.&quot;);

<span class="nc" id="L1616">            connection.getDefaultDomain(null);</span>
<span class="nc" id="L1617">        }</span>

        protected void doStart() throws IOException {
            // Get RMIServer stub from directory or URL encoding if needed.
            RMIServer stub;
            try {
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                stub = (rmiServer!=null)?rmiServer:</span>
<span class="nc" id="L1624">                    findRMIServer(jmxServiceURL, env);</span>
<span class="nc" id="L1625">            } catch (NamingException ne) {</span>
<span class="nc" id="L1626">                throw new IOException(&quot;Failed to get a RMI stub: &quot;+ne);</span>
<span class="nc" id="L1627">            }</span>

            // Connect IIOP Stub if needed.
<span class="nc" id="L1630">            stub = connectStub(stub,env);</span>

            // Calling newClient on the RMIServer stub.
<span class="nc" id="L1633">            Object credentials = env.get(CREDENTIALS);</span>
<span class="nc" id="L1634">            connection = stub.newClient(credentials);</span>

            // notif issues
<span class="nc" id="L1637">            final ClientListenerInfo[] old = rmiNotifClient.preReconnection();</span>

<span class="nc" id="L1639">            reconnectNotificationListeners(old);</span>

<span class="nc" id="L1641">            connectionId = getConnectionId();</span>

<span class="nc" id="L1643">            Notification reconnectedNotif =</span>
                    new JMXConnectionNotification(JMXConnectionNotification.OPENED,
                    this,
<span class="nc" id="L1646">                    connectionId,</span>
<span class="nc" id="L1647">                    clientNotifSeqNo++,</span>
                    &quot;Reconnected to server&quot;,
                    null);
<span class="nc" id="L1650">            sendNotification(reconnectedNotif);</span>

<span class="nc" id="L1652">        }</span>

        protected void doStop() {
            try {
<span class="nc" id="L1656">                close();</span>
<span class="nc" id="L1657">            } catch (IOException ioe) {</span>
<span class="nc" id="L1658">                logger.warning(&quot;RMIClientCommunicatorAdmin-doStop&quot;,</span>
                        &quot;Failed to call the method close():&quot; + ioe);
<span class="nc" id="L1660">                logger.debug(&quot;RMIClientCommunicatorAdmin-doStop&quot;,ioe);</span>
<span class="nc" id="L1661">            }</span>
<span class="nc" id="L1662">        }</span>
    }

    //--------------------------------------------------------------------
    // Private stuff - Serialization
    //--------------------------------------------------------------------
    /**
     * &lt;p&gt;In order to be usable, an IIOP stub must be connected to an ORB.
     * The stub is automatically connected to the ORB if:
     * &lt;ul&gt;
     *     &lt;li&gt; It was returned by the COS naming&lt;/li&gt;
     *     &lt;li&gt; Its server counterpart has been registered in COS naming
     *          through JNDI.&lt;/li&gt;
     * &lt;/ul&gt;
     * Otherwise, it is not connected. A stub which is deserialized
     * from Jini is not connected. A stub which is obtained from a
     * non registered RMIIIOPServerImpl is not a connected.&lt;br&gt;
     * A stub which is not connected can't be serialized, and thus
     * can't be registered in Jini. A stub which is not connected can't
     * be used to invoke methods on the server.
     * &lt;p&gt;
     * In order to palliate this, this method will connect the
     * given stub if it is not yet connected. If the given
     * &lt;var&gt;RMIServer&lt;/var&gt; is not an instance of
     * {@link javax.rmi.CORBA.Stub javax.rmi.CORBA.Stub}, then the
     * method do nothing and simply returns that stub. Otherwise,
     * this method will attempt to connect the stub to an ORB as
     * follows:
     * &lt;ul&gt;
     * &lt;li&gt;This method looks in the provided &lt;var&gt;environment&lt;/var&gt; for
     * the &quot;java.naming.corba.orb&quot; property. If it is found, the
     * referenced object (an {@link org.omg.CORBA.ORB ORB}) is used to
     * connect the stub. Otherwise, a new org.omg.CORBA.ORB is created
     * by calling {@link
     * org.omg.CORBA.ORB#init(String[], Properties)
     * org.omg.CORBA.ORB.init((String[])null,(Properties)null)}&lt;/li&gt;
     * &lt;li&gt;The new created ORB is kept in a static
     * {@link WeakReference} and can be reused for connecting other
     * stubs. However, no reference is ever kept on the ORB provided
     * in the &lt;var&gt;environment&lt;/var&gt; map, if any.&lt;/li&gt;
     * &lt;/ul&gt;
     * @param rmiServer A RMI Server Stub.
     * @param environment An environment map, possibly containing an ORB.
     * @return the given stub.
     * @exception IllegalArgumentException if the
     *      &lt;tt&gt;java.naming.corba.orb&lt;/tt&gt; property is specified and
     *      does not point to an {@link org.omg.CORBA.ORB ORB}.
     * @exception IOException if the connection to the ORB failed.
     **/
    static RMIServer connectStub(RMIServer rmiServer,
                                 Map&lt;String, ?&gt; environment)
        throws IOException {
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        if (IIOPHelper.isStub(rmiServer)) {</span>
            try {
<span class="nc" id="L1716">                IIOPHelper.getOrb(rmiServer);</span>
<span class="nc" id="L1717">            } catch (UnsupportedOperationException x) {</span>
                // BAD_OPERATION
<span class="nc" id="L1719">                IIOPHelper.connect(rmiServer, resolveOrb(environment));</span>
<span class="nc" id="L1720">            }</span>
        }
<span class="nc" id="L1722">        return rmiServer;</span>
    }

    /**
     * Get the ORB specified by &lt;var&gt;environment&lt;/var&gt;, or create a
     * new one.
     * &lt;p&gt;This method looks in the provided &lt;var&gt;environment&lt;/var&gt; for
     * the &quot;java.naming.corba.orb&quot; property. If it is found, the
     * referenced object (an {@link org.omg.CORBA.ORB ORB}) is
     * returned. Otherwise, a new org.omg.CORBA.ORB is created
     * by calling {@link
     * org.omg.CORBA.ORB#init(String[], java.util.Properties)
     * org.omg.CORBA.ORB.init((String[])null,(Properties)null)}
     * &lt;p&gt;The new created ORB is kept in a static
     * {@link WeakReference} and can be reused for connecting other
     * stubs. However, no reference is ever kept on the ORB provided
     * in the &lt;var&gt;environment&lt;/var&gt; map, if any.
     * @param environment An environment map, possibly containing an ORB.
     * @return An ORB.
     * @exception IllegalArgumentException if the
     *      &lt;tt&gt;java.naming.corba.orb&lt;/tt&gt; property is specified and
     *      does not point to an {@link org.omg.CORBA.ORB ORB}.
     * @exception IOException if the ORB initialization failed.
     **/
    static Object resolveOrb(Map&lt;String, ?&gt; environment)
        throws IOException {
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (environment != null) {</span>
<span class="nc" id="L1749">            final Object orb = environment.get(EnvHelp.DEFAULT_ORB);</span>
<span class="nc bnc" id="L1750" title="All 4 branches missed.">            if (orb != null &amp;&amp; !(IIOPHelper.isOrb(orb)))</span>
<span class="nc" id="L1751">                throw new IllegalArgumentException(EnvHelp.DEFAULT_ORB +</span>
                        &quot; must be an instance of org.omg.CORBA.ORB.&quot;);
<span class="nc bnc" id="L1753" title="All 2 branches missed.">            if (orb != null) return orb;</span>
        }
<span class="nc bnc" id="L1755" title="All 2 branches missed.">        final Object orb =</span>
<span class="nc" id="L1756">                (RMIConnector.orb==null)?null:RMIConnector.orb.get();</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">        if (orb != null) return orb;</span>

<span class="nc" id="L1759">        final Object newOrb =</span>
<span class="nc" id="L1760">                IIOPHelper.createOrb((String[])null, (Properties)null);</span>
<span class="nc" id="L1761">        RMIConnector.orb = new WeakReference&lt;Object&gt;(newOrb);</span>
<span class="nc" id="L1762">        return newOrb;</span>
    }

    /**
     * Read RMIConnector fields from an {@link java.io.ObjectInputStream
     * ObjectInputStream}.
     * Calls &lt;code&gt;s.defaultReadObject()&lt;/code&gt; and then initializes
     * all transient variables that need initializing.
     * @param s The ObjectInputStream to read from.
     * @exception InvalidObjectException if none of &lt;var&gt;rmiServer&lt;/var&gt; stub
     *    or &lt;var&gt;jmxServiceURL&lt;/var&gt; are set.
     * @see #RMIConnector(JMXServiceURL,Map)
     * @see #RMIConnector(RMIServer,Map)
     **/
    private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException  {
<span class="nc" id="L1778">        s.defaultReadObject();</span>

<span class="nc bnc" id="L1780" title="All 4 branches missed.">        if (rmiServer == null &amp;&amp; jmxServiceURL == null) throw new</span>
                InvalidObjectException(&quot;rmiServer and jmxServiceURL both null&quot;);

<span class="nc" id="L1783">        initTransients();</span>
<span class="nc" id="L1784">    }</span>

    /**
     * Writes the RMIConnector fields to an {@link java.io.ObjectOutputStream
     * ObjectOutputStream}.
     * &lt;p&gt;Connects the underlying RMIServer stub to an ORB, if needed,
     * before serializing it. This is done using the environment
     * map that was provided to the constructor, if any, and as documented
     * in {@link javax.management.remote.rmi}.&lt;/p&gt;
     * &lt;p&gt;This method then calls &lt;code&gt;s.defaultWriteObject()&lt;/code&gt;.
     * Usually, &lt;var&gt;rmiServer&lt;/var&gt; is null if this object
     * was constructed with a JMXServiceURL, and &lt;var&gt;jmxServiceURL&lt;/var&gt;
     * is null if this object is constructed with a RMIServer stub.
     * &lt;p&gt;Note that the environment Map is not serialized, since the objects
     * it contains are assumed to be contextual and relevant only
     * with respect to the local environment (class loader, ORB, etc...).&lt;/p&gt;
     * &lt;p&gt;After an RMIConnector is deserialized, it is assumed that the
     * user will call {@link #connect(Map)}, providing a new Map that
     * can contain values which are contextually relevant to the new
     * local environment.&lt;/p&gt;
     * &lt;p&gt;Since connection to the ORB is needed prior to serializing, and
     * since the ORB to connect to is one of those contextual parameters,
     * it is not recommended to re-serialize a just de-serialized object -
     * as the de-serialized object has no map. Thus, when an RMIConnector
     * object is needed for serialization or transmission to a remote
     * application, it is recommended to obtain a new RMIConnector stub
     * by calling {@link RMIConnectorServer#toJMXConnector(Map)}.&lt;/p&gt;
     * @param s The ObjectOutputStream to write to.
     * @exception InvalidObjectException if none of &lt;var&gt;rmiServer&lt;/var&gt; stub
     *    or &lt;var&gt;jmxServiceURL&lt;/var&gt; are set.
     * @see #RMIConnector(JMXServiceURL,Map)
     * @see #RMIConnector(RMIServer,Map)
     **/
    private void writeObject(java.io.ObjectOutputStream s)
    throws IOException {
<span class="nc bnc" id="L1819" title="All 4 branches missed.">        if (rmiServer == null &amp;&amp; jmxServiceURL == null) throw new</span>
                InvalidObjectException(&quot;rmiServer and jmxServiceURL both null.&quot;);
<span class="nc" id="L1821">        connectStub(this.rmiServer,env);</span>
<span class="nc" id="L1822">        s.defaultWriteObject();</span>
<span class="nc" id="L1823">    }</span>

    // Initialization of transient variables.
    private void initTransients() {
<span class="nc" id="L1827">        rmbscMap = new WeakHashMap&lt;Subject, WeakReference&lt;MBeanServerConnection&gt;&gt;();</span>
<span class="nc" id="L1828">        connected = false;</span>
<span class="nc" id="L1829">        terminated = false;</span>

<span class="nc" id="L1831">        connectionBroadcaster = new NotificationBroadcasterSupport();</span>
<span class="nc" id="L1832">    }</span>

    //--------------------------------------------------------------------
    // Private stuff - Check if stub can be trusted.
    //--------------------------------------------------------------------

    private static void checkStub(Remote stub,
            Class&lt;?&gt; stubClass) {

        // Check remote stub is from the expected class.
        //
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        if (stub.getClass() != stubClass) {</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">            if (!Proxy.isProxyClass(stub.getClass())) {</span>
<span class="nc" id="L1845">                throw new SecurityException(</span>
<span class="nc" id="L1846">                        &quot;Expecting a &quot; + stubClass.getName() + &quot; stub!&quot;);</span>
            } else {
<span class="nc" id="L1848">                InvocationHandler handler = Proxy.getInvocationHandler(stub);</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">                if (handler.getClass() != RemoteObjectInvocationHandler.class)</span>
<span class="nc" id="L1850">                    throw new SecurityException(</span>
                            &quot;Expecting a dynamic proxy instance with a &quot; +
<span class="nc" id="L1852">                            RemoteObjectInvocationHandler.class.getName() +</span>
                            &quot; invocation handler!&quot;);
                else
<span class="nc" id="L1855">                    stub = (Remote) handler;</span>
            }
        }

        // Check RemoteRef in stub is from the expected class
        // &quot;sun.rmi.server.UnicastRef2&quot;.
        //
<span class="nc" id="L1862">        RemoteRef ref = ((RemoteObject)stub).getRef();</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">        if (ref.getClass() != UnicastRef2.class)</span>
<span class="nc" id="L1864">            throw new SecurityException(</span>
<span class="nc" id="L1865">                    &quot;Expecting a &quot; + UnicastRef2.class.getName() +</span>
                    &quot; remote reference in stub!&quot;);

        // Check RMIClientSocketFactory in stub is from the expected class
        // &quot;javax.rmi.ssl.SslRMIClientSocketFactory&quot;.
        //
<span class="nc" id="L1871">        LiveRef liveRef = ((UnicastRef2)ref).getLiveRef();</span>
<span class="nc" id="L1872">        RMIClientSocketFactory csf = liveRef.getClientSocketFactory();</span>
<span class="nc bnc" id="L1873" title="All 4 branches missed.">        if (csf == null || csf.getClass() != SslRMIClientSocketFactory.class)</span>
<span class="nc" id="L1874">            throw new SecurityException(</span>
<span class="nc" id="L1875">                    &quot;Expecting a &quot; + SslRMIClientSocketFactory.class.getName() +</span>
                    &quot; RMI client socket factory in stub!&quot;);
<span class="nc" id="L1877">    }</span>

    //--------------------------------------------------------------------
    // Private stuff - RMIServer creation
    //--------------------------------------------------------------------

    private RMIServer findRMIServer(JMXServiceURL directoryURL,
            Map&lt;String, Object&gt; environment)
            throws NamingException, IOException {
<span class="nc" id="L1886">        final boolean isIiop = RMIConnectorServer.isIiopURL(directoryURL,true);</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">        if (isIiop) {</span>
            // Make sure java.naming.corba.orb is in the Map.
<span class="nc" id="L1889">            environment.put(EnvHelp.DEFAULT_ORB,resolveOrb(environment));</span>
        }

<span class="nc" id="L1892">        String path = directoryURL.getURLPath();</span>
<span class="nc" id="L1893">        int end = path.indexOf(';');</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">        if (end &lt; 0) end = path.length();</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">        if (path.startsWith(&quot;/jndi/&quot;))</span>
<span class="nc" id="L1896">            return findRMIServerJNDI(path.substring(6,end), environment, isIiop);</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">        else if (path.startsWith(&quot;/stub/&quot;))</span>
<span class="nc" id="L1898">            return findRMIServerJRMP(path.substring(6,end), environment, isIiop);</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">        else if (path.startsWith(&quot;/ior/&quot;)) {</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">            if (!IIOPHelper.isAvailable())</span>
<span class="nc" id="L1901">                throw new IOException(&quot;iiop protocol not available&quot;);</span>
<span class="nc" id="L1902">            return findRMIServerIIOP(path.substring(5,end), environment, isIiop);</span>
        } else {
<span class="nc" id="L1904">            final String msg = &quot;URL path must begin with /jndi/ or /stub/ &quot; +</span>
                    &quot;or /ior/: &quot; + path;
<span class="nc" id="L1906">            throw new MalformedURLException(msg);</span>
        }
    }

    /**
     * Lookup the RMIServer stub in a directory.
     * @param jndiURL A JNDI URL indicating the location of the Stub
     *                (see {@link javax.management.remote.rmi}), e.g.:
     *   &lt;ul&gt;&lt;li&gt;&lt;tt&gt;rmi://registry-host:port/rmi-stub-name&lt;/tt&gt;&lt;/li&gt;
     *       &lt;li&gt;or &lt;tt&gt;iiop://cosnaming-host:port/iiop-stub-name&lt;/tt&gt;&lt;/li&gt;
     *       &lt;li&gt;or &lt;tt&gt;ldap://ldap-host:port/java-container-dn&lt;/tt&gt;&lt;/li&gt;
     *   &lt;/ul&gt;
     * @param env the environment Map passed to the connector.
     * @param isIiop true if the stub is expected to be an IIOP stub.
     * @return The retrieved RMIServer stub.
     * @exception NamingException if the stub couldn't be found.
     **/
    private RMIServer findRMIServerJNDI(String jndiURL, Map&lt;String, ?&gt; env,
            boolean isIiop)
            throws NamingException {

<span class="nc" id="L1927">        InitialContext ctx = new InitialContext(EnvHelp.mapToHashtable(env));</span>

<span class="nc" id="L1929">        Object objref = ctx.lookup(jndiURL);</span>
<span class="nc" id="L1930">        ctx.close();</span>

<span class="nc bnc" id="L1932" title="All 2 branches missed.">        if (isIiop)</span>
<span class="nc" id="L1933">            return narrowIIOPServer(objref);</span>
        else
<span class="nc" id="L1935">            return narrowJRMPServer(objref);</span>
    }

    private static RMIServer narrowJRMPServer(Object objref) {

<span class="nc" id="L1940">        return (RMIServer) objref;</span>
    }

    private static RMIServer narrowIIOPServer(Object objref) {
        try {
<span class="nc" id="L1945">            return IIOPHelper.narrow(objref, RMIServer.class);</span>
<span class="nc" id="L1946">        } catch (ClassCastException e) {</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">            if (logger.traceOn())</span>
<span class="nc" id="L1948">                logger.trace(&quot;narrowIIOPServer&quot;,&quot;Failed to narrow objref=&quot; +</span>
                        objref + &quot;: &quot; + e);
<span class="nc bnc" id="L1950" title="All 2 branches missed.">            if (logger.debugOn()) logger.debug(&quot;narrowIIOPServer&quot;,e);</span>
<span class="nc" id="L1951">            return null;</span>
        }
    }

    private RMIServer findRMIServerIIOP(String ior, Map&lt;String, ?&gt; env, boolean isIiop) {
        // could forbid &quot;rmi:&quot; URL here -- but do we need to?
<span class="nc" id="L1957">        final Object orb = env.get(EnvHelp.DEFAULT_ORB);</span>
<span class="nc" id="L1958">        final Object stub = IIOPHelper.stringToObject(orb, ior);</span>
<span class="nc" id="L1959">        return IIOPHelper.narrow(stub, RMIServer.class);</span>
    }

    private RMIServer findRMIServerJRMP(String base64, Map&lt;String, ?&gt; env, boolean isIiop)
        throws IOException {
        // could forbid &quot;iiop:&quot; URL here -- but do we need to?
        final byte[] serialized;
        try {
<span class="nc" id="L1967">            serialized = base64ToByteArray(base64);</span>
<span class="nc" id="L1968">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1969">            throw new MalformedURLException(&quot;Bad BASE64 encoding: &quot; +</span>
<span class="nc" id="L1970">                    e.getMessage());</span>
<span class="nc" id="L1971">        }</span>
<span class="nc" id="L1972">        final ByteArrayInputStream bin = new ByteArrayInputStream(serialized);</span>

<span class="nc" id="L1974">        final ClassLoader loader = EnvHelp.resolveClientClassLoader(env);</span>
<span class="nc bnc" id="L1975" title="All 2 branches missed.">        final ObjectInputStream oin =</span>
                (loader == null) ?
                    new ObjectInputStream(bin) :
                    new ObjectInputStreamWithLoader(bin, loader);
        final Object stub;
        try {
<span class="nc" id="L1981">            stub = oin.readObject();</span>
<span class="nc" id="L1982">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1983">            throw new MalformedURLException(&quot;Class not found: &quot; + e);</span>
<span class="nc" id="L1984">        }</span>
<span class="nc" id="L1985">        return (RMIServer)stub;</span>
    }

    private static final class ObjectInputStreamWithLoader
            extends ObjectInputStream {
        ObjectInputStreamWithLoader(InputStream in, ClassLoader cl)
        throws IOException {
<span class="nc" id="L1992">            super(in);</span>
<span class="nc" id="L1993">            this.loader = cl;</span>
<span class="nc" id="L1994">        }</span>

        @Override
        protected Class&lt;?&gt; resolveClass(ObjectStreamClass classDesc)
                throws IOException, ClassNotFoundException {
<span class="nc" id="L1999">            String name = classDesc.getName();</span>
<span class="nc" id="L2000">            ReflectUtil.checkPackageAccess(name);</span>
<span class="nc" id="L2001">            return Class.forName(name, false, loader);</span>
        }

        private final ClassLoader loader;
    }

    private MBeanServerConnection getConnectionWithSubject(Subject delegationSubject) {
<span class="nc" id="L2008">        MBeanServerConnection conn = null;</span>

<span class="nc bnc" id="L2010" title="All 2 branches missed.">        if (delegationSubject == null) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">            if (nullSubjectConnRef == null</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                    || (conn = nullSubjectConnRef.get()) == null) {</span>
<span class="nc" id="L2013">                conn = new RemoteMBeanServerConnection(null);</span>
<span class="nc" id="L2014">                nullSubjectConnRef = new WeakReference(conn);</span>
            }
        } else {
<span class="nc" id="L2017">            WeakReference&lt;MBeanServerConnection&gt; wr = rmbscMap.get(delegationSubject);</span>
<span class="nc bnc" id="L2018" title="All 4 branches missed.">            if (wr == null || (conn = wr.get()) == null) {</span>
<span class="nc" id="L2019">                conn = new RemoteMBeanServerConnection(delegationSubject);</span>
<span class="nc" id="L2020">                rmbscMap.put(delegationSubject, new WeakReference(conn));</span>
            }
        }
<span class="nc" id="L2023">        return conn;</span>
    }

    /*
       The following section of code avoids a class loading problem
       with RMI.  The problem is that an RMI stub, when deserializing
       a remote method return value or exception, will first of all
       consult the first non-bootstrap class loader it finds in the
       call stack.  This can lead to behavior that is not portable
       between implementations of the JMX Remote API.  Notably, an
       implementation on J2SE 1.4 will find the RMI stub's loader on
       the stack.  But in J2SE 5, this stub is loaded by the
       bootstrap loader, so RMI will find the loader of the user code
       that called an MBeanServerConnection method.

       To avoid this problem, we take advantage of what the RMI stub
       is doing internally.  Each remote call will end up calling
       ref.invoke(...), where ref is the RemoteRef parameter given to
       the RMI stub's constructor.  It is within this call that the
       deserialization will happen.  So we fabricate our own RemoteRef
       that delegates everything to the &quot;real&quot; one but that is loaded
       by a class loader that knows no other classes.  The class
       loader NoCallStackClassLoader does this: the RemoteRef is an
       instance of the class named by proxyRefClassName, which is
       fabricated by the class loader using byte code that is defined
       by the string below.

       The call stack when the deserialization happens is thus this:
       MBeanServerConnection.getAttribute (or whatever)
       -&gt; RMIConnectionImpl_Stub.getAttribute
          -&gt; ProxyRef.invoke(...getAttribute...)
             -&gt; UnicastRef.invoke(...getAttribute...)
                -&gt; internal RMI stuff

       Here UnicastRef is the RemoteRef created when the stub was
       deserialized (which is of some RMI internal class).  It and the
       &quot;internal RMI stuff&quot; are loaded by the bootstrap loader, so are
       transparent to the stack search.  The first non-bootstrap
       loader found is our ProxyRefLoader, as required.

       In a future version of this code as integrated into J2SE 5,
       this workaround could be replaced by direct access to the
       internals of RMI.  For now, we use the same code base for J2SE
       and for the standalone Reference Implementation.

       The byte code below encodes the following class, compiled using
       J2SE 1.4.2 with the -g:none option.

        package com.sun.jmx.remote.internal;

        import java.lang.reflect.Method;
        import java.rmi.Remote;
        import java.rmi.server.RemoteRef;
        import com.sun.jmx.remote.internal.ProxyRef;

        public class PRef extends ProxyRef {
            public PRef(RemoteRef ref) {
                super(ref);
            }

            public Object invoke(Remote obj, Method method,
                                 Object[] params, long opnum)
                    throws Exception {
                return ref.invoke(obj, method, params, opnum);
            }
        }
     */

<span class="nc" id="L2091">    private static final String rmiServerImplStubClassName =</span>
<span class="nc" id="L2092">        RMIServer.class.getName() + &quot;Impl_Stub&quot;;</span>
    private static final Class&lt;?&gt; rmiServerImplStubClass;
<span class="nc" id="L2094">    private static final String rmiConnectionImplStubClassName =</span>
<span class="nc" id="L2095">            RMIConnection.class.getName() + &quot;Impl_Stub&quot;;</span>
    private static final Class&lt;?&gt; rmiConnectionImplStubClass;
    private static final String pRefClassName =
        &quot;com.sun.jmx.remote.internal.PRef&quot;;
    private static final Constructor&lt;?&gt; proxyRefConstructor;
    static {
        final String pRefByteCodeString =
                &quot;\312\376\272\276\0\0\0.\0\27\12\0\5\0\15\11\0\4\0\16\13\0\17\0&quot;+
                &quot;\20\7\0\21\7\0\22\1\0\6&lt;init&gt;\1\0\36(Ljava/rmi/server/RemoteRef;&quot;+
                &quot;)V\1\0\4Code\1\0\6invoke\1\0S(Ljava/rmi/Remote;Ljava/lang/reflec&quot;+
                &quot;t/Method;[Ljava/lang/Object;J)Ljava/lang/Object;\1\0\12Exception&quot;+
                &quot;s\7\0\23\14\0\6\0\7\14\0\24\0\25\7\0\26\14\0\11\0\12\1\0\40com/&quot;+
                &quot;sun/jmx/remote/internal/PRef\1\0$com/sun/jmx/remote/internal/Pr&quot;+
                &quot;oxyRef\1\0\23java/lang/Exception\1\0\3ref\1\0\33Ljava/rmi/serve&quot;+
                &quot;r/RemoteRef;\1\0\31java/rmi/server/RemoteRef\0!\0\4\0\5\0\0\0\0&quot;+
                &quot;\0\2\0\1\0\6\0\7\0\1\0\10\0\0\0\22\0\2\0\2\0\0\0\6*+\267\0\1\261&quot;+
                &quot;\0\0\0\0\0\1\0\11\0\12\0\2\0\10\0\0\0\33\0\6\0\6\0\0\0\17*\264\0&quot;+
                &quot;\2+,-\26\4\271\0\3\6\0\260\0\0\0\0\0\13\0\0\0\4\0\1\0\14\0\0&quot;;
<span class="nc" id="L2113">        final byte[] pRefByteCode =</span>
<span class="nc" id="L2114">                NoCallStackClassLoader.stringToBytes(pRefByteCodeString);</span>
<span class="nc" id="L2115">        PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt; action =</span>
<span class="nc" id="L2116">                new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() {</span>
            public Constructor&lt;?&gt; run() throws Exception {
<span class="nc" id="L2118">                Class thisClass = RMIConnector.class;</span>
<span class="nc" id="L2119">                ClassLoader thisLoader = thisClass.getClassLoader();</span>
<span class="nc" id="L2120">                ProtectionDomain thisProtectionDomain =</span>
<span class="nc" id="L2121">                        thisClass.getProtectionDomain();</span>
<span class="nc" id="L2122">                String[] otherClassNames = {ProxyRef.class.getName()};</span>
<span class="nc" id="L2123">                ClassLoader cl =</span>
                        new NoCallStackClassLoader(pRefClassName,
                        pRefByteCode,
                        otherClassNames,
                        thisLoader,
                        thisProtectionDomain);
<span class="nc" id="L2129">                Class&lt;?&gt; c = cl.loadClass(pRefClassName);</span>
<span class="nc" id="L2130">                return c.getConstructor(RemoteRef.class);</span>
            }
        };

        Class&lt;?&gt; serverStubClass;
        try {
<span class="nc" id="L2136">            serverStubClass = Class.forName(rmiServerImplStubClassName);</span>
<span class="nc" id="L2137">        } catch (Exception e) {</span>
<span class="nc" id="L2138">            logger.error(&quot;&lt;clinit&gt;&quot;,</span>
                    &quot;Failed to instantiate &quot; +
                    rmiServerImplStubClassName + &quot;: &quot; + e);
<span class="nc" id="L2141">            logger.debug(&quot;&lt;clinit&gt;&quot;,e);</span>
<span class="nc" id="L2142">            serverStubClass = null;</span>
<span class="nc" id="L2143">        }</span>
<span class="nc" id="L2144">        rmiServerImplStubClass = serverStubClass;</span>

        Class&lt;?&gt; stubClass;
        Constructor&lt;?&gt; constr;
        try {
<span class="nc" id="L2149">            stubClass = Class.forName(rmiConnectionImplStubClassName);</span>
<span class="nc" id="L2150">            constr = (Constructor&lt;?&gt;) AccessController.doPrivileged(action);</span>
<span class="nc" id="L2151">        } catch (Exception e) {</span>
<span class="nc" id="L2152">            logger.error(&quot;&lt;clinit&gt;&quot;,</span>
                    &quot;Failed to initialize proxy reference constructor &quot;+
                    &quot;for &quot; + rmiConnectionImplStubClassName + &quot;: &quot; + e);
<span class="nc" id="L2155">            logger.debug(&quot;&lt;clinit&gt;&quot;,e);</span>
<span class="nc" id="L2156">            stubClass = null;</span>
<span class="nc" id="L2157">            constr = null;</span>
<span class="nc" id="L2158">        }</span>
<span class="nc" id="L2159">        rmiConnectionImplStubClass = stubClass;</span>
<span class="nc" id="L2160">        proxyRefConstructor = constr;</span>
    }

    private static RMIConnection shadowJrmpStub(RemoteObject stub)
    throws InstantiationException, IllegalAccessException,
            InvocationTargetException, ClassNotFoundException,
            NoSuchMethodException {
<span class="nc" id="L2167">        RemoteRef ref = stub.getRef();</span>
<span class="nc" id="L2168">        RemoteRef proxyRef = (RemoteRef)</span>
<span class="nc" id="L2169">            proxyRefConstructor.newInstance(new Object[] {ref});</span>
<span class="nc" id="L2170">        final Constructor&lt;?&gt; rmiConnectionImplStubConstructor =</span>
<span class="nc" id="L2171">            rmiConnectionImplStubClass.getConstructor(RemoteRef.class);</span>
<span class="nc" id="L2172">        Object[] args = {proxyRef};</span>
<span class="nc" id="L2173">        RMIConnection proxyStub = (RMIConnection)</span>
<span class="nc" id="L2174">        rmiConnectionImplStubConstructor.newInstance(args);</span>
<span class="nc" id="L2175">        return proxyStub;</span>
    }

    /*
       The following code performs a similar trick for RMI/IIOP to the
       one described above for RMI/JRMP.  Unlike JRMP, though, we
       can't easily insert an object between the RMIConnection stub
       and the RMI/IIOP deserialization code, as explained below.

       A method in an RMI/IIOP stub does the following.  It makes an
       org.omg.CORBA_2_3.portable.OutputStream for each request, and
       writes the parameters to it.  Then it calls
       _invoke(OutputStream) which it inherits from CORBA's
       ObjectImpl.  That returns an
       org.omg.CORBA_2_3.portable.InputStream.  The return value is
       read from this InputStream.  So the stack during
       deserialization looks like this:

       MBeanServerConnection.getAttribute (or whatever)
       -&gt; _RMIConnection_Stub.getAttribute
          -&gt; Util.readAny (a CORBA method)
             -&gt; InputStream.read_any
                -&gt; internal CORBA stuff

       What we would have *liked* to have done would be the same thing
       as for RMI/JRMP.  We create a &quot;ProxyDelegate&quot; that is an
       org.omg.CORBA.portable.Delegate that simply forwards every
       operation to the real original Delegate from the RMIConnection
       stub, except that the InputStream returned by _invoke is
       wrapped by a &quot;ProxyInputStream&quot; that is loaded by our
       NoCallStackClassLoader.

       Unfortunately, this doesn't work, at least with Sun's J2SE
       1.4.2, because the CORBA code is not designed to allow you to
       change Delegates arbitrarily.  You get a ClassCastException
       from code that expects the Delegate to implement an internal
       interface.

       So instead we do the following.  We create a subclass of the
       stub that overrides the _invoke method so as to wrap the
       returned InputStream in a ProxyInputStream.  We create a
       subclass of ProxyInputStream using the NoCallStackClassLoader
       and override its read_any and read_value(Class) methods.
       (These are the only methods called during deserialization of
       MBeanServerConnection return values.)  We extract the Delegate
       from the original stub and insert it into our subclass stub,
       and away we go.  The state of a stub consists solely of its
       Delegate.

       We also need to catch ApplicationException, which will encode
       any exceptions declared in the throws clause of the called
       method.  Its InputStream needs to be wrapped in a
       ProxyInputSteam too.

       We override _releaseReply in the stub subclass so that it
       replaces a ProxyInputStream argument with the original
       InputStream.  This avoids problems if the implementation of
       _releaseReply ends up casting this InputStream to an
       implementation-specific interface (which in Sun's J2SE 5 it
       does).

       It is not strictly necessary for the stub subclass to be loaded
       by a NoCallStackClassLoader, since the call-stack search stops
       at the ProxyInputStream subclass.  However, it is convenient
       for two reasons.  One is that it means that the
       ProxyInputStream subclass can be accessed directly, without
       using reflection.  The other is that it avoids build problems,
       since usually stubs are created after other classes are
       compiled, so we can't access them from this class without,
       again, using reflection.

       The strings below encode the following two Java classes,
       compiled using javac -g:none.

        package com.sun.jmx.remote.protocol.iiop;

        import org.omg.stub.javax.management.remote.rmi._RMIConnection_Stub;

        import org.omg.CORBA.portable.ApplicationException;
        import org.omg.CORBA.portable.InputStream;
        import org.omg.CORBA.portable.OutputStream;
        import org.omg.CORBA.portable.RemarshalException;

        public class ProxyStub extends _RMIConnection_Stub {
            public InputStream _invoke(OutputStream out)
                    throws ApplicationException, RemarshalException {
                try {
                    return new PInputStream(super._invoke(out));
                } catch (ApplicationException e) {
                    InputStream pis = new PInputStream(e.getInputStream());
                    throw new ApplicationException(e.getId(), pis);
                }
            }

            public void _releaseReply(InputStream in) {
                if (in != null)
                    in = ((PInputStream)in).getProxiedInputStream();
                super._releaseReply(in);
            }
        }

        package com.sun.jmx.remote.protocol.iiop;

        public class PInputStream extends ProxyInputStream {
            public PInputStream(org.omg.CORBA.portable.InputStream in) {
                super(in);
            }

            public org.omg.CORBA.Any read_any() {
                return in.read_any();
            }

            public java.io.Serializable read_value(Class clz) {
                return narrow().read_value(clz);
            }
        }


     */
    private static final String iiopConnectionStubClassName =
        &quot;org.omg.stub.javax.management.remote.rmi._RMIConnection_Stub&quot;;
    private static final String proxyStubClassName =
        &quot;com.sun.jmx.remote.protocol.iiop.ProxyStub&quot;;
    private static final String ProxyInputStreamClassName =
        &quot;com.sun.jmx.remote.protocol.iiop.ProxyInputStream&quot;;
    private static final String pInputStreamClassName =
        &quot;com.sun.jmx.remote.protocol.iiop.PInputStream&quot;;
    private static final Class&lt;?&gt; proxyStubClass;
    static {
        final String proxyStubByteCodeString =
                &quot;\312\376\272\276\0\0\0\63\0+\12\0\14\0\30\7\0\31\12\0\14\0\32\12&quot;+
                &quot;\0\2\0\33\7\0\34\12\0\5\0\35\12\0\5\0\36\12\0\5\0\37\12\0\2\0 &quot;+
                &quot;\12\0\14\0!\7\0\&quot;\7\0#\1\0\6&lt;init&gt;\1\0\3()V\1\0\4Code\1\0\7_in&quot;+
                &quot;voke\1\0K(Lorg/omg/CORBA/portable/OutputStream;)Lorg/omg/CORBA&quot;+
                &quot;/portable/InputStream;\1\0\15StackMapTable\7\0\34\1\0\12Except&quot;+
                &quot;ions\7\0$\1\0\15_releaseReply\1\0'(Lorg/omg/CORBA/portable/Inp&quot;+
                &quot;utStream;)V\14\0\15\0\16\1\0-com/sun/jmx/remote/protocol/iiop/&quot;+
                &quot;PInputStream\14\0\20\0\21\14\0\15\0\27\1\0+org/omg/CORBA/porta&quot;+
                &quot;ble/ApplicationException\14\0%\0&amp;\14\0'\0(\14\0\15\0)\14\0*\0&amp;&quot;+
                &quot;\14\0\26\0\27\1\0*com/sun/jmx/remote/protocol/iiop/ProxyStub\1&quot;+
                &quot;\0&lt;org/omg/stub/javax/management/remote/rmi/_RMIConnection_Stu&quot;+
                &quot;b\1\0)org/omg/CORBA/portable/RemarshalException\1\0\16getInput&quot;+
                &quot;Stream\1\0&amp;()Lorg/omg/CORBA/portable/InputStream;\1\0\5getId\1&quot;+
                &quot;\0\24()Ljava/lang/String;\1\09(Ljava/lang/String;Lorg/omg/CORB&quot;+
                &quot;A/portable/InputStream;)V\1\0\25getProxiedInputStream\0!\0\13\0&quot;+
                &quot;\14\0\0\0\0\0\3\0\1\0\15\0\16\0\1\0\17\0\0\0\21\0\1\0\1\0\0\0\5&quot;+
                &quot;*\267\0\1\261\0\0\0\0\0\1\0\20\0\21\0\2\0\17\0\0\0G\0\4\0\4\0\0&quot;+
                &quot;\0'\273\0\2Y*+\267\0\3\267\0\4\260M\273\0\2Y,\266\0\6\267\0\4N&quot;+
                &quot;\273\0\5Y,\266\0\7-\267\0\10\277\0\1\0\0\0\14\0\15\0\5\0\1\0\22&quot;+
                &quot;\0\0\0\6\0\1M\7\0\23\0\24\0\0\0\6\0\2\0\5\0\25\0\1\0\26\0\27\0&quot;+
                &quot;\1\0\17\0\0\0'\0\2\0\2\0\0\0\22+\306\0\13+\300\0\2\266\0\11L*+&quot;+
                &quot;\267\0\12\261\0\0\0\1\0\22\0\0\0\3\0\1\14\0\0&quot;;
        final String pInputStreamByteCodeString =
                &quot;\312\376\272\276\0\0\0\63\0\36\12\0\7\0\17\11\0\6\0\20\12\0\21&quot;+
                &quot;\0\22\12\0\6\0\23\12\0\24\0\25\7\0\26\7\0\27\1\0\6&lt;init&gt;\1\0'(&quot;+
                &quot;Lorg/omg/CORBA/portable/InputStream;)V\1\0\4Code\1\0\10read_an&quot;+
                &quot;y\1\0\25()Lorg/omg/CORBA/Any;\1\0\12read_value\1\0)(Ljava/lang&quot;+
                &quot;/Class;)Ljava/io/Serializable;\14\0\10\0\11\14\0\30\0\31\7\0\32&quot;+
                &quot;\14\0\13\0\14\14\0\33\0\34\7\0\35\14\0\15\0\16\1\0-com/sun/jmx&quot;+
                &quot;/remote/protocol/iiop/PInputStream\1\0\61com/sun/jmx/remote/pr&quot;+
                &quot;otocol/iiop/ProxyInputStream\1\0\2in\1\0$Lorg/omg/CORBA/portab&quot;+
                &quot;le/InputStream;\1\0\&quot;org/omg/CORBA/portable/InputStream\1\0\6n&quot;+
                &quot;arrow\1\0*()Lorg/omg/CORBA_2_3/portable/InputStream;\1\0&amp;org/o&quot;+
                &quot;mg/CORBA_2_3/portable/InputStream\0!\0\6\0\7\0\0\0\0\0\3\0\1\0&quot;+
                &quot;\10\0\11\0\1\0\12\0\0\0\22\0\2\0\2\0\0\0\6*+\267\0\1\261\0\0\0&quot;+
                &quot;\0\0\1\0\13\0\14\0\1\0\12\0\0\0\24\0\1\0\1\0\0\0\10*\264\0\2\266&quot;+
                &quot;\0\3\260\0\0\0\0\0\1\0\15\0\16\0\1\0\12\0\0\0\25\0\2\0\2\0\0\0&quot;+
                &quot;\11*\266\0\4+\266\0\5\260\0\0\0\0\0\0&quot;;
<span class="nc" id="L2343">        final byte[] proxyStubByteCode =</span>
<span class="nc" id="L2344">                NoCallStackClassLoader.stringToBytes(proxyStubByteCodeString);</span>
<span class="nc" id="L2345">        final byte[] pInputStreamByteCode =</span>
<span class="nc" id="L2346">                NoCallStackClassLoader.stringToBytes(pInputStreamByteCodeString);</span>
<span class="nc" id="L2347">        final String[] classNames={proxyStubClassName, pInputStreamClassName};</span>
<span class="nc" id="L2348">        final byte[][] byteCodes = {proxyStubByteCode, pInputStreamByteCode};</span>
<span class="nc" id="L2349">        final String[] otherClassNames = {</span>
            iiopConnectionStubClassName,
            ProxyInputStreamClassName,
        };
<span class="nc bnc" id="L2353" title="All 2 branches missed.">        if (IIOPHelper.isAvailable()) {</span>
<span class="nc" id="L2354">            PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt; action =</span>
<span class="nc" id="L2355">                new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() {</span>
              public Class&lt;?&gt; run() throws Exception {
<span class="nc" id="L2357">                Class thisClass = RMIConnector.class;</span>
<span class="nc" id="L2358">                ClassLoader thisLoader = thisClass.getClassLoader();</span>
<span class="nc" id="L2359">                ProtectionDomain thisProtectionDomain =</span>
<span class="nc" id="L2360">                        thisClass.getProtectionDomain();</span>
<span class="nc" id="L2361">                ClassLoader cl =</span>
                        new NoCallStackClassLoader(classNames,
                        byteCodes,
                        otherClassNames,
                        thisLoader,
                        thisProtectionDomain);
<span class="nc" id="L2367">                return cl.loadClass(proxyStubClassName);</span>
              }
            };
            Class&lt;?&gt; stubClass;
            try {
<span class="nc" id="L2372">                stubClass = AccessController.doPrivileged(action);</span>
<span class="nc" id="L2373">            } catch (Exception e) {</span>
<span class="nc" id="L2374">                logger.error(&quot;&lt;clinit&gt;&quot;,</span>
                        &quot;Unexpected exception making shadow IIOP stub class: &quot;+e);
<span class="nc" id="L2376">                logger.debug(&quot;&lt;clinit&gt;&quot;,e);</span>
<span class="nc" id="L2377">                stubClass = null;</span>
<span class="nc" id="L2378">            }</span>
<span class="nc" id="L2379">            proxyStubClass = stubClass;</span>
<span class="nc" id="L2380">        } else {</span>
<span class="nc" id="L2381">            proxyStubClass = null;</span>
        }
    }

  private static RMIConnection shadowIiopStub(Object stub)
    throws InstantiationException, IllegalAccessException {
<span class="nc" id="L2387">        Object proxyStub = null;</span>
        try {
<span class="nc" id="L2389">            proxyStub = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {</span>
                public Object run() throws Exception {
<span class="nc" id="L2391">                    return proxyStubClass.newInstance();</span>
                }
            });
<span class="nc" id="L2394">        } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L2395">            throw new InternalError();</span>
<span class="nc" id="L2396">        }</span>
<span class="nc" id="L2397">        IIOPHelper.setDelegate(proxyStub, IIOPHelper.getDelegate(stub));</span>
<span class="nc" id="L2398">        return (RMIConnection) proxyStub;</span>
    }
    private static RMIConnection getConnection(RMIServer server,
            Object credentials,
            boolean checkStub)
            throws IOException {
<span class="nc" id="L2404">        RMIConnection c = server.newClient(credentials);</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (checkStub) checkStub(c, rmiConnectionImplStubClass);</span>
        try {
<span class="nc bnc" id="L2407" title="All 2 branches missed.">            if (c.getClass() == rmiConnectionImplStubClass)</span>
<span class="nc" id="L2408">                return shadowJrmpStub((RemoteObject) c);</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">            if (c.getClass().getName().equals(iiopConnectionStubClassName))</span>
<span class="nc" id="L2410">                return shadowIiopStub(c);</span>
<span class="nc" id="L2411">            logger.trace(&quot;getConnection&quot;,</span>
<span class="nc" id="L2412">                    &quot;Did not wrap &quot; + c.getClass() + &quot; to foil &quot; +</span>
                    &quot;stack search for classes: class loading semantics &quot; +
                    &quot;may be incorrect&quot;);
<span class="nc" id="L2415">        } catch (Exception e) {</span>
<span class="nc" id="L2416">            logger.error(&quot;getConnection&quot;,</span>
<span class="nc" id="L2417">                    &quot;Could not wrap &quot; + c.getClass() + &quot; to foil &quot; +</span>
                    &quot;stack search for classes: class loading semantics &quot; +
                    &quot;may be incorrect: &quot; + e);
<span class="nc" id="L2420">            logger.debug(&quot;getConnection&quot;,e);</span>
            // so just return the original stub, which will work for all
            // but the most exotic class loading situations
<span class="nc" id="L2423">        }</span>
<span class="nc" id="L2424">        return c;</span>
    }

    private static byte[] base64ToByteArray(String s) {
<span class="nc" id="L2428">        int sLen = s.length();</span>
<span class="nc" id="L2429">        int numGroups = sLen/4;</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">        if (4*numGroups != sLen)</span>
<span class="nc" id="L2431">            throw new IllegalArgumentException(</span>
                    &quot;String length must be a multiple of four.&quot;);
<span class="nc" id="L2433">        int missingBytesInLastGroup = 0;</span>
<span class="nc" id="L2434">        int numFullGroups = numGroups;</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">        if (sLen != 0) {</span>
<span class="nc bnc" id="L2436" title="All 2 branches missed.">            if (s.charAt(sLen-1) == '=') {</span>
<span class="nc" id="L2437">                missingBytesInLastGroup++;</span>
<span class="nc" id="L2438">                numFullGroups--;</span>
            }
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            if (s.charAt(sLen-2) == '=')</span>
<span class="nc" id="L2441">                missingBytesInLastGroup++;</span>
        }
<span class="nc" id="L2443">        byte[] result = new byte[3*numGroups - missingBytesInLastGroup];</span>

        // Translate all full groups from base64 to byte array elements
<span class="nc" id="L2446">        int inCursor = 0, outCursor = 0;</span>
<span class="nc bnc" id="L2447" title="All 2 branches missed.">        for (int i=0; i&lt;numFullGroups; i++) {</span>
<span class="nc" id="L2448">            int ch0 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2449">            int ch1 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2450">            int ch2 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2451">            int ch3 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2452">            result[outCursor++] = (byte) ((ch0 &lt;&lt; 2) | (ch1 &gt;&gt; 4));</span>
<span class="nc" id="L2453">            result[outCursor++] = (byte) ((ch1 &lt;&lt; 4) | (ch2 &gt;&gt; 2));</span>
<span class="nc" id="L2454">            result[outCursor++] = (byte) ((ch2 &lt;&lt; 6) | ch3);</span>
        }

        // Translate partial group, if present
<span class="nc bnc" id="L2458" title="All 2 branches missed.">        if (missingBytesInLastGroup != 0) {</span>
<span class="nc" id="L2459">            int ch0 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2460">            int ch1 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2461">            result[outCursor++] = (byte) ((ch0 &lt;&lt; 2) | (ch1 &gt;&gt; 4));</span>

<span class="nc bnc" id="L2463" title="All 2 branches missed.">            if (missingBytesInLastGroup == 1) {</span>
<span class="nc" id="L2464">                int ch2 = base64toInt(s.charAt(inCursor++));</span>
<span class="nc" id="L2465">                result[outCursor++] = (byte) ((ch1 &lt;&lt; 4) | (ch2 &gt;&gt; 2));</span>
            }
        }
        // assert inCursor == s.length()-missingBytesInLastGroup;
        // assert outCursor == result.length;
<span class="nc" id="L2470">        return result;</span>
    }

    /**
     * Translates the specified character, which is assumed to be in the
     * &quot;Base 64 Alphabet&quot; into its equivalent 6-bit positive integer.
     *
     * @throws IllegalArgumentException if
     *        c is not in the Base64 Alphabet.
     */
    private static int base64toInt(char c) {
        int result;

<span class="nc bnc" id="L2483" title="All 2 branches missed.">        if (c &gt;= base64ToInt.length)</span>
<span class="nc" id="L2484">            result = -1;</span>
        else
<span class="nc" id="L2486">            result = base64ToInt[c];</span>

<span class="nc bnc" id="L2488" title="All 2 branches missed.">        if (result &lt; 0)</span>
<span class="nc" id="L2489">            throw new IllegalArgumentException(&quot;Illegal character &quot; + c);</span>
<span class="nc" id="L2490">        return result;</span>
    }

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the &quot;Base64 Alphabet&quot; (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     */
<span class="nc" id="L2500">    private static final byte base64ToInt[] = {</span>
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    };

    //--------------------------------------------------------------------
    // Private stuff - Find / Set default class loader
    //--------------------------------------------------------------------
    private ClassLoader pushDefaultClassLoader() {
<span class="nc" id="L2514">        final Thread t = Thread.currentThread();</span>
<span class="nc" id="L2515">        final ClassLoader old =  t.getContextClassLoader();</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">        if (defaultClassLoader != null)</span>
<span class="nc" id="L2517">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="nc" id="L2519">                    t.setContextClassLoader(defaultClassLoader);</span>
<span class="nc" id="L2520">                    return null;</span>
                }
            });
<span class="nc" id="L2523">            return old;</span>
    }

    private void popDefaultClassLoader(final ClassLoader old) {
<span class="nc" id="L2527">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
<span class="nc" id="L2529">                Thread.currentThread().setContextClassLoader(old);</span>
<span class="nc" id="L2530">                return null;</span>
            }
        });
<span class="nc" id="L2533">    }</span>

    //--------------------------------------------------------------------
    // Private variables
    //--------------------------------------------------------------------
    /**
     * @serial The RMIServer stub of the RMI JMX Connector server to
     * which this client connector is (or will be) connected. This
     * field can be null when &lt;var&gt;jmxServiceURL&lt;/var&gt; is not
     * null. This includes the case where &lt;var&gt;jmxServiceURL&lt;/var&gt;
     * contains a serialized RMIServer stub. If both
     * &lt;var&gt;rmiServer&lt;/var&gt; and &lt;var&gt;jmxServiceURL&lt;/var&gt; are null then
     * serialization will fail.
     *
     * @see #RMIConnector(RMIServer,Map)
     **/
    private final RMIServer rmiServer;

    /**
     * @serial The JMXServiceURL of the RMI JMX Connector server to
     * which this client connector will be connected. This field can
     * be null when &lt;var&gt;rmiServer&lt;/var&gt; is not null. If both
     * &lt;var&gt;rmiServer&lt;/var&gt; and &lt;var&gt;jmxServiceURL&lt;/var&gt; are null then
     * serialization will fail.
     *
     * @see #RMIConnector(JMXServiceURL,Map)
     **/
    private final JMXServiceURL jmxServiceURL;

    // ---------------------------------------------------------
    // WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
    // ---------------------------------------------------------
    // Any transient variable which needs to be initialized should
    // be initialized in the method initTransient()
    private transient Map&lt;String, Object&gt; env;
    private transient ClassLoader defaultClassLoader;
    private transient RMIConnection connection;
    private transient String connectionId;

<span class="nc" id="L2572">    private transient long clientNotifSeqNo = 0;</span>

    private transient WeakHashMap&lt;Subject, WeakReference&lt;MBeanServerConnection&gt;&gt; rmbscMap;
<span class="nc" id="L2575">    private transient WeakReference&lt;MBeanServerConnection&gt; nullSubjectConnRef = null;</span>

    private transient RMINotifClient rmiNotifClient;
    // = new RMINotifClient(new Integer(0));

<span class="nc" id="L2580">    private transient long clientNotifCounter = 0;</span>

    private transient boolean connected;
    // = false;
    private transient boolean terminated;
    // = false;

    private transient Exception closeException;

    private transient NotificationBroadcasterSupport connectionBroadcaster;

    private transient ClientCommunicatorAdmin communicatorAdmin;

    /**
     * A static WeakReference to an {@link org.omg.CORBA.ORB ORB} to
     * connect unconnected stubs.
     **/
<span class="nc" id="L2597">    private static volatile WeakReference&lt;Object&gt; orb = null;</span>

    // TRACES &amp; DEBUG
    //---------------
    private static String objects(final Object[] objs) {
<span class="nc bnc" id="L2602" title="All 2 branches missed.">        if (objs == null)</span>
<span class="nc" id="L2603">            return &quot;null&quot;;</span>
        else
<span class="nc" id="L2605">            return Arrays.asList(objs).toString();</span>
    }

    private static String strings(final String[] strs) {
<span class="nc" id="L2609">        return objects(strs);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>