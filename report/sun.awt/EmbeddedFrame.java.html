<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EmbeddedFrame.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt</a> &gt; <span class="el_source">EmbeddedFrame.java</span></div><h1>EmbeddedFrame.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.peer.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.util.Set;
import java.awt.AWTKeyStroke;
import java.applet.Applet;
import sun.applet.AppletPanel;

/**
 * A generic container used for embedding Java components, usually applets.
 * An EmbeddedFrame has two related uses:
 *
 * . Within a Java-based application, an EmbeddedFrame serves as a sort of
 *   firewall, preventing the contained components or applets from using
 *   getParent() to find parent components, such as menubars.
 *
 * . Within a C-based application, an EmbeddedFrame contains a window handle
 *   which was created by the application, which serves as the top-level
 *   Java window.  EmbeddedFrames created for this purpose are passed-in a
 *   handle of an existing window created by the application.  The window
 *   handle should be of the appropriate native type for a specific
 *   platform, as stored in the pData field of the ComponentPeer.
 *
 * @author      Thomas Ball
 */
public abstract class EmbeddedFrame extends Frame
                          implements KeyEventDispatcher, PropertyChangeListener {

<span class="nc" id="L59">    private boolean isCursorAllowed = true;</span>
<span class="nc" id="L60">    private boolean supportsXEmbed = false;</span>
    private KeyboardFocusManager appletKFM;
    // JDK 1.1 compatibility
    private static final long serialVersionUID = 2967042741780317130L;

    /*
     * The constants define focus traversal directions.
     * Use them in {@code traverseIn}, {@code traverseOut} methods.
     */
    protected static final boolean FORWARD = true;
    protected static final boolean BACKWARD = false;

    public boolean supportsXEmbed() {
<span class="nc bnc" id="L73" title="All 4 branches missed.">        return supportsXEmbed &amp;&amp; SunToolkit.needsXEmbed();</span>
    }

    protected EmbeddedFrame(boolean supportsXEmbed) {
<span class="nc" id="L77">        this((long)0, supportsXEmbed);</span>
<span class="nc" id="L78">    }</span>


    protected EmbeddedFrame() {
<span class="nc" id="L82">        this((long)0);</span>
<span class="nc" id="L83">    }</span>

    /**
     * @deprecated This constructor will be removed in 1.5
     */
    @Deprecated
    protected EmbeddedFrame(int handle) {
<span class="nc" id="L90">        this((long)handle);</span>
<span class="nc" id="L91">    }</span>

    protected EmbeddedFrame(long handle) {
<span class="nc" id="L94">        this(handle, false);</span>
<span class="nc" id="L95">    }</span>

<span class="nc" id="L97">    protected EmbeddedFrame(long handle, boolean supportsXEmbed) {</span>
<span class="nc" id="L98">        this.supportsXEmbed = supportsXEmbed;</span>
<span class="nc" id="L99">        registerListeners();</span>
<span class="nc" id="L100">    }</span>

    /**
     * Block introspection of a parent window by this child.
     */
    public Container getParent() {
<span class="nc" id="L106">        return null;</span>
    }

    /**
     * Needed to track which KeyboardFocusManager is current. We want to avoid memory
     * leaks, so when KFM stops being current, we remove ourselves as listeners.
     */
    public void propertyChange(PropertyChangeEvent evt) {
        // We don't handle any other properties. Skip it.
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (!evt.getPropertyName().equals(&quot;managingFocus&quot;)) {</span>
<span class="nc" id="L116">            return;</span>
        }

        // We only do it if it stops being current. Technically, we should
        // never get an event about KFM starting being current.
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (evt.getNewValue() == Boolean.TRUE) {</span>
<span class="nc" id="L122">            return;</span>
        }

        // should be the same as appletKFM
<span class="nc" id="L126">        removeTraversingOutListeners((KeyboardFocusManager)evt.getSource());</span>

<span class="nc" id="L128">        appletKFM = KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (isVisible()) {</span>
<span class="nc" id="L130">            addTraversingOutListeners(appletKFM);</span>
        }
<span class="nc" id="L132">    }</span>

    /**
     * Register us as KeyEventDispatcher and property &quot;managingFocus&quot; listeners.
     */
    private void addTraversingOutListeners(KeyboardFocusManager kfm) {
<span class="nc" id="L138">        kfm.addKeyEventDispatcher(this);</span>
<span class="nc" id="L139">        kfm.addPropertyChangeListener(&quot;managingFocus&quot;, this);</span>
<span class="nc" id="L140">    }</span>

    /**
     * Deregister us as KeyEventDispatcher and property &quot;managingFocus&quot; listeners.
     */
    private void removeTraversingOutListeners(KeyboardFocusManager kfm) {
<span class="nc" id="L146">        kfm.removeKeyEventDispatcher(this);</span>
<span class="nc" id="L147">        kfm.removePropertyChangeListener(&quot;managingFocus&quot;, this);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Because there may be many AppContexts, and we can't be sure where this
     * EmbeddedFrame is first created or shown, we can't automatically determine
     * the correct KeyboardFocusManager to attach to as KeyEventDispatcher.
     * Those who want to use the functionality of traversing out of the EmbeddedFrame
     * must call this method on the Applet's AppContext. After that, all the changes
     * can be handled automatically, including possible replacement of
     * KeyboardFocusManager.
     */
    public void registerListeners() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (appletKFM != null) {</span>
<span class="nc" id="L161">            removeTraversingOutListeners(appletKFM);</span>
        }
<span class="nc" id="L163">        appletKFM = KeyboardFocusManager.getCurrentKeyboardFocusManager();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (isVisible()) {</span>
<span class="nc" id="L165">            addTraversingOutListeners(appletKFM);</span>
        }
<span class="nc" id="L167">    }</span>

    /**
     * Needed to avoid memory leak: we register this EmbeddedFrame as a listener with
     * KeyboardFocusManager of applet's AppContext. We don't want the KFM to keep
     * reference to our EmbeddedFrame forever if the Frame is no longer in use, so we
     * add listeners in show() and remove them in hide().
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public void show() {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (appletKFM != null) {</span>
<span class="nc" id="L178">            addTraversingOutListeners(appletKFM);</span>
        }
<span class="nc" id="L180">        super.show();</span>
<span class="nc" id="L181">    }</span>

    /**
     * Needed to avoid memory leak: we register this EmbeddedFrame as a listener with
     * KeyboardFocusManager of applet's AppContext. We don't want the KFM to keep
     * reference to our EmbeddedFrame forever if the Frame is no longer in use, so we
     * add listeners in show() and remove them in hide().
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public void hide() {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (appletKFM != null) {</span>
<span class="nc" id="L192">            removeTraversingOutListeners(appletKFM);</span>
        }
<span class="nc" id="L194">        super.hide();</span>
<span class="nc" id="L195">    }</span>

    /**
     * Need this method to detect when the focus may have chance to leave the
     * focus cycle root which is EmbeddedFrame. Mostly, the code here is copied
     * from DefaultKeyboardFocusManager.processKeyEvent with some minor
     * modifications.
     */
    public boolean dispatchKeyEvent(KeyEvent e) {

<span class="nc" id="L205">        Container currentRoot = AWTAccessor.getKeyboardFocusManagerAccessor()</span>
<span class="nc" id="L206">                                    .getCurrentFocusCycleRoot();</span>

        // if we are not in EmbeddedFrame's cycle, we should not try to leave.
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (this != currentRoot) {</span>
<span class="nc" id="L210">            return false;</span>
        }

        // KEY_TYPED events cannot be focus traversal keys
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (e.getID() == KeyEvent.KEY_TYPED) {</span>
<span class="nc" id="L215">            return false;</span>
        }

<span class="nc bnc" id="L218" title="All 4 branches missed.">        if (!getFocusTraversalKeysEnabled() || e.isConsumed()) {</span>
<span class="nc" id="L219">            return false;</span>
        }

<span class="nc" id="L222">        AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e);</span>
        Set&lt;AWTKeyStroke&gt; toTest;
<span class="nc" id="L224">        Component currentFocused = e.getComponent();</span>

<span class="nc" id="L226">        toTest = getFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (toTest.contains(stroke)) {</span>
            // 6581899: performance improvement for SortingFocusTraversalPolicy
<span class="nc" id="L229">            Component last = getFocusTraversalPolicy().getLastComponent(this);</span>
<span class="nc bnc" id="L230" title="All 4 branches missed.">            if (currentFocused == last || last == null) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if (traverseOut(FORWARD)) {</span>
<span class="nc" id="L232">                    e.consume();</span>
<span class="nc" id="L233">                    return true;</span>
                }
            }
        }

<span class="nc" id="L238">        toTest = getFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (toTest.contains(stroke)) {</span>
            // 6581899: performance improvement for SortingFocusTraversalPolicy
<span class="nc" id="L241">            Component first = getFocusTraversalPolicy().getFirstComponent(this);</span>
<span class="nc bnc" id="L242" title="All 4 branches missed.">            if (currentFocused == first || first == null) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                if (traverseOut(BACKWARD)) {</span>
<span class="nc" id="L244">                    e.consume();</span>
<span class="nc" id="L245">                    return true;</span>
                }
            }
        }
<span class="nc" id="L249">        return false;</span>
    }

    /**
     * This method is called by the embedder when we should receive focus as element
     * of the traversal chain.  The method requests focus on:
     * 1. the first Component of this EmbeddedFrame if user moves focus forward
     *    in the focus traversal cycle.
     * 2. the last Component of this EmbeddedFrame if user moves focus backward
     *    in the focus traversal cycle.
     *
     * The direction parameter specifies which of the two mentioned cases is
     * happening. Use FORWARD and BACKWARD constants defined in the EmbeddedFrame class
     * to avoid confusing boolean values.
     *
     * A concrete implementation of this method is defined in the platform-dependent
     * subclasses.
     *
     * @param direction FORWARD or BACKWARD
     * @return true, if the EmbeddedFrame wants to get focus, false otherwise.
     */
    public boolean traverseIn(boolean direction) {
<span class="nc" id="L271">        Component comp = null;</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (direction == FORWARD) {</span>
<span class="nc" id="L274">            comp = getFocusTraversalPolicy().getFirstComponent(this);</span>
        } else {
<span class="nc" id="L276">            comp = getFocusTraversalPolicy().getLastComponent(this);</span>
        }
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (comp != null) {</span>
            // comp.requestFocus(); - Leads to a hung.

<span class="nc" id="L281">            AWTAccessor.getKeyboardFocusManagerAccessor().setMostRecentFocusOwner(this, comp);</span>
<span class="nc" id="L282">            synthesizeWindowActivation(true);</span>
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        return (null != comp);</span>
    }

    /**
     * This method is called from dispatchKeyEvent in the following two cases:
     * 1. The focus is on the first Component of this EmbeddedFrame and we are
     *    about to transfer the focus backward.
     * 2. The focus in on the last Component of this EmbeddedFrame and we are
     *    about to transfer the focus forward.
     * This is needed to give the opportuity for keyboard focus to leave the
     * EmbeddedFrame. Override this method, initiate focus transfer in it and
     * return true if you want the focus to leave EmbeddedFrame's cycle.
     * The direction parameter specifies which of the two mentioned cases is
     * happening. Use FORWARD and BACKWARD constants defined in EmbeddedFrame
     * to avoid confusing boolean values.
     *
     * @param direction FORWARD or BACKWARD
     * @return true, if EmbeddedFrame wants the focus to leave it,
     *         false otherwise.
     */
    protected boolean traverseOut(boolean direction) {
<span class="nc" id="L305">        return false;</span>
    }

    /**
     * Block modifying any frame attributes, since they aren't applicable
     * for EmbeddedFrames.
     */
<span class="nc" id="L312">    public void setTitle(String title) {}</span>
<span class="nc" id="L313">    public void setIconImage(Image image) {}</span>
<span class="nc" id="L314">    public void setIconImages(java.util.List&lt;? extends Image&gt; icons) {}</span>
<span class="nc" id="L315">    public void setMenuBar(MenuBar mb) {}</span>
<span class="nc" id="L316">    public void setResizable(boolean resizable) {}</span>
<span class="nc" id="L317">    public void remove(MenuComponent m) {}</span>

    public boolean isResizable() {
<span class="nc" id="L320">        return true;</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    public void addNotify() {
<span class="nc" id="L325">        synchronized (getTreeLock()) {</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (getPeer() == null) {</span>
<span class="nc" id="L327">                setPeer(new NullEmbeddedFramePeer());</span>
            }
<span class="nc" id="L329">            super.addNotify();</span>
<span class="nc" id="L330">        }</span>
<span class="nc" id="L331">    }</span>

    // These three functions consitute RFE 4100710. Do not remove.
    @SuppressWarnings(&quot;deprecation&quot;)
    public void setCursorAllowed(boolean isCursorAllowed) {
<span class="nc" id="L336">        this.isCursorAllowed = isCursorAllowed;</span>
<span class="nc" id="L337">        getPeer().updateCursorImmediately();</span>
<span class="nc" id="L338">    }</span>
    public boolean isCursorAllowed() {
<span class="nc" id="L340">        return isCursorAllowed;</span>
    }
    public Cursor getCursor() {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        return (isCursorAllowed)</span>
<span class="nc" id="L344">            ? super.getCursor()</span>
<span class="nc" id="L345">            : Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    protected void setPeer(final ComponentPeer p){
<span class="nc" id="L350">        AWTAccessor.getComponentAccessor().setPeer(EmbeddedFrame.this, p);</span>
<span class="nc" id="L351">    };</span>

    /**
     * Synthesize native message to activate or deactivate EmbeddedFrame window
     * depending on the value of parameter &lt;code&gt;b&lt;/code&gt;.
     * Peers should override this method if they are to implement
     * this functionality.
     * @param doActivate  if &lt;code&gt;true&lt;/code&gt;, activates the window;
     * otherwise, deactivates the window
     */
<span class="nc" id="L361">    public void synthesizeWindowActivation(boolean doActivate) {}</span>

    /**
     * Moves this embedded frame to a new location. The top-left corner of
     * the new location is specified by the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;
     * parameters relative to the native parent component.
     * &lt;p&gt;
     * setLocation() and setBounds() for EmbeddedFrame really don't move it
     * within the native parent. These methods always put embedded frame to
     * (0, 0) for backward compatibility. To allow moving embedded frame
     * setLocationPrivate() and setBoundsPrivate() were introduced, and they
     * work just the same way as setLocation() and setBounds() for usual,
     * non-embedded components.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Using usual get/setLocation() and get/setBounds() together with new
     * get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
     * For example, calling getBoundsPrivate() after setLocation() works fine,
     * but getBounds() after setBoundsPrivate() may return unpredictable value.
     * &lt;/p&gt;
     * @param x the new &lt;i&gt;x&lt;/i&gt;-coordinate relative to the parent component
     * @param y the new &lt;i&gt;y&lt;/i&gt;-coordinate relative to the parent component
     * @see java.awt.Component#setLocation
     * @see #getLocationPrivate
     * @see #setBoundsPrivate
     * @see #getBoundsPrivate
     * @since 1.5
     */
    protected void setLocationPrivate(int x, int y) {
<span class="nc" id="L390">        Dimension size = getSize();</span>
<span class="nc" id="L391">        setBoundsPrivate(x, y, size.width, size.height);</span>
<span class="nc" id="L392">    }</span>

    /**
     * Gets the location of this embedded frame as a point specifying the
     * top-left corner relative to parent component.
     * &lt;p&gt;
     * setLocation() and setBounds() for EmbeddedFrame really don't move it
     * within the native parent. These methods always put embedded frame to
     * (0, 0) for backward compatibility. To allow getting location and size
     * of embedded frame getLocationPrivate() and getBoundsPrivate() were
     * introduced, and they work just the same way as getLocation() and getBounds()
     * for ususal, non-embedded components.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Using usual get/setLocation() and get/setBounds() together with new
     * get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
     * For example, calling getBoundsPrivate() after setLocation() works fine,
     * but getBounds() after setBoundsPrivate() may return unpredictable value.
     * &lt;/p&gt;
     * @return a point indicating this embedded frame's top-left corner
     * @see java.awt.Component#getLocation
     * @see #setLocationPrivate
     * @see #setBoundsPrivate
     * @see #getBoundsPrivate
     * @since 1.6
     */
    protected Point getLocationPrivate() {
<span class="nc" id="L419">        Rectangle bounds = getBoundsPrivate();</span>
<span class="nc" id="L420">        return new Point(bounds.x, bounds.y);</span>
    }

    /**
     * Moves and resizes this embedded frame. The new location of the top-left
     * corner is specified by &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; parameters
     * relative to the native parent component. The new size is specified by
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;.
     * &lt;p&gt;
     * setLocation() and setBounds() for EmbeddedFrame really don't move it
     * within the native parent. These methods always put embedded frame to
     * (0, 0) for backward compatibility. To allow moving embedded frames
     * setLocationPrivate() and setBoundsPrivate() were introduced, and they
     * work just the same way as setLocation() and setBounds() for usual,
     * non-embedded components.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Using usual get/setLocation() and get/setBounds() together with new
     * get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
     * For example, calling getBoundsPrivate() after setLocation() works fine,
     * but getBounds() after setBoundsPrivate() may return unpredictable value.
     * &lt;/p&gt;
     * @param x the new &lt;i&gt;x&lt;/i&gt;-coordinate relative to the parent component
     * @param y the new &lt;i&gt;y&lt;/i&gt;-coordinate relative to the parent component
     * @param width the new &lt;code&gt;width&lt;/code&gt; of this embedded frame
     * @param height the new &lt;code&gt;height&lt;/code&gt; of this embedded frame
     * @see java.awt.Component#setBounds
     * @see #setLocationPrivate
     * @see #getLocationPrivate
     * @see #getBoundsPrivate
     * @since 1.5
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    protected void setBoundsPrivate(int x, int y, int width, int height) {
<span class="nc" id="L454">        final FramePeer peer = (FramePeer)getPeer();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L456">            peer.setBoundsPrivate(x, y, width, height);</span>
        }
<span class="nc" id="L458">    }</span>

    /**
     * Gets the bounds of this embedded frame as a rectangle specifying the
     * width, height and location relative to the native parent component.
     * &lt;p&gt;
     * setLocation() and setBounds() for EmbeddedFrame really don't move it
     * within the native parent. These methods always put embedded frame to
     * (0, 0) for backward compatibility. To allow getting location and size
     * of embedded frames getLocationPrivate() and getBoundsPrivate() were
     * introduced, and they work just the same way as getLocation() and getBounds()
     * for ususal, non-embedded components.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Using usual get/setLocation() and get/setBounds() together with new
     * get/setLocationPrivate() and get/setBoundsPrivate() is not recommended.
     * For example, calling getBoundsPrivate() after setLocation() works fine,
     * but getBounds() after setBoundsPrivate() may return unpredictable value.
     * &lt;/p&gt;
     * @return a rectangle indicating this embedded frame's bounds
     * @see java.awt.Component#getBounds
     * @see #setLocationPrivate
     * @see #getLocationPrivate
     * @see #setBoundsPrivate
     * @since 1.6
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    protected Rectangle getBoundsPrivate() {
<span class="nc" id="L486">        final FramePeer peer = (FramePeer)getPeer();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (peer != null) {</span>
<span class="nc" id="L488">            return peer.getBoundsPrivate();</span>
        }
        else {
<span class="nc" id="L491">            return getBounds();</span>
        }
    }

<span class="nc" id="L495">    public void toFront() {}</span>
<span class="nc" id="L496">    public void toBack() {}</span>

    public abstract void registerAccelerator(AWTKeyStroke stroke);
    public abstract void unregisterAccelerator(AWTKeyStroke stroke);

    /**
     * Checks if the component is in an EmbeddedFrame. If so,
     * returns the applet found in the hierarchy or null if
     * not found.
     * @return the parent applet or {@ null}
     * @since 1.6
     */
    public static Applet getAppletIfAncestorOf(Component comp) {
<span class="nc" id="L509">        Container parent = comp.getParent();</span>
<span class="nc" id="L510">        Applet applet = null;</span>
<span class="nc bnc" id="L511" title="All 4 branches missed.">        while (parent != null &amp;&amp; !(parent instanceof EmbeddedFrame)) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (parent instanceof Applet) {</span>
<span class="nc" id="L513">                applet = (Applet)parent;</span>
            }
<span class="nc" id="L515">            parent = parent.getParent();</span>
        }
<span class="nc bnc" id="L517" title="All 2 branches missed.">        return parent == null ? null : applet;</span>
    }

    /**
     * This method should be overriden in subclasses. It is
     * called when window this frame is within should be blocked
     * by some modal dialog.
     */
    public void notifyModalBlocked(Dialog blocker, boolean blocked) {
<span class="nc" id="L526">    }</span>

<span class="nc" id="L528">    private static class NullEmbeddedFramePeer</span>
        extends NullComponentPeer implements FramePeer {
<span class="nc" id="L530">        public void setTitle(String title) {}</span>
<span class="nc" id="L531">        public void setIconImage(Image im) {}</span>
<span class="nc" id="L532">        public void updateIconImages() {}</span>
<span class="nc" id="L533">        public void setMenuBar(MenuBar mb) {}</span>
<span class="nc" id="L534">        public void setResizable(boolean resizeable) {}</span>
<span class="nc" id="L535">        public void setState(int state) {}</span>
<span class="nc" id="L536">        public int getState() { return Frame.NORMAL; }</span>
<span class="nc" id="L537">        public void setMaximizedBounds(Rectangle b) {}</span>
<span class="nc" id="L538">        public void toFront() {}</span>
<span class="nc" id="L539">        public void toBack() {}</span>
<span class="nc" id="L540">        public void updateFocusableWindowState() {}</span>
<span class="nc" id="L541">        public void updateAlwaysOnTop() {}</span>
<span class="nc" id="L542">        public void updateAlwaysOnTopState() {}</span>
<span class="nc" id="L543">        public Component getGlobalHeavyweightFocusOwner() { return null; }</span>
        public void setBoundsPrivate(int x, int y, int width, int height) {
<span class="nc" id="L545">            setBounds(x, y, width, height, SET_BOUNDS);</span>
<span class="nc" id="L546">        }</span>
        public Rectangle getBoundsPrivate() {
<span class="nc" id="L548">            return getBounds();</span>
        }
<span class="nc" id="L550">        public void setModalBlocked(Dialog blocker, boolean blocked) {}</span>

        /**
         * @see java.awt.peer.ContainerPeer#restack
         */
        public void restack() {
<span class="nc" id="L556">            throw new UnsupportedOperationException();</span>
        }

        /**
         * @see java.awt.peer.ContainerPeer#isRestackSupported
         */
        public boolean isRestackSupported() {
<span class="nc" id="L563">            return false;</span>
        }
        public boolean requestWindowFocus() {
<span class="nc" id="L566">            return false;</span>
        }
        public void updateMinimumSize() {
<span class="nc" id="L569">        }</span>

        public void setOpacity(float opacity) {
<span class="nc" id="L572">        }</span>

        public void setOpaque(boolean isOpaque) {
<span class="nc" id="L575">        }</span>

        public void updateWindow() {
<span class="nc" id="L578">        }</span>

        public void repositionSecurityWarning() {
<span class="nc" id="L581">        }</span>

        public void emulateActivation(boolean activate) {
<span class="nc" id="L584">        }</span>
    }
} // class EmbeddedFrame
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>