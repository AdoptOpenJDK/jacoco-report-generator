<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RepaintArea.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt</a> &gt; <span class="el_source">RepaintArea.java</span></div><h1>RepaintArea.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.PaintEvent;

/**
 * The &lt;code&gt;RepaintArea&lt;/code&gt; is a geometric construct created for the
 * purpose of holding the geometry of several coalesced paint events.
 * This geometry is accessed synchronously, although it is written such
 * that painting may still be executed asynchronously.
 *
 * @author      Eric Hawkes
 * @since       1.3
 */
public class RepaintArea {

    /**
     * Maximum ratio of bounding rectangle to benefit for which
     * both the vertical and horizontal unions are repainted.
     * For smaller ratios the whole bounding rectangle is repainted.
     * @see #paint
     */
    private static final int MAX_BENEFIT_RATIO = 4;

    private static final int HORIZONTAL = 0;
    private static final int VERTICAL = 1;
    private static final int UPDATE = 2;

    private static final int RECT_COUNT = UPDATE + 1;

<span class="nc" id="L58">    private Rectangle paintRects[] = new Rectangle[RECT_COUNT];</span>


    /**
     * Constructs a new &lt;code&gt;RepaintArea&lt;/code&gt;
     * @since   1.3
     */
<span class="nc" id="L65">    public RepaintArea() {</span>
<span class="nc" id="L66">    }</span>

    /**
     * Constructs a new &lt;code&gt;RepaintArea&lt;/code&gt; initialized to match
     * the values of the specified RepaintArea.
     *
     * @param   ra  the &lt;code&gt;RepaintArea&lt;/code&gt; from which to copy initial
     *              values to a newly constructed RepaintArea
     * @since   1.3
     */
<span class="nc" id="L76">    private RepaintArea(RepaintArea ra) {</span>
        // This constructor is private because it should only be called
        // from the cloneAndReset method
<span class="nc bnc" id="L79" title="All 2 branches missed.">        for (int i = 0; i &lt; RECT_COUNT; i++) {</span>
<span class="nc" id="L80">            paintRects[i] = ra.paintRects[i];</span>
        }
<span class="nc" id="L82">    }</span>

    /**
     * Adds a &lt;code&gt;Rectangle&lt;/code&gt; to this &lt;code&gt;RepaintArea&lt;/code&gt;.
     * PAINT Rectangles are divided into mostly vertical and mostly horizontal.
     * Each group is unioned together.
     * UPDATE Rectangles are unioned.
     *
     * @param   r   the specified &lt;code&gt;Rectangle&lt;/code&gt;
     * @param   id  possible values PaintEvent.UPDATE or PaintEvent.PAINT
     * @since   1.3
     */
    public synchronized void add(Rectangle r, int id) {
        // Make sure this new rectangle has positive dimensions
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (r.isEmpty()) {</span>
<span class="nc" id="L97">            return;</span>
        }
<span class="nc" id="L99">        int addTo = UPDATE;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (id == PaintEvent.PAINT) {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            addTo = (r.width &gt; r.height) ? HORIZONTAL : VERTICAL;</span>
        }
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (paintRects[addTo] != null) {</span>
<span class="nc" id="L104">            paintRects[addTo].add(r);</span>
        } else {
<span class="nc" id="L106">            paintRects[addTo] = new Rectangle(r);</span>
        }
<span class="nc" id="L108">    }</span>


    /**
     * Creates a new &lt;code&gt;RepaintArea&lt;/code&gt; with the same geometry as this
     * RepaintArea, then removes all of the geometry from this
     * RepaintArea and restores it to an empty RepaintArea.
     *
     * @return  ra a new &lt;code&gt;RepaintArea&lt;/code&gt; having the same geometry as
     *          this RepaintArea.
     * @since   1.3
     */
    private synchronized RepaintArea cloneAndReset() {
<span class="nc" id="L121">        RepaintArea ra = new RepaintArea(this);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (int i = 0; i &lt; RECT_COUNT; i++) {</span>
<span class="nc" id="L123">            paintRects[i] = null;</span>
        }
<span class="nc" id="L125">        return ra;</span>
    }

    public boolean isEmpty() {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (int i = 0; i &lt; RECT_COUNT; i++) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (paintRects[i] != null) {</span>
<span class="nc" id="L131">                return false;</span>
            }
        }
<span class="nc" id="L134">        return true;</span>
    }

    /**
     * Constrains the size of the repaint area to the passed in bounds.
     */
    public synchronized void constrain(int x, int y, int w, int h) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (int i = 0; i &lt; RECT_COUNT; i++) {</span>
<span class="nc" id="L142">            Rectangle rect = paintRects[i];</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (rect != null) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                if (rect.x &lt; x) {</span>
<span class="nc" id="L145">                    rect.width -= (x - rect.x);</span>
<span class="nc" id="L146">                    rect.x = x;</span>
                }
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (rect.y &lt; y) {</span>
<span class="nc" id="L149">                    rect.height -= (y - rect.y);</span>
<span class="nc" id="L150">                    rect.y = y;</span>
                }
<span class="nc" id="L152">                int xDelta = rect.x + rect.width - x - w;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if (xDelta &gt; 0) {</span>
<span class="nc" id="L154">                    rect.width -= xDelta;</span>
                }
<span class="nc" id="L156">                int yDelta = rect.y + rect.height - y - h;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (yDelta &gt; 0) {</span>
<span class="nc" id="L158">                    rect.height -= yDelta;</span>
                }
<span class="nc bnc" id="L160" title="All 4 branches missed.">                if (rect.width &lt;= 0 || rect.height &lt;= 0) {</span>
<span class="nc" id="L161">                    paintRects[i] = null;</span>
                }
            }
        }
<span class="nc" id="L165">    }</span>

    /**
     * Marks the passed in region as not needing to be painted. It's possible
     * this will do nothing.
     */
    public synchronized void subtract(int x, int y, int w, int h) {
<span class="nc" id="L172">        Rectangle subtract = new Rectangle(x, y, w, h);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (int i = 0; i &lt; RECT_COUNT; i++) {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (subtract(paintRects[i], subtract)) {</span>
<span class="nc bnc" id="L175" title="All 4 branches missed.">                if (paintRects[i] != null &amp;&amp; paintRects[i].isEmpty()) {</span>
<span class="nc" id="L176">                    paintRects[i] = null;</span>
                }
            }
        }
<span class="nc" id="L180">    }</span>

    /**
     * Invokes paint and update on target Component with optimal
     * rectangular clip region.
     * If PAINT bounding rectangle is less than
     * MAX_BENEFIT_RATIO times the benefit, then the vertical and horizontal unions are
     * painted separately.  Otherwise the entire bounding rectangle is painted.
     *
     * @param   target Component to &lt;code&gt;paint&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt;
     * @since   1.4
     */
    public void paint(Object target, boolean shouldClearRectBeforePaint) {
<span class="nc" id="L193">        Component comp = (Component)target;</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (isEmpty()) {</span>
<span class="nc" id="L196">            return;</span>
        }

<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (!comp.isVisible()) {</span>
<span class="nc" id="L200">            return;</span>
        }

<span class="nc" id="L203">        RepaintArea ra = this.cloneAndReset();</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (!subtract(ra.paintRects[VERTICAL], ra.paintRects[HORIZONTAL])) {</span>
<span class="nc" id="L206">            subtract(ra.paintRects[HORIZONTAL], ra.paintRects[VERTICAL]);</span>
        }

<span class="nc bnc" id="L209" title="All 4 branches missed.">        if (ra.paintRects[HORIZONTAL] != null &amp;&amp; ra.paintRects[VERTICAL] != null) {</span>
<span class="nc" id="L210">            Rectangle paintRect = ra.paintRects[HORIZONTAL].union(ra.paintRects[VERTICAL]);</span>
<span class="nc" id="L211">            int square = paintRect.width * paintRect.height;</span>
<span class="nc" id="L212">            int benefit = square - ra.paintRects[HORIZONTAL].width</span>
                * ra.paintRects[HORIZONTAL].height - ra.paintRects[VERTICAL].width
                * ra.paintRects[VERTICAL].height;
            // if benefit is comparable with bounding box
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (MAX_BENEFIT_RATIO * benefit &lt; square) {</span>
<span class="nc" id="L217">                ra.paintRects[HORIZONTAL] = paintRect;</span>
<span class="nc" id="L218">                ra.paintRects[VERTICAL] = null;</span>
            }
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        for (int i = 0; i &lt; paintRects.length; i++) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (ra.paintRects[i] != null</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                &amp;&amp; !ra.paintRects[i].isEmpty())</span>
            {
                // Should use separate Graphics for each paint() call,
                // since paint() can change Graphics state for next call.
<span class="nc" id="L227">                Graphics g = comp.getGraphics();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (g != null) {</span>
                    try {
<span class="nc" id="L230">                        g.setClip(ra.paintRects[i]);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                        if (i == UPDATE) {</span>
<span class="nc" id="L232">                            updateComponent(comp, g);</span>
                        } else {
<span class="nc bnc" id="L234" title="All 2 branches missed.">                            if (shouldClearRectBeforePaint) {</span>
<span class="nc" id="L235">                                g.clearRect( ra.paintRects[i].x,</span>
                                             ra.paintRects[i].y,
                                             ra.paintRects[i].width,
                                             ra.paintRects[i].height);
                            }
<span class="nc" id="L240">                            paintComponent(comp, g);</span>
                        }
                    } finally {
<span class="nc" id="L243">                        g.dispose();</span>
<span class="nc" id="L244">                    }</span>
                }
            }
        }
<span class="nc" id="L248">    }</span>

    /**
     * Calls &lt;code&gt;Component.update(Graphics)&lt;/code&gt; with given Graphics.
     */
    protected void updateComponent(Component comp, Graphics g) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (comp != null) {</span>
<span class="nc" id="L255">            comp.update(g);</span>
        }
<span class="nc" id="L257">    }</span>

    /**
     * Calls &lt;code&gt;Component.paint(Graphics)&lt;/code&gt; with given Graphics.
     */
    protected void paintComponent(Component comp, Graphics g) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (comp != null) {</span>
<span class="nc" id="L264">            comp.paint(g);</span>
        }
<span class="nc" id="L266">    }</span>

    /**
     * Subtracts subtr from rect. If the result is rectangle
     * changes rect and returns true. Otherwise false.
     */
    static boolean subtract(Rectangle rect, Rectangle subtr) {
<span class="nc bnc" id="L273" title="All 4 branches missed.">        if (rect == null || subtr == null) {</span>
<span class="nc" id="L274">            return true;</span>
        }
<span class="nc" id="L276">        Rectangle common = rect.intersection(subtr);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (common.isEmpty()) {</span>
<span class="nc" id="L278">            return true;</span>
        }
<span class="nc bnc" id="L280" title="All 4 branches missed.">        if (rect.x == common.x &amp;&amp; rect.y == common.y) {</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            if (rect.width == common.width) {</span>
<span class="nc" id="L282">                rect.y += common.height;</span>
<span class="nc" id="L283">                rect.height -= common.height;</span>
<span class="nc" id="L284">                return true;</span>
            } else
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (rect.height == common.height) {</span>
<span class="nc" id="L287">                rect.x += common.width;</span>
<span class="nc" id="L288">                rect.width -= common.width;</span>
<span class="nc" id="L289">                return true;</span>
            }
        } else
<span class="nc bnc" id="L292" title="All 4 branches missed.">        if (rect.x + rect.width == common.x + common.width</span>
            &amp;&amp; rect.y + rect.height == common.y + common.height)
        {
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (rect.width == common.width) {</span>
<span class="nc" id="L296">                rect.height -= common.height;</span>
<span class="nc" id="L297">                return true;</span>
            } else
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (rect.height == common.height) {</span>
<span class="nc" id="L300">                rect.width -= common.width;</span>
<span class="nc" id="L301">                return true;</span>
            }
        }
<span class="nc" id="L304">        return false;</span>
    }

    public String toString() {
<span class="nc" id="L308">        return super.toString() + &quot;[ horizontal=&quot; + paintRects[0] +</span>
            &quot; vertical=&quot; + paintRects[1] +
            &quot; update=&quot; + paintRects[2] + &quot;]&quot;;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>