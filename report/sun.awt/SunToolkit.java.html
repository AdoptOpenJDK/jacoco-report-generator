<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SunToolkit.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt</a> &gt; <span class="el_source">SunToolkit.java</span></div><h1>SunToolkit.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt;

import java.awt.*;
import static java.awt.RenderingHints.*;
import java.awt.dnd.*;
import java.awt.dnd.peer.DragSourceContextPeer;
import java.awt.peer.*;
import java.awt.event.WindowEvent;
import java.awt.event.KeyEvent;
import java.awt.image.*;
import java.awt.TrayIcon;
import java.awt.SystemTray;
import java.awt.event.InputEvent;
import java.net.URL;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import sun.security.util.SecurityConstants;
import sun.util.logging.PlatformLogger;
import sun.misc.SoftCache;
import sun.font.FontDesignMetrics;
import sun.awt.im.InputContext;
import sun.awt.image.*;
import sun.security.action.GetPropertyAction;
import sun.security.action.GetBooleanAction;
import java.lang.reflect.InvocationTargetException;
import java.security.AccessController;

<span class="pc bpc" id="L57" title="1 of 2 branches missed.">public abstract class SunToolkit extends Toolkit</span>
    implements WindowClosingSupport, WindowClosingListener,
    ComponentFactory, InputMethodSupport, KeyboardFocusManagerPeerProvider {

    // 8014718: logging has been removed from SunToolkit

    /* Load debug settings for native code */
    static {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.nativedebug&quot;))) {</span>
<span class="nc" id="L66">            DebugSettings.init();</span>
        }
    };

    /**
     * Special mask for the UngrabEvent events, in addition to the
     * public masks defined in AWTEvent.  Should be used as the mask
     * value for Toolkit.addAWTEventListener.
     */
    public static final int GRAB_EVENT_MASK = 0x80000000;

    /* The key to put()/get() the PostEventQueue into/from the AppContext.
     */
    private static final String POST_EVENT_QUEUE_KEY = &quot;PostEventQueue&quot;;

    /**
     * Number of buttons.
     * By default it's taken from the system. If system value does not
     * fit into int type range, use our own MAX_BUTTONS_SUPPORT value.
     */
<span class="fc" id="L86">    protected static int numberOfButtons = 0;</span>


    /* XFree standard mention 24 buttons as maximum:
     * http://www.xfree86.org/current/mouse.4.html
     * We workaround systems supporting more than 24 buttons.
     * Otherwise, we have to use long type values as masks
     * which leads to API change.
     * InputEvent.BUTTON_DOWN_MASK may contain only 21 masks due to
     * the 4-bytes limit for the int type. (CR 6799099)
     * One more bit is reserved for FIRST_HIGH_BIT.
     */
    public final static int MAX_BUTTONS_SUPPORTED = 20;

    /**
     * Creates and initializes EventQueue instance for the specified
     * AppContext.
     * Note that event queue must be created from createNewAppContext()
     * only in order to ensure that EventQueue constructor obtains
     * the correct AppContext.
     * @param appContext AppContext to associate with the event queue
     */
    private static void initEQ(AppContext appContext) {
        EventQueue eventQueue;

<span class="fc" id="L111">        String eqName = System.getProperty(&quot;AWT.EventQueueClass&quot;,</span>
                &quot;java.awt.EventQueue&quot;);

        try {
<span class="fc" id="L115">            eventQueue = (EventQueue)Class.forName(eqName).newInstance();</span>
<span class="nc" id="L116">        } catch (Exception e) {</span>
<span class="nc" id="L117">            e.printStackTrace();</span>
<span class="nc" id="L118">            System.err.println(&quot;Failed loading &quot; + eqName + &quot;: &quot; + e);</span>
<span class="nc" id="L119">            eventQueue = new EventQueue();</span>
<span class="fc" id="L120">        }</span>
<span class="fc" id="L121">        appContext.put(AppContext.EVENT_QUEUE_KEY, eventQueue);</span>

<span class="fc" id="L123">        PostEventQueue postEventQueue = new PostEventQueue(eventQueue);</span>
<span class="fc" id="L124">        appContext.put(POST_EVENT_QUEUE_KEY, postEventQueue);</span>
<span class="fc" id="L125">    }</span>

<span class="fc" id="L127">    public SunToolkit() {</span>
<span class="fc" id="L128">    }</span>

    public boolean useBufferPerWindow() {
<span class="nc" id="L131">        return false;</span>
    }

    public abstract WindowPeer createWindow(Window target)
        throws HeadlessException;

    public abstract FramePeer createFrame(Frame target)
        throws HeadlessException;

    public abstract FramePeer createLightweightFrame(LightweightFrame target)
        throws HeadlessException;

    public abstract DialogPeer createDialog(Dialog target)
        throws HeadlessException;

    public abstract ButtonPeer createButton(Button target)
        throws HeadlessException;

    public abstract TextFieldPeer createTextField(TextField target)
        throws HeadlessException;

    public abstract ChoicePeer createChoice(Choice target)
        throws HeadlessException;

    public abstract LabelPeer createLabel(Label target)
        throws HeadlessException;

    public abstract ListPeer createList(java.awt.List target)
        throws HeadlessException;

    public abstract CheckboxPeer createCheckbox(Checkbox target)
        throws HeadlessException;

    public abstract ScrollbarPeer createScrollbar(Scrollbar target)
        throws HeadlessException;

    public abstract ScrollPanePeer createScrollPane(ScrollPane target)
        throws HeadlessException;

    public abstract TextAreaPeer createTextArea(TextArea target)
        throws HeadlessException;

    public abstract FileDialogPeer createFileDialog(FileDialog target)
        throws HeadlessException;

    public abstract MenuBarPeer createMenuBar(MenuBar target)
        throws HeadlessException;

    public abstract MenuPeer createMenu(Menu target)
        throws HeadlessException;

    public abstract PopupMenuPeer createPopupMenu(PopupMenu target)
        throws HeadlessException;

    public abstract MenuItemPeer createMenuItem(MenuItem target)
        throws HeadlessException;

    public abstract CheckboxMenuItemPeer createCheckboxMenuItem(
        CheckboxMenuItem target)
        throws HeadlessException;

    public abstract DragSourceContextPeer createDragSourceContextPeer(
        DragGestureEvent dge)
        throws InvalidDnDOperationException;

    public abstract TrayIconPeer createTrayIcon(TrayIcon target)
        throws HeadlessException, AWTException;

    public abstract SystemTrayPeer createSystemTray(SystemTray target);

    public abstract boolean isTraySupported();

    @SuppressWarnings(&quot;deprecation&quot;)
    public abstract FontPeer getFontPeer(String name, int style);

    public abstract RobotPeer createRobot(Robot target, GraphicsDevice screen)
        throws AWTException;

    public abstract KeyboardFocusManagerPeer getKeyboardFocusManagerPeer()
        throws HeadlessException;

    /**
     * The AWT lock is typically only used on Unix platforms to synchronize
     * access to Xlib, OpenGL, etc.  However, these methods are implemented
     * in SunToolkit so that they can be called from shared code (e.g.
     * from the OGL pipeline) or from the X11 pipeline regardless of whether
     * XToolkit or MToolkit is currently in use.  There are native macros
     * (such as AWT_LOCK) defined in awt.h, so if the implementation of these
     * methods is changed, make sure it is compatible with the native macros.
     *
     * Note: The following methods (awtLock(), awtUnlock(), etc) should be
     * used in place of:
     *     synchronized (getAWTLock()) {
     *         ...
     *     }
     *
     * By factoring these methods out specially, we are able to change the
     * implementation of these methods (e.g. use more advanced locking
     * mechanisms) without impacting calling code.
     *
     * Sample usage:
     *     private void doStuffWithXlib() {
     *         assert !SunToolkit.isAWTLockHeldByCurrentThread();
     *         SunToolkit.awtLock();
     *         try {
     *             ...
     *             XlibWrapper.XDoStuff();
     *         } finally {
     *             SunToolkit.awtUnlock();
     *         }
     *     }
     */

<span class="fc" id="L244">    private static final ReentrantLock AWT_LOCK = new ReentrantLock();</span>
<span class="fc" id="L245">    private static final Condition AWT_LOCK_COND = AWT_LOCK.newCondition();</span>

    public static final void awtLock() {
<span class="nc" id="L248">        AWT_LOCK.lock();</span>
<span class="nc" id="L249">    }</span>

    public static final boolean awtTryLock() {
<span class="nc" id="L252">        return AWT_LOCK.tryLock();</span>
    }

    public static final void awtUnlock() {
<span class="nc" id="L256">        AWT_LOCK.unlock();</span>
<span class="nc" id="L257">    }</span>

    public static final void awtLockWait()
        throws InterruptedException
    {
<span class="nc" id="L262">        AWT_LOCK_COND.await();</span>
<span class="nc" id="L263">    }</span>

    public static final void awtLockWait(long timeout)
        throws InterruptedException
    {
<span class="nc" id="L268">        AWT_LOCK_COND.await(timeout, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L269">    }</span>

    public static final void awtLockNotify() {
<span class="nc" id="L272">        AWT_LOCK_COND.signal();</span>
<span class="nc" id="L273">    }</span>

    public static final void awtLockNotifyAll() {
<span class="nc" id="L276">        AWT_LOCK_COND.signalAll();</span>
<span class="nc" id="L277">    }</span>

    public static final boolean isAWTLockHeldByCurrentThread() {
<span class="nc" id="L280">        return AWT_LOCK.isHeldByCurrentThread();</span>
    }

    /*
     * Create a new AppContext, along with its EventQueue, for a
     * new ThreadGroup.  Browser code, for example, would use this
     * method to create an AppContext &amp; EventQueue for an Applet.
     */
    public static AppContext createNewAppContext() {
<span class="fc" id="L289">        ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();</span>
<span class="fc" id="L290">        return createNewAppContext(threadGroup);</span>
    }

    static final AppContext createNewAppContext(ThreadGroup threadGroup) {
        // Create appContext before initialization of EventQueue, so all
        // the calls to AppContext.getAppContext() from EventQueue ctor
        // return correct values
<span class="fc" id="L297">        AppContext appContext = new AppContext(threadGroup);</span>
<span class="fc" id="L298">        initEQ(appContext);</span>

<span class="fc" id="L300">        return appContext;</span>
    }

    static void wakeupEventQueue(EventQueue q, boolean isShutdown){
<span class="nc" id="L304">        AWTAccessor.getEventQueueAccessor().wakeup(q, isShutdown);</span>
<span class="nc" id="L305">    }</span>

    /*
     * Fetch the peer associated with the given target (as specified
     * in the peer creation method).  This can be used to determine
     * things like what the parent peer is.  If the target is null
     * or the target can't be found (either because the a peer was
     * never created for it or the peer was disposed), a null will
     * be returned.
     */
    protected static Object targetToPeer(Object target) {
<span class="nc bnc" id="L316" title="All 4 branches missed.">        if (target != null &amp;&amp; !GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L317">            return AWTAutoShutdown.getInstance().getPeer(target);</span>
        }
<span class="nc" id="L319">        return null;</span>
    }

    protected static void targetCreatedPeer(Object target, Object peer) {
<span class="nc bnc" id="L323" title="All 4 branches missed.">        if (target != null &amp;&amp; peer != null &amp;&amp;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">            !GraphicsEnvironment.isHeadless())</span>
        {
<span class="nc" id="L326">            AWTAutoShutdown.getInstance().registerPeer(target, peer);</span>
        }
<span class="nc" id="L328">    }</span>

    protected static void targetDisposedPeer(Object target, Object peer) {
<span class="nc bnc" id="L331" title="All 4 branches missed.">        if (target != null &amp;&amp; peer != null &amp;&amp;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            !GraphicsEnvironment.isHeadless())</span>
        {
<span class="nc" id="L334">            AWTAutoShutdown.getInstance().unregisterPeer(target, peer);</span>
        }
<span class="nc" id="L336">    }</span>

    // Maps from non-Component/MenuComponent to AppContext.
    // WeakHashMap&lt;Component,AppContext&gt;
<span class="fc" id="L340">    private static final Map&lt;Object, AppContext&gt; appContextMap =</span>
<span class="fc" id="L341">        Collections.synchronizedMap(new WeakHashMap&lt;Object, AppContext&gt;());</span>

    /**
     * Sets the appContext field of target. If target is not a Component or
     * MenuComponent, this returns false.
     */
    private static boolean setAppContext(Object target,
                                         AppContext context) {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (target instanceof Component) {</span>
<span class="nc" id="L350">            AWTAccessor.getComponentAccessor().</span>
<span class="nc" id="L351">                setAppContext((Component)target, context);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        } else if (target instanceof MenuComponent) {</span>
<span class="nc" id="L353">            AWTAccessor.getMenuComponentAccessor().</span>
<span class="nc" id="L354">                setAppContext((MenuComponent)target, context);</span>
        } else {
<span class="nc" id="L356">            return false;</span>
        }
<span class="nc" id="L358">        return true;</span>
    }

    /**
     * Returns the appContext field for target. If target is not a
     * Component or MenuComponent this returns null.
     */
    private static AppContext getAppContext(Object target) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (target instanceof Component) {</span>
<span class="nc" id="L367">            return AWTAccessor.getComponentAccessor().</span>
<span class="nc" id="L368">                       getAppContext((Component)target);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        } else if (target instanceof MenuComponent) {</span>
<span class="nc" id="L370">            return AWTAccessor.getMenuComponentAccessor().</span>
<span class="nc" id="L371">                       getAppContext((MenuComponent)target);</span>
        } else {
<span class="nc" id="L373">            return null;</span>
        }
    }

    /*
     * Fetch the AppContext associated with the given target.
     * This can be used to determine things like which EventQueue
     * to use for posting events to a Component.  If the target is
     * null or the target can't be found, a null with be returned.
     */
    public static AppContext targetToAppContext(Object target) {
<span class="nc bnc" id="L384" title="All 4 branches missed.">        if (target == null || GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L385">            return null;</span>
        }
<span class="nc" id="L387">        AppContext context = getAppContext(target);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (context == null) {</span>
            // target is not a Component/MenuComponent, try the
            // appContextMap.
<span class="nc" id="L391">            context = appContextMap.get(target);</span>
        }
<span class="nc" id="L393">        return context;</span>
    }

     /**
      * Sets the synchronous status of focus requests on lightweight
      * components in the specified window to the specified value.
      * If the boolean parameter is &lt;code&gt;true&lt;/code&gt; then the focus
      * requests on lightweight components will be performed
      * synchronously, if it is &lt;code&gt;false&lt;/code&gt;, then asynchronously.
      * By default, all windows have their lightweight request status
      * set to asynchronous.
      * &lt;p&gt;
      * The application can only set the status of lightweight focus
      * requests to synchronous for any of its windows if it doesn't
      * perform focus transfers between different heavyweight containers.
      * In this case the observable focus behaviour is the same as with
      * asynchronous status.
      * &lt;p&gt;
      * If the application performs focus transfer between different
      * heavyweight containers and sets the lightweight focus request
      * status to synchronous for any of its windows, then further focus
      * behaviour is unspecified.
      * &lt;p&gt;
      * @param    w window for which the lightweight focus request status
      *             should be set
      * @param    status the value of lightweight focus request status
      */

    public static void setLWRequestStatus(Window changed,boolean status){
<span class="nc" id="L422">        AWTAccessor.getWindowAccessor().setLWRequestStatus(changed, status);</span>
<span class="nc" id="L423">    };</span>

    public static void checkAndSetPolicy(Container cont) {
        FocusTraversalPolicy defaultPolicy = KeyboardFocusManager.
<span class="nc" id="L427">            getCurrentKeyboardFocusManager().</span>
<span class="nc" id="L428">                getDefaultFocusTraversalPolicy();</span>

<span class="nc" id="L430">        cont.setFocusTraversalPolicy(defaultPolicy);</span>
<span class="nc" id="L431">    }</span>

    private static FocusTraversalPolicy createLayoutPolicy() {
<span class="nc" id="L434">        FocusTraversalPolicy policy = null;</span>
        try {
<span class="nc" id="L436">            Class&lt;?&gt; layoutPolicyClass =</span>
<span class="nc" id="L437">                Class.forName(&quot;javax.swing.LayoutFocusTraversalPolicy&quot;);</span>
<span class="nc" id="L438">            policy = (FocusTraversalPolicy)layoutPolicyClass.newInstance();</span>
        }
<span class="nc" id="L440">        catch (ClassNotFoundException e) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            assert false;</span>
        }
<span class="nc" id="L443">        catch (InstantiationException e) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            assert false;</span>
        }
<span class="nc" id="L446">        catch (IllegalAccessException e) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L448">        }</span>

<span class="nc" id="L450">        return policy;</span>
    }

    /*
     * Insert a mapping from target to AppContext, for later retrieval
     * via targetToAppContext() above.
     */
    public static void insertTargetMapping(Object target, AppContext appContext) {
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">            if (!setAppContext(target, appContext)) {</span>
                // Target is not a Component/MenuComponent, use the private Map
                // instead.
<span class="nc" id="L462">                appContextMap.put(target, appContext);</span>
            }
        }
<span class="nc" id="L465">    }</span>

    /*
     * Post an AWTEvent to the Java EventQueue, using the PostEventQueue
     * to avoid possibly calling client code (EventQueueSubclass.postEvent())
     * on the toolkit (AWT-Windows/AWT-Motif) thread.  This function should
     * not be called under another lock since it locks the EventQueue.
     * See bugids 4632918, 4526597.
     */
    public static void postEvent(AppContext appContext, AWTEvent event) {
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (event == null) {</span>
<span class="nc" id="L476">            throw new NullPointerException();</span>
        }

<span class="nc" id="L479">        AWTAccessor.SequencedEventAccessor sea = AWTAccessor.getSequencedEventAccessor();</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">        if (sea != null &amp;&amp; sea.isSequencedEvent(event)) {</span>
<span class="nc" id="L481">            AWTEvent nested = sea.getNested(event);</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">            if (nested.getID() == WindowEvent.WINDOW_LOST_FOCUS &amp;&amp;</span>
                nested instanceof TimedWindowEvent)
            {
<span class="nc" id="L485">                TimedWindowEvent twe = (TimedWindowEvent)nested;</span>
<span class="nc" id="L486">                ((SunToolkit)Toolkit.getDefaultToolkit()).</span>
<span class="nc" id="L487">                    setWindowDeactivationTime((Window)twe.getSource(), twe.getWhen());</span>
            }
        }

        // All events posted via this method are system-generated.
        // Placing the following call here reduces considerably the
        // number of places throughout the toolkit that would
        // otherwise have to be modified to precisely identify
        // system-generated events.
<span class="nc" id="L496">        setSystemGenerated(event);</span>
<span class="nc" id="L497">        AppContext eventContext = targetToAppContext(event.getSource());</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">        if (eventContext != null &amp;&amp; !eventContext.equals(appContext)) {</span>
<span class="nc" id="L499">            throw new RuntimeException(&quot;Event posted on wrong app context : &quot; + event);</span>
        }
<span class="nc" id="L501">        PostEventQueue postEventQueue =</span>
<span class="nc" id="L502">            (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (postEventQueue != null) {</span>
<span class="nc" id="L504">            postEventQueue.postEvent(event);</span>
        }
<span class="nc" id="L506">    }</span>

    /*
     * Post AWTEvent of high priority.
     */
    public static void postPriorityEvent(final AWTEvent e) {
<span class="nc" id="L512">        PeerEvent pe = new PeerEvent(Toolkit.getDefaultToolkit(), new Runnable() {</span>
                public void run() {
<span class="nc" id="L514">                    AWTAccessor.getAWTEventAccessor().setPosted(e);</span>
<span class="nc" id="L515">                    ((Component)e.getSource()).dispatchEvent(e);</span>
<span class="nc" id="L516">                }</span>
            }, PeerEvent.ULTIMATE_PRIORITY_EVENT);
<span class="nc" id="L518">        postEvent(targetToAppContext(e.getSource()), pe);</span>
<span class="nc" id="L519">    }</span>

    /*
     * Flush any pending events which haven't been posted to the AWT
     * EventQueue yet.
     */
    public static void flushPendingEvents()  {
<span class="nc" id="L526">        AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L527">        flushPendingEvents(appContext);</span>
<span class="nc" id="L528">    }</span>

    /*
     * Flush the PostEventQueue for the right AppContext.
     * The default flushPendingEvents only flushes the thread-local context,
     * which is not always correct, c.f. 3746956
     */
    public static void flushPendingEvents(AppContext appContext) {
<span class="nc" id="L536">        PostEventQueue postEventQueue =</span>
<span class="nc" id="L537">                (PostEventQueue)appContext.get(POST_EVENT_QUEUE_KEY);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (postEventQueue != null) {</span>
<span class="nc" id="L539">            postEventQueue.flush();</span>
        }
<span class="nc" id="L541">    }</span>

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Does not wait for the execution to occur before
     * returning to the caller.
     */
    public static void executeOnEventHandlerThread(Object target,
                                                   Runnable runnable) {
<span class="nc" id="L550">        executeOnEventHandlerThread(new PeerEvent(target, runnable, PeerEvent.PRIORITY_EVENT));</span>
<span class="nc" id="L551">    }</span>

    /*
     * Fixed 5064013: the InvocationEvent time should be equals
     * the time of the ActionEvent
     */
    @SuppressWarnings(&quot;serial&quot;)
    public static void executeOnEventHandlerThread(Object target,
                                                   Runnable runnable,
                                                   final long when) {
<span class="nc" id="L561">        executeOnEventHandlerThread(</span>
<span class="nc" id="L562">            new PeerEvent(target, runnable, PeerEvent.PRIORITY_EVENT) {</span>
                public long getWhen() {
<span class="nc" id="L564">                    return when;</span>
                }
            });
<span class="nc" id="L567">    }</span>

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Does not wait for the execution to occur before
     * returning to the caller.
     */
    public static void executeOnEventHandlerThread(PeerEvent peerEvent) {
<span class="nc" id="L575">        postEvent(targetToAppContext(peerEvent.getSource()), peerEvent);</span>
<span class="nc" id="L576">    }</span>

    /*
     * Execute a chunk of code on the Java event handler thread. The
     * method takes into account provided AppContext and sets
     * &lt;code&gt;SunToolkit.getDefaultToolkit()&lt;/code&gt; as a target of the
     * event. See 6451487 for detailes.
     * Does not wait for the execution to occur before returning to
     * the caller.
     */
     public static void invokeLaterOnAppContext(
        AppContext appContext, Runnable dispatcher)
     {
<span class="nc" id="L589">        postEvent(appContext,</span>
<span class="nc" id="L590">            new PeerEvent(Toolkit.getDefaultToolkit(), dispatcher,</span>
                PeerEvent.PRIORITY_EVENT));
<span class="nc" id="L592">     }</span>

    /*
     * Execute a chunk of code on the Java event handler thread for the
     * given target.  Waits for the execution to occur before returning
     * to the caller.
     */
    public static void executeOnEDTAndWait(Object target, Runnable runnable)
        throws InterruptedException, InvocationTargetException
    {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
<span class="nc" id="L603">            throw new Error(&quot;Cannot call executeOnEDTAndWait from any event dispatcher thread&quot;);</span>
        }

<span class="nc" id="L606">        class AWTInvocationLock {}</span>
<span class="nc" id="L607">        Object lock = new AWTInvocationLock();</span>

<span class="nc" id="L609">        PeerEvent event = new PeerEvent(target, runnable, lock, true, PeerEvent.PRIORITY_EVENT);</span>

<span class="nc" id="L611">        synchronized (lock) {</span>
<span class="nc" id="L612">            executeOnEventHandlerThread(event);</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">            while(!event.isDispatched()) {</span>
<span class="nc" id="L614">                lock.wait();</span>
            }
<span class="nc" id="L616">        }</span>

<span class="nc" id="L618">        Throwable eventThrowable = event.getThrowable();</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (eventThrowable != null) {</span>
<span class="nc" id="L620">            throw new InvocationTargetException(eventThrowable);</span>
        }
<span class="nc" id="L622">    }</span>

    /*
     * Returns true if the calling thread is the event dispatch thread
     * contained within AppContext which associated with the given target.
     * Use this call to ensure that a given task is being executed
     * (or not being) on the event dispatch thread for the given target.
     */
    public static boolean isDispatchThreadForAppContext(Object target) {
<span class="nc" id="L631">        AppContext appContext = targetToAppContext(target);</span>
<span class="nc" id="L632">        EventQueue eq = (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);</span>

<span class="nc" id="L634">        AWTAccessor.EventQueueAccessor accessor = AWTAccessor.getEventQueueAccessor();</span>
<span class="nc" id="L635">        return accessor.isDispatchThreadImpl(eq);</span>
    }

    public Dimension getScreenSize() {
<span class="nc" id="L639">        return new Dimension(getScreenWidth(), getScreenHeight());</span>
    }
    protected abstract int getScreenWidth();
    protected abstract int getScreenHeight();

    @SuppressWarnings(&quot;deprecation&quot;)
    public FontMetrics getFontMetrics(Font font) {
<span class="nc" id="L646">        return FontDesignMetrics.getMetrics(font);</span>
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    public String[] getFontList() {
<span class="nc" id="L651">        String[] hardwiredFontList = {</span>
            Font.DIALOG, Font.SANS_SERIF, Font.SERIF, Font.MONOSPACED,
            Font.DIALOG_INPUT

            // -- Obsolete font names from 1.0.2.  It was decided that
            // -- getFontList should not return these old names:
            //    &quot;Helvetica&quot;, &quot;TimesRoman&quot;, &quot;Courier&quot;, &quot;ZapfDingbats&quot;
        };
<span class="nc" id="L659">        return hardwiredFontList;</span>
    }

    public PanelPeer createPanel(Panel target) {
<span class="nc" id="L663">        return (PanelPeer)createComponent(target);</span>
    }

    public CanvasPeer createCanvas(Canvas target) {
<span class="nc" id="L667">        return (CanvasPeer)createComponent(target);</span>
    }

    /**
     * Disables erasing of background on the canvas before painting if
     * this is supported by the current toolkit. It is recommended to
     * call this method early, before the Canvas becomes displayable,
     * because some Toolkit implementations do not support changing
     * this property once the Canvas becomes displayable.
     */
    public void disableBackgroundErase(Canvas canvas) {
<span class="nc" id="L678">        disableBackgroundEraseImpl(canvas);</span>
<span class="nc" id="L679">    }</span>

    /**
     * Disables the native erasing of the background on the given
     * component before painting if this is supported by the current
     * toolkit. This only has an effect for certain components such as
     * Canvas, Panel and Window. It is recommended to call this method
     * early, before the Component becomes displayable, because some
     * Toolkit implementations do not support changing this property
     * once the Component becomes displayable.
     */
    public void disableBackgroundErase(Component component) {
<span class="nc" id="L691">        disableBackgroundEraseImpl(component);</span>
<span class="nc" id="L692">    }</span>

    private void disableBackgroundEraseImpl(Component component) {
<span class="nc" id="L695">        AWTAccessor.getComponentAccessor().setBackgroundEraseDisabled(component, true);</span>
<span class="nc" id="L696">    }</span>

    /**
     * Returns the value of &quot;sun.awt.noerasebackground&quot; property. Default
     * value is {@code false}.
     */
    public static boolean getSunAwtNoerasebackground() {
<span class="nc" id="L703">        return AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.noerasebackground&quot;));</span>
    }

    /**
     * Returns the value of &quot;sun.awt.erasebackgroundonresize&quot; property. Default
     * value is {@code false}.
     */
    public static boolean getSunAwtErasebackgroundonresize() {
<span class="nc" id="L711">        return AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.erasebackgroundonresize&quot;));</span>
    }


<span class="fc" id="L715">    static final SoftCache imgCache = new SoftCache();</span>

    static Image getImageFromHash(Toolkit tk, URL url) {
<span class="nc" id="L718">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (sm != null) {</span>
            try {
<span class="nc" id="L721">                java.security.Permission perm =</span>
<span class="nc" id="L722">                    url.openConnection().getPermission();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">                if (perm != null) {</span>
                    try {
<span class="nc" id="L725">                        sm.checkPermission(perm);</span>
<span class="nc" id="L726">                    } catch (SecurityException se) {</span>
                        // fallback to checkRead/checkConnect for pre 1.2
                        // security managers
<span class="nc bnc" id="L729" title="All 2 branches missed.">                        if ((perm instanceof java.io.FilePermission) &amp;&amp;</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                            perm.getActions().indexOf(&quot;read&quot;) != -1) {</span>
<span class="nc" id="L731">                            sm.checkRead(perm.getName());</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                        } else if ((perm instanceof</span>
                            java.net.SocketPermission) &amp;&amp;
<span class="nc bnc" id="L734" title="All 2 branches missed.">                            perm.getActions().indexOf(&quot;connect&quot;) != -1) {</span>
<span class="nc" id="L735">                            sm.checkConnect(url.getHost(), url.getPort());</span>
                        } else {
<span class="nc" id="L737">                            throw se;</span>
                        }
<span class="nc" id="L739">                    }</span>
                }
<span class="nc" id="L741">            } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L742">                    sm.checkConnect(url.getHost(), url.getPort());</span>
<span class="nc" id="L743">            }</span>
        }
<span class="nc" id="L745">        synchronized (imgCache) {</span>
<span class="nc" id="L746">            Image img = (Image)imgCache.get(url);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (img == null) {</span>
                try {
<span class="nc" id="L749">                    img = tk.createImage(new URLImageSource(url));</span>
<span class="nc" id="L750">                    imgCache.put(url, img);</span>
<span class="nc" id="L751">                } catch (Exception e) {</span>
<span class="nc" id="L752">                }</span>
            }
<span class="nc" id="L754">            return img;</span>
<span class="nc" id="L755">        }</span>
    }

    static Image getImageFromHash(Toolkit tk,
                                               String filename) {
<span class="nc" id="L760">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L762">            security.checkRead(filename);</span>
        }
<span class="nc" id="L764">        synchronized (imgCache) {</span>
<span class="nc" id="L765">            Image img = (Image)imgCache.get(filename);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            if (img == null) {</span>
                try {
<span class="nc" id="L768">                    img = tk.createImage(new FileImageSource(filename));</span>
<span class="nc" id="L769">                    imgCache.put(filename, img);</span>
<span class="nc" id="L770">                } catch (Exception e) {</span>
<span class="nc" id="L771">                }</span>
            }
<span class="nc" id="L773">            return img;</span>
<span class="nc" id="L774">        }</span>
    }

    public Image getImage(String filename) {
<span class="nc" id="L778">        return getImageFromHash(this, filename);</span>
    }

    public Image getImage(URL url) {
<span class="nc" id="L782">        return getImageFromHash(this, url);</span>
    }

    public Image createImage(String filename) {
<span class="nc" id="L786">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L788">            security.checkRead(filename);</span>
        }
<span class="nc" id="L790">        return createImage(new FileImageSource(filename));</span>
    }

    public Image createImage(URL url) {
<span class="nc" id="L794">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (sm != null) {</span>
            try {
<span class="nc" id="L797">                java.security.Permission perm =</span>
<span class="nc" id="L798">                    url.openConnection().getPermission();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                if (perm != null) {</span>
                    try {
<span class="nc" id="L801">                        sm.checkPermission(perm);</span>
<span class="nc" id="L802">                    } catch (SecurityException se) {</span>
                        // fallback to checkRead/checkConnect for pre 1.2
                        // security managers
<span class="nc bnc" id="L805" title="All 2 branches missed.">                        if ((perm instanceof java.io.FilePermission) &amp;&amp;</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                            perm.getActions().indexOf(&quot;read&quot;) != -1) {</span>
<span class="nc" id="L807">                            sm.checkRead(perm.getName());</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                        } else if ((perm instanceof</span>
                            java.net.SocketPermission) &amp;&amp;
<span class="nc bnc" id="L810" title="All 2 branches missed.">                            perm.getActions().indexOf(&quot;connect&quot;) != -1) {</span>
<span class="nc" id="L811">                            sm.checkConnect(url.getHost(), url.getPort());</span>
                        } else {
<span class="nc" id="L813">                            throw se;</span>
                        }
<span class="nc" id="L815">                    }</span>
                }
<span class="nc" id="L817">            } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L818">                    sm.checkConnect(url.getHost(), url.getPort());</span>
<span class="nc" id="L819">            }</span>
        }
<span class="nc" id="L821">        return createImage(new URLImageSource(url));</span>
    }

    public Image createImage(byte[] data, int offset, int length) {
<span class="nc" id="L825">        return createImage(new ByteArrayImageSource(data, offset, length));</span>
    }

    public Image createImage(ImageProducer producer) {
<span class="nc" id="L829">        return new ToolkitImage(producer);</span>
    }

    public int checkImage(Image img, int w, int h, ImageObserver o) {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L834">            return ImageObserver.ALLBITS;</span>
        }

<span class="nc" id="L837">        ToolkitImage tkimg = (ToolkitImage)img;</span>
        int repbits;
<span class="nc bnc" id="L839" title="All 4 branches missed.">        if (w == 0 || h == 0) {</span>
<span class="nc" id="L840">            repbits = ImageObserver.ALLBITS;</span>
        } else {
<span class="nc" id="L842">            repbits = tkimg.getImageRep().check(o);</span>
        }
<span class="nc" id="L844">        return tkimg.check(o) | repbits;</span>
    }

    public boolean prepareImage(Image img, int w, int h, ImageObserver o) {
<span class="nc bnc" id="L848" title="All 4 branches missed.">        if (w == 0 || h == 0) {</span>
<span class="nc" id="L849">            return true;</span>
        }

        // Must be a ToolkitImage
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L854">            return true;</span>
        }

<span class="nc" id="L857">        ToolkitImage tkimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (tkimg.hasError()) {</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (o != null) {</span>
<span class="nc" id="L860">                o.imageUpdate(img, ImageObserver.ERROR|ImageObserver.ABORT,</span>
                              -1, -1, -1, -1);
            }
<span class="nc" id="L863">            return false;</span>
        }
<span class="nc" id="L865">        ImageRepresentation ir = tkimg.getImageRep();</span>
<span class="nc" id="L866">        return ir.prepare(o);</span>
    }

    /**
     * Scans {@code imageList} for best-looking image of specified dimensions.
     * Image can be scaled and/or padded with transparency.
     */
    public static BufferedImage getScaledIconImage(java.util.List&lt;Image&gt; imageList, int width, int height) {
<span class="nc bnc" id="L874" title="All 4 branches missed.">        if (width == 0 || height == 0) {</span>
<span class="nc" id="L875">            return null;</span>
        }
<span class="nc" id="L877">        Image bestImage = null;</span>
<span class="nc" id="L878">        int bestWidth = 0;</span>
<span class="nc" id="L879">        int bestHeight = 0;</span>
<span class="nc" id="L880">        double bestSimilarity = 3; //Impossibly high value</span>
<span class="nc" id="L881">        double bestScaleFactor = 0;</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        for (Iterator&lt;Image&gt; i = imageList.iterator();i.hasNext();) {</span>
            //Iterate imageList looking for best matching image.
            //'Similarity' measure is defined as good scale factor and small insets.
            //best possible similarity is 0 (no scale, no insets).
            //It's found while the experiments that good-looking result is achieved
            //with scale factors x1, x3/4, x2/3, xN, x1/N.
<span class="nc" id="L888">            Image im = i.next();</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if (im == null) {</span>
<span class="nc" id="L890">                continue;</span>
            }
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (im instanceof ToolkitImage) {</span>
<span class="nc" id="L893">                ImageRepresentation ir = ((ToolkitImage)im).getImageRep();</span>
<span class="nc" id="L894">                ir.reconstruct(ImageObserver.ALLBITS);</span>
            }
            int iw;
            int ih;
            try {
<span class="nc" id="L899">                iw = im.getWidth(null);</span>
<span class="nc" id="L900">                ih = im.getHeight(null);</span>
<span class="nc" id="L901">            } catch (Exception e){</span>
<span class="nc" id="L902">                continue;</span>
<span class="nc" id="L903">            }</span>
<span class="nc bnc" id="L904" title="All 4 branches missed.">            if (iw &gt; 0 &amp;&amp; ih &gt; 0) {</span>
                //Calc scale factor
<span class="nc" id="L906">                double scaleFactor = Math.min((double)width / (double)iw,</span>
                                              (double)height / (double)ih);
                //Calculate scaled image dimensions
                //adjusting scale factor to nearest &quot;good&quot; value
<span class="nc" id="L910">                int adjw = 0;</span>
<span class="nc" id="L911">                int adjh = 0;</span>
<span class="nc" id="L912">                double scaleMeasure = 1; //0 - best (no) scale, 1 - impossibly bad</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                if (scaleFactor &gt;= 2) {</span>
                    //Need to enlarge image more than twice
                    //Round down scale factor to multiply by integer value
<span class="nc" id="L916">                    scaleFactor = Math.floor(scaleFactor);</span>
<span class="nc" id="L917">                    adjw = iw * (int)scaleFactor;</span>
<span class="nc" id="L918">                    adjh = ih * (int)scaleFactor;</span>
<span class="nc" id="L919">                    scaleMeasure = 1.0 - 0.5 / scaleFactor;</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                } else if (scaleFactor &gt;= 1) {</span>
                    //Don't scale
<span class="nc" id="L922">                    scaleFactor = 1.0;</span>
<span class="nc" id="L923">                    adjw = iw;</span>
<span class="nc" id="L924">                    adjh = ih;</span>
<span class="nc" id="L925">                    scaleMeasure = 0;</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                } else if (scaleFactor &gt;= 0.75) {</span>
                    //Multiply by 3/4
<span class="nc" id="L928">                    scaleFactor = 0.75;</span>
<span class="nc" id="L929">                    adjw = iw * 3 / 4;</span>
<span class="nc" id="L930">                    adjh = ih * 3 / 4;</span>
<span class="nc" id="L931">                    scaleMeasure = 0.3;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                } else if (scaleFactor &gt;= 0.6666) {</span>
                    //Multiply by 2/3
<span class="nc" id="L934">                    scaleFactor = 0.6666;</span>
<span class="nc" id="L935">                    adjw = iw * 2 / 3;</span>
<span class="nc" id="L936">                    adjh = ih * 2 / 3;</span>
<span class="nc" id="L937">                    scaleMeasure = 0.33;</span>
                } else {
                    //Multiply size by 1/scaleDivider
                    //where scaleDivider is minimum possible integer
                    //larger than 1/scaleFactor
<span class="nc" id="L942">                    double scaleDivider = Math.ceil(1.0 / scaleFactor);</span>
<span class="nc" id="L943">                    scaleFactor = 1.0 / scaleDivider;</span>
<span class="nc" id="L944">                    adjw = (int)Math.round((double)iw / scaleDivider);</span>
<span class="nc" id="L945">                    adjh = (int)Math.round((double)ih / scaleDivider);</span>
<span class="nc" id="L946">                    scaleMeasure = 1.0 - 1.0 / scaleDivider;</span>
                }
<span class="nc" id="L948">                double similarity = ((double)width - (double)adjw) / (double)width +</span>
                    ((double)height - (double)adjh) / (double)height + //Large padding is bad
                    scaleMeasure; //Large rescale is bad
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (similarity &lt; bestSimilarity) {</span>
<span class="nc" id="L952">                    bestSimilarity = similarity;</span>
<span class="nc" id="L953">                    bestScaleFactor = scaleFactor;</span>
<span class="nc" id="L954">                    bestImage = im;</span>
<span class="nc" id="L955">                    bestWidth = adjw;</span>
<span class="nc" id="L956">                    bestHeight = adjh;</span>
                }
<span class="nc bnc" id="L958" title="All 2 branches missed.">                if (similarity == 0) break;</span>
            }
<span class="nc" id="L960">        }</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (bestImage == null) {</span>
            //No images were found, possibly all are broken
<span class="nc" id="L963">            return null;</span>
        }
<span class="nc" id="L965">        BufferedImage bimage =</span>
            new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L967">        Graphics2D g = bimage.createGraphics();</span>
<span class="nc" id="L968">        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,</span>
                           RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        try {
<span class="nc" id="L971">            int x = (width - bestWidth) / 2;</span>
<span class="nc" id="L972">            int y = (height - bestHeight) / 2;</span>
<span class="nc" id="L973">            g.drawImage(bestImage, x, y, bestWidth, bestHeight, null);</span>
        } finally {
<span class="nc" id="L975">            g.dispose();</span>
<span class="nc" id="L976">        }</span>
<span class="nc" id="L977">        return bimage;</span>
    }

    public static DataBufferInt getScaledIconData(java.util.List&lt;Image&gt; imageList, int width, int height) {
<span class="nc" id="L981">        BufferedImage bimage = getScaledIconImage(imageList, width, height);</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        if (bimage == null) {</span>
<span class="nc" id="L983">            return null;</span>
        }
<span class="nc" id="L985">        Raster raster = bimage.getRaster();</span>
<span class="nc" id="L986">        DataBuffer buffer = raster.getDataBuffer();</span>
<span class="nc" id="L987">        return (DataBufferInt)buffer;</span>
    }

    protected EventQueue getSystemEventQueueImpl() {
<span class="nc" id="L991">        return getSystemEventQueueImplPP();</span>
    }

    // Package private implementation
    static EventQueue getSystemEventQueueImplPP() {
<span class="nc" id="L996">        return getSystemEventQueueImplPP(AppContext.getAppContext());</span>
    }

    public static EventQueue getSystemEventQueueImplPP(AppContext appContext) {
<span class="nc" id="L1000">        EventQueue theEventQueue =</span>
<span class="nc" id="L1001">            (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);</span>
<span class="nc" id="L1002">        return theEventQueue;</span>
    }

    /**
     * Give native peers the ability to query the native container
     * given a native component (eg the direct parent may be lightweight).
     */
    public static Container getNativeContainer(Component c) {
<span class="nc" id="L1010">        return Toolkit.getNativeContainer(c);</span>
    }

    /**
     * Gives native peers the ability to query the closest HW component.
     * If the given component is heavyweight, then it returns this. Otherwise,
     * it goes one level up in the hierarchy and tests next component.
     */
    public static Component getHeavyweightComponent(Component c) {
<span class="nc bnc" id="L1019" title="All 4 branches missed.">        while (c != null &amp;&amp; AWTAccessor.getComponentAccessor().isLightweight(c)) {</span>
<span class="nc" id="L1020">            c = AWTAccessor.getComponentAccessor().getParent(c);</span>
        }
<span class="nc" id="L1022">        return c;</span>
    }

    /**
     * Returns key modifiers used by Swing to set up a focus accelerator key stroke.
     */
    public int getFocusAcceleratorKeyMask() {
<span class="nc" id="L1029">        return InputEvent.ALT_MASK;</span>
    }

    /**
     * Tests whether specified key modifiers mask can be used to enter a printable
     * character. This is a default implementation of this method, which reflects
     * the way things work on Windows: here, pressing ctrl + alt allows user to enter
     * characters from the extended character set (like euro sign or math symbols)
     */
    public boolean isPrintableCharacterModifiersMask(int mods) {
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        return ((mods &amp; InputEvent.ALT_MASK) == (mods &amp; InputEvent.CTRL_MASK));</span>
    }

    /**
     * Returns whether popup is allowed to be shown above the task bar.
     * This is a default implementation of this method, which checks
     * corresponding security permission.
     */
    public boolean canPopupOverlapTaskBar() {
<span class="nc" id="L1048">        boolean result = true;</span>
        try {
<span class="nc" id="L1050">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L1052">                sm.checkPermission(</span>
                        SecurityConstants.AWT.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);
            }
<span class="nc" id="L1055">        } catch (SecurityException se) {</span>
            // There is no permission to show popups over the task bar
<span class="nc" id="L1057">            result = false;</span>
<span class="nc" id="L1058">        }</span>
<span class="nc" id="L1059">        return result;</span>
    }

    /**
     * Returns a new input method window, with behavior as specified in
     * {@link java.awt.im.spi.InputMethodContext#createInputMethodWindow}.
     * If the inputContext is not null, the window should return it from its
     * getInputContext() method. The window needs to implement
     * sun.awt.im.InputMethodWindow.
     * &lt;p&gt;
     * SunToolkit subclasses can override this method to return better input
     * method windows.
     */
    public Window createInputMethodWindow(String title, InputContext context) {
<span class="nc" id="L1073">        return new sun.awt.im.SimpleInputMethodWindow(title, context);</span>
    }

    /**
     * Returns whether enableInputMethods should be set to true for peered
     * TextComponent instances on this platform. False by default.
     */
    public boolean enableInputMethodsForTextComponent() {
<span class="nc" id="L1081">        return false;</span>
    }

<span class="fc" id="L1084">    private static Locale startupLocale = null;</span>

    /**
     * Returns the locale in which the runtime was started.
     */
    public static Locale getStartupLocale() {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if (startupLocale == null) {</span>
            String language, region, country, variant;
<span class="nc" id="L1092">            language = AccessController.doPrivileged(</span>
                            new GetPropertyAction(&quot;user.language&quot;, &quot;en&quot;));
            // for compatibility, check for old user.region property
<span class="nc" id="L1095">            region = AccessController.doPrivileged(</span>
                            new GetPropertyAction(&quot;user.region&quot;));
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            if (region != null) {</span>
                // region can be of form country, country_variant, or _variant
<span class="nc" id="L1099">                int i = region.indexOf('_');</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                if (i &gt;= 0) {</span>
<span class="nc" id="L1101">                    country = region.substring(0, i);</span>
<span class="nc" id="L1102">                    variant = region.substring(i + 1);</span>
                } else {
<span class="nc" id="L1104">                    country = region;</span>
<span class="nc" id="L1105">                    variant = &quot;&quot;;</span>
                }
<span class="nc" id="L1107">            } else {</span>
<span class="nc" id="L1108">                country = AccessController.doPrivileged(</span>
                                new GetPropertyAction(&quot;user.country&quot;, &quot;&quot;));
<span class="nc" id="L1110">                variant = AccessController.doPrivileged(</span>
                                new GetPropertyAction(&quot;user.variant&quot;, &quot;&quot;));
            }
<span class="nc" id="L1113">            startupLocale = new Locale(language, country, variant);</span>
        }
<span class="nc" id="L1115">        return startupLocale;</span>
    }

    /**
     * Returns the default keyboard locale of the underlying operating system
     */
    public Locale getDefaultKeyboardLocale() {
<span class="nc" id="L1122">        return getStartupLocale();</span>
    }

<span class="fc" id="L1125">    private static String dataTransfererClassName = null;</span>

    protected static void setDataTransfererClassName(String className) {
<span class="nc" id="L1128">        dataTransfererClassName = className;</span>
<span class="nc" id="L1129">    }</span>

    public static String getDataTransfererClassName() {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (dataTransfererClassName == null) {</span>
<span class="nc" id="L1133">            Toolkit.getDefaultToolkit(); // transferer set during toolkit init</span>
        }
<span class="nc" id="L1135">        return dataTransfererClassName;</span>
    }

    // Support for window closing event notifications
<span class="fc" id="L1139">    private transient WindowClosingListener windowClosingListener = null;</span>
    /**
     * @see sun.awt.WindowClosingSupport#getWindowClosingListener
     */
    public WindowClosingListener getWindowClosingListener() {
<span class="nc" id="L1144">        return windowClosingListener;</span>
    }
    /**
     * @see sun.awt.WindowClosingSupport#setWindowClosingListener
     */
    public void setWindowClosingListener(WindowClosingListener wcl) {
<span class="nc" id="L1150">        windowClosingListener = wcl;</span>
<span class="nc" id="L1151">    }</span>

    /**
     * @see sun.awt.WindowClosingListener#windowClosingNotify
     */
    public RuntimeException windowClosingNotify(WindowEvent event) {
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (windowClosingListener != null) {</span>
<span class="nc" id="L1158">            return windowClosingListener.windowClosingNotify(event);</span>
        } else {
<span class="nc" id="L1160">            return null;</span>
        }
    }
    /**
     * @see sun.awt.WindowClosingListener#windowClosingDelivered
     */
    public RuntimeException windowClosingDelivered(WindowEvent event) {
<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (windowClosingListener != null) {</span>
<span class="nc" id="L1168">            return windowClosingListener.windowClosingDelivered(event);</span>
        } else {
<span class="nc" id="L1170">            return null;</span>
        }
    }

<span class="fc" id="L1174">    private static DefaultMouseInfoPeer mPeer = null;</span>

    protected synchronized MouseInfoPeer getMouseInfoPeer() {
<span class="nc bnc" id="L1177" title="All 2 branches missed.">        if (mPeer == null) {</span>
<span class="nc" id="L1178">            mPeer = new DefaultMouseInfoPeer();</span>
        }
<span class="nc" id="L1180">        return mPeer;</span>
    }


    /**
     * Returns whether default toolkit needs the support of the xembed
     * from embedding host(if any).
     * @return &lt;code&gt;true&lt;/code&gt;, if XEmbed is needed, &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public static boolean needsXEmbed() {
<span class="nc" id="L1190">        String noxembed = AccessController.</span>
<span class="nc" id="L1191">            doPrivileged(new GetPropertyAction(&quot;sun.awt.noxembed&quot;, &quot;false&quot;));</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        if (&quot;true&quot;.equals(noxembed)) {</span>
<span class="nc" id="L1193">            return false;</span>
        }

<span class="nc" id="L1196">        Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (tk instanceof SunToolkit) {</span>
            // SunToolkit descendants should override this method to specify
            // concrete behavior
<span class="nc" id="L1200">            return ((SunToolkit)tk).needsXEmbedImpl();</span>
        } else {
            // Non-SunToolkit doubtly might support XEmbed
<span class="nc" id="L1203">            return false;</span>
        }
    }

    /**
     * Returns whether this toolkit needs the support of the xembed
     * from embedding host(if any).
     * @return &lt;code&gt;true&lt;/code&gt;, if XEmbed is needed, &lt;code&gt;false&lt;/code&gt; otherwise
     */
    protected boolean needsXEmbedImpl() {
<span class="nc" id="L1213">        return false;</span>
    }

<span class="fc" id="L1216">    private static Dialog.ModalExclusionType DEFAULT_MODAL_EXCLUSION_TYPE = null;</span>

    /**
     * Returns whether the XEmbed server feature is requested by
     * developer.  If true, Toolkit should return an
     * XEmbed-server-enabled CanvasPeer instead of the ordinary CanvasPeer.
     */
    protected final boolean isXEmbedServerRequested() {
<span class="nc" id="L1224">        return AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.xembedserver&quot;));</span>
    }

    /**
     * Returns whether the modal exclusion API is supported by the current toolkit.
     * When it isn't supported, calling &lt;code&gt;setModalExcluded&lt;/code&gt; has no
     * effect, and &lt;code&gt;isModalExcluded&lt;/code&gt; returns false for all windows.
     *
     * @return true if modal exclusion is supported by the toolkit, false otherwise
     *
     * @see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
     * @see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)
     *
     * @since 1.5
     */
    public static boolean isModalExcludedSupported()
    {
<span class="nc" id="L1241">        Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L1242">        return tk.isModalExclusionTypeSupported(DEFAULT_MODAL_EXCLUSION_TYPE);</span>
    }
    /*
     * Default implementation for isModalExcludedSupportedImpl(), returns false.
     *
     * @see sun.awt.windows.WToolkit#isModalExcludeSupportedImpl
     * @see sun.awt.X11.XToolkit#isModalExcludeSupportedImpl
     *
     * @since 1.5
     */
    protected boolean isModalExcludedSupportedImpl()
    {
<span class="nc" id="L1254">        return false;</span>
    }

    /*
     * Sets this window to be excluded from being modally blocked. When the
     * toolkit supports modal exclusion and this method is called, input
     * events, focus transfer and z-order will continue to work for the
     * window, it's owned windows and child components, even in the
     * presence of a modal dialog.
     * For details on which &lt;code&gt;Window&lt;/code&gt;s are normally blocked
     * by modal dialog, see {@link java.awt.Dialog}.
     * Invoking this method when the modal exclusion API is not supported by
     * the current toolkit has no effect.
     * @param window Window to be marked as not modally blocked
     * @see java.awt.Dialog
     * @see java.awt.Dialog#setModal(boolean)
     * @see sun.awt.SunToolkit#isModalExcludedSupported
     * @see sun.awt.SunToolkit#isModalExcluded(java.awt.Window)
     */
    public static void setModalExcluded(Window window)
    {
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (DEFAULT_MODAL_EXCLUSION_TYPE == null) {</span>
<span class="nc" id="L1276">            DEFAULT_MODAL_EXCLUSION_TYPE = Dialog.ModalExclusionType.APPLICATION_EXCLUDE;</span>
        }
<span class="nc" id="L1278">        window.setModalExclusionType(DEFAULT_MODAL_EXCLUSION_TYPE);</span>
<span class="nc" id="L1279">    }</span>

    /*
     * Returns whether the specified window is blocked by modal dialogs.
     * If the modal exclusion API isn't supported by the current toolkit,
     * it returns false for all windows.
     *
     * @param window Window to test for modal exclusion
     *
     * @return true if the window is modal excluded, false otherwise. If
     * the modal exclusion isn't supported by the current Toolkit, false
     * is returned
     *
     * @see sun.awt.SunToolkit#isModalExcludedSupported
     * @see sun.awt.SunToolkit#setModalExcluded(java.awt.Window)
     *
     * @since 1.5
     */
    public static boolean isModalExcluded(Window window)
    {
<span class="nc bnc" id="L1299" title="All 2 branches missed.">        if (DEFAULT_MODAL_EXCLUSION_TYPE == null) {</span>
<span class="nc" id="L1300">            DEFAULT_MODAL_EXCLUSION_TYPE = Dialog.ModalExclusionType.APPLICATION_EXCLUDE;</span>
        }
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        return window.getModalExclusionType().compareTo(DEFAULT_MODAL_EXCLUSION_TYPE) &gt;= 0;</span>
    }

    /**
     * Overridden in XToolkit and WToolkit
     */
    public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
<span class="nc bnc" id="L1309" title="All 4 branches missed.">        return (modalityType == Dialog.ModalityType.MODELESS) ||</span>
               (modalityType == Dialog.ModalityType.APPLICATION_MODAL);
    }

    /**
     * Overridden in XToolkit and WToolkit
     */
    public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        return (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE);</span>
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // The following is used by the Java Plug-in to coordinate dialog modality
    // between containing applications (browsers, ActiveX containers etc) and
    // the AWT.
    //
    ///////////////////////////////////////////////////////////////////////////

<span class="fc" id="L1328">    private ModalityListenerList modalityListeners = new ModalityListenerList();</span>

    public void addModalityListener(ModalityListener listener) {
<span class="nc" id="L1331">        modalityListeners.add(listener);</span>
<span class="nc" id="L1332">    }</span>

    public void removeModalityListener(ModalityListener listener) {
<span class="nc" id="L1335">        modalityListeners.remove(listener);</span>
<span class="nc" id="L1336">    }</span>

    public void notifyModalityPushed(Dialog dialog) {
<span class="nc" id="L1339">        notifyModalityChange(ModalityEvent.MODALITY_PUSHED, dialog);</span>
<span class="nc" id="L1340">    }</span>

    public void notifyModalityPopped(Dialog dialog) {
<span class="nc" id="L1343">        notifyModalityChange(ModalityEvent.MODALITY_POPPED, dialog);</span>
<span class="nc" id="L1344">    }</span>

    final void notifyModalityChange(int id, Dialog source) {
<span class="nc" id="L1347">        ModalityEvent ev = new ModalityEvent(source, modalityListeners, id);</span>
<span class="nc" id="L1348">        ev.dispatch();</span>
<span class="nc" id="L1349">    }</span>

<span class="fc" id="L1351">    static class ModalityListenerList implements ModalityListener {</span>

<span class="fc" id="L1353">        Vector&lt;ModalityListener&gt; listeners = new Vector&lt;ModalityListener&gt;();</span>

        void add(ModalityListener listener) {
<span class="nc" id="L1356">            listeners.addElement(listener);</span>
<span class="nc" id="L1357">        }</span>

        void remove(ModalityListener listener) {
<span class="nc" id="L1360">            listeners.removeElement(listener);</span>
<span class="nc" id="L1361">        }</span>

        public void modalityPushed(ModalityEvent ev) {
<span class="nc" id="L1364">            Iterator&lt;ModalityListener&gt; it = listeners.iterator();</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L1366">                it.next().modalityPushed(ev);</span>
            }
<span class="nc" id="L1368">        }</span>

        public void modalityPopped(ModalityEvent ev) {
<span class="nc" id="L1371">            Iterator&lt;ModalityListener&gt; it = listeners.iterator();</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L1373">                it.next().modalityPopped(ev);</span>
            }
<span class="nc" id="L1375">        }</span>
    } // end of class ModalityListenerList

    ///////////////////////////////////////////////////////////////////////////
    // End Plug-in code
    ///////////////////////////////////////////////////////////////////////////

    public static boolean isLightweightOrUnknown(Component comp) {
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (comp.isLightweight()</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            || !(getDefaultToolkit() instanceof SunToolkit))</span>
        {
<span class="nc" id="L1386">            return true;</span>
        }
<span class="nc bnc" id="L1388" title="All 24 branches missed.">        return !(comp instanceof Button</span>
            || comp instanceof Canvas
            || comp instanceof Checkbox
            || comp instanceof Choice
            || comp instanceof Label
            || comp instanceof java.awt.List
            || comp instanceof Panel
            || comp instanceof Scrollbar
            || comp instanceof ScrollPane
            || comp instanceof TextArea
            || comp instanceof TextField
            || comp instanceof Window);
    }

    @SuppressWarnings(&quot;serial&quot;)
    public static class OperationTimedOut extends RuntimeException {
        public OperationTimedOut(String msg) {
<span class="nc" id="L1405">            super(msg);</span>
<span class="nc" id="L1406">        }</span>
<span class="nc" id="L1407">        public OperationTimedOut() {</span>
<span class="nc" id="L1408">        }</span>
    }

    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L1412">    public static class InfiniteLoop extends RuntimeException {</span>
    }

    @SuppressWarnings(&quot;serial&quot;)
    public static class IllegalThreadException extends RuntimeException {
        public IllegalThreadException(String msg) {
<span class="nc" id="L1418">            super(msg);</span>
<span class="nc" id="L1419">        }</span>
<span class="nc" id="L1420">        public IllegalThreadException() {</span>
<span class="nc" id="L1421">        }</span>
    }

    public static final int DEFAULT_WAIT_TIME = 10000;
    private static final int MAX_ITERS = 20;
    private static final int MIN_ITERS = 0;
    private static final int MINIMAL_EDELAY = 0;

    /**
     * Parameterless version of realsync which uses default timout (see DEFAUL_WAIT_TIME).
     */
    public void realSync() throws OperationTimedOut, InfiniteLoop {
<span class="nc" id="L1433">        realSync(DEFAULT_WAIT_TIME);</span>
<span class="nc" id="L1434">    }</span>

    /**
     * Forces toolkit to synchronize with the native windowing
     * sub-system, flushing all pending work and waiting for all the
     * events to be processed.  This method guarantees that after
     * return no additional Java events will be generated, unless
     * cause by user. Obviously, the method cannot be used on the
     * event dispatch thread (EDT). In case it nevertheless gets
     * invoked on this thread, the method throws the
     * IllegalThreadException runtime exception.
     *
     * &lt;p&gt; This method allows to write tests without explicit timeouts
     * or wait for some event.  Example:
     * &lt;code&gt;
     * Frame f = ...;
     * f.setVisible(true);
     * ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
     * &lt;/code&gt;
     *
     * &lt;p&gt; After realSync, &lt;code&gt;f&lt;/code&gt; will be completely visible
     * on the screen, its getLocationOnScreen will be returning the
     * right result and it will be the focus owner.
     *
     * &lt;p&gt; Another example:
     * &lt;code&gt;
     * b.requestFocus();
     * ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
     * &lt;/code&gt;
     *
     * &lt;p&gt; After realSync, &lt;code&gt;b&lt;/code&gt; will be focus owner.
     *
     * &lt;p&gt; Notice that realSync isn't guaranteed to work if recurring
     * actions occur, such as if during processing of some event
     * another request which may generate some events occurs.  By
     * default, sync tries to perform as much as {@value MAX_ITERS}
     * cycles of event processing, allowing for roughly {@value
     * MAX_ITERS} additional requests.
     *
     * &lt;p&gt; For example, requestFocus() generates native request, which
     * generates one or two Java focus events, which then generate a
     * serie of paint events, a serie of Java focus events, which then
     * generate a serie of paint events which then are processed -
     * three cycles, minimum.
     *
     * @param timeout the maximum time to wait in milliseconds, negative means &quot;forever&quot;.
     */
    public void realSync(final long timeout) throws OperationTimedOut, InfiniteLoop
    {
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
<span class="nc" id="L1484">            throw new IllegalThreadException(&quot;The SunToolkit.realSync() method cannot be used on the event dispatch thread (EDT).&quot;);</span>
        }
<span class="nc" id="L1486">        int bigLoop = 0;</span>
        do {
            // Let's do sync first
<span class="nc" id="L1489">            sync();</span>

            // During the wait process, when we were processing incoming
            // events, we could have made some new request, which can
            // generate new events.  Example: MapNotify/XSetInputFocus.
            // Therefore, we dispatch them as long as there is something
            // to dispatch.
<span class="nc" id="L1496">            int iters = 0;</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">            while (iters &lt; MIN_ITERS) {</span>
<span class="nc" id="L1498">                syncNativeQueue(timeout);</span>
<span class="nc" id="L1499">                iters++;</span>
            }
<span class="nc bnc" id="L1501" title="All 4 branches missed.">            while (syncNativeQueue(timeout) &amp;&amp; iters &lt; MAX_ITERS) {</span>
<span class="nc" id="L1502">                iters++;</span>
            }
<span class="nc bnc" id="L1504" title="All 2 branches missed.">            if (iters &gt;= MAX_ITERS) {</span>
<span class="nc" id="L1505">                throw new InfiniteLoop();</span>
            }

            // native requests were dispatched by X/Window Manager or Windows
            // Moreover, we processed them all on Toolkit thread
            // Now wait while EDT processes them.
            //
            // During processing of some events (focus, for example),
            // some other events could have been generated.  So, after
            // waitForIdle, we may end up with full EventQueue
<span class="nc" id="L1515">            iters = 0;</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            while (iters &lt; MIN_ITERS) {</span>
<span class="nc" id="L1517">                waitForIdle(timeout);</span>
<span class="nc" id="L1518">                iters++;</span>
            }
<span class="nc bnc" id="L1520" title="All 4 branches missed.">            while (waitForIdle(timeout) &amp;&amp; iters &lt; MAX_ITERS) {</span>
<span class="nc" id="L1521">                iters++;</span>
            }
<span class="nc bnc" id="L1523" title="All 2 branches missed.">            if (iters &gt;= MAX_ITERS) {</span>
<span class="nc" id="L1524">                throw new InfiniteLoop();</span>
            }

<span class="nc" id="L1527">            bigLoop++;</span>
            // Again, for Java events, it was simple to check for new Java
            // events by checking event queue, but what if Java events
            // resulted in native requests?  Therefor, check native events again.
<span class="nc bnc" id="L1531" title="All 6 branches missed.">        } while ((syncNativeQueue(timeout) || waitForIdle(timeout)) &amp;&amp; bigLoop &lt; MAX_ITERS);</span>
<span class="nc" id="L1532">    }</span>

    /**
     * Platform toolkits need to implement this method to perform the
     * sync of the native queue.  The method should wait until native
     * requests are processed, all native events are processed and
     * corresponding Java events are generated.  Should return
     * &lt;code&gt;true&lt;/code&gt; if some events were processed,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    protected abstract boolean syncNativeQueue(final long timeout);

<span class="fc" id="L1544">    private boolean eventDispatched = false;</span>
<span class="fc" id="L1545">    private boolean queueEmpty = false;</span>
<span class="fc" id="L1546">    private final Object waitLock = &quot;Wait Lock&quot;;</span>

    private boolean isEQEmpty() {
<span class="nc" id="L1549">        EventQueue queue = getSystemEventQueueImpl();</span>
<span class="nc" id="L1550">        return AWTAccessor.getEventQueueAccessor().noEvents(queue);</span>
    }

    /**
     * Waits for the Java event queue to empty.  Ensures that all
     * events are processed (including paint events), and that if
     * recursive events were generated, they are also processed.
     * Should return &lt;code&gt;true&lt;/code&gt; if more processing is
     * necessary, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @SuppressWarnings(&quot;serial&quot;)
    protected final boolean waitForIdle(final long timeout) {
<span class="nc" id="L1562">        flushPendingEvents();</span>
<span class="nc" id="L1563">        boolean queueWasEmpty = isEQEmpty();</span>
<span class="nc" id="L1564">        queueEmpty = false;</span>
<span class="nc" id="L1565">        eventDispatched = false;</span>
<span class="nc" id="L1566">        synchronized(waitLock) {</span>
<span class="nc" id="L1567">            postEvent(AppContext.getAppContext(),</span>
<span class="nc" id="L1568">                      new PeerEvent(getSystemEventQueueImpl(), null, PeerEvent.LOW_PRIORITY_EVENT) {</span>
                          public void dispatch() {
                              // Here we block EDT.  It could have some
                              // events, it should have dispatched them by
                              // now.  So native requests could have been
                              // generated.  First, dispatch them.  Then,
                              // flush Java events again.
<span class="nc" id="L1575">                              int iters = 0;</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">                              while (iters &lt; MIN_ITERS) {</span>
<span class="nc" id="L1577">                                  syncNativeQueue(timeout);</span>
<span class="nc" id="L1578">                                  iters++;</span>
                              }
<span class="nc bnc" id="L1580" title="All 4 branches missed.">                              while (syncNativeQueue(timeout) &amp;&amp; iters &lt; MAX_ITERS) {</span>
<span class="nc" id="L1581">                                  iters++;</span>
                              }
<span class="nc" id="L1583">                              flushPendingEvents();</span>

<span class="nc" id="L1585">                              synchronized(waitLock) {</span>
<span class="nc" id="L1586">                                  queueEmpty = isEQEmpty();</span>
<span class="nc" id="L1587">                                  eventDispatched = true;</span>
<span class="nc" id="L1588">                                  waitLock.notifyAll();</span>
<span class="nc" id="L1589">                              }</span>
<span class="nc" id="L1590">                          }</span>
                      });
            try {
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                while (!eventDispatched) {</span>
<span class="nc" id="L1594">                    waitLock.wait();</span>
                }
<span class="nc" id="L1596">            } catch (InterruptedException ie) {</span>
<span class="nc" id="L1597">                return false;</span>
<span class="nc" id="L1598">            }</span>
<span class="nc" id="L1599">        }</span>

        try {
<span class="nc" id="L1602">            Thread.sleep(MINIMAL_EDELAY);</span>
<span class="nc" id="L1603">        } catch (InterruptedException ie) {</span>
<span class="nc" id="L1604">            throw new RuntimeException(&quot;Interrupted&quot;);</span>
<span class="nc" id="L1605">        }</span>

<span class="nc" id="L1607">        flushPendingEvents();</span>

        // Lock to force write-cache flush for queueEmpty.
<span class="nc" id="L1610">        synchronized (waitLock) {</span>
<span class="nc bnc" id="L1611" title="All 6 branches missed.">            return !(queueEmpty &amp;&amp; isEQEmpty() &amp;&amp; queueWasEmpty);</span>
<span class="nc" id="L1612">        }</span>
    }

    /**
     * Grabs the mouse input for the given window.  The window must be
     * visible.  The window or its children do not receive any
     * additional mouse events besides those targeted to them.  All
     * other events will be dispatched as before - to the respective
     * targets.  This Window will receive UngrabEvent when automatic
     * ungrab is about to happen.  The event can be listened to by
     * installing AWTEventListener with WINDOW_EVENT_MASK.  See
     * UngrabEvent class for the list of conditions when ungrab is
     * about to happen.
     * @see UngrabEvent
     */
    public abstract void grab(Window w);

    /**
     * Forces ungrab.  No event will be sent.
     */
    public abstract void ungrab(Window w);


    /**
     * Locates the splash screen library in a platform dependent way and closes
     * the splash screen. Should be invoked on first top-level frame display.
     * @see java.awt.SplashScreen
     * @since 1.6
     */
    public static native void closeSplashScreen();

    /* The following methods and variables are to support retrieving
     * desktop text anti-aliasing settings
     */

    /* Need an instance method because setDesktopProperty(..) is protected. */
    private void fireDesktopFontPropertyChanges() {
<span class="nc" id="L1649">        setDesktopProperty(SunToolkit.DESKTOPFONTHINTS,</span>
<span class="nc" id="L1650">                           SunToolkit.getDesktopFontHints());</span>
<span class="nc" id="L1651">    }</span>

    private static boolean checkedSystemAAFontSettings;
    private static boolean useSystemAAFontSettings;
<span class="fc" id="L1655">    private static boolean lastExtraCondition = true;</span>
    private static RenderingHints desktopFontHints;

    /* Since Swing is the reason for this &quot;extra condition&quot; logic its
     * worth documenting it in some detail.
     * First, a goal is for Swing and applications to both retrieve and
     * use the same desktop property value so that there is complete
     * consistency between the settings used by JDK's Swing implementation
     * and 3rd party custom Swing components, custom L&amp;Fs and any general
     * text rendering that wants to be consistent with these.
     * But by default on Solaris &amp; Linux Swing will not use AA text over
     * remote X11 display (unless Xrender can be used which is TBD and may not
     * always be available anyway) as that is a noticeable performance hit.
     * So there needs to be a way to express that extra condition so that
     * it is seen by all clients of the desktop property API.
     * If this were the only condition it could be handled here as it would
     * be the same for any L&amp;F and could reasonably be considered to be
     * a static behaviour of those systems.
     * But GTK currently has an additional test based on locale which is
     * not applied by Metal. So mixing GTK in a few locales with Metal
     * would mean the last one wins.
     * This could be stored per-app context which would work
     * for different applets, but wouldn't help for a single application
     * using GTK and some other L&amp;F concurrently.
     * But it is expected this will be addressed within GTK and the font
     * system so is a temporary and somewhat unlikely harmless corner case.
     */
    public static void setAAFontSettingsCondition(boolean extraCondition) {
<span class="pc bpc" id="L1683" title="1 of 2 branches missed.">        if (extraCondition != lastExtraCondition) {</span>
<span class="nc" id="L1684">            lastExtraCondition = extraCondition;</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            if (checkedSystemAAFontSettings) {</span>
                /* Someone already asked for this info, under a different
                 * condition.
                 * We'll force re-evaluation instead of replicating the
                 * logic, then notify any listeners of any change.
                 */
<span class="nc" id="L1691">                checkedSystemAAFontSettings = false;</span>
<span class="nc" id="L1692">                Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                if (tk instanceof SunToolkit) {</span>
<span class="nc" id="L1694">                     ((SunToolkit)tk).fireDesktopFontPropertyChanges();</span>
                }
            }
        }
<span class="fc" id="L1698">    }</span>

    /* &quot;false&quot;, &quot;off&quot;, &quot;&quot;default&quot; aren't explicitly tested, they
     * just fall through to produce a null return which all are equated to
     * &quot;false&quot;.
     */
    private static RenderingHints getDesktopAAHintsByName(String hintname) {
<span class="nc" id="L1705">        Object aaHint = null;</span>
<span class="nc" id="L1706">        hintname = hintname.toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">        if (hintname.equals(&quot;on&quot;)) {</span>
<span class="nc" id="L1708">            aaHint = VALUE_TEXT_ANTIALIAS_ON;</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">        } else if (hintname.equals(&quot;gasp&quot;)) {</span>
<span class="nc" id="L1710">            aaHint = VALUE_TEXT_ANTIALIAS_GASP;</span>
<span class="nc bnc" id="L1711" title="All 4 branches missed.">        } else if (hintname.equals(&quot;lcd&quot;) || hintname.equals(&quot;lcd_hrgb&quot;)) {</span>
<span class="nc" id="L1712">            aaHint = VALUE_TEXT_ANTIALIAS_LCD_HRGB;</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">        } else if (hintname.equals(&quot;lcd_hbgr&quot;)) {</span>
<span class="nc" id="L1714">            aaHint = VALUE_TEXT_ANTIALIAS_LCD_HBGR;</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">        } else if (hintname.equals(&quot;lcd_vrgb&quot;)) {</span>
<span class="nc" id="L1716">            aaHint = VALUE_TEXT_ANTIALIAS_LCD_VRGB;</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">        } else if (hintname.equals(&quot;lcd_vbgr&quot;)) {</span>
<span class="nc" id="L1718">            aaHint = VALUE_TEXT_ANTIALIAS_LCD_VBGR;</span>
        }
<span class="nc bnc" id="L1720" title="All 2 branches missed.">        if (aaHint != null) {</span>
<span class="nc" id="L1721">            RenderingHints map = new RenderingHints(null);</span>
<span class="nc" id="L1722">            map.put(KEY_TEXT_ANTIALIASING, aaHint);</span>
<span class="nc" id="L1723">            return map;</span>
        } else {
<span class="nc" id="L1725">            return null;</span>
        }
    }

    /* This method determines whether to use the system font settings,
     * or ignore them if a L&amp;F has specified they should be ignored, or
     * to override both of these with a system property specified value.
     * If the toolkit isn't a SunToolkit, (eg may be headless) then that
     * system property isn't applied as desktop properties are considered
     * to be inapplicable in that case. In that headless case although
     * this method will return &quot;true&quot; the toolkit will return a null map.
     */
    private static boolean useSystemAAFontSettings() {
<span class="nc bnc" id="L1738" title="All 2 branches missed.">        if (!checkedSystemAAFontSettings) {</span>
<span class="nc" id="L1739">            useSystemAAFontSettings = true; /* initially set this true */</span>
<span class="nc" id="L1740">            String systemAAFonts = null;</span>
<span class="nc" id="L1741">            Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">            if (tk instanceof SunToolkit) {</span>
<span class="nc" id="L1743">                systemAAFonts =</span>
<span class="nc" id="L1744">                    AccessController.doPrivileged(</span>
                         new GetPropertyAction(&quot;awt.useSystemAAFontSettings&quot;));
            }
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (systemAAFonts != null) {</span>
<span class="nc" id="L1748">                useSystemAAFontSettings =</span>
<span class="nc" id="L1749">                    Boolean.valueOf(systemAAFonts).booleanValue();</span>
                /* If it is anything other than &quot;true&quot;, then it may be
                 * a hint name , or it may be &quot;off, &quot;default&quot;, etc.
                 */
<span class="nc bnc" id="L1753" title="All 2 branches missed.">                if (!useSystemAAFontSettings) {</span>
<span class="nc" id="L1754">                    desktopFontHints = getDesktopAAHintsByName(systemAAFonts);</span>
                }
            }
            /* If its still true, apply the extra condition */
<span class="nc bnc" id="L1758" title="All 2 branches missed.">            if (useSystemAAFontSettings) {</span>
<span class="nc" id="L1759">                 useSystemAAFontSettings = lastExtraCondition;</span>
            }
<span class="nc" id="L1761">            checkedSystemAAFontSettings = true;</span>
        }
<span class="nc" id="L1763">        return useSystemAAFontSettings;</span>
    }

    /* A variable defined for the convenience of JDK code */
    public static final String DESKTOPFONTHINTS = &quot;awt.font.desktophints&quot;;

    /* Overridden by subclasses to return platform/desktop specific values */
    protected RenderingHints getDesktopAAHints() {
<span class="nc" id="L1771">        return null;</span>
    }

    /* Subclass desktop property loading methods call this which
     * in turn calls the appropriate subclass implementation of
     * getDesktopAAHints() when system settings are being used.
     * Its public rather than protected because subclasses may delegate
     * to a helper class.
     */
    public static RenderingHints getDesktopFontHints() {
<span class="nc bnc" id="L1781" title="All 2 branches missed.">        if (useSystemAAFontSettings()) {</span>
<span class="nc" id="L1782">             Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">             if (tk instanceof SunToolkit) {</span>
<span class="nc" id="L1784">                 Object map = ((SunToolkit)tk).getDesktopAAHints();</span>
<span class="nc" id="L1785">                 return (RenderingHints)map;</span>
             } else { /* Headless Toolkit */
<span class="nc" id="L1787">                 return null;</span>
             }
<span class="nc bnc" id="L1789" title="All 2 branches missed.">        } else if (desktopFontHints != null) {</span>
            /* cloning not necessary as the return value is cloned later, but
             * its harmless.
             */
<span class="nc" id="L1793">            return (RenderingHints)(desktopFontHints.clone());</span>
        } else {
<span class="nc" id="L1795">            return null;</span>
        }
    }


    public abstract boolean isDesktopSupported();

    /*
     * consumeNextKeyTyped() method is not currently used,
     * however Swing could use it in the future.
     */
    public static synchronized void consumeNextKeyTyped(KeyEvent keyEvent) {
        try {
<span class="nc" id="L1808">            AWTAccessor.getDefaultKeyboardFocusManagerAccessor().consumeNextKeyTyped(</span>
                (DefaultKeyboardFocusManager)KeyboardFocusManager.
<span class="nc" id="L1810">                    getCurrentKeyboardFocusManager(),</span>
                keyEvent);
<span class="nc" id="L1812">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L1813">             cce.printStackTrace();</span>
<span class="nc" id="L1814">        }</span>
<span class="nc" id="L1815">    }</span>

    protected static void dumpPeers(final PlatformLogger aLog) {
<span class="nc" id="L1818">        AWTAutoShutdown.getInstance().dumpPeers(aLog);</span>
<span class="nc" id="L1819">    }</span>

    /**
     * Returns the &lt;code&gt;Window&lt;/code&gt; ancestor of the component &lt;code&gt;comp&lt;/code&gt;.
     * @return Window ancestor of the component or component by itself if it is Window;
     *         null, if component is not a part of window hierarchy
     */
    public static Window getContainingWindow(Component comp) {
<span class="nc bnc" id="L1827" title="All 4 branches missed.">        while (comp != null &amp;&amp; !(comp instanceof Window)) {</span>
<span class="nc" id="L1828">            comp = comp.getParent();</span>
        }
<span class="nc" id="L1830">        return (Window)comp;</span>
    }

<span class="fc" id="L1833">    private static Boolean sunAwtDisableMixing = null;</span>

    /**
     * Returns the value of &quot;sun.awt.disableMixing&quot; property. Default
     * value is {@code false}.
     */
    public synchronized static boolean getSunAwtDisableMixing() {
<span class="nc bnc" id="L1840" title="All 2 branches missed.">        if (sunAwtDisableMixing == null) {</span>
<span class="nc" id="L1841">            sunAwtDisableMixing = AccessController.doPrivileged(</span>
                                      new GetBooleanAction(&quot;sun.awt.disableMixing&quot;));
        }
<span class="nc" id="L1844">        return sunAwtDisableMixing.booleanValue();</span>
    }

    /**
     * Returns true if the native GTK libraries are available.  The
     * default implementation returns false, but UNIXToolkit overrides this
     * method to provide a more specific answer.
     */
    public boolean isNativeGTKAvailable() {
<span class="nc" id="L1853">        return false;</span>
    }

<span class="fc" id="L1856">    private static final Object DEACTIVATION_TIMES_MAP_KEY = new Object();</span>

    public synchronized void setWindowDeactivationTime(Window w, long time) {
<span class="nc" id="L1859">        AppContext ctx = getAppContext(w);</span>
<span class="nc" id="L1860">        WeakHashMap&lt;Window, Long&gt; map = (WeakHashMap&lt;Window, Long&gt;)ctx.get(DEACTIVATION_TIMES_MAP_KEY);</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L1862">            map = new WeakHashMap&lt;Window, Long&gt;();</span>
<span class="nc" id="L1863">            ctx.put(DEACTIVATION_TIMES_MAP_KEY, map);</span>
        }
<span class="nc" id="L1865">        map.put(w, time);</span>
<span class="nc" id="L1866">    }</span>

    public synchronized long getWindowDeactivationTime(Window w) {
<span class="nc" id="L1869">        AppContext ctx = getAppContext(w);</span>
<span class="nc" id="L1870">        WeakHashMap&lt;Window, Long&gt; map = (WeakHashMap&lt;Window, Long&gt;)ctx.get(DEACTIVATION_TIMES_MAP_KEY);</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L1872">            return -1;</span>
        }
<span class="nc" id="L1874">        Long time = map.get(w);</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">        return time == null ? -1 : time;</span>
    }

    // Cosntant alpha
    public boolean isWindowOpacitySupported() {
<span class="nc" id="L1880">        return false;</span>
    }

    // Shaping
    public boolean isWindowShapingSupported() {
<span class="nc" id="L1885">        return false;</span>
    }

    // Per-pixel alpha
    public boolean isWindowTranslucencySupported() {
<span class="nc" id="L1890">        return false;</span>
    }

    public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
<span class="nc" id="L1894">        return false;</span>
    }

    /**
     * Returns true if swing backbuffer should be translucent.
     */
    public boolean isSwingBackbufferTranslucencySupported() {
<span class="nc" id="L1901">        return false;</span>
    }

    /**
     * Returns whether or not a containing top level window for the passed
     * component is
     * {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}.
     *
     * @param c a Component which toplevel's to check
     * @return {@code true}  if the passed component is not null and has a
     * containing toplevel window which is opaque (so per-pixel translucency
     * is not enabled), {@code false} otherwise
     * @see GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
     */
    public static boolean isContainingTopLevelOpaque(Component c) {
<span class="nc" id="L1916">        Window w = getContainingWindow(c);</span>
<span class="nc bnc" id="L1917" title="All 4 branches missed.">        return w != null &amp;&amp; w.isOpaque();</span>
    }

    /**
     * Returns whether or not a containing top level window for the passed
     * component is
     * {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}.
     *
     * @param c a Component which toplevel's to check
     * @return {@code true} if the passed component is not null and has a
     * containing toplevel window which has opacity less than
     * 1.0f (which means that it is translucent), {@code false} otherwise
     * @see GraphicsDevice.WindowTranslucency#TRANSLUCENT
     */
    public static boolean isContainingTopLevelTranslucent(Component c) {
<span class="nc" id="L1932">        Window w = getContainingWindow(c);</span>
<span class="nc bnc" id="L1933" title="All 4 branches missed.">        return w != null &amp;&amp; w.getOpacity() &lt; 1.0f;</span>
    }

    /**
     * Returns whether the native system requires using the peer.updateWindow()
     * method to update the contents of a non-opaque window, or if usual
     * painting procedures are sufficient. The default return value covers
     * the X11 systems. On MS Windows this method is overriden in WToolkit
     * to return true.
     */
    public boolean needUpdateWindow() {
<span class="nc" id="L1944">        return false;</span>
    }

    /**
     * Descendants of the SunToolkit should override and put their own logic here.
     */
    public int getNumberOfButtons(){
<span class="nc" id="L1951">        return 3;</span>
    }

    /**
     * Checks that the given object implements/extends the given
     * interface/class.
     *
     * Note that using the instanceof operator causes a class to be loaded.
     * Using this method doesn't load a class and it can be used instead of
     * the instanceof operator for performance reasons.
     *
     * @param obj Object to be checked
     * @param type The name of the interface/class. Must be
     * fully-qualified interface/class name.
     * @return true, if this object implements/extends the given
     *         interface/class, false, otherwise, or if obj or type is null
     */
    public static boolean isInstanceOf(Object obj, String type) {
<span class="nc bnc" id="L1969" title="All 2 branches missed.">        if (obj == null) return false;</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">        if (type == null) return false;</span>

<span class="nc" id="L1972">        return isInstanceOf(obj.getClass(), type);</span>
    }

    private static boolean isInstanceOf(Class&lt;?&gt; cls, String type) {
<span class="nc bnc" id="L1976" title="All 2 branches missed.">        if (cls == null) return false;</span>

<span class="nc bnc" id="L1978" title="All 2 branches missed.">        if (cls.getName().equals(type)) {</span>
<span class="nc" id="L1979">            return true;</span>
        }

<span class="nc bnc" id="L1982" title="All 2 branches missed.">        for (Class&lt;?&gt; c : cls.getInterfaces()) {</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">            if (c.getName().equals(type)) {</span>
<span class="nc" id="L1984">                return true;</span>
            }
        }
<span class="nc" id="L1987">        return isInstanceOf(cls.getSuperclass(), type);</span>
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // The following methods help set and identify whether a particular
    // AWTEvent object was produced by the system or by user code. As of this
    // writing the only consumer is the Java Plug-In, although this information
    // could be useful to more clients and probably should be formalized in
    // the public API.
    //
    ///////////////////////////////////////////////////////////////////////////

    public static void setSystemGenerated(AWTEvent e) {
<span class="nc" id="L2001">        AWTAccessor.getAWTEventAccessor().setSystemGenerated(e);</span>
<span class="nc" id="L2002">    }</span>

    public static boolean isSystemGenerated(AWTEvent e) {
<span class="nc" id="L2005">        return AWTAccessor.getAWTEventAccessor().isSystemGenerated(e);</span>
    }

} // class SunToolkit


/*
 * PostEventQueue is a Thread that runs in the same AppContext as the
 * Java EventQueue.  It is a queue of AWTEvents to be posted to the
 * Java EventQueue.  The toolkit Thread (AWT-Windows/AWT-Motif) posts
 * events to this queue, which then calls EventQueue.postEvent().
 *
 * We do this because EventQueue.postEvent() may be overridden by client
 * code, and we mustn't ever call client code from the toolkit thread.
 */
class PostEventQueue {
<span class="fc" id="L2021">    private EventQueueItem queueHead = null;</span>
<span class="fc" id="L2022">    private EventQueueItem queueTail = null;</span>
    private final EventQueue eventQueue;

<span class="fc" id="L2025">    private Thread flushThread = null;</span>

<span class="fc" id="L2027">    PostEventQueue(EventQueue eq) {</span>
<span class="fc" id="L2028">        eventQueue = eq;</span>
<span class="fc" id="L2029">    }</span>

    /*
     * Continually post pending AWTEvents to the Java EventQueue. The method
     * is synchronized to ensure the flush is completed before a new event
     * can be posted to this queue.
     *
     * 7177040: The method couldn't be wholly synchronized because of calls
     * of EventQueue.postEvent() that uses pushPopLock, otherwise it could
     * potentially lead to deadlock
     */
    public void flush() {

<span class="nc" id="L2042">        Thread newThread = Thread.currentThread();</span>

        try {
            EventQueueItem tempQueue;
<span class="nc" id="L2046">            synchronized (this) {</span>
                // Avoid method recursion
<span class="nc bnc" id="L2048" title="All 2 branches missed.">                if (newThread == flushThread) {</span>
<span class="nc" id="L2049">                    return;</span>
                }
                // Wait for other threads' flushing
<span class="nc bnc" id="L2052" title="All 2 branches missed.">                while (flushThread != null) {</span>
<span class="nc" id="L2053">                    wait();</span>
                }
                // Skip everything if queue is empty
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                if (queueHead == null) {</span>
<span class="nc" id="L2057">                    return;</span>
                }
                // Remember flushing thread
<span class="nc" id="L2060">                flushThread = newThread;</span>

<span class="nc" id="L2062">                tempQueue = queueHead;</span>
<span class="nc" id="L2063">                queueHead = queueTail = null;</span>
<span class="nc" id="L2064">            }</span>
            try {
<span class="nc bnc" id="L2066" title="All 2 branches missed.">                while (tempQueue != null) {</span>
<span class="nc" id="L2067">                    eventQueue.postEvent(tempQueue.event);</span>
<span class="nc" id="L2068">                    tempQueue = tempQueue.next;</span>
                }
            }
            finally {
                // Only the flushing thread can get here
<span class="nc" id="L2073">                synchronized (this) {</span>
                    // Forget flushing thread, inform other pending threads
<span class="nc" id="L2075">                    flushThread = null;</span>
<span class="nc" id="L2076">                    notifyAll();</span>
<span class="nc" id="L2077">                }</span>
<span class="nc" id="L2078">            }</span>
        }
<span class="nc" id="L2080">        catch (InterruptedException e) {</span>
            // Couldn't allow exception go up, so at least recover the flag
<span class="nc" id="L2082">            newThread.interrupt();</span>
<span class="nc" id="L2083">        }</span>
<span class="nc" id="L2084">    }</span>

    /*
     * Enqueue an AWTEvent to be posted to the Java EventQueue.
     */
    void postEvent(AWTEvent event) {
<span class="nc" id="L2090">        EventQueueItem item = new EventQueueItem(event);</span>

<span class="nc" id="L2092">        synchronized (this) {</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">            if (queueHead == null) {</span>
<span class="nc" id="L2094">                queueHead = queueTail = item;</span>
            } else {
<span class="nc" id="L2096">                queueTail.next = item;</span>
<span class="nc" id="L2097">                queueTail = item;</span>
            }
<span class="nc" id="L2099">        }</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">        SunToolkit.wakeupEventQueue(eventQueue, event.getSource() == AWTAutoShutdown.getInstance());</span>
<span class="nc" id="L2101">    }</span>
} // class PostEventQueue
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>