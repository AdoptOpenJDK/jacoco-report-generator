<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TableSorter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.jconsole.inspector</a> &gt; <span class="el_source">TableSorter.java</span></div><h1>TableSorter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.jconsole.inspector;


// Imports for picking up mouse events from the JTable.

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Vector;
import javax.swing.JTable;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumnModel;
import sun.tools.jconsole.JConsole;

@SuppressWarnings(&quot;serial&quot;)
public class TableSorter extends DefaultTableModel implements MouseListener {
<span class="nc" id="L44">    private boolean ascending = true;</span>
    private TableColumnModel columnModel;
    private JTable tableView;
    private Vector&lt;TableModelListener&gt; evtListenerList;
<span class="nc" id="L48">    private int sortColumn = 0;</span>

    private int[] invertedIndex;

    public TableSorter() {
<span class="nc" id="L53">        super();</span>
<span class="nc" id="L54">        evtListenerList = new Vector&lt;TableModelListener&gt;();</span>
<span class="nc" id="L55">    }</span>

    public TableSorter(Object[] columnNames, int numRows) {
<span class="nc" id="L58">        super(columnNames,numRows);</span>
<span class="nc" id="L59">        evtListenerList = new Vector&lt;TableModelListener&gt;();</span>
<span class="nc" id="L60">    }</span>

    @Override
    public void newDataAvailable(TableModelEvent e) {
<span class="nc" id="L64">        super.newDataAvailable(e);</span>
<span class="nc" id="L65">        invertedIndex = new int[getRowCount()];</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        for (int i = 0; i &lt; invertedIndex.length; i++) {</span>
<span class="nc" id="L67">            invertedIndex[i] = i;</span>
        }
<span class="nc" id="L69">        sort(this.sortColumn, this.ascending);</span>
<span class="nc" id="L70">    }</span>

    @Override
    public void addTableModelListener(TableModelListener l) {
<span class="nc" id="L74">        evtListenerList.add(l);</span>
<span class="nc" id="L75">        super.addTableModelListener(l);</span>
<span class="nc" id="L76">    }</span>

    @Override
    public void removeTableModelListener(TableModelListener l) {
<span class="nc" id="L80">        evtListenerList.remove(l);</span>
<span class="nc" id="L81">        super.removeTableModelListener(l);</span>
<span class="nc" id="L82">    }</span>

    private void removeListeners() {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        for(TableModelListener tnl : evtListenerList)</span>
<span class="nc" id="L86">            super.removeTableModelListener(tnl);</span>
<span class="nc" id="L87">    }</span>

    private void restoreListeners() {
<span class="nc bnc" id="L90" title="All 2 branches missed.">        for(TableModelListener tnl : evtListenerList)</span>
<span class="nc" id="L91">            super.addTableModelListener(tnl);</span>
<span class="nc" id="L92">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private int compare(Object o1, Object o2) {
        // take care of the case where both o1 &amp; o2 are null. Needed to keep
        // the method symmetric. Without this quickSort gives surprising results.
<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (o1 == o2)</span>
<span class="nc" id="L99">            return 0;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (o1==null)</span>
<span class="nc" id="L101">            return 1;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (o2==null)</span>
<span class="nc" id="L103">            return -1;</span>
        //two object of the same class and that are comparable
<span class="nc bnc" id="L105" title="All 4 branches missed.">        else if ((o1.getClass().equals(o2.getClass())) &amp;&amp;</span>
                 (o1 instanceof Comparable)) {
<span class="nc" id="L107">            return (((Comparable) o1).compareTo(o2));</span>
        }
        else {
<span class="nc" id="L110">            return o1.toString().compareTo(o2.toString());</span>
        }
    }

    private void sort(int column, boolean isAscending) {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        final XMBeanAttributes attrs =</span>
                (tableView instanceof XMBeanAttributes)
                ?(XMBeanAttributes) tableView
                :null;

        // We cannot sort rows when a cell is being
        // edited - so we're going to cancel cell editing here if needed.
        // This might happen when the user is editing a row, and clicks on
        // another row without validating. In that case there are two events
        // that compete: one is the validation of the value that was previously
        // edited, the other is the mouse click that opens the new editor.
        //
        // When we reach here the previous value is already validated, and the
        // old editor is closed, but the new editor might have opened.
        // It's this new editor that wil be cancelled here, if needed.
        //
<span class="nc bnc" id="L131" title="All 4 branches missed.">        if (attrs != null &amp;&amp; attrs.isEditing())</span>
<span class="nc" id="L132">            attrs.cancelCellEditing();</span>

        // remove registered listeners
<span class="nc" id="L135">        removeListeners();</span>
        // do the sort

<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (JConsole.isDebug()) {</span>
<span class="nc" id="L139">            System.err.println(&quot;sorting table against column=&quot;+column</span>
                    +&quot; ascending=&quot;+isAscending);
        }
<span class="nc" id="L142">        quickSort(0,getRowCount()-1,column,isAscending);</span>
        // restore registered listeners
<span class="nc" id="L144">        restoreListeners();</span>

        // update row heights in XMBeanAttributes (required by expandable cells)
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (attrs != null) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            for (int i = 0; i &lt; getRowCount(); i++) {</span>
<span class="nc" id="L149">                Vector data = (Vector) dataVector.elementAt(i);</span>
<span class="nc" id="L150">                attrs.updateRowHeight(data.elementAt(1), i);</span>
            }
        }
<span class="nc" id="L153">    }</span>

    private boolean compareS(Object s1, Object s2, boolean isAscending) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (isAscending)</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            return (compare(s1,s2) &gt; 0);</span>
        else
<span class="nc bnc" id="L159" title="All 2 branches missed.">            return (compare(s1,s2) &lt; 0);</span>
    }

    private boolean compareG(Object s1, Object s2, boolean isAscending) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (isAscending)</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            return (compare(s1,s2) &lt; 0);</span>
        else
<span class="nc bnc" id="L166" title="All 2 branches missed.">            return (compare(s1,s2) &gt; 0);</span>
    }

    private void quickSort(int lo0,int hi0, int key, boolean isAscending) {
<span class="nc" id="L170">        int lo = lo0;</span>
<span class="nc" id="L171">        int hi = hi0;</span>
        Object mid;

<span class="nc bnc" id="L174" title="All 2 branches missed.">        if ( hi0 &gt; lo0)</span>
            {
<span class="nc" id="L176">                mid = getValueAt( ( lo0 + hi0 ) / 2 , key);</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">                while( lo &lt;= hi )</span>
                    {
                        /* find the first element that is greater than
                         * or equal to the partition element starting
                         * from the left Index.
                         */
<span class="nc bnc" id="L184" title="All 2 branches missed.">                        while( ( lo &lt; hi0 ) &amp;&amp;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                               ( compareS(mid,getValueAt(lo,key), isAscending) ))</span>
<span class="nc" id="L186">                            ++lo;</span>

                        /* find an element that is smaller than or equal to
                         * the partition element starting from the right Index.
                         */
<span class="nc bnc" id="L191" title="All 2 branches missed.">                        while( ( hi &gt; lo0 ) &amp;&amp;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                               ( compareG(mid,getValueAt(hi,key), isAscending) ))</span>
<span class="nc" id="L193">                            --hi;</span>

                        // if the indexes have not crossed, swap
<span class="nc bnc" id="L196" title="All 2 branches missed.">                        if( lo &lt;= hi )</span>
                            {
<span class="nc" id="L198">                                swap(lo, hi, key);</span>
<span class="nc" id="L199">                                ++lo;</span>
<span class="nc" id="L200">                                --hi;</span>
                            }
                    }

                                /* If the right index has not reached the
                                 * left side of array
                                 * must now sort the left partition.
                                 */
<span class="nc bnc" id="L208" title="All 2 branches missed.">                if( lo0 &lt; hi )</span>
<span class="nc" id="L209">                    quickSort(lo0, hi , key, isAscending);</span>

                                /* If the left index has not reached the right
                                 * side of array
                                 * must now sort the right partition.
                                 */
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if( lo &lt;= hi0 )</span>
<span class="nc" id="L216">                    quickSort(lo, hi0 , key, isAscending);</span>
            }
<span class="nc" id="L218">    }</span>

    private Vector getRow(int row) {
<span class="nc" id="L221">        return (Vector) dataVector.elementAt(row);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private void setRow(Vector data, int row) {
<span class="nc" id="L226">        dataVector.setElementAt(data,row);</span>
<span class="nc" id="L227">    }</span>

    private void swap(int i, int j, int column) {
<span class="nc" id="L230">        Vector data = getRow(i);</span>
<span class="nc" id="L231">        setRow(getRow(j),i);</span>
<span class="nc" id="L232">        setRow(data,j);</span>

<span class="nc" id="L234">        int a = invertedIndex[i];</span>
<span class="nc" id="L235">        invertedIndex[i] = invertedIndex[j];</span>
<span class="nc" id="L236">        invertedIndex[j] = a;</span>
<span class="nc" id="L237">    }</span>

    public void sortByColumn(int column) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">        sortByColumn(column, !ascending);</span>
<span class="nc" id="L241">    }</span>

    public void sortByColumn(int column, boolean ascending) {
<span class="nc" id="L244">        this.ascending = ascending;</span>
<span class="nc" id="L245">        this.sortColumn = column;</span>
<span class="nc" id="L246">        sort(column,ascending);</span>
<span class="nc" id="L247">    }</span>

    public int getIndexOfRow(int row) {
<span class="nc" id="L250">        return invertedIndex[row];</span>
    }

    // Add a mouse listener to the Table to trigger a table sort
    // when a column heading is clicked in the JTable.
    public void addMouseListenerToHeaderInTable(JTable table) {
<span class="nc" id="L256">        tableView = table;</span>
<span class="nc" id="L257">        columnModel = tableView.getColumnModel();</span>
<span class="nc" id="L258">        JTableHeader th = tableView.getTableHeader();</span>
<span class="nc" id="L259">        th.addMouseListener(this);</span>
<span class="nc" id="L260">    }</span>

    public void mouseClicked(MouseEvent e) {
<span class="nc" id="L263">        int viewColumn = columnModel.getColumnIndexAtX(e.getX());</span>
<span class="nc" id="L264">        int column = tableView.convertColumnIndexToModel(viewColumn);</span>
<span class="nc bnc" id="L265" title="All 4 branches missed.">        if (e.getClickCount() == 1 &amp;&amp; column != -1) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (tableView instanceof XTable) {</span>
<span class="nc" id="L267">                XTable attrs = (XTable) tableView;</span>
                // inform the table view that the rows are going to be sorted
                // against the values in a given column. This gives the
                // chance to the table view to close its editor - if needed.
                //
<span class="nc" id="L272">                attrs.sortRequested(column);</span>
            }
<span class="nc" id="L274">            tableView.invalidate();</span>
<span class="nc" id="L275">            sortByColumn(column);</span>
<span class="nc" id="L276">            tableView.validate();</span>
<span class="nc" id="L277">            tableView.repaint();</span>
        }
<span class="nc" id="L279">    }</span>

    public void mousePressed(MouseEvent e) {
<span class="nc" id="L282">    }</span>

    public void mouseEntered(MouseEvent e) {
<span class="nc" id="L285">    }</span>

    public void mouseExited(MouseEvent e) {
<span class="nc" id="L288">    }</span>

    public void mouseReleased(MouseEvent e) {
<span class="nc" id="L291">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>