<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Scanner.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">Scanner.java</span></div><h1>Scanner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.io.IOException;
import java.io.InputStream;
import java.util.Hashtable;

/**
 * A Scanner for Java tokens. Errors are reported
 * to the environment object.&lt;p&gt;
 *
 * The scanner keeps track of the current token,
 * the value of the current token (if any), and the start
 * position of the current token.&lt;p&gt;
 *
 * The scan() method advances the scanner to the next
 * token in the input.&lt;p&gt;
 *
 * The match() method is used to quickly match opening
 * brackets (ie: '(', '{', or '[') with their closing
 * counter part. This is useful during error recovery.&lt;p&gt;
 *
 * An position consists of: ((linenr &lt;&lt; WHEREOFFSETBITS) | offset)
 * this means that both the line number and the exact offset into
 * the file are encoded in each position value.&lt;p&gt;
 *
 * The compiler treats either &quot;\n&quot;, &quot;\r&quot; or &quot;\r\n&quot; as the
 * end of a line.&lt;p&gt;
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author      Arthur van Hoff
 */

public
class Scanner implements Constants {
    /**
     * The increment for each character.
     */
    public static final long OFFSETINC = 1;

    /**
     * The increment for each line.
     */
    public static final long LINEINC = 1L &lt;&lt; WHEREOFFSETBITS;

    /**
     * End of input
     */
    public static final int EOF = -1;

    /**
     * Where errors are reported
     */
    public Environment env;

    /**
     * Input reader
     */
    protected ScannerInputReader in;

    /**
     * If true, present all comments as tokens.
     * Contents are not saved, but positions are recorded accurately,
     * so the comment can be recovered from the text.
     * Line terminations are also returned as comment tokens,
     * and may be distinguished by their start and end positions,
     * which are equal (meaning, these tokens contain no chars).
     */
<span class="nc" id="L96">   public boolean scanComments = false;</span>

    /**
     * Current token
     */
    public int token;

    /**
     * The position of the current token
     */
    public long pos;

    /**
     * The position of the previous token
     */
    public long prevPos;

    /**
     * The current character
     */
    protected int ch;

    /*
     * Token values.
     */
    public char charValue;
    public int intValue;
    public long longValue;
    public float floatValue;
    public double doubleValue;
    public String stringValue;
    public Identifier idValue;
    public int radix;   // Radix, when reading int or long

    /*
     * A doc comment preceding the most recent token
     */
    public String docComment;

    /*
     * A growable character buffer.
     */
    private int count;
<span class="nc" id="L139">    private char buffer[] = new char[1024];</span>
    private void growBuffer() {
<span class="nc" id="L141">        char newBuffer[] = new char[buffer.length * 2];</span>
<span class="nc" id="L142">        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);</span>
<span class="nc" id="L143">        buffer = newBuffer;</span>
<span class="nc" id="L144">    }</span>

    // The following two methods have been hand-inlined in
    // scanDocComment.  If you make changes here, you should
    // check to see if scanDocComment also needs modification.
    private void putc(int ch) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (count == buffer.length) {</span>
<span class="nc" id="L151">            growBuffer();</span>
        }
<span class="nc" id="L153">        buffer[count++] = (char)ch;</span>
<span class="nc" id="L154">    }</span>

    private String bufferString() {
<span class="nc" id="L157">        return new String(buffer, 0, count);</span>
    }

    /**
     * Create a scanner to scan an input stream.
     */
<span class="nc" id="L163">    public Scanner(Environment env, InputStream in) throws IOException {</span>
<span class="nc" id="L164">        this.env = env;</span>
<span class="nc" id="L165">        useInputStream(in);</span>
<span class="nc" id="L166">    }</span>

    /**
     * Setup input from the given input stream,
     * and scan the first token from it.
     */
    protected void useInputStream(InputStream in) throws IOException {
        try {
<span class="nc" id="L174">            this.in = new ScannerInputReader(env, in);</span>
<span class="nc" id="L175">        } catch (Exception e) {</span>
<span class="nc" id="L176">            env.setCharacterEncoding(null);</span>
<span class="nc" id="L177">            this.in = new ScannerInputReader(env, in);</span>
<span class="nc" id="L178">        }</span>

<span class="nc" id="L180">        ch = this.in.read();</span>
<span class="nc" id="L181">        prevPos = this.in.pos;</span>

<span class="nc" id="L183">        scan();</span>
<span class="nc" id="L184">    }</span>

    /**
     * Create a scanner to scan an input stream.
     */
<span class="nc" id="L189">    protected Scanner(Environment env) {</span>
<span class="nc" id="L190">        this.env = env;</span>
        // Expect the subclass to call useInputStream at the right time.
<span class="nc" id="L192">    }</span>

    /**
     * Define a keyword.
     */
    private static void defineKeyword(int val) {
<span class="nc" id="L198">        Identifier.lookup(opNames[val]).setType(val);</span>
<span class="nc" id="L199">    }</span>

    /**
     * Initialized keyword and token Hashtables
     */
    static {
        // Statement keywords
<span class="nc" id="L206">        defineKeyword(FOR);</span>
<span class="nc" id="L207">        defineKeyword(IF);</span>
<span class="nc" id="L208">        defineKeyword(ELSE);</span>
<span class="nc" id="L209">        defineKeyword(WHILE);</span>
<span class="nc" id="L210">        defineKeyword(DO);</span>
<span class="nc" id="L211">        defineKeyword(SWITCH);</span>
<span class="nc" id="L212">        defineKeyword(CASE);</span>
<span class="nc" id="L213">        defineKeyword(DEFAULT);</span>
<span class="nc" id="L214">        defineKeyword(BREAK);</span>
<span class="nc" id="L215">        defineKeyword(CONTINUE);</span>
<span class="nc" id="L216">        defineKeyword(RETURN);</span>
<span class="nc" id="L217">        defineKeyword(TRY);</span>
<span class="nc" id="L218">        defineKeyword(CATCH);</span>
<span class="nc" id="L219">        defineKeyword(FINALLY);</span>
<span class="nc" id="L220">        defineKeyword(THROW);</span>

        // Type defineKeywords
<span class="nc" id="L223">        defineKeyword(BYTE);</span>
<span class="nc" id="L224">        defineKeyword(CHAR);</span>
<span class="nc" id="L225">        defineKeyword(SHORT);</span>
<span class="nc" id="L226">        defineKeyword(INT);</span>
<span class="nc" id="L227">        defineKeyword(LONG);</span>
<span class="nc" id="L228">        defineKeyword(FLOAT);</span>
<span class="nc" id="L229">        defineKeyword(DOUBLE);</span>
<span class="nc" id="L230">        defineKeyword(VOID);</span>
<span class="nc" id="L231">        defineKeyword(BOOLEAN);</span>

        // Expression keywords
<span class="nc" id="L234">        defineKeyword(INSTANCEOF);</span>
<span class="nc" id="L235">        defineKeyword(TRUE);</span>
<span class="nc" id="L236">        defineKeyword(FALSE);</span>
<span class="nc" id="L237">        defineKeyword(NEW);</span>
<span class="nc" id="L238">        defineKeyword(THIS);</span>
<span class="nc" id="L239">        defineKeyword(SUPER);</span>
<span class="nc" id="L240">        defineKeyword(NULL);</span>

        // Declaration keywords
<span class="nc" id="L243">        defineKeyword(IMPORT);</span>
<span class="nc" id="L244">        defineKeyword(CLASS);</span>
<span class="nc" id="L245">        defineKeyword(EXTENDS);</span>
<span class="nc" id="L246">        defineKeyword(IMPLEMENTS);</span>
<span class="nc" id="L247">        defineKeyword(INTERFACE);</span>
<span class="nc" id="L248">        defineKeyword(PACKAGE);</span>
<span class="nc" id="L249">        defineKeyword(THROWS);</span>

        // Modifier keywords
<span class="nc" id="L252">        defineKeyword(PRIVATE);</span>
<span class="nc" id="L253">        defineKeyword(PUBLIC);</span>
<span class="nc" id="L254">        defineKeyword(PROTECTED);</span>
<span class="nc" id="L255">        defineKeyword(STATIC);</span>
<span class="nc" id="L256">        defineKeyword(TRANSIENT);</span>
<span class="nc" id="L257">        defineKeyword(SYNCHRONIZED);</span>
<span class="nc" id="L258">        defineKeyword(NATIVE);</span>
<span class="nc" id="L259">        defineKeyword(ABSTRACT);</span>
<span class="nc" id="L260">        defineKeyword(VOLATILE);</span>
<span class="nc" id="L261">        defineKeyword(FINAL);</span>
<span class="nc" id="L262">        defineKeyword(STRICTFP);</span>

        // reserved keywords
<span class="nc" id="L265">        defineKeyword(CONST);</span>
<span class="nc" id="L266">        defineKeyword(GOTO);</span>
<span class="nc" id="L267">    }</span>

    /**
     * Scan a comment. This method should be
     * called once the initial /, * and the next
     * character have been read.
     */
    private void skipComment() throws IOException {
        while (true) {
<span class="nc bnc" id="L276" title="All 3 branches missed.">            switch (ch) {</span>
              case EOF:
<span class="nc" id="L278">                env.error(pos, &quot;eof.in.comment&quot;);</span>
<span class="nc" id="L279">                return;</span>

              case '*':
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if ((ch = in.read()) == '/')  {</span>
<span class="nc" id="L283">                    ch = in.read();</span>
<span class="nc" id="L284">                    return;</span>
                }
                break;

              default:
<span class="nc" id="L289">                ch = in.read();</span>
<span class="nc" id="L290">                break;</span>
            }
        }
    }

    /**
     * Scan a doc comment. This method should be called
     * once the initial /, * and * have been read. It gathers
     * the content of the comment (witout leading spaces and '*'s)
     * in the string buffer.
     */
    private String scanDocComment() throws IOException {
        // Note: this method has been hand-optimized to yield
        // better performance.  This was done after it was noted
        // that javadoc spent a great deal of its time here.
        // This should also help the performance of the compiler
        // as well -- it scans the doc comments to find
        // @deprecated tags.
        //
        // The logic of the method has been completely rewritten
        // to avoid the use of flags that need to be looked at
        // for every character read.  Members that are accessed
        // more than once have been stored in local variables.
        // The methods putc() and bufferString() have been
        // inlined by hand.  Extra cases have been added to
        // switch statements to trick the compiler into generating
        // a tableswitch instead of a lookupswitch.
        //
        // This implementation aims to preserve the previous
        // behavior of this method.

        int c;

        // Put `in' in a local variable.
<span class="nc" id="L324">        final ScannerInputReader in = this.in;</span>

        // We maintain the buffer locally rather than calling putc().
<span class="nc" id="L327">        char[] buffer = this.buffer;</span>
<span class="nc" id="L328">        int count = 0;</span>

        // We are called pointing at the second star of the doc
        // comment:
        //
        // Input: /** the rest of the comment ... */
        //          ^
        //
        // We rely on this in the code below.

        // Consume any number of stars.
<span class="nc bnc" id="L339" title="All 2 branches missed.">        while ((c = in.read()) == '*')</span>
<span class="nc" id="L340">            ;</span>

        // Is the comment of the form /**/, /***/, /****/, etc.?
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (c == '/') {</span>
            // Set ch and return
<span class="nc" id="L345">            ch = in.read();</span>
<span class="nc" id="L346">            return &quot;&quot;;</span>
        }

        // Skip a newline on the first line of the comment.
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (c == '\n') {</span>
<span class="nc" id="L351">            c = in.read();</span>
        }

    outerLoop:
        // The outerLoop processes the doc comment, looping once
        // for each line.  For each line, it first strips off
        // whitespace, then it consumes any stars, then it
        // puts the rest of the line into our buffer.
        while (true) {

            // The wsLoop consumes whitespace from the beginning
            // of each line.
        wsLoop:
            while (true) {
<span class="nc bnc" id="L365" title="All 2 branches missed.">                switch (c) {</span>
                case ' ':
                case '\t':
                    // We could check for other forms of whitespace
                    // as well, but this is left as is for minimum
                    // disturbance of functionality.
                    //
                    // Just skip whitespace.
<span class="nc" id="L373">                    c = in.read();</span>
<span class="nc" id="L374">                    break;</span>

                // We have added extra cases here to trick the
                // compiler into using a tableswitch instead of
                // a lookupswitch.  They can be removed without
                // a change in meaning.
                case 10: case 11: case 12: case 13: case 14: case 15:
                case 16: case 17: case 18: case 19: case 20: case 21:
                case 22: case 23: case 24: case 25: case 26: case 27:
                case 28: case 29: case 30: case 31:
                default:
                    // We've seen something that isn't whitespace,
                    // jump out.
<span class="nc" id="L387">                    break wsLoop;</span>
                }
            } // end wsLoop.

            // Are there stars here?  If so, consume them all
            // and check for the end of comment.
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (c == '*') {</span>
                // Skip all of the stars...
                do {
<span class="nc" id="L396">                    c = in.read();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                } while (c == '*');</span>

                // ...then check for the closing slash.
<span class="nc bnc" id="L400" title="All 2 branches missed.">                if (c == '/') {</span>
                    // We're done with the doc comment.
                    // Set ch and break out.
<span class="nc" id="L403">                    ch = in.read();</span>
<span class="nc" id="L404">                    break outerLoop;</span>
                }
            }

            // The textLoop processes the rest of the characters
            // on the line, adding them to our buffer.
        textLoop:
            while (true) {
<span class="nc bnc" id="L412" title="All 4 branches missed.">                switch (c) {</span>
                case EOF:
                    // We've seen a premature EOF.  Break out
                    // of the loop.
<span class="nc" id="L416">                    env.error(pos, &quot;eof.in.comment&quot;);</span>
<span class="nc" id="L417">                    ch = EOF;</span>
<span class="nc" id="L418">                    break outerLoop;</span>

                case '*':
                    // Is this just a star?  Or is this the
                    // end of a comment?
<span class="nc" id="L423">                    c = in.read();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    if (c == '/') {</span>
                        // This is the end of the comment,
                        // set ch and return our buffer.
<span class="nc" id="L427">                        ch = in.read();</span>
<span class="nc" id="L428">                        break outerLoop;</span>
                    }
                    // This is just an ordinary star.  Add it to
                    // the buffer.
<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (count == buffer.length) {</span>
<span class="nc" id="L433">                        growBuffer();</span>
<span class="nc" id="L434">                        buffer = this.buffer;</span>
                    }
<span class="nc" id="L436">                    buffer[count++] = '*';</span>
<span class="nc" id="L437">                    break;</span>

                case '\n':
                    // We've seen a newline.  Add it to our
                    // buffer and break out of this loop,
                    // starting fresh on a new line.
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (count == buffer.length) {</span>
<span class="nc" id="L444">                        growBuffer();</span>
<span class="nc" id="L445">                        buffer = this.buffer;</span>
                    }
<span class="nc" id="L447">                    buffer[count++] = '\n';</span>
<span class="nc" id="L448">                    c = in.read();</span>
<span class="nc" id="L449">                    break textLoop;</span>

                // Again, the extra cases here are a trick
                // to get the compiler to generate a tableswitch.
                case 0: case 1: case 2: case 3: case 4: case 5:
                case 6: case 7: case 8: case 11: case 12: case 13:
                case 14: case 15: case 16: case 17: case 18: case 19:
                case 20: case 21: case 22: case 23: case 24: case 25:
                case 26: case 27: case 28: case 29: case 30: case 31:
                case 32: case 33: case 34: case 35: case 36: case 37:
                case 38: case 39: case 40:
                default:
                    // Add the character to our buffer.
<span class="nc bnc" id="L462" title="All 2 branches missed.">                    if (count == buffer.length) {</span>
<span class="nc" id="L463">                        growBuffer();</span>
<span class="nc" id="L464">                        buffer = this.buffer;</span>
                    }
<span class="nc" id="L466">                    buffer[count++] = (char)c;</span>
<span class="nc" id="L467">                    c = in.read();</span>
<span class="nc" id="L468">                    break;</span>
                }
            } // end textLoop
        } // end outerLoop

        // We have scanned our doc comment.  It is stored in
        // buffer.  The previous implementation of scanDocComment
        // stripped off all trailing spaces and stars from the comment.
        // We will do this as well, so as to cause a minimum of
        // disturbance.  Is this what we want?
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (count &gt; 0) {</span>
<span class="nc" id="L479">            int i = count - 1;</span>
        trailLoop:
<span class="nc bnc" id="L481" title="All 2 branches missed.">            while (i &gt; -1) {</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">                switch (buffer[i]) {</span>
                case ' ':
                case '\t':
                case '*':
<span class="nc" id="L486">                    i--;</span>
<span class="nc" id="L487">                    break;</span>
                // And again, the extra cases here are a trick
                // to get the compiler to generate a tableswitch.
                case 0: case 1: case 2: case 3: case 4: case 5:
                case 6: case 7: case 8: case 10: case 11: case 12:
                case 13: case 14: case 15: case 16: case 17: case 18:
                case 19: case 20: case 21: case 22: case 23: case 24:
                case 25: case 26: case 27: case 28: case 29: case 30:
                case 31: case 33: case 34: case 35: case 36: case 37:
                case 38: case 39: case 40:
                default:
<span class="nc" id="L498">                    break trailLoop;</span>
                }
            }
<span class="nc" id="L501">            count = i + 1;</span>

            // Return the text of the doc comment.
<span class="nc" id="L504">            return new String(buffer, 0, count);</span>
        } else {
<span class="nc" id="L506">            return &quot;&quot;;</span>
        }
    }

    /**
     * Scan a number. The first digit of the number should be the current
     * character.  We may be scanning hex, decimal, or octal at this point
     */
    private void scanNumber() throws IOException {
<span class="nc" id="L515">        boolean seenNonOctal = false;</span>
<span class="nc" id="L516">        boolean overflow = false;</span>
<span class="nc" id="L517">        boolean seenDigit = false; // used to detect invalid hex number 0xL</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        radix = (ch == '0' ? 8 : 10);</span>
<span class="nc" id="L519">        long value = ch - '0';</span>
<span class="nc" id="L520">        count = 0;</span>
<span class="nc" id="L521">        putc(ch);               // save character in buffer</span>
    numberLoop:
        for (;;) {
<span class="nc bnc" id="L524" title="All 8 branches missed.">            switch (ch = in.read()) {</span>
              case '.':
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (radix == 16)</span>
<span class="nc" id="L527">                    break numberLoop; // an illegal character</span>
<span class="nc" id="L528">                scanReal();</span>
<span class="nc" id="L529">                return;</span>

              case '8': case '9':
                // We can't yet throw an error if reading an octal.  We might
                // discover we're really reading a real.
<span class="nc" id="L534">                seenNonOctal = true;</span>
              case '0': case '1': case '2': case '3':
              case '4': case '5': case '6': case '7':
<span class="nc" id="L537">                seenDigit = true;</span>
<span class="nc" id="L538">                putc(ch);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (radix == 10) {</span>
<span class="nc bnc" id="L540" title="All 4 branches missed.">                    overflow = overflow || (value * 10)/10 != value;</span>
<span class="nc" id="L541">                    value = (value * 10) + (ch - '0');</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">                    overflow = overflow || (value - 1 &lt; -1);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                } else if (radix == 8) {</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">                    overflow = overflow || (value &gt;&gt;&gt; 61) != 0;</span>
<span class="nc" id="L545">                    value = (value &lt;&lt; 3) + (ch - '0');</span>
                } else {
<span class="nc bnc" id="L547" title="All 4 branches missed.">                    overflow = overflow || (value &gt;&gt;&gt; 60) != 0;</span>
<span class="nc" id="L548">                    value = (value &lt;&lt; 4) + (ch - '0');</span>
                }
<span class="nc" id="L550">                break;</span>

              case 'd': case 'D': case 'e': case 'E': case 'f': case 'F':
<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (radix != 16) {</span>
<span class="nc" id="L554">                    scanReal();</span>
<span class="nc" id="L555">                    return;</span>
                }
                // fall through
              case 'a': case 'A': case 'b': case 'B': case 'c': case 'C':
<span class="nc" id="L559">                seenDigit = true;</span>
<span class="nc" id="L560">                putc(ch);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (radix != 16)</span>
<span class="nc" id="L562">                    break numberLoop; // an illegal character</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">                overflow = overflow || (value &gt;&gt;&gt; 60) != 0;</span>
<span class="nc" id="L564">                value = (value &lt;&lt; 4) + 10 +</span>
<span class="nc" id="L565">                         Character.toLowerCase((char)ch) - 'a';</span>
<span class="nc" id="L566">                break;</span>

              case 'l': case 'L':
<span class="nc" id="L569">                ch = in.read(); // skip over 'l'</span>
<span class="nc" id="L570">                longValue = value;</span>
<span class="nc" id="L571">                token = LONGVAL;</span>
<span class="nc" id="L572">                break numberLoop;</span>

              case 'x': case 'X':
                // if the first character is a '0' and this is the second
                // letter, then read in a hexadecimal number.  Otherwise, error.
<span class="nc bnc" id="L577" title="All 4 branches missed.">                if (count == 1 &amp;&amp; radix == 8) {</span>
<span class="nc" id="L578">                    radix = 16;</span>
<span class="nc" id="L579">                    seenDigit = false;</span>
<span class="nc" id="L580">                    break;</span>
                } else {
                    // we'll get an illegal character error
                    break numberLoop;
                }

              default:
<span class="nc" id="L587">                intValue = (int)value;</span>
<span class="nc" id="L588">                token = INTVAL;</span>
<span class="nc" id="L589">                break numberLoop;</span>
            }
        } // while true

        // We have just finished reading the number.  The next thing better
        // not be a letter or digit.
        // Note:  There will be deprecation warnings against these uses
        // of Character.isJavaLetterOrDigit and Character.isJavaLetter.
        // Do not fix them yet; allow the compiler to run on pre-JDK1.1 VMs.
<span class="nc bnc" id="L598" title="All 4 branches missed.">        if (Character.isJavaLetterOrDigit((char)ch) || ch == '.') {</span>
<span class="nc" id="L599">            env.error(in.pos, &quot;invalid.number&quot;);</span>
<span class="nc" id="L600">            do { ch = in.read(); }</span>
<span class="nc bnc" id="L601" title="All 4 branches missed.">            while (Character.isJavaLetterOrDigit((char)ch) || ch == '.');</span>
<span class="nc" id="L602">            intValue = 0;</span>
<span class="nc" id="L603">            token = INTVAL;</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">        } else if (radix == 8 &amp;&amp; seenNonOctal) {</span>
            // A bogus octal literal.
<span class="nc" id="L606">            intValue = 0;</span>
<span class="nc" id="L607">            token = INTVAL;</span>
<span class="nc" id="L608">            env.error(pos, &quot;invalid.octal.number&quot;);</span>
<span class="nc bnc" id="L609" title="All 4 branches missed.">        } else if (radix == 16 &amp;&amp; seenDigit == false) {</span>
            // A hex literal with no digits, 0xL, for example.
<span class="nc" id="L611">            intValue = 0;</span>
<span class="nc" id="L612">            token = INTVAL;</span>
<span class="nc" id="L613">            env.error(pos, &quot;invalid.hex.number&quot;);</span>
        } else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (token == INTVAL) {</span>
                // Check for overflow.  Note that base 10 literals
                // have different rules than base 8 and 16.
<span class="nc bnc" id="L618" title="All 8 branches missed.">                overflow = overflow ||</span>
                    (value &amp; 0xFFFFFFFF00000000L) != 0 ||
                    (radix == 10 &amp;&amp; value &gt; 2147483648L);

<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (overflow) {</span>
<span class="nc" id="L623">                    intValue = 0;</span>

                    // Give a specific error message which tells
                    // the user the range.
<span class="nc bnc" id="L627" title="All 4 branches missed.">                    switch (radix) {</span>
                    case 8:
<span class="nc" id="L629">                        env.error(pos, &quot;overflow.int.oct&quot;);</span>
<span class="nc" id="L630">                        break;</span>
                    case 10:
<span class="nc" id="L632">                        env.error(pos, &quot;overflow.int.dec&quot;);</span>
<span class="nc" id="L633">                        break;</span>
                    case 16:
<span class="nc" id="L635">                        env.error(pos, &quot;overflow.int.hex&quot;);</span>
<span class="nc" id="L636">                        break;</span>
                    default:
<span class="nc" id="L638">                        throw new CompilerError(&quot;invalid radix&quot;);</span>
                    }
                }
            } else {
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (overflow) {</span>
<span class="nc" id="L643">                    longValue = 0;</span>

                    // Give a specific error message which tells
                    // the user the range.
<span class="nc bnc" id="L647" title="All 4 branches missed.">                    switch (radix) {</span>
                    case 8:
<span class="nc" id="L649">                        env.error(pos, &quot;overflow.long.oct&quot;);</span>
<span class="nc" id="L650">                        break;</span>
                    case 10:
<span class="nc" id="L652">                        env.error(pos, &quot;overflow.long.dec&quot;);</span>
<span class="nc" id="L653">                        break;</span>
                    case 16:
<span class="nc" id="L655">                        env.error(pos, &quot;overflow.long.hex&quot;);</span>
<span class="nc" id="L656">                        break;</span>
                    default:
<span class="nc" id="L658">                        throw new CompilerError(&quot;invalid radix&quot;);</span>
                    }
                }
            }
        }
<span class="nc" id="L663">    }</span>

    /**
     * Scan a float.  We are either looking at the decimal, or we have already
     * seen it and put it into the buffer.  We haven't seen an exponent.
     * Scan a float.  Should be called with the current character is either
     * the 'e', 'E' or '.'
     */
    private void scanReal() throws IOException {
<span class="nc" id="L672">        boolean seenExponent = false;</span>
<span class="nc" id="L673">        boolean isSingleFloat = false;</span>
        char lastChar;
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (ch == '.') {</span>
<span class="nc" id="L676">            putc(ch);</span>
<span class="nc" id="L677">            ch = in.read();</span>
        }

    numberLoop:
<span class="nc" id="L681">        for ( ; ; ch = in.read()) {</span>
<span class="nc bnc" id="L682" title="All 6 branches missed.">            switch (ch) {</span>
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
<span class="nc" id="L685">                    putc(ch);</span>
<span class="nc" id="L686">                    break;</span>

                case 'e': case 'E':
<span class="nc bnc" id="L689" title="All 2 branches missed.">                    if (seenExponent)</span>
<span class="nc" id="L690">                        break numberLoop; // we'll get a format error</span>
<span class="nc" id="L691">                    putc(ch);</span>
<span class="nc" id="L692">                    seenExponent = true;</span>
<span class="nc" id="L693">                    break;</span>

                case '+': case '-':
<span class="nc" id="L696">                    lastChar = buffer[count - 1];</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">                    if (lastChar != 'e' &amp;&amp; lastChar != 'E')</span>
<span class="nc" id="L698">                        break numberLoop; // this isn't an error, though!</span>
<span class="nc" id="L699">                    putc(ch);</span>
<span class="nc" id="L700">                    break;</span>

                case 'f': case 'F':
<span class="nc" id="L703">                    ch = in.read(); // skip over 'f'</span>
<span class="nc" id="L704">                    isSingleFloat = true;</span>
<span class="nc" id="L705">                    break numberLoop;</span>

                case 'd': case 'D':
<span class="nc" id="L708">                    ch = in.read(); // skip over 'd'</span>
                    // fall through
                default:
<span class="nc" id="L711">                    break numberLoop;</span>
            } // sswitch
        } // loop

        // we have just finished reading the number.  The next thing better
        // not be a letter or digit.
<span class="nc bnc" id="L717" title="All 4 branches missed.">        if (Character.isJavaLetterOrDigit((char)ch) || ch == '.') {</span>
<span class="nc" id="L718">            env.error(in.pos, &quot;invalid.number&quot;);</span>
<span class="nc" id="L719">            do { ch = in.read(); }</span>
<span class="nc bnc" id="L720" title="All 4 branches missed.">            while (Character.isJavaLetterOrDigit((char)ch) || ch == '.');</span>
<span class="nc" id="L721">            doubleValue = 0;</span>
<span class="nc" id="L722">            token = DOUBLEVAL;</span>
        } else {
<span class="nc bnc" id="L724" title="All 2 branches missed.">            token = isSingleFloat ? FLOATVAL : DOUBLEVAL;</span>
            try {
<span class="nc" id="L726">                lastChar = buffer[count - 1];</span>
<span class="nc bnc" id="L727" title="All 8 branches missed.">                if (lastChar == 'e' || lastChar == 'E'</span>
                       || lastChar == '+' || lastChar == '-') {
<span class="nc" id="L729">                    env.error(in.pos -1, &quot;float.format&quot;);</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                } else if (isSingleFloat) {</span>
<span class="nc" id="L731">                    String string = bufferString();</span>
<span class="nc" id="L732">                    floatValue = Float.valueOf(string).floatValue();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                    if (Float.isInfinite(floatValue)) {</span>
<span class="nc" id="L734">                        env.error(pos, &quot;overflow.float&quot;);</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">                    } else if (floatValue == 0 &amp;&amp; !looksLikeZero(string)) {</span>
<span class="nc" id="L736">                        env.error(pos, &quot;underflow.float&quot;);</span>
                    }
<span class="nc" id="L738">                } else {</span>
<span class="nc" id="L739">                    String string = bufferString();</span>
<span class="nc" id="L740">                    doubleValue = Double.valueOf(string).doubleValue();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                    if (Double.isInfinite(doubleValue)) {</span>
<span class="nc" id="L742">                        env.error(pos, &quot;overflow.double&quot;);</span>
<span class="nc bnc" id="L743" title="All 4 branches missed.">                    } else if (doubleValue == 0 &amp;&amp; !looksLikeZero(string)) {</span>
<span class="nc" id="L744">                        env.error(pos, &quot;underflow.double&quot;);</span>
                    }
                }
<span class="nc" id="L747">            } catch (NumberFormatException ee) {</span>
<span class="nc" id="L748">                env.error(pos, &quot;float.format&quot;);</span>
<span class="nc" id="L749">                doubleValue = 0;</span>
<span class="nc" id="L750">                floatValue = 0;</span>
<span class="nc" id="L751">            }</span>
        }
<span class="nc" id="L753">        return;</span>
    }

    // We have a token that parses as a number.  Is this token possibly zero?
    // i.e. does it have a non-zero value in the mantissa?
    private static boolean looksLikeZero(String token) {
<span class="nc" id="L759">        int length = token.length();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc bnc" id="L761" title="All 4 branches missed.">            switch (token.charAt(i)) {</span>
                case 0: case '.':
<span class="nc" id="L763">                    continue;</span>
                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
<span class="nc" id="L766">                    return false;</span>
                case 'e': case 'E': case 'f': case 'F':
<span class="nc" id="L768">                    return true;</span>
            }
        }
<span class="nc" id="L771">        return true;</span>
    }

    /**
     * Scan an escape character.
     * @return the character or -1 if it escaped an
     * end-of-line.
     */
    private int scanEscapeChar() throws IOException {
<span class="nc" id="L780">        long p = in.pos;</span>

<span class="nc bnc" id="L782" title="All 10 branches missed.">        switch (ch = in.read()) {</span>
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7': {
<span class="nc" id="L785">            int n = ch - '0';</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">            for (int i = 2 ; i &gt; 0 ; i--) {</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                switch (ch = in.read()) {</span>
                  case '0': case '1': case '2': case '3':
                  case '4': case '5': case '6': case '7':
<span class="nc" id="L790">                    n = (n &lt;&lt; 3) + ch - '0';</span>
<span class="nc" id="L791">                    break;</span>

                  default:
<span class="nc bnc" id="L794" title="All 2 branches missed.">                    if (n &gt; 0xFF) {</span>
<span class="nc" id="L795">                        env.error(p, &quot;invalid.escape.char&quot;);</span>
                    }
<span class="nc" id="L797">                    return n;</span>
                }
            }
<span class="nc" id="L800">            ch = in.read();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (n &gt; 0xFF) {</span>
<span class="nc" id="L802">                env.error(p, &quot;invalid.escape.char&quot;);</span>
            }
<span class="nc" id="L804">            return n;</span>
          }

<span class="nc" id="L807">          case 'r':  ch = in.read(); return '\r';</span>
<span class="nc" id="L808">          case 'n':  ch = in.read(); return '\n';</span>
<span class="nc" id="L809">          case 'f':  ch = in.read(); return '\f';</span>
<span class="nc" id="L810">          case 'b':  ch = in.read(); return '\b';</span>
<span class="nc" id="L811">          case 't':  ch = in.read(); return '\t';</span>
<span class="nc" id="L812">          case '\\': ch = in.read(); return '\\';</span>
<span class="nc" id="L813">          case '\&quot;': ch = in.read(); return '\&quot;';</span>
<span class="nc" id="L814">          case '\'': ch = in.read(); return '\'';</span>
        }

<span class="nc" id="L817">        env.error(p, &quot;invalid.escape.char&quot;);</span>
<span class="nc" id="L818">        ch = in.read();</span>
<span class="nc" id="L819">        return -1;</span>
    }

    /**
     * Scan a string. The current character
     * should be the opening &quot; of the string.
     */
    private void scanString() throws IOException {
<span class="nc" id="L827">        token = STRINGVAL;</span>
<span class="nc" id="L828">        count = 0;</span>
<span class="nc" id="L829">        ch = in.read();</span>

        // Scan a String
        while (true) {
<span class="nc bnc" id="L833" title="All 5 branches missed.">            switch (ch) {</span>
              case EOF:
<span class="nc" id="L835">                env.error(pos, &quot;eof.in.string&quot;);</span>
<span class="nc" id="L836">                stringValue = bufferString();</span>
<span class="nc" id="L837">                return;</span>

              case '\r':
              case '\n':
<span class="nc" id="L841">                ch = in.read();</span>
<span class="nc" id="L842">                env.error(pos, &quot;newline.in.string&quot;);</span>
<span class="nc" id="L843">                stringValue = bufferString();</span>
<span class="nc" id="L844">                return;</span>

              case '&quot;':
<span class="nc" id="L847">                ch = in.read();</span>
<span class="nc" id="L848">                stringValue = bufferString();</span>
<span class="nc" id="L849">                return;</span>

              case '\\': {
<span class="nc" id="L852">                int c = scanEscapeChar();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                if (c &gt;= 0) {</span>
<span class="nc" id="L854">                    putc((char)c);</span>
                }
                break;
              }

              default:
<span class="nc" id="L860">                putc(ch);</span>
<span class="nc" id="L861">                ch = in.read();</span>
<span class="nc" id="L862">                break;</span>
            }
        }
    }

    /**
     * Scan a character. The current character should be
     * the opening ' of the character constant.
     */
    private void scanCharacter() throws IOException {
<span class="nc" id="L872">        token = CHARVAL;</span>

<span class="nc bnc" id="L874" title="All 4 branches missed.">        switch (ch = in.read()) {</span>
          case '\\':
<span class="nc" id="L876">            int c = scanEscapeChar();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            charValue = (char)((c &gt;= 0) ? c : 0);</span>
<span class="nc" id="L878">            break;</span>

        case '\'':
            // There are two standard problems this case deals with.  One
            // is the malformed single quote constant (i.e. the programmer
            // uses ''' instead of '\'') and the other is the empty
            // character constant (i.e. '').  Just consume any number of
            // single quotes and emit an error message.
<span class="nc" id="L886">            charValue = 0;</span>
<span class="nc" id="L887">            env.error(pos, &quot;invalid.char.constant&quot;);</span>
<span class="nc" id="L888">            ch = in.read();</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            while (ch == '\'') {</span>
<span class="nc" id="L890">                ch = in.read();</span>
            }
<span class="nc" id="L892">            return;</span>

          case '\r':
          case '\n':
<span class="nc" id="L896">            charValue = 0;</span>
<span class="nc" id="L897">            env.error(pos, &quot;invalid.char.constant&quot;);</span>
<span class="nc" id="L898">            return;</span>

          default:
<span class="nc" id="L901">            charValue = (char)ch;</span>
<span class="nc" id="L902">            ch = in.read();</span>
            break;
        }

<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (ch == '\'') {</span>
<span class="nc" id="L907">            ch = in.read();</span>
        } else {
<span class="nc" id="L909">            env.error(pos, &quot;invalid.char.constant&quot;);</span>
            while (true) {
<span class="nc bnc" id="L911" title="All 3 branches missed.">                switch (ch) {</span>
                  case '\'':
<span class="nc" id="L913">                    ch = in.read();</span>
<span class="nc" id="L914">                    return;</span>
                  case ';':
                  case '\n':
                  case EOF:
<span class="nc" id="L918">                    return;</span>
                  default:
<span class="nc" id="L920">                    ch = in.read();</span>
                }
            }
        }
<span class="nc" id="L924">    }</span>

    /**
     * Scan an Identifier. The current character should
     * be the first character of the identifier.
     */
    private void scanIdentifier() throws IOException {
<span class="nc" id="L931">        count = 0;</span>

        while (true) {
<span class="nc" id="L934">            putc(ch);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            switch (ch = in.read()) {</span>
              case 'a': case 'b': case 'c': case 'd': case 'e':
              case 'f': case 'g': case 'h': case 'i': case 'j':
              case 'k': case 'l': case 'm': case 'n': case 'o':
              case 'p': case 'q': case 'r': case 's': case 't':
              case 'u': case 'v': case 'w': case 'x': case 'y':
              case 'z':
              case 'A': case 'B': case 'C': case 'D': case 'E':
              case 'F': case 'G': case 'H': case 'I': case 'J':
              case 'K': case 'L': case 'M': case 'N': case 'O':
              case 'P': case 'Q': case 'R': case 'S': case 'T':
              case 'U': case 'V': case 'W': case 'X': case 'Y':
              case 'Z':
              case '0': case '1': case '2': case '3': case '4':
              case '5': case '6': case '7': case '8': case '9':
              case '$': case '_':
<span class="nc" id="L951">                break;</span>

              default:
<span class="nc bnc" id="L954" title="All 2 branches missed.">                if (!Character.isJavaLetterOrDigit((char)ch)) {</span>
<span class="nc" id="L955">                    idValue = Identifier.lookup(bufferString());</span>
<span class="nc" id="L956">                    token = idValue.getType();</span>
<span class="nc" id="L957">                    return;</span>
                }
            }
        }
    }

    /**
     * The ending position of the current token
     */
    // Note: This should be part of the pos itself.
    public long getEndPos() {
<span class="nc" id="L968">        return in.pos;</span>
    }

    /**
     * If the current token is IDENT, return the identifier occurrence.
     * It will be freshly allocated.
     */
    public IdentifierToken getIdToken() {
<span class="nc bnc" id="L976" title="All 2 branches missed.">        return (token != IDENT) ? null : new IdentifierToken(pos, idValue);</span>
    }

    /**
     * Scan the next token.
     * @return the position of the previous token.
     */
   public long scan() throws IOException {
<span class="nc" id="L984">       return xscan();</span>
   }

    protected long xscan() throws IOException {
<span class="nc" id="L988">        final ScannerInputReader in = this.in;</span>
<span class="nc" id="L989">        long retPos = pos;</span>
<span class="nc" id="L990">        prevPos = in.pos;</span>
<span class="nc" id="L991">        docComment = null;</span>
        while (true) {
<span class="nc" id="L993">            pos = in.pos;</span>

<span class="nc bnc" id="L995" title="All 33 branches missed.">            switch (ch) {</span>
              case EOF:
<span class="nc" id="L997">                token = EOF;</span>
<span class="nc" id="L998">                return retPos;</span>

              case '\n':
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                if (scanComments) {</span>
<span class="nc" id="L1002">                    ch = ' ';</span>
                    // Avoid this path the next time around.
                    // Do not just call in.read; we want to present
                    // a null token (and also avoid read-ahead).
<span class="nc" id="L1006">                    token = COMMENT;</span>
<span class="nc" id="L1007">                    return retPos;</span>
                }
              case ' ':
              case '\t':
              case '\f':
<span class="nc" id="L1012">                ch = in.read();</span>
<span class="nc" id="L1013">                break;</span>

              case '/':
<span class="nc bnc" id="L1016" title="All 4 branches missed.">                switch (ch = in.read()) {</span>
                  case '/':
                    // Parse a // comment
<span class="nc bnc" id="L1019" title="All 4 branches missed.">                    while (((ch = in.read()) != EOF) &amp;&amp; (ch != '\n'));</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                    if (scanComments) {</span>
<span class="nc" id="L1021">                        token = COMMENT;</span>
<span class="nc" id="L1022">                        return retPos;</span>
                    }
                    break;

                  case '*':
<span class="nc" id="L1027">                    ch = in.read();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                    if (ch == '*') {</span>
<span class="nc" id="L1029">                        docComment = scanDocComment();</span>
                    } else {
<span class="nc" id="L1031">                        skipComment();</span>
                    }
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                    if (scanComments) {</span>
<span class="nc" id="L1034">                        return retPos;</span>
                    }
                    break;

                  case '=':
<span class="nc" id="L1039">                    ch = in.read();</span>
<span class="nc" id="L1040">                    token = ASGDIV;</span>
<span class="nc" id="L1041">                    return retPos;</span>

                  default:
<span class="nc" id="L1044">                    token = DIV;</span>
<span class="nc" id="L1045">                    return retPos;</span>
                }
                break;

              case '&quot;':
<span class="nc" id="L1050">                scanString();</span>
<span class="nc" id="L1051">                return retPos;</span>

              case '\'':
<span class="nc" id="L1054">                scanCharacter();</span>
<span class="nc" id="L1055">                return retPos;</span>

              case '0': case '1': case '2': case '3': case '4':
              case '5': case '6': case '7': case '8': case '9':
<span class="nc" id="L1059">                scanNumber();</span>
<span class="nc" id="L1060">                return retPos;</span>

              case '.':
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                switch (ch = in.read()) {</span>
                  case '0': case '1': case '2': case '3': case '4':
                  case '5': case '6': case '7': case '8': case '9':
<span class="nc" id="L1066">                    count = 0;</span>
<span class="nc" id="L1067">                    putc('.');</span>
<span class="nc" id="L1068">                    scanReal();</span>
<span class="nc" id="L1069">                    break;</span>
                  default:
<span class="nc" id="L1071">                    token = FIELD;</span>
                }
<span class="nc" id="L1073">                return retPos;</span>

              case '{':
<span class="nc" id="L1076">                ch = in.read();</span>
<span class="nc" id="L1077">                token = LBRACE;</span>
<span class="nc" id="L1078">                return retPos;</span>

              case '}':
<span class="nc" id="L1081">                ch = in.read();</span>
<span class="nc" id="L1082">                token = RBRACE;</span>
<span class="nc" id="L1083">                return retPos;</span>

              case '(':
<span class="nc" id="L1086">                ch = in.read();</span>
<span class="nc" id="L1087">                token = LPAREN;</span>
<span class="nc" id="L1088">                return retPos;</span>

              case ')':
<span class="nc" id="L1091">                ch = in.read();</span>
<span class="nc" id="L1092">                token = RPAREN;</span>
<span class="nc" id="L1093">                return retPos;</span>

              case '[':
<span class="nc" id="L1096">                ch = in.read();</span>
<span class="nc" id="L1097">                token = LSQBRACKET;</span>
<span class="nc" id="L1098">                return retPos;</span>

              case ']':
<span class="nc" id="L1101">                ch = in.read();</span>
<span class="nc" id="L1102">                token = RSQBRACKET;</span>
<span class="nc" id="L1103">                return retPos;</span>

              case ',':
<span class="nc" id="L1106">                ch = in.read();</span>
<span class="nc" id="L1107">                token = COMMA;</span>
<span class="nc" id="L1108">                return retPos;</span>

              case ';':
<span class="nc" id="L1111">                ch = in.read();</span>
<span class="nc" id="L1112">                token = SEMICOLON;</span>
<span class="nc" id="L1113">                return retPos;</span>

              case '?':
<span class="nc" id="L1116">                ch = in.read();</span>
<span class="nc" id="L1117">                token = QUESTIONMARK;</span>
<span class="nc" id="L1118">                return retPos;</span>

              case '~':
<span class="nc" id="L1121">                ch = in.read();</span>
<span class="nc" id="L1122">                token = BITNOT;</span>
<span class="nc" id="L1123">                return retPos;</span>

              case ':':
<span class="nc" id="L1126">                ch = in.read();</span>
<span class="nc" id="L1127">                token = COLON;</span>
<span class="nc" id="L1128">                return retPos;</span>

              case '-':
<span class="nc bnc" id="L1131" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '-':
<span class="nc" id="L1133">                    ch = in.read();</span>
<span class="nc" id="L1134">                    token = DEC;</span>
<span class="nc" id="L1135">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1138">                    ch = in.read();</span>
<span class="nc" id="L1139">                    token = ASGSUB;</span>
<span class="nc" id="L1140">                    return retPos;</span>
                }
<span class="nc" id="L1142">                token = SUB;</span>
<span class="nc" id="L1143">                return retPos;</span>

              case '+':
<span class="nc bnc" id="L1146" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '+':
<span class="nc" id="L1148">                    ch = in.read();</span>
<span class="nc" id="L1149">                    token = INC;</span>
<span class="nc" id="L1150">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1153">                    ch = in.read();</span>
<span class="nc" id="L1154">                    token = ASGADD;</span>
<span class="nc" id="L1155">                    return retPos;</span>
                }
<span class="nc" id="L1157">                token = ADD;</span>
<span class="nc" id="L1158">                return retPos;</span>

              case '&lt;':
<span class="nc bnc" id="L1161" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '&lt;':
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                    if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1164">                        ch = in.read();</span>
<span class="nc" id="L1165">                        token = ASGLSHIFT;</span>
<span class="nc" id="L1166">                        return retPos;</span>
                    }
<span class="nc" id="L1168">                    token = LSHIFT;</span>
<span class="nc" id="L1169">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1172">                    ch = in.read();</span>
<span class="nc" id="L1173">                    token = LE;</span>
<span class="nc" id="L1174">                    return retPos;</span>
                }
<span class="nc" id="L1176">                token = LT;</span>
<span class="nc" id="L1177">                return retPos;</span>

              case '&gt;':
<span class="nc bnc" id="L1180" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '&gt;':
<span class="nc bnc" id="L1182" title="All 3 branches missed.">                    switch (ch = in.read()) {</span>
                      case '=':
<span class="nc" id="L1184">                        ch = in.read();</span>
<span class="nc" id="L1185">                        token = ASGRSHIFT;</span>
<span class="nc" id="L1186">                        return retPos;</span>

                      case '&gt;':
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                        if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1190">                            ch = in.read();</span>
<span class="nc" id="L1191">                            token = ASGURSHIFT;</span>
<span class="nc" id="L1192">                            return retPos;</span>
                        }
<span class="nc" id="L1194">                        token = URSHIFT;</span>
<span class="nc" id="L1195">                        return retPos;</span>
                    }
<span class="nc" id="L1197">                    token = RSHIFT;</span>
<span class="nc" id="L1198">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1201">                    ch = in.read();</span>
<span class="nc" id="L1202">                    token = GE;</span>
<span class="nc" id="L1203">                    return retPos;</span>
                }
<span class="nc" id="L1205">                token = GT;</span>
<span class="nc" id="L1206">                return retPos;</span>

              case '|':
<span class="nc bnc" id="L1209" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '|':
<span class="nc" id="L1211">                    ch = in.read();</span>
<span class="nc" id="L1212">                    token = OR;</span>
<span class="nc" id="L1213">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1216">                    ch = in.read();</span>
<span class="nc" id="L1217">                    token = ASGBITOR;</span>
<span class="nc" id="L1218">                    return retPos;</span>
                }
<span class="nc" id="L1220">                token = BITOR;</span>
<span class="nc" id="L1221">                return retPos;</span>

              case '&amp;':
<span class="nc bnc" id="L1224" title="All 3 branches missed.">                switch (ch = in.read()) {</span>
                  case '&amp;':
<span class="nc" id="L1226">                    ch = in.read();</span>
<span class="nc" id="L1227">                    token = AND;</span>
<span class="nc" id="L1228">                    return retPos;</span>

                  case '=':
<span class="nc" id="L1231">                    ch = in.read();</span>
<span class="nc" id="L1232">                    token = ASGBITAND;</span>
<span class="nc" id="L1233">                    return retPos;</span>
                }
<span class="nc" id="L1235">                token = BITAND;</span>
<span class="nc" id="L1236">                return retPos;</span>

              case '=':
<span class="nc bnc" id="L1239" title="All 2 branches missed.">                if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1240">                    ch = in.read();</span>
<span class="nc" id="L1241">                    token = EQ;</span>
<span class="nc" id="L1242">                    return retPos;</span>
                }
<span class="nc" id="L1244">                token = ASSIGN;</span>
<span class="nc" id="L1245">                return retPos;</span>

              case '%':
<span class="nc bnc" id="L1248" title="All 2 branches missed.">                if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1249">                    ch = in.read();</span>
<span class="nc" id="L1250">                    token = ASGREM;</span>
<span class="nc" id="L1251">                    return retPos;</span>
                }
<span class="nc" id="L1253">                token = REM;</span>
<span class="nc" id="L1254">                return retPos;</span>

              case '^':
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1258">                    ch = in.read();</span>
<span class="nc" id="L1259">                    token = ASGBITXOR;</span>
<span class="nc" id="L1260">                    return retPos;</span>
                }
<span class="nc" id="L1262">                token = BITXOR;</span>
<span class="nc" id="L1263">                return retPos;</span>

              case '!':
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1267">                    ch = in.read();</span>
<span class="nc" id="L1268">                    token = NE;</span>
<span class="nc" id="L1269">                    return retPos;</span>
                }
<span class="nc" id="L1271">                token = NOT;</span>
<span class="nc" id="L1272">                return retPos;</span>

              case '*':
<span class="nc bnc" id="L1275" title="All 2 branches missed.">                if ((ch = in.read()) == '=') {</span>
<span class="nc" id="L1276">                    ch = in.read();</span>
<span class="nc" id="L1277">                    token = ASGMUL;</span>
<span class="nc" id="L1278">                    return retPos;</span>
                }
<span class="nc" id="L1280">                token = MUL;</span>
<span class="nc" id="L1281">                return retPos;</span>

              case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
              case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
              case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
              case 's': case 't': case 'u': case 'v': case 'w': case 'x':
              case 'y': case 'z':
              case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
              case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
              case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
              case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
              case 'Y': case 'Z':
              case '$': case '_':
<span class="nc" id="L1294">                scanIdentifier();</span>
<span class="nc" id="L1295">                return retPos;</span>

              case '\u001a':
                // Our one concession to DOS.
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if ((ch = in.read()) == EOF) {</span>
<span class="nc" id="L1300">                    token = EOF;</span>
<span class="nc" id="L1301">                    return retPos;</span>
                }
<span class="nc" id="L1303">                env.error(pos, &quot;funny.char&quot;);</span>
<span class="nc" id="L1304">                ch = in.read();</span>
<span class="nc" id="L1305">                break;</span>


              default:
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                if (Character.isJavaLetter((char)ch)) {</span>
<span class="nc" id="L1310">                    scanIdentifier();</span>
<span class="nc" id="L1311">                    return retPos;</span>
                }
<span class="nc" id="L1313">                env.error(pos, &quot;funny.char&quot;);</span>
<span class="nc" id="L1314">                ch = in.read();</span>
<span class="nc" id="L1315">                break;</span>
            }
        }
    }

    /**
     * Scan to a matching '}', ']' or ')'. The current token must be
     * a '{', '[' or '(';
     */
    public void match(int open, int close) throws IOException {
<span class="nc" id="L1325">        int depth = 1;</span>

        while (true) {
<span class="nc" id="L1328">            scan();</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (token == open) {</span>
<span class="nc" id="L1330">                depth++;</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">            } else if (token == close) {</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                if (--depth == 0) {</span>
<span class="nc" id="L1333">                    return;</span>
                }
<span class="nc bnc" id="L1335" title="All 2 branches missed.">            } else if (token == EOF) {</span>
<span class="nc" id="L1336">                env.error(pos, &quot;unbalanced.paren&quot;);</span>
<span class="nc" id="L1337">                return;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>