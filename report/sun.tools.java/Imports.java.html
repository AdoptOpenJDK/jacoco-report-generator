<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Imports.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">Imports.java</span></div><h1>Imports.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import java.util.List;
import java.util.Collections;
import java.io.IOException;

/**
 * This class describes the classes and packages imported
 * from a source file. A Hashtable called bindings is maintained
 * to quickly map symbol names to classes. This table is flushed
 * everytime a new import is added.
 *
 * A class name is resolved as follows:
 *  - if it is a qualified name then return the corresponding class
 *  - if the name corresponds to an individually imported class then return that class
 *  - check if the class is defined in any of the imported packages,
 *    if it is then return it, make sure it is defined in only one package
 *  - assume that the class is defined in the current package
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */

public
class Imports implements Constants {
    /**
     * The current package, which is implicitly imported,
     * and has precedence over other imported packages.
     */
<span class="nc" id="L59">    Identifier currentPackage = idNull;</span>

    /**
     * A location for the current package declaration.  Used to
     * report errors against the current package.
     */
<span class="nc" id="L65">    long currentPackageWhere = 0;</span>

    /**
     * The imported classes, including memoized imports from packages.
     */
<span class="nc" id="L70">    Hashtable classes = new Hashtable();</span>

    /**
     * The imported package identifiers.  This will not contain duplicate
     * imports for the same package.  It will also not contain the
     * current package.
     */
<span class="nc" id="L77">    Vector packages = new Vector();</span>

    /**
     * The (originally) imported classes.
     * A vector of IdentifierToken.
     */
<span class="nc" id="L83">    Vector singles = new Vector();</span>

    /**
     * Are the import names checked yet?
     */
    protected int checked;

    /**
     * Constructor, always import java.lang.
     */
<span class="nc" id="L93">    public Imports(Environment env) {</span>
<span class="nc" id="L94">        addPackage(idJavaLang);</span>
<span class="nc" id="L95">    }</span>

    /**
     * Check the names of the imports.
     */
    public synchronized void resolve(Environment env) {
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if (checked != 0) {</span>
<span class="nc" id="L102">            return;</span>
        }
<span class="nc" id="L104">        checked = -1;</span>

        // After all class information has been read, now we can
        // safely inspect import information for errors.
        // If we did this before all parsing was finished,
        // we could get vicious circularities, since files can
        // import each others' classes.

        // A note: the resolution of the package java.lang takes place
        // in the sun.tools.javac.BatchEnvironment#setExemptPackages().

        // Make sure that the current package's name does not collide
        // with the name of an existing class. (bug 4101529)
        //
        // This change has been backed out because, on WIN32, it
        // failed to distinguish between java.awt.event and
        // java.awt.Event when looking for a directory.  We will
        // add this back in later.
        //
        // if (currentPackage != idNull) {
        //    Identifier resolvedName =
        //      env.resolvePackageQualifiedName(currentPackage);
        //
        //   Identifier className = resolvedName.getTopName();
        //
        //   if (importable(className, env)) {
        //      // The name of the current package is also the name
        //      // of a class.
        //      env.error(currentPackageWhere, &quot;package.class.conflict&quot;,
        //                currentPackage, className);
        //     }
        // }

<span class="nc" id="L137">        Vector resolvedPackages = new Vector();</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        for (Enumeration e = packages.elements() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L139">            IdentifierToken t = (IdentifierToken)e.nextElement();</span>
<span class="nc" id="L140">            Identifier nm = t.getName();</span>
<span class="nc" id="L141">            long where = t.getWhere();</span>

            // Check to see if this package is exempt from the &quot;exists&quot;
            // check.  See the note in
            // sun.tools.javac.BatchEnvironment#setExemptPackages()
            // for more information.
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (env.isExemptPackage(nm)) {</span>
<span class="nc" id="L148">                resolvedPackages.addElement(t);</span>
<span class="nc" id="L149">                continue;</span>
            }

            // (Note: This code is moved from BatchParser.importPackage().)
            try {
<span class="nc" id="L154">                Identifier rnm = env.resolvePackageQualifiedName(nm);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (importable(rnm, env)) {</span>
                    // This name is a real class; better not be a package too.
<span class="nc bnc" id="L157" title="All 2 branches missed.">                    if (env.getPackage(rnm.getTopName()).exists()) {</span>
<span class="nc" id="L158">                        env.error(where, &quot;class.and.package&quot;,</span>
<span class="nc" id="L159">                                  rnm.getTopName());</span>
                    }
                    // Pass an &quot;inner&quot; name to the imports.
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (!rnm.isInner())</span>
<span class="nc" id="L163">                        rnm = Identifier.lookupInner(rnm, idNull);</span>
<span class="nc" id="L164">                    nm = rnm;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                } else if (!env.getPackage(nm).exists()) {</span>
<span class="nc" id="L166">                    env.error(where, &quot;package.not.found&quot;, nm, &quot;import&quot;);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                } else if (rnm.isInner()) {</span>
                    // nm exists, and rnm.getTopName() is a parent package
<span class="nc" id="L169">                    env.error(where, &quot;class.and.package&quot;, rnm.getTopName());</span>
                }
<span class="nc" id="L171">                resolvedPackages.addElement(new IdentifierToken(where, nm));</span>
<span class="nc" id="L172">            } catch (IOException ee) {</span>
<span class="nc" id="L173">                env.error(where, &quot;io.exception&quot;, &quot;import&quot;);</span>
<span class="nc" id="L174">            }</span>
<span class="nc" id="L175">        }</span>
<span class="nc" id="L176">        packages = resolvedPackages;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">        for (Enumeration e = singles.elements() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L179">            IdentifierToken t = (IdentifierToken)e.nextElement();</span>
<span class="nc" id="L180">            Identifier nm = t.getName();</span>
<span class="nc" id="L181">            long where = t.getWhere();</span>
<span class="nc" id="L182">            Identifier pkg = nm.getQualifier();</span>

            // (Note: This code is moved from BatchParser.importClass().)
<span class="nc" id="L185">            nm = env.resolvePackageQualifiedName(nm);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (!env.classExists(nm.getTopName())) {</span>
<span class="nc" id="L187">                env.error(where, &quot;class.not.found&quot;, nm, &quot;import&quot;);</span>
            }

            // (Note: This code is moved from Imports.addClass().)
<span class="nc" id="L191">            Identifier snm = nm.getFlatName().getName();</span>

            // make sure it isn't already imported explicitly
<span class="nc" id="L194">            Identifier className = (Identifier)classes.get(snm);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            if (className != null) {</span>
<span class="nc" id="L196">                Identifier f1 = Identifier.lookup(className.getQualifier(),</span>
<span class="nc" id="L197">                                                  className.getFlatName());</span>
<span class="nc" id="L198">                Identifier f2 = Identifier.lookup(nm.getQualifier(),</span>
<span class="nc" id="L199">                                                  nm.getFlatName());</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (!f1.equals(f2)) {</span>
<span class="nc" id="L201">                    env.error(where, &quot;ambig.class&quot;, nm, className);</span>
                }
            }
<span class="nc" id="L204">            classes.put(snm, nm);</span>


            // The code here needs to check to see, if we
            // are importing an inner class, that all of its
            // enclosing classes are visible to us.  To check this,
            // we need to construct a definition for the class.
            // The code here used to call...
            //
            //     ClassDefinition def = env.getClassDefinition(nm);
            //
            // ...but that interfered with the basicCheck()'ing of
            // interfaces in certain cases (bug no. 4086139).  Never
            // fear.  Instead we load the class with a call to the
            // new getClassDefinitionNoCheck() which does no basicCheck() and
            // lets us answer the questions we are interested in w/o
            // interfering with the demand-driven nature of basicCheck().

            try {
                // Get a declaration
<span class="nc" id="L224">                ClassDeclaration decl = env.getClassDeclaration(nm);</span>

                // Get the definition (no env argument)
<span class="nc" id="L227">                ClassDefinition def = decl.getClassDefinitionNoCheck(env);</span>

                // Get the true name of the package containing this class.
                // `pkg' from above is insufficient.  It includes the
                // names of our enclosing classes.  Fix for 4086815.
<span class="nc" id="L232">                Identifier importedPackage = def.getName().getQualifier();</span>

                // Walk out the outerClass chain, ensuring that each level
                // is visible from our perspective.
<span class="nc bnc" id="L236" title="All 2 branches missed.">                for (; def != null; def = def.getOuterClass()) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                    if (def.isPrivate()</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                        || !(def.isPublic()</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                             || importedPackage.equals(currentPackage))) {</span>
<span class="nc" id="L240">                        env.error(where, &quot;cant.access.class&quot;, def);</span>
<span class="nc" id="L241">                        break;</span>
                    }
                }
<span class="nc" id="L244">            } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L245">                env.error(where, &quot;ambig.class&quot;, ee.name1, ee.name2);</span>
<span class="nc" id="L246">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L247">                env.error(where, &quot;class.not.found&quot;, ee.name, &quot;import&quot;);</span>
<span class="nc" id="L248">            }</span>
<span class="nc" id="L249">        }</span>
<span class="nc" id="L250">        checked = 1;</span>
<span class="nc" id="L251">    }</span>

    /**
     * Lookup a class, given the current set of imports,
     * AmbiguousClass exception is thrown if the name can be
     * resolved in more than one way. A ClassNotFound exception
     * is thrown if the class is not found in the imported classes
     * and packages.
     */
    public synchronized Identifier resolve(Environment env, Identifier nm) throws ClassNotFound {
<span class="nc" id="L261">        if (tracing) env.dtEnter(&quot;Imports.resolve: &quot; + nm);</span>

        // If the class has the special ambiguous prefix, then we will
        // get the original AmbiguousClass exception by removing the
        // prefix and proceeding in the normal fashion.
        // (part of solution for 4059855)
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (nm.hasAmbigPrefix()) {</span>
<span class="nc" id="L268">            nm = nm.removeAmbigPrefix();</span>
        }

<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (nm.isQualified()) {</span>
            // Don't bother it is already qualified
<span class="nc" id="L273">            if (tracing) env.dtExit(&quot;Imports.resolve: QUALIFIED &quot; + nm);</span>
<span class="nc" id="L274">            return nm;</span>
        }

<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (checked &lt;= 0) {</span>
<span class="nc" id="L278">            checked = 0;</span>
<span class="nc" id="L279">            resolve(env);</span>
        }

        // Check if it was imported before
<span class="nc" id="L283">        Identifier className = (Identifier)classes.get(nm);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (className != null) {</span>
<span class="nc" id="L285">            if (tracing) env.dtExit(&quot;Imports.resolve: PREVIOUSLY IMPORTED &quot; + nm);</span>
<span class="nc" id="L286">            return className;</span>
        }

        // Note: the section below has changed a bit during the fix
        // for bug 4093217.  The current package is no longer grouped
        // with the rest of the import-on-demands; it is now checked
        // separately.  Also, the list of import-on-demands is now
        // guarranteed to be duplicate-free, so the code below can afford
        // to be a bit simpler.

        // First we look in the current package.  The current package
        // is given precedence over the rest of the import-on-demands,
        // which means, among other things, that a class in the current
        // package cannot be ambiguous.
<span class="nc" id="L300">        Identifier id = Identifier.lookup(currentPackage, nm);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (importable(id, env)) {</span>
<span class="nc" id="L302">            className = id;</span>
        } else {
            // If it isn't in the current package, try to find it in
            // our import-on-demands.
<span class="nc" id="L306">            Enumeration e = packages.elements();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            while (e.hasMoreElements()) {</span>
<span class="nc" id="L308">                IdentifierToken t = (IdentifierToken)e.nextElement();</span>
<span class="nc" id="L309">                id = Identifier.lookup(t.getName(), nm);</span>

<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (importable(id, env)) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                    if (className == null) {</span>
                        // We haven't found any other matching classes yet.
                        // Set className to what we've found and continue
                        // looking for an ambiguity.
<span class="nc" id="L316">                        className = id;</span>
                    } else {
                        if (tracing)
<span class="nc" id="L319">                            env.dtExit(&quot;Imports.resolve: AMBIGUOUS &quot; + nm);</span>

                        // We've found an ambiguity.
<span class="nc" id="L322">                        throw new AmbiguousClass(className, id);</span>
                    }
                }
<span class="nc" id="L325">            }</span>
        }

        // Make sure a class was found
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (className == null) {</span>
<span class="nc" id="L330">            if (tracing) env.dtExit(&quot;Imports.resolve: NOT FOUND &quot; + nm);</span>
<span class="nc" id="L331">            throw new ClassNotFound(nm);</span>
        }

        // Remember the binding
<span class="nc" id="L335">        classes.put(nm, className);</span>
<span class="nc" id="L336">        if (tracing) env.dtExit(&quot;Imports.resolve: FIRST IMPORT &quot; + nm);</span>
<span class="nc" id="L337">        return className;</span>
    }

    /**
     * Check to see if 'id' names an importable class in `env'.
     * This method was made public and static for utility.
     */
    static public boolean importable(Identifier id, Environment env) {
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (!id.isInner()) {</span>
<span class="nc" id="L346">            return env.classExists(id);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        } else if (!env.classExists(id.getTopName())) {</span>
<span class="nc" id="L348">            return false;</span>
        } else {
            // load the top class and look inside it
            try {
                // There used to be a call to...
                //    env.getClassDeclaration(id.getTopName());
                // ...here.  It has been replaced with the
                // two statements below.  These should be functionally
                // the same except for the fact that
                // getClassDefinitionNoCheck() does not call
                // basicCheck().  This allows us to avoid a circular
                // need to do basicChecking that can arise with
                // certain patterns of importing and inheritance.
                // This is a fix for a variant of bug 4086139.
                //
                // Note: the special case code in env.getClassDefinition()
                // which handles inner class names is not replicated below.
                // This should be okay, as we are looking up id.getTopName(),
                // not id.
<span class="nc" id="L367">                ClassDeclaration decl =</span>
<span class="nc" id="L368">                    env.getClassDeclaration(id.getTopName());</span>
<span class="nc" id="L369">                ClassDefinition c =</span>
<span class="nc" id="L370">                    decl.getClassDefinitionNoCheck(env);</span>

<span class="nc" id="L372">                return c.innerClassExists(id.getFlatName().getTail());</span>
<span class="nc" id="L373">            } catch (ClassNotFound ee) {</span>
<span class="nc" id="L374">                return false;</span>
            }
        }
    }

    /**
     * Suppose a resolve() call has failed.
     * This routine can be used silently to give a reasonable
     * default qualification (the current package) to the identifier.
     * This decision is recorded for future reference.
     */
    public synchronized Identifier forceResolve(Environment env, Identifier nm) {
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (nm.isQualified())</span>
<span class="nc" id="L387">            return nm;</span>

<span class="nc" id="L389">        Identifier className = (Identifier)classes.get(nm);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (className != null) {</span>
<span class="nc" id="L391">            return className;</span>
        }

<span class="nc" id="L394">        className = Identifier.lookup(currentPackage, nm);</span>

<span class="nc" id="L396">        classes.put(nm, className);</span>
<span class="nc" id="L397">        return className;</span>
    }

    /**
     * Add a class import
     */
    public synchronized void addClass(IdentifierToken t) {
<span class="nc" id="L404">        singles.addElement(t);</span>
<span class="nc" id="L405">    }</span>
    // for compatibility
    public void addClass(Identifier nm) throws AmbiguousClass {
<span class="nc" id="L408">        addClass(new IdentifierToken(nm));</span>
<span class="nc" id="L409">    }</span>

    /**
     * Add a package import, or perhaps an inner class scope.
     * Ignore any duplicate imports.
     */
    public synchronized void addPackage(IdentifierToken t) {
<span class="nc" id="L416">        final Identifier name = t.getName();</span>

        // If this is a duplicate import for the current package,
        // ignore it.
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (name == currentPackage) {</span>
<span class="nc" id="L421">            return;</span>
        }

        // If this is a duplicate of a package which has already been
        // added to the list, ignore it.
<span class="nc" id="L426">        final int size = packages.size();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (name == ((IdentifierToken)packages.elementAt(i)).getName()) {</span>
<span class="nc" id="L429">                return;</span>
            }
        }

        // Add the package to the list.
<span class="nc" id="L434">        packages.addElement(t);</span>
<span class="nc" id="L435">    }</span>
    // for compatibility
    public void addPackage(Identifier id) {
<span class="nc" id="L438">        addPackage(new IdentifierToken(id));</span>
<span class="nc" id="L439">    }</span>

    /**
     * Specify the current package with an IdentifierToken.
     */
    public synchronized void setCurrentPackage(IdentifierToken t) {
<span class="nc" id="L445">        currentPackage = t.getName();</span>
<span class="nc" id="L446">        currentPackageWhere = t.getWhere();</span>
<span class="nc" id="L447">    }</span>

    /**
     * Specify the current package
     */
    public synchronized void setCurrentPackage(Identifier id) {
<span class="nc" id="L453">        currentPackage = id;</span>
<span class="nc" id="L454">    }</span>

    /**
     * Report the current package
     */
    public Identifier getCurrentPackage() {
<span class="nc" id="L460">        return currentPackage;</span>
    }

    /**
     * Return an unmodifiable list of IdentifierToken representing
     * packages specified as imports.
     */
    public List getImportedPackages() {
<span class="nc" id="L468">        return Collections.unmodifiableList(packages);</span>
    }

    /**
     * Return an unmodifiable list of IdentifierToken representing
     * classes specified as imports.
     */
    public List getImportedClasses() {
<span class="nc" id="L476">        return Collections.unmodifiableList(singles);</span>
    }

    /**
     * Extend an environment with my resolve() method.
     */
    public Environment newEnvironment(Environment env) {
<span class="nc" id="L483">        return new ImportEnvironment(env, this);</span>
    }
}

final
class ImportEnvironment extends Environment {
    Imports imports;

    ImportEnvironment(Environment env, Imports imports) {
<span class="nc" id="L492">        super(env, env.getSource());</span>
<span class="nc" id="L493">        this.imports = imports;</span>
<span class="nc" id="L494">    }</span>

    public Identifier resolve(Identifier nm) throws ClassNotFound {
<span class="nc" id="L497">        return imports.resolve(this, nm);</span>
    }

    public Imports getImports() {
<span class="nc" id="L501">        return imports;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>