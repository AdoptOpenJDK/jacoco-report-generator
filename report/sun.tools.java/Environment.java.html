<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Environment.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">Environment.java</span></div><h1>Environment.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.util.Stack;
import java.io.IOException;
import sun.tools.tree.Context;
//JCOV
import java.io.File;
//end JCOV

/**
 * This class defines the environment for a compilation.
 * It is used to load classes, resolve class names and
 * report errors. It is an abstract class, a subclass
 * must define implementations for some of the functions.&lt;p&gt;
 *
 * An environment has a source object associated with it.
 * This is the thing against which errors are reported, it
 * is usually a file name, a field or a class.&lt;p&gt;
 *
 * Environments can be nested to change the source object.&lt;p&gt;
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author      Arthur van Hoff
 */

public class Environment implements Constants {
    /**
     * The actual environment to which everything is forwarded.
     */
    Environment env;

    /**
     * External character encoding name
     */
    String encoding;

    /**
     * The object that is currently being parsed/compiled.
     * It is either a file name (String) or a field (MemberDefinition)
     * or a class (ClassDeclaration or ClassDefinition).
     */
    Object source;

<span class="nc" id="L72">    public Environment(Environment env, Object source) {</span>
<span class="nc bnc" id="L73" title="All 6 branches missed.">        if (env != null &amp;&amp; env.env != null &amp;&amp; env.getClass() == this.getClass())</span>
<span class="nc" id="L74">            env = env.env;      // a small optimization</span>
<span class="nc" id="L75">        this.env = env;</span>
<span class="nc" id="L76">        this.source = source;</span>
<span class="nc" id="L77">    }</span>
    public Environment() {
<span class="nc" id="L79">        this(null, null);</span>
<span class="nc" id="L80">    }</span>

    /**
     * Tells whether an Identifier refers to a package which should be
     * exempt from the &quot;exists&quot; check in Imports#resolve().
     */
    public boolean isExemptPackage(Identifier id) {
<span class="nc" id="L87">        return env.isExemptPackage(id);</span>
    }

    /**
     * Return a class declaration given a fully qualified class name.
     */
    public ClassDeclaration getClassDeclaration(Identifier nm) {
<span class="nc" id="L94">        return env.getClassDeclaration(nm);</span>
    }

    /**
     * Return a class definition given a fully qualified class name.
     * &lt;p&gt;
     * Should be called only with 'internal' class names, i.e., the result
     * of a call to 'resolveName' or a synthetic class name.
     */
    public final ClassDefinition getClassDefinition(Identifier nm) throws ClassNotFound {
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (nm.isInner()) {</span>
<span class="nc" id="L105">            ClassDefinition c = getClassDefinition(nm.getTopName());</span>
<span class="nc" id="L106">            Identifier tail = nm.getFlatName();</span>
        walkTail:
<span class="nc bnc" id="L108" title="All 2 branches missed.">            while (tail.isQualified()) {</span>
<span class="nc" id="L109">                tail = tail.getTail();</span>
<span class="nc" id="L110">                Identifier head = tail.getHead();</span>
                //System.out.println(&quot;CLASS: &quot; + c + &quot; HEAD: &quot; + head + &quot; TAIL: &quot; + tail);
<span class="nc" id="L112">                String hname = head.toString();</span>
                // If the name is of the form 'ClassName.N$localName', where N is
                // a number, the field 'N$localName' may not necessarily be a member
                // of the class named by 'ClassName', but might be a member of some
                // inaccessible class contained within it.  We use 'getLocalClass'
                // to do the lookup in this case.  This is part of a fix for bugid
                // 4054523 and 4030421.  See also 'BatchEnvironment.makeClassDefinition'.
                // This should also work for anonymous class names of the form
                // 'ClassName.N'.  Note that the '.' qualifications get converted to
                // '$' characters when determining the external name of the class and
                // the name of the class file.
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (hname.length() &gt; 0</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                    &amp;&amp; Character.isDigit(hname.charAt(0))) {</span>
<span class="nc" id="L125">                    ClassDefinition localClass = c.getLocalClass(hname);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    if (localClass != null) {</span>
<span class="nc" id="L127">                        c = localClass;</span>
<span class="nc" id="L128">                        continue walkTail;</span>
                    }
<span class="nc" id="L130">                } else {</span>
<span class="nc" id="L131">                    for (MemberDefinition f = c.getFirstMatch(head);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                         f != null; f = f.getNextMatch()) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                        if (f.isInnerClass()) {</span>
<span class="nc" id="L134">                            c = f.getInnerClass();</span>
<span class="nc" id="L135">                            continue walkTail;</span>
                        }
                    }
                }
<span class="nc" id="L139">                throw new ClassNotFound(Identifier.lookupInner(c.getName(), head));</span>
            }
            //System.out.println(&quot;FOUND &quot; + c + &quot; FOR &quot; + nm);
<span class="nc" id="L142">            return c;</span>
        }
<span class="nc" id="L144">        return getClassDeclaration(nm).getClassDefinition(this);</span>
    }


    /**
     * Return a class declaration given a type. Only works for
     * class types.
     */
    public ClassDeclaration getClassDeclaration(Type t) {
<span class="nc" id="L153">        return getClassDeclaration(t.getClassName());</span>
    }

    /**
     * Return a class definition given a type. Only works for
     * class types.
     */
    public final ClassDefinition getClassDefinition(Type t) throws ClassNotFound {
<span class="nc" id="L161">        return getClassDefinition(t.getClassName());</span>
    }

    /**
     * Check if a class exists (without actually loading it).
     * (Since inner classes cannot in general be examined without
     * loading source, this method does not accept inner names.)
     */
    public boolean classExists(Identifier nm) {
<span class="nc" id="L170">        return env.classExists(nm);</span>
    }

    public final boolean classExists(Type t) {
<span class="nc bnc" id="L174" title="All 4 branches missed.">        return !t.isType(TC_CLASS) || classExists(t.getClassName());</span>
    }

    /**
     * Get the package path for a package
     */
    public Package getPackage(Identifier pkg) throws IOException {
<span class="nc" id="L181">        return env.getPackage(pkg);</span>
    }

    /**
     * Load the definition of a class.
     */
    public void loadDefinition(ClassDeclaration c) {
<span class="nc" id="L188">        env.loadDefinition(c);</span>
<span class="nc" id="L189">    }</span>

    /**
     * Return the source of the environment (ie: the thing being compiled/parsed).
     */
    public final Object getSource() {
<span class="nc" id="L195">        return source;</span>
    }

    /**
     * Resolve a type. Make sure that all the classes referred to by
     * the type have a definition.  Report errors.  Return true if
     * the type is well-formed.  Presently used for types appearing
     * in member declarations, which represent named types internally as
     * qualified identifiers.  Type names appearing in local variable
     * declarations and within expressions are represented as identifier
     * or field expressions, and are resolved by 'toType', which delegates
     * handling of the non-inner portion of the name to this method.
     * &lt;p&gt;
     * In 'toType', the various stages of qualification are represented by
     * separate AST nodes.  Here, we are given a single identifier which
     * contains the entire qualification structure.  It is not possible in
     * general to set the error location to the exact position of a component
     * that is in error, so an error message must refer to the entire qualified
     * name.  An attempt to keep track of the string length of the components of
     * the name and to offset the location accordingly fails because the initial
     * prefix of the name may have been rewritten by an earlier call to
     * 'resolveName'.  See 'SourceMember.resolveTypeStructure'.  The situation
     * is actually even worse than this, because only a single location is
     * passed in for an entire declaration, which may contain many type names.
     * All error messages are thus poorly localized.  These checks should be
     * done while traversing the parse tree for the type, not the type descriptor.
     * &lt;p&gt;
     * DESIGN NOTE:
     * As far as I can tell, the two-stage resolution of names represented in
     * string form is an artifact of the late implementation of inner classes
     * and the use of mangled names internally within the compiler.  All
     * qualified names should have their hiearchical structure made explicit
     * in the parse tree at the phase at which they are presented for static
     * semantic checking.  This would affect class names appearing in 'extends',
     * 'implements', and 'throws' clauses, as well as in member declarations.
     */
    public boolean resolve(long where, ClassDefinition c, Type t) {
<span class="nc bnc" id="L232" title="All 4 branches missed.">        switch (t.getTypeCode()) {</span>
          case TC_CLASS: {
            ClassDefinition def;
            try {
<span class="nc" id="L236">                Identifier nm = t.getClassName();</span>
<span class="nc bnc" id="L237" title="All 6 branches missed.">                if (!nm.isQualified() &amp;&amp; !nm.isInner() &amp;&amp; !classExists(nm)) {</span>
<span class="nc" id="L238">                    resolve(nm);        // elicit complaints about ambiguity</span>
                }
<span class="nc" id="L240">                def = getQualifiedClassDefinition(where, nm, c, false);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (!c.canAccess(this, def.getClassDeclaration())) {</span>
                    // Reported error location may be imprecise
                    // if the name is qualified.
<span class="nc" id="L244">                    error(where, &quot;cant.access.class&quot;, def);</span>
<span class="nc" id="L245">                    return true; // return false later</span>
                }
<span class="nc" id="L247">                def.noteUsedBy(c, where, env);</span>
<span class="nc" id="L248">            } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L249">                error(where, &quot;ambig.class&quot;, ee.name1, ee.name2);</span>
<span class="nc" id="L250">                return false;</span>
<span class="nc" id="L251">            } catch (ClassNotFound e) {</span>
                // For now, report &quot;class.and.package&quot; only when the code
                // is going to fail anyway.
                try {
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    if (e.name.isInner() &amp;&amp;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">                            getPackage(e.name.getTopName()).exists()) {</span>
<span class="nc" id="L257">                        env.error(where, &quot;class.and.package&quot;,</span>
<span class="nc" id="L258">                                  e.name.getTopName());</span>
                    }
<span class="nc" id="L260">                } catch (IOException ee) {</span>
<span class="nc" id="L261">                    env.error(where, &quot;io.exception&quot;, &quot;package check&quot;);</span>
<span class="nc" id="L262">                }</span>
                // This error message is also emitted for 'new' expressions.
                // error(where, &quot;class.not.found&quot;, e.name, &quot;declaration&quot;);
<span class="nc" id="L265">                error(where, &quot;class.not.found.no.context&quot;, e.name);</span>
<span class="nc" id="L266">                return false;</span>
<span class="nc" id="L267">            }</span>
<span class="nc" id="L268">            return true;</span>
          }

          case TC_ARRAY:
<span class="nc" id="L272">            return resolve(where, c, t.getElementType());</span>

          case TC_METHOD:
<span class="nc" id="L275">            boolean ok = resolve(where, c, t.getReturnType());</span>
<span class="nc" id="L276">            Type args[] = t.getArgumentTypes();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (int i = args.length ; i-- &gt; 0 ; ) {</span>
<span class="nc" id="L278">                ok &amp;= resolve(where, c, args[i]);</span>
            }
<span class="nc" id="L280">            return ok;</span>
        }
<span class="nc" id="L282">        return true;</span>
    }

    /**
     * Given its fully-qualified name, verify that a class is defined and accessible.
     * Used to check components of qualified names in contexts where a class is expected.
     * Like 'resolve', but is given a single type name, not a type descriptor.
     */
    public boolean resolveByName(long where, ClassDefinition c, Identifier nm) {
<span class="nc" id="L291">        return resolveByName(where, c, nm, false);</span>
    }

    public boolean resolveExtendsByName(long where, ClassDefinition c, Identifier nm) {
<span class="nc" id="L295">        return resolveByName(where, c, nm, true);</span>
    }

    private boolean resolveByName(long where, ClassDefinition c,
                                 Identifier nm, boolean isExtends) {
        ClassDefinition def;
        try {
<span class="nc bnc" id="L302" title="All 6 branches missed.">            if (!nm.isQualified() &amp;&amp; !nm.isInner() &amp;&amp; !classExists(nm)) {</span>
<span class="nc" id="L303">                resolve(nm);    // elicit complaints about ambiguity</span>
            }
<span class="nc" id="L305">            def = getQualifiedClassDefinition(where, nm, c, isExtends);</span>
<span class="nc" id="L306">            ClassDeclaration decl = def.getClassDeclaration();</span>
<span class="nc bnc" id="L307" title="All 6 branches missed.">            if (!((!isExtends &amp;&amp; c.canAccess(this, decl))</span>
                  ||
<span class="nc bnc" id="L309" title="All 2 branches missed.">                  (isExtends &amp;&amp; c.extendsCanAccess(this, decl)))) {</span>
<span class="nc" id="L310">                error(where, &quot;cant.access.class&quot;, def);</span>
<span class="nc" id="L311">                return true; // return false later</span>
            }
<span class="nc" id="L313">        } catch (AmbiguousClass ee) {</span>
<span class="nc" id="L314">            error(where, &quot;ambig.class&quot;, ee.name1, ee.name2);</span>
<span class="nc" id="L315">            return false;</span>
<span class="nc" id="L316">        } catch (ClassNotFound e) {</span>
            // For now, report &quot;class.and.package&quot; only when the code
            // is going to fail anyway.
            try {
<span class="nc bnc" id="L320" title="All 2 branches missed.">                if (e.name.isInner() &amp;&amp;</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                    getPackage(e.name.getTopName()).exists()) {</span>
<span class="nc" id="L322">                    env.error(where, &quot;class.and.package&quot;,</span>
<span class="nc" id="L323">                              e.name.getTopName());</span>
                }
<span class="nc" id="L325">            } catch (IOException ee) {</span>
<span class="nc" id="L326">                env.error(where, &quot;io.exception&quot;, &quot;package check&quot;);</span>
<span class="nc" id="L327">            }</span>
<span class="nc" id="L328">            error(where, &quot;class.not.found&quot;, e.name, &quot;type name&quot;);</span>
<span class="nc" id="L329">            return false;</span>
<span class="nc" id="L330">        }</span>
<span class="nc" id="L331">        return true;</span>
    }

    /**
     * Like 'getClassDefinition(env)', but check access on each component.
     * Currently called only by 'resolve' above.  It is doubtful that calls
     * to 'getClassDefinition(env)' are appropriate now.
     */
    public final ClassDefinition
    getQualifiedClassDefinition(long where,
                                Identifier nm,
                                ClassDefinition ctxClass,
                                boolean isExtends) throws ClassNotFound {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (nm.isInner()) {</span>
<span class="nc" id="L345">            ClassDefinition c = getClassDefinition(nm.getTopName());</span>
<span class="nc" id="L346">            Identifier tail = nm.getFlatName();</span>
        walkTail:
<span class="nc bnc" id="L348" title="All 2 branches missed.">            while (tail.isQualified()) {</span>
<span class="nc" id="L349">                tail = tail.getTail();</span>
<span class="nc" id="L350">                Identifier head = tail.getHead();</span>
                // System.out.println(&quot;CLASS: &quot; + c + &quot; HEAD: &quot; + head + &quot; TAIL: &quot; + tail);
<span class="nc" id="L352">                String hname = head.toString();</span>
                // Handle synthesized names of local and anonymous classes.
                // See 'getClassDefinition(env)' above.
<span class="nc bnc" id="L355" title="All 2 branches missed.">                if (hname.length() &gt; 0</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    &amp;&amp; Character.isDigit(hname.charAt(0))) {</span>
<span class="nc" id="L357">                    ClassDefinition localClass = c.getLocalClass(hname);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                    if (localClass != null) {</span>
<span class="nc" id="L359">                        c = localClass;</span>
<span class="nc" id="L360">                        continue walkTail;</span>
                    }
<span class="nc" id="L362">                } else {</span>
<span class="nc" id="L363">                    for (MemberDefinition f = c.getFirstMatch(head);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                         f != null; f = f.getNextMatch()) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">                        if (f.isInnerClass()) {</span>
<span class="nc" id="L366">                            ClassDeclaration rdecl = c.getClassDeclaration();</span>
<span class="nc" id="L367">                            c = f.getInnerClass();</span>
<span class="nc" id="L368">                            ClassDeclaration fdecl = c.getClassDeclaration();</span>
                            // This check is presumably applicable even if the
                            // original source-code name (expanded by 'resolveNames')
                            // was a simple, unqualified name.  Hopefully, JLS 2e
                            // will clarify the matter.
<span class="nc bnc" id="L373" title="All 2 branches missed.">                            if ((!isExtends</span>
<span class="nc bnc" id="L374" title="All 4 branches missed.">                                 &amp;&amp; !ctxClass.canAccess(env, fdecl))</span>
                                ||
                                (isExtends
<span class="nc bnc" id="L377" title="All 2 branches missed.">                                 &amp;&amp; !ctxClass.extendsCanAccess(env, fdecl))) {</span>
                                // Reported error location is imprecise.
<span class="nc" id="L379">                                env.error(where, &quot;no.type.access&quot;, head, rdecl, ctxClass);</span>
                            }
                            // The JLS 6.6.2 restrictions on access to protected members
                            // depend in an essential way upon the syntactic form of the name.
                            // Since the compiler has previously expanded the class names
                            // here into fully-qualified form ('resolveNames'), this check
                            // cannot be performed here.  Unfortunately, the original names
                            // are clobbered during 'basicCheck', which is also the phase that
                            // resolves the inheritance structure, required to implement the
                            // access restrictions.  Pending a large-scale revision of the
                            // name-resolution machinery, we forgo this check, with the result
                            // that the JLS 6.6.2 restrictions are not enforced for some cases
                            // of qualified access to inner classes.  Some qualified names are
                            // resolved elsewhere via a different mechanism, and will be
                            // treated correctly -- see 'FieldExpression.checkCommon'.
                            /*---------------------------------------*
                            if (f.isProtected()) {
                                Type rty = Type.tClass(rdecl.getName()); // hack
                                if (!ctxClass.protectedAccess(env, f, rty)) {
                                    // Reported error location is imprecise.
                                    env.error(where, &quot;invalid.protected.type.use&quot;,
                                              head, ctxClass, rty);
                                }
                            }
                            *---------------------------------------*/
                            continue walkTail;
                        }
                    }
                }
<span class="nc" id="L408">                throw new ClassNotFound(Identifier.lookupInner(c.getName(), head));</span>
            }
            //System.out.println(&quot;FOUND &quot; + c + &quot; FOR &quot; + nm);
<span class="nc" id="L411">            return c;</span>
        }
<span class="nc" id="L413">        return getClassDeclaration(nm).getClassDefinition(this);</span>
    }

    /**
     * Resolve the names within a type, returning the adjusted type.
     * Adjust class names to reflect scoping.
     * Do not report errors.
     * &lt;p&gt;
     * NOTE: It would be convenient to check for errors here, such as
     * verifying that each component of a qualified name exists and is
     * accessible.  Why must this be done in a separate phase?
     * &lt;p&gt;
     * If the 'synth' argument is true, indicating that the member whose
     * type is being resolved is synthetic, names are resolved with respect
     * to the package scope.  (Fix for 4097882)
     */
    public Type resolveNames(ClassDefinition c, Type t, boolean synth) {
<span class="nc" id="L430">        if (tracing) dtEvent(&quot;Environment.resolveNames: &quot; + c + &quot;, &quot; + t);</span>
<span class="nc bnc" id="L431" title="All 4 branches missed.">        switch (t.getTypeCode()) {</span>
          case TC_CLASS: {
<span class="nc" id="L433">            Identifier name = t.getClassName();</span>
            Identifier rname;
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (synth) {</span>
<span class="nc" id="L436">                rname = resolvePackageQualifiedName(name);</span>
            } else {
<span class="nc" id="L438">                rname = c.resolveName(this, name);</span>
            }
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (name != rname) {</span>
<span class="nc" id="L441">                t = Type.tClass(rname);</span>
            }
            break;
          }

          case TC_ARRAY:
<span class="nc" id="L447">            t = Type.tArray(resolveNames(c, t.getElementType(), synth));</span>
<span class="nc" id="L448">            break;</span>

          case TC_METHOD: {
<span class="nc" id="L451">            Type ret = t.getReturnType();</span>
<span class="nc" id="L452">            Type rret = resolveNames(c, ret, synth);</span>
<span class="nc" id="L453">            Type args[] = t.getArgumentTypes();</span>
<span class="nc" id="L454">            Type rargs[] = new Type[args.length];</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            boolean changed = (ret != rret);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            for (int i = args.length ; i-- &gt; 0 ; ) {</span>
<span class="nc" id="L457">                Type arg = args[i];</span>
<span class="nc" id="L458">                Type rarg = resolveNames(c, arg, synth);</span>
<span class="nc" id="L459">                rargs[i] = rarg;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (arg != rarg) {</span>
<span class="nc" id="L461">                    changed = true;</span>
                }
<span class="nc" id="L463">            }</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (changed) {</span>
<span class="nc" id="L465">                t = Type.tMethod(rret, rargs);</span>
            }
            break;
          }
        }
<span class="nc" id="L470">        return t;</span>
    }

    /**
     * Resolve a class name, using only package and import directives.
     * Report no errors.
     * &lt;p&gt;
     */
    public Identifier resolveName(Identifier name) {
        // This logic is pretty exactly parallel to that of
        // ClassDefinition.resolveName().
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (name.isQualified()) {</span>
            // Try to resolve the first identifier component,
            // because inner class names take precedence over
            // package prefixes.  (Cf. ClassDefinition.resolveName.)
<span class="nc" id="L485">            Identifier rhead = resolveName(name.getHead());</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">            if (rhead.hasAmbigPrefix()) {</span>
                // The first identifier component refers to an
                // ambiguous class.  Limp on.  We throw away the
                // rest of the classname as it is irrelevant.
                // (part of solution for 4059855).
<span class="nc" id="L492">                return rhead;</span>
            }

<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (!this.classExists(rhead)) {</span>
<span class="nc" id="L496">                return this.resolvePackageQualifiedName(name);</span>
            }
            try {
<span class="nc" id="L499">                return this.getClassDefinition(rhead).</span>
<span class="nc" id="L500">                    resolveInnerClass(this, name.getTail());</span>
<span class="nc" id="L501">            } catch (ClassNotFound ee) {</span>
                // return partially-resolved name someone else can fail on
<span class="nc" id="L503">                return Identifier.lookupInner(rhead, name.getTail());</span>
            }
        }
        try {
<span class="nc" id="L507">            return resolve(name);</span>
<span class="nc" id="L508">        } catch (AmbiguousClass ee) {</span>
            // Don't force a resolution of the name if it is ambiguous.
            // Forcing the resolution would tack the current package
            // name onto the front of the class, which would be wrong.
            // Instead, mark the name as ambiguous and let a later stage
            // find the error by calling env.resolve(name).
            // (part of solution for 4059855).

<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (name.hasAmbigPrefix()) {</span>
<span class="nc" id="L517">                return name;</span>
            } else {
<span class="nc" id="L519">                return name.addAmbigPrefix();</span>
            }
<span class="nc" id="L521">        } catch (ClassNotFound ee) {</span>
            // last chance to make something halfway sensible
<span class="nc" id="L523">            Imports imports = getImports();</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            if (imports != null)</span>
<span class="nc" id="L525">                return imports.forceResolve(this, name);</span>
        }
<span class="nc" id="L527">        return name;</span>
    }

    /**
     * Discover if name consists of a package prefix, followed by the
     * name of a class (that actually exists), followed possibly by
     * some inner class names.  If we can't find a class that exists,
     * return the name unchanged.
     * &lt;p&gt;
     * This routine is used after a class name fails to
     * be resolved by means of imports or inner classes.
     * However, import processing uses this routine directly,
     * since import names must be exactly qualified to start with.
     */
    public final Identifier resolvePackageQualifiedName(Identifier name) {
<span class="nc" id="L542">        Identifier tail = null;</span>
        for (;;) {
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (classExists(name)) {</span>
<span class="nc" id="L545">                break;</span>
            }
<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (!name.isQualified()) {</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                name = (tail == null) ? name : Identifier.lookup(name, tail);</span>
<span class="nc" id="L549">                tail = null;</span>
<span class="nc" id="L550">                break;</span>
            }
<span class="nc" id="L552">            Identifier nm = name.getName();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            tail = (tail == null)? nm: Identifier.lookup(nm, tail);</span>
<span class="nc" id="L554">            name = name.getQualifier();</span>
<span class="nc" id="L555">        }</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (tail != null)</span>
<span class="nc" id="L557">            name = Identifier.lookupInner(name, tail);</span>
<span class="nc" id="L558">        return name;</span>
    }

    /**
     * Resolve a class name, using only package and import directives.
     */
    public Identifier resolve(Identifier nm) throws ClassNotFound {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (env == null)  return nm;    // a pretty useless no-op</span>
<span class="nc" id="L566">        return env.resolve(nm);</span>
    }

    /**
     * Get the imports used to resolve class names.
     */
    public Imports getImports() {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (env == null)  return null; // lame default</span>
<span class="nc" id="L574">        return env.getImports();</span>
    }

    /**
     * Create a new class.
     */
    public ClassDefinition makeClassDefinition(Environment origEnv, long where,
                                               IdentifierToken name,
                                               String doc, int modifiers,
                                               IdentifierToken superClass,
                                               IdentifierToken interfaces[],
                                               ClassDefinition outerClass) {
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (env == null)  return null; // lame default</span>
<span class="nc" id="L587">        return env.makeClassDefinition(origEnv, where, name,</span>
                                       doc, modifiers,
                                       superClass, interfaces, outerClass);
    }

    /**
     * Create a new field.
     */
    public MemberDefinition makeMemberDefinition(Environment origEnv, long where,
                                               ClassDefinition clazz,
                                               String doc, int modifiers,
                                               Type type, Identifier name,
                                               IdentifierToken argNames[],
                                               IdentifierToken expIds[],
                                               Object value) {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (env == null)  return null; // lame default</span>
<span class="nc" id="L603">        return env.makeMemberDefinition(origEnv, where, clazz, doc, modifiers,</span>
                                       type, name, argNames, expIds, value);
    }

    /**
     * Returns true if the given method is applicable to the given arguments
     */

    public boolean isApplicable(MemberDefinition m, Type args[]) throws ClassNotFound {
<span class="nc" id="L612">        Type mType = m.getType();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (!mType.isType(TC_METHOD))</span>
<span class="nc" id="L614">            return false;</span>
<span class="nc" id="L615">        Type mArgs[] = mType.getArgumentTypes();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (args.length != mArgs.length)</span>
<span class="nc" id="L617">            return false;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        for (int i = args.length ; --i &gt;= 0 ;)</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (!isMoreSpecific(args[i], mArgs[i]))</span>
<span class="nc" id="L620">                return false;</span>
<span class="nc" id="L621">        return true;</span>
    }


    /**
     * Returns true if &quot;best&quot; is in every argument at least as good as &quot;other&quot;
     */
    public boolean isMoreSpecific(MemberDefinition best, MemberDefinition other)
           throws ClassNotFound {
<span class="nc" id="L630">        Type bestType = best.getClassDeclaration().getType();</span>
<span class="nc" id="L631">        Type otherType = other.getClassDeclaration().getType();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        boolean result = isMoreSpecific(bestType, otherType)</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                      &amp;&amp; isApplicable(other, best.getType().getArgumentTypes());</span>
        // System.out.println(&quot;isMoreSpecific: &quot; + best + &quot;/&quot; + other
        //                      + &quot; =&gt; &quot; + result);
<span class="nc" id="L636">        return result;</span>
    }

    /**
     * Returns true if &quot;from&quot; is a more specific type than &quot;to&quot;
     */

    public boolean isMoreSpecific(Type from, Type to) throws ClassNotFound {
<span class="nc" id="L644">        return implicitCast(from, to);</span>
    }

    /**
     * Return true if an implicit cast from this type to
     * the given type is allowed.
     */
    public boolean implicitCast(Type from, Type to) throws ClassNotFound {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (from == to)</span>
<span class="nc" id="L653">            return true;</span>

<span class="nc" id="L655">        int toTypeCode = to.getTypeCode();</span>

<span class="nc bnc" id="L657" title="All 9 branches missed.">        switch(from.getTypeCode()) {</span>
        case TC_BYTE:
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (toTypeCode == TC_SHORT)</span>
<span class="nc" id="L660">                return true;</span>
        case TC_SHORT:
        case TC_CHAR:
<span class="nc bnc" id="L663" title="All 2 branches missed.">            if (toTypeCode == TC_INT) return true;</span>
        case TC_INT:
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (toTypeCode == TC_LONG) return true;</span>
        case TC_LONG:
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (toTypeCode == TC_FLOAT) return true;</span>
        case TC_FLOAT:
<span class="nc bnc" id="L669" title="All 2 branches missed.">            if (toTypeCode == TC_DOUBLE) return true;</span>
        case TC_DOUBLE:
        default:
<span class="nc" id="L672">            return false;</span>

        case TC_NULL:
<span class="nc" id="L675">            return to.inMask(TM_REFERENCE);</span>

        case TC_ARRAY:
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (!to.isType(TC_ARRAY)) {</span>
<span class="nc bnc" id="L679" title="All 6 branches missed.">                return (to == Type.tObject || to == Type.tCloneable</span>
                           || to == Type.tSerializable);
            } else {
                // both are arrays.  recurse down both until one isn't an array
                do {
<span class="nc" id="L684">                    from = from.getElementType();</span>
<span class="nc" id="L685">                    to = to.getElementType();</span>
<span class="nc bnc" id="L686" title="All 4 branches missed.">                } while (from.isType(TC_ARRAY) &amp;&amp; to.isType(TC_ARRAY));</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (  from.inMask(TM_ARRAY|TM_CLASS)</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">                      &amp;&amp; to.inMask(TM_ARRAY|TM_CLASS)) {</span>
<span class="nc" id="L689">                    return isMoreSpecific(from, to);</span>
                } else {
<span class="nc bnc" id="L691" title="All 2 branches missed.">                    return (from.getTypeCode() == to.getTypeCode());</span>
                }
            }

        case TC_CLASS:
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (toTypeCode == TC_CLASS) {</span>
<span class="nc" id="L697">                ClassDefinition fromDef = getClassDefinition(from);</span>
<span class="nc" id="L698">                ClassDefinition toDef = getClassDefinition(to);</span>
<span class="nc" id="L699">                return toDef.implementedBy(this,</span>
<span class="nc" id="L700">                                           fromDef.getClassDeclaration());</span>
            } else {
<span class="nc" id="L702">                return false;</span>
            }
        }
    }


    /**
     * Return true if an explicit cast from this type to
     * the given type is allowed.
     */
    public boolean explicitCast(Type from, Type to) throws ClassNotFound {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (implicitCast(from, to)) {</span>
<span class="nc" id="L714">            return true;</span>
        }
<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (from.inMask(TM_NUMBER)) {</span>
<span class="nc" id="L717">            return to.inMask(TM_NUMBER);</span>
        }
<span class="nc bnc" id="L719" title="All 4 branches missed.">        if (from.isType(TC_CLASS) &amp;&amp; to.isType(TC_CLASS)) {</span>
<span class="nc" id="L720">            ClassDefinition fromClass = getClassDefinition(from);</span>
<span class="nc" id="L721">            ClassDefinition toClass = getClassDefinition(to);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (toClass.isFinal()) {</span>
<span class="nc" id="L723">                return fromClass.implementedBy(this,</span>
<span class="nc" id="L724">                                               toClass.getClassDeclaration());</span>
            }
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (fromClass.isFinal()) {</span>
<span class="nc" id="L727">                return toClass.implementedBy(this,</span>
<span class="nc" id="L728">                                             fromClass.getClassDeclaration());</span>
            }

            // The code here used to omit this case.  If both types
            // involved in a cast are interfaces, then JLS 5.5 requires
            // that we do a simple test -- make sure none of the methods
            // in toClass and fromClass have the same signature but
            // different return types.  (bug number 4028359)
<span class="nc bnc" id="L736" title="All 4 branches missed.">            if (toClass.isInterface() &amp;&amp; fromClass.isInterface()) {</span>
<span class="nc" id="L737">                return toClass.couldImplement(fromClass);</span>
            }

<span class="nc bnc" id="L740" title="All 2 branches missed.">            return toClass.isInterface() ||</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">                   fromClass.isInterface() ||</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                   fromClass.superClassOf(this, toClass.getClassDeclaration());</span>
        }
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (to.isType(TC_ARRAY)) {</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (from.isType(TC_ARRAY))  {</span>
<span class="nc" id="L746">                Type t1 = from.getElementType();</span>
<span class="nc" id="L747">                Type t2 = to.getElementType();</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                while ((t1.getTypeCode() == TC_ARRAY)</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                       &amp;&amp; (t2.getTypeCode() == TC_ARRAY)) {</span>
<span class="nc" id="L750">                    t1 = t1.getElementType();</span>
<span class="nc" id="L751">                    t2 = t2.getElementType();</span>
                }
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if (t1.inMask(TM_ARRAY|TM_CLASS) &amp;&amp;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                    t2.inMask(TM_ARRAY|TM_CLASS)) {</span>
<span class="nc" id="L755">                    return explicitCast(t1, t2);</span>
                }
<span class="nc bnc" id="L757" title="All 6 branches missed.">            } else if (from == Type.tObject || from == Type.tCloneable</span>
                          || from == Type.tSerializable)
<span class="nc" id="L759">                return true;</span>
        }
<span class="nc" id="L761">        return false;</span>
    }

    /**
     * Flags.
     */
    public int getFlags() {
<span class="nc" id="L768">        return env.getFlags();</span>
    }

    /**
     * Debugging flags.  There used to be a method debug()
     * that has been replaced because -g has changed meaning
     * (it now cooperates with -O and line number, variable
     * range and source file info can be toggled separately).
     */
    public final boolean debug_lines() {
<span class="nc bnc" id="L778" title="All 2 branches missed.">        return (getFlags() &amp; F_DEBUG_LINES) != 0;</span>
    }
    public final boolean debug_vars() {
<span class="nc bnc" id="L781" title="All 2 branches missed.">        return (getFlags() &amp; F_DEBUG_VARS) != 0;</span>
    }
    public final boolean debug_source() {
<span class="nc bnc" id="L784" title="All 2 branches missed.">        return (getFlags() &amp; F_DEBUG_SOURCE) != 0;</span>
    }

    /**
     * Optimization flags.  There used to be a method optimize()
     * that has been replaced because -O has changed meaning in
     * javac to be replaced with -O and -O:interclass.
     */
    public final boolean opt() {
<span class="nc bnc" id="L793" title="All 2 branches missed.">        return (getFlags() &amp; F_OPT) != 0;</span>
    }
    public final boolean opt_interclass() {
<span class="nc bnc" id="L796" title="All 2 branches missed.">        return (getFlags() &amp; F_OPT_INTERCLASS) != 0;</span>
    }

    /**
     * Verbose
     */
    public final boolean verbose() {
<span class="nc bnc" id="L803" title="All 2 branches missed.">        return (getFlags() &amp; F_VERBOSE) != 0;</span>
    }

    /**
     * Dump debugging stuff
     */
    public final boolean dump() {
<span class="nc bnc" id="L810" title="All 2 branches missed.">        return (getFlags() &amp; F_DUMP) != 0;</span>
    }

    /**
     * Verbose
     */
    public final boolean warnings() {
<span class="nc bnc" id="L817" title="All 2 branches missed.">        return (getFlags() &amp; F_WARNINGS) != 0;</span>
    }

    /**
     * Dependencies
     */
    public final boolean dependencies() {
<span class="nc bnc" id="L824" title="All 2 branches missed.">        return (getFlags() &amp; F_DEPENDENCIES) != 0;</span>
    }

    /**
     * Print Dependencies to stdout
     */
    public final boolean print_dependencies() {
<span class="nc bnc" id="L831" title="All 2 branches missed.">        return (getFlags() &amp; F_PRINT_DEPENDENCIES) != 0;</span>
    }

    /**
     * Deprecation warnings are enabled.
     */
    public final boolean deprecation() {
<span class="nc bnc" id="L838" title="All 2 branches missed.">        return (getFlags() &amp; F_DEPRECATION) != 0;</span>
    }

    /**
     * Do not support virtual machines before version 1.2.
     * This option is not supported and is only here for testing purposes.
     */
    public final boolean version12() {
<span class="nc bnc" id="L846" title="All 2 branches missed.">        return (getFlags() &amp; F_VERSION12) != 0;</span>
    }

    /**
     * Floating point is strict by default
     */
    public final boolean strictdefault() {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        return (getFlags() &amp; F_STRICTDEFAULT) != 0;</span>
    }

    /**
     * Release resources, if any.
     */
    public void shutdown() {
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (env != null) {</span>
<span class="nc" id="L861">            env.shutdown();</span>
        }
<span class="nc" id="L863">    }</span>

    /**
     * Issue an error.
     *  source   - the input source, usually a file name string
     *  offset   - the offset in the source of the error
     *  err      - the error number (as defined in this interface)
     *  arg1     - an optional argument to the error (null if not applicable)
     *  arg2     - a second optional argument to the error (null if not applicable)
     *  arg3     - a third optional argument to the error (null if not applicable)
     */
    public void error(Object source, long where, String err, Object arg1, Object arg2, Object arg3) {
<span class="nc" id="L875">        env.error(source, where, err, arg1, arg2, arg3);</span>
<span class="nc" id="L876">    }</span>
    public final void error(long where, String err, Object arg1, Object arg2, Object arg3) {
<span class="nc" id="L878">        error(source, where, err, arg1, arg2, arg3);</span>
<span class="nc" id="L879">    }</span>
    public final void error(long where, String err, Object arg1, Object arg2) {
<span class="nc" id="L881">        error(source, where, err, arg1, arg2, null);</span>
<span class="nc" id="L882">    }</span>
    public final void error(long where, String err, Object arg1) {
<span class="nc" id="L884">        error(source, where, err, arg1, null, null);</span>
<span class="nc" id="L885">    }</span>
    public final void error(long where, String err) {
<span class="nc" id="L887">        error(source, where, err, null, null, null);</span>
<span class="nc" id="L888">    }</span>

    /**
     * Output a string. This can either be an error message or something
     * for debugging. This should be used instead of println.
     */
    public void output(String msg) {
<span class="nc" id="L895">        env.output(msg);</span>
<span class="nc" id="L896">    }</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">    private static boolean debugging = (System.getProperty(&quot;javac.debug&quot;) != null);</span>

    public static void debugOutput(Object msg) {
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (Environment.debugging)</span>
<span class="nc" id="L902">            System.out.println(msg.toString());</span>
<span class="nc" id="L903">    }</span>

    /**
     * set character encoding name
     */
    public void setCharacterEncoding(String encoding) {
<span class="nc" id="L909">        this.encoding = encoding;</span>
<span class="nc" id="L910">    }</span>

    /**
     * Return character encoding name
     */
    public String getCharacterEncoding() {
<span class="nc" id="L916">        return encoding;</span>
    }

    /**
     * Return major version to use in generated class files.
     */
    public short getMajorVersion() {
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (env==null) return JAVA_DEFAULT_VERSION;  // needed for javah</span>
<span class="nc" id="L924">        return env.getMajorVersion();</span>
    }

    /**
     * Return minor version to use in generated class files.
     */
    public short getMinorVersion() {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        if (env==null) return JAVA_DEFAULT_MINOR_VERSION;  // needed for javah</span>
<span class="nc" id="L932">        return env.getMinorVersion();</span>
    }

// JCOV
    /**
     *  get coverage flag
     */
    public final boolean coverage() {
<span class="nc bnc" id="L940" title="All 2 branches missed.">        return (getFlags() &amp; F_COVERAGE) != 0;</span>
    }

    /**
     *  get flag of generation the coverage data file
     */
    public final boolean covdata() {
<span class="nc bnc" id="L947" title="All 2 branches missed.">        return (getFlags() &amp; F_COVDATA) != 0;</span>
    }

    /**
     * Return the coverage data file
     */
    public File getcovFile() {
<span class="nc" id="L954">        return env.getcovFile();</span>
    }

// end JCOV

    /**
     * Debug tracing.
     * Currently, this code is used only for tracing the loading and
     * checking of classes, particularly the demand-driven aspects.
     * This code should probably be integrated with 'debugOutput' above,
     * but we need to give more thought to the issue of classifying debugging
     * messages and allowing those only those of interest to be enabled.
     *
     * Calls to these methods are generally conditioned on the final variable
     * 'Constants.tracing', which allows the calls to be completely omitted
     * in a production release to avoid space and time overhead.
     */

<span class="nc" id="L972">    private static boolean dependtrace =</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                (System.getProperty(&quot;javac.trace.depend&quot;) != null);</span>

    public void dtEnter(String s) {
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (dependtrace) System.out.println(&quot;&gt;&gt;&gt; &quot; + s);</span>
<span class="nc" id="L977">    }</span>

    public void dtExit(String s) {
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (dependtrace) System.out.println(&quot;&lt;&lt;&lt; &quot; + s);</span>
<span class="nc" id="L981">    }</span>

    public void dtEvent(String s) {
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (dependtrace) System.out.println(s);</span>
<span class="nc" id="L985">    }</span>

    /**
     * Enable diagnostic dump of class modifier bits, including those
     * in InnerClasses attributes, as they are written to the classfile.
     * In the future, may also enable dumping field and method modifiers.
     */

<span class="nc" id="L993">    private static boolean dumpmodifiers =</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                (System.getProperty(&quot;javac.dump.modifiers&quot;) != null);</span>

<span class="nc" id="L996">    public boolean dumpModifiers() { return dumpmodifiers; }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>