<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Identifier.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">Identifier.java</span></div><h1>Identifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.util.Hashtable;
import java.io.PrintStream;
import java.util.Enumeration;

/**
 * A class to represent identifiers.&lt;p&gt;
 *
 * An identifier instance is very similar to a String. The difference
 * is that identifier can't be instanciated directly, instead they are
 * looked up in a hash table. This means that identifiers with the same
 * name map to the same identifier object. This makes comparisons of
 * identifiers much faster.&lt;p&gt;
 *
 * A lot of identifiers are qualified, that is they have '.'s in them.
 * Each qualified identifier is chopped up into the qualifier and the
 * name. The qualifier is cached in the value field.&lt;p&gt;
 *
 * Unqualified identifiers can have a type. This type is an integer that
 * can be used by a scanner as a token value. This value has to be set
 * using the setType method.&lt;p&gt;
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author      Arthur van Hoff
 */

public final
class Identifier implements Constants {
    /**
     * The hashtable of identifiers
     */
<span class="nc" id="L61">    static Hashtable hash = new Hashtable(3001, 0.5f);</span>

    /**
     * The name of the identifier
     */
    String name;

    /**
     * The value of the identifier, for keywords this is an
     * instance of class Integer, for qualified names this is
     * another identifier (the qualifier).
     */
    Object value;

    /**
     * The Type which corresponds to this Identifier.  This is used as
     * cache for Type.tClass() and shouldn't be used outside of that
     * context.
     */
<span class="nc" id="L80">    Type typeObject = null;</span>

    /**
     * The index of INNERCLASS_PREFIX in the name, or -1 if none.
     */
    private int ipos;

    /**
     * Construct an identifier. Don't call this directly,
     * use lookup instead.
     * @see Identifier.lookup
     */
<span class="nc" id="L92">    private Identifier(String name) {</span>
<span class="nc" id="L93">        this.name = name;</span>
<span class="nc" id="L94">        this.ipos = name.indexOf(INNERCLASS_PREFIX);</span>
<span class="nc" id="L95">    }</span>

    /**
     * Get the type of the identifier.
     */
    int getType() {
<span class="nc bnc" id="L101" title="All 4 branches missed.">        return ((value != null) &amp;&amp; (value instanceof Integer)) ?</span>
<span class="nc" id="L102">                ((Integer)value).intValue() : IDENT;</span>
    }

    /**
     * Set the type of the identifier.
     */
    void setType(int t) {
<span class="nc" id="L109">        value = new Integer(t);</span>
        //System.out.println(&quot;type(&quot; + this + &quot;)=&quot; + t);
<span class="nc" id="L111">    }</span>

    /**
     * Lookup an identifier.
     */
    public static synchronized Identifier lookup(String s) {
        //System.out.println(&quot;lookup(&quot; + s + &quot;)&quot;);
<span class="nc" id="L118">        Identifier id = (Identifier)hash.get(s);</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (id == null) {</span>
<span class="nc" id="L120">            hash.put(s, id = new Identifier(s));</span>
        }
<span class="nc" id="L122">        return id;</span>
    }

    /**
     * Lookup a qualified identifier.
     */
    public static Identifier lookup(Identifier q, Identifier n) {
        // lookup(&quot;&quot;, x) =&gt; x
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (q == idNull)  return n;</span>
        // lookup(lookupInner(c, &quot;&quot;), n) =&gt; lookupInner(c, lookup(&quot;&quot;, n))
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (q.name.charAt(q.name.length()-1) == INNERCLASS_PREFIX)</span>
<span class="nc" id="L133">            return lookup(q.name+n.name);</span>
<span class="nc" id="L134">        Identifier id = lookup(q + &quot;.&quot; + n);</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">        if (!n.isQualified() &amp;&amp; !q.isInner())</span>
<span class="nc" id="L136">            id.value = q;</span>
<span class="nc" id="L137">        return id;</span>
    }

    /**
     * Lookup an inner identifier.
     * (Note:  n can be idNull.)
     */
    public static Identifier lookupInner(Identifier c, Identifier n) {
        Identifier id;
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (c.isInner()) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (c.name.charAt(c.name.length()-1) == INNERCLASS_PREFIX)</span>
<span class="nc" id="L148">                id = lookup(c.name+n);</span>
            else
<span class="nc" id="L150">                id = lookup(c, n);</span>
        } else {
<span class="nc" id="L152">            id = lookup(c + &quot;.&quot; + INNERCLASS_PREFIX + n);</span>
        }
<span class="nc" id="L154">        id.value = c.value;</span>
<span class="nc" id="L155">        return id;</span>
    }

    /**
     * Convert to a string.
     */
    public String toString() {
<span class="nc" id="L162">        return name;</span>
    }

    /**
     * Check if the name is qualified (ie: it contains a '.').
     */
    public boolean isQualified() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L170">            int idot = ipos;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (idot &lt;= 0)</span>
<span class="nc" id="L172">                idot = name.length();</span>
            else
<span class="nc" id="L174">                idot -= 1;      // back up over previous dot</span>
<span class="nc" id="L175">            int index = name.lastIndexOf('.', idot-1);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            value = (index &lt; 0) ? idNull : Identifier.lookup(name.substring(0, index));</span>
        }
<span class="nc bnc" id="L178" title="All 4 branches missed.">        return (value instanceof Identifier) &amp;&amp; (value != idNull);</span>
    }

    /**
     * Return the qualifier. The null identifier is returned if
     * the name was not qualified.  The qualifier does not include
     * any inner part of the name.
     */
    public Identifier getQualifier() {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        return isQualified() ? (Identifier)value : idNull;</span>
    }

    /**
     * Return the unqualified name.
     * In the case of an inner name, the unqualified name
     * will itself contain components.
     */
    public Identifier getName() {
<span class="nc bnc" id="L196" title="All 2 branches missed.">        return isQualified() ?</span>
<span class="nc" id="L197">            Identifier.lookup(name.substring(((Identifier)value).name.length() + 1)) : this;</span>
    }

    /** A space character, which precedes the first inner class
     *  name in a qualified name, and thus marks the qualification
     *  as involving inner classes, instead of merely packages.&lt;p&gt;
     *  Ex:  &lt;tt&gt;java.util.Vector. Enumerator&lt;/tt&gt;.
     */
    public static final char INNERCLASS_PREFIX = ' ';

    /* Explanation:
     * Since much of the compiler's low-level name resolution code
     * operates in terms of Identifier objects.  This includes the
     * code which walks around the file system and reports what
     * classes are where.  It is important to get nesting information
     * right as early as possible, since it affects the spelling of
     * signatures.  Thus, the low-level import and resolve code must
     * be able Identifier type must be able to report the nesting
     * of types, which implied that that information must be carried
     * by Identifiers--or that the low-level interfaces be significantly
     * changed.
     */

    /**
     * Check if the name is inner (ie: it contains a ' ').
     */
    public boolean isInner() {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        return (ipos &gt; 0);</span>
    }

    /**
     * Return the class name, without its qualifier,
     * and with any nesting flattened into a new qualfication structure.
     * If the original identifier is inner,
     * the result will be qualified, and can be further
     * decomposed by means of &lt;tt&gt;getQualifier&lt;/tt&gt; and &lt;tt&gt;getName&lt;/tt&gt;.
     * &lt;p&gt;
     * For example:
     * &lt;pre&gt;
     * Identifier id = Identifier.lookup(&quot;pkg.Foo. Bar&quot;);
     * id.getName().name      =&gt;  &quot;Foo. Bar&quot;
     * id.getFlatName().name  =&gt;  &quot;Foo.Bar&quot;
     * &lt;/pre&gt;
     */
    public Identifier getFlatName() {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (isQualified()) {</span>
<span class="nc" id="L243">            return getName().getFlatName();</span>
        }
<span class="nc bnc" id="L245" title="All 4 branches missed.">        if (ipos &gt; 0 &amp;&amp; name.charAt(ipos-1) == '.') {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (ipos+1 == name.length()) {</span>
                // last component is idNull
<span class="nc" id="L248">                return Identifier.lookup(name.substring(0,ipos-1));</span>
            }
<span class="nc" id="L250">            String n = name.substring(ipos+1);</span>
<span class="nc" id="L251">            String t = name.substring(0,ipos);</span>
<span class="nc" id="L252">            return Identifier.lookup(t+n);</span>
        }
        // Not inner.  Just return the same as getName()
<span class="nc" id="L255">        return this;</span>
    }

    public Identifier getTopName() {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (!isInner())  return this;</span>
<span class="nc" id="L260">        return Identifier.lookup(getQualifier(), getFlatName().getHead());</span>
    }

    /**
     * Yet another way to slice qualified identifiers:
     * The head of an identifier is its first qualifier component,
     * and the tail is the rest of them.
     */
    public Identifier getHead() {
<span class="nc" id="L269">        Identifier id = this;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        while (id.isQualified())</span>
<span class="nc" id="L271">            id = id.getQualifier();</span>
<span class="nc" id="L272">        return id;</span>
    }

    /**
     * @see getHead
     */
    public Identifier getTail() {
<span class="nc" id="L279">        Identifier id = getHead();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (id == this)</span>
<span class="nc" id="L281">            return idNull;</span>
        else
<span class="nc" id="L283">            return Identifier.lookup(name.substring(id.name.length() + 1));</span>
    }

    // Unfortunately, the current structure of the compiler requires
    // that the resolveName() family of methods (which appear in
    // Environment.java, Context.java, and ClassDefinition.java) raise
    // no exceptions and emit no errors.  When we are in resolveName()
    // and we find a method that is ambiguous, we need to
    // unambiguously mark it as such, so that later stages of the
    // compiler realize that they should give an ambig.class rather than
    // a class.not.found error.  To mark it we add a special prefix
    // which cannot occur in the program source.  The routines below
    // are used to check, add, and remove this prefix.
    // (part of solution for 4059855).

    /**
     * A special prefix to add to ambiguous names.
     */
    private static final String ambigPrefix = &quot;&lt;&lt;ambiguous&gt;&gt;&quot;;

    /**
     * Determine whether an Identifier has been marked as ambiguous.
     */
    public boolean hasAmbigPrefix() {
<span class="nc" id="L307">        return (name.startsWith(ambigPrefix));</span>
    }

    /**
     * Add ambigPrefix to `this' to make a new Identifier marked as
     * ambiguous.  It is important that this new Identifier not refer
     * to an existing class.
     */
    public Identifier addAmbigPrefix() {
<span class="nc" id="L316">        return Identifier.lookup(ambigPrefix + name);</span>
    }

    /**
     * Remove the ambigPrefix from `this' to get the original identifier.
     */
    public Identifier removeAmbigPrefix() {
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (hasAmbigPrefix()) {</span>
<span class="nc" id="L324">            return Identifier.lookup(name.substring(ambigPrefix.length()));</span>
        } else {
<span class="nc" id="L326">            return this;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>