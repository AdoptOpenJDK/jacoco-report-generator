<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BinaryClass.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">BinaryClass.java</span></div><h1>BinaryClass.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.io.IOException;
import java.io.DataInputStream;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayInputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

/**
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public final
class BinaryClass extends ClassDefinition implements Constants {
    BinaryConstantPool cpool;
    BinaryAttribute atts;
    Vector dependencies;
<span class="nc" id="L47">    private boolean haveLoadedNested = false;</span>

    /**
     * Constructor
     */
    public BinaryClass(Object source, ClassDeclaration declaration, int modifiers,
                           ClassDeclaration superClass, ClassDeclaration interfaces[],
                           Vector dependencies) {
<span class="nc" id="L55">        super(source, 0, declaration, modifiers, null, null);</span>
<span class="nc" id="L56">        this.dependencies = dependencies;</span>
<span class="nc" id="L57">        this.superClass = superClass;</span>
<span class="nc" id="L58">        this.interfaces = interfaces;</span>
<span class="nc" id="L59">    }</span>

    /**
     * Flags used by basicCheck() to avoid duplicate calls.
     * (Part of fix for 4105911)
     */
<span class="nc" id="L65">    private boolean basicCheckDone = false;</span>
<span class="nc" id="L66">    private boolean basicChecking = false;</span>

    /**
     * Ready a BinaryClass for further checking.  Note that, until recently,
     * BinaryClass relied on the default basicCheck() provided by
     * ClassDefinition.  The definition here has been added to ensure that
     * the information generated by collectInheritedMethods is available
     * for BinaryClasses.
     */
    protected void basicCheck(Environment env) throws ClassNotFound {
<span class="nc" id="L76">        if (tracing) env.dtEnter(&quot;BinaryClass.basicCheck: &quot; + getName());</span>

        // We need to guard against duplicate calls to basicCheck().  They
        // can lead to calling collectInheritedMethods() for this class
        // from within a previous call to collectInheritedMethods() for
        // this class.  That is not allowed.
        // (Part of fix for 4105911)
<span class="nc bnc" id="L83" title="All 4 branches missed.">        if (basicChecking || basicCheckDone) {</span>
<span class="nc" id="L84">            if (tracing) env.dtExit(&quot;BinaryClass.basicCheck: OK &quot; + getName());</span>
<span class="nc" id="L85">            return;</span>
        }

<span class="nc" id="L88">        if (tracing) env.dtEvent(&quot;BinaryClass.basicCheck: CHECKING &quot; + getName());</span>
<span class="nc" id="L89">        basicChecking = true;</span>

<span class="nc" id="L91">        super.basicCheck(env);</span>

        // Collect inheritance information.
<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (doInheritanceChecks) {</span>
<span class="nc" id="L95">            collectInheritedMethods(env);</span>
        }

<span class="nc" id="L98">        basicCheckDone = true;</span>
<span class="nc" id="L99">        basicChecking = false;</span>
<span class="nc" id="L100">        if (tracing) env.dtExit(&quot;BinaryClass.basicCheck: &quot; + getName());</span>
<span class="nc" id="L101">    }</span>

    /**
     * Load a binary class
     */
    public static BinaryClass load(Environment env, DataInputStream in) throws IOException {
<span class="nc" id="L107">        return load(env, in, ~(ATT_CODE|ATT_ALLCLASSES));</span>
    }

    public static BinaryClass load(Environment env,
                                   DataInputStream in, int mask) throws IOException {
        // Read the header
<span class="nc" id="L113">        int magic = in.readInt();                    // JVM 4.1 ClassFile.magic</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (magic != JAVA_MAGIC) {</span>
<span class="nc" id="L115">            throw new ClassFormatError(&quot;wrong magic: &quot; + magic + &quot;, expected &quot; + JAVA_MAGIC);</span>
        }
<span class="nc" id="L117">        int minor_version = in.readUnsignedShort();  // JVM 4.1 ClassFile.minor_version</span>
<span class="nc" id="L118">        int version = in.readUnsignedShort();        // JVM 4.1 ClassFile.major_version</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (version &lt; JAVA_MIN_SUPPORTED_VERSION) {</span>
<span class="nc" id="L120">            throw new ClassFormatError(</span>
<span class="nc" id="L121">                           sun.tools.javac.Main.getText(</span>
                               &quot;javac.err.version.too.old&quot;,
<span class="nc" id="L123">                               String.valueOf(version)));</span>
<span class="nc bnc" id="L124" title="All 6 branches missed.">        } else if ((version &gt; JAVA_MAX_SUPPORTED_VERSION)</span>
                     || (version == JAVA_MAX_SUPPORTED_VERSION
                  &amp;&amp; minor_version &gt; JAVA_MAX_SUPPORTED_MINOR_VERSION)) {
<span class="nc" id="L127">            throw new ClassFormatError(</span>
<span class="nc" id="L128">                           sun.tools.javac.Main.getText(</span>
                               &quot;javac.err.version.too.recent&quot;,
                               version+&quot;.&quot;+minor_version));
        }

        // Read the constant pool
<span class="nc" id="L134">        BinaryConstantPool cpool = new BinaryConstantPool(in);</span>

        // The dependencies of this class
<span class="nc" id="L137">        Vector dependencies = cpool.getDependencies(env);</span>

        // Read modifiers
<span class="nc" id="L140">        int classMod = in.readUnsignedShort() &amp; ACCM_CLASS;  // JVM 4.1 ClassFile.access_flags</span>

        // Read the class name - from JVM 4.1 ClassFile.this_class
<span class="nc" id="L143">        ClassDeclaration classDecl = cpool.getDeclaration(env, in.readUnsignedShort());</span>

        // Read the super class name (may be null) - from JVM 4.1 ClassFile.super_class
<span class="nc" id="L146">        ClassDeclaration superClassDecl = cpool.getDeclaration(env, in.readUnsignedShort());</span>

        // Read the interface names - from JVM 4.1 ClassFile.interfaces_count
<span class="nc" id="L149">        ClassDeclaration interfaces[] = new ClassDeclaration[in.readUnsignedShort()];</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
            // JVM 4.1 ClassFile.interfaces[]
<span class="nc" id="L152">            interfaces[i] = cpool.getDeclaration(env, in.readUnsignedShort());</span>
        }

        // Allocate the class
<span class="nc" id="L156">        BinaryClass c = new BinaryClass(null, classDecl, classMod, superClassDecl,</span>
                                        interfaces, dependencies);
<span class="nc" id="L158">        c.cpool = cpool;</span>

        // Add any additional dependencies
<span class="nc" id="L161">        c.addDependency(superClassDecl);</span>

        // Read the fields
<span class="nc" id="L164">        int nfields = in.readUnsignedShort();  // JVM 4.1 ClassFile.fields_count</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        for (int i = 0 ; i &lt; nfields ; i++) {</span>
            // JVM 4.5 field_info.access_flags
<span class="nc" id="L167">            int fieldMod = in.readUnsignedShort() &amp; ACCM_FIELD;</span>
            // JVM 4.5 field_info.name_index
<span class="nc" id="L169">            Identifier fieldName = cpool.getIdentifier(in.readUnsignedShort());</span>
            // JVM 4.5 field_info.descriptor_index
<span class="nc" id="L171">            Type fieldType = cpool.getType(in.readUnsignedShort());</span>
<span class="nc" id="L172">            BinaryAttribute atts = BinaryAttribute.load(in, cpool, mask);</span>
<span class="nc" id="L173">            c.addMember(new BinaryMember(c, fieldMod, fieldType, fieldName, atts));</span>
        }

        // Read the methods
<span class="nc" id="L177">        int nmethods = in.readUnsignedShort();  // JVM 4.1 ClassFile.methods_count</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        for (int i = 0 ; i &lt; nmethods ; i++) {</span>
            // JVM 4.6 method_info.access_flags
<span class="nc" id="L180">            int methMod = in.readUnsignedShort() &amp; ACCM_METHOD;</span>
            // JVM 4.6 method_info.name_index
<span class="nc" id="L182">            Identifier methName = cpool.getIdentifier(in.readUnsignedShort());</span>
            // JVM 4.6 method_info.descriptor_index
<span class="nc" id="L184">            Type methType = cpool.getType(in.readUnsignedShort());</span>
<span class="nc" id="L185">            BinaryAttribute atts = BinaryAttribute.load(in, cpool, mask);</span>
<span class="nc" id="L186">            c.addMember(new BinaryMember(c, methMod, methType, methName, atts));</span>
        }

        // Read the class attributes
<span class="nc" id="L190">        c.atts = BinaryAttribute.load(in, cpool, mask);</span>

        // See if the SourceFile is known
<span class="nc" id="L193">        byte data[] = c.getAttribute(idSourceFile);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L195">            DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(data));</span>
            // JVM 4.7.2 SourceFile_attribute.sourcefile_index
<span class="nc" id="L197">            c.source = cpool.getString(dataStream.readUnsignedShort());</span>
        }

        // See if the Documentation is know
<span class="nc" id="L201">        data = c.getAttribute(idDocumentation);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (data != null) {</span>
<span class="nc" id="L203">            c.documentation = new DataInputStream(new ByteArrayInputStream(data)).readUTF();</span>
        }

        // Was it compiled as deprecated?
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (c.getAttribute(idDeprecated) != null) {</span>
<span class="nc" id="L208">            c.modifiers |= M_DEPRECATED;</span>
        }

        // Was it synthesized by the compiler?
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (c.getAttribute(idSynthetic) != null) {</span>
<span class="nc" id="L213">            c.modifiers |= M_SYNTHETIC;</span>
        }

<span class="nc" id="L216">        return c;</span>
    }

    /**
     * Called when an environment ties a binary definition to a declaration.
     * At this point, auxiliary definitions may be loaded.
     */

    public void loadNested(Environment env) {
<span class="nc" id="L225">        loadNested(env, 0);</span>
<span class="nc" id="L226">    }</span>

    public void loadNested(Environment env, int flags) {
        // Sanity check.
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (haveLoadedNested) {</span>
            // Duplicate calls most likely should not occur, but they do
            // in javap.  Be tolerant of them for the time being.
            // throw new CompilerError(&quot;multiple loadNested&quot;);
<span class="nc" id="L234">            if (tracing) env.dtEvent(&quot;loadNested: DUPLICATE CALL SKIPPED&quot;);</span>
<span class="nc" id="L235">            return;</span>
        }
<span class="nc" id="L237">        haveLoadedNested = true;</span>
        // Read class-nesting information.
        try {
            byte data[];
<span class="nc" id="L241">            data = getAttribute(idInnerClasses);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (data != null) {</span>
<span class="nc" id="L243">                initInnerClasses(env, data, flags);</span>
            }
<span class="nc" id="L245">        } catch (IOException ee) {</span>
            // The inner classes attribute is not well-formed.
            // It may, for example, contain no data.  Report this.
            // We used to throw a CompilerError here (bug 4095108).
<span class="nc" id="L249">            env.error(0, &quot;malformed.attribute&quot;, getClassDeclaration(),</span>
                      idInnerClasses);
            if (tracing)
<span class="nc" id="L252">                env.dtEvent(&quot;loadNested: MALFORMED ATTRIBUTE (InnerClasses)&quot;);</span>
<span class="nc" id="L253">        }</span>
<span class="nc" id="L254">    }</span>

    private void initInnerClasses(Environment env,
                                  byte data[],
                                  int flags) throws IOException {
<span class="nc" id="L259">        DataInputStream ds = new DataInputStream(new ByteArrayInputStream(data));</span>
<span class="nc" id="L260">        int nrec = ds.readUnsignedShort();  // InnerClasses_attribute.number_of_classes</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        for (int i = 0; i &lt; nrec; i++) {</span>
            // For each inner class name transformation, we have a record
            // with the following fields:
            //
            //    u2 inner_class_info_index;   // CONSTANT_Class_info index
            //    u2 outer_class_info_index;   // CONSTANT_Class_info index
            //    u2 inner_name_index;         // CONSTANT_Utf8_info index
            //    u2 inner_class_access_flags; // access_flags bitmask
            //
            // The spec states that outer_class_info_index is 0 iff
            // the inner class is not a member of its enclosing class (i.e.
            // it is a local or anonymous class).  The spec also states
            // that if a class is anonymous then inner_name_index should
            // be 0.
            //
            // Prior to jdk1.2, javac did not implement the spec.  Instead
            // it &lt;em&gt;always&lt;/em&gt; set outer_class_info_index to the
            // enclosing outer class and if the class was anonymous,
            // it set inner_name_index to be the index of a CONSTANT_Utf8
            // entry containing the null string &quot;&quot; (idNull).  This code is
            // designed to handle either kind of class file.
            //
            // See also the compileClass() method in SourceClass.java.

            // Read in the inner_class_info
            // InnerClasses_attribute.classes.inner_class_info_index
<span class="nc" id="L287">            int inner_index = ds.readUnsignedShort();</span>
            // could check for zero.
<span class="nc" id="L289">            ClassDeclaration inner = cpool.getDeclaration(env, inner_index);</span>

            // Read in the outer_class_info.  Note that the index will be
            // zero if the class is &quot;not a member&quot;.
<span class="nc" id="L293">            ClassDeclaration outer = null;</span>
            // InnerClasses_attribute.classes.outer_class_info_index
<span class="nc" id="L295">            int outer_index = ds.readUnsignedShort();</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (outer_index != 0) {</span>
<span class="nc" id="L297">                outer = cpool.getDeclaration(env, outer_index);</span>
            }

            // Read in the inner_name_index.  This may be zero.  An anonymous
            // class will either have an inner_nm_index of zero (as the spec
            // dictates) or it will have an inner_nm of idNull (for classes
            // generated by pre-1.2 compilers).  Handle both.
<span class="nc" id="L304">            Identifier inner_nm = idNull;</span>
            // InnerClasses_attribute.classes.inner_name_index
<span class="nc" id="L306">            int inner_nm_index = ds.readUnsignedShort();</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (inner_nm_index != 0) {</span>
<span class="nc" id="L308">                inner_nm = Identifier.lookup(cpool.getString(inner_nm_index));</span>
            }

            // Read in the modifiers for the inner class.
            // InnerClasses_attribute.classes.inner_name_index
<span class="nc" id="L313">            int mods = ds.readUnsignedShort();</span>

            // Is the class accessible?
            // The old code checked for
            //
            //    (!inner_nm.equals(idNull) &amp;&amp; (mods &amp; M_PRIVATE) == 0)
            //
            // which we will preserve to keep it working for class files
            // generated by 1.1 compilers.  In addition we check for
            //
            //    (outer != null)
            //
            // as an additional check that only makes sense with 1.2
            // generated files.  Note that it is entirely possible that
            // the M_PRIVATE bit is always enough.  We are being
            // conservative here.
            //
            // The ATT_ALLCLASSES flag causes the M_PRIVATE modifier
            // to be ignored, and is used by tools such as 'javap' that
            // wish to examine all classes regardless of the normal access
            // controls that apply during compilation.  Note that anonymous
            // and local classes are still not considered accessible, though
            // named local classes in jdk1.1 may slip through.  Note that
            // this accessibility test is an optimization, and it is safe to
            // err on the side of greater accessibility.
<span class="nc bnc" id="L338" title="All 2 branches missed.">            boolean accessible =</span>
                (outer != null) &amp;&amp;
<span class="nc bnc" id="L340" title="All 6 branches missed.">                (!inner_nm.equals(idNull)) &amp;&amp;</span>
                ((mods &amp; M_PRIVATE) == 0 ||
                 (flags &amp; ATT_ALLCLASSES) != 0);

            // The reader should note that there has been a significant change
            // in the way that the InnerClasses attribute is being handled.
            // In particular, previously the compiler called initInner() for
            // &lt;em&gt;every&lt;/em&gt; inner class.  Now the compiler does not call
            // initInner() if the inner class is inaccessible.  This means
            // that inaccessible inner classes don't have any of the processing
            // from initInner() done for them: fixing the access flags,
            // setting outerClass, setting outerMember in their outerClass,
            // etc.  We believe this is fine: if the class is inaccessible
            // and binary, then everyone who needs to see its internals
            // has already been compiled.  Hopefully.

<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (accessible) {</span>
<span class="nc" id="L357">                Identifier nm =</span>
<span class="nc" id="L358">                    Identifier.lookupInner(outer.getName(), inner_nm);</span>

                // Tell the type module about the nesting relation:
<span class="nc" id="L361">                Type.tClass(nm);</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">                if (inner.equals(getClassDeclaration())) {</span>
                    // The inner class in the record is this class.
                    try {
<span class="nc" id="L366">                        ClassDefinition outerClass = outer.getClassDefinition(env);</span>
<span class="nc" id="L367">                        initInner(outerClass, mods);</span>
<span class="nc" id="L368">                    } catch (ClassNotFound e) {</span>
                        // report the error elsewhere
<span class="nc" id="L370">                    }</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                } else if (outer.equals(getClassDeclaration())) {</span>
                    // The outer class in the record is this class.
                    try {
<span class="nc" id="L374">                        ClassDefinition innerClass =</span>
<span class="nc" id="L375">                            inner.getClassDefinition(env);</span>
<span class="nc" id="L376">                        initOuter(innerClass, mods);</span>
<span class="nc" id="L377">                    } catch (ClassNotFound e) {</span>
                        // report the error elsewhere
<span class="nc" id="L379">                    }</span>
                }
            }
        }
<span class="nc" id="L383">    }</span>

    private void initInner(ClassDefinition outerClass, int mods) {
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (getOuterClass() != null)</span>
<span class="nc" id="L387">            return;             // already done</span>
        /******
        // Maybe set static, protected, or private.
        if ((modifiers &amp; M_PUBLIC) != 0)
            mods &amp;= M_STATIC;
        else
            mods &amp;= M_PRIVATE | M_PROTECTED | M_STATIC;
        modifiers |= mods;
        ******/
        // For an inner class, the class access may have been weakened
        // from that originally declared the source.  We must take the
        // actual access permissions against which we check any source
        // we are currently compiling from the InnerClasses attribute.
        // We attempt to guard here against bogus combinations of modifiers.
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if ((mods &amp; M_PRIVATE) != 0) {</span>
            // Private cannot be combined with public or protected.
<span class="nc" id="L403">            mods &amp;= ~(M_PUBLIC | M_PROTECTED);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        } else if ((mods &amp; M_PROTECTED) != 0) {</span>
            // Protected cannot be combined with public.
<span class="nc" id="L406">            mods &amp;= ~M_PUBLIC;</span>
        }
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if ((mods &amp; M_INTERFACE) != 0) {</span>
            // All interfaces are implicitly abstract.
            // All interfaces that are members of a type are implicitly static.
<span class="nc" id="L411">            mods |= (M_ABSTRACT | M_STATIC);</span>
        }
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (outerClass.isInterface()) {</span>
            // All types that are members of interfaces are implicitly
            // public and static.
<span class="nc" id="L416">            mods |= (M_PUBLIC | M_STATIC);</span>
<span class="nc" id="L417">            mods &amp;= ~(M_PRIVATE | M_PROTECTED);</span>
        }
<span class="nc" id="L419">        modifiers = mods;</span>

<span class="nc" id="L421">        setOuterClass(outerClass);</span>

<span class="nc" id="L423">        for (MemberDefinition field = getFirstMember();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">             field != null;</span>
<span class="nc" id="L425">             field = field.getNextMember()) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (field.isUplevelValue()</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                    &amp;&amp; outerClass.getType().equals(field.getType())</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                    &amp;&amp; field.getName().toString().startsWith(prefixThis)) {</span>
<span class="nc" id="L429">                setOuterMember(field);</span>
            }
        }
<span class="nc" id="L432">    }</span>

    private void initOuter(ClassDefinition innerClass, int mods) {
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (innerClass instanceof BinaryClass)</span>
<span class="nc" id="L436">            ((BinaryClass)innerClass).initInner(this, mods);</span>
<span class="nc" id="L437">        addMember(new BinaryMember(innerClass));</span>
<span class="nc" id="L438">    }</span>

    /**
     * Write the class out to a given stream.  This function mirrors the loader.
     */
    public void write(Environment env, OutputStream out) throws IOException {
<span class="nc" id="L444">        DataOutputStream data = new DataOutputStream(out);</span>

        // write out the header
<span class="nc" id="L447">        data.writeInt(JAVA_MAGIC);</span>
<span class="nc" id="L448">        data.writeShort(env.getMinorVersion());</span>
<span class="nc" id="L449">        data.writeShort(env.getMajorVersion());</span>

        // Write out the constant pool
<span class="nc" id="L452">        cpool.write(data, env);</span>

        // Write class information
<span class="nc" id="L455">        data.writeShort(getModifiers() &amp; ACCM_CLASS);</span>
<span class="nc" id="L456">        data.writeShort(cpool.indexObject(getClassDeclaration(), env));</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">        data.writeShort((getSuperClass() != null)</span>
<span class="nc" id="L458">                        ? cpool.indexObject(getSuperClass(), env) : 0);</span>
<span class="nc" id="L459">        data.writeShort(interfaces.length);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc" id="L461">            data.writeShort(cpool.indexObject(interfaces[i], env));</span>
        }

        // count the fields and the methods
<span class="nc" id="L465">        int fieldCount = 0, methodCount = 0;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        for (MemberDefinition f = firstMember; f != null; f = f.getNextMember())</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (f.isMethod()) methodCount++; else fieldCount++;</span>

        // write out each the field count, and then each field
<span class="nc" id="L470">        data.writeShort(fieldCount);</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        for (MemberDefinition f = firstMember; f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (!f.isMethod()) {</span>
<span class="nc" id="L473">                data.writeShort(f.getModifiers() &amp; ACCM_FIELD);</span>
<span class="nc" id="L474">                String name = f.getName().toString();</span>
<span class="nc" id="L475">                String signature = f.getType().getTypeSignature();</span>
<span class="nc" id="L476">                data.writeShort(cpool.indexString(name, env));</span>
<span class="nc" id="L477">                data.writeShort(cpool.indexString(signature, env));</span>
<span class="nc" id="L478">                BinaryAttribute.write(((BinaryMember)f).atts, data, cpool, env);</span>
            }
        }

        // write out each method count, and then each method
<span class="nc" id="L483">        data.writeShort(methodCount);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (MemberDefinition f = firstMember; f != null; f = f.getNextMember()) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (f.isMethod()) {</span>
<span class="nc" id="L486">                data.writeShort(f.getModifiers() &amp; ACCM_METHOD);</span>
<span class="nc" id="L487">                String name = f.getName().toString();</span>
<span class="nc" id="L488">                String signature = f.getType().getTypeSignature();</span>
<span class="nc" id="L489">                data.writeShort(cpool.indexString(name, env));</span>
<span class="nc" id="L490">                data.writeShort(cpool.indexString(signature, env));</span>
<span class="nc" id="L491">                BinaryAttribute.write(((BinaryMember)f).atts, data, cpool, env);</span>
            }
        }

        // write out the class attributes
<span class="nc" id="L496">        BinaryAttribute.write(atts, data, cpool, env);</span>
<span class="nc" id="L497">        data.flush();</span>
<span class="nc" id="L498">    }</span>

    /**
     * Get the dependencies
     */
    public Enumeration getDependencies() {
<span class="nc" id="L504">        return dependencies.elements();</span>
    }

    /**
     * Add a dependency
     */
    public void addDependency(ClassDeclaration c) {
<span class="nc bnc" id="L511" title="All 4 branches missed.">        if ((c != null) &amp;&amp; !dependencies.contains(c)) {</span>
<span class="nc" id="L512">            dependencies.addElement(c);</span>
        }
<span class="nc" id="L514">    }</span>

    /**
     * Get the constant pool
     */
    public BinaryConstantPool getConstants() {
<span class="nc" id="L520">        return cpool;</span>
    }

    /**
     * Get a class attribute
     */
    public byte getAttribute(Identifier name)[] {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        for (BinaryAttribute att = atts ; att != null ; att = att.next) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (att.name.equals(name)) {</span>
<span class="nc" id="L529">                return att.data;</span>
            }
        }
<span class="nc" id="L532">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>