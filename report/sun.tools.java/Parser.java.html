<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import sun.tools.tree.*;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Vector;

/**
 * This class is used to parse Java statements and expressions.
 * The result is a parse tree.&lt;p&gt;
 *
 * This class implements an operator precedence parser. Errors are
 * reported to the Environment object, if the error can't be
 * resolved immediately, a SyntaxError exception is thrown.&lt;p&gt;
 *
 * Error recovery is implemented by catching SyntaxError exceptions
 * and discarding input tokens until an input token is reached that
 * is possibly a legal continuation.&lt;p&gt;
 *
 * The parse tree that is constructed represents the input
 * exactly (no rewrites to simpler forms). This is important
 * if the resulting tree is to be used for code formatting in
 * a programming environment. Currently only documentation comments
 * are retained.&lt;p&gt;
 *
 * The parsing algorithm does NOT use any type information. Changes
 * in the type system do not affect the structure of the parse tree.
 * This restriction does introduce an ambiguity an expression of the
 * form: (e1) e2 is assumed to be a cast if e2 does not start with
 * an operator. That means that (a) - b is interpreted as subtract
 * b from a and not cast negative b to type a. However, if a is a
 * simple type (byte, int, ...) then it is assumed to be a cast.&lt;p&gt;
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * @author      Arthur van Hoff
 */

public
class Parser extends Scanner implements ParserActions, Constants {
    /**
     * Create a parser
     */
    protected Parser(Environment env, InputStream in) throws IOException {
<span class="nc" id="L73">        super(env, in);</span>
<span class="nc" id="L74">        this.scanner = this;</span>
<span class="nc" id="L75">        this.actions = this;</span>
<span class="nc" id="L76">    }</span>

    /**
     * Create a parser, given a scanner.
     */
    protected Parser(Scanner scanner) throws IOException {
<span class="nc" id="L82">        super(scanner.env);</span>
<span class="nc" id="L83">        this.scanner = scanner;</span>
<span class="nc" id="L84">        ((Scanner)this).env = scanner.env;</span>
<span class="nc" id="L85">        ((Scanner)this).token = scanner.token;</span>
<span class="nc" id="L86">        ((Scanner)this).pos = scanner.pos;</span>
<span class="nc" id="L87">        this.actions = this;</span>
<span class="nc" id="L88">    }</span>

    /**
     * Create a parser, given a scanner and the semantic callback.
     */
    public Parser(Scanner scanner, ParserActions actions) throws IOException {
<span class="nc" id="L94">        this(scanner);</span>
<span class="nc" id="L95">        this.actions = actions;</span>
<span class="nc" id="L96">    }</span>

    /**
     * Usually &lt;code&gt;this.actions == (ParserActions)this&lt;/code&gt;.
     * However, a delegate scanner can produce tokens for this parser,
     * in which case &lt;code&gt;(Scanner)this&lt;/code&gt; is unused,
     * except for &lt;code&gt;this.token&lt;/code&gt; and &lt;code&gt;this.pos&lt;/code&gt;
     * instance variables which are filled from the real scanner
     * by &lt;code&gt;this.scan()&lt;/code&gt; and the constructor.
     */
    ParserActions actions;

    // Note:  The duplication of methods allows pre-1.1 classes to
    // be binary compatible with the new version of the parser,
    // which now passes IdentifierTokens to the semantics phase,
    // rather than just Identifiers.  This change is necessary,
    // since the parser is no longer responsible for managing the
    // resolution of type names.  (That caused the &quot;Vector&quot; bug.)
    //
    // In a future release, the old &quot;plain-Identifier&quot; methods will
    // go away, and the corresponding &quot;IdentifierToken&quot; methods
    // may become abstract.

    /**
     * package declaration
     * @deprecated
     */
    @Deprecated
    public void packageDeclaration(long off, IdentifierToken nm) {
        // By default, call the deprecated version.
        // Any application must override one of the packageDeclaration methods.
<span class="nc" id="L127">        packageDeclaration(off, nm.id);</span>
<span class="nc" id="L128">    }</span>
    /**
     * @deprecated
     */
    @Deprecated
    protected void packageDeclaration(long off, Identifier nm) {
<span class="nc" id="L134">        throw new RuntimeException(&quot;beginClass method is abstract&quot;);</span>
    }

    /**
     * import class
     * @deprecated
     */
    @Deprecated
    public void importClass(long off, IdentifierToken nm) {
        // By default, call the deprecated version.
        // Any application must override one of the packageDeclaration methods.
<span class="nc" id="L145">        importClass(off, nm.id);</span>
<span class="nc" id="L146">    }</span>
    /**
     * @deprecated Use the version with the IdentifierToken arguments.
     */
    @Deprecated
    protected void importClass(long off, Identifier nm) {
<span class="nc" id="L152">        throw new RuntimeException(&quot;importClass method is abstract&quot;);</span>
    }

    /**
     * import package
     * @deprecated
     */
    @Deprecated
    public void importPackage(long off, IdentifierToken nm) {
        // By default, call the deprecated version.
        // Any application must override one of the importPackage methods.
<span class="nc" id="L163">        importPackage(off, nm.id);</span>
<span class="nc" id="L164">    }</span>
    /**
     * @deprecated Use the version with the IdentifierToken arguments.
     */
    @Deprecated
    protected void importPackage(long off, Identifier nm) {
<span class="nc" id="L170">        throw new RuntimeException(&quot;importPackage method is abstract&quot;);</span>
    }

    /**
     * Define class
     * @deprecated
     */
    @Deprecated
    public ClassDefinition beginClass(long off, String doc,
                                      int mod, IdentifierToken nm,
                                      IdentifierToken sup,
                                      IdentifierToken impl[]) {
        // By default, call the deprecated version.
        // Any application must override one of the beginClass methods.
<span class="nc bnc" id="L184" title="All 2 branches missed.">        Identifier supId = (sup == null) ? null : sup.id;</span>
<span class="nc" id="L185">        Identifier implIds[] = null;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (impl != null) {</span>
<span class="nc" id="L187">            implIds = new Identifier[impl.length];</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            for (int i = 0; i &lt; impl.length; i++) {</span>
<span class="nc" id="L189">                implIds[i] = impl[i].id;</span>
            }
        }
<span class="nc" id="L192">        beginClass(off, doc, mod, nm.id, supId, implIds);</span>
<span class="nc" id="L193">        return getCurrentClass();</span>
    }
    /**
     * @deprecated Use the version with the IdentifierToken arguments.
     */
    @Deprecated
    protected void beginClass(long off, String doc, int mod, Identifier nm,
                              Identifier sup, Identifier impl[]) {
<span class="nc" id="L201">        throw new RuntimeException(&quot;beginClass method is abstract&quot;);</span>
    }

    /**
     * Report the current class under construction.
     * By default, it's a no-op which returns null.
     * It may only be called before the corresponding endClass().
     */
    protected ClassDefinition getCurrentClass() {
<span class="nc" id="L210">        return null;</span>
    }

    /**
     * End class
     * @deprecated
     */
    @Deprecated
    public void endClass(long off, ClassDefinition c) {
        // By default, call the deprecated version.
        // Any application must override one of the beginClass methods.
<span class="nc" id="L221">        endClass(off, c.getName().getFlatName().getName());</span>
<span class="nc" id="L222">    }</span>
    /**
     * @deprecated Use the version with the IdentifierToken arguments.
     */
    @Deprecated
    protected void endClass(long off, Identifier nm) {
<span class="nc" id="L228">        throw new RuntimeException(&quot;endClass method is abstract&quot;);</span>
    }

    /**
     * Define a field
     * @deprecated
     */
    @Deprecated
    public void defineField(long where, ClassDefinition c,
                            String doc, int mod, Type t,
                            IdentifierToken nm, IdentifierToken args[],
                            IdentifierToken exp[], Node val) {
        // By default, call the deprecated version.
        // Any application must override one of the defineField methods.
<span class="nc" id="L242">        Identifier argIds[] = null;</span>
<span class="nc" id="L243">        Identifier expIds[] = null;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (args != null) {</span>
<span class="nc" id="L245">            argIds = new Identifier[args.length];</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc" id="L247">                argIds[i] = args[i].id;</span>
            }
        }
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (exp != null) {</span>
<span class="nc" id="L251">            expIds = new Identifier[exp.length];</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            for (int i = 0; i &lt; exp.length; i++) {</span>
<span class="nc" id="L253">                expIds[i] = exp[i].id;</span>
            }
        }
<span class="nc" id="L256">        defineField(where, doc, mod, t, nm.id, argIds, expIds, val);</span>
<span class="nc" id="L257">    }</span>

    /**
     * @deprecated Use the version with the IdentifierToken arguments.
     */
    @Deprecated
    protected void defineField(long where, String doc, int mod, Type t,
                               Identifier nm, Identifier args[],
                               Identifier exp[], Node val) {
<span class="nc" id="L266">        throw new RuntimeException(&quot;defineField method is abstract&quot;);</span>
    }

    /*
     * A growable array of nodes. It is used as a growable
     * buffer to hold argument lists and expression lists.
     * I'm not using Vector to make it more efficient.
     */
<span class="nc" id="L274">    private Node args[] = new Node[32];</span>
<span class="nc" id="L275">    protected int argIndex = 0;</span>

    protected final void addArgument(Node n) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (argIndex == args.length) {</span>
<span class="nc" id="L279">            Node newArgs[] = new Node[args.length * 2];</span>
<span class="nc" id="L280">            System.arraycopy(args, 0, newArgs, 0, args.length);</span>
<span class="nc" id="L281">            args = newArgs;</span>
        }
<span class="nc" id="L283">        args[argIndex++] = n;</span>
<span class="nc" id="L284">    }</span>
    protected final Expression exprArgs(int index)[] {
<span class="nc" id="L286">        Expression e[] = new Expression[argIndex - index];</span>
<span class="nc" id="L287">        System.arraycopy(args, index, e, 0, argIndex - index);</span>
<span class="nc" id="L288">        argIndex = index;</span>
<span class="nc" id="L289">        return e;</span>
    }
    protected final Statement statArgs(int index)[] {
<span class="nc" id="L292">        Statement s[] = new Statement[argIndex - index];</span>
<span class="nc" id="L293">        System.arraycopy(args, index, s, 0, argIndex - index);</span>
<span class="nc" id="L294">        argIndex = index;</span>
<span class="nc" id="L295">        return s;</span>
    }

    /**
     * Expect a token, return its value, scan the next token or
     * throw an exception.
     */
    protected void expect(int t) throws SyntaxError, IOException {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (token != t) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            switch (t) {</span>
              case IDENT:
<span class="nc" id="L306">                env.error(scanner.prevPos, &quot;identifier.expected&quot;);</span>
<span class="nc" id="L307">                break;</span>
              default:
<span class="nc" id="L309">                env.error(scanner.prevPos, &quot;token.expected&quot;, opNames[t]);</span>
                break;
            }
<span class="nc" id="L312">                throw new SyntaxError();</span>
        }
<span class="nc" id="L314">        scan();</span>
<span class="nc" id="L315">    }</span>

    /**
     * Parse a type expression. Does not parse the []'s.
     */
    protected Expression parseTypeExpression() throws SyntaxError, IOException {
<span class="nc bnc" id="L321" title="All 11 branches missed.">        switch (token) {</span>
          case VOID:
<span class="nc" id="L323">            return new TypeExpression(scan(), Type.tVoid);</span>
          case BOOLEAN:
<span class="nc" id="L325">            return new TypeExpression(scan(), Type.tBoolean);</span>
          case BYTE:
<span class="nc" id="L327">            return new TypeExpression(scan(), Type.tByte);</span>
          case CHAR:
<span class="nc" id="L329">            return new TypeExpression(scan(), Type.tChar);</span>
          case SHORT:
<span class="nc" id="L331">            return new TypeExpression(scan(), Type.tShort);</span>
          case INT:
<span class="nc" id="L333">            return new TypeExpression(scan(), Type.tInt);</span>
          case LONG:
<span class="nc" id="L335">            return new TypeExpression(scan(), Type.tLong);</span>
          case FLOAT:
<span class="nc" id="L337">            return new TypeExpression(scan(), Type.tFloat);</span>
          case DOUBLE:
<span class="nc" id="L339">            return new TypeExpression(scan(), Type.tDouble);</span>
          case IDENT:
<span class="nc" id="L341">            Expression e = new IdentifierExpression(pos, scanner.idValue);</span>
<span class="nc" id="L342">            scan();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            while (token == FIELD) {</span>
<span class="nc" id="L344">                e = new FieldExpression(scan(), e, scanner.idValue);</span>
<span class="nc" id="L345">                expect(IDENT);</span>
            }
<span class="nc" id="L347">            return e;</span>
        }

<span class="nc" id="L350">        env.error(pos, &quot;type.expected&quot;);</span>
<span class="nc" id="L351">        throw new SyntaxError();</span>
    }

    /**
     * Parse a method invocation. Should be called when the current
     * then is the '(' of the argument list.
     */
    protected Expression parseMethodExpression(Expression e, Identifier id) throws SyntaxError, IOException {
<span class="nc" id="L359">       long p = scan();</span>
<span class="nc" id="L360">       int i = argIndex;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">       if (token != RPAREN) {</span>
<span class="nc" id="L362">           addArgument(parseExpression());</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">           while (token == COMMA) {</span>
<span class="nc" id="L364">               scan();</span>
<span class="nc" id="L365">               addArgument(parseExpression());</span>
           }
       }
<span class="nc" id="L368">       expect(RPAREN);</span>
<span class="nc" id="L369">       return new MethodExpression(p, e, id, exprArgs(i));</span>
    }

    /**
     * Parse a new instance expression.  Should be called when the current
     * token is the '(' of the argument list.
     */
    protected Expression parseNewInstanceExpression(long p, Expression outerArg, Expression type) throws SyntaxError, IOException {
<span class="nc" id="L377">        int i = argIndex;</span>
<span class="nc" id="L378">        expect(LPAREN);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (token != RPAREN) {</span>
<span class="nc" id="L380">            addArgument(parseExpression());</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            while (token == COMMA) {</span>
<span class="nc" id="L382">                scan();</span>
<span class="nc" id="L383">                addArgument(parseExpression());</span>
            }
        }
<span class="nc" id="L386">        expect(RPAREN);</span>
<span class="nc" id="L387">        ClassDefinition body = null;</span>
<span class="nc bnc" id="L388" title="All 4 branches missed.">        if (token == LBRACE &amp;&amp; !(type instanceof TypeExpression)) {</span>
<span class="nc" id="L389">            long tp = pos;</span>
            // x = new Type(arg) { subclass body ... }
<span class="nc" id="L391">            Identifier superName = FieldExpression.toIdentifier(type);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (superName == null) {</span>
<span class="nc" id="L393">                env.error(type.getWhere(), &quot;type.expected&quot;);</span>
            }
<span class="nc" id="L395">            Vector ext = new Vector(1);</span>
<span class="nc" id="L396">            Vector impl = new Vector(0);</span>
<span class="nc" id="L397">            ext.addElement(new IdentifierToken(idNull));</span>
<span class="nc bnc" id="L398" title="All 4 branches missed.">            if (token == IMPLEMENTS || token == EXTENDS) {</span>
<span class="nc" id="L399">                env.error(pos, &quot;anonymous.extends&quot;);</span>
<span class="nc" id="L400">                parseInheritance(ext, impl); // error recovery</span>
            }
<span class="nc" id="L402">            body = parseClassBody(new IdentifierToken(tp, idNull),</span>
                                  M_ANONYMOUS | M_LOCAL, EXPR, null,
<span class="nc" id="L404">                                  ext, impl, type.getWhere());</span>
        }
<span class="nc bnc" id="L406" title="All 4 branches missed.">        if (outerArg == null &amp;&amp; body == null) {</span>
<span class="nc" id="L407">            return new NewInstanceExpression(p, type, exprArgs(i));</span>
        }
<span class="nc" id="L409">        return new NewInstanceExpression(p, type, exprArgs(i), outerArg, body);</span>
    }

    /**
     * Parse a primary expression.
     */
    protected Expression parseTerm() throws SyntaxError, IOException {
<span class="nc bnc" id="L416" title="All 23 branches missed.">        switch (token) {</span>
          case CHARVAL: {
<span class="nc" id="L418">            char v = scanner.charValue;</span>
<span class="nc" id="L419">            return new CharExpression(scan(), v);</span>
          }
          case INTVAL: {
<span class="nc" id="L422">            int v = scanner.intValue;</span>
<span class="nc" id="L423">            long q = scan();</span>
<span class="nc bnc" id="L424" title="All 4 branches missed.">            if (v &lt; 0 &amp;&amp; radix == 10) env.error(q, &quot;overflow.int.dec&quot;);</span>
<span class="nc" id="L425">            return new IntExpression(q, v);</span>
          }
          case LONGVAL: {
<span class="nc" id="L428">            long v = scanner.longValue;</span>
<span class="nc" id="L429">            long q = scan();</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">            if (v &lt; 0 &amp;&amp; radix == 10) env.error(q, &quot;overflow.long.dec&quot;);</span>
<span class="nc" id="L431">            return new LongExpression(q, v);</span>
          }
          case FLOATVAL: {
<span class="nc" id="L434">            float v = scanner.floatValue;</span>
<span class="nc" id="L435">            return new FloatExpression(scan(), v);</span>
          }
          case DOUBLEVAL: {
<span class="nc" id="L438">            double v = scanner.doubleValue;</span>
<span class="nc" id="L439">            return new DoubleExpression(scan(), v);</span>
          }
          case STRINGVAL: {
<span class="nc" id="L442">            String v = scanner.stringValue;</span>
<span class="nc" id="L443">            return new StringExpression(scan(), v);</span>
          }
          case IDENT: {
<span class="nc" id="L446">            Identifier v = scanner.idValue;</span>
<span class="nc" id="L447">            long p = scan();</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            return (token == LPAREN) ?</span>
<span class="nc" id="L449">                        parseMethodExpression(null, v) : new IdentifierExpression(p, v);</span>
          }

          case TRUE:
<span class="nc" id="L453">            return new BooleanExpression(scan(), true);</span>
          case FALSE:
<span class="nc" id="L455">            return new BooleanExpression(scan(), false);</span>
          case NULL:
<span class="nc" id="L457">            return new NullExpression(scan());</span>

          case THIS: {
<span class="nc" id="L460">            Expression e = new ThisExpression(scan());</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            return (token == LPAREN) ? parseMethodExpression(e, idInit) : e;</span>
          }
          case SUPER: {
<span class="nc" id="L464">            Expression e = new SuperExpression(scan());</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            return (token == LPAREN) ? parseMethodExpression(e, idInit) : e;</span>
          }

          case VOID:
          case BOOLEAN:
          case BYTE:
          case CHAR:
          case SHORT:
          case INT:
          case LONG:
          case FLOAT:
          case DOUBLE:
<span class="nc" id="L477">            return parseTypeExpression();</span>

          case ADD: {
<span class="nc" id="L480">            long p = scan();</span>
<span class="nc bnc" id="L481" title="All 5 branches missed.">            switch (token) {</span>
              case INTVAL: {
<span class="nc" id="L483">                int v = scanner.intValue;</span>
<span class="nc" id="L484">                long q = scan();</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">                if (v &lt; 0 &amp;&amp; radix == 10) env.error(q, &quot;overflow.int.dec&quot;);</span>
<span class="nc" id="L486">                return new IntExpression(q, v);</span>
              }
              case LONGVAL: {
<span class="nc" id="L489">                long v = scanner.longValue;</span>
<span class="nc" id="L490">                long q = scan();</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">                if (v &lt; 0 &amp;&amp; radix == 10) env.error(q, &quot;overflow.long.dec&quot;);</span>
<span class="nc" id="L492">                return new LongExpression(q, v);</span>
              }
              case FLOATVAL: {
<span class="nc" id="L495">                float v = scanner.floatValue;</span>
<span class="nc" id="L496">                return new FloatExpression(scan(), v);</span>
              }
              case DOUBLEVAL: {
<span class="nc" id="L499">                double v = scanner.doubleValue;</span>
<span class="nc" id="L500">                return new DoubleExpression(scan(), v);</span>
              }
            }
<span class="nc" id="L503">            return new PositiveExpression(p, parseTerm());</span>
          }
          case SUB: {
<span class="nc" id="L506">            long p = scan();</span>
<span class="nc bnc" id="L507" title="All 5 branches missed.">            switch (token) {</span>
              case INTVAL: {
<span class="nc" id="L509">                int v = -scanner.intValue;</span>
<span class="nc" id="L510">                return new IntExpression(scan(), v);</span>
              }
              case LONGVAL: {
<span class="nc" id="L513">                long v = -scanner.longValue;</span>
<span class="nc" id="L514">                return new LongExpression(scan(), v);</span>
              }
              case FLOATVAL: {
<span class="nc" id="L517">                float v = -scanner.floatValue;</span>
<span class="nc" id="L518">                return new FloatExpression(scan(), v);</span>
              }
              case DOUBLEVAL: {
<span class="nc" id="L521">                double v = -scanner.doubleValue;</span>
<span class="nc" id="L522">                return new DoubleExpression(scan(), v);</span>
              }
            }
<span class="nc" id="L525">            return new NegativeExpression(p, parseTerm());</span>
          }
          case NOT:
<span class="nc" id="L528">            return new NotExpression(scan(), parseTerm());</span>
          case BITNOT:
<span class="nc" id="L530">            return new BitNotExpression(scan(), parseTerm());</span>
          case INC:
<span class="nc" id="L532">            return new PreIncExpression(scan(), parseTerm());</span>
          case DEC:
<span class="nc" id="L534">            return new PreDecExpression(scan(), parseTerm());</span>

          case LPAREN: {
            // bracketed-expr: (expr)
<span class="nc" id="L538">            long p = scan();</span>
<span class="nc" id="L539">            Expression e = parseExpression();</span>
<span class="nc" id="L540">            expect(RPAREN);</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (e.getOp() == TYPE) {</span>
                // cast-expr: (simple-type) expr
<span class="nc" id="L544">                return new CastExpression(p, e, parseTerm());</span>
            }

<span class="nc bnc" id="L547" title="All 4 branches missed.">            switch (token) {</span>

                // We handle INC and DEC specially.
                // See the discussion in JLS section 15.14.1.
                // (Part of fix for 4044502.)

              case INC:
                  // We know this must be a postfix increment.
<span class="nc" id="L555">                  return new PostIncExpression(scan(), e);</span>

              case DEC:
                  // We know this must be a postfix decrement.
<span class="nc" id="L559">                  return new PostDecExpression(scan(), e);</span>

              case LPAREN:
              case CHARVAL:
              case INTVAL:
              case LONGVAL:
              case FLOATVAL:
              case DOUBLEVAL:
              case STRINGVAL:
              case IDENT:
              case TRUE:
              case FALSE:
              case NOT:
              case BITNOT:
              case THIS:
              case SUPER:
              case NULL:
              case NEW:
                // cast-expr: (expr) expr
<span class="nc" id="L578">                return new CastExpression(p, e, parseTerm());</span>
            }
<span class="nc" id="L580">            return new ExprExpression(p, e);</span>
          }

          case LBRACE: {
            // array initializer: {expr1, expr2, ... exprn}
<span class="nc" id="L585">            long p = scan();</span>
<span class="nc" id="L586">            int i = argIndex;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if (token != RBRACE) {</span>
<span class="nc" id="L588">                addArgument(parseExpression());</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                while (token == COMMA) {</span>
<span class="nc" id="L590">                    scan();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                    if (token == RBRACE) {</span>
<span class="nc" id="L592">                        break;</span>
                    }
<span class="nc" id="L594">                    addArgument(parseExpression());</span>
                }
            }
<span class="nc" id="L597">            expect(RBRACE);</span>
<span class="nc" id="L598">            return new ArrayExpression(p, exprArgs(i));</span>
          }

          case NEW: {
<span class="nc" id="L602">            long p = scan();</span>
<span class="nc" id="L603">            int i = argIndex;</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">            if (token == LPAREN) {</span>
<span class="nc" id="L606">                scan();</span>
<span class="nc" id="L607">                Expression e = parseExpression();</span>
<span class="nc" id="L608">                expect(RPAREN);</span>
<span class="nc" id="L609">                env.error(p, &quot;not.supported&quot;, &quot;new(...)&quot;);</span>
<span class="nc" id="L610">                return new NullExpression(p);</span>
            }

<span class="nc" id="L613">            Expression e = parseTypeExpression();</span>

<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (token == LSQBRACKET) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                while (token == LSQBRACKET) {</span>
<span class="nc" id="L617">                    scan();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    addArgument((token != RSQBRACKET) ? parseExpression() : null);</span>
<span class="nc" id="L619">                    expect(RSQBRACKET);</span>
                }
<span class="nc" id="L621">                Expression[] dims = exprArgs(i);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                if (token == LBRACE) {</span>
<span class="nc" id="L623">                    return new NewArrayExpression(p, e, dims, parseTerm());</span>
                }
<span class="nc" id="L625">                return new NewArrayExpression(p, e, dims);</span>
            } else {
<span class="nc" id="L627">                return parseNewInstanceExpression(p, null, e);</span>
            }
          }
        }

        // System.err.println(&quot;NEAR: &quot; + opNames[token]);
<span class="nc" id="L633">        env.error(scanner.prevPos, &quot;missing.term&quot;);</span>
<span class="nc" id="L634">        return new IntExpression(pos, 0);</span>
    }

    /**
     * Parse an expression.
     */
    protected Expression parseExpression() throws SyntaxError, IOException {
<span class="nc bnc" id="L641" title="All 2 branches missed.">        for (Expression e = parseTerm() ; e != null ; e = e.order()) {</span>
<span class="nc" id="L642">            Expression more = parseBinaryExpression(e);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (more == null)</span>
<span class="nc" id="L644">                return e;</span>
<span class="nc" id="L645">            e = more;</span>
        }
        // this return is bogus
<span class="nc" id="L648">        return null;</span>
    }

    /**
     * Given a left-hand term, parse an operator and right-hand term.
     */
    protected Expression parseBinaryExpression(Expression e) throws SyntaxError, IOException {
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (e != null) {</span>
<span class="nc bnc" id="L656" title="All 38 branches missed.">            switch (token) {</span>
              case LSQBRACKET: {
                // index: expr1[expr2]
<span class="nc" id="L659">                long p = scan();</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                Expression index = (token != RSQBRACKET) ? parseExpression() : null;</span>
<span class="nc" id="L661">                expect(RSQBRACKET);</span>
<span class="nc" id="L662">                e = new ArrayAccessExpression(p, e, index);</span>
<span class="nc" id="L663">                break;</span>
              }

              case INC:
<span class="nc" id="L667">                e = new PostIncExpression(scan(), e);</span>
<span class="nc" id="L668">                break;</span>
              case DEC:
<span class="nc" id="L670">                e = new PostDecExpression(scan(), e);</span>
<span class="nc" id="L671">                break;</span>
              case FIELD: {
<span class="nc" id="L673">                long p = scan();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (token == THIS) {</span>
                    // class C { class N { ... C.this ... } }
                    // class C { class N { N(C c){ ... c.this() ... } } }
<span class="nc" id="L677">                    long q = scan();</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                    if (token == LPAREN) {</span>
<span class="nc" id="L679">                        e = new ThisExpression(q, e);</span>
<span class="nc" id="L680">                        e = parseMethodExpression(e, idInit);</span>
                    } else {
<span class="nc" id="L682">                        e = new FieldExpression(p, e, idThis);</span>
                    }
<span class="nc" id="L684">                    break;</span>
                }
<span class="nc bnc" id="L686" title="All 2 branches missed.">                if (token == SUPER) {</span>
                    // class D extends C.N { D(C.N n) { n.super(); } }
                    // Also, 'C.super', as in:
                    // class C extends CS { class N { ... C.super.foo ... } }
                    // class C extends CS { class N { ... C.super.foo() ... } }
<span class="nc" id="L691">                    long q = scan();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    if (token == LPAREN) {</span>
<span class="nc" id="L693">                        e = new SuperExpression(q, e);</span>
<span class="nc" id="L694">                        e = parseMethodExpression(e, idInit);</span>
                    } else {
                        // We must check elsewhere that this expression
                        // does not stand alone, but qualifies a member name.
<span class="nc" id="L698">                        e = new FieldExpression(p, e, idSuper);</span>
                    }
<span class="nc" id="L700">                    break;</span>
                }
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (token == NEW) {</span>
                    // new C().new N()
<span class="nc" id="L704">                    scan();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    if (token != IDENT)</span>
<span class="nc" id="L706">                        expect(IDENT);</span>
<span class="nc" id="L707">                    e = parseNewInstanceExpression(p, e, parseTypeExpression());</span>
<span class="nc" id="L708">                    break;</span>
                }
<span class="nc bnc" id="L710" title="All 2 branches missed.">                if (token == CLASS) {</span>
                    // just class literals, really
                    // Class c = C.class;
<span class="nc" id="L713">                    scan();</span>
<span class="nc" id="L714">                    e = new FieldExpression(p, e, idClass);</span>
<span class="nc" id="L715">                    break;</span>
                }
<span class="nc" id="L717">                Identifier id = scanner.idValue;</span>
<span class="nc" id="L718">                expect(IDENT);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                if (token == LPAREN) {</span>
<span class="nc" id="L720">                    e = parseMethodExpression(e, id);</span>
                } else {
<span class="nc" id="L722">                    e = new FieldExpression(p, e, id);</span>
                }
<span class="nc" id="L724">                break;</span>
              }
              case INSTANCEOF:
<span class="nc" id="L727">                e = new InstanceOfExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L728">                break;</span>
              case ADD:
<span class="nc" id="L730">                e = new AddExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L731">                break;</span>
              case SUB:
<span class="nc" id="L733">                e = new SubtractExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L734">                break;</span>
              case MUL:
<span class="nc" id="L736">                e = new MultiplyExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L737">                break;</span>
              case DIV:
<span class="nc" id="L739">                e = new DivideExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L740">                break;</span>
              case REM:
<span class="nc" id="L742">                e = new RemainderExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L743">                break;</span>
              case LSHIFT:
<span class="nc" id="L745">                e = new ShiftLeftExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L746">                break;</span>
              case RSHIFT:
<span class="nc" id="L748">                e = new ShiftRightExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L749">                break;</span>
              case URSHIFT:
<span class="nc" id="L751">                e = new UnsignedShiftRightExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L752">                break;</span>
              case LT:
<span class="nc" id="L754">                e = new LessExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L755">                break;</span>
              case LE:
<span class="nc" id="L757">                e = new LessOrEqualExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L758">                break;</span>
              case GT:
<span class="nc" id="L760">                e = new GreaterExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L761">                break;</span>
              case GE:
<span class="nc" id="L763">                e = new GreaterOrEqualExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L764">                break;</span>
              case EQ:
<span class="nc" id="L766">                e = new EqualExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L767">                break;</span>
              case NE:
<span class="nc" id="L769">                e = new NotEqualExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L770">                break;</span>
              case BITAND:
<span class="nc" id="L772">                e = new BitAndExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L773">                break;</span>
              case BITXOR:
<span class="nc" id="L775">                e = new BitXorExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L776">                break;</span>
              case BITOR:
<span class="nc" id="L778">                e = new BitOrExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L779">                break;</span>
              case AND:
<span class="nc" id="L781">                e = new AndExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L782">                break;</span>
              case OR:
<span class="nc" id="L784">                e = new OrExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L785">                break;</span>
              case ASSIGN:
<span class="nc" id="L787">                e = new AssignExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L788">                break;</span>
              case ASGMUL:
<span class="nc" id="L790">                e = new AssignMultiplyExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L791">                break;</span>
              case ASGDIV:
<span class="nc" id="L793">                e = new AssignDivideExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L794">                break;</span>
              case ASGREM:
<span class="nc" id="L796">                e = new AssignRemainderExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L797">                break;</span>
              case ASGADD:
<span class="nc" id="L799">                e = new AssignAddExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L800">                break;</span>
              case ASGSUB:
<span class="nc" id="L802">                e = new AssignSubtractExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L803">                break;</span>
              case ASGLSHIFT:
<span class="nc" id="L805">                e = new AssignShiftLeftExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L806">                break;</span>
              case ASGRSHIFT:
<span class="nc" id="L808">                e = new AssignShiftRightExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L809">                break;</span>
              case ASGURSHIFT:
<span class="nc" id="L811">                e = new AssignUnsignedShiftRightExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L812">                break;</span>
              case ASGBITAND:
<span class="nc" id="L814">                e = new AssignBitAndExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L815">                break;</span>
              case ASGBITOR:
<span class="nc" id="L817">                e = new AssignBitOrExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L818">                break;</span>
              case ASGBITXOR:
<span class="nc" id="L820">                e = new AssignBitXorExpression(scan(), e, parseTerm());</span>
<span class="nc" id="L821">                break;</span>
              case QUESTIONMARK: {
<span class="nc" id="L823">                long p = scan();</span>
<span class="nc" id="L824">                Expression second = parseExpression();</span>
<span class="nc" id="L825">                expect(COLON);</span>
<span class="nc" id="L826">                Expression third = parseExpression();</span>

                // The grammar in the JLS does not allow assignment
                // expressions as the third part of a ?: expression.
                // Even though javac has no trouble parsing this,
                // check for this case and signal an error.
                // (fix for bug 4092958)
<span class="nc bnc" id="L833" title="All 4 branches missed.">                if (third instanceof AssignExpression</span>
                    || third instanceof AssignOpExpression) {
<span class="nc" id="L835">                    env.error(third.getWhere(), &quot;assign.in.conditionalexpr&quot;);</span>
                }

<span class="nc" id="L838">                e = new ConditionalExpression(p, e, second, third);</span>
<span class="nc" id="L839">                break;</span>
              }

              default:
<span class="nc" id="L843">                return null; // mark end of binary expressions</span>
            }
        }
<span class="nc" id="L846">        return e;           // return more binary expression stuff</span>
    }

    /**
     * Recover after a syntax error in a statement. This involves
     * discarding tokens until EOF or a possible continuation is
     * encountered.
     */
    protected boolean recoverStatement() throws SyntaxError, IOException {
        while (true) {
<span class="nc bnc" id="L856" title="All 5 branches missed.">            switch (token) {</span>
              case EOF:
              case RBRACE:
              case LBRACE:
              case IF:
              case FOR:
              case WHILE:
              case DO:
              case TRY:
              case CATCH:
              case FINALLY:
              case BREAK:
              case CONTINUE:
              case RETURN:
                // begin of a statement, return
<span class="nc" id="L871">                return true;</span>

              case VOID:
              case STATIC:
              case PUBLIC:
              case PRIVATE:
              case SYNCHRONIZED:
              case INTERFACE:
              case CLASS:
              case TRANSIENT:
                // begin of something outside a statement, panic some more
<span class="nc" id="L882">                expect(RBRACE);</span>
<span class="nc" id="L883">                return false;</span>

              case LPAREN:
<span class="nc" id="L886">                match(LPAREN, RPAREN);</span>
<span class="nc" id="L887">                scan();</span>
<span class="nc" id="L888">                break;</span>

              case LSQBRACKET:
<span class="nc" id="L891">                match(LSQBRACKET, RSQBRACKET);</span>
<span class="nc" id="L892">                scan();</span>
<span class="nc" id="L893">                break;</span>

              default:
                // don't know what to do, skip
<span class="nc" id="L897">                scan();</span>
<span class="nc" id="L898">                break;</span>
            }
        }
    }

    /**
     * Parse declaration, called after the type expression
     * has been parsed and the current token is IDENT.
     */
    protected Statement parseDeclaration(long p, int mod, Expression type) throws SyntaxError, IOException {
<span class="nc" id="L908">        int i = argIndex;</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">        if (token == IDENT) {</span>
<span class="nc" id="L910">            addArgument(new VarDeclarationStatement(pos, parseExpression()));</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            while (token == COMMA) {</span>
<span class="nc" id="L912">                scan();</span>
<span class="nc" id="L913">                addArgument(new VarDeclarationStatement(pos, parseExpression()));</span>
            }
        }
<span class="nc" id="L916">        return new DeclarationStatement(p, mod, type, statArgs(i));</span>
    }

    /**
     * Check if an expression is a legal toplevel expression.
     * Only method, inc, dec, and new expression are allowed.
     */
    protected void topLevelExpression(Expression e) {
<span class="nc bnc" id="L924" title="All 2 branches missed.">        switch (e.getOp()) {</span>
          case ASSIGN:
          case ASGMUL:
          case ASGDIV:
          case ASGREM:
          case ASGADD:
          case ASGSUB:
          case ASGLSHIFT:
          case ASGRSHIFT:
          case ASGURSHIFT:
          case ASGBITAND:
          case ASGBITOR:
          case ASGBITXOR:
          case PREINC:
          case PREDEC:
          case POSTINC:
          case POSTDEC:
          case METHOD:
          case NEWINSTANCE:
<span class="nc" id="L943">            return;</span>
        }
<span class="nc" id="L945">        env.error(e.getWhere(), &quot;invalid.expr&quot;);</span>
<span class="nc" id="L946">    }</span>

    /**
     * Parse a statement.
     */
    protected Statement parseStatement() throws SyntaxError, IOException {
<span class="nc bnc" id="L952" title="All 23 branches missed.">        switch (token) {</span>
          case SEMICOLON:
<span class="nc" id="L954">            return new CompoundStatement(scan(), new Statement[0]);</span>

          case LBRACE:
<span class="nc" id="L957">              return parseBlockStatement();</span>

          case IF: {
            // if-statement: if (expr) stat
            // if-statement: if (expr) stat else stat
<span class="nc" id="L962">            long p = scan();</span>

<span class="nc" id="L964">            expect(LPAREN);</span>
<span class="nc" id="L965">            Expression c = parseExpression();</span>
<span class="nc" id="L966">            expect(RPAREN);</span>
<span class="nc" id="L967">            Statement t = parseStatement();</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (token == ELSE) {</span>
<span class="nc" id="L969">                scan();</span>
<span class="nc" id="L970">                return new IfStatement(p, c, t, parseStatement());</span>
            } else {
<span class="nc" id="L972">                return new IfStatement(p, c, t, null);</span>
            }
          }

          case ELSE: {
            // else-statement: else stat
<span class="nc" id="L978">            env.error(scan(), &quot;else.without.if&quot;);</span>
<span class="nc" id="L979">            return parseStatement();</span>
          }

          case FOR: {
            // for-statement: for (decl-expr? ; expr? ; expr?) stat
<span class="nc" id="L984">            long p = scan();</span>
<span class="nc" id="L985">            Statement init = null;</span>
<span class="nc" id="L986">            Expression cond = null, inc = null;</span>

<span class="nc" id="L988">            expect(LPAREN);</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">            if (token != SEMICOLON) {</span>
<span class="nc" id="L990">                long p2 = pos;</span>
<span class="nc" id="L991">                int mod = parseModifiers(M_FINAL);</span>
<span class="nc" id="L992">                Expression e = parseExpression();</span>

<span class="nc bnc" id="L994" title="All 2 branches missed.">                if (token == IDENT) {</span>
<span class="nc" id="L995">                    init = parseDeclaration(p2, mod, e);</span>
                } else {
<span class="nc bnc" id="L997" title="All 2 branches missed.">                    if (mod != 0) {</span>
<span class="nc" id="L998">                        expect(IDENT); // should have been a declaration</span>
                    }
<span class="nc" id="L1000">                    topLevelExpression(e);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                    while (token == COMMA) {</span>
<span class="nc" id="L1002">                        long p3 = scan();</span>
<span class="nc" id="L1003">                        Expression e2 = parseExpression();</span>
<span class="nc" id="L1004">                        topLevelExpression(e2);</span>
<span class="nc" id="L1005">                        e = new CommaExpression(p3, e, e2);</span>
<span class="nc" id="L1006">                    }</span>
<span class="nc" id="L1007">                    init = new ExpressionStatement(p2, e);</span>
                }
            }
<span class="nc" id="L1010">            expect(SEMICOLON);</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            if (token != SEMICOLON) {</span>
<span class="nc" id="L1012">                cond = parseExpression();</span>
            }
<span class="nc" id="L1014">            expect(SEMICOLON);</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">            if (token != RPAREN) {</span>
<span class="nc" id="L1016">                inc = parseExpression();</span>
<span class="nc" id="L1017">                topLevelExpression(inc);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                while (token == COMMA) {</span>
<span class="nc" id="L1019">                    long p2 = scan();</span>
<span class="nc" id="L1020">                    Expression e2 = parseExpression();</span>
<span class="nc" id="L1021">                    topLevelExpression(e2);</span>
<span class="nc" id="L1022">                    inc = new CommaExpression(p2, inc, e2);</span>
<span class="nc" id="L1023">                }</span>
            }
<span class="nc" id="L1025">            expect(RPAREN);</span>
<span class="nc" id="L1026">            return new ForStatement(p, init, cond, inc, parseStatement());</span>
          }

          case WHILE: {
            // while-statement: while (expr) stat
<span class="nc" id="L1031">            long p = scan();</span>

<span class="nc" id="L1033">            expect(LPAREN);</span>
<span class="nc" id="L1034">            Expression cond = parseExpression();</span>
<span class="nc" id="L1035">            expect(RPAREN);</span>
<span class="nc" id="L1036">            return new WhileStatement(p, cond, parseStatement());</span>
          }

          case DO: {
            // do-statement: do stat while (expr)
<span class="nc" id="L1041">            long p = scan();</span>

<span class="nc" id="L1043">            Statement body = parseStatement();</span>
<span class="nc" id="L1044">            expect(WHILE);</span>
<span class="nc" id="L1045">            expect(LPAREN);</span>
<span class="nc" id="L1046">            Expression cond = parseExpression();</span>
<span class="nc" id="L1047">            expect(RPAREN);</span>
<span class="nc" id="L1048">            expect(SEMICOLON);</span>
<span class="nc" id="L1049">            return new DoStatement(p, body, cond);</span>
          }

          case BREAK: {
            // break-statement: break ;
<span class="nc" id="L1054">            long p = scan();</span>
<span class="nc" id="L1055">            Identifier label = null;</span>

<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (token == IDENT) {</span>
<span class="nc" id="L1058">                label = scanner.idValue;</span>
<span class="nc" id="L1059">                scan();</span>
            }
<span class="nc" id="L1061">            expect(SEMICOLON);</span>
<span class="nc" id="L1062">            return new BreakStatement(p, label);</span>
          }

          case CONTINUE: {
            // continue-statement: continue ;
<span class="nc" id="L1067">            long p = scan();</span>
<span class="nc" id="L1068">            Identifier label = null;</span>

<span class="nc bnc" id="L1070" title="All 2 branches missed.">            if (token == IDENT) {</span>
<span class="nc" id="L1071">                label = scanner.idValue;</span>
<span class="nc" id="L1072">                scan();</span>
            }
<span class="nc" id="L1074">            expect(SEMICOLON);</span>
<span class="nc" id="L1075">            return new ContinueStatement(p, label);</span>
          }

          case RETURN: {
            // return-statement: return ;
            // return-statement: return expr ;
<span class="nc" id="L1081">            long p = scan();</span>
<span class="nc" id="L1082">            Expression e = null;</span>

<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (token != SEMICOLON) {</span>
<span class="nc" id="L1085">                e = parseExpression();</span>
            }
<span class="nc" id="L1087">            expect(SEMICOLON);</span>
<span class="nc" id="L1088">            return new ReturnStatement(p, e);</span>
          }

          case SWITCH: {
            // switch statement: switch ( expr ) stat
<span class="nc" id="L1093">            long p = scan();</span>
<span class="nc" id="L1094">            int i = argIndex;</span>

<span class="nc" id="L1096">            expect(LPAREN);</span>
<span class="nc" id="L1097">            Expression e = parseExpression();</span>
<span class="nc" id="L1098">            expect(RPAREN);</span>
<span class="nc" id="L1099">            expect(LBRACE);</span>

<span class="nc bnc" id="L1101" title="All 4 branches missed.">            while ((token != EOF) &amp;&amp; (token != RBRACE)) {</span>
<span class="nc" id="L1102">                int j = argIndex;</span>
                try {
<span class="nc bnc" id="L1104" title="All 3 branches missed.">                    switch (token) {</span>
                      case CASE:
                        // case-statement: case expr:
<span class="nc" id="L1107">                        addArgument(new CaseStatement(scan(), parseExpression()));</span>
<span class="nc" id="L1108">                        expect(COLON);</span>
<span class="nc" id="L1109">                        break;</span>

                      case DEFAULT:
                        // default-statement: default:
<span class="nc" id="L1113">                        addArgument(new CaseStatement(scan(), null));</span>
<span class="nc" id="L1114">                        expect(COLON);</span>
<span class="nc" id="L1115">                        break;</span>

                      default:
<span class="nc" id="L1118">                        addArgument(parseStatement());</span>
                        break;
                    }
<span class="nc" id="L1121">                } catch (SyntaxError ee) {</span>
<span class="nc" id="L1122">                    argIndex = j;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                    if (!recoverStatement()) {</span>
<span class="nc" id="L1124">                        throw ee;</span>
                    }
<span class="nc" id="L1126">                }</span>
<span class="nc" id="L1127">            }</span>
<span class="nc" id="L1128">            expect(RBRACE);</span>
<span class="nc" id="L1129">            return new SwitchStatement(p, e, statArgs(i));</span>
          }

          case CASE: {
            // case-statement: case expr : stat
<span class="nc" id="L1134">            env.error(pos, &quot;case.without.switch&quot;);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            while (token == CASE) {</span>
<span class="nc" id="L1136">                scan();</span>
<span class="nc" id="L1137">                parseExpression();</span>
<span class="nc" id="L1138">                expect(COLON);</span>
            }
<span class="nc" id="L1140">            return parseStatement();</span>
          }

          case DEFAULT: {
            // default-statement: default : stat
<span class="nc" id="L1145">            env.error(pos, &quot;default.without.switch&quot;);</span>
<span class="nc" id="L1146">            scan();</span>
<span class="nc" id="L1147">            expect(COLON);</span>
<span class="nc" id="L1148">            return parseStatement();</span>
          }

          case TRY: {
            // try-statement: try stat catch (type-expr ident) stat finally stat
<span class="nc" id="L1153">            long p = scan();</span>
<span class="nc" id="L1154">            Statement init = null;              // try-object specification</span>
<span class="nc" id="L1155">            int i = argIndex;</span>
<span class="nc" id="L1156">            boolean catches = false;</span>

            if (false &amp;&amp; token == LPAREN) {
                expect(LPAREN);
                long p2 = pos;
                int mod = parseModifiers(M_FINAL);
                Expression e = parseExpression();

                if (token == IDENT) {
                    init = parseDeclaration(p2, mod, e);
                    // leave check for try (T x, y) for semantic phase
                } else {
                    if (mod != 0) {
                        expect(IDENT); // should have been a declaration
                    }
                    init = new ExpressionStatement(p2, e);
                }
                expect(RPAREN);
            }

<span class="nc" id="L1176">            Statement s = parseBlockStatement();</span>

<span class="nc bnc" id="L1178" title="All 2 branches missed.">            if (init != null) {</span>
                // s = new FinallyStatement(p, init, s, 0);
            }

<span class="nc bnc" id="L1182" title="All 2 branches missed.">            while (token == CATCH) {</span>
<span class="nc" id="L1183">                long pp = pos;</span>
<span class="nc" id="L1184">                expect(CATCH);</span>
<span class="nc" id="L1185">                expect(LPAREN);</span>
<span class="nc" id="L1186">                int mod = parseModifiers(M_FINAL);</span>
<span class="nc" id="L1187">                Expression t = parseExpression();</span>
<span class="nc" id="L1188">                IdentifierToken id = scanner.getIdToken();</span>
<span class="nc" id="L1189">                expect(IDENT);</span>
<span class="nc" id="L1190">                id.modifiers = mod;</span>
                // We only catch Throwable's, so this is no longer required
                // while (token == LSQBRACKET) {
                //    t = new ArrayAccessExpression(scan(), t, null);
                //    expect(RSQBRACKET);
                // }
<span class="nc" id="L1196">                expect(RPAREN);</span>
<span class="nc" id="L1197">                addArgument(new CatchStatement(pp, t, id, parseBlockStatement()));</span>
<span class="nc" id="L1198">                catches = true;</span>
<span class="nc" id="L1199">            }</span>

<span class="nc bnc" id="L1201" title="All 2 branches missed.">            if (catches)</span>
<span class="nc" id="L1202">                s = new TryStatement(p, s, statArgs(i));</span>

<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (token == FINALLY) {</span>
<span class="nc" id="L1205">                scan();</span>
<span class="nc" id="L1206">                return new FinallyStatement(p, s, parseBlockStatement());</span>
<span class="nc bnc" id="L1207" title="All 4 branches missed.">            } else if (catches || init != null) {</span>
<span class="nc" id="L1208">                return s;</span>
            } else {
<span class="nc" id="L1210">                env.error(pos, &quot;try.without.catch.finally&quot;);</span>
<span class="nc" id="L1211">                return new TryStatement(p, s, null);</span>
            }
          }

          case CATCH: {
            // catch-statement: catch (expr ident) stat finally stat
<span class="nc" id="L1217">            env.error(pos, &quot;catch.without.try&quot;);</span>

            Statement s;
            do {
<span class="nc" id="L1221">                scan();</span>
<span class="nc" id="L1222">                expect(LPAREN);</span>
<span class="nc" id="L1223">                parseModifiers(M_FINAL);</span>
<span class="nc" id="L1224">                parseExpression();</span>
<span class="nc" id="L1225">                expect(IDENT);</span>
<span class="nc" id="L1226">                expect(RPAREN);</span>
<span class="nc" id="L1227">                s = parseBlockStatement();</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">            } while (token == CATCH);</span>

<span class="nc bnc" id="L1230" title="All 2 branches missed.">            if (token == FINALLY) {</span>
<span class="nc" id="L1231">                scan();</span>
<span class="nc" id="L1232">                s = parseBlockStatement();</span>
            }
<span class="nc" id="L1234">            return s;</span>
          }

          case FINALLY: {
            // finally-statement: finally stat
<span class="nc" id="L1239">            env.error(pos, &quot;finally.without.try&quot;);</span>
<span class="nc" id="L1240">            scan();</span>
<span class="nc" id="L1241">            return parseBlockStatement();</span>
          }

          case THROW: {
            // throw-statement: throw expr;
<span class="nc" id="L1246">            long p = scan();</span>
<span class="nc" id="L1247">            Expression e = parseExpression();</span>
<span class="nc" id="L1248">            expect(SEMICOLON);</span>
<span class="nc" id="L1249">            return new ThrowStatement(p, e);</span>
          }

          case GOTO: {
<span class="nc" id="L1253">            long p = scan();</span>
<span class="nc" id="L1254">            expect(IDENT);</span>
<span class="nc" id="L1255">            expect(SEMICOLON);</span>
<span class="nc" id="L1256">            env.error(p, &quot;not.supported&quot;, &quot;goto&quot;);</span>
<span class="nc" id="L1257">            return new CompoundStatement(p, new Statement[0]);</span>
          }

          case SYNCHRONIZED: {
            // synchronized-statement: synchronized (expr) stat
<span class="nc" id="L1262">            long p = scan();</span>
<span class="nc" id="L1263">            expect(LPAREN);</span>
<span class="nc" id="L1264">            Expression e = parseExpression();</span>
<span class="nc" id="L1265">            expect(RPAREN);</span>
<span class="nc" id="L1266">            return new SynchronizedStatement(p, e, parseBlockStatement());</span>
          }

          case INTERFACE:
          case CLASS:
            // Inner class.
<span class="nc" id="L1272">            return parseLocalClass(0);</span>

          case CONST:
          case ABSTRACT:
          case FINAL:
          case STRICTFP: {
            // a declaration of some sort
<span class="nc" id="L1279">            long p = pos;</span>

            // A class which is local to a block is not a member, and so
            // cannot be public, private, protected, or static. It is in
            // effect private to the block, since it cannot be used outside
            // its scope.
            //
            // However, any class (if it has a name) can be declared final,
            // abstract, or strictfp.
<span class="nc" id="L1288">            int mod = parseModifiers(M_FINAL | M_ABSTRACT</span>
                                             | M_STRICTFP );

<span class="nc bnc" id="L1291" title="All 3 branches missed.">            switch (token) {</span>
              case INTERFACE:
              case CLASS:
<span class="nc" id="L1294">                return parseLocalClass(mod);</span>

              case BOOLEAN:
              case BYTE:
              case CHAR:
              case SHORT:
              case INT:
              case LONG:
              case FLOAT:
              case DOUBLE:
              case IDENT: {
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                if ((mod &amp; (M_ABSTRACT | M_STRICTFP )) != 0) {</span>
<span class="nc" id="L1306">                    mod &amp;= ~ (M_ABSTRACT | M_STRICTFP );</span>
<span class="nc" id="L1307">                    expect(CLASS);</span>
                }
<span class="nc" id="L1309">                Expression e = parseExpression();</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                if (token != IDENT) {</span>
<span class="nc" id="L1311">                    expect(IDENT);</span>
                }
                // declaration: final expr expr
<span class="nc" id="L1314">                Statement s = parseDeclaration(p, mod, e);</span>
<span class="nc" id="L1315">                expect(SEMICOLON);</span>
<span class="nc" id="L1316">                return s;</span>
              }

              default:
<span class="nc" id="L1320">                env.error(pos, &quot;type.expected&quot;);</span>
<span class="nc" id="L1321">                throw new SyntaxError();</span>
            }
          }

          case VOID:
          case STATIC:
          case PUBLIC:
          case PRIVATE:
          case TRANSIENT:
            // This is the start of something outside a statement
<span class="nc" id="L1331">            env.error(pos, &quot;statement.expected&quot;);</span>
<span class="nc" id="L1332">            throw new SyntaxError();</span>
        }

<span class="nc" id="L1335">        long p = pos;</span>
<span class="nc" id="L1336">        Expression e = parseExpression();</span>

<span class="nc bnc" id="L1338" title="All 2 branches missed.">        if (token == IDENT) {</span>
            // declaration: expr expr
<span class="nc" id="L1340">            Statement s = parseDeclaration(p, 0, e);</span>
<span class="nc" id="L1341">            expect(SEMICOLON);</span>
<span class="nc" id="L1342">            return s;</span>
        }
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (token == COLON) {</span>
            // label: id: stat
<span class="nc" id="L1346">            scan();</span>
<span class="nc" id="L1347">            Statement s = parseStatement();</span>
<span class="nc" id="L1348">            s.setLabel(env, e);</span>
<span class="nc" id="L1349">            return s;</span>
        }

        // it was just an expression...
<span class="nc" id="L1353">        topLevelExpression(e);</span>
<span class="nc" id="L1354">        expect(SEMICOLON);</span>
<span class="nc" id="L1355">        return new ExpressionStatement(p, e);</span>
    }

    protected Statement parseBlockStatement() throws SyntaxError, IOException {
        // compound statement: { stat1 stat2 ... statn }
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        if (token != LBRACE) {</span>
            // We're expecting a block statement.  But we'll probably do the
            // least damage if we try to parse a normal statement instead.
<span class="nc" id="L1363">            env.error(scanner.prevPos, &quot;token.expected&quot;, opNames[LBRACE]);</span>
<span class="nc" id="L1364">            return parseStatement();</span>
        }
<span class="nc" id="L1366">        long p = scan();</span>
<span class="nc" id="L1367">        int i = argIndex;</span>
<span class="nc bnc" id="L1368" title="All 4 branches missed.">        while ((token != EOF) &amp;&amp; (token != RBRACE)) {</span>
<span class="nc" id="L1369">            int j = argIndex;</span>
            try {
<span class="nc" id="L1371">                addArgument(parseStatement());</span>
<span class="nc" id="L1372">            } catch (SyntaxError e) {</span>
<span class="nc" id="L1373">                argIndex = j;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                if (!recoverStatement()) {</span>
<span class="nc" id="L1375">                    throw e;</span>
                }
<span class="nc" id="L1377">            }</span>
<span class="nc" id="L1378">        }</span>

<span class="nc" id="L1380">        expect(RBRACE);</span>
<span class="nc" id="L1381">        return new CompoundStatement(p, statArgs(i));</span>
    }


    /**
     * Parse an identifier. ie: a.b.c returns &quot;a.b.c&quot;
     * If star is true then &quot;a.b.*&quot; is allowed.
     * The return value encodes both the identifier and its location.
     */
    protected IdentifierToken parseName(boolean star) throws SyntaxError, IOException {
<span class="nc" id="L1391">        IdentifierToken res = scanner.getIdToken();</span>
<span class="nc" id="L1392">        expect(IDENT);</span>

<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (token != FIELD) {</span>
<span class="nc" id="L1395">            return res;</span>
        }

<span class="nc" id="L1398">        StringBuffer buf = new StringBuffer(res.id.toString());</span>

<span class="nc bnc" id="L1400" title="All 2 branches missed.">        while (token == FIELD) {</span>
<span class="nc" id="L1401">            scan();</span>
<span class="nc bnc" id="L1402" title="All 4 branches missed.">            if ((token == MUL) &amp;&amp; star) {</span>
<span class="nc" id="L1403">                scan();</span>
<span class="nc" id="L1404">                buf.append(&quot;.*&quot;);</span>
<span class="nc" id="L1405">                break;</span>
            }

<span class="nc" id="L1408">            buf.append('.');</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (token == IDENT) {</span>
<span class="nc" id="L1410">                buf.append(scanner.idValue);</span>
            }
<span class="nc" id="L1412">            expect(IDENT);</span>
        }

<span class="nc" id="L1415">        res.id = Identifier.lookup(buf.toString());</span>
<span class="nc" id="L1416">        return res;</span>
    }
    /**
     * @deprecated
     * @see #parseName
     */
    @Deprecated
    protected Identifier parseIdentifier(boolean star) throws SyntaxError, IOException {
<span class="nc" id="L1424">        return parseName(star).id;</span>
    }

    /**
     * Parse a type expression, this results in a Type.
     * The parse includes trailing array brackets.
     */
    protected Type parseType() throws SyntaxError, IOException {
        Type t;

<span class="nc bnc" id="L1434" title="All 11 branches missed.">        switch (token) {</span>
          case IDENT:
<span class="nc" id="L1436">            t = Type.tClass(parseName(false).id);</span>
<span class="nc" id="L1437">            break;</span>
          case VOID:
<span class="nc" id="L1439">            scan();</span>
<span class="nc" id="L1440">            t = Type.tVoid;</span>
<span class="nc" id="L1441">            break;</span>
          case BOOLEAN:
<span class="nc" id="L1443">            scan();</span>
<span class="nc" id="L1444">            t = Type.tBoolean;</span>
<span class="nc" id="L1445">            break;</span>
          case BYTE:
<span class="nc" id="L1447">            scan();</span>
<span class="nc" id="L1448">            t = Type.tByte;</span>
<span class="nc" id="L1449">            break;</span>
          case CHAR:
<span class="nc" id="L1451">            scan();</span>
<span class="nc" id="L1452">            t = Type.tChar;</span>
<span class="nc" id="L1453">            break;</span>
          case SHORT:
<span class="nc" id="L1455">            scan();</span>
<span class="nc" id="L1456">            t = Type.tShort;</span>
<span class="nc" id="L1457">            break;</span>
          case INT:
<span class="nc" id="L1459">            scan();</span>
<span class="nc" id="L1460">            t = Type.tInt;</span>
<span class="nc" id="L1461">            break;</span>
          case FLOAT:
<span class="nc" id="L1463">            scan();</span>
<span class="nc" id="L1464">            t = Type.tFloat;</span>
<span class="nc" id="L1465">            break;</span>
          case LONG:
<span class="nc" id="L1467">            scan();</span>
<span class="nc" id="L1468">            t = Type.tLong;</span>
<span class="nc" id="L1469">            break;</span>
          case DOUBLE:
<span class="nc" id="L1471">            scan();</span>
<span class="nc" id="L1472">            t = Type.tDouble;</span>
<span class="nc" id="L1473">            break;</span>
          default:
<span class="nc" id="L1475">            env.error(pos, &quot;type.expected&quot;);</span>
<span class="nc" id="L1476">            throw new SyntaxError();</span>
        }
<span class="nc" id="L1478">        return parseArrayBrackets(t);</span>
    }

    /**
     * Parse the tail of a type expression, which might be array brackets.
     * Return the given type, as possibly modified by the suffix.
     */
    protected Type parseArrayBrackets(Type t) throws SyntaxError, IOException {

        // Parse []'s
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        while (token == LSQBRACKET) {</span>
<span class="nc" id="L1489">            scan();</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">            if (token != RSQBRACKET) {</span>
<span class="nc" id="L1491">                env.error(pos, &quot;array.dim.in.decl&quot;);</span>
<span class="nc" id="L1492">                parseExpression();</span>
            }
<span class="nc" id="L1494">            expect(RSQBRACKET);</span>
<span class="nc" id="L1495">            t = Type.tArray(t);</span>
        }
<span class="nc" id="L1497">        return t;</span>
    }

    /*
     * Dealing with argument lists, I'm not using
     * Vector for efficiency.
     */

<span class="nc" id="L1505">    private int aCount = 0;</span>
<span class="nc" id="L1506">    private Type aTypes[] = new Type[8];</span>
<span class="nc" id="L1507">    private IdentifierToken aNames[] = new IdentifierToken[aTypes.length];</span>

    private void addArgument(int mod, Type t, IdentifierToken nm) {
<span class="nc" id="L1510">        nm.modifiers = mod;</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">        if (aCount &gt;= aTypes.length) {</span>
<span class="nc" id="L1512">            Type newATypes[] = new Type[aCount * 2];</span>
<span class="nc" id="L1513">            System.arraycopy(aTypes, 0, newATypes, 0, aCount);</span>
<span class="nc" id="L1514">            aTypes = newATypes;</span>
<span class="nc" id="L1515">            IdentifierToken newANames[] = new IdentifierToken[aCount * 2];</span>
<span class="nc" id="L1516">            System.arraycopy(aNames, 0, newANames, 0, aCount);</span>
<span class="nc" id="L1517">            aNames = newANames;</span>
        }
<span class="nc" id="L1519">        aTypes[aCount] = t;</span>
<span class="nc" id="L1520">        aNames[aCount++] = nm;</span>
<span class="nc" id="L1521">    }</span>

    /**
     * Parse a possibly-empty sequence of modifier keywords.
     * Return the resulting bitmask.
     * Diagnose repeated modifiers, but make no other checks.
     * Only modifiers mentioned in the given bitmask are scanned;
     * an unmatched modifier must be handled by the caller.
     */
    protected int parseModifiers(int mask) throws IOException {
<span class="nc" id="L1531">        int mod = 0;</span>
        while (true) {
<span class="nc bnc" id="L1533" title="All 2 branches missed.">            if (token==CONST) {</span>
                // const isn't in java, but handle a common C++ usage gently
<span class="nc" id="L1535">                env.error(pos, &quot;not.supported&quot;, &quot;const&quot;);</span>
<span class="nc" id="L1536">                scan();</span>
            }
<span class="nc" id="L1538">            int nextmod = 0;</span>
<span class="nc bnc" id="L1539" title="All 12 branches missed.">            switch (token) {</span>
<span class="nc" id="L1540">               case PRIVATE:            nextmod = M_PRIVATE;      break;</span>
<span class="nc" id="L1541">               case PUBLIC:             nextmod = M_PUBLIC;       break;</span>
<span class="nc" id="L1542">               case PROTECTED:          nextmod = M_PROTECTED;    break;</span>
<span class="nc" id="L1543">               case STATIC:             nextmod = M_STATIC;       break;</span>
<span class="nc" id="L1544">               case TRANSIENT:          nextmod = M_TRANSIENT;    break;</span>
<span class="nc" id="L1545">               case FINAL:              nextmod = M_FINAL;        break;</span>
<span class="nc" id="L1546">               case ABSTRACT:           nextmod = M_ABSTRACT;     break;</span>
<span class="nc" id="L1547">               case NATIVE:             nextmod = M_NATIVE;       break;</span>
<span class="nc" id="L1548">               case VOLATILE:           nextmod = M_VOLATILE;     break;</span>
<span class="nc" id="L1549">               case SYNCHRONIZED:       nextmod = M_SYNCHRONIZED; break;</span>
<span class="nc" id="L1550">               case STRICTFP:           nextmod = M_STRICTFP;     break;</span>
            }
<span class="nc bnc" id="L1552" title="All 2 branches missed.">            if ((nextmod &amp; mask) == 0) {</span>
<span class="nc" id="L1553">                break;</span>
            }
<span class="nc bnc" id="L1555" title="All 2 branches missed.">            if ((nextmod &amp; mod) != 0) {</span>
<span class="nc" id="L1556">                env.error(pos, &quot;repeated.modifier&quot;);</span>
            }
<span class="nc" id="L1558">            mod |= nextmod;</span>
<span class="nc" id="L1559">            scan();</span>
<span class="nc" id="L1560">        }</span>
<span class="nc" id="L1561">        return mod;</span>
    }

    private ClassDefinition curClass;

    /**
     * Parse a field.
     */
    protected void parseField() throws SyntaxError, IOException {

        // Empty fields are not allowed by the JLS but are accepted by
        // the compiler, and much code has come to rely on this.  It has
        // been decided that the language will be extended to legitimize them.
<span class="nc bnc" id="L1574" title="All 2 branches missed.">        if (token == SEMICOLON) {</span>
            // empty field
<span class="nc" id="L1576">            scan();</span>
<span class="nc" id="L1577">            return;</span>
        }

        // Optional doc comment
<span class="nc" id="L1581">        String doc = scanner.docComment;</span>

        // The start of the field
<span class="nc" id="L1584">        long p = pos;</span>

        // Parse the modifiers
<span class="nc" id="L1587">        int mod = parseModifiers(MM_FIELD | MM_METHOD);</span>

        // Check for static initializer
        // ie: static { ... }
        // or an instance initializer (w/o the static).
<span class="nc bnc" id="L1592" title="All 4 branches missed.">        if ((mod == (mod &amp; M_STATIC)) &amp;&amp; (token == LBRACE)) {</span>
            // static initializer
<span class="nc" id="L1594">            actions.defineField(p, curClass, doc, mod,</span>
<span class="nc" id="L1595">                                Type.tMethod(Type.tVoid),</span>
                                new IdentifierToken(idClassInit), null, null,
<span class="nc" id="L1597">                                parseStatement());</span>
<span class="nc" id="L1598">            return;</span>
        }

        // Check for inner class
<span class="nc bnc" id="L1602" title="All 4 branches missed.">        if (token == CLASS || token == INTERFACE) {</span>
<span class="nc" id="L1603">            parseNamedClass(mod, CLASS, doc);</span>
<span class="nc" id="L1604">            return;</span>
        }

        // Parse the type
<span class="nc" id="L1608">        p = pos;</span>
<span class="nc" id="L1609">        Type t = parseType();</span>
<span class="nc" id="L1610">        IdentifierToken id = null;</span>

        // Check that the type is followed by an Identifier
        // (the name of the method or the first variable),
        // otherwise it is a constructor.
<span class="nc bnc" id="L1615" title="All 3 branches missed.">        switch (token) {</span>
          case IDENT:
<span class="nc" id="L1617">            id = scanner.getIdToken();</span>
<span class="nc" id="L1618">            p = scan();</span>
<span class="nc" id="L1619">            break;</span>

          case LPAREN:
            // It is a constructor
<span class="nc" id="L1623">            id = new IdentifierToken(idInit);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">            if ((mod &amp; M_STRICTFP) != 0)</span>
<span class="nc" id="L1625">                env.error(pos, &quot;bad.constructor.modifier&quot;);</span>
            break;

          default:
<span class="nc" id="L1629">            expect(IDENT);</span>
        }

        // If the next token is a left-bracket then we
        // are dealing with a method or constructor, otherwise it is
        // a list of variables
<span class="nc bnc" id="L1635" title="All 2 branches missed.">        if (token == LPAREN) {</span>
            // It is a method or constructor declaration
<span class="nc" id="L1637">            scan();</span>
<span class="nc" id="L1638">            aCount = 0;</span>

<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (token != RPAREN) {</span>
                // Parse argument type and identifier
                // (arguments (like locals) are allowed to be final)
<span class="nc" id="L1643">                int am = parseModifiers(M_FINAL);</span>
<span class="nc" id="L1644">                Type at = parseType();</span>
<span class="nc" id="L1645">                IdentifierToken an = scanner.getIdToken();</span>
<span class="nc" id="L1646">                expect(IDENT);</span>

                // Parse optional array specifier, ie: a[][]
<span class="nc" id="L1649">                at = parseArrayBrackets(at);</span>
<span class="nc" id="L1650">                addArgument(am, at, an);</span>

                // If the next token is a comma then there are
                // more arguments
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                while (token == COMMA) {</span>
                    // Parse argument type and identifier
<span class="nc" id="L1656">                    scan();</span>
<span class="nc" id="L1657">                    am = parseModifiers(M_FINAL);</span>
<span class="nc" id="L1658">                    at = parseType();</span>
<span class="nc" id="L1659">                    an = scanner.getIdToken();</span>
<span class="nc" id="L1660">                    expect(IDENT);</span>

                    // Parse optional array specifier, ie: a[][]
<span class="nc" id="L1663">                    at = parseArrayBrackets(at);</span>
<span class="nc" id="L1664">                    addArgument(am, at, an);</span>
                }
            }
<span class="nc" id="L1667">            expect(RPAREN);</span>

            // Parse optional array sepecifier, ie: foo()[][]
<span class="nc" id="L1670">            t = parseArrayBrackets(t);</span>

            // copy arguments
<span class="nc" id="L1673">            Type atypes[] = new Type[aCount];</span>
<span class="nc" id="L1674">            System.arraycopy(aTypes, 0, atypes, 0, aCount);</span>

<span class="nc" id="L1676">            IdentifierToken anames[] = new IdentifierToken[aCount];</span>
<span class="nc" id="L1677">            System.arraycopy(aNames, 0, anames, 0, aCount);</span>

            // Construct the type signature
<span class="nc" id="L1680">            t = Type.tMethod(t, atypes);</span>

            // Parse and ignore throws clause
<span class="nc" id="L1683">            IdentifierToken exp[] = null;</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            if (token == THROWS) {</span>
<span class="nc" id="L1685">                Vector v = new Vector();</span>
<span class="nc" id="L1686">                scan();</span>
<span class="nc" id="L1687">                v.addElement(parseName(false));</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                while (token == COMMA) {</span>
<span class="nc" id="L1689">                    scan();</span>
<span class="nc" id="L1690">                    v.addElement(parseName(false));</span>
                }

<span class="nc" id="L1693">                exp = new IdentifierToken[v.size()];</span>
<span class="nc" id="L1694">                v.copyInto(exp);</span>
            }

            // Check if it is a method definition or a method declaration
            // ie: foo() {...} or foo();
<span class="nc bnc" id="L1699" title="All 3 branches missed.">            switch (token) {</span>
              case LBRACE:      // It's a method definition

                // Set the state of FP strictness for the body of the method
<span class="nc" id="L1703">                int oldFPstate = FPstate;</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">                if ((mod &amp; M_STRICTFP)!=0) {</span>
<span class="nc" id="L1705">                    FPstate = M_STRICTFP;</span>
                } else {
<span class="nc" id="L1707">                    mod |= FPstate &amp; M_STRICTFP;</span>
                }

<span class="nc" id="L1710">                actions.defineField(p, curClass, doc, mod, t, id,</span>
<span class="nc" id="L1711">                                    anames, exp, parseStatement());</span>

<span class="nc" id="L1713">                FPstate = oldFPstate;</span>

<span class="nc" id="L1715">                break;</span>

              case SEMICOLON:
<span class="nc" id="L1718">                scan();</span>
<span class="nc" id="L1719">                actions.defineField(p, curClass, doc, mod, t, id,</span>
                                    anames, exp, null);
<span class="nc" id="L1721">                break;</span>

              default:
                // really expected a statement body here
<span class="nc bnc" id="L1725" title="All 2 branches missed.">                if ((mod &amp; (M_NATIVE | M_ABSTRACT)) == 0) {</span>
<span class="nc" id="L1726">                    expect(LBRACE);</span>
                } else {
<span class="nc" id="L1728">                    expect(SEMICOLON);</span>
                }
            }
<span class="nc" id="L1731">            return;</span>
        }

        // It is a list of instance variables
        while (true) {
<span class="nc" id="L1736">            p = pos;            // get the current position</span>
            // parse the array brackets (if any)
            // ie: var[][][]
<span class="nc" id="L1739">            Type vt = parseArrayBrackets(t);</span>

            // Parse the optional initializer
<span class="nc" id="L1742">            Node init = null;</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">            if (token == ASSIGN) {</span>
<span class="nc" id="L1744">                scan();</span>
<span class="nc" id="L1745">                init = parseExpression();</span>
            }

            // Define the variable
<span class="nc" id="L1749">            actions.defineField(p, curClass, doc, mod, vt, id,</span>
                                null, null, init);

            // If the next token is a comma, then there is more
<span class="nc bnc" id="L1753" title="All 2 branches missed.">            if (token != COMMA) {</span>
<span class="nc" id="L1754">                expect(SEMICOLON);</span>
<span class="nc" id="L1755">                return;</span>
            }
<span class="nc" id="L1757">            scan();</span>

            // The next token must be an identifier
<span class="nc" id="L1760">            id = scanner.getIdToken();</span>
<span class="nc" id="L1761">            expect(IDENT);</span>
<span class="nc" id="L1762">        }</span>
    }

    /**
     * Recover after a syntax error in a field. This involves
     * discarding tokens until an EOF or a possible legal
     * continuation is encountered.
     */
    protected void recoverField(ClassDefinition newClass) throws SyntaxError, IOException {
        while (true) {
<span class="nc bnc" id="L1772" title="All 6 branches missed.">            switch (token) {</span>
              case EOF:
              case STATIC:
              case FINAL:
              case PUBLIC:
              case PRIVATE:
              case SYNCHRONIZED:
              case TRANSIENT:

              case VOID:
              case BOOLEAN:
              case BYTE:
              case CHAR:
              case SHORT:
              case INT:
              case FLOAT:
              case LONG:
              case DOUBLE:
                // possible begin of a field, continue
<span class="nc" id="L1791">                return;</span>

              case LBRACE:
<span class="nc" id="L1794">                match(LBRACE, RBRACE);</span>
<span class="nc" id="L1795">                scan();</span>
<span class="nc" id="L1796">                break;</span>

              case LPAREN:
<span class="nc" id="L1799">                match(LPAREN, RPAREN);</span>
<span class="nc" id="L1800">                scan();</span>
<span class="nc" id="L1801">                break;</span>

              case LSQBRACKET:
<span class="nc" id="L1804">                match(LSQBRACKET, RSQBRACKET);</span>
<span class="nc" id="L1805">                scan();</span>
<span class="nc" id="L1806">                break;</span>

              case RBRACE:
              case INTERFACE:
              case CLASS:
              case IMPORT:
              case PACKAGE:
                // begin of something outside a class, panic more
<span class="nc" id="L1814">                actions.endClass(pos, newClass);</span>
<span class="nc" id="L1815">                throw new SyntaxError();</span>

              default:
                // don't know what to do, skip
<span class="nc" id="L1819">                scan();</span>
<span class="nc" id="L1820">                break;</span>
            }
        }
    }

    /**
     * Parse a top-level class or interface declaration.
     */
    protected void parseClass() throws SyntaxError, IOException {
<span class="nc" id="L1829">        String doc = scanner.docComment;</span>

        // Parse the modifiers.
<span class="nc" id="L1832">        int mod = parseModifiers(MM_CLASS | MM_MEMBER);</span>

<span class="nc" id="L1834">        parseNamedClass(mod, PACKAGE, doc);</span>
<span class="nc" id="L1835">    }</span>

    // Current strict/default state of floating point.  This is
    // set and reset with a stack discipline around methods and named
    // classes.  Only M_STRICTFP may be set in this word.  try...
    // finally is not needed to protect setting and resetting because
    // there are no error messages based on FPstate.
<span class="nc" id="L1842">    private int FPstate = 0;</span>

    /**
     * Parse a block-local class or interface declaration.
     */
    protected Statement parseLocalClass(int mod) throws SyntaxError, IOException {
<span class="nc" id="L1848">        long p = pos;</span>
<span class="nc" id="L1849">        ClassDefinition body = parseNamedClass(M_LOCAL | mod, STAT, null);</span>
<span class="nc" id="L1850">        Statement ds[] = {</span>
            new VarDeclarationStatement(p, new LocalMember(body), null)
        };
<span class="nc" id="L1853">        Expression type = new TypeExpression(p, body.getType());</span>
<span class="nc" id="L1854">        return new DeclarationStatement(p, 0, type, ds);</span>
    }

    /**
     * Parse a named class or interface declaration,
     * starting at &quot;class&quot; or &quot;interface&quot;.
     * @arg ctx Syntactic context of the class, one of {PACKAGE CLASS STAT EXPR}.
     */
    protected ClassDefinition parseNamedClass(int mod, int ctx, String doc) throws SyntaxError, IOException {
        // Parse class/interface
<span class="nc bnc" id="L1864" title="All 3 branches missed.">        switch (token) {</span>
          case INTERFACE:
<span class="nc" id="L1866">            scan();</span>
<span class="nc" id="L1867">            mod |= M_INTERFACE;</span>
<span class="nc" id="L1868">            break;</span>

          case CLASS:
<span class="nc" id="L1871">            scan();</span>
<span class="nc" id="L1872">            break;</span>

          default:
<span class="nc" id="L1875">            env.error(pos, &quot;class.expected&quot;);</span>
            break;
        }

<span class="nc" id="L1879">        int oldFPstate = FPstate;</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">        if ((mod &amp; M_STRICTFP)!=0) {</span>
<span class="nc" id="L1881">            FPstate = M_STRICTFP;</span>
        } else {
            // The &amp; (...) isn't really necessary here because we do maintain
            // the invariant that FPstate has no extra bits set.
<span class="nc" id="L1885">            mod |= FPstate &amp; M_STRICTFP;</span>
        }

        // Parse the class name
<span class="nc" id="L1889">        IdentifierToken nm = scanner.getIdToken();</span>
<span class="nc" id="L1890">        long p = pos;</span>
<span class="nc" id="L1891">        expect(IDENT);</span>

<span class="nc" id="L1893">        Vector ext = new Vector();</span>
<span class="nc" id="L1894">        Vector impl = new Vector();</span>
<span class="nc" id="L1895">        parseInheritance(ext, impl);</span>

<span class="nc" id="L1897">        ClassDefinition tmp = parseClassBody(nm, mod, ctx, doc, ext, impl, p);</span>

<span class="nc" id="L1899">        FPstate = oldFPstate;</span>

<span class="nc" id="L1901">        return tmp;</span>
    }

    protected void parseInheritance(Vector ext, Vector impl) throws SyntaxError, IOException {
        // Parse extends clause
<span class="nc bnc" id="L1906" title="All 2 branches missed.">        if (token == EXTENDS) {</span>
<span class="nc" id="L1907">            scan();</span>
<span class="nc" id="L1908">            ext.addElement(parseName(false));</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            while (token == COMMA) {</span>
<span class="nc" id="L1910">                scan();</span>
<span class="nc" id="L1911">                ext.addElement(parseName(false));</span>
            }
        }

        // Parse implements clause
<span class="nc bnc" id="L1916" title="All 2 branches missed.">        if (token == IMPLEMENTS) {</span>
<span class="nc" id="L1917">            scan();</span>
<span class="nc" id="L1918">            impl.addElement(parseName(false));</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">            while (token == COMMA) {</span>
<span class="nc" id="L1920">                scan();</span>
<span class="nc" id="L1921">                impl.addElement(parseName(false));</span>
            }
        }
<span class="nc" id="L1924">    }</span>

    /**
     * Parse the body of a class or interface declaration,
     * starting at the left brace.
     */
    protected ClassDefinition parseClassBody(IdentifierToken nm, int mod,
                                             int ctx, String doc,
                                             Vector ext, Vector impl, long p
                                             ) throws SyntaxError, IOException {
        // Decide which is the super class
<span class="nc" id="L1935">        IdentifierToken sup = null;</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">        if ((mod &amp; M_INTERFACE) != 0) {</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">            if (impl.size() &gt; 0) {</span>
<span class="nc" id="L1938">                env.error(((IdentifierToken)impl.elementAt(0)).getWhere(),</span>
                          &quot;intf.impl.intf&quot;);
            }
<span class="nc" id="L1941">            impl = ext;</span>
        } else {
<span class="nc bnc" id="L1943" title="All 2 branches missed.">            if (ext.size() &gt; 0) {</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">                if (ext.size() &gt; 1) {</span>
<span class="nc" id="L1945">                    env.error(((IdentifierToken)ext.elementAt(1)).getWhere(),</span>
                              &quot;multiple.inherit&quot;);
                }
<span class="nc" id="L1948">                sup = (IdentifierToken)ext.elementAt(0);</span>
            }
        }

<span class="nc" id="L1952">        ClassDefinition oldClass = curClass;</span>

        // Begin a new class
<span class="nc" id="L1955">        IdentifierToken implids[] = new IdentifierToken[impl.size()];</span>
<span class="nc" id="L1956">        impl.copyInto(implids);</span>
<span class="nc" id="L1957">        ClassDefinition newClass =</span>
<span class="nc" id="L1958">            actions.beginClass(p, doc, mod, nm, sup, implids);</span>

        // Parse fields
<span class="nc" id="L1961">        expect(LBRACE);</span>
<span class="nc bnc" id="L1962" title="All 4 branches missed.">        while ((token != EOF) &amp;&amp; (token != RBRACE)) {</span>
            try {
<span class="nc" id="L1964">                curClass = newClass;</span>
<span class="nc" id="L1965">                parseField();</span>
<span class="nc" id="L1966">            } catch (SyntaxError e) {</span>
<span class="nc" id="L1967">                recoverField(newClass);</span>
            } finally {
<span class="nc" id="L1969">                curClass = oldClass;</span>
<span class="nc" id="L1970">            }</span>
        }
<span class="nc" id="L1972">        expect(RBRACE);</span>

        // End the class
<span class="nc" id="L1975">        actions.endClass(scanner.prevPos, newClass);</span>
<span class="nc" id="L1976">        return newClass;</span>
    }

    /**
     * Recover after a syntax error in the file.
     * This involves discarding tokens until an EOF
     * or a possible legal continuation is encountered.
     */
    protected void recoverFile() throws IOException {
        while (true) {
<span class="nc bnc" id="L1986" title="All 6 branches missed.">            switch (token) {</span>
              case CLASS:
              case INTERFACE:
                // Start of a new source file statement, continue
<span class="nc" id="L1990">                return;</span>

              case LBRACE:
<span class="nc" id="L1993">                match(LBRACE, RBRACE);</span>
<span class="nc" id="L1994">                scan();</span>
<span class="nc" id="L1995">                break;</span>

              case LPAREN:
<span class="nc" id="L1998">                match(LPAREN, RPAREN);</span>
<span class="nc" id="L1999">                scan();</span>
<span class="nc" id="L2000">                break;</span>

              case LSQBRACKET:
<span class="nc" id="L2003">                match(LSQBRACKET, RSQBRACKET);</span>
<span class="nc" id="L2004">                scan();</span>
<span class="nc" id="L2005">                break;</span>

              case EOF:
<span class="nc" id="L2008">                return;</span>

              default:
                // Don't know what to do, skip
<span class="nc" id="L2012">                scan();</span>
<span class="nc" id="L2013">                break;</span>
            }
        }
    }

    /**
     * Parse an Java file.
     */
    public void parseFile() {
        try {
            try {
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                if (token == PACKAGE) {</span>
                    // Package statement
<span class="nc" id="L2026">                    long p = scan();</span>
<span class="nc" id="L2027">                    IdentifierToken id = parseName(false);</span>
<span class="nc" id="L2028">                    expect(SEMICOLON);</span>
<span class="nc" id="L2029">                    actions.packageDeclaration(p, id);</span>
                }
<span class="nc" id="L2031">            } catch (SyntaxError e) {</span>
<span class="nc" id="L2032">                recoverFile();</span>
<span class="nc" id="L2033">            }</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">            while (token == IMPORT) {</span>
                try{
                    // Import statement
<span class="nc" id="L2037">                    long p = scan();</span>
<span class="nc" id="L2038">                    IdentifierToken id = parseName(true);</span>
<span class="nc" id="L2039">                    expect(SEMICOLON);</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">                    if (id.id.getName().equals(idStar)) {</span>
<span class="nc" id="L2041">                        id.id = id.id.getQualifier();</span>
<span class="nc" id="L2042">                        actions.importPackage(p, id);</span>
                    } else {
<span class="nc" id="L2044">                        actions.importClass(p, id);</span>
                    }
<span class="nc" id="L2046">                } catch (SyntaxError e) {</span>
<span class="nc" id="L2047">                    recoverFile();</span>
<span class="nc" id="L2048">                }</span>
            }

<span class="nc bnc" id="L2051" title="All 2 branches missed.">            while (token != EOF) {</span>
                try {
<span class="nc bnc" id="L2053" title="All 4 branches missed.">                    switch (token) {</span>
                      case FINAL:
                      case PUBLIC:
                      case PRIVATE:
                      case ABSTRACT:
                      case CLASS:
                      case INTERFACE:
                      case STRICTFP:
                        // Start of a class
<span class="nc" id="L2062">                        parseClass();</span>
<span class="nc" id="L2063">                        break;</span>

                      case SEMICOLON:
                        // Bogus semicolon.
                        // According to the JLS (7.6,19.6), a TypeDeclaration
                        // may consist of a single semicolon, however, this
                        // usage is discouraged (JLS 7.6).  In contrast,
                        // a FieldDeclaration may not be empty, and is flagged
                        // as an error.  See parseField above.
<span class="nc" id="L2072">                        scan();</span>
<span class="nc" id="L2073">                        break;</span>

                      case EOF:
                        // The end
<span class="nc" id="L2077">                        return;</span>

                      default:
                        // Oops
<span class="nc" id="L2081">                        env.error(pos, &quot;toplevel.expected&quot;);</span>
<span class="nc" id="L2082">                        throw new SyntaxError();</span>
                    }
<span class="nc" id="L2084">                } catch (SyntaxError e) {</span>
<span class="nc" id="L2085">                    recoverFile();</span>
<span class="nc" id="L2086">                }</span>
            }
<span class="nc" id="L2088">        } catch (IOException e) {</span>
<span class="nc" id="L2089">            env.error(pos, &quot;io.exception&quot;, env.getSource());</span>
<span class="nc" id="L2090">            return;</span>
<span class="nc" id="L2091">        }</span>
<span class="nc" id="L2092">    }</span>

    /**
     * Usually &lt;code&gt;this.scanner == (Scanner)this&lt;/code&gt;.
     * However, a delegate scanner can produce tokens for this parser,
     * in which case &lt;code&gt;(Scanner)this&lt;/code&gt; is unused,
     * except for &lt;code&gt;this.token&lt;/code&gt; and &lt;code&gt;this.pos&lt;/code&gt;
     * instance variables which are filled from the real scanner
     * by &lt;code&gt;this.scan()&lt;/code&gt; and the constructor.
     */
    protected Scanner scanner;

    // Design Note: We ought to disinherit Parser from Scanner.
    // We also should split out the interface ParserActions from
    // Parser, and make BatchParser implement ParserActions,
    // not extend Parser.  This would split scanning, parsing,
    // and class building into distinct responsibility areas.
    // (Perhaps tree building could be virtualized too.)

    public long scan() throws IOException {
<span class="nc bnc" id="L2112" title="All 4 branches missed.">        if (scanner != this &amp;&amp; scanner != null) {</span>
<span class="nc" id="L2113">            long result = scanner.scan();</span>
<span class="nc" id="L2114">            ((Scanner)this).token = scanner.token;</span>
<span class="nc" id="L2115">            ((Scanner)this).pos = scanner.pos;</span>
<span class="nc" id="L2116">            return result;</span>
        }
<span class="nc" id="L2118">        return super.scan();</span>
    }

    public void match(int open, int close) throws IOException {
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        if (scanner != this) {</span>
<span class="nc" id="L2123">            scanner.match(open, close);</span>
<span class="nc" id="L2124">            ((Scanner)this).token = scanner.token;</span>
<span class="nc" id="L2125">            ((Scanner)this).pos = scanner.pos;</span>
<span class="nc" id="L2126">            return;</span>
        }
<span class="nc" id="L2128">        super.match(open, close);</span>
<span class="nc" id="L2129">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>