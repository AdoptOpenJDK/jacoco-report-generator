<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BinaryConstantPool.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">BinaryConstantPool.java</span></div><h1>BinaryConstantPool.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.io.IOException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.util.Vector;
import java.util.Hashtable;

/**
 * This class is used to represent a constant table once
 * it is read from a class file.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public final
class BinaryConstantPool implements Constants {
    private byte types[];
    private Object cpool[];

    /**
     * Constructor
     */
<span class="nc" id="L50">    BinaryConstantPool(DataInputStream in) throws IOException {</span>
        // JVM 4.1 ClassFile.constant_pool_count
<span class="nc" id="L52">        types = new byte[in.readUnsignedShort()];</span>
<span class="nc" id="L53">        cpool = new Object[types.length];</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        for (int i = 1 ; i &lt; cpool.length ; i++) {</span>
<span class="nc" id="L55">            int j = i;</span>
            // JVM 4.4 cp_info.tag
<span class="nc bnc" id="L57" title="All 11 branches missed.">            switch(types[i] = in.readByte()) {</span>
              case CONSTANT_UTF8:
<span class="nc" id="L59">                cpool[i] = in.readUTF();</span>
<span class="nc" id="L60">                break;</span>

              case CONSTANT_INTEGER:
<span class="nc" id="L63">                cpool[i] = new Integer(in.readInt());</span>
<span class="nc" id="L64">                break;</span>
              case CONSTANT_FLOAT:
<span class="nc" id="L66">                cpool[i] = new Float(in.readFloat());</span>
<span class="nc" id="L67">                break;</span>
              case CONSTANT_LONG:
<span class="nc" id="L69">                cpool[i++] = new Long(in.readLong());</span>
<span class="nc" id="L70">                break;</span>
              case CONSTANT_DOUBLE:
<span class="nc" id="L72">                cpool[i++] = new Double(in.readDouble());</span>
<span class="nc" id="L73">                break;</span>

              case CONSTANT_CLASS:
              case CONSTANT_STRING:
                // JVM 4.4.3 CONSTANT_String_info.string_index
                // or JVM 4.4.1 CONSTANT_Class_info.name_index
<span class="nc" id="L79">                cpool[i] = new Integer(in.readUnsignedShort());</span>
<span class="nc" id="L80">                break;</span>

              case CONSTANT_FIELD:
              case CONSTANT_METHOD:
              case CONSTANT_INTERFACEMETHOD:
              case CONSTANT_NAMEANDTYPE:
                // JVM 4.4.2 CONSTANT_*ref_info.class_index &amp; name_and_type_index
<span class="nc" id="L87">                cpool[i] = new Integer((in.readUnsignedShort() &lt;&lt; 16) | in.readUnsignedShort());</span>
<span class="nc" id="L88">                break;</span>

              case CONSTANT_METHODHANDLE:
<span class="nc" id="L91">                cpool[i] = readBytes(in, 3);</span>
<span class="nc" id="L92">                break;</span>
              case CONSTANT_METHODTYPE:
<span class="nc" id="L94">                cpool[i] = readBytes(in, 2);</span>
<span class="nc" id="L95">                break;</span>
              case CONSTANT_INVOKEDYNAMIC:
<span class="nc" id="L97">                cpool[i] = readBytes(in, 4);</span>
<span class="nc" id="L98">                break;</span>

              case 0:
              default:
<span class="nc" id="L102">                throw new ClassFormatError(&quot;invalid constant type: &quot; + (int)types[i]);</span>
            }
        }
<span class="nc" id="L105">    }</span>

    private byte[] readBytes(DataInputStream in, int cnt) throws IOException {
<span class="nc" id="L108">        byte[] b = new byte[cnt];</span>
<span class="nc" id="L109">        in.readFully(b);</span>
<span class="nc" id="L110">        return b;</span>
    }

    /**
     * get a integer
     */
    public int getInteger(int n) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        return (n == 0) ? 0 : ((Number)cpool[n]).intValue();</span>
    }

    /**
     * get a value
     */
    public Object getValue(int n) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        return (n == 0) ? null : cpool[n];</span>
    }

    /**
     * get a string
     */
    public String getString(int n) {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        return (n == 0) ? null : (String)cpool[n];</span>
    }

    /**
     * get an identifier
     */
    public Identifier getIdentifier(int n) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        return (n == 0) ? null : Identifier.lookup(getString(n));</span>
    }

    /**
     * get class declaration
     */
    public ClassDeclaration getDeclarationFromName(Environment env, int n) {
<span class="nc bnc" id="L145" title="All 2 branches missed.">        return (n == 0) ? null : env.getClassDeclaration(Identifier.lookup(getString(n).replace('/','.')));</span>
    }

    /**
     * get class declaration
     */
    public ClassDeclaration getDeclaration(Environment env, int n) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">        return (n == 0) ? null : getDeclarationFromName(env, getInteger(n));</span>
    }

    /**
     * get a type from a type signature
     */
    public Type getType(int n) {
<span class="nc" id="L159">        return Type.tType(getString(n));</span>
    }

    /**
     * get the type of constant given an index
     */
    public int getConstantType(int n) {
<span class="nc" id="L166">        return types[n];</span>
    }

    /**
     * get the n-th constant from the constant pool
     */
    public Object getConstant(int n, Environment env) {
<span class="nc" id="L173">        int constant_type = getConstantType(n);</span>
<span class="nc bnc" id="L174" title="All 5 branches missed.">        switch (constant_type) {</span>
            case CONSTANT_INTEGER:
            case CONSTANT_FLOAT:
            case CONSTANT_LONG:
            case CONSTANT_DOUBLE:
            case CONSTANT_METHODHANDLE:
            case CONSTANT_METHODTYPE:
            case CONSTANT_INVOKEDYNAMIC:
<span class="nc" id="L182">                return getValue(n);</span>

            case CONSTANT_CLASS:
<span class="nc" id="L185">                return getDeclaration(env, n);</span>

            case CONSTANT_STRING:
<span class="nc" id="L188">                return getString(getInteger(n));</span>

            case CONSTANT_FIELD:
            case CONSTANT_METHOD:
            case CONSTANT_INTERFACEMETHOD:
                try {
<span class="nc" id="L194">                    int key = getInteger(n);</span>
<span class="nc" id="L195">                    ClassDefinition clazz =</span>
<span class="nc" id="L196">                        getDeclaration(env, key &gt;&gt; 16).getClassDefinition(env);</span>
<span class="nc" id="L197">                    int name_and_type = getInteger(key &amp; 0xFFFF);</span>
<span class="nc" id="L198">                    Identifier id = getIdentifier(name_and_type &gt;&gt; 16);</span>
<span class="nc" id="L199">                    Type type = getType(name_and_type &amp; 0xFFFF);</span>

<span class="nc" id="L201">                    for (MemberDefinition field = clazz.getFirstMatch(id);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                         field != null;</span>
<span class="nc" id="L203">                         field = field.getNextMatch()) {</span>
<span class="nc" id="L204">                        Type field_type = field.getType();</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                        if ((constant_type == CONSTANT_FIELD)</span>
                            ? (field_type == type)
<span class="nc bnc" id="L207" title="All 2 branches missed.">                            : (field_type.equalArguments(type)))</span>
<span class="nc" id="L208">                            return field;</span>
                    }
<span class="nc" id="L210">                } catch (ClassNotFound e) {</span>
<span class="nc" id="L211">                }</span>
<span class="nc" id="L212">                return null;</span>

            default:
<span class="nc" id="L215">                throw new ClassFormatError(&quot;invalid constant type: &quot; +</span>
                                              constant_type);
        }
    }


    /**
     * Get a list of dependencies, ie: all the classes referenced in this
     * constant pool.
     */
    public Vector getDependencies(Environment env) {
<span class="nc" id="L226">        Vector v = new Vector();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        for (int i = 1 ; i &lt; cpool.length ; i++) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            switch(types[i]) {</span>
              case CONSTANT_CLASS:
<span class="nc" id="L230">                v.addElement(getDeclarationFromName(env, getInteger(i)));</span>
                break;
            }
        }
<span class="nc" id="L234">        return v;</span>
    }

    Hashtable indexHashObject, indexHashAscii;
    Vector MoreStuff;

    /**
     * Find the index of an Object in the constant pool
     */
    public int indexObject(Object obj, Environment env) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (indexHashObject == null)</span>
<span class="nc" id="L245">            createIndexHash(env);</span>
<span class="nc" id="L246">        Integer result = (Integer)indexHashObject.get(obj);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (result == null)</span>
<span class="nc" id="L248">            throw new IndexOutOfBoundsException(&quot;Cannot find object &quot; + obj + &quot; of type &quot; +</span>
<span class="nc" id="L249">                                obj.getClass() + &quot; in constant pool&quot;);</span>
<span class="nc" id="L250">        return result.intValue();</span>
    }

    /**
     * Find the index of an ascii string in the constant pool.  If it's not in
     * the constant pool, then add it at the end.
     */
    public int indexString(String string, Environment env) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (indexHashObject == null)</span>
<span class="nc" id="L259">            createIndexHash(env);</span>
<span class="nc" id="L260">        Integer result = (Integer)indexHashAscii.get(string);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (MoreStuff == null) MoreStuff = new Vector();</span>
<span class="nc" id="L263">            result = new Integer(cpool.length + MoreStuff.size());</span>
<span class="nc" id="L264">            MoreStuff.addElement(string);</span>
<span class="nc" id="L265">            indexHashAscii.put(string, result);</span>
        }
<span class="nc" id="L267">        return result.intValue();</span>
    }

    /**
     * Create a hash table of all the items in the constant pool that could
     * possibly be referenced from the outside.
     */

    public void createIndexHash(Environment env) {
<span class="nc" id="L276">        indexHashObject = new Hashtable();</span>
<span class="nc" id="L277">        indexHashAscii = new Hashtable();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (int i = 1; i &lt; cpool.length; i++) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (types[i] == CONSTANT_UTF8) {</span>
<span class="nc" id="L280">                indexHashAscii.put(cpool[i], new Integer(i));</span>
            } else {
                try {
<span class="nc" id="L283">                    indexHashObject.put(getConstant(i, env), new Integer(i));</span>
<span class="nc" id="L284">                } catch (ClassFormatError e) { }</span>
            }
        }
<span class="nc" id="L287">    }</span>


    /**
     * Write out the contents of the constant pool, including any additions
     * that have been added.
     */
    public void write(DataOutputStream out, Environment env) throws IOException {
<span class="nc" id="L295">        int length = cpool.length;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (MoreStuff != null)</span>
<span class="nc" id="L297">            length += MoreStuff.size();</span>
<span class="nc" id="L298">        out.writeShort(length);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int i = 1 ; i &lt; cpool.length; i++) {</span>
<span class="nc" id="L300">            int type = types[i];</span>
<span class="nc" id="L301">            Object x = cpool[i];</span>
<span class="nc" id="L302">            out.writeByte(type);</span>
<span class="nc bnc" id="L303" title="All 9 branches missed.">            switch (type) {</span>
                case CONSTANT_UTF8:
<span class="nc" id="L305">                    out.writeUTF((String) x);</span>
<span class="nc" id="L306">                    break;</span>
                case CONSTANT_INTEGER:
<span class="nc" id="L308">                    out.writeInt(((Number)x).intValue());</span>
<span class="nc" id="L309">                    break;</span>
                case CONSTANT_FLOAT:
<span class="nc" id="L311">                    out.writeFloat(((Number)x).floatValue());</span>
<span class="nc" id="L312">                    break;</span>
                case CONSTANT_LONG:
<span class="nc" id="L314">                    out.writeLong(((Number)x).longValue());</span>
<span class="nc" id="L315">                    i++;</span>
<span class="nc" id="L316">                    break;</span>
                case CONSTANT_DOUBLE:
<span class="nc" id="L318">                    out.writeDouble(((Number)x).doubleValue());</span>
<span class="nc" id="L319">                    i++;</span>
<span class="nc" id="L320">                    break;</span>
                case CONSTANT_CLASS:
                case CONSTANT_STRING:
<span class="nc" id="L323">                    out.writeShort(((Number)x).intValue());</span>
<span class="nc" id="L324">                    break;</span>
                case CONSTANT_FIELD:
                case CONSTANT_METHOD:
                case CONSTANT_INTERFACEMETHOD:
                case CONSTANT_NAMEANDTYPE: {
<span class="nc" id="L329">                    int value = ((Number)x).intValue();</span>
<span class="nc" id="L330">                    out.writeShort(value &gt;&gt; 16);</span>
<span class="nc" id="L331">                    out.writeShort(value &amp; 0xFFFF);</span>
<span class="nc" id="L332">                    break;</span>
                }
                case CONSTANT_METHODHANDLE:
                case CONSTANT_METHODTYPE:
                case CONSTANT_INVOKEDYNAMIC:
<span class="nc" id="L337">                    out.write((byte[])x, 0, ((byte[])x).length);</span>
<span class="nc" id="L338">                    break;</span>
                default:
<span class="nc" id="L340">                     throw new ClassFormatError(&quot;invalid constant type: &quot;</span>
                                                   + (int)types[i]);
            }
        }
<span class="nc bnc" id="L344" title="All 2 branches missed.">        for (int i = cpool.length; i &lt; length; i++) {</span>
<span class="nc" id="L345">            String string = (String)(MoreStuff.elementAt(i - cpool.length));</span>
<span class="nc" id="L346">            out.writeByte(CONSTANT_UTF8);</span>
<span class="nc" id="L347">            out.writeUTF(string);</span>
        }
<span class="nc" id="L349">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>