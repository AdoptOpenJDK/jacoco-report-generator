<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ClassDefinition.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.tools.java</a> &gt; <span class="el_source">ClassDefinition.java</span></div><h1>ClassDefinition.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.java;

import java.util.*;
import java.io.OutputStream;
import java.io.PrintStream;
import sun.tools.tree.Context;
import sun.tools.tree.Vset;
import sun.tools.tree.Expression;
import sun.tools.tree.LocalMember;
import sun.tools.tree.UplevelReference;

/**
 * This class is a Java class definition
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class ClassDefinition implements Constants {

    protected Object source;
    protected long where;
    protected int modifiers;
    protected Identifier localName; // for local classes
    protected ClassDeclaration declaration;
    protected IdentifierToken superClassId;
    protected IdentifierToken interfaceIds[];
    protected ClassDeclaration superClass;
    protected ClassDeclaration interfaces[];
    protected ClassDefinition outerClass;
    protected MemberDefinition outerMember;
    protected MemberDefinition innerClassMember;        // field for me in outerClass
    protected MemberDefinition firstMember;
    protected MemberDefinition lastMember;
    protected boolean resolved;
    protected String documentation;
    protected boolean error;
    protected boolean nestError;
    protected UplevelReference references;
    protected boolean referencesFrozen;
<span class="nc" id="L67">    private Hashtable fieldHash = new Hashtable(31);</span>
    private int abstr;

    // Table of local and anonymous classes whose internal names are constructed
    // using the current class as a prefix.  This is part of a fix for
    // bugid 4054523 and 4030421.  See also 'Environment.getClassDefinition'
    // and 'BatchEnvironment.makeClassDefinition'.  Allocated on demand.
<span class="nc" id="L74">    private Hashtable localClasses = null;</span>
<span class="nc" id="L75">    private final int LOCAL_CLASSES_SIZE = 31;</span>

    // The immediately surrounding context in which the class appears.
    // Set at the beginning of checking, upon entry to 'SourceClass.checkInternal'.
    // Null for classes that are not local or inside a local class.
    // At present, this field exists only for the benefit of 'resolveName' as part
    // of the fix for 4095716.
    protected Context classContext;

    // The saved class context is now also used in 'SourceClass.getAccessMember'.
    // Provide read-only access via this method.  Part of fix for 4098093.
    public Context getClassContext() {
<span class="nc" id="L87">        return classContext;</span>
    }


    /**
     * Constructor
     */
    protected ClassDefinition(Object source, long where, ClassDeclaration declaration,
<span class="nc" id="L95">                              int modifiers, IdentifierToken superClass, IdentifierToken interfaces[]) {</span>
<span class="nc" id="L96">        this.source = source;</span>
<span class="nc" id="L97">        this.where = where;</span>
<span class="nc" id="L98">        this.declaration = declaration;</span>
<span class="nc" id="L99">        this.modifiers = modifiers;</span>
<span class="nc" id="L100">        this.superClassId = superClass;</span>
<span class="nc" id="L101">        this.interfaceIds = interfaces;</span>
<span class="nc" id="L102">    }</span>

    /**
     * Get the source of the class
     */
    public final Object getSource() {
<span class="nc" id="L108">        return source;</span>
    }

    /**
     * Check if there were any errors in this class.
     */
    public final boolean getError() {
<span class="nc" id="L115">        return error;</span>
    }

    /**
     * Mark this class to be erroneous.
     */
    public final void setError() {
<span class="nc" id="L122">        this.error = true;</span>
<span class="nc" id="L123">        setNestError();</span>
<span class="nc" id="L124">    }</span>

    /**
     * Check if there were any errors in our class nest.
     */
    public final boolean getNestError() {
        // Check to see if our error value is set, or if any of our
        // outer classes' error values are set.  This will work in
        // conjunction with setError(), which sets the error value
        // of its outer class, to yield true is any of our nest
        // siblings has an error.  This addresses bug 4111488: either
        // code should be generated for all classes in a nest, or
        // none of them.
<span class="nc bnc" id="L137" title="All 6 branches missed.">        return nestError || ((outerClass != null) ? outerClass.getNestError() : false);</span>
    }

    /**
     * Mark this class, and all siblings in its class nest, to be
     * erroneous.
     */
    public final void setNestError() {
<span class="nc" id="L145">        this.nestError = true;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (outerClass != null) {</span>
            // If we have an outer class, set it to be erroneous as well.
            // This will work in conjunction with getError(), which checks
            // the error value of its outer class, to set the whole class
            // nest to be erroneous.  This address bug 4111488: either
            // code should be generated for all classes in a nest, or
            // none of them.
<span class="nc" id="L153">            outerClass.setNestError();</span>
        }
<span class="nc" id="L155">    }</span>

    /**
     * Get the position in the input
     */
    public final long getWhere() {
<span class="nc" id="L161">        return where;</span>
    }

    /**
     * Get the class declaration
     */
    public final ClassDeclaration getClassDeclaration() {
<span class="nc" id="L168">        return declaration;</span>
    }

    /**
     * Get the class' modifiers
     */
    public final int getModifiers() {
<span class="nc" id="L175">        return modifiers;</span>
    }
    public final void subModifiers(int mod) {
<span class="nc" id="L178">        modifiers &amp;= ~mod;</span>
<span class="nc" id="L179">    }</span>
    public final void addModifiers(int mod) {
<span class="nc" id="L181">        modifiers |= mod;</span>
<span class="nc" id="L182">    }</span>

    // *** DEBUG ***
<span class="nc bnc" id="L185" title="All 2 branches missed.">    protected boolean supersCheckStarted = !(this instanceof sun.tools.javac.SourceClass);</span>

    /**
     * Get the class' super class
     */
    public final ClassDeclaration getSuperClass() {
        /*---
        if (superClass == null &amp;&amp; superClassId != null)
            throw new CompilerError(&quot;getSuperClass &quot;+superClassId);
        // There are obscure cases where null is the right answer,
        // in order to enable some error reporting later on.
        // For example:  class T extends T.N { class N { } }
        ---*/

        // *** DEBUG ***
        // This method should not be called if the superclass has not been resolved.
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (!supersCheckStarted) throw new CompilerError(&quot;unresolved super&quot;);</span>

<span class="nc" id="L203">        return superClass;</span>
    }

    /**
     * Get the super class, and resolve names now if necessary.
     *
     * It is only possible to resolve names at this point if we are
     * a source class.  The provision of this method at this level
     * in the class hierarchy is dubious, but see 'getInnerClass' below.
     * All other calls to 'getSuperClass(env)' appear in 'SourceClass'.
     * NOTE: An older definition of this method has been moved to
     * 'SourceClass', where it overrides this one.
     *
     * @see #resolveTypeStructure
     */

    public ClassDeclaration getSuperClass(Environment env) {
<span class="nc" id="L220">        return getSuperClass();</span>
    }

    /**
     * Get the class' interfaces
     */
    public final ClassDeclaration getInterfaces()[] {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (interfaces == null)  throw new CompilerError(&quot;getInterfaces&quot;);</span>
<span class="nc" id="L228">        return interfaces;</span>
    }

    /**
     * Get the class' enclosing class (or null if not inner)
     */
    public final ClassDefinition getOuterClass() {
<span class="nc" id="L235">        return outerClass;</span>
    }

    /**
     * Set the class' enclosing class.  Must be done at most once.
     */
    protected final void setOuterClass(ClassDefinition outerClass) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (this.outerClass != null)  throw new CompilerError(&quot;setOuterClass&quot;);</span>
<span class="nc" id="L243">        this.outerClass = outerClass;</span>
<span class="nc" id="L244">    }</span>

    /**
     * Set the class' enclosing current instance pointer.
     * Must be done at most once.
     */
    protected final void setOuterMember(MemberDefinition outerMember) {

<span class="nc bnc" id="L252" title="All 4 branches missed.">        if (isStatic() || !isInnerClass())  throw new CompilerError(&quot;setOuterField&quot;);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (this.outerMember != null)  throw new CompilerError(&quot;setOuterField&quot;);</span>
<span class="nc" id="L254">        this.outerMember = outerMember;</span>
<span class="nc" id="L255">    }</span>

    /**
     * Tell if the class is inner.
     * This predicate also returns true for top-level nested types.
     * To test for a true inner class as seen by the programmer,
     * use &lt;tt&gt;!isTopLevel()&lt;/tt&gt;.
     */
    public final boolean isInnerClass() {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        return outerClass != null;</span>
    }

    /**
     * Tell if the class is a member of another class.
     * This is false for package members and for block-local classes.
     */
    public final boolean isMember() {
<span class="nc bnc" id="L272" title="All 4 branches missed.">        return outerClass != null &amp;&amp; !isLocal();</span>
    }

    /**
     * Tell if the class is &quot;top-level&quot;, which is either a package member,
     * or a static member of another top-level class.
     */
    public final boolean isTopLevel() {
<span class="nc bnc" id="L280" title="All 6 branches missed.">        return outerClass == null || isStatic() || isInterface();</span>
    }

    /**
     * Tell if the class is local or inside a local class,
     * which means it cannot be mentioned outside of its file.
     */

    // The comment above is true only because M_LOCAL is set
    // whenever M_ANONYMOUS is.  I think it is risky to assume that
    // isAnonymous(x) =&gt; isLocal(x).

    public final boolean isInsideLocal() {
<span class="nc bnc" id="L293" title="All 4 branches missed.">        return isLocal() ||</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            (outerClass != null &amp;&amp; outerClass.isInsideLocal());</span>
    }

    /**
     * Tell if the class is local or or anonymous class, or inside
     * such a class, which means it cannot be mentioned outside of
     * its file.
     */
    public final boolean isInsideLocalOrAnonymous() {
<span class="nc bnc" id="L303" title="All 6 branches missed.">        return isLocal() || isAnonymous () ||</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            (outerClass != null &amp;&amp; outerClass.isInsideLocalOrAnonymous());</span>
    }

    /**
     * Return a simple identifier for this class (idNull if anonymous).
     */
    public Identifier getLocalName() {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (localName != null) {</span>
<span class="nc" id="L312">            return localName;</span>
        }
        // This is also the name of the innerClassMember, if any:
<span class="nc" id="L315">        return getName().getFlatName().getName();</span>
    }

    /**
     * Set the local name of a class.  Must be a local class.
     */
    public void setLocalName(Identifier name) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (isLocal()) {</span>
<span class="nc" id="L323">            localName = name;</span>
        }
<span class="nc" id="L325">    }</span>

    /**
     * If inner, get the field for this class in the enclosing class
     */
    public final MemberDefinition getInnerClassMember() {
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (outerClass == null)</span>
<span class="nc" id="L332">            return null;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (innerClassMember == null) {</span>
            // We must find the field in the outer class.
<span class="nc" id="L335">            Identifier nm = getName().getFlatName().getName();</span>
<span class="nc" id="L336">            for (MemberDefinition field = outerClass.getFirstMatch(nm);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                 field != null; field = field.getNextMatch()) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (field.isInnerClass()) {</span>
<span class="nc" id="L339">                    innerClassMember = field;</span>
<span class="nc" id="L340">                    break;</span>
                }
            }
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (innerClassMember == null)</span>
<span class="nc" id="L344">                throw new CompilerError(&quot;getInnerClassField&quot;);</span>
        }
<span class="nc" id="L346">        return innerClassMember;</span>
    }

    /**
     * If inner, return an innermost uplevel self pointer, if any exists.
     * Otherwise, return null.
     */
    public final MemberDefinition findOuterMember() {
<span class="nc" id="L354">        return outerMember;</span>
    }

    /**
     * See if this is a (nested) static class.
     */
    public final boolean isStatic() {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        return (modifiers &amp; ACC_STATIC) != 0;</span>
    }

    /**
     * Get the class' top-level enclosing class
     */
    public final ClassDefinition getTopClass() {
        ClassDefinition p, q;
<span class="nc bnc" id="L369" title="All 2 branches missed.">        for (p = this; (q = p.outerClass) != null; p = q)</span>
            ;
<span class="nc" id="L371">        return p;</span>
    }

    /**
     * Get the class' first field or first match
     */
    public final MemberDefinition getFirstMember() {
<span class="nc" id="L378">        return firstMember;</span>
    }
    public final MemberDefinition getFirstMatch(Identifier name) {
<span class="nc" id="L381">        return (MemberDefinition)fieldHash.get(name);</span>
    }

    /**
     * Get the class' name
     */
    public final Identifier getName() {
<span class="nc" id="L388">        return declaration.getName();</span>
    }

    /**
     * Get the class' type
     */
    public final Type getType() {
<span class="nc" id="L395">        return declaration.getType();</span>
    }

    /**
     * Get the class' documentation
     */
    public String getDocumentation() {
<span class="nc" id="L402">        return documentation;</span>
    }

    /**
     * Return true if the given documentation string contains a deprecation
     * paragraph.  This is true if the string contains the tag @deprecated
     * is the first word in a line.
     */
    public static boolean containsDeprecated(String documentation) {
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (documentation == null) {</span>
<span class="nc" id="L412">            return false;</span>
        }
    doScan:
<span class="nc" id="L415">        for (int scan = 0;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">             (scan = documentation.indexOf(paraDeprecated, scan)) &gt;= 0;</span>
<span class="nc" id="L417">             scan += paraDeprecated.length()) {</span>
            // make sure there is only whitespace between this word
            // and the beginning of the line
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int beg = scan-1; beg &gt;= 0; beg--) {</span>
<span class="nc" id="L421">                char ch = documentation.charAt(beg);</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">                if (ch == '\n' || ch == '\r') {</span>
<span class="nc" id="L423">                    break;      // OK</span>
                }
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (!Character.isSpace(ch)) {</span>
<span class="nc" id="L426">                    continue doScan;</span>
                }
            }
            // make sure the char after the word is space or end of line
<span class="nc" id="L430">            int end = scan+paraDeprecated.length();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (end &lt; documentation.length()) {</span>
<span class="nc" id="L432">                char ch = documentation.charAt(end);</span>
<span class="nc bnc" id="L433" title="All 6 branches missed.">                if (!(ch == '\n' || ch == '\r') &amp;&amp; !Character.isSpace(ch)) {</span>
<span class="nc" id="L434">                    continue doScan;</span>
                }
            }
<span class="nc" id="L437">            return true;</span>
        }
<span class="nc" id="L439">        return false;</span>
    }

    public final boolean inSamePackage(ClassDeclaration c) {
        // find out if the class stored in c is defined in the same
        // package as the current class.
<span class="nc" id="L445">        return inSamePackage(c.getName().getQualifier());</span>
    }

    public final boolean inSamePackage(ClassDefinition c) {
        // find out if the class stored in c is defined in the same
        // package as the current class.
<span class="nc" id="L451">        return inSamePackage(c.getName().getQualifier());</span>
    }

    public final boolean inSamePackage(Identifier packageName) {
<span class="nc" id="L455">        return (getName().getQualifier().equals(packageName));</span>
    }

    /**
     * Checks
     */
    public final boolean isInterface() {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        return (getModifiers() &amp; M_INTERFACE) != 0;</span>
    }
    public final boolean isClass() {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        return (getModifiers() &amp; M_INTERFACE) == 0;</span>
    }
    public final boolean isPublic() {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        return (getModifiers() &amp; M_PUBLIC) != 0;</span>
    }
    public final boolean isPrivate() {
<span class="nc bnc" id="L471" title="All 2 branches missed.">        return (getModifiers() &amp; M_PRIVATE) != 0;</span>
    }
    public final boolean isProtected() {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        return (getModifiers() &amp; M_PROTECTED) != 0;</span>
    }
    public final boolean isPackagePrivate() {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        return (modifiers &amp; (M_PUBLIC | M_PRIVATE | M_PROTECTED)) == 0;</span>
    }
    public final boolean isFinal() {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        return (getModifiers() &amp; M_FINAL) != 0;</span>
    }
    public final boolean isAbstract() {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        return (getModifiers() &amp; M_ABSTRACT) != 0;</span>
    }
    public final boolean isSynthetic() {
<span class="nc bnc" id="L486" title="All 2 branches missed.">        return (getModifiers() &amp; M_SYNTHETIC) != 0;</span>
    }
    public final boolean isDeprecated() {
<span class="nc bnc" id="L489" title="All 2 branches missed.">        return (getModifiers() &amp; M_DEPRECATED) != 0;</span>
    }
    public final boolean isAnonymous() {
<span class="nc bnc" id="L492" title="All 2 branches missed.">        return (getModifiers() &amp; M_ANONYMOUS) != 0;</span>
    }
    public final boolean isLocal() {
<span class="nc bnc" id="L495" title="All 2 branches missed.">        return (getModifiers() &amp; M_LOCAL) != 0;</span>
    }
    public final boolean hasConstructor() {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        return getFirstMatch(idInit) != null;</span>
    }


    /**
     * Check to see if a class must be abstract.  This method replaces
     * isAbstract(env)
     */
    public final boolean mustBeAbstract(Environment env) {
        // If it is declared abstract, return true.
        // (Fix for 4110534.)
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (isAbstract()) {</span>
<span class="nc" id="L510">            return true;</span>
        }

        // Check to see if the class should have been declared to be
        // abstract.

        // We make sure that the inherited method collection has been
        // performed.
<span class="nc" id="L518">        collectInheritedMethods(env);</span>

        // We check for any abstract methods inherited or declared
        // by this class.
<span class="nc" id="L522">        Iterator methods = getMethods();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        while (methods.hasNext()) {</span>
<span class="nc" id="L524">            MemberDefinition method = (MemberDefinition) methods.next();</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (method.isAbstract()) {</span>
<span class="nc" id="L527">                return true;</span>
            }
<span class="nc" id="L529">        }</span>

        // We check for hidden &quot;permanently abstract&quot; methods in
        // our superclasses.
<span class="nc" id="L533">        return getPermanentlyAbstractMethods().hasNext();</span>
    }

    /**
     * Check if this is a super class of another class
     */
    public boolean superClassOf(Environment env, ClassDeclaration otherClass)
                                                                throws ClassNotFound {
<span class="nc bnc" id="L541" title="All 2 branches missed.">        while (otherClass != null) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (getClassDeclaration().equals(otherClass)) {</span>
<span class="nc" id="L543">                return true;</span>
            }
<span class="nc" id="L545">            otherClass = otherClass.getClassDefinition(env).getSuperClass();</span>
        }
<span class="nc" id="L547">        return false;</span>
    }

    /**
     * Check if this is an enclosing class of another class
     */
    public boolean enclosingClassOf(ClassDefinition otherClass) {
<span class="nc bnc" id="L554" title="All 2 branches missed.">        while ((otherClass = otherClass.getOuterClass()) != null) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (this == otherClass) {</span>
<span class="nc" id="L556">                return true;</span>
            }
        }
<span class="nc" id="L559">        return false;</span>
    }

    /**
     * Check if this is a sub class of another class
     */
    public boolean subClassOf(Environment env, ClassDeclaration otherClass) throws ClassNotFound {
<span class="nc" id="L566">        ClassDeclaration c = getClassDeclaration();</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">        while (c != null) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (c.equals(otherClass)) {</span>
<span class="nc" id="L569">                return true;</span>
            }
<span class="nc" id="L571">            c = c.getClassDefinition(env).getSuperClass();</span>
        }
<span class="nc" id="L573">        return false;</span>
    }

    /**
     * Check if this class is implemented by another class
     */
    public boolean implementedBy(Environment env, ClassDeclaration c) throws ClassNotFound {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        for (; c != null ; c = c.getClassDefinition(env).getSuperClass()) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (getClassDeclaration().equals(c)) {</span>
<span class="nc" id="L582">                return true;</span>
            }
<span class="nc" id="L584">            ClassDeclaration intf[] = c.getClassDefinition(env).getInterfaces();</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            for (int i = 0 ; i &lt; intf.length ; i++) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (implementedBy(env, intf[i])) {</span>
<span class="nc" id="L587">                    return true;</span>
                }
            }
        }
<span class="nc" id="L591">        return false;</span>
    }

    /**
     * Check to see if a class which implements interface `this' could
     * possibly implement the interface `intDef'.  Note that the only
     * way that this can fail is if `this' and `intDef' have methods
     * which are of the same signature and different return types.  This
     * method is used by Environment.explicitCast() to determine if a
     * cast between two interfaces is legal.
     *
     * This method should only be called on a class after it has been
     * basicCheck()'ed.
     */
    public boolean couldImplement(ClassDefinition intDef) {
        // Check to see if we could have done the necessary checks.
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (!doInheritanceChecks) {</span>
<span class="nc" id="L608">            throw new CompilerError(&quot;couldImplement: no checks&quot;);</span>
        }

        // This method should only be called for interfaces.
<span class="nc bnc" id="L612" title="All 4 branches missed.">        if (!isInterface() || !intDef.isInterface()) {</span>
<span class="nc" id="L613">            throw new CompilerError(&quot;couldImplement: not interface&quot;);</span>
        }

        // Make sure we are not called before we have collected our
        // inheritance information.
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (allMethods == null) {</span>
<span class="nc" id="L619">            throw new CompilerError(&quot;couldImplement: called early&quot;);</span>
        }

        // Get the other classes' methods.  getMethods() in
        // general can return methods which are not visible to the
        // current package.  We need to make sure that these do not
        // prevent this class from being implemented.
<span class="nc" id="L626">        Iterator otherMethods = intDef.getMethods();</span>

<span class="nc bnc" id="L628" title="All 2 branches missed.">        while (otherMethods.hasNext()) {</span>
            // Get one of the methods from intDef...
<span class="nc" id="L630">            MemberDefinition method =</span>
<span class="nc" id="L631">                (MemberDefinition) otherMethods.next();</span>

<span class="nc" id="L633">            Identifier name = method.getName();</span>
<span class="nc" id="L634">            Type type = method.getType();</span>

            // See if we implement a method of the same signature...
<span class="nc" id="L637">            MemberDefinition myMethod = allMethods.lookupSig(name, type);</span>

            //System.out.println(&quot;Comparing\n\t&quot; + myMethod +
            //                   &quot;\nand\n\t&quot; + method);

<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (myMethod != null) {</span>
                // We do.  Make sure the methods have the same return type.
<span class="nc bnc" id="L644" title="All 2 branches missed.">                if (!myMethod.sameReturnType(method)) {</span>
<span class="nc" id="L645">                    return false;</span>
                }
            }
<span class="nc" id="L648">        }</span>

<span class="nc" id="L650">        return true;</span>
    }

    /**
     * Check if another class can be accessed from the 'extends' or 'implements'
     * clause of this class.
     */
    public boolean extendsCanAccess(Environment env, ClassDeclaration c) throws ClassNotFound {

        // Names in the 'extends' or 'implements' clause of an inner class
        // are checked as if they appeared in the body of the surrounding class.
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (outerClass != null) {</span>
<span class="nc" id="L662">            return outerClass.canAccess(env, c);</span>
        }

        // We are a package member.

<span class="nc" id="L667">        ClassDefinition cdef = c.getClassDefinition(env);</span>

<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (cdef.isLocal()) {</span>
            // No locals should be in scope in the 'extends' or
            // 'implements' clause of a package member.
<span class="nc" id="L672">            throw new CompilerError(&quot;top local&quot;);</span>
        }

<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (cdef.isInnerClass()) {</span>
<span class="nc" id="L676">            MemberDefinition f = cdef.getInnerClassMember();</span>

            // Access to public member is always allowed.
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (f.isPublic()) {</span>
<span class="nc" id="L680">                return true;</span>
            }

            // Private access is ok only from the same class nest.  This can
            // happen only if the class represented by 'this' encloses the inner
            // class represented by 'f'.
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (f.isPrivate()) {</span>
<span class="nc" id="L687">                return getClassDeclaration().equals(f.getTopClass().getClassDeclaration());</span>
            }

            // Protected or default access -- allow access if in same package.
<span class="nc" id="L691">            return getName().getQualifier().equals(f.getClassDeclaration().getName().getQualifier());</span>
        }

        // Access to public member is always allowed.
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (cdef.isPublic()) {</span>
<span class="nc" id="L696">            return true;</span>
        }

        // Default access -- allow access if in same package.
<span class="nc" id="L700">        return getName().getQualifier().equals(c.getName().getQualifier());</span>
    }

    /**
     * Check if another class can be accessed from within the body of this class.
     */
    public boolean canAccess(Environment env, ClassDeclaration c) throws ClassNotFound {
<span class="nc" id="L707">        ClassDefinition cdef = c.getClassDefinition(env);</span>

<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (cdef.isLocal()) {</span>
            // if it's in scope, it's accessible
<span class="nc" id="L711">            return true;</span>
        }

<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (cdef.isInnerClass()) {</span>
<span class="nc" id="L715">            return canAccess(env, cdef.getInnerClassMember());</span>
        }

        // Public access is always ok
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (cdef.isPublic()) {</span>
<span class="nc" id="L720">            return true;</span>
        }

        // It must be in the same package
<span class="nc" id="L724">        return getName().getQualifier().equals(c.getName().getQualifier());</span>
    }

    /**
     * Check if a field can be accessed from a class
     */

    public boolean canAccess(Environment env, MemberDefinition f)
                throws ClassNotFound {

        // Public access is always ok
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (f.isPublic()) {</span>
<span class="nc" id="L736">            return true;</span>
        }
        // Protected access is ok from a subclass
<span class="nc bnc" id="L739" title="All 4 branches missed.">        if (f.isProtected() &amp;&amp; subClassOf(env, f.getClassDeclaration())) {</span>
<span class="nc" id="L740">            return true;</span>
        }
        // Private access is ok only from the same class nest
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (f.isPrivate()) {</span>
<span class="nc" id="L744">            return getTopClass().getClassDeclaration()</span>
<span class="nc" id="L745">                .equals(f.getTopClass().getClassDeclaration());</span>
        }
        // It must be in the same package
<span class="nc" id="L748">        return getName().getQualifier().equals(f.getClassDeclaration().getName().getQualifier());</span>
    }

    /**
     * Check if a class is entitled to inline access to a class from
     * another class.
     */
    public boolean permitInlinedAccess(Environment env, ClassDeclaration c)
                       throws ClassNotFound {

<span class="nc bnc" id="L758" title="All 4 branches missed.">        return (env.opt() &amp;&amp; c.equals(declaration)) ||</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">               (env.opt_interclass() &amp;&amp; canAccess(env, c));</span>
    }

    /**
     * Check if a class is entitled to inline access to a method from
     * another class.
     */
    public boolean permitInlinedAccess(Environment env, MemberDefinition f)
                       throws ClassNotFound {
<span class="nc bnc" id="L768" title="All 2 branches missed.">        return (env.opt()</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                    &amp;&amp; (f.clazz.getClassDeclaration().equals(declaration))) ||</span>
<span class="nc bnc" id="L770" title="All 4 branches missed.">               (env.opt_interclass() &amp;&amp; canAccess(env, f));</span>
    }

    /**
     * We know the the field is marked protected (and not public) and that
     * the field is visible (as per canAccess).  Can we access the field as
     * &lt;accessor&gt;.&lt;field&gt;, where &lt;accessor&gt; has the type &lt;accessorType&gt;?
     *
     * Protected fields can only be accessed when the accessorType is a
     * subclass of the current class
     */
    public boolean protectedAccess(Environment env, MemberDefinition f,
                                   Type accessorType)
        throws ClassNotFound
    {

<span class="nc" id="L786">        return</span>
               // static protected fields are accessible
<span class="nc bnc" id="L788" title="All 2 branches missed.">               f.isStatic()</span>
            || // allow array.clone()
<span class="nc bnc" id="L790" title="All 4 branches missed.">               (accessorType.isType(TC_ARRAY) &amp;&amp; (f.getName() == idClone)</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                 &amp;&amp; (f.getType().getArgumentTypes().length == 0))</span>
            || // &lt;accessorType&gt; is a subtype of the current class
<span class="nc bnc" id="L793" title="All 2 branches missed.">               (accessorType.isType(TC_CLASS)</span>
<span class="nc" id="L794">                 &amp;&amp; env.getClassDefinition(accessorType.getClassName())</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                         .subClassOf(env, getClassDeclaration()))</span>
            || // we are accessing the field from a friendly class (same package)
<span class="nc" id="L797">               (getName().getQualifier()</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                   .equals(f.getClassDeclaration().getName().getQualifier()));</span>
    }


    /**
     * Find or create an access method for a private member,
     * or return null if this is not possible.
     */
    public MemberDefinition getAccessMember(Environment env, Context ctx,
                                          MemberDefinition field, boolean isSuper) {
<span class="nc" id="L808">        throw new CompilerError(&quot;binary getAccessMember&quot;);</span>
    }

    /**
     * Find or create an update method for a private member,
     * or return null if this is not possible.
     */
    public MemberDefinition getUpdateMember(Environment env, Context ctx,
                                            MemberDefinition field, boolean isSuper) {
<span class="nc" id="L817">        throw new CompilerError(&quot;binary getUpdateMember&quot;);</span>
    }

    /**
     * Get a field from this class.  Report ambiguous fields.
     * If no accessible field is found, this method may return an
     * inaccessible field to allow a useful error message.
     *
     * getVariable now takes the source class `source' as an argument.
     * This allows getVariable to check whether a field is inaccessible
     * before it signals that a field is ambiguous.  The compiler used to
     * signal an ambiguity even when one of the fields involved was not
     * accessible.  (bug 4053724)
     */
    public MemberDefinition getVariable(Environment env,
                                        Identifier nm,
                                        ClassDefinition source)
        throws AmbiguousMember, ClassNotFound {

<span class="nc" id="L836">        return getVariable0(env, nm, source, true, true);</span>
    }

    /*
     * private fields are never inherited.  package-private fields are
     * not inherited across package boundaries.  To capture this, we
     * take two booleans as parameters: showPrivate indicates whether
     * we have passed a class boundary, and showPackage indicates whether
     * we have crossed a package boundary.
     */
    private MemberDefinition getVariable0(Environment env,
                                          Identifier nm,
                                          ClassDefinition source,
                                          boolean showPrivate,
                                          boolean showPackage)
        throws AmbiguousMember, ClassNotFound {

        // Check to see if this field is defined in the current class
<span class="nc" id="L854">        for (MemberDefinition member = getFirstMatch(nm);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">             member != null;</span>
<span class="nc" id="L856">             member = member.getNextMatch()) {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (member.isVariable()) {</span>
<span class="nc bnc" id="L858" title="All 6 branches missed.">                if ((showPrivate || !member.isPrivate()) &amp;&amp;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    (showPackage || !member.isPackagePrivate())) {</span>
                    // It is defined in this class.
<span class="nc" id="L861">                    return member;</span>
                } else {
                    // Even though this definition is not inherited,
                    // it hides all definitions in supertypes.
<span class="nc" id="L865">                    return null;</span>
                }
            }
        }

        // Find the field in our superclass.
<span class="nc" id="L871">        ClassDeclaration sup = getSuperClass();</span>
<span class="nc" id="L872">        MemberDefinition field = null;</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">        if (sup != null) {</span>
<span class="nc" id="L874">            field =</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                sup.getClassDefinition(env)</span>
<span class="nc" id="L876">                  .getVariable0(env, nm, source,</span>
                                false,
<span class="nc bnc" id="L878" title="All 2 branches missed.">                                showPackage &amp;&amp; inSamePackage(sup));</span>
        }

        // Find the field in our superinterfaces.
<span class="nc bnc" id="L882" title="All 2 branches missed.">        for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
            // Try to look up the field in an interface.  Since interfaces
            // only have public fields, the values of the two boolean
            // arguments are not important.
<span class="nc" id="L886">            MemberDefinition field2 =</span>
<span class="nc" id="L887">                interfaces[i].getClassDefinition(env)</span>
<span class="nc" id="L888">                  .getVariable0(env, nm, source, true, true);</span>

<span class="nc bnc" id="L890" title="All 2 branches missed.">            if (field2 != null) {</span>
                // If we have two different, accessible fields, then
                // we've found an ambiguity.
<span class="nc bnc" id="L893" title="All 2 branches missed.">                if (field != null &amp;&amp;</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">                    source.canAccess(env, field) &amp;&amp;</span>
                    field2 != field) {

<span class="nc" id="L897">                    throw new AmbiguousMember(field2, field);</span>
                }
<span class="nc" id="L899">                field = field2;</span>
            }
        }
<span class="nc" id="L902">        return field;</span>
    }

    /**
     * Tells whether to report a deprecation error for this class.
     */
    public boolean reportDeprecated(Environment env) {
<span class="nc bnc" id="L909" title="All 4 branches missed.">        return (isDeprecated()</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                || (outerClass != null &amp;&amp; outerClass.reportDeprecated(env)));</span>
    }

    /**
     * Note that this class is being used somehow by &lt;tt&gt;ref&lt;/tt&gt;.
     * Report deprecation errors, etc.
     */
    public void noteUsedBy(ClassDefinition ref, long where, Environment env) {
        // (Have this deal with canAccess() checks, too?)
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (reportDeprecated(env)) {</span>
<span class="nc" id="L920">            env.error(where, &quot;warn.class.is.deprecated&quot;, this);</span>
        }
<span class="nc" id="L922">    }</span>

   /**
     * Get an inner class.
     * Look in supers but not outers.
     * (This is used directly to resolve expressions like &quot;site.K&quot;, and
     * inside a loop to resolve lone names like &quot;K&quot; or the &quot;K&quot; in &quot;K.L&quot;.)
     *
     * Called from 'Context' and 'FieldExpression' as well as this class.
     *
     * @see FieldExpression.checkCommon
     * @see resolveName
     */
    public MemberDefinition getInnerClass(Environment env, Identifier nm)
                                                        throws ClassNotFound {
        // Note:  AmbiguousClass will not be thrown unless and until
        // inner classes can be defined inside interfaces.

        // Check if it is defined in the current class
<span class="nc" id="L941">        for (MemberDefinition field = getFirstMatch(nm);</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                field != null ; field = field.getNextMatch()) {</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (field.isInnerClass()) {</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                if (field.getInnerClass().isLocal()) {</span>
<span class="nc" id="L945">                    continue;   // ignore this name; it is internally generated</span>
                }
<span class="nc" id="L947">                return field;</span>
            }
        }

        // Get it from the super class
        // It is likely that 'getSuperClass()' could be made to work here
        // but we would have to assure somehow that 'resolveTypeStructure'
        // has been called on the current class nest.  Since we can get
        // here from 'resolveName', which is called from 'resolveSupers',
        // it is possible that the first attempt to resolve the superclass
        // will originate here, instead of in the call to 'getSuperClass'
        // in 'checkSupers'.  See 'resolveTypeStructure', in which a call
        // to 'resolveSupers' precedes the call to 'checkSupers'.  Why is
        // name resolution done twice, first in 'resolveName'?
        // NOTE: 'SourceMember.resolveTypeStructure' may initiate type
        // structure resolution for an inner class.  Normally, this
        // occurs during the resolution of the outer class, but fields
        // added after the resolution of their containing class will
        // be resolved late -- see 'addMember(env,field)' below.
        // This should only happen for synthetic members, which should
        // never be an inner class.
<span class="nc" id="L968">        ClassDeclaration sup = getSuperClass(env);</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (sup != null)</span>
<span class="nc" id="L970">            return sup.getClassDefinition(env).getInnerClass(env, nm);</span>

<span class="nc" id="L972">        return null;</span>
    }

    /**
     * Lookup a method.  This code implements the method lookup
     * mechanism specified in JLS 15.11.2.
     *
     * This mechanism cannot be used to lookup synthetic methods.
     */
    private MemberDefinition matchMethod(Environment env,
                                         ClassDefinition accessor,
                                         Identifier methodName,
                                         Type[] argumentTypes,
                                         boolean isAnonConstCall,
                                         Identifier accessPackage)
        throws AmbiguousMember, ClassNotFound {

<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (allMethods == null || !allMethods.isFrozen()) {</span>
            // This may be too restrictive.
<span class="nc" id="L991">            throw new CompilerError(&quot;matchMethod called early&quot;);</span>
            // collectInheritedMethods(env);
        }

        // A tentative maximally specific method.
<span class="nc" id="L996">        MemberDefinition tentative = null;</span>

        // A list of other methods which may be maximally specific too.
<span class="nc" id="L999">        List candidateList = null;</span>

        // Get all the methods inherited by this class which
        // have the name `methodName'.
<span class="nc" id="L1003">        Iterator methods = allMethods.lookupName(methodName);</span>

<span class="nc bnc" id="L1005" title="All 2 branches missed.">        while (methods.hasNext()) {</span>
<span class="nc" id="L1006">            MemberDefinition method = (MemberDefinition)methods.next();</span>

            // See if this method is applicable.
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if (!env.isApplicable(method, argumentTypes)) {</span>
<span class="nc" id="L1010">                continue;</span>
            }

            // See if this method is accessible.
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            if (accessor != null) {</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                if (!accessor.canAccess(env, method)) {</span>
<span class="nc" id="L1016">                    continue;</span>
                }
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            } else if (isAnonConstCall) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                if (method.isPrivate() ||</span>
<span class="nc bnc" id="L1020" title="All 4 branches missed.">                    (method.isPackagePrivate() &amp;&amp;</span>
                     accessPackage != null &amp;&amp;
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                     !inSamePackage(accessPackage))) {</span>
                    // For anonymous constructor accesses, we
                    // haven't yet built an accessing class.
                    // We disallow anonymous classes from seeing
                    // private/package-private inaccessible
                    // constructors in their superclass.
<span class="nc" id="L1028">                    continue;</span>
                }
            } else {
                // If accessor is null, we assume that the access
                // is allowed.  Query: is this option used?
            }

<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (tentative == null) {</span>
                // `method' becomes our tentative maximally specific match.
<span class="nc" id="L1037">                tentative = method;</span>
            } else {
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                if (env.isMoreSpecific(method, tentative)) {</span>
                    // We have found a method which is a strictly better
                    // match than `tentative'.  Replace it.
<span class="nc" id="L1042">                    tentative = method;</span>
                } else {
                    // If this method could possibly be another
                    // maximally specific method, add it to our
                    // list of other candidates.
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                    if (!env.isMoreSpecific(tentative,method)) {</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                        if (candidateList == null) {</span>
<span class="nc" id="L1049">                            candidateList = new ArrayList();</span>
                        }
<span class="nc" id="L1051">                        candidateList.add(method);</span>
                    }
                }
            }
<span class="nc" id="L1055">        }</span>

<span class="nc bnc" id="L1057" title="All 4 branches missed.">        if (tentative != null &amp;&amp; candidateList != null) {</span>
            // Find out if our `tentative' match is a uniquely
            // maximally specific.
<span class="nc" id="L1060">            Iterator candidates = candidateList.iterator();</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">            while (candidates.hasNext()) {</span>
<span class="nc" id="L1062">                MemberDefinition method = (MemberDefinition)candidates.next();</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                if (!env.isMoreSpecific(tentative, method)) {</span>
<span class="nc" id="L1064">                    throw new AmbiguousMember(tentative, method);</span>
                }
<span class="nc" id="L1066">            }</span>
        }

<span class="nc" id="L1069">        return tentative;</span>
    }

    /**
     * Lookup a method.  This code implements the method lookup
     * mechanism specified in JLS 15.11.2.
     *
     * This mechanism cannot be used to lookup synthetic methods.
     */
    public MemberDefinition matchMethod(Environment env,
                                        ClassDefinition accessor,
                                        Identifier methodName,
                                        Type[] argumentTypes)
        throws AmbiguousMember, ClassNotFound {

<span class="nc" id="L1084">        return matchMethod(env, accessor, methodName,</span>
                           argumentTypes, false, null);
    }

    /**
     * Lookup a method.  This code implements the method lookup
     * mechanism specified in JLS 15.11.2.
     *
     * This mechanism cannot be used to lookup synthetic methods.
     */
    public MemberDefinition matchMethod(Environment env,
                                        ClassDefinition accessor,
                                        Identifier methodName)
        throws AmbiguousMember, ClassNotFound {

<span class="nc" id="L1099">        return matchMethod(env, accessor, methodName,</span>
                           Type.noArgs, false, null);
    }

    /**
     * A version of matchMethod to be used only for constructors
     * when we cannot pass in a sourceClass argument.  We just assert
     * our package name.
     *
     * This is used only for anonymous classes, where we have to look up
     * a (potentially) protected constructor with no valid sourceClass
     * parameter available.
     */
    public MemberDefinition matchAnonConstructor(Environment env,
                                                 Identifier accessPackage,
                                                 Type argumentTypes[])
        throws AmbiguousMember, ClassNotFound {

<span class="nc" id="L1117">        return matchMethod(env, null, idInit, argumentTypes,</span>
                           true, accessPackage);
    }

    /**
     * Find a method, ie: exact match in this class or any of the super
     * classes.
     *
     * Only called by javadoc.  For now I am holding off rewriting this
     * code to rely on collectInheritedMethods(), as that code has
     * not gotten along with javadoc in the past.
     */
    public MemberDefinition findMethod(Environment env, Identifier nm, Type t)
    throws ClassNotFound {
        // look in the current class
        MemberDefinition f;
<span class="nc bnc" id="L1133" title="All 2 branches missed.">        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</span>
            // Note that non-method types return false for equalArguments().
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (f.getType().equalArguments(t)) {</span>
<span class="nc" id="L1136">                return f;</span>
            }
        }

        // constructors are not inherited
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (nm.equals(idInit)) {</span>
<span class="nc" id="L1142">            return null;</span>
        }

        // look in the super class
<span class="nc" id="L1146">        ClassDeclaration sup = getSuperClass();</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (sup == null)</span>
<span class="nc" id="L1148">            return null;</span>

<span class="nc" id="L1150">        return sup.getClassDefinition(env).findMethod(env, nm, t);</span>
    }

    // We create a stub for this.  Source classes do more work.
    protected void basicCheck(Environment env) throws ClassNotFound {
        // Do the outer class first.
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (outerClass != null)</span>
<span class="nc" id="L1157">            outerClass.basicCheck(env);</span>
<span class="nc" id="L1158">    }</span>

    /**
     * Check this class.
     */
    public void check(Environment env) throws ClassNotFound {
<span class="nc" id="L1164">    }</span>

    public Vset checkLocalClass(Environment env, Context ctx,
                                Vset vset, ClassDefinition sup,
                                Expression args[], Type argTypes[]
                                ) throws ClassNotFound {
<span class="nc" id="L1170">        throw new CompilerError(&quot;checkLocalClass&quot;);</span>
    }

    //---------------------------------------------------------------
    // The non-synthetic methods defined in this class or in any
    // of its parents (class or interface).  This member is used
    // to cache work done in collectInheritedMethods for use by
    // getMethods() and matchMethod().  It should be accessed by
    // no other method without forethought.
<span class="nc" id="L1179">    MethodSet allMethods = null;</span>

    // One of our superclasses may contain an abstract method which
    // we are unable to ever implement.  This happens when there is
    // a package-private abstract method in our parent and we are in
    // a different package than our parent.  In these cases, we
    // keep a list of the &quot;permanently abstract&quot; or &quot;unimplementable&quot;
    // methods so that we can correctly detect that this class is
    // indeed abstract and so that we can give somewhat comprehensible
    // error messages.
<span class="nc" id="L1189">    private List permanentlyAbstractMethods = new ArrayList();</span>

    /**
     * This method returns an Iterator of all abstract methods
     * in our superclasses which we are unable to implement.
     */
    protected Iterator getPermanentlyAbstractMethods() {
        // This method can only be called after collectInheritedMethods.
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (allMethods == null) {</span>
<span class="nc" id="L1198">            throw new CompilerError(&quot;isPermanentlyAbstract() called early&quot;);</span>
        }

<span class="nc" id="L1201">        return permanentlyAbstractMethods.iterator();</span>
    }

    /**
     * A flag used by turnOffInheritanceChecks() to indicate if
     * inheritance checks are on or off.
     */
<span class="nc" id="L1208">    protected static boolean doInheritanceChecks = true;</span>

    /**
     * This is a workaround to allow javadoc to turn off certain
     * inheritance/override checks which interfere with javadoc
     * badly.  In the future it might be good to eliminate the
     * shared sources of javadoc and javac to avoid the need for this
     * sort of workaround.
     */
    public static void turnOffInheritanceChecks() {
<span class="nc" id="L1218">        doInheritanceChecks = false;</span>
<span class="nc" id="L1219">    }</span>

    /**
     * Add all of the methods declared in or above `parent' to
     * `allMethods', the set of methods in the current class.
     * `myMethods' is the set of all methods declared in this
     * class, and `mirandaMethods' is a repository for Miranda methods.
     * If mirandaMethods is null, no mirandaMethods will be
     * generated.
     *
     * For a definition of Miranda methods, see the comment above the
     * method addMirandaMethods() which occurs later in this file.
     */
    private void collectOneClass(Environment env,
                                 ClassDeclaration parent,
                                 MethodSet myMethods,
                                 MethodSet allMethods,
                                 MethodSet mirandaMethods) {

        // System.out.println(&quot;Inheriting methods from &quot; + parent);

        try {
<span class="nc" id="L1241">            ClassDefinition pClass = parent.getClassDefinition(env);</span>
<span class="nc" id="L1242">            Iterator methods = pClass.getMethods(env);</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            while (methods.hasNext()) {</span>
<span class="nc" id="L1244">                MemberDefinition method =</span>
<span class="nc" id="L1245">                    (MemberDefinition) methods.next();</span>

                // Private methods are not inherited.
                //
                // Constructors are not inherited.
                //
                // Any non-abstract methods in an interface come
                // from java.lang.Object.  This means that they
                // should have already been added to allMethods
                // when we walked our superclass lineage.
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                if (method.isPrivate() ||</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                    method.isConstructor() ||</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">                    (pClass.isInterface() &amp;&amp; !method.isAbstract())) {</span>

<span class="nc" id="L1259">                    continue;</span>
                }

                // Get the components of the methods' signature.
<span class="nc" id="L1263">                Identifier name = method.getName();</span>
<span class="nc" id="L1264">                Type type = method.getType();</span>

                // Check for a method of the same signature which
                // was locally declared.
<span class="nc" id="L1268">                MemberDefinition override =</span>
<span class="nc" id="L1269">                    myMethods.lookupSig(name, type);</span>

                // Is this method inaccessible due to package-private
                // visibility?
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                if (method.isPackagePrivate() &amp;&amp;</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">                    !inSamePackage(method.getClassDeclaration())) {</span>

<span class="nc bnc" id="L1276" title="All 4 branches missed.">                    if (override != null &amp;&amp; this instanceof</span>
                        sun.tools.javac.SourceClass) {
                        // We give a warning when a class shadows an
                        // inaccessible package-private method from
                        // its superclass.  This warning is meant
                        // to prevent people from relying on overriding
                        // when it does not happen.  This warning should
                        // probably be removed to be consistent with the
                        // general &quot;no warnings&quot; policy of this
                        // compiler.
                        //
                        // The `instanceof' above is a hack so that only
                        // SourceClass generates this warning, not a
                        // BinaryClass, for example.
<span class="nc" id="L1290">                        env.error(method.getWhere(),</span>
                                  &quot;warn.no.override.access&quot;,
                                  override,
<span class="nc" id="L1293">                                  override.getClassDeclaration(),</span>
<span class="nc" id="L1294">                                  method.getClassDeclaration());</span>
                    }

                    // If our superclass has a package-private abstract
                    // method that we have no access to, then we add
                    // this method to our list of permanently abstract
                    // methods.  The idea is, since we cannot override
                    // the method, we can never make this class
                    // non-abstract.
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                    if (method.isAbstract()) {</span>
<span class="nc" id="L1304">                        permanentlyAbstractMethods.add(method);</span>
                    }

                    // `method' is inaccessible.  We do not inherit it.
                    continue;
                }

<span class="nc bnc" id="L1311" title="All 2 branches missed.">                if (override != null) {</span>
                    // `method' and `override' have the same signature.
                    // We are required to check that `override' is a
                    // legal override of `method'

                    //System.out.println (&quot;About to check override of &quot; +
                    //              method);

<span class="nc" id="L1319">                    override.checkOverride(env, method);</span>
                } else {
                    // In the absence of a definition in the class
                    // itself, we check to see if this definition
                    // can be successfully merged with any other
                    // inherited definitions.

                    // Have we added a member of the same signature
                    // to `allMethods' already?
<span class="nc" id="L1328">                    MemberDefinition formerMethod =</span>
<span class="nc" id="L1329">                        allMethods.lookupSig(name, type);</span>

                    // If the previous definition is nonexistent or
                    // ignorable, replace it.
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                    if (formerMethod == null) {</span>
                        //System.out.println(&quot;Added &quot; + method + &quot; to &quot; +
                        //             this);

<span class="nc bnc" id="L1337" title="All 2 branches missed.">                        if (mirandaMethods != null &amp;&amp;</span>
<span class="nc bnc" id="L1338" title="All 4 branches missed.">                            pClass.isInterface() &amp;&amp; !isInterface()) {</span>
                            // Whenever a class inherits a method
                            // from an interface, that method is
                            // one of our &quot;miranda&quot; methods.  Early
                            // VMs require that these methods be
                            // added as true members to the class
                            // to enable method lookup to work in the
                            // VM.
<span class="nc" id="L1346">                            method =</span>
                                new sun.tools.javac.SourceMember(method,this,
                                                                 env);
<span class="nc" id="L1349">                            mirandaMethods.add(method);</span>

                            //System.out.println(&quot;Added &quot; + method +
                            // &quot; to &quot; + this + &quot; as a Miranda&quot;);
                        }

                        // There is no previous inherited definition.
                        // Add `method' to `allMethods'.
<span class="nc" id="L1357">                        allMethods.add(method);</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">                    } else if (isInterface() &amp;&amp;</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">                               !formerMethod.isAbstract() &amp;&amp;</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                               method.isAbstract()) {</span>
                        // If we are in an interface and we have inherited
                        // both an abstract method and a non-abstract method
                        // then we know that the non-abstract method is
                        // a placeholder from Object put in for type checking
                        // and the abstract method was already checked to
                        // be proper by our superinterface.
<span class="nc" id="L1367">                        allMethods.replace(method);</span>

                    } else {
                        // Okay, `formerMethod' and `method' both have the
                        // same signature.  See if they are compatible.

                        //System.out.println (&quot;About to check meet of &quot; +
                        //              method);

<span class="nc bnc" id="L1376" title="All 2 branches missed.">                        if (!formerMethod.checkMeet(env,</span>
                                           method,
<span class="nc" id="L1378">                                           this.getClassDeclaration())) {</span>
                                // The methods are incompatible.  Skip to
                                // next method.
<span class="nc" id="L1381">                            continue;</span>
                        }

<span class="nc bnc" id="L1384" title="All 2 branches missed.">                        if (formerMethod.couldOverride(env, method)) {</span>
                                // Do nothing.  The current definition
                                // is specific enough.

                                //System.out.println(&quot;trivial meet of &quot; +
                                //                 method);
<span class="nc" id="L1390">                            continue;</span>
                        }

<span class="nc bnc" id="L1393" title="All 2 branches missed.">                        if (method.couldOverride(env, formerMethod)) {</span>
                                // `method' is more specific than
                                // `formerMethod'.  replace `formerMethod'.

                                //System.out.println(&quot;new def of &quot; + method);
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                            if (mirandaMethods != null &amp;&amp;</span>
<span class="nc bnc" id="L1399" title="All 4 branches missed.">                                pClass.isInterface() &amp;&amp; !isInterface()) {</span>
                                // Whenever a class inherits a method
                                // from an interface, that method is
                                // one of our &quot;miranda&quot; methods.  Early
                                // VMs require that these methods be
                                // added as true members to the class
                                // to enable method lookup to work in the
                                // VM.
<span class="nc" id="L1407">                                method =</span>
                                    new sun.tools.javac.SourceMember(method,
                                                                     this,env);

<span class="nc" id="L1411">                                mirandaMethods.replace(method);</span>

                                //System.out.println(&quot;Added &quot; + method +
                                // &quot; to &quot; + this + &quot; as a Miranda&quot;);
                            }

<span class="nc" id="L1417">                            allMethods.replace(method);</span>

<span class="nc" id="L1419">                            continue;</span>
                        }

                        // Neither method is more specific than the other.
                        // Oh well.  We need to construct a nontrivial
                        // meet of the two methods.
                        //
                        // This is not yet implemented, so we give
                        // a message with a helpful workaround.
<span class="nc" id="L1428">                        env.error(this.where,</span>
                                  &quot;nontrivial.meet&quot;, method,
<span class="nc" id="L1430">                                  formerMethod.getClassDefinition(),</span>
<span class="nc" id="L1431">                                  method.getClassDeclaration()</span>
                                  );
                    }
                }
<span class="nc" id="L1435">            }</span>
<span class="nc" id="L1436">        } catch (ClassNotFound ee) {</span>
<span class="nc" id="L1437">            env.error(getWhere(), &quot;class.not.found&quot;, ee.name, this);</span>
<span class="nc" id="L1438">        }</span>
<span class="nc" id="L1439">    }</span>

    /**
     * &lt;p&gt;Collect all methods defined in this class or inherited from
     * any of our superclasses or interfaces.  Look for any
     * incompatible definitions.
     *
     * &lt;p&gt;This function is also responsible for collecting the
     * &lt;em&gt;Miranda&lt;/em&gt; methods for a class.  For a definition of
     * Miranda methods, see the comment in addMirandaMethods()
     * below.
     */
    protected void collectInheritedMethods(Environment env) {
        // The methods defined in this class.
        MethodSet myMethods;
        MethodSet mirandaMethods;

        //System.out.println(&quot;Called collectInheritedMethods() for &quot; +
        //                 this);

<span class="nc bnc" id="L1459" title="All 2 branches missed.">        if (allMethods != null) {</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">            if (allMethods.isFrozen()) {</span>
                // We have already done the collection.  No need to
                // do it again.
<span class="nc" id="L1463">                return;</span>
            } else {
                // We have run into a circular need to collect our methods.
                // This should not happen at this stage.
<span class="nc" id="L1467">                throw new CompilerError(&quot;collectInheritedMethods()&quot;);</span>
            }
        }

<span class="nc" id="L1471">        myMethods = new MethodSet();</span>
<span class="nc" id="L1472">        allMethods = new MethodSet();</span>

        // For testing, do not generate miranda methods.
<span class="nc bnc" id="L1475" title="All 2 branches missed.">        if (env.version12()) {</span>
<span class="nc" id="L1476">            mirandaMethods = null;</span>
        } else {
<span class="nc" id="L1478">            mirandaMethods = new MethodSet();</span>
        }

        // Any methods defined in the current class get added
        // to both the myMethods and the allMethods MethodSets.

<span class="nc" id="L1484">        for (MemberDefinition member = getFirstMember();</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">             member != null;</span>
<span class="nc" id="L1486">             member = member.nextMember) {</span>

            // We only collect methods.  Initializers are not relevant.
<span class="nc bnc" id="L1489" title="All 2 branches missed.">            if (member.isMethod() &amp;&amp;</span>
<span class="nc bnc" id="L1490" title="All 2 branches missed.">                !member.isInitializer()) {</span>

                //System.out.println(&quot;Declared in &quot; + this + &quot;, &quot; + member);

                ////////////////////////////////////////////////////////////
                // PCJ 2003-07-30 modified the following code because with
                // the covariant return type feature of the 1.5 compiler,
                // there might be multiple methods with the same signature
                // but different return types, and MethodSet doesn't
                // support that.  We use a new utility method that attempts
                // to ensure that the appropriate method winds up in the
                // MethodSet.  See 4892308.
                ////////////////////////////////////////////////////////////
                // myMethods.add(member);
                // allMethods.add(member);
                ////////////////////////////////////////////////////////////
<span class="nc" id="L1506">                methodSetAdd(env, myMethods, member);</span>
<span class="nc" id="L1507">                methodSetAdd(env, allMethods, member);</span>
                ////////////////////////////////////////////////////////////
            }
        }

        // We're ready to start adding inherited methods.  First add
        // the methods from our superclass.

        //System.out.println(&quot;About to start superclasses for &quot; + this);

<span class="nc" id="L1517">        ClassDeclaration scDecl = getSuperClass(env);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">        if (scDecl != null) {</span>
<span class="nc" id="L1519">            collectOneClass(env, scDecl,</span>
                            myMethods, allMethods, mirandaMethods);

            // Make sure that we add all unimplementable methods from our
            // superclass to our list of unimplementable methods.
<span class="nc" id="L1524">            ClassDefinition sc = scDecl.getClassDefinition();</span>
<span class="nc" id="L1525">            Iterator supIter = sc.getPermanentlyAbstractMethods();</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">            while (supIter.hasNext()) {</span>
<span class="nc" id="L1527">                permanentlyAbstractMethods.add(supIter.next());</span>
            }
        }

        // Now we inherit all of the methods from our interfaces.

        //System.out.println(&quot;About to start interfaces for &quot; + this);

<span class="nc bnc" id="L1535" title="All 2 branches missed.">        for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L1536">            collectOneClass(env, interfaces[i],</span>
                            myMethods, allMethods, mirandaMethods);
        }
<span class="nc" id="L1539">        allMethods.freeze();</span>

        // Now we have collected all of our methods from our superclasses
        // and interfaces into our `allMethods' member.  Good.  As a last
        // task, we add our collected miranda methods to this class.
        //
        // If we do not add the mirandas to the class explicitly, there
        // will be no code generated for them.
<span class="nc bnc" id="L1547" title="All 4 branches missed.">        if (mirandaMethods != null &amp;&amp; mirandaMethods.size() &gt; 0) {</span>
<span class="nc" id="L1548">            addMirandaMethods(env, mirandaMethods.iterator());</span>
        }
<span class="nc" id="L1550">    }</span>

    ////////////////////////////////////////////////////////////
    // PCJ 2003-07-30 added this utility method to insulate
    // MethodSet additions from the covariant return type
    // feature of the 1.5 compiler.  When there are multiple
    // methods with the same signature and different return
    // types to be added, we try to ensure that the one with
    // the most specific return type winds up in the MethodSet.
    // This logic was not put into MethodSet itself because it
    // requires access to an Environment for type relationship
    // checking.  No error checking is performed here, but that
    // should be OK because this code is only still used by
    // rmic.  See 4892308.
    ////////////////////////////////////////////////////////////
    private static void methodSetAdd(Environment env,
                                     MethodSet methodSet,
                                     MemberDefinition newMethod)
    {
<span class="nc" id="L1569">        MemberDefinition oldMethod = methodSet.lookupSig(newMethod.getName(),</span>
<span class="nc" id="L1570">                                                         newMethod.getType());</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        if (oldMethod != null) {</span>
<span class="nc" id="L1572">            Type oldReturnType = oldMethod.getType().getReturnType();</span>
<span class="nc" id="L1573">            Type newReturnType = newMethod.getType().getReturnType();</span>
            try {
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                if (env.isMoreSpecific(newReturnType, oldReturnType)) {</span>
<span class="nc" id="L1576">                    methodSet.replace(newMethod);</span>
                }
<span class="nc" id="L1578">            } catch (ClassNotFound ignore) {</span>
<span class="nc" id="L1579">            }</span>
<span class="nc" id="L1580">        } else {</span>
<span class="nc" id="L1581">            methodSet.add(newMethod);</span>
        }
<span class="nc" id="L1583">    }</span>
    ////////////////////////////////////////////////////////////

    /**
     * Get an Iterator of all methods which could be accessed in an
     * instance of this class.
     */
    public Iterator getMethods(Environment env) {
<span class="nc bnc" id="L1591" title="All 2 branches missed.">        if (allMethods == null) {</span>
<span class="nc" id="L1592">            collectInheritedMethods(env);</span>
        }
<span class="nc" id="L1594">        return getMethods();</span>
    }

    /**
     * Get an Iterator of all methods which could be accessed in an
     * instance of this class.  Throw a compiler error if we haven't
     * generated this information yet.
     */
    public Iterator getMethods() {
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        if (allMethods == null) {</span>
<span class="nc" id="L1604">            throw new CompilerError(&quot;getMethods: too early&quot;);</span>
        }
<span class="nc" id="L1606">        return allMethods.iterator();</span>
    }

    // In early VM's there was a bug -- the VM didn't walk the interfaces
    // of a class looking for a method, they only walked the superclass
    // chain.  This meant that abstract methods defined only in interfaces
    // were not being found.  To fix this bug, a counter-bug was introduced
    // in the compiler -- the so-called Miranda methods.  If a class
    // does not provide a definition for an abstract method in one of
    // its interfaces then the compiler inserts one in the class artificially.
    // That way the VM didn't have to bother looking at the interfaces.
    //
    // This is a problem.  Miranda methods are not part of the specification.
    // But they continue to be inserted so that old VM's can run new code.
    // Someday, when the old VM's are gone, perhaps classes can be compiled
    // without Miranda methods.  Towards this end, the compiler has a
    // flag, -nomiranda, which can turn off the creation of these methods.
    // Eventually that behavior should become the default.
    //
    // Why are they called Miranda methods?  Well the sentence &quot;If the
    // class is not able to provide a method, then one will be provided
    // by the compiler&quot; is very similar to the sentence &quot;If you cannot
    // afford an attorney, one will be provided by the court,&quot; -- one
    // of the so-called &quot;Miranda&quot; rights in the United States.

    /**
     * Add a list of methods to this class as miranda methods.  This
     * gets overridden with a meaningful implementation in SourceClass.
     * BinaryClass should not need to do anything -- it should already
     * have its miranda methods and, if it doesn't, then that doesn't
     * affect our compilation.
     */
    protected void addMirandaMethods(Environment env,
                                     Iterator mirandas) {
        // do nothing.
<span class="nc" id="L1641">    }</span>

    //---------------------------------------------------------------

    public void inlineLocalClass(Environment env) {
<span class="nc" id="L1646">    }</span>

    /**
     * We create a stub for this.  Source classes do more work.
     * Some calls from 'SourceClass.checkSupers' execute this method.
     * @see sun.tools.javac.SourceClass#resolveTypeStructure
     */

    public void resolveTypeStructure(Environment env) {
<span class="nc" id="L1655">    }</span>

    /**
     * Look up an inner class name, from somewhere inside this class.
     * Since supers and outers are in scope, search them too.
     * &lt;p&gt;
     * If no inner class is found, env.resolveName() is then called,
     * to interpret the ambient package and import directives.
     * &lt;p&gt;
     * This routine operates on a &quot;best-efforts&quot; basis.  If
     * at some point a class is not found, the partially-resolved
     * identifier is returned.  Eventually, someone else has to
     * try to get the ClassDefinition and diagnose the ClassNotFound.
     * &lt;p&gt;
     * resolveName() looks at surrounding scopes, and hence
     * pulling in both inherited and uplevel types.  By contrast,
     * resolveInnerClass() is intended only for interpreting
     * explicitly qualified names, and so look only at inherited
     * types.  Also, resolveName() looks for package prefixes,
     * which appear similar to &quot;very uplevel&quot; outer classes.
     * &lt;p&gt;
     * A similar (but more complex) name-lookup process happens
     * when field and identifier expressions denoting qualified names
     * are type-checked.  The added complexity comes from the fact
     * that variables may occur in such names, and take precedence
     * over class and package names.
     * &lt;p&gt;
     * In the expression type-checker, resolveInnerClass() is paralleled
     * by code in FieldExpression.checkAmbigName(), which also calls
     * ClassDefinition.getInnerClass() to interpret names of the form
     * &quot;OuterClass.Inner&quot; (and also outerObject.Inner).  The checking
     * of an identifier expression that fails to be a variable is referred
     * directly to resolveName().
     */
    public Identifier resolveName(Environment env, Identifier name) {
<span class="nc" id="L1690">        if (tracing) env.dtEvent(&quot;ClassDefinition.resolveName: &quot; + name);</span>
        // This logic is pretty much exactly parallel to that of
        // Environment.resolveName().
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        if (name.isQualified()) {</span>
            // Try to resolve the first identifier component,
            // because inner class names take precedence over
            // package prefixes.  (Cf. Environment.resolveName.)
<span class="nc" id="L1697">            Identifier rhead = resolveName(env, name.getHead());</span>

<span class="nc bnc" id="L1699" title="All 2 branches missed.">            if (rhead.hasAmbigPrefix()) {</span>
                // The first identifier component refers to an
                // ambiguous class.  Limp on.  We throw away the
                // rest of the classname as it is irrelevant.
                // (part of solution for 4059855).
<span class="nc" id="L1704">                return rhead;</span>
            }

<span class="nc bnc" id="L1707" title="All 2 branches missed.">            if (!env.classExists(rhead)) {</span>
<span class="nc" id="L1708">                return env.resolvePackageQualifiedName(name);</span>
            }
            try {
<span class="nc" id="L1711">                return env.getClassDefinition(rhead).</span>
<span class="nc" id="L1712">                    resolveInnerClass(env, name.getTail());</span>
<span class="nc" id="L1713">            } catch (ClassNotFound ee) {</span>
                // return partially-resolved name someone else can fail on
<span class="nc" id="L1715">                return Identifier.lookupInner(rhead, name.getTail());</span>
            }
        }

        // This method used to fail to look for local classes, thus a
        // reference to a local class within, e.g., the type of a member
        // declaration, would fail to resolve if the immediately enclosing
        // context was an inner class.  The code added below is ugly, but
        // it works, and is lifted from existing code in 'Context.resolveName'
        // and 'Context.getClassCommon'. See the comments there about the design.
        // Fixes 4095716.

<span class="nc" id="L1727">        int ls = -2;</span>
<span class="nc" id="L1728">        LocalMember lf = null;</span>
<span class="nc bnc" id="L1729" title="All 2 branches missed.">        if (classContext != null) {</span>
<span class="nc" id="L1730">            lf = classContext.getLocalClass(name);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            if (lf != null) {</span>
<span class="nc" id="L1732">                ls = lf.getScopeNumber();</span>
            }
        }

        // Look for an unqualified name in enclosing scopes.
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        for (ClassDefinition c = this; c != null; c = c.outerClass) {</span>
            try {
<span class="nc" id="L1739">                MemberDefinition f = c.getInnerClass(env, name);</span>
<span class="nc bnc" id="L1740" title="All 4 branches missed.">                if (f != null &amp;&amp;</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">                    (lf == null || classContext.getScopeNumber(c) &gt; ls)) {</span>
                    // An uplevel member was found, and was nested more deeply than
                    // any enclosing local of the same name.
<span class="nc" id="L1744">                    return f.getInnerClass().getName();</span>
                }
<span class="nc" id="L1746">            } catch (ClassNotFound ee) {</span>
                // a missing superclass, or something catastrophic
<span class="nc" id="L1748">            }</span>
        }

        // No uplevel member found, so use the enclosing local if one was found.
<span class="nc bnc" id="L1752" title="All 2 branches missed.">        if (lf != null) {</span>
<span class="nc" id="L1753">           return lf.getInnerClass().getName();</span>
        }

        // look in imports, etc.
<span class="nc" id="L1757">        return env.resolveName(name);</span>
    }

    /**
     * Interpret a qualified class name, which may have further subcomponents..
     * Follow inheritance links, as in:
     *  class C { class N { } }  class D extends C { }  ... new D.N() ...
     * Ignore outer scopes and packages.
     * @see resolveName
     */
    public Identifier resolveInnerClass(Environment env, Identifier nm) {
<span class="nc bnc" id="L1768" title="All 2 branches missed.">        if (nm.isInner())  throw new CompilerError(&quot;inner&quot;);</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">        if (nm.isQualified()) {</span>
<span class="nc" id="L1770">            Identifier rhead = resolveInnerClass(env, nm.getHead());</span>
            try {
<span class="nc" id="L1772">                return env.getClassDefinition(rhead).</span>
<span class="nc" id="L1773">                    resolveInnerClass(env, nm.getTail());</span>
<span class="nc" id="L1774">            } catch (ClassNotFound ee) {</span>
                // return partially-resolved name someone else can fail on
<span class="nc" id="L1776">                return Identifier.lookupInner(rhead, nm.getTail());</span>
            }
        } else {
            try {
<span class="nc" id="L1780">                MemberDefinition f = getInnerClass(env, nm);</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">                if (f != null) {</span>
<span class="nc" id="L1782">                    return f.getInnerClass().getName();</span>
                }
<span class="nc" id="L1784">            } catch (ClassNotFound ee) {</span>
                // a missing superclass, or something catastrophic
<span class="nc" id="L1786">            }</span>
            // Fake a good name for a diagnostic.
<span class="nc" id="L1788">            return Identifier.lookupInner(this.getName(), nm);</span>
        }
    }

    /**
     * While resolving import directives, the question has arisen:
     * does a given inner class exist?  If the top-level class exists,
     * we ask it about an inner class via this method.
     * This method looks only at the literal name of the class,
     * and does not attempt to follow inheritance links.
     * This is necessary, since at the time imports are being
     * processed, inheritance links have not been resolved yet.
     * (Thus, an import directive must always spell a class
     * name exactly.)
     */
    public boolean innerClassExists(Identifier nm) {
<span class="nc bnc" id="L1804" title="All 2 branches missed.">        for (MemberDefinition field = getFirstMatch(nm.getHead()) ; field != null ; field = field.getNextMatch()) {</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">            if (field.isInnerClass()) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">                if (field.getInnerClass().isLocal()) {</span>
<span class="nc" id="L1807">                    continue;   // ignore this name; it is internally generated</span>
                }
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                return !nm.isQualified() ||</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">                    field.getInnerClass().innerClassExists(nm.getTail());</span>
            }
        }
<span class="nc" id="L1813">        return false;</span>
    }

   /**
     * Find any method with a given name.
     */
    public MemberDefinition findAnyMethod(Environment env, Identifier nm) throws ClassNotFound {
        MemberDefinition f;
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            if (f.isMethod()) {</span>
<span class="nc" id="L1823">                return f;</span>
            }
        }

        // look in the super class
<span class="nc" id="L1828">        ClassDeclaration sup = getSuperClass();</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">        if (sup == null)</span>
<span class="nc" id="L1830">            return null;</span>
<span class="nc" id="L1831">        return sup.getClassDefinition(env).findAnyMethod(env, nm);</span>
    }

    /**
      * Given the fact that this class has no method &quot;nm&quot; matching &quot;argTypes&quot;,
      * find out if the mismatch can be blamed on a particular actual argument
      * which disagrees with all of the overloadings.
      * If so, return the code (i&lt;&lt;2)+(castOK&lt;&lt;1)+ambig, where
      * &quot;i&quot; is the number of the offending argument, and
      * &quot;castOK&quot; is 1 if a cast could fix the problem.
      * The target type for the argument is returned in margTypeResult[0].
      * If not all methods agree on this type, &quot;ambig&quot; is 1.
      * If there is more than one method, the choice of target type is
      * arbitrary.&lt;p&gt;
      * Return -1 if every argument is acceptable to at least one method.
      * Return -2 if there are no methods of the required arity.
      * The value &quot;start&quot; gives the index of the first argument to begin
      * checking.
      */
    public int diagnoseMismatch(Environment env, Identifier nm, Type argTypes[],
                                int start, Type margTypeResult[]) throws ClassNotFound {
<span class="nc" id="L1852">        int haveMatch[] = new int[argTypes.length];</span>
<span class="nc" id="L1853">        Type margType[] = new Type[argTypes.length];</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">        if (!diagnoseMismatch(env, nm, argTypes, start, haveMatch, margType))</span>
<span class="nc" id="L1855">            return -2;</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">        for (int i = start; i &lt; argTypes.length; i++) {</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">            if (haveMatch[i] &lt; 4) {</span>
<span class="nc" id="L1858">                margTypeResult[0] = margType[i];</span>
<span class="nc" id="L1859">                return (i&lt;&lt;2) | haveMatch[i];</span>
            }
        }
<span class="nc" id="L1862">        return -1;</span>
    }

    private boolean diagnoseMismatch(Environment env, Identifier nm, Type argTypes[], int start,
                                     int haveMatch[], Type margType[]) throws ClassNotFound {
        // look in the current class
<span class="nc" id="L1868">        boolean haveOne = false;</span>
        MemberDefinition f;
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            if (!f.isMethod()) {</span>
<span class="nc" id="L1872">                continue;</span>
            }
<span class="nc" id="L1874">            Type fArgTypes[] = f.getType().getArgumentTypes();</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">            if (fArgTypes.length == argTypes.length) {</span>
<span class="nc" id="L1876">                haveOne = true;</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                for (int i = start; i &lt; argTypes.length; i++) {</span>
<span class="nc" id="L1878">                    Type at = argTypes[i];</span>
<span class="nc" id="L1879">                    Type ft = fArgTypes[i];</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">                    if (env.implicitCast(at, ft)) {</span>
<span class="nc" id="L1881">                        haveMatch[i] = 4;</span>
<span class="nc" id="L1882">                        continue;</span>
<span class="nc bnc" id="L1883" title="All 4 branches missed.">                    } else if (haveMatch[i] &lt;= 2 &amp;&amp; env.explicitCast(at, ft)) {</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">                        if (haveMatch[i] &lt; 2)  margType[i] = null;</span>
<span class="nc" id="L1885">                        haveMatch[i] = 2;</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                    } else if (haveMatch[i] &gt; 0) {</span>
<span class="nc" id="L1887">                        continue;</span>
                    }
<span class="nc bnc" id="L1889" title="All 2 branches missed.">                    if (margType[i] == null)</span>
<span class="nc" id="L1890">                        margType[i] = ft;</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">                    else if (margType[i] != ft)</span>
<span class="nc" id="L1892">                        haveMatch[i] |= 1;</span>
                }
            }
        }

        // constructors are not inherited
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (nm.equals(idInit)) {</span>
<span class="nc" id="L1899">            return haveOne;</span>
        }

        // look in the super class
<span class="nc" id="L1903">        ClassDeclaration sup = getSuperClass();</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">        if (sup != null) {</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">            if (sup.getClassDefinition(env).diagnoseMismatch(env, nm, argTypes, start,</span>
                                                             haveMatch, margType))
<span class="nc" id="L1907">                haveOne = true;</span>
        }
<span class="nc" id="L1909">        return haveOne;</span>
    }

    /**
     * Add a field (no checks)
     */
    public void addMember(MemberDefinition field) {
        //System.out.println(&quot;ADD = &quot; + field);
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (firstMember == null) {</span>
<span class="nc" id="L1918">            firstMember = lastMember = field;</span>
<span class="nc bnc" id="L1919" title="All 4 branches missed.">        } else if (field.isSynthetic() &amp;&amp; field.isFinal()</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">                                       &amp;&amp; field.isVariable()) {</span>
            // insert this at the front, because of initialization order
<span class="nc" id="L1922">            field.nextMember = firstMember;</span>
<span class="nc" id="L1923">            firstMember = field;</span>
<span class="nc" id="L1924">            field.nextMatch = (MemberDefinition)fieldHash.get(field.name);</span>
        } else {
<span class="nc" id="L1926">            lastMember.nextMember = field;</span>
<span class="nc" id="L1927">            lastMember = field;</span>
<span class="nc" id="L1928">            field.nextMatch = (MemberDefinition)fieldHash.get(field.name);</span>
        }
<span class="nc" id="L1930">        fieldHash.put(field.name, field);</span>
<span class="nc" id="L1931">    }</span>

    /**
     * Add a field (subclasses make checks)
     */
    public void addMember(Environment env, MemberDefinition field) {
<span class="nc" id="L1937">        addMember(field);</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">        if (resolved) {</span>
            // a late addition
<span class="nc" id="L1940">            field.resolveTypeStructure(env);</span>
        }
<span class="nc" id="L1942">    }</span>

    /**
     * Find or create an uplevel reference for the given target.
     */
    public UplevelReference getReference(LocalMember target) {
<span class="nc bnc" id="L1948" title="All 2 branches missed.">        for (UplevelReference r = references; r != null; r = r.getNext()) {</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">            if (r.getTarget() == target) {</span>
<span class="nc" id="L1950">                return r;</span>
            }
        }
<span class="nc" id="L1953">        return addReference(target);</span>
    }

    protected UplevelReference addReference(LocalMember target) {
<span class="nc bnc" id="L1957" title="All 2 branches missed.">        if (target.getClassDefinition() == this) {</span>
<span class="nc" id="L1958">            throw new CompilerError(&quot;addReference &quot;+target);</span>
        }
<span class="nc" id="L1960">        referencesMustNotBeFrozen();</span>
<span class="nc" id="L1961">        UplevelReference r = new UplevelReference(this, target);</span>
<span class="nc" id="L1962">        references = r.insertInto(references);</span>
<span class="nc" id="L1963">        return r;</span>
    }

    /**
     * Return the list of all uplevel references.
     */
    public UplevelReference getReferences() {
<span class="nc" id="L1970">        return references;</span>
    }

    /**
     * Return the same value as getReferences.
     * Also, mark the set of references frozen.
     * After that, it is an error to add new references.
     */
    public UplevelReference getReferencesFrozen() {
<span class="nc" id="L1979">        referencesFrozen = true;</span>
<span class="nc" id="L1980">        return references;</span>
    }

    /**
     * assertion check
     */
    public final void referencesMustNotBeFrozen() {
<span class="nc bnc" id="L1987" title="All 2 branches missed.">        if (referencesFrozen) {</span>
<span class="nc" id="L1988">            throw new CompilerError(&quot;referencesMustNotBeFrozen &quot;+this);</span>
        }
<span class="nc" id="L1990">    }</span>

    /**
     * Get helper method for class literal lookup.
     */
    public MemberDefinition getClassLiteralLookup(long fwhere) {
<span class="nc" id="L1996">        throw new CompilerError(&quot;binary class&quot;);</span>
    }

    /**
     * Add a dependency
     */
    public void addDependency(ClassDeclaration c) {
<span class="nc" id="L2003">        throw new CompilerError(&quot;addDependency&quot;);</span>
    }

    /**
     * Maintain a hash table of local and anonymous classes
     * whose internal names are prefixed by the current class.
     * The key is the simple internal name, less the prefix.
     */

    public ClassDefinition getLocalClass(String name) {
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        if (localClasses == null) {</span>
<span class="nc" id="L2014">            return null;</span>
        } else {
<span class="nc" id="L2016">            return (ClassDefinition)localClasses.get(name);</span>
        }
    }

    public void addLocalClass(ClassDefinition c, String name) {
<span class="nc bnc" id="L2021" title="All 2 branches missed.">        if (localClasses == null) {</span>
<span class="nc" id="L2022">            localClasses = new Hashtable(LOCAL_CLASSES_SIZE);</span>
        }
<span class="nc" id="L2024">        localClasses.put(name, c);</span>
<span class="nc" id="L2025">    }</span>


    /**
     * Print for debugging
     */
    public void print(PrintStream out) {
<span class="nc bnc" id="L2032" title="All 2 branches missed.">        if (isPublic()) {</span>
<span class="nc" id="L2033">            out.print(&quot;public &quot;);</span>
        }
<span class="nc bnc" id="L2035" title="All 2 branches missed.">        if (isInterface()) {</span>
<span class="nc" id="L2036">            out.print(&quot;interface &quot;);</span>
        } else {
<span class="nc" id="L2038">            out.print(&quot;class &quot;);</span>
        }
<span class="nc" id="L2040">        out.print(getName() + &quot; &quot;);</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">        if (getSuperClass() != null) {</span>
<span class="nc" id="L2042">            out.print(&quot;extends &quot; + getSuperClass().getName() + &quot; &quot;);</span>
        }
<span class="nc bnc" id="L2044" title="All 2 branches missed.">        if (interfaces.length &gt; 0) {</span>
<span class="nc" id="L2045">            out.print(&quot;implements &quot;);</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">            for (int i = 0 ; i &lt; interfaces.length ; i++) {</span>
<span class="nc bnc" id="L2047" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L2048">                    out.print(&quot;, &quot;);</span>
                }
<span class="nc" id="L2050">                out.print(interfaces[i].getName());</span>
<span class="nc" id="L2051">                out.print(&quot; &quot;);</span>
            }
        }
<span class="nc" id="L2054">        out.println(&quot;{&quot;);</span>

<span class="nc bnc" id="L2056" title="All 2 branches missed.">        for (MemberDefinition f = getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc" id="L2057">            out.print(&quot;    &quot;);</span>
<span class="nc" id="L2058">            f.print(out);</span>
        }

<span class="nc" id="L2061">        out.println(&quot;}&quot;);</span>
<span class="nc" id="L2062">    }</span>

    /**
     * Convert to String
     */
    public String toString() {
<span class="nc" id="L2068">        return getClassDeclaration().toString();</span>
    }

    /**
     * After the class has been written to disk, try to free up
     * some storage.
     */
    public void cleanup(Environment env) {
<span class="nc bnc" id="L2076" title="All 2 branches missed.">        if (env.dump()) {</span>
<span class="nc" id="L2077">            env.output(&quot;[cleanup &quot; + getName() + &quot;]&quot;);</span>
        }
<span class="nc bnc" id="L2079" title="All 2 branches missed.">        for (MemberDefinition f = getFirstMember() ; f != null ; f = f.getNextMember()) {</span>
<span class="nc" id="L2080">            f.cleanup(env);</span>
        }
        // keep &quot;references&quot; around, for the sake of local subclasses
<span class="nc" id="L2083">        documentation = null;</span>
<span class="nc" id="L2084">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>