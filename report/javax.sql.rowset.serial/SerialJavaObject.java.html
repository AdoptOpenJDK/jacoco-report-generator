<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SerialJavaObject.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.sql.rowset.serial</a> &gt; <span class="el_source">SerialJavaObject.java</span></div><h1>SerialJavaObject.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sql.rowset.serial;

import java.io.*;
import java.lang.reflect.*;
import java.util.Arrays;
import java.util.Vector;
import javax.sql.rowset.RowSetWarning;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.reflect.misc.ReflectUtil;

/**
 * A serializable mapping in the Java programming language of an SQL
 * &lt;code&gt;JAVA_OBJECT&lt;/code&gt; value. Assuming the Java object
 * implements the &lt;code&gt;Serializable&lt;/code&gt; interface, this class simply wraps the
 * serialization process.
 * &lt;P&gt;
 * If however, the serialization is not possible because
 * the Java object is not immediately serializable, this class will
 * attempt to serialize all non-static members to permit the object
 * state to be serialized.
 * Static or transient fields cannot be serialized; an attempt to serialize
 * them will result in a &lt;code&gt;SerialException&lt;/code&gt; object being thrown.
 *
 * &lt;h3&gt; Thread safety &lt;/h3&gt;
 *
 * A SerialJavaObject is not safe for use by multiple concurrent threads.  If a
 * SerialJavaObject is to be used by more than one thread then access to the
 * SerialJavaObject should be controlled by appropriate synchronization.
 *
 * @author Jonathan Bruce
 */
public class SerialJavaObject implements Serializable, Cloneable {

    /**
     * Placeholder for object to be serialized.
     */
    private Object obj;


   /**
    * Placeholder for all fields in the &lt;code&gt;JavaObject&lt;/code&gt; being serialized.
    */
    private transient Field[] fields;

    /**
     * Constructor for &lt;code&gt;SerialJavaObject&lt;/code&gt; helper class.
     * &lt;p&gt;
     *
     * @param obj the Java &lt;code&gt;Object&lt;/code&gt; to be serialized
     * @throws SerialException if the object is found not to be serializable
     */
<span class="nc" id="L78">    public SerialJavaObject(Object obj) throws SerialException {</span>

        // if any static fields are found, an exception
        // should be thrown


        // get Class. Object instance should always be available
<span class="nc" id="L85">        Class&lt;?&gt; c = obj.getClass();</span>

        // determine if object implements Serializable i/f
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (!(obj instanceof java.io.Serializable)) {</span>
<span class="nc" id="L89">            setWarning(new RowSetWarning(&quot;Warning, the object passed to the constructor does not implement Serializable&quot;));</span>
        }

        // can only determine public fields (obviously). If
        // any of these are static, this should invalidate
        // the action of attempting to persist these fields
        // in a serialized form
<span class="nc" id="L96">        fields = c.getFields();</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">        if (hasStaticFields(fields)) {</span>
<span class="nc" id="L99">            throw new SerialException(&quot;Located static fields in &quot; +</span>
                &quot;object instance. Cannot serialize&quot;);
        }

<span class="nc" id="L103">        this.obj = obj;</span>
<span class="nc" id="L104">    }</span>

    /**
     * Returns an &lt;code&gt;Object&lt;/code&gt; that is a copy of this &lt;code&gt;SerialJavaObject&lt;/code&gt;
     * object.
     *
     * @return a copy of this &lt;code&gt;SerialJavaObject&lt;/code&gt; object as an
     *         &lt;code&gt;Object&lt;/code&gt; in the Java programming language
     * @throws SerialException if the instance is corrupt
     */
    public Object getObject() throws SerialException {
<span class="nc" id="L115">        return this.obj;</span>
    }

    /**
     * Returns an array of &lt;code&gt;Field&lt;/code&gt; objects that contains each
     * field of the object that this helper class is serializing.
     *
     * @return an array of &lt;code&gt;Field&lt;/code&gt; objects
     * @throws SerialException if an error is encountered accessing
     * the serialized object
     * @throws  SecurityException  If a security manager, &lt;i&gt;s&lt;/i&gt;, is present
     * and the caller's class loader is not the same as or an
     * ancestor of the class loader for the class of the
     * {@linkplain #getObject object} being serialized
     * and invocation of {@link SecurityManager#checkPackageAccess
     * s.checkPackageAccess()} denies access to the package
     * of that class.
     * @see Class#getFields
     */
    @CallerSensitive
    public Field[] getFields() throws SerialException {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (fields != null) {</span>
<span class="nc" id="L137">            Class&lt;?&gt; c = this.obj.getClass();</span>
<span class="nc" id="L138">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (sm != null) {</span>
                /*
                 * Check if the caller is allowed to access the specified class's package.
                 * If access is denied, throw a SecurityException.
                 */
<span class="nc" id="L144">                Class&lt;?&gt; caller = sun.reflect.Reflection.getCallerClass();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),</span>
<span class="nc" id="L146">                                                        c.getClassLoader())) {</span>
<span class="nc" id="L147">                    ReflectUtil.checkPackageAccess(c);</span>
                }
            }
<span class="nc" id="L150">            return c.getFields();</span>
        } else {
<span class="nc" id="L152">            throw new SerialException(&quot;SerialJavaObject does not contain&quot; +</span>
                &quot; a serialized object instance&quot;);
        }
    }

    /**
     * The identifier that assists in the serialization of this
     * &lt;code&gt;SerialJavaObject&lt;/code&gt; object.
     */
    static final long serialVersionUID = -1465795139032831023L;

    /**
     * A container for the warnings issued on this &lt;code&gt;SerialJavaObject&lt;/code&gt;
     * object. When there are multiple warnings, each warning is chained to the
     * previous warning.
     */
    Vector&lt;RowSetWarning&gt; chain;

    /**
     * Compares this SerialJavaObject to the specified object.
     * The result is {@code true} if and only if the argument
     * is not {@code null} and is a {@code SerialJavaObject}
     * object that is identical to this object
     *
     * @param  o The object to compare this {@code SerialJavaObject} against
     *
     * @return  {@code true} if the given object represents a {@code SerialJavaObject}
     *          equivalent to this SerialJavaObject, {@code false} otherwise
     *
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L184">            return true;</span>
        }
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (o instanceof SerialJavaObject) {</span>
<span class="nc" id="L187">            SerialJavaObject sjo = (SerialJavaObject) o;</span>
<span class="nc" id="L188">            return obj.equals(sjo.obj);</span>
        }
<span class="nc" id="L190">        return false;</span>
    }

    /**
     * Returns a hash code for this SerialJavaObject. The hash code for a
     * {@code SerialJavaObject} object is taken as the hash code of
     * the {@code Object} it stores
     *
     * @return  a hash code value for this object.
     */
    public int hashCode() {
<span class="nc" id="L201">        return 31 + obj.hashCode();</span>
    }

    /**
     * Returns a clone of this {@code SerialJavaObject}.
     *
     * @return  a clone of this SerialJavaObject
     */

    public Object clone() {
        try {
<span class="nc" id="L212">            SerialJavaObject sjo = (SerialJavaObject) super.clone();</span>
<span class="nc" id="L213">            sjo.fields = Arrays.copyOf(fields, fields.length);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (chain != null)</span>
<span class="nc" id="L215">                sjo.chain = new Vector&lt;&gt;(chain);</span>
<span class="nc" id="L216">            return sjo;</span>
<span class="nc" id="L217">        } catch (CloneNotSupportedException ex) {</span>
            // this shouldn't happen, since we are Cloneable
<span class="nc" id="L219">            throw new InternalError();</span>
        }
    }

    /**
     * Registers the given warning.
     */
    private void setWarning(RowSetWarning e) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (chain == null) {</span>
<span class="nc" id="L228">            chain = new Vector&lt;&gt;();</span>
        }
<span class="nc" id="L230">        chain.add(e);</span>
<span class="nc" id="L231">    }</span>

    /**
     * readObject is called to restore the state of the {@code SerialJavaObject}
     * from a stream.
     */
    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {

<span class="nc" id="L240">        ObjectInputStream.GetField fields1 = s.readFields();</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L242">        Vector&lt;RowSetWarning&gt; tmp = (Vector&lt;RowSetWarning&gt;)fields1.get(&quot;chain&quot;, null);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (tmp != null)</span>
<span class="nc" id="L244">            chain = new Vector&lt;&gt;(tmp);</span>

<span class="nc" id="L246">        obj = fields1.get(&quot;obj&quot;, null);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (obj != null) {</span>
<span class="nc" id="L248">            fields = obj.getClass().getFields();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if(hasStaticFields(fields))</span>
<span class="nc" id="L250">                throw new IOException(&quot;Located static fields in &quot; +</span>
                &quot;object instance. Cannot serialize&quot;);
        } else {
<span class="nc" id="L253">            throw new IOException(&quot;Object cannot be null!&quot;);</span>
        }

<span class="nc" id="L256">    }</span>

    /**
     * writeObject is called to save the state of the {@code SerialJavaObject}
     * to a stream.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
<span class="nc" id="L264">        ObjectOutputStream.PutField fields = s.putFields();</span>
<span class="nc" id="L265">        fields.put(&quot;obj&quot;, obj);</span>
<span class="nc" id="L266">        fields.put(&quot;chain&quot;, chain);</span>
<span class="nc" id="L267">        s.writeFields();</span>
<span class="nc" id="L268">    }</span>

    /*
     * Check to see if there are any Static Fields in this object
     */
    private static boolean hasStaticFields(Field[] fields) {
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (Field field : fields) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if ( field.getModifiers() == Modifier.STATIC) {</span>
<span class="nc" id="L276">                return true;</span>
            }
        }
<span class="nc" id="L279">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>