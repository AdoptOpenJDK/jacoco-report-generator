<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DGCClient.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.transport</a> &gt; <span class="el_source">DGCClient.java</span></div><h1>DGCClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.rmi.transport;

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.rmi.ConnectException;
import java.rmi.RemoteException;
import java.rmi.dgc.DGC;
import java.rmi.dgc.Lease;
import java.rmi.dgc.VMID;
import java.rmi.server.ObjID;
import sun.misc.GC;
import sun.rmi.runtime.NewThreadAction;
import sun.rmi.server.UnicastRef;
import sun.rmi.server.Util;
import sun.security.action.GetLongAction;

/**
 * DGCClient implements the client-side of the RMI distributed garbage
 * collection system.
 *
 * The external interface to DGCClient is the &quot;registerRefs&quot; method.
 * When a LiveRef to a remote object enters the VM, it needs to be
 * registered with the DGCClient to participate in distributed garbage
 * collection.
 *
 * When the first LiveRef to a particular remote object is registered,
 * a &quot;dirty&quot; call is made to the server-side distributed garbage
 * collector for the remote object, which returns a lease guaranteeing
 * that the server-side DGC will not collect the remote object for a
 * certain period of time.  While LiveRef instances to remote objects
 * on a particular server exist, the DGCClient periodically sends more
 * &quot;dirty&quot; calls to renew its lease.
 *
 * The DGCClient tracks the local reachability of registered LiveRef
 * instances (using phantom references).  When the LiveRef instance
 * for a particular remote object becomes garbage collected locally,
 * a &quot;clean&quot; call is made to the server-side distributed garbage
 * collector, indicating that the server no longer needs to keep the
 * remote object alive for this client.
 *
 * @see java.rmi.dgc.DGC, sun.rmi.transport.DGCImpl
 *
 * @author  Ann Wollrath
 * @author  Peter Jones
 */
final class DGCClient {

    /** next sequence number for DGC calls (access synchronized on class) */
<span class="fc" id="L81">    private static long nextSequenceNum = Long.MIN_VALUE;</span>

    /** unique identifier for this VM as a client of DGC */
<span class="fc" id="L84">    private static VMID vmid = new VMID();</span>

    /** lease duration to request (usually ignored by server) */
<span class="fc" id="L87">    private static final long leaseValue =              // default 10 minutes</span>
<span class="fc" id="L88">        AccessController.doPrivileged(</span>
            new GetLongAction(&quot;java.rmi.dgc.leaseValue&quot;,
<span class="fc" id="L90">                              600000)).longValue();</span>

    /** maximum interval between retries of failed clean calls */
<span class="fc" id="L93">    private static final long cleanInterval =           // default 3 minutes</span>
<span class="fc" id="L94">        AccessController.doPrivileged(</span>
            new GetLongAction(&quot;sun.rmi.dgc.cleanInterval&quot;,
<span class="fc" id="L96">                              180000)).longValue();</span>

    /** maximum interval between complete garbage collections of local heap */
<span class="fc" id="L99">    private static final long gcInterval =              // default 1 hour</span>
<span class="fc" id="L100">        AccessController.doPrivileged(</span>
            new GetLongAction(&quot;sun.rmi.dgc.client.gcInterval&quot;,
<span class="fc" id="L102">                              3600000)).longValue();</span>

    /** minimum retry count for dirty calls that fail */
    private static final int dirtyFailureRetries = 5;

    /** retry count for clean calls that fail with ConnectException */
    private static final int cleanFailureRetries = 5;

    /** constant empty ObjID array for lease renewal optimization */
<span class="fc" id="L111">    private static final ObjID[] emptyObjIDArray = new ObjID[0];</span>

    /** ObjID for server-side DGC object */
<span class="fc" id="L114">    private static final ObjID dgcID = new ObjID(ObjID.DGC_ID);</span>

    /*
     * Disallow anyone from creating one of these.
     */
<span class="nc" id="L119">    private DGCClient() {}</span>

    /**
     * Register the LiveRef instances in the supplied list to participate
     * in distributed garbage collection.
     *
     * All of the LiveRefs in the list must be for remote objects at the
     * given endpoint.
     */
    static void registerRefs(Endpoint ep, List&lt;LiveRef&gt; refs) {
        /*
         * Look up the given endpoint and register the refs with it.
         * The retrieved entry may get removed from the global endpoint
         * table before EndpointEntry.registerRefs() is able to acquire
         * its lock; in this event, it returns false, and we loop and
         * try again.
         */
        EndpointEntry epEntry;
        do {
<span class="fc" id="L138">            epEntry = EndpointEntry.lookup(ep);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        } while (!epEntry.registerRefs(refs));</span>
<span class="fc" id="L140">    }</span>

    /**
     * Get the next sequence number to be used for a dirty or clean
     * operation from this VM.  This method should only be called while
     * synchronized on the EndpointEntry whose data structures the
     * operation affects.
     */
    private static synchronized long getNextSequenceNum() {
<span class="fc" id="L149">        return nextSequenceNum++;</span>
    }

    /**
     * Given the length of a lease and the time that it was granted,
     * compute the absolute time at which it should be renewed, giving
     * room for reasonable computational and communication delays.
     */
    private static long computeRenewTime(long grantTime, long duration) {
        /*
         * REMIND: This algorithm should be more sophisticated, waiting
         * a longer fraction of the lease duration for longer leases.
         */
<span class="fc" id="L162">        return grantTime + (duration / 2);</span>
    }

    /**
     * EndpointEntry encapsulates the client-side DGC information specific
     * to a particular Endpoint.  Of most significance is the table that
     * maps LiveRef value to RefEntry objects and the renew/clean thread
     * that handles asynchronous client-side DGC operations.
     */
<span class="fc bfc" id="L171" title="All 2 branches covered.">    private static class EndpointEntry {</span>

        /** the endpoint that this entry is for */
        private Endpoint endpoint;
        /** synthesized reference to the remote server-side DGC */
        private DGC dgc;

        /** table of refs held for endpoint: maps LiveRef to RefEntry */
<span class="fc" id="L179">        private Map&lt;LiveRef, RefEntry&gt; refTable = new HashMap&lt;&gt;(5);</span>
        /** set of RefEntry instances from last (failed) dirty call */
<span class="fc" id="L181">        private Set&lt;RefEntry&gt; invalidRefs = new HashSet&lt;&gt;(5);</span>

        /** true if this entry has been removed from the global table */
<span class="fc" id="L184">        private boolean removed = false;</span>

        /** absolute time to renew current lease to this endpoint */
<span class="fc" id="L187">        private long renewTime = Long.MAX_VALUE;</span>
        /** absolute time current lease to this endpoint will expire */
<span class="fc" id="L189">        private long expirationTime = Long.MIN_VALUE;</span>
        /** count of recent dirty calls that have failed */
<span class="fc" id="L191">        private int dirtyFailures = 0;</span>
        /** absolute time of first recent failed dirty call */
        private long dirtyFailureStartTime;
        /** (average) elapsed time for recent failed dirty calls */
        private long dirtyFailureDuration;

        /** renew/clean thread for handling lease renewals and clean calls */
        private Thread renewCleanThread;
        /** true if renew/clean thread may be interrupted */
<span class="fc" id="L200">        private boolean interruptible = false;</span>

        /** reference queue for phantom references */
<span class="fc" id="L203">        private ReferenceQueue&lt;LiveRef&gt; refQueue = new ReferenceQueue&lt;&gt;();</span>
        /** set of clean calls that need to be made */
<span class="fc" id="L205">        private Set&lt;CleanRequest&gt; pendingCleans = new HashSet&lt;&gt;(5);</span>

        /** global endpoint table: maps Endpoint to EndpointEntry */
<span class="fc" id="L208">        private static Map&lt;Endpoint,EndpointEntry&gt; endpointTable = new HashMap&lt;&gt;(5);</span>
        /** handle for GC latency request (for future cancellation) */
<span class="fc" id="L210">        private static GC.LatencyRequest gcLatencyRequest = null;</span>

        /**
         * Look up the EndpointEntry for the given Endpoint.  An entry is
         * created if one does not already exist.
         */
        public static EndpointEntry lookup(Endpoint ep) {
<span class="fc" id="L217">            synchronized (endpointTable) {</span>
<span class="fc" id="L218">                EndpointEntry entry = endpointTable.get(ep);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (entry == null) {</span>
<span class="fc" id="L220">                    entry = new EndpointEntry(ep);</span>
<span class="fc" id="L221">                    endpointTable.put(ep, entry);</span>
                    /*
                     * While we are tracking live remote references registered
                     * in this VM, request a maximum latency for inspecting the
                     * entire heap from the local garbage collector, to place
                     * an upper bound on the time to discover remote references
                     * that have become unreachable (see bugid 4171278).
                     */
<span class="fc bfc" id="L229" title="All 2 branches covered.">                    if (gcLatencyRequest == null) {</span>
<span class="fc" id="L230">                        gcLatencyRequest = GC.requestLatency(gcInterval);</span>
                    }
                }
<span class="fc" id="L233">                return entry;</span>
<span class="nc" id="L234">            }</span>
        }

<span class="fc" id="L237">        private EndpointEntry(final Endpoint endpoint) {</span>
<span class="fc" id="L238">            this.endpoint = endpoint;</span>
            try {
<span class="fc" id="L240">                LiveRef dgcRef = new LiveRef(dgcID, endpoint, false);</span>
<span class="fc" id="L241">                dgc = (DGC) Util.createProxy(DGCImpl.class,</span>
                                             new UnicastRef(dgcRef), true);
<span class="nc" id="L243">            } catch (RemoteException e) {</span>
<span class="nc" id="L244">                throw new Error(&quot;internal error creating DGC stub&quot;);</span>
<span class="fc" id="L245">            }</span>
<span class="fc" id="L246">            renewCleanThread =  AccessController.doPrivileged(</span>
                new NewThreadAction(new RenewCleanThread(),
                                    &quot;RenewClean-&quot; + endpoint, true));
<span class="fc" id="L249">            renewCleanThread.start();</span>
<span class="fc" id="L250">        }</span>

        /**
         * Register the LiveRef instances in the supplied list to participate
         * in distributed garbage collection.
         *
         * This method returns false if this entry was removed from the
         * global endpoint table (because it was empty) before these refs
         * could be registered.  In that case, a new EndpointEntry needs
         * to be looked up.
         *
         * This method must NOT be called while synchronized on this entry.
         */
        public boolean registerRefs(List&lt;LiveRef&gt; refs) {
<span class="pc bpc" id="L264" title="1 of 4 branches missed.">            assert !Thread.holdsLock(this);</span>

<span class="fc" id="L266">            Set&lt;RefEntry&gt; refsToDirty = null;     // entries for refs needing dirty</span>
            long sequenceNum;           // sequence number for dirty call

<span class="fc" id="L269">            synchronized (this) {</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">                if (removed) {</span>
<span class="nc" id="L271">                    return false;</span>
                }

<span class="fc" id="L274">                Iterator&lt;LiveRef&gt; iter = refs.iterator();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                while (iter.hasNext()) {</span>
<span class="fc" id="L276">                    LiveRef ref = iter.next();</span>
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">                    assert ref.getEndpoint().equals(endpoint);</span>

<span class="fc" id="L279">                    RefEntry refEntry = refTable.get(ref);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">                    if (refEntry == null) {</span>
<span class="fc" id="L281">                        LiveRef refClone = (LiveRef) ref.clone();</span>
<span class="fc" id="L282">                        refEntry = new RefEntry(refClone);</span>
<span class="fc" id="L283">                        refTable.put(refClone, refEntry);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                        if (refsToDirty == null) {</span>
<span class="fc" id="L285">                            refsToDirty = new HashSet&lt;&gt;(5);</span>
                        }
<span class="fc" id="L287">                        refsToDirty.add(refEntry);</span>
                    }

<span class="fc" id="L290">                    refEntry.addInstanceToRefSet(ref);</span>
<span class="fc" id="L291">                }</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">                if (refsToDirty == null) {</span>
<span class="fc" id="L294">                    return true;</span>
                }

<span class="fc" id="L297">                refsToDirty.addAll(invalidRefs);</span>
<span class="fc" id="L298">                invalidRefs.clear();</span>

<span class="fc" id="L300">                sequenceNum = getNextSequenceNum();</span>
<span class="pc" id="L301">            }</span>

<span class="fc" id="L303">            makeDirtyCall(refsToDirty, sequenceNum);</span>
<span class="fc" id="L304">            return true;</span>
        }

        /**
         * Remove the given RefEntry from the ref table.  If that makes
         * the ref table empty, remove this entry from the global endpoint
         * table.
         *
         * This method must ONLY be called while synchronized on this entry.
         */
        private void removeRefEntry(RefEntry refEntry) {
<span class="pc bpc" id="L315" title="1 of 4 branches missed.">            assert Thread.holdsLock(this);</span>
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">            assert !removed;</span>
<span class="pc bpc" id="L317" title="1 of 4 branches missed.">            assert refTable.containsKey(refEntry.getRef());</span>

<span class="fc" id="L319">            refTable.remove(refEntry.getRef());</span>
<span class="fc" id="L320">            invalidRefs.remove(refEntry);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if (refTable.isEmpty()) {</span>
<span class="fc" id="L322">                synchronized (endpointTable) {</span>
<span class="fc" id="L323">                    endpointTable.remove(endpoint);</span>
<span class="fc" id="L324">                    Transport transport = endpoint.getOutboundTransport();</span>
<span class="fc" id="L325">                    transport.free(endpoint);</span>
                    /*
                     * If there are no longer any live remote references
                     * registered, we are no longer concerned with the
                     * latency of local garbage collection here.
                     */
<span class="fc bfc" id="L331" title="All 2 branches covered.">                    if (endpointTable.isEmpty()) {</span>
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">                        assert gcLatencyRequest != null;</span>
<span class="fc" id="L333">                        gcLatencyRequest.cancel();</span>
<span class="fc" id="L334">                        gcLatencyRequest = null;</span>
                    }
<span class="fc" id="L336">                    removed = true;</span>
<span class="pc" id="L337">                }</span>
            }
<span class="fc" id="L339">        }</span>

        /**
         * Make a DGC dirty call to this entry's endpoint, for the ObjIDs
         * corresponding to the given set of refs and with the given
         * sequence number.
         *
         * This method must NOT be called while synchronized on this entry.
         */
        private void makeDirtyCall(Set&lt;RefEntry&gt; refEntries, long sequenceNum) {
<span class="pc bpc" id="L349" title="1 of 4 branches missed.">            assert !Thread.holdsLock(this);</span>

            ObjID[] ids;
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (refEntries != null) {</span>
<span class="fc" id="L353">                ids = createObjIDArray(refEntries);</span>
            } else {
<span class="fc" id="L355">                ids = emptyObjIDArray;</span>
            }

<span class="fc" id="L358">            long startTime = System.currentTimeMillis();</span>
            try {
<span class="fc" id="L360">                Lease lease =</span>
<span class="fc" id="L361">                    dgc.dirty(ids, sequenceNum, new Lease(vmid, leaseValue));</span>
<span class="fc" id="L362">                long duration = lease.getValue();</span>

<span class="fc" id="L364">                long newRenewTime = computeRenewTime(startTime, duration);</span>
<span class="fc" id="L365">                long newExpirationTime = startTime + duration;</span>

<span class="fc" id="L367">                synchronized (this) {</span>
<span class="fc" id="L368">                    dirtyFailures = 0;</span>
<span class="fc" id="L369">                    setRenewTime(newRenewTime);</span>
<span class="fc" id="L370">                    expirationTime = newExpirationTime;</span>
<span class="pc" id="L371">                }</span>

<span class="fc" id="L373">            } catch (Exception e) {</span>
<span class="fc" id="L374">                long endTime = System.currentTimeMillis();</span>

<span class="fc" id="L376">                synchronized (this) {</span>
<span class="fc" id="L377">                    dirtyFailures++;</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">                    if (dirtyFailures == 1) {</span>
                        /*
                         * If this was the first recent failed dirty call,
                         * reschedule another one immediately, in case there
                         * was just a transient network problem, and remember
                         * the start time and duration of this attempt for
                         * future calculations of the delays between retries.
                         */
<span class="fc" id="L387">                        dirtyFailureStartTime = startTime;</span>
<span class="fc" id="L388">                        dirtyFailureDuration = endTime - startTime;</span>
<span class="fc" id="L389">                        setRenewTime(endTime);</span>
                    } else {
                        /*
                         * For each successive failed dirty call, wait for a
                         * (binary) exponentially increasing delay before
                         * retrying, to avoid network congestion.
                         */
<span class="fc" id="L396">                        int n = dirtyFailures - 2;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                        if (n == 0) {</span>
                            /*
                             * Calculate the initial retry delay from the
                             * average time elapsed for each of the first
                             * two failed dirty calls.  The result must be
                             * at least 1000ms, to prevent a tight loop.
                             */
<span class="fc" id="L404">                            dirtyFailureDuration =</span>
<span class="fc" id="L405">                                Math.max((dirtyFailureDuration +</span>
                                          (endTime - startTime)) &gt;&gt; 1, 1000);
                        }
<span class="fc" id="L408">                        long newRenewTime =</span>
                            endTime + (dirtyFailureDuration &lt;&lt; n);

                        /*
                         * Continue if the last known held lease has not
                         * expired, or else at least a fixed number of times,
                         * or at least until we've tried for a fixed amount
                         * of time (the default lease value we request).
                         */
<span class="fc bfc" id="L417" title="All 4 branches covered.">                        if (newRenewTime &lt; expirationTime ||</span>
                            dirtyFailures &lt; dirtyFailureRetries ||
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">                            newRenewTime &lt; dirtyFailureStartTime + leaseValue)</span>
                        {
<span class="fc" id="L421">                            setRenewTime(newRenewTime);</span>
                        } else {
                            /*
                             * Give up: postpone lease renewals until next
                             * ref is registered for this endpoint.
                             */
<span class="nc" id="L427">                            setRenewTime(Long.MAX_VALUE);</span>
                        }
                    }

<span class="fc bfc" id="L431" title="All 2 branches covered.">                    if (refEntries != null) {</span>
                        /*
                         * Add all of these refs to the set of refs for this
                         * endpoint that may be invalid (this VM may not be in
                         * the server's referenced set), so that we will
                         * attempt to explicitly dirty them again in the
                         * future.
                         */
<span class="fc" id="L439">                        invalidRefs.addAll(refEntries);</span>

                        /*
                         * Record that a dirty call has failed for all of these
                         * refs, so that clean calls for them in the future
                         * will be strong.
                         */
<span class="fc" id="L446">                        Iterator&lt;RefEntry&gt; iter = refEntries.iterator();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">                        while (iter.hasNext()) {</span>
<span class="fc" id="L448">                            RefEntry refEntry = iter.next();</span>
<span class="fc" id="L449">                            refEntry.markDirtyFailed();</span>
<span class="fc" id="L450">                        }</span>
                    }

                    /*
                     * If the last known held lease will have expired before
                     * the next renewal, all refs might be invalid.
                     */
<span class="fc bfc" id="L457" title="All 2 branches covered.">                    if (renewTime &gt;= expirationTime) {</span>
<span class="fc" id="L458">                        invalidRefs.addAll(refTable.values());</span>
                    }
<span class="pc" id="L460">                }</span>
<span class="fc" id="L461">            }</span>
<span class="fc" id="L462">        }</span>

        /**
         * Set the absolute time at which the lease for this entry should
         * be renewed.
         *
         * This method must ONLY be called while synchronized on this entry.
         */
        private void setRenewTime(long newRenewTime) {
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">            assert Thread.holdsLock(this);</span>

<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (newRenewTime &lt; renewTime) {</span>
<span class="fc" id="L474">                renewTime = newRenewTime;</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">                if (interruptible) {</span>
<span class="fc" id="L476">                    AccessController.doPrivileged(</span>
<span class="fc" id="L477">                        new PrivilegedAction&lt;Void&gt;() {</span>
                            public Void run() {
<span class="fc" id="L479">                            renewCleanThread.interrupt();</span>
<span class="fc" id="L480">                            return null;</span>
                        }
                    });
                }
            } else {
<span class="fc" id="L485">                renewTime = newRenewTime;</span>
            }
<span class="fc" id="L487">        }</span>

        /**
         * RenewCleanThread handles the asynchronous client-side DGC activity
         * for this entry: renewing the leases and making clean calls.
         */
<span class="fc" id="L493">        private class RenewCleanThread implements Runnable {</span>

            public void run() {
                do {
                    long timeToWait;
<span class="fc" id="L498">                    RefEntry.PhantomLiveRef phantom = null;</span>
<span class="fc" id="L499">                    boolean needRenewal = false;</span>
<span class="fc" id="L500">                    Set&lt;RefEntry&gt; refsToDirty = null;</span>
<span class="fc" id="L501">                    long sequenceNum = Long.MIN_VALUE;</span>

<span class="fc" id="L503">                    synchronized (EndpointEntry.this) {</span>
                        /*
                         * Calculate time to block (waiting for phantom
                         * reference notifications).  It is the time until the
                         * lease renewal should be done, bounded on the low
                         * end by 1 ms so that the reference queue will always
                         * get processed, and if there are pending clean
                         * requests (remaining because some clean calls
                         * failed), bounded on the high end by the maximum
                         * clean call retry interval.
                         */
<span class="fc" id="L514">                        long timeUntilRenew =</span>
<span class="fc" id="L515">                            renewTime - System.currentTimeMillis();</span>
<span class="fc" id="L516">                        timeToWait = Math.max(timeUntilRenew, 1);</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                        if (!pendingCleans.isEmpty()) {</span>
<span class="fc" id="L518">                            timeToWait = Math.min(timeToWait, cleanInterval);</span>
                        }

                        /*
                         * Set flag indicating that it is OK to interrupt this
                         * thread now, such as if a earlier lease renewal time
                         * is set, because we are only going to be blocking
                         * and can deal with interrupts.
                         */
<span class="fc" id="L527">                        interruptible = true;</span>
<span class="pc" id="L528">                    }</span>

                    try {
                        /*
                         * Wait for the duration calculated above for any of
                         * our phantom references to be enqueued.
                         */
<span class="fc" id="L535">                        phantom = (RefEntry.PhantomLiveRef)</span>
<span class="fc" id="L536">                            refQueue.remove(timeToWait);</span>
<span class="fc" id="L537">                    } catch (InterruptedException e) {</span>
<span class="fc" id="L538">                    }</span>

<span class="fc" id="L540">                    synchronized (EndpointEntry.this) {</span>
                        /*
                         * Set flag indicating that it is NOT OK to interrupt
                         * this thread now, because we may be undertaking I/O
                         * operations that should not be interrupted (and we
                         * will not be blocking arbitrarily).
                         */
<span class="fc" id="L547">                        interruptible = false;</span>
<span class="fc" id="L548">                        Thread.interrupted();   // clear interrupted state</span>

                        /*
                         * If there was a phantom reference enqueued, process
                         * it and all the rest on the queue, generating
                         * clean requests as necessary.
                         */
<span class="fc bfc" id="L555" title="All 2 branches covered.">                        if (phantom != null) {</span>
<span class="fc" id="L556">                            processPhantomRefs(phantom);</span>
                        }

                        /*
                         * Check if it is time to renew this entry's lease.
                         */
<span class="fc" id="L562">                        long currentTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                        if (currentTime &gt; renewTime) {</span>
<span class="fc" id="L564">                            needRenewal = true;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                            if (!invalidRefs.isEmpty()) {</span>
<span class="fc" id="L566">                                refsToDirty = invalidRefs;</span>
<span class="fc" id="L567">                                invalidRefs = new HashSet&lt;&gt;(5);</span>
                            }
<span class="fc" id="L569">                            sequenceNum = getNextSequenceNum();</span>
                        }
<span class="pc" id="L571">                    }</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (needRenewal) {</span>
<span class="fc" id="L574">                        makeDirtyCall(refsToDirty, sequenceNum);</span>
                    }

<span class="fc bfc" id="L577" title="All 2 branches covered.">                    if (!pendingCleans.isEmpty()) {</span>
<span class="fc" id="L578">                        makeCleanCalls();</span>
                    }
<span class="fc bfc" id="L580" title="All 4 branches covered.">                } while (!removed || !pendingCleans.isEmpty());</span>
<span class="fc" id="L581">            }</span>
        }

        /**
         * Process the notification of the given phantom reference and any
         * others that are on this entry's reference queue.  Each phantom
         * reference is removed from its RefEntry's ref set.  All ref
         * entries that have no more registered instances are collected
         * into up to two batched clean call requests: one for refs
         * requiring a &quot;strong&quot; clean call, and one for the rest.
         *
         * This method must ONLY be called while synchronized on this entry.
         */
        private void processPhantomRefs(RefEntry.PhantomLiveRef phantom) {
<span class="pc bpc" id="L595" title="1 of 4 branches missed.">            assert Thread.holdsLock(this);</span>

<span class="fc" id="L597">            Set&lt;RefEntry&gt; strongCleans = null;</span>
<span class="fc" id="L598">            Set&lt;RefEntry&gt; normalCleans = null;</span>

            do {
<span class="fc" id="L601">                RefEntry refEntry = phantom.getRefEntry();</span>
<span class="fc" id="L602">                refEntry.removeInstanceFromRefSet(phantom);</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                if (refEntry.isRefSetEmpty()) {</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">                    if (refEntry.hasDirtyFailed()) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                        if (strongCleans == null) {</span>
<span class="nc" id="L606">                            strongCleans = new HashSet&lt;&gt;(5);</span>
                        }
<span class="nc" id="L608">                        strongCleans.add(refEntry);</span>
                    } else {
<span class="fc bfc" id="L610" title="All 2 branches covered.">                        if (normalCleans == null) {</span>
<span class="fc" id="L611">                            normalCleans = new HashSet&lt;&gt;(5);</span>
                        }
<span class="fc" id="L613">                        normalCleans.add(refEntry);</span>
                    }
<span class="fc" id="L615">                    removeRefEntry(refEntry);</span>
                }
<span class="fc" id="L617">            } while ((phantom =</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                (RefEntry.PhantomLiveRef) refQueue.poll()) != null);</span>

<span class="pc bpc" id="L620" title="1 of 2 branches missed.">            if (strongCleans != null) {</span>
<span class="nc" id="L621">                pendingCleans.add(</span>
<span class="nc" id="L622">                    new CleanRequest(createObjIDArray(strongCleans),</span>
<span class="nc" id="L623">                                     getNextSequenceNum(), true));</span>
            }
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (normalCleans != null) {</span>
<span class="fc" id="L626">                pendingCleans.add(</span>
<span class="fc" id="L627">                    new CleanRequest(createObjIDArray(normalCleans),</span>
<span class="fc" id="L628">                                     getNextSequenceNum(), false));</span>
            }
<span class="fc" id="L630">        }</span>

        /**
         * CleanRequest holds the data for the parameters of a clean call
         * that needs to be made.
         */
        private static class CleanRequest {

            final ObjID[] objIDs;
            final long sequenceNum;
            final boolean strong;

            /** how many times this request has failed */
<span class="fc" id="L643">            int failures = 0;</span>

<span class="fc" id="L645">            CleanRequest(ObjID[] objIDs, long sequenceNum, boolean strong) {</span>
<span class="fc" id="L646">                this.objIDs = objIDs;</span>
<span class="fc" id="L647">                this.sequenceNum = sequenceNum;</span>
<span class="fc" id="L648">                this.strong = strong;</span>
<span class="fc" id="L649">            }</span>
        }

        /**
         * Make all of the clean calls described by the clean requests in
         * this entry's set of &quot;pending cleans&quot;.  Clean requests for clean
         * calls that succeed are removed from the &quot;pending cleans&quot; set.
         *
         * This method must NOT be called while synchronized on this entry.
         */
        private void makeCleanCalls() {
<span class="pc bpc" id="L660" title="1 of 4 branches missed.">            assert !Thread.holdsLock(this);</span>

<span class="fc" id="L662">            Iterator&lt;CleanRequest&gt; iter = pendingCleans.iterator();</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L664">                CleanRequest request = iter.next();</span>
                try {
<span class="fc" id="L666">                    dgc.clean(request.objIDs, request.sequenceNum, vmid,</span>
                              request.strong);
<span class="fc" id="L668">                    iter.remove();</span>
<span class="fc" id="L669">                } catch (Exception e) {</span>
                    /*
                     * Many types of exceptions here could have been
                     * caused by a transient failure, so try again a
                     * few times, but not forever.
                     */
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">                    if (++request.failures &gt;= cleanFailureRetries) {</span>
<span class="nc" id="L676">                        iter.remove();</span>
                    }
<span class="fc" id="L678">                }</span>
<span class="fc" id="L679">            }</span>
<span class="fc" id="L680">        }</span>

        /**
         * Create an array of ObjIDs (needed for the DGC remote calls)
         * from the ids in the given set of refs.
         */
        private static ObjID[] createObjIDArray(Set&lt;RefEntry&gt; refEntries) {
<span class="fc" id="L687">            ObjID[] ids = new ObjID[refEntries.size()];</span>
<span class="fc" id="L688">            Iterator&lt;RefEntry&gt; iter = refEntries.iterator();</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            for (int i = 0; i &lt; ids.length; i++) {</span>
<span class="fc" id="L690">                ids[i] = iter.next().getRef().getObjID();</span>
            }
<span class="fc" id="L692">            return ids;</span>
        }

        /**
         * RefEntry encapsulates the client-side DGC information specific
         * to a particular LiveRef value.  In particular, it contains a
         * set of phantom references to all of the instances of the LiveRef
         * value registered in the system (but not garbage collected
         * locally).
         */
<span class="fc bfc" id="L702" title="All 2 branches covered.">        private class RefEntry {</span>

            /** LiveRef value for this entry (not a registered instance) */
            private LiveRef ref;
            /** set of phantom references to registered instances */
<span class="fc" id="L707">            private Set&lt;PhantomLiveRef&gt; refSet = new HashSet&lt;&gt;(5);</span>
            /** true if a dirty call containing this ref has failed */
<span class="fc" id="L709">            private boolean dirtyFailed = false;</span>

<span class="fc" id="L711">            public RefEntry(LiveRef ref) {</span>
<span class="fc" id="L712">                this.ref = ref;</span>
<span class="fc" id="L713">            }</span>

            /**
             * Return the LiveRef value for this entry (not a registered
             * instance).
             */
            public LiveRef getRef() {
<span class="fc" id="L720">                return ref;</span>
            }

            /**
             * Add a LiveRef to the set of registered instances for this entry.
             *
             * This method must ONLY be invoked while synchronized on this
             * RefEntry's EndpointEntry.
             */
            public void addInstanceToRefSet(LiveRef ref) {
<span class="pc bpc" id="L730" title="1 of 4 branches missed.">                assert Thread.holdsLock(EndpointEntry.this);</span>
<span class="pc bpc" id="L731" title="1 of 4 branches missed.">                assert ref.equals(this.ref);</span>

                /*
                 * Only keep a phantom reference to the registered instance,
                 * so that it can be garbage collected normally (and we can be
                 * notified when that happens).
                 */
<span class="fc" id="L738">                refSet.add(new PhantomLiveRef(ref));</span>
<span class="fc" id="L739">            }</span>

            /**
             * Remove a PhantomLiveRef from the set of registered instances.
             *
             * This method must ONLY be invoked while synchronized on this
             * RefEntry's EndpointEntry.
             */
            public void removeInstanceFromRefSet(PhantomLiveRef phantom) {
<span class="pc bpc" id="L748" title="1 of 4 branches missed.">                assert Thread.holdsLock(EndpointEntry.this);</span>
<span class="pc bpc" id="L749" title="1 of 4 branches missed.">                assert refSet.contains(phantom);</span>
<span class="fc" id="L750">                refSet.remove(phantom);</span>
<span class="fc" id="L751">            }</span>

            /**
             * Return true if there are no registered LiveRef instances for
             * this entry still reachable in this VM.
             *
             * This method must ONLY be invoked while synchronized on this
             * RefEntry's EndpointEntry.
             */
            public boolean isRefSetEmpty() {
<span class="pc bpc" id="L761" title="1 of 4 branches missed.">                assert Thread.holdsLock(EndpointEntry.this);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                return refSet.size() == 0;</span>
            }

            /**
             * Record that a dirty call that explicitly contained this
             * entry's ref has failed.
             *
             * This method must ONLY be invoked while synchronized on this
             * RefEntry's EndpointEntry.
             */
            public void markDirtyFailed() {
<span class="pc bpc" id="L773" title="1 of 4 branches missed.">                assert Thread.holdsLock(EndpointEntry.this);</span>
<span class="fc" id="L774">                dirtyFailed = true;</span>
<span class="fc" id="L775">            }</span>

            /**
             * Return true if a dirty call that explicitly contained this
             * entry's ref has failed (and therefore a clean call for this
             * ref needs to be marked &quot;strong&quot;).
             *
             * This method must ONLY be invoked while synchronized on this
             * RefEntry's EndpointEntry.
             */
            public boolean hasDirtyFailed() {
<span class="pc bpc" id="L786" title="1 of 4 branches missed.">                assert Thread.holdsLock(EndpointEntry.this);</span>
<span class="fc" id="L787">                return dirtyFailed;</span>
            }

            /**
             * PhantomLiveRef is a PhantomReference to a LiveRef instance,
             * used to detect when the LiveRef becomes permanently
             * unreachable in this VM.
             */
            private class PhantomLiveRef extends PhantomReference&lt;LiveRef&gt; {

<span class="fc" id="L797">                public PhantomLiveRef(LiveRef ref) {</span>
<span class="fc" id="L798">                    super(ref, EndpointEntry.this.refQueue);</span>
<span class="fc" id="L799">                }</span>

                public RefEntry getRefEntry() {
<span class="fc" id="L802">                    return RefEntry.this;</span>
                }
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>