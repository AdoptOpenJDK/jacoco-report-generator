<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SslRMIServerSocketFactory.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.rmi.ssl</a> &gt; <span class="el_source">SslRMIServerSocketFactory.java</span></div><h1>SslRMIServerSocketFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.rmi.ssl;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.rmi.server.RMIServerSocketFactory;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

/**
 * &lt;p&gt;An &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; instance is used by the RMI
 * runtime in order to obtain server sockets for RMI calls via SSL.&lt;/p&gt;
 *
 * &lt;p&gt;This class implements &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; over
 * the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)
 * protocols.&lt;/p&gt;
 *
 * &lt;p&gt;This class creates SSL sockets using the default
 * &lt;code&gt;SSLSocketFactory&lt;/code&gt; (see {@link
 * SSLSocketFactory#getDefault}) or the default
 * &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; (see {@link
 * SSLServerSocketFactory#getDefault}) unless the
 * constructor taking an &lt;code&gt;SSLContext&lt;/code&gt; is
 * used in which case the SSL sockets are created using
 * the &lt;code&gt;SSLSocketFactory&lt;/code&gt; returned by
 * {@link SSLContext#getSocketFactory} or the
 * &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; returned by
 * {@link SSLContext#getServerSocketFactory}.
 *
 * When an &lt;code&gt;SSLContext&lt;/code&gt; is not supplied all the instances of this
 * class share the same keystore, and the same truststore (when client
 * authentication is required by the server). This behavior can be modified
 * by supplying an already initialized &lt;code&gt;SSLContext&lt;/code&gt; instance.
 *
 * @see javax.net.ssl.SSLSocketFactory
 * @see javax.net.ssl.SSLServerSocketFactory
 * @see javax.rmi.ssl.SslRMIClientSocketFactory
 * @since 1.5
 */
public class SslRMIServerSocketFactory implements RMIServerSocketFactory {

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with
     * the default SSL socket configuration.&lt;/p&gt;
     *
     * &lt;p&gt;SSL connections accepted by server sockets created by this
     * factory have the default cipher suites and protocol versions
     * enabled and do not require client authentication.&lt;/p&gt;
     */
    public SslRMIServerSocketFactory() {
<span class="fc" id="L80">        this(null, null, false);</span>
<span class="fc" id="L81">    }</span>

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with
     * the specified SSL socket configuration.&lt;/p&gt;
     *
     * @param enabledCipherSuites names of all the cipher suites to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the cipher suites
     * that are enabled by default
     *
     * @param enabledProtocols names of all the protocol versions to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the protocol versions
     * that are enabled by default
     *
     * @param needClientAuth &lt;code&gt;true&lt;/code&gt; to require client
     * authentication on SSL connections accepted by server sockets
     * created by this factory; &lt;code&gt;false&lt;/code&gt; to not require
     * client authentication
     *
     * @exception IllegalArgumentException when one or more of the cipher
     * suites named by the &lt;code&gt;enabledCipherSuites&lt;/code&gt; parameter is
     * not supported, when one or more of the protocols named by the
     * &lt;code&gt;enabledProtocols&lt;/code&gt; parameter is not supported or when
     * a problem is encountered while trying to check if the supplied
     * cipher suites and protocols to be enabled are supported.
     *
     * @see SSLSocket#setEnabledCipherSuites
     * @see SSLSocket#setEnabledProtocols
     * @see SSLSocket#setNeedClientAuth
     */
    public SslRMIServerSocketFactory(
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean needClientAuth)
            throws IllegalArgumentException {
<span class="fc" id="L118">        this(null, enabledCipherSuites, enabledProtocols, needClientAuth);</span>
<span class="fc" id="L119">    }</span>

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; with the
     * specified &lt;code&gt;SSLContext&lt;/code&gt; and SSL socket configuration.&lt;/p&gt;
     *
     * @param context the SSL context to be used for creating SSL sockets.
     * If &lt;code&gt;context&lt;/code&gt; is null the default &lt;code&gt;SSLSocketFactory&lt;/code&gt;
     * or the default &lt;code&gt;SSLServerSocketFactory&lt;/code&gt; will be used to
     * create SSL sockets. Otherwise, the socket factory returned by
     * &lt;code&gt;SSLContext.getSocketFactory()&lt;/code&gt; or
     * &lt;code&gt;SSLContext.getServerSocketFactory()&lt;/code&gt; will be used instead.
     *
     * @param enabledCipherSuites names of all the cipher suites to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the cipher suites
     * that are enabled by default
     *
     * @param enabledProtocols names of all the protocol versions to
     * enable on SSL connections accepted by server sockets created by
     * this factory, or &lt;code&gt;null&lt;/code&gt; to use the protocol versions
     * that are enabled by default
     *
     * @param needClientAuth &lt;code&gt;true&lt;/code&gt; to require client
     * authentication on SSL connections accepted by server sockets
     * created by this factory; &lt;code&gt;false&lt;/code&gt; to not require
     * client authentication
     *
     * @exception IllegalArgumentException when one or more of the cipher
     * suites named by the &lt;code&gt;enabledCipherSuites&lt;/code&gt; parameter is
     * not supported, when one or more of the protocols named by the
     * &lt;code&gt;enabledProtocols&lt;/code&gt; parameter is not supported or when
     * a problem is encountered while trying to check if the supplied
     * cipher suites and protocols to be enabled are supported.
     *
     * @see SSLSocket#setEnabledCipherSuites
     * @see SSLSocket#setEnabledProtocols
     * @see SSLSocket#setNeedClientAuth
     * @since 1.7
     */
    public SslRMIServerSocketFactory(
            SSLContext context,
            String[] enabledCipherSuites,
            String[] enabledProtocols,
            boolean needClientAuth)
<span class="fc" id="L164">            throws IllegalArgumentException {</span>
        // Initialize the configuration parameters.
        //
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        this.enabledCipherSuites = enabledCipherSuites == null ?</span>
<span class="pc" id="L168">            null : enabledCipherSuites.clone();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        this.enabledProtocols = enabledProtocols == null ?</span>
<span class="pc" id="L170">            null : enabledProtocols.clone();</span>
<span class="fc" id="L171">        this.needClientAuth = needClientAuth;</span>

        // Force the initialization of the default at construction time,
        // rather than delaying it to the first time createServerSocket()
        // is called.
        //
<span class="fc" id="L177">        this.context = context;</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        final SSLSocketFactory sslSocketFactory =</span>
                context == null ?
<span class="pc" id="L180">                    getDefaultSSLSocketFactory() : context.getSocketFactory();</span>
<span class="fc" id="L181">        SSLSocket sslSocket = null;</span>
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">        if (this.enabledCipherSuites != null || this.enabledProtocols != null) {</span>
            try {
<span class="nc" id="L184">                sslSocket = (SSLSocket) sslSocketFactory.createSocket();</span>
<span class="nc" id="L185">            } catch (Exception e) {</span>
                final String msg = &quot;Unable to check if the cipher suites &quot; +
                        &quot;and protocols to enable are supported&quot;;
<span class="nc" id="L188">                throw (IllegalArgumentException)</span>
<span class="nc" id="L189">                new IllegalArgumentException(msg).initCause(e);</span>
<span class="nc" id="L190">            }</span>
        }

        // Check if all the cipher suites and protocol versions to enable
        // are supported by the underlying SSL/TLS implementation and if
        // true create lists from arrays.
        //
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (this.enabledCipherSuites != null) {</span>
<span class="nc" id="L198">            sslSocket.setEnabledCipherSuites(this.enabledCipherSuites);</span>
<span class="nc" id="L199">            enabledCipherSuitesList = Arrays.asList(this.enabledCipherSuites);</span>
        }
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (this.enabledProtocols != null) {</span>
<span class="nc" id="L202">            sslSocket.setEnabledProtocols(this.enabledProtocols);</span>
<span class="nc" id="L203">            enabledProtocolsList = Arrays.asList(this.enabledProtocols);</span>
        }
<span class="fc" id="L205">    }</span>

    /**
     * &lt;p&gt;Returns the names of the cipher suites enabled on SSL
     * connections accepted by server sockets created by this factory,
     * or &lt;code&gt;null&lt;/code&gt; if this factory uses the cipher suites
     * that are enabled by default.&lt;/p&gt;
     *
     * @return an array of cipher suites enabled, or &lt;code&gt;null&lt;/code&gt;
     *
     * @see SSLSocket#setEnabledCipherSuites
     */
    public final String[] getEnabledCipherSuites() {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        return enabledCipherSuites == null ?</span>
<span class="nc" id="L219">            null : enabledCipherSuites.clone();</span>
    }

    /**
     * &lt;p&gt;Returns the names of the protocol versions enabled on SSL
     * connections accepted by server sockets created by this factory,
     * or &lt;code&gt;null&lt;/code&gt; if this factory uses the protocol versions
     * that are enabled by default.&lt;/p&gt;
     *
     * @return an array of protocol versions enabled, or
     * &lt;code&gt;null&lt;/code&gt;
     *
     * @see SSLSocket#setEnabledProtocols
     */
    public final String[] getEnabledProtocols() {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        return enabledProtocols == null ?</span>
<span class="nc" id="L235">            null : enabledProtocols.clone();</span>
    }

    /**
     * &lt;p&gt;Returns &lt;code&gt;true&lt;/code&gt; if client authentication is
     * required on SSL connections accepted by server sockets created
     * by this factory.&lt;/p&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if client authentication is required
     *
     * @see SSLSocket#setNeedClientAuth
     */
    public final boolean getNeedClientAuth() {
<span class="nc" id="L248">        return needClientAuth;</span>
    }

    /**
     * &lt;p&gt;Creates a server socket that accepts SSL connections
     * configured according to this factory's SSL socket configuration
     * parameters.&lt;/p&gt;
     */
    public ServerSocket createServerSocket(int port) throws IOException {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        final SSLSocketFactory sslSocketFactory =</span>
                context == null ?
<span class="pc" id="L259">                    getDefaultSSLSocketFactory() : context.getSocketFactory();</span>
<span class="fc" id="L260">        return new ServerSocket(port) {</span>
            public Socket accept() throws IOException {
<span class="nc" id="L262">                Socket socket = super.accept();</span>
<span class="nc" id="L263">                SSLSocket sslSocket = (SSLSocket) sslSocketFactory.createSocket(</span>
<span class="nc" id="L264">                        socket, socket.getInetAddress().getHostName(),</span>
<span class="nc" id="L265">                        socket.getPort(), true);</span>
<span class="nc" id="L266">                sslSocket.setUseClientMode(false);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (enabledCipherSuites != null) {</span>
<span class="nc" id="L268">                    sslSocket.setEnabledCipherSuites(enabledCipherSuites);</span>
                }
<span class="nc bnc" id="L270" title="All 2 branches missed.">                if (enabledProtocols != null) {</span>
<span class="nc" id="L271">                    sslSocket.setEnabledProtocols(enabledProtocols);</span>
                }
<span class="nc" id="L273">                sslSocket.setNeedClientAuth(needClientAuth);</span>
<span class="nc" id="L274">                return sslSocket;</span>
            }
        };
    }

    /**
     * &lt;p&gt;Indicates whether some other object is &quot;equal to&quot; this one.&lt;/p&gt;
     *
     * &lt;p&gt;Two &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt; objects are equal
     * if they have been constructed with the same SSL context and
     * SSL socket configuration parameters.&lt;/p&gt;
     *
     * &lt;p&gt;A subclass should override this method (as well as
     * {@link #hashCode()}) if it adds instance state that affects
     * equality.&lt;/p&gt;
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (obj == null) return false;</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">        if (obj == this) return true;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (!(obj instanceof SslRMIServerSocketFactory))</span>
<span class="nc" id="L294">            return false;</span>
<span class="nc" id="L295">        SslRMIServerSocketFactory that = (SslRMIServerSocketFactory) obj;</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">        return (getClass().equals(that.getClass()) &amp;&amp; checkParameters(that));</span>
    }

    private boolean checkParameters(SslRMIServerSocketFactory that) {
        // SSL context
        //
<span class="nc bnc" id="L302" title="All 6 branches missed.">        if (context == null ? that.context != null : !context.equals(that.context))</span>
<span class="nc" id="L303">            return false;</span>

        // needClientAuth flag
        //
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (needClientAuth != that.needClientAuth)</span>
<span class="nc" id="L308">            return false;</span>

        // enabledCipherSuites
        //
<span class="nc bnc" id="L312" title="All 8 branches missed.">        if ((enabledCipherSuites == null &amp;&amp; that.enabledCipherSuites != null) ||</span>
                (enabledCipherSuites != null &amp;&amp; that.enabledCipherSuites == null))
<span class="nc" id="L314">            return false;</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">        if (enabledCipherSuites != null &amp;&amp; that.enabledCipherSuites != null) {</span>
<span class="nc" id="L316">            List&lt;String&gt; thatEnabledCipherSuitesList =</span>
<span class="nc" id="L317">                    Arrays.asList(that.enabledCipherSuites);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (!enabledCipherSuitesList.equals(thatEnabledCipherSuitesList))</span>
<span class="nc" id="L319">                return false;</span>
        }

        // enabledProtocols
        //
<span class="nc bnc" id="L324" title="All 8 branches missed.">        if ((enabledProtocols == null &amp;&amp; that.enabledProtocols != null) ||</span>
                (enabledProtocols != null &amp;&amp; that.enabledProtocols == null))
<span class="nc" id="L326">            return false;</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if (enabledProtocols != null &amp;&amp; that.enabledProtocols != null) {</span>
<span class="nc" id="L328">            List&lt;String&gt; thatEnabledProtocolsList =</span>
<span class="nc" id="L329">                    Arrays.asList(that.enabledProtocols);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (!enabledProtocolsList.equals(thatEnabledProtocolsList))</span>
<span class="nc" id="L331">                return false;</span>
        }

<span class="nc" id="L334">        return true;</span>
    }

    /**
     * &lt;p&gt;Returns a hash code value for this
     * &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a hash code value for this
     * &lt;code&gt;SslRMIServerSocketFactory&lt;/code&gt;.
     */
    public int hashCode() {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        return getClass().hashCode() +</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">                (context == null ? 0 : context.hashCode()) +</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                (needClientAuth ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode()) +</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                (enabledCipherSuites == null ? 0 : enabledCipherSuitesList.hashCode()) +</span>
<span class="pc" id="L349">                (enabledProtocols == null ? 0 : enabledProtocolsList.hashCode());</span>
    }

    // We use a static field because:
    //
    //    SSLSocketFactory.getDefault() always returns the same object
    //    (at least on Sun's implementation), and we want to make sure
    //    that the Javadoc &amp; the implementation stay in sync.
    //
    // If someone needs to have different SslRMIServerSocketFactory
    // factories with different underlying SSLSocketFactory objects
    // using different keystores and truststores, he/she can always
    // use the constructor that takes an SSLContext as input.
    //
<span class="fc" id="L363">    private static SSLSocketFactory defaultSSLSocketFactory = null;</span>

    private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (defaultSSLSocketFactory == null)</span>
            defaultSSLSocketFactory =
<span class="fc" id="L368">                    (SSLSocketFactory) SSLSocketFactory.getDefault();</span>
<span class="fc" id="L369">        return defaultSSLSocketFactory;</span>
    }

    private final String[] enabledCipherSuites;
    private final String[] enabledProtocols;
    private final boolean needClientAuth;
    private List&lt;String&gt; enabledCipherSuitesList;
    private List&lt;String&gt; enabledProtocolsList;
    private SSLContext context;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>