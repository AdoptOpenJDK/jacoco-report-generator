<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SslRMIClientSocketFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.rmi.ssl</a> &gt; <span class="el_source">SslRMIClientSocketFactory.java</span></div><h1>SslRMIClientSocketFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.rmi.ssl;

import java.io.IOException;
import java.io.Serializable;
import java.net.Socket;
import java.rmi.server.RMIClientSocketFactory;
import java.util.StringTokenizer;
import javax.net.SocketFactory;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

/**
 * &lt;p&gt;An &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt; instance is used by the RMI
 * runtime in order to obtain client sockets for RMI calls via SSL.&lt;/p&gt;
 *
 * &lt;p&gt;This class implements &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; over
 * the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)
 * protocols.&lt;/p&gt;
 *
 * &lt;p&gt;This class creates SSL sockets using the default
 * &lt;code&gt;SSLSocketFactory&lt;/code&gt; (see {@link
 * SSLSocketFactory#getDefault}).  All instances of this class are
 * functionally equivalent.  In particular, they all share the same
 * truststore, and the same keystore when client authentication is
 * required by the server.  This behavior can be modified in
 * subclasses by overriding the {@link #createSocket(String,int)}
 * method; in that case, {@link #equals(Object) equals} and {@link
 * #hashCode() hashCode} may also need to be overridden.&lt;/p&gt;
 *
 * &lt;p&gt;If the system property
 * &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified,
 * the {@link #createSocket(String,int)} method will call {@link
 * SSLSocket#setEnabledCipherSuites(String[])} before returning the
 * socket.  The value of this system property is a string that is a
 * comma-separated list of SSL/TLS cipher suites to enable.&lt;/p&gt;
 *
 * &lt;p&gt;If the system property
 * &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified,
 * the {@link #createSocket(String,int)} method will call {@link
 * SSLSocket#setEnabledProtocols(String[])} before returning the
 * socket.  The value of this system property is a string that is a
 * comma-separated list of SSL/TLS protocol versions to enable.&lt;/p&gt;
 *
 * @see javax.net.ssl.SSLSocketFactory
 * @see javax.rmi.ssl.SslRMIServerSocketFactory
 * @since 1.5
 */
public class SslRMIClientSocketFactory
    implements RMIClientSocketFactory, Serializable {

    /**
     * &lt;p&gt;Creates a new &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;
     */
<span class="fc" id="L79">    public SslRMIClientSocketFactory() {</span>
        // We don't force the initialization of the default SSLSocketFactory
        // at construction time - because the RMI client socket factory is
        // created on the server side, where that initialization is a priori
        // meaningless, unless both server and client run in the same JVM.
        // We could possibly override readObject() to force this initialization,
        // but it might not be a good idea to actually mix this with possible
        // deserialization problems.
        // So contrarily to what we do for the server side, the initialization
        // of the SSLSocketFactory will be delayed until the first time
        // createSocket() is called - note that the default SSLSocketFactory
        // might already have been initialized anyway if someone in the JVM
        // already called SSLSocketFactory.getDefault().
        //
<span class="fc" id="L93">    }</span>

    /**
     * &lt;p&gt;Creates an SSL socket.&lt;/p&gt;
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is
     * specified, this method will call {@link
     * SSLSocket#setEnabledCipherSuites(String[])} before returning
     * the socket. The value of this system property is a string that
     * is a comma-separated list of SSL/TLS cipher suites to
     * enable.&lt;/p&gt;
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is
     * specified, this method will call {@link
     * SSLSocket#setEnabledProtocols(String[])} before returning the
     * socket. The value of this system property is a string that is a
     * comma-separated list of SSL/TLS protocol versions to
     * enable.&lt;/p&gt;
     */
    public Socket createSocket(String host, int port) throws IOException {
        // Retrieve the SSLSocketFactory
        //
<span class="nc" id="L117">        final SocketFactory sslSocketFactory = getDefaultClientSocketFactory();</span>
        // Create the SSLSocket
        //
<span class="nc" id="L120">        final SSLSocket sslSocket = (SSLSocket)</span>
<span class="nc" id="L121">            sslSocketFactory.createSocket(host, port);</span>
        // Set the SSLSocket Enabled Cipher Suites
        //
<span class="nc" id="L124">        final String enabledCipherSuites =</span>
<span class="nc" id="L125">            System.getProperty(&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (enabledCipherSuites != null) {</span>
<span class="nc" id="L127">            StringTokenizer st = new StringTokenizer(enabledCipherSuites, &quot;,&quot;);</span>
<span class="nc" id="L128">            int tokens = st.countTokens();</span>
<span class="nc" id="L129">            String enabledCipherSuitesList[] = new String[tokens];</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            for (int i = 0 ; i &lt; tokens; i++) {</span>
<span class="nc" id="L131">                enabledCipherSuitesList[i] = st.nextToken();</span>
            }
            try {
<span class="nc" id="L134">                sslSocket.setEnabledCipherSuites(enabledCipherSuitesList);</span>
<span class="nc" id="L135">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L136">                throw (IOException)</span>
<span class="nc" id="L137">                    new IOException(e.getMessage()).initCause(e);</span>
<span class="nc" id="L138">            }</span>
        }
        // Set the SSLSocket Enabled Protocols
        //
<span class="nc" id="L142">        final String enabledProtocols =</span>
<span class="nc" id="L143">            System.getProperty(&quot;javax.rmi.ssl.client.enabledProtocols&quot;);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (enabledProtocols != null) {</span>
<span class="nc" id="L145">            StringTokenizer st = new StringTokenizer(enabledProtocols, &quot;,&quot;);</span>
<span class="nc" id="L146">            int tokens = st.countTokens();</span>
<span class="nc" id="L147">            String enabledProtocolsList[] = new String[tokens];</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            for (int i = 0 ; i &lt; tokens; i++) {</span>
<span class="nc" id="L149">                enabledProtocolsList[i] = st.nextToken();</span>
            }
            try {
<span class="nc" id="L152">                sslSocket.setEnabledProtocols(enabledProtocolsList);</span>
<span class="nc" id="L153">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L154">                throw (IOException)</span>
<span class="nc" id="L155">                    new IOException(e.getMessage()).initCause(e);</span>
<span class="nc" id="L156">            }</span>
        }
        // Return the preconfigured SSLSocket
        //
<span class="nc" id="L160">        return sslSocket;</span>
    }

    /**
     * &lt;p&gt;Indicates whether some other object is &quot;equal to&quot; this one.&lt;/p&gt;
     *
     * &lt;p&gt;Because all instances of this class are functionally equivalent
     * (they all use the default
     * &lt;code&gt;SSLSocketFactory&lt;/code&gt;), this method simply returns
     * &lt;code&gt;this.getClass().equals(obj.getClass())&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;A subclass should override this method (as well
     * as {@link #hashCode()}) if its instances are not all
     * functionally equivalent.&lt;/p&gt;
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (obj == null) return false;</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (obj == this) return true;</span>
<span class="nc" id="L178">        return this.getClass().equals(obj.getClass());</span>
    }

    /**
     * &lt;p&gt;Returns a hash code value for this
     * &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a hash code value for this
     * &lt;code&gt;SslRMIClientSocketFactory&lt;/code&gt;.
     */
    public int hashCode() {
<span class="fc" id="L189">        return this.getClass().hashCode();</span>
    }

    // We use a static field because:
    //
    //    SSLSocketFactory.getDefault() always returns the same object
    //    (at least on Sun's implementation), and we want to make sure
    //    that the Javadoc &amp; the implementation stay in sync.
    //
    // If someone needs to have different SslRMIClientSocketFactory factories
    // with different underlying SSLSocketFactory objects using different key
    // and trust stores, he can always do so by subclassing this class and
    // overriding createSocket(String host, int port).
    //
<span class="fc" id="L203">    private static SocketFactory defaultSocketFactory = null;</span>

    private static synchronized SocketFactory getDefaultClientSocketFactory() {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (defaultSocketFactory == null)</span>
<span class="fc" id="L207">            defaultSocketFactory = SSLSocketFactory.getDefault();</span>
<span class="fc" id="L208">        return defaultSocketFactory;</span>
    }

    private static final long serialVersionUID = -8310631444933958385L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>