<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SynthTabbedPaneUI.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.synth</a> &gt; <span class="el_source">SynthTabbedPaneUI.java</span></div><h1>SynthTabbedPaneUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.plaf.synth;

import javax.swing.*;
import javax.swing.plaf.*;
import javax.swing.plaf.basic.*;
import javax.swing.text.View;

import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import sun.swing.SwingUtilities2;

/**
 * Provides the Synth L&amp;amp;F UI delegate for
 * {@link javax.swing.JTabbedPane}.
 *
 * &lt;p&gt;Looks up the {@code selectedTabPadInsets} property from the Style,
 * which represents additional insets for the selected tab.
 *
 * @author Scott Violet
 * @since 1.7
 */
<span class="nc" id="L49">public class SynthTabbedPaneUI extends BasicTabbedPaneUI</span>
                               implements PropertyChangeListener, SynthUI {

    /**
     * &lt;p&gt;If non-zero, tabOverlap indicates the amount that the tab bounds
     * should be altered such that they would overlap with a tab on either the
     * leading or trailing end of a run (ie: in TOP, this would be on the left
     * or right).&lt;/p&gt;

     * &lt;p&gt;A positive overlap indicates that tabs should overlap right/down,
     * while a negative overlap indicates tha tabs should overlap left/up.&lt;/p&gt;
     *
     * &lt;p&gt;When tabOverlap is specified, it both changes the x position and width
     * of the tab if in TOP or BOTTOM placement, and changes the y position and
     * height if in LEFT or RIGHT placement.&lt;/p&gt;
     *
     * &lt;p&gt;This is done for the following reason. Consider a run of 10 tabs.
     * There are 9 gaps between these tabs. If you specified a tabOverlap of
     * &quot;-1&quot;, then each of the tabs &quot;x&quot; values will be shifted left. This leaves
     * 9 pixels of space to the right of the right-most tab unpainted. So, each
     * tab's width is also extended by 1 pixel to make up the difference.&lt;/p&gt;
     *
     * &lt;p&gt;This property respects the RTL component orientation.&lt;/p&gt;
     */
<span class="nc" id="L73">    private int tabOverlap = 0;</span>

    /**
     * When a tabbed pane has multiple rows of tabs, this indicates whether
     * the tabs in the upper row(s) should extend to the base of the tab area,
     * or whether they should remain at their normal tab height. This does not
     * affect the bounds of the tabs, only the bounds of area painted by the
     * tabs. The text position does not change. The result is that the bottom
     * border of the upper row of tabs becomes fully obscured by the lower tabs,
     * resulting in a cleaner look.
     */
<span class="nc" id="L84">    private boolean extendTabsToBase = false;</span>

    private SynthContext tabAreaContext;
    private SynthContext tabContext;
    private SynthContext tabContentContext;

    private SynthStyle style;
    private SynthStyle tabStyle;
    private SynthStyle tabAreaStyle;
    private SynthStyle tabContentStyle;

<span class="nc" id="L95">    private Rectangle textRect = new Rectangle();</span>
<span class="nc" id="L96">    private Rectangle iconRect = new Rectangle();</span>

<span class="nc" id="L98">    private Rectangle tabAreaBounds = new Rectangle();</span>

    //added for the Nimbus look and feel, where the tab area is painted differently depending on the
    //state for the selected tab
<span class="nc" id="L102">    private boolean tabAreaStatesMatchSelectedTab = false;</span>
    //added for the Nimbus LAF to ensure that the labels don't move whether the tab is selected or not
<span class="nc" id="L104">    private boolean nudgeSelectedLabel = true;</span>

<span class="nc" id="L106">    private boolean selectedTabIsPressed = false;</span>

    /**
     * Creates a new UI object for the given component.
     *
     * @param c component to create UI object for
     * @return the UI object
     */
    public static ComponentUI createUI(JComponent c) {
<span class="nc" id="L115">        return new SynthTabbedPaneUI();</span>
    }

     private boolean scrollableTabLayoutEnabled() {
<span class="nc bnc" id="L119" title="All 2 branches missed.">        return (tabPane.getTabLayoutPolicy() == JTabbedPane.SCROLL_TAB_LAYOUT);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void installDefaults() {
<span class="nc" id="L127">        updateStyle(tabPane);</span>
<span class="nc" id="L128">    }</span>

    private void updateStyle(JTabbedPane c) {
<span class="nc" id="L131">        SynthContext context = getContext(c, ENABLED);</span>
<span class="nc" id="L132">        SynthStyle oldStyle = style;</span>
<span class="nc" id="L133">        style = SynthLookAndFeel.updateStyle(context, this);</span>
        // Add properties other than JComponent colors, Borders and
        // opacity settings here:
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (style != oldStyle) {</span>
<span class="nc" id="L137">            tabRunOverlay =</span>
<span class="nc" id="L138">                style.getInt(context, &quot;TabbedPane.tabRunOverlay&quot;, 0);</span>
<span class="nc" id="L139">            tabOverlap = style.getInt(context, &quot;TabbedPane.tabOverlap&quot;, 0);</span>
<span class="nc" id="L140">            extendTabsToBase = style.getBoolean(context,</span>
                    &quot;TabbedPane.extendTabsToBase&quot;, false);
<span class="nc" id="L142">            textIconGap = style.getInt(context, &quot;TabbedPane.textIconGap&quot;, 0);</span>
<span class="nc" id="L143">            selectedTabPadInsets = (Insets)style.get(context,</span>
                &quot;TabbedPane.selectedTabPadInsets&quot;);
<span class="nc bnc" id="L145" title="All 2 branches missed.">            if (selectedTabPadInsets == null) {</span>
<span class="nc" id="L146">                selectedTabPadInsets = new Insets(0, 0, 0, 0);</span>
            }
<span class="nc" id="L148">            tabAreaStatesMatchSelectedTab = style.getBoolean(context,</span>
                    &quot;TabbedPane.tabAreaStatesMatchSelectedTab&quot;, false);
<span class="nc" id="L150">            nudgeSelectedLabel = style.getBoolean(context,</span>
                    &quot;TabbedPane.nudgeSelectedLabel&quot;, true);
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (oldStyle != null) {</span>
<span class="nc" id="L153">                uninstallKeyboardActions();</span>
<span class="nc" id="L154">                installKeyboardActions();</span>
            }
        }
<span class="nc" id="L157">        context.dispose();</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (tabContext != null) {</span>
<span class="nc" id="L160">            tabContext.dispose();</span>
        }
<span class="nc" id="L162">        tabContext = getContext(c, Region.TABBED_PANE_TAB, ENABLED);</span>
<span class="nc" id="L163">        this.tabStyle = SynthLookAndFeel.updateStyle(tabContext, this);</span>
<span class="nc" id="L164">        tabInsets = tabStyle.getInsets(tabContext, null);</span>


<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (tabAreaContext != null) {</span>
<span class="nc" id="L168">            tabAreaContext.dispose();</span>
        }
<span class="nc" id="L170">        tabAreaContext = getContext(c, Region.TABBED_PANE_TAB_AREA, ENABLED);</span>
<span class="nc" id="L171">        this.tabAreaStyle = SynthLookAndFeel.updateStyle(tabAreaContext, this);</span>
<span class="nc" id="L172">        tabAreaInsets = tabAreaStyle.getInsets(tabAreaContext, null);</span>


<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (tabContentContext != null) {</span>
<span class="nc" id="L176">            tabContentContext.dispose();</span>
        }
<span class="nc" id="L178">        tabContentContext = getContext(c, Region.TABBED_PANE_CONTENT, ENABLED);</span>
<span class="nc" id="L179">        this.tabContentStyle = SynthLookAndFeel.updateStyle(tabContentContext,</span>
                                                            this);
<span class="nc" id="L181">        contentBorderInsets =</span>
<span class="nc" id="L182">            tabContentStyle.getInsets(tabContentContext, null);</span>
<span class="nc" id="L183">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void installListeners() {
<span class="nc" id="L190">        super.installListeners();</span>
<span class="nc" id="L191">        tabPane.addPropertyChangeListener(this);</span>
<span class="nc" id="L192">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void uninstallListeners() {
<span class="nc" id="L199">        super.uninstallListeners();</span>
<span class="nc" id="L200">        tabPane.removePropertyChangeListener(this);</span>
<span class="nc" id="L201">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void uninstallDefaults() {
<span class="nc" id="L208">        SynthContext context = getContext(tabPane, ENABLED);</span>
<span class="nc" id="L209">        style.uninstallDefaults(context);</span>
<span class="nc" id="L210">        context.dispose();</span>
<span class="nc" id="L211">        style = null;</span>

<span class="nc" id="L213">        tabStyle.uninstallDefaults(tabContext);</span>
<span class="nc" id="L214">        tabContext.dispose();</span>
<span class="nc" id="L215">        tabContext = null;</span>
<span class="nc" id="L216">        tabStyle = null;</span>

<span class="nc" id="L218">        tabAreaStyle.uninstallDefaults(tabAreaContext);</span>
<span class="nc" id="L219">        tabAreaContext.dispose();</span>
<span class="nc" id="L220">        tabAreaContext = null;</span>
<span class="nc" id="L221">        tabAreaStyle = null;</span>

<span class="nc" id="L223">        tabContentStyle.uninstallDefaults(tabContentContext);</span>
<span class="nc" id="L224">        tabContentContext.dispose();</span>
<span class="nc" id="L225">        tabContentContext = null;</span>
<span class="nc" id="L226">        tabContentStyle = null;</span>
<span class="nc" id="L227">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public SynthContext getContext(JComponent c) {
<span class="nc" id="L234">        return getContext(c, SynthLookAndFeel.getComponentState(c));</span>
    }

    private SynthContext getContext(JComponent c, int state) {
<span class="nc" id="L238">        return SynthContext.getContext(SynthContext.class, c,</span>
<span class="nc" id="L239">                    SynthLookAndFeel.getRegion(c),style, state);</span>
    }

    private SynthContext getContext(JComponent c, Region subregion, int state){
<span class="nc" id="L243">        SynthStyle style = null;</span>
<span class="nc" id="L244">        Class klass = SynthContext.class;</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (subregion == Region.TABBED_PANE_TAB) {</span>
<span class="nc" id="L247">            style = tabStyle;</span>
        }
<span class="nc bnc" id="L249" title="All 2 branches missed.">        else if (subregion == Region.TABBED_PANE_TAB_AREA) {</span>
<span class="nc" id="L250">            style = tabAreaStyle;</span>
        }
<span class="nc bnc" id="L252" title="All 2 branches missed.">        else if (subregion == Region.TABBED_PANE_CONTENT) {</span>
<span class="nc" id="L253">            style = tabContentStyle;</span>
        }
<span class="nc" id="L255">        return SynthContext.getContext(klass, c, subregion, style, state);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected JButton createScrollButton(int direction) {
        // added for Nimbus LAF so that it can use the basic arrow buttons
        // UIManager is queried directly here because this is called before
        // updateStyle is called so the style can not be queried directly
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (UIManager.getBoolean(&quot;TabbedPane.useBasicArrows&quot;)) {</span>
<span class="nc" id="L267">            JButton btn = super.createScrollButton(direction);</span>
<span class="nc" id="L268">            btn.setBorder(BorderFactory.createEmptyBorder());</span>
<span class="nc" id="L269">            return btn;</span>
        }
<span class="nc" id="L271">        return new SynthScrollableTabButton(direction);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void propertyChange(PropertyChangeEvent e) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (SynthLookAndFeel.shouldUpdateStyle(e)) {</span>
<span class="nc" id="L280">            updateStyle(tabPane);</span>
        }
<span class="nc" id="L282">    }</span>

    /**
     * {@inheritDoc}
     *
     * Overridden to keep track of whether the selected tab is also pressed.
     */
    @Override
    protected MouseListener createMouseListener() {
<span class="nc" id="L291">        final MouseListener delegate = super.createMouseListener();</span>
<span class="nc" id="L292">        final MouseMotionListener delegate2 = (MouseMotionListener)delegate;</span>
<span class="nc" id="L293">        return new MouseListener() {</span>
<span class="nc" id="L294">            public void mouseClicked(MouseEvent e) { delegate.mouseClicked(e); }</span>
<span class="nc" id="L295">            public void mouseEntered(MouseEvent e) { delegate.mouseEntered(e); }</span>
<span class="nc" id="L296">            public void mouseExited(MouseEvent e) { delegate.mouseExited(e); }</span>

            public void mousePressed(MouseEvent e) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (!tabPane.isEnabled()) {</span>
<span class="nc" id="L300">                    return;</span>
                }

<span class="nc" id="L303">                int tabIndex = tabForCoordinate(tabPane, e.getX(), e.getY());</span>
<span class="nc bnc" id="L304" title="All 4 branches missed.">                if (tabIndex &gt;= 0 &amp;&amp; tabPane.isEnabledAt(tabIndex)) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if (tabIndex == tabPane.getSelectedIndex()) {</span>
                        // Clicking on selected tab
<span class="nc" id="L307">                        selectedTabIsPressed = true;</span>
                        //TODO need to just repaint the tab area!
<span class="nc" id="L309">                        tabPane.repaint();</span>
                    }
                }

                //forward the event (this will set the selected index, or none at all
<span class="nc" id="L314">                delegate.mousePressed(e);</span>
<span class="nc" id="L315">            }</span>

            public void mouseReleased(MouseEvent e) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">                if (selectedTabIsPressed) {</span>
<span class="nc" id="L319">                    selectedTabIsPressed = false;</span>
                    //TODO need to just repaint the tab area!
<span class="nc" id="L321">                    tabPane.repaint();</span>
                }
                //forward the event
<span class="nc" id="L324">                delegate.mouseReleased(e);</span>

                //hack: The super method *should* be setting the mouse-over property correctly
                //here, but it doesn't. That is, when the mouse is released, whatever tab is below the
                //released mouse should be in rollover state. But, if you select a tab and don't
                //move the mouse, this doesn't happen. Hence, forwarding the event.
<span class="nc" id="L330">                delegate2.mouseMoved(e);</span>
<span class="nc" id="L331">            }</span>
        };
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected int getTabLabelShiftX(int tabPlacement, int tabIndex, boolean isSelected) {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (nudgeSelectedLabel) {</span>
<span class="nc" id="L341">            return super.getTabLabelShiftX(tabPlacement, tabIndex, isSelected);</span>
        } else {
<span class="nc" id="L343">            return 0;</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected int getTabLabelShiftY(int tabPlacement, int tabIndex, boolean isSelected) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (nudgeSelectedLabel) {</span>
<span class="nc" id="L353">            return super.getTabLabelShiftY(tabPlacement, tabIndex, isSelected);</span>
        } else {
<span class="nc" id="L355">            return 0;</span>
        }
    }

    /**
     * Notifies this UI delegate to repaint the specified component.
     * This method paints the component background, then calls
     * the {@link #paint(SynthContext,Graphics)} method.
     *
     * &lt;p&gt;In general, this method does not need to be overridden by subclasses.
     * All Look and Feel rendering code should reside in the {@code paint} method.
     *
     * @param g the {@code Graphics} object used for painting
     * @param c the component being painted
     * @see #paint(SynthContext,Graphics)
     */
    @Override
    public void update(Graphics g, JComponent c) {
<span class="nc" id="L373">        SynthContext context = getContext(c);</span>

<span class="nc" id="L375">        SynthLookAndFeel.update(context, g);</span>
<span class="nc" id="L376">        context.getPainter().paintTabbedPaneBackground(context,</span>
<span class="nc" id="L377">                          g, 0, 0, c.getWidth(), c.getHeight());</span>
<span class="nc" id="L378">        paint(context, g);</span>
<span class="nc" id="L379">        context.dispose();</span>
<span class="nc" id="L380">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected int getBaseline(int tab) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (tabPane.getTabComponentAt(tab) != null ||</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                getTextViewForTab(tab) != null) {</span>
<span class="nc" id="L389">            return super.getBaseline(tab);</span>
        }
<span class="nc" id="L391">        String title = tabPane.getTitleAt(tab);</span>
<span class="nc" id="L392">        Font font = tabContext.getStyle().getFont(tabContext);</span>
<span class="nc" id="L393">        FontMetrics metrics = getFontMetrics(font);</span>
<span class="nc" id="L394">        Icon icon = getIconForTab(tab);</span>
<span class="nc" id="L395">        textRect.setBounds(0, 0, 0, 0);</span>
<span class="nc" id="L396">        iconRect.setBounds(0, 0, 0, 0);</span>
<span class="nc" id="L397">        calcRect.setBounds(0, 0, Short.MAX_VALUE, maxTabHeight);</span>
<span class="nc" id="L398">        tabContext.getStyle().getGraphicsUtils(tabContext).layoutText(</span>
                tabContext, metrics, title, icon, SwingUtilities.CENTER,
                SwingUtilities.CENTER, SwingUtilities.LEADING,
                SwingUtilities.CENTER, calcRect,
                iconRect, textRect, textIconGap);
<span class="nc" id="L403">        return textRect.y + metrics.getAscent() + getBaselineOffset();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void paintBorder(SynthContext context, Graphics g, int x,
                            int y, int w, int h) {
<span class="nc" id="L412">        context.getPainter().paintTabbedPaneBorder(context, g, x, y, w, h);</span>
<span class="nc" id="L413">    }</span>

    /**
     * Paints the specified component according to the Look and Feel.
     * &lt;p&gt;This method is not used by Synth Look and Feel.
     * Painting is handled by the {@link #paint(SynthContext,Graphics)} method.
     *
     * @param g the {@code Graphics} object used for painting
     * @param c the component being painted
     * @see #paint(SynthContext,Graphics)
     */
    @Override
    public void paint(Graphics g, JComponent c) {
<span class="nc" id="L426">        SynthContext context = getContext(c);</span>

<span class="nc" id="L428">        paint(context, g);</span>
<span class="nc" id="L429">        context.dispose();</span>
<span class="nc" id="L430">    }</span>

    /**
     * Paints the specified component.
     *
     * @param context context for the component being painted
     * @param g the {@code Graphics} object used for painting
     * @see #update(Graphics,JComponent)
     */
    protected void paint(SynthContext context, Graphics g) {
<span class="nc" id="L440">        int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc" id="L441">        int tabPlacement = tabPane.getTabPlacement();</span>

<span class="nc" id="L443">        ensureCurrentLayout();</span>

        // Paint tab area
        // If scrollable tabs are enabled, the tab area will be
        // painted by the scrollable tab panel instead.
        //
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (!scrollableTabLayoutEnabled()) { // WRAP_TAB_LAYOUT</span>
<span class="nc" id="L450">            Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L451">            int x = insets.left;</span>
<span class="nc" id="L452">            int y = insets.top;</span>
<span class="nc" id="L453">            int width = tabPane.getWidth() - insets.left - insets.right;</span>
<span class="nc" id="L454">            int height = tabPane.getHeight() - insets.top - insets.bottom;</span>
            int size;
<span class="nc bnc" id="L456" title="All 4 branches missed.">            switch(tabPlacement) {</span>
            case LEFT:
<span class="nc" id="L458">                width = calculateTabAreaWidth(tabPlacement, runCount,</span>
                                              maxTabWidth);
<span class="nc" id="L460">                break;</span>
            case RIGHT:
<span class="nc" id="L462">                size = calculateTabAreaWidth(tabPlacement, runCount,</span>
                                             maxTabWidth);
<span class="nc" id="L464">                x = x + width - size;</span>
<span class="nc" id="L465">                width = size;</span>
<span class="nc" id="L466">                break;</span>
            case BOTTOM:
<span class="nc" id="L468">                size = calculateTabAreaHeight(tabPlacement, runCount,</span>
                                              maxTabHeight);
<span class="nc" id="L470">                y = y + height - size;</span>
<span class="nc" id="L471">                height = size;</span>
<span class="nc" id="L472">                break;</span>
            case TOP:
            default:
<span class="nc" id="L475">                height = calculateTabAreaHeight(tabPlacement, runCount,</span>
                                                maxTabHeight);
            }

<span class="nc" id="L479">            tabAreaBounds.setBounds(x, y, width, height);</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (g.getClipBounds().intersects(tabAreaBounds)) {</span>
<span class="nc" id="L482">                paintTabArea(tabAreaContext, g, tabPlacement,</span>
                         selectedIndex, tabAreaBounds);
            }
        }

        // Paint content border
<span class="nc" id="L488">        paintContentBorder(tabContentContext, g, tabPlacement, selectedIndex);</span>
<span class="nc" id="L489">    }</span>

    protected void paintTabArea(Graphics g, int tabPlacement,
                                int selectedIndex) {
        // This can be invoked from ScrollabeTabPanel
<span class="nc" id="L494">        Insets insets = tabPane.getInsets();</span>
<span class="nc" id="L495">        int x = insets.left;</span>
<span class="nc" id="L496">        int y = insets.top;</span>
<span class="nc" id="L497">        int width = tabPane.getWidth() - insets.left - insets.right;</span>
<span class="nc" id="L498">        int height = tabPane.getHeight() - insets.top - insets.bottom;</span>

<span class="nc" id="L500">        paintTabArea(tabAreaContext, g, tabPlacement, selectedIndex,</span>
                     new Rectangle(x, y, width, height));
<span class="nc" id="L502">    }</span>

    private void paintTabArea(SynthContext ss, Graphics g,
                                int tabPlacement, int selectedIndex,
                                Rectangle tabAreaBounds) {
<span class="nc" id="L507">        Rectangle clipRect = g.getClipBounds();</span>

        //if the tab area's states should match that of the selected tab, then
        //first update the selected tab's states, then set the state
        //for the tab area to match
        //otherwise, restore the tab area's state to ENABLED (which is the
        //only supported state otherwise).
<span class="nc bnc" id="L514" title="All 4 branches missed.">        if (tabAreaStatesMatchSelectedTab &amp;&amp; selectedIndex &gt;= 0) {</span>
<span class="nc" id="L515">            updateTabContext(selectedIndex, true, selectedTabIsPressed,</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                              (getRolloverTab() == selectedIndex),</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                              (getFocusIndex() == selectedIndex));</span>
<span class="nc" id="L518">            ss.setComponentState(tabContext.getComponentState());</span>
        } else {
<span class="nc" id="L520">            ss.setComponentState(SynthConstants.ENABLED);</span>
        }

        // Paint the tab area.
<span class="nc" id="L524">        SynthLookAndFeel.updateSubregion(ss, g, tabAreaBounds);</span>
<span class="nc" id="L525">        ss.getPainter().paintTabbedPaneTabAreaBackground(ss, g,</span>
             tabAreaBounds.x, tabAreaBounds.y, tabAreaBounds.width,
             tabAreaBounds.height, tabPlacement);
<span class="nc" id="L528">        ss.getPainter().paintTabbedPaneTabAreaBorder(ss, g, tabAreaBounds.x,</span>
             tabAreaBounds.y, tabAreaBounds.width, tabAreaBounds.height,
             tabPlacement);

<span class="nc" id="L532">        int tabCount = tabPane.getTabCount();</span>

<span class="nc" id="L534">        iconRect.setBounds(0, 0, 0, 0);</span>
<span class="nc" id="L535">        textRect.setBounds(0, 0, 0, 0);</span>

        // Paint tabRuns of tabs from back to front
<span class="nc bnc" id="L538" title="All 2 branches missed.">        for (int i = runCount - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L539">            int start = tabRuns[i];</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            int next = tabRuns[(i == runCount - 1)? 0 : i + 1];</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            int end = (next != 0? next - 1: tabCount - 1);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            for (int j = start; j &lt;= end; j++) {</span>
<span class="nc bnc" id="L543" title="All 4 branches missed.">                if (rects[j].intersects(clipRect) &amp;&amp; selectedIndex != j) {</span>
<span class="nc" id="L544">                    paintTab(tabContext, g, tabPlacement, rects, j, iconRect,</span>
                             textRect);
                }
            }
        }

<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (selectedIndex &gt;= 0) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (rects[selectedIndex].intersects(clipRect)) {</span>
<span class="nc" id="L552">                paintTab(tabContext, g, tabPlacement, rects, selectedIndex,</span>
                         iconRect, textRect);
            }
        }
<span class="nc" id="L556">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void setRolloverTab(int index) {
<span class="nc" id="L563">        int oldRolloverTab = getRolloverTab();</span>
<span class="nc" id="L564">        super.setRolloverTab(index);</span>

<span class="nc" id="L566">        Rectangle r = null;</span>

<span class="nc bnc" id="L568" title="All 4 branches missed.">        if (oldRolloverTab != index &amp;&amp; tabAreaStatesMatchSelectedTab) {</span>
            //TODO need to just repaint the tab area!
<span class="nc" id="L570">            tabPane.repaint();</span>
        } else {
<span class="nc bnc" id="L572" title="All 4 branches missed.">            if ((oldRolloverTab &gt;= 0) &amp;&amp; (oldRolloverTab &lt; tabPane.getTabCount())) {</span>
<span class="nc" id="L573">                r = getTabBounds(tabPane, oldRolloverTab);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L575">                    tabPane.repaint(r);</span>
                }
            }

<span class="nc bnc" id="L579" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="nc" id="L580">                r = getTabBounds(tabPane, index);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc" id="L582">                    tabPane.repaint(r);</span>
                }
            }
        }
<span class="nc" id="L586">    }</span>

    private void paintTab(SynthContext ss, Graphics g,
                            int tabPlacement, Rectangle[] rects, int tabIndex,
                            Rectangle iconRect, Rectangle textRect) {
<span class="nc" id="L591">        Rectangle tabRect = rects[tabIndex];</span>
<span class="nc" id="L592">        int selectedIndex = tabPane.getSelectedIndex();</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        boolean isSelected = selectedIndex == tabIndex;</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">        updateTabContext(tabIndex, isSelected, isSelected &amp;&amp; selectedTabIsPressed,</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                            (getRolloverTab() == tabIndex),</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                            (getFocusIndex() == tabIndex));</span>

<span class="nc" id="L598">        SynthLookAndFeel.updateSubregion(ss, g, tabRect);</span>
<span class="nc" id="L599">        int x = tabRect.x;</span>
<span class="nc" id="L600">        int y = tabRect.y;</span>
<span class="nc" id="L601">        int height = tabRect.height;</span>
<span class="nc" id="L602">        int width = tabRect.width;</span>
<span class="nc" id="L603">        int placement = tabPane.getTabPlacement();</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">        if (extendTabsToBase &amp;&amp; runCount &gt; 1) {</span>
            //paint this tab such that its edge closest to the base is equal to
            //edge of the selected tab closest to the base. In terms of the TOP
            //tab placement, this will cause the bottom of each tab to be
            //painted even with the bottom of the selected tab. This is because
            //in each tab placement (TOP, LEFT, BOTTOM, RIGHT) the selected tab
            //is closest to the base.
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (selectedIndex &gt;= 0) {</span>
<span class="nc" id="L612">                Rectangle r = rects[selectedIndex];</span>
<span class="nc bnc" id="L613" title="All 5 branches missed.">                switch (placement) {</span>
                    case TOP:
<span class="nc" id="L615">                        int bottomY = r.y + r.height;</span>
<span class="nc" id="L616">                        height = bottomY - tabRect.y;</span>
<span class="nc" id="L617">                        break;</span>
                    case LEFT:
<span class="nc" id="L619">                        int rightX = r.x + r.width;</span>
<span class="nc" id="L620">                        width = rightX - tabRect.x;</span>
<span class="nc" id="L621">                        break;</span>
                    case BOTTOM:
<span class="nc" id="L623">                        int topY = r.y;</span>
<span class="nc" id="L624">                        height = (tabRect.y + tabRect.height) - topY;</span>
<span class="nc" id="L625">                        y = topY;</span>
<span class="nc" id="L626">                        break;</span>
                    case RIGHT:
<span class="nc" id="L628">                        int leftX = r.x;</span>
<span class="nc" id="L629">                        width = (tabRect.x + tabRect.width) - leftX;</span>
<span class="nc" id="L630">                        x = leftX;</span>
                        break;
                }
            }
        }
<span class="nc" id="L635">        tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,</span>
                x, y, width, height, tabIndex, placement);
<span class="nc" id="L637">        tabContext.getPainter().paintTabbedPaneTabBorder(tabContext, g,</span>
                x, y, width, height, tabIndex, placement);

<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (tabPane.getTabComponentAt(tabIndex) == null) {</span>
<span class="nc" id="L641">            String title = tabPane.getTitleAt(tabIndex);</span>
<span class="nc" id="L642">            Font font = ss.getStyle().getFont(ss);</span>
<span class="nc" id="L643">            FontMetrics metrics = SwingUtilities2.getFontMetrics(tabPane, g, font);</span>
<span class="nc" id="L644">            Icon icon = getIconForTab(tabIndex);</span>

<span class="nc" id="L646">            layoutLabel(ss, tabPlacement, metrics, tabIndex, title, icon,</span>
                    tabRect, iconRect, textRect, isSelected);

<span class="nc" id="L649">            paintText(ss, g, tabPlacement, font, metrics,</span>
                    tabIndex, title, textRect, isSelected);

<span class="nc" id="L652">            paintIcon(g, tabPlacement, tabIndex, icon, iconRect, isSelected);</span>
        }
<span class="nc" id="L654">    }</span>

    private void layoutLabel(SynthContext ss, int tabPlacement,
                               FontMetrics metrics, int tabIndex,
                               String title, Icon icon,
                               Rectangle tabRect, Rectangle iconRect,
                               Rectangle textRect, boolean isSelected ) {
<span class="nc" id="L661">        View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L663">            tabPane.putClientProperty(&quot;html&quot;, v);</span>
        }

<span class="nc" id="L666">        textRect.x = textRect.y = iconRect.x = iconRect.y = 0;</span>

<span class="nc" id="L668">        ss.getStyle().getGraphicsUtils(ss).layoutText(ss, metrics, title,</span>
                         icon, SwingUtilities.CENTER, SwingUtilities.CENTER,
                         SwingUtilities.LEADING, SwingUtilities.CENTER,
                         tabRect, iconRect, textRect, textIconGap);

<span class="nc" id="L673">        tabPane.putClientProperty(&quot;html&quot;, null);</span>

<span class="nc" id="L675">        int xNudge = getTabLabelShiftX(tabPlacement, tabIndex, isSelected);</span>
<span class="nc" id="L676">        int yNudge = getTabLabelShiftY(tabPlacement, tabIndex, isSelected);</span>
<span class="nc" id="L677">        iconRect.x += xNudge;</span>
<span class="nc" id="L678">        iconRect.y += yNudge;</span>
<span class="nc" id="L679">        textRect.x += xNudge;</span>
<span class="nc" id="L680">        textRect.y += yNudge;</span>
<span class="nc" id="L681">    }</span>

    private void paintText(SynthContext ss,
                             Graphics g, int tabPlacement,
                             Font font, FontMetrics metrics, int tabIndex,
                             String title, Rectangle textRect,
                             boolean isSelected) {
<span class="nc" id="L688">        g.setFont(font);</span>

<span class="nc" id="L690">        View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (v != null) {</span>
            // html
<span class="nc" id="L693">            v.paint(g, textRect);</span>
        } else {
            // plain text
<span class="nc" id="L696">            int mnemIndex = tabPane.getDisplayedMnemonicIndexAt(tabIndex);</span>

<span class="nc" id="L698">            g.setColor(ss.getStyle().getColor(ss, ColorType.TEXT_FOREGROUND));</span>
<span class="nc" id="L699">            ss.getStyle().getGraphicsUtils(ss).paintText(ss, g, title,</span>
                                  textRect, mnemIndex);
        }
<span class="nc" id="L702">    }</span>


    private void paintContentBorder(SynthContext ss, Graphics g,
                                      int tabPlacement, int selectedIndex) {
<span class="nc" id="L707">        int width = tabPane.getWidth();</span>
<span class="nc" id="L708">        int height = tabPane.getHeight();</span>
<span class="nc" id="L709">        Insets insets = tabPane.getInsets();</span>

<span class="nc" id="L711">        int x = insets.left;</span>
<span class="nc" id="L712">        int y = insets.top;</span>
<span class="nc" id="L713">        int w = width - insets.right - insets.left;</span>
<span class="nc" id="L714">        int h = height - insets.top - insets.bottom;</span>

<span class="nc bnc" id="L716" title="All 4 branches missed.">        switch(tabPlacement) {</span>
          case LEFT:
<span class="nc" id="L718">              x += calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L719">              w -= (x - insets.left);</span>
<span class="nc" id="L720">              break;</span>
          case RIGHT:
<span class="nc" id="L722">              w -= calculateTabAreaWidth(tabPlacement, runCount, maxTabWidth);</span>
<span class="nc" id="L723">              break;</span>
          case BOTTOM:
<span class="nc" id="L725">              h -= calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L726">              break;</span>
          case TOP:
          default:
<span class="nc" id="L729">              y += calculateTabAreaHeight(tabPlacement, runCount, maxTabHeight);</span>
<span class="nc" id="L730">              h -= (y - insets.top);</span>
        }
<span class="nc" id="L732">        SynthLookAndFeel.updateSubregion(ss, g, new Rectangle(x, y, w, h));</span>
<span class="nc" id="L733">        ss.getPainter().paintTabbedPaneContentBackground(ss, g, x, y,</span>
                                                           w, h);
<span class="nc" id="L735">        ss.getPainter().paintTabbedPaneContentBorder(ss, g, x, y, w, h);</span>
<span class="nc" id="L736">    }</span>

    private void ensureCurrentLayout() {
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (!tabPane.isValid()) {</span>
<span class="nc" id="L740">            tabPane.validate();</span>
        }
        /* If tabPane doesn't have a peer yet, the validate() call will
         * silently fail.  We handle that by forcing a layout if tabPane
         * is still invalid.  See bug 4237677.
         */
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (!tabPane.isValid()) {</span>
<span class="nc" id="L747">            TabbedPaneLayout layout = (TabbedPaneLayout)tabPane.getLayout();</span>
<span class="nc" id="L748">            layout.calculateLayoutInfo();</span>
        }
<span class="nc" id="L750">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected int calculateMaxTabHeight(int tabPlacement) {
<span class="nc" id="L757">        FontMetrics metrics = getFontMetrics(tabContext.getStyle().getFont(</span>
                                             tabContext));
<span class="nc" id="L759">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L760">        int result = 0;</span>
<span class="nc" id="L761">        int fontHeight = metrics.getHeight();</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">        for(int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L763">            result = Math.max(calculateTabHeight(tabPlacement, i, fontHeight), result);</span>
        }
<span class="nc" id="L765">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected int calculateTabWidth(int tabPlacement, int tabIndex,
                                    FontMetrics metrics) {
<span class="nc" id="L774">        Icon icon = getIconForTab(tabIndex);</span>
<span class="nc" id="L775">        Insets tabInsets = getTabInsets(tabPlacement, tabIndex);</span>
<span class="nc" id="L776">        int width = tabInsets.left + tabInsets.right;</span>
<span class="nc" id="L777">        Component tabComponent = tabPane.getTabComponentAt(tabIndex);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (tabComponent != null) {</span>
<span class="nc" id="L779">            width += tabComponent.getPreferredSize().width;</span>
        } else {
<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (icon != null) {</span>
<span class="nc" id="L782">                width += icon.getIconWidth() + textIconGap;</span>
            }
<span class="nc" id="L784">            View v = getTextViewForTab(tabIndex);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (v != null) {</span>
                // html
<span class="nc" id="L787">                width += (int) v.getPreferredSpan(View.X_AXIS);</span>
            } else {
                // plain text
<span class="nc" id="L790">                String title = tabPane.getTitleAt(tabIndex);</span>
<span class="nc" id="L791">                width += tabContext.getStyle().getGraphicsUtils(tabContext).</span>
<span class="nc" id="L792">                        computeStringWidth(tabContext, metrics.getFont(),</span>
                                metrics, title);
            }
        }
<span class="nc" id="L796">        return width;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected int calculateMaxTabWidth(int tabPlacement) {
<span class="nc" id="L804">        FontMetrics metrics = getFontMetrics(tabContext.getStyle().getFont(</span>
                                     tabContext));
<span class="nc" id="L806">        int tabCount = tabPane.getTabCount();</span>
<span class="nc" id="L807">        int result = 0;</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        for(int i = 0; i &lt; tabCount; i++) {</span>
<span class="nc" id="L809">            result = Math.max(calculateTabWidth(tabPlacement, i, metrics),</span>
                              result);
        }
<span class="nc" id="L812">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected Insets getTabInsets(int tabPlacement, int tabIndex) {
<span class="nc" id="L820">        updateTabContext(tabIndex, false, false, false,</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                          (getFocusIndex() == tabIndex));</span>
<span class="nc" id="L822">        return tabInsets;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected FontMetrics getFontMetrics() {
<span class="nc" id="L830">        return getFontMetrics(tabContext.getStyle().getFont(tabContext));</span>
    }

    private FontMetrics getFontMetrics(Font font) {
<span class="nc" id="L834">        return tabPane.getFontMetrics(font);</span>
    }

    private void updateTabContext(int index, boolean selected,
                                  boolean isMouseDown, boolean isMouseOver, boolean hasFocus) {
<span class="nc" id="L839">        int state = 0;</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">        if (!tabPane.isEnabled() || !tabPane.isEnabledAt(index)) {</span>
<span class="nc" id="L841">            state |= SynthConstants.DISABLED;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (selected) {</span>
<span class="nc" id="L843">                state |= SynthConstants.SELECTED;</span>
            }
        }
<span class="nc bnc" id="L846" title="All 2 branches missed.">        else if (selected) {</span>
<span class="nc" id="L847">            state |= (SynthConstants.ENABLED | SynthConstants.SELECTED);</span>
<span class="nc bnc" id="L848" title="All 4 branches missed.">            if (isMouseOver &amp;&amp; UIManager.getBoolean(&quot;TabbedPane.isTabRollover&quot;)) {</span>
<span class="nc" id="L849">                state |= SynthConstants.MOUSE_OVER;</span>
            }
        }
<span class="nc bnc" id="L852" title="All 2 branches missed.">        else if (isMouseOver) {</span>
<span class="nc" id="L853">            state |= (SynthConstants.ENABLED | SynthConstants.MOUSE_OVER);</span>
        }
        else {
<span class="nc" id="L856">            state = SynthLookAndFeel.getComponentState(tabPane);</span>
<span class="nc" id="L857">            state &amp;= ~SynthConstants.FOCUSED; // don't use tabbedpane focus state</span>
        }
<span class="nc bnc" id="L859" title="All 4 branches missed.">        if (hasFocus &amp;&amp; tabPane.hasFocus()) {</span>
<span class="nc" id="L860">            state |= SynthConstants.FOCUSED; // individual tab has focus</span>
        }
<span class="nc bnc" id="L862" title="All 2 branches missed.">        if (isMouseDown) {</span>
<span class="nc" id="L863">            state |= SynthConstants.PRESSED;</span>
        }

<span class="nc" id="L866">        tabContext.setComponentState(state);</span>
<span class="nc" id="L867">    }</span>

    /**
     * {@inheritDoc}
     *
     * Overridden to create a TabbedPaneLayout subclass which takes into
     * account tabOverlap.
     */
    @Override
    protected LayoutManager createLayoutManager() {
<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (tabPane.getTabLayoutPolicy() == JTabbedPane.SCROLL_TAB_LAYOUT) {</span>
<span class="nc" id="L878">            return super.createLayoutManager();</span>
        } else { /* WRAP_TAB_LAYOUT */
<span class="nc" id="L880">            return new TabbedPaneLayout() {</span>
                @Override
                public void calculateLayoutInfo() {
<span class="nc" id="L883">                    super.calculateLayoutInfo();</span>
                    //shift all the tabs, if necessary
<span class="nc bnc" id="L885" title="All 2 branches missed.">                    if (tabOverlap != 0) {</span>
<span class="nc" id="L886">                        int tabCount = tabPane.getTabCount();</span>
                        //left-to-right/right-to-left only affects layout
                        //when placement is TOP or BOTTOM
<span class="nc" id="L889">                        boolean ltr = tabPane.getComponentOrientation().isLeftToRight();</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                        for (int i = runCount - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L891">                            int start = tabRuns[i];</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">                            int next = tabRuns[(i == runCount - 1)? 0 : i + 1];</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                            int end = (next != 0? next - 1: tabCount - 1);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                            for (int j = start+1; j &lt;= end; j++) {</span>
                                // xshift and yshift represent the amount &amp;
                                // direction to shift the tab in their
                                // respective axis.
<span class="nc" id="L898">                                int xshift = 0;</span>
<span class="nc" id="L899">                                int yshift = 0;</span>
                                // configure xshift and y shift based on tab
                                // position and ltr/rtl
<span class="nc bnc" id="L902" title="All 3 branches missed.">                                switch (tabPane.getTabPlacement()) {</span>
                                    case JTabbedPane.TOP:
                                    case JTabbedPane.BOTTOM:
<span class="nc bnc" id="L905" title="All 2 branches missed.">                                        xshift = ltr ? tabOverlap : -tabOverlap;</span>
<span class="nc" id="L906">                                        break;</span>
                                    case JTabbedPane.LEFT:
                                    case JTabbedPane.RIGHT:
<span class="nc" id="L909">                                        yshift = tabOverlap;</span>
<span class="nc" id="L910">                                        break;</span>
                                    default: //do nothing
                                }
<span class="nc" id="L913">                                rects[j].x += xshift;</span>
<span class="nc" id="L914">                                rects[j].y += yshift;</span>
<span class="nc" id="L915">                                rects[j].width += Math.abs(xshift);</span>
<span class="nc" id="L916">                                rects[j].height += Math.abs(yshift);</span>
                            }
                        }
                    }
<span class="nc" id="L920">                }</span>
            };
        }
    }

<span class="nc" id="L925">    private class SynthScrollableTabButton extends SynthArrowButton implements</span>
            UIResource {
<span class="nc" id="L927">        public SynthScrollableTabButton(int direction) {</span>
<span class="nc" id="L928">            super(direction);</span>
<span class="nc" id="L929">            setName(&quot;TabbedPane.button&quot;);</span>
<span class="nc" id="L930">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>