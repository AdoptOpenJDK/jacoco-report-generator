<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SynthComboBoxUI.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.synth</a> &gt; <span class="el_source">SynthComboBoxUI.java</span></div><h1>SynthComboBoxUI.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.plaf.synth;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.plaf.*;
import javax.swing.event.*;
import javax.swing.plaf.basic.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;

/**
 * Provides the Synth L&amp;amp;F UI delegate for
 * {@link javax.swing.JComboBox}.
 *
 * @author Scott Violet
 * @since 1.7
 */
<span class="nc" id="L44">public class SynthComboBoxUI extends BasicComboBoxUI implements</span>
                              PropertyChangeListener, SynthUI {
    private SynthStyle style;
    private boolean useListColors;

    /**
     * Used to adjust the location and size of the popup. Very useful for
     * situations such as we find in Nimbus where part of the border is used
     * to paint the focus. In such cases, the border is empty space, and not
     * part of the &quot;visual&quot; border, and in these cases, you'd like the popup
     * to be adjusted such that it looks as if it were next to the visual border.
     * You may want to use negative insets to get the right look.
     */
    Insets popupInsets;

    /**
     * This flag may be set via UIDefaults. By default, it is false, to
     * preserve backwards compatibility. If true, then the combo will
     * &quot;act as a button&quot; when it is not editable.
     */
    private boolean buttonWhenNotEditable;

    /**
     * A flag to indicate that the combo box and combo box button should
     * remain in the PRESSED state while the combo popup is visible.
     */
    private boolean pressedWhenPopupVisible;

    /**
     * When buttonWhenNotEditable is true, this field is used to help make
     * the combo box appear and function as a button when the combo box is
     * not editable. In such a state, you can click anywhere on the button
     * to get it to open the popup. Also, anywhere you hover over the combo
     * will cause the entire combo to go into &quot;rollover&quot; state, and anywhere
     * you press will go into &quot;pressed&quot; state. This also keeps in sync the
     * state of the combo and the arrowButton.
     */
    private ButtonHandler buttonHandler;

    /**
     * Handler for repainting combo when editor component gains/looses focus
     */
    private EditorFocusHandler editorFocusHandler;

    /**
     * If true, then the cell renderer will be forced to be non-opaque when
     * used for rendering the selected item in the combo box (not in the list),
     * and forced to opaque after rendering the selected value.
     */
<span class="nc" id="L93">    private boolean forceOpaque = false;</span>

    /**
     * Creates a new UI object for the given component.
     *
     * @param c component to create UI object for
     * @return the UI object
     */
    public static ComponentUI createUI(JComponent c) {
<span class="nc" id="L102">        return new SynthComboBoxUI();</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to ensure that ButtonHandler is created prior to any of
     * the other installXXX methods, since several of them reference
     * buttonHandler.
     */
    @Override
    public void installUI(JComponent c) {
<span class="nc" id="L114">        buttonHandler = new ButtonHandler();</span>
<span class="nc" id="L115">        super.installUI(c);</span>
<span class="nc" id="L116">    }</span>

    @Override
    protected void installDefaults() {
<span class="nc" id="L120">        updateStyle(comboBox);</span>
<span class="nc" id="L121">    }</span>

    private void updateStyle(JComboBox comboBox) {
<span class="nc" id="L124">        SynthStyle oldStyle = style;</span>
<span class="nc" id="L125">        SynthContext context = getContext(comboBox, ENABLED);</span>

<span class="nc" id="L127">        style = SynthLookAndFeel.updateStyle(context, this);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (style != oldStyle) {</span>
<span class="nc" id="L129">            padding = (Insets) style.get(context, &quot;ComboBox.padding&quot;);</span>
<span class="nc" id="L130">            popupInsets = (Insets)style.get(context, &quot;ComboBox.popupInsets&quot;);</span>
<span class="nc" id="L131">            useListColors = style.getBoolean(context,</span>
                    &quot;ComboBox.rendererUseListColors&quot;, true);
<span class="nc" id="L133">            buttonWhenNotEditable = style.getBoolean(context,</span>
                    &quot;ComboBox.buttonWhenNotEditable&quot;, false);
<span class="nc" id="L135">            pressedWhenPopupVisible = style.getBoolean(context,</span>
                    &quot;ComboBox.pressedWhenPopupVisible&quot;, false);
<span class="nc" id="L137">            squareButton = style.getBoolean(context,</span>
                    &quot;ComboBox.squareButton&quot;, true);

<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (oldStyle != null) {</span>
<span class="nc" id="L141">                uninstallKeyboardActions();</span>
<span class="nc" id="L142">                installKeyboardActions();</span>
            }
<span class="nc" id="L144">            forceOpaque = style.getBoolean(context,</span>
                    &quot;ComboBox.forceOpaque&quot;, false);
        }
<span class="nc" id="L147">        context.dispose();</span>

<span class="nc bnc" id="L149" title="All 2 branches missed.">        if(listBox != null) {</span>
<span class="nc" id="L150">            SynthLookAndFeel.updateStyles(listBox);</span>
        }
<span class="nc" id="L152">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void installListeners() {
<span class="nc" id="L159">        comboBox.addPropertyChangeListener(this);</span>
<span class="nc" id="L160">        comboBox.addMouseListener(buttonHandler);</span>
<span class="nc" id="L161">        editorFocusHandler = new EditorFocusHandler(comboBox);</span>
<span class="nc" id="L162">        super.installListeners();</span>
<span class="nc" id="L163">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void uninstallUI(JComponent c) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (popup instanceof SynthComboPopup) {</span>
<span class="nc" id="L171">            ((SynthComboPopup)popup).removePopupMenuListener(buttonHandler);</span>
        }
<span class="nc" id="L173">        super.uninstallUI(c);</span>
<span class="nc" id="L174">        buttonHandler = null;</span>
<span class="nc" id="L175">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void uninstallDefaults() {
<span class="nc" id="L182">        SynthContext context = getContext(comboBox, ENABLED);</span>

<span class="nc" id="L184">        style.uninstallDefaults(context);</span>
<span class="nc" id="L185">        context.dispose();</span>
<span class="nc" id="L186">        style = null;</span>
<span class="nc" id="L187">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void uninstallListeners() {
<span class="nc" id="L194">        editorFocusHandler.unregister();</span>
<span class="nc" id="L195">        comboBox.removePropertyChangeListener(this);</span>
<span class="nc" id="L196">        comboBox.removeMouseListener(buttonHandler);</span>
<span class="nc" id="L197">        buttonHandler.pressed = false;</span>
<span class="nc" id="L198">        buttonHandler.over = false;</span>
<span class="nc" id="L199">        super.uninstallListeners();</span>
<span class="nc" id="L200">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public SynthContext getContext(JComponent c) {
<span class="nc" id="L207">        return getContext(c, getComponentState(c));</span>
    }

    private SynthContext getContext(JComponent c, int state) {
<span class="nc" id="L211">        return SynthContext.getContext(SynthContext.class, c,</span>
<span class="nc" id="L212">                    SynthLookAndFeel.getRegion(c), style, state);</span>
    }

    private int getComponentState(JComponent c) {
        // currently we have a broken situation where if a developer
        // takes the border from a JComboBox and sets it on a JTextField
        // then the codepath will eventually lead back to this method
        // but pass in a JTextField instead of JComboBox! In case this
        // happens, we just return the normal synth state for the component
        // instead of doing anything special
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (!(c instanceof JComboBox)) return SynthLookAndFeel.getComponentState(c);</span>

<span class="nc" id="L224">        JComboBox box = (JComboBox)c;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (shouldActLikeButton()) {</span>
<span class="nc" id="L226">            int state = ENABLED;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if ((!c.isEnabled())) {</span>
<span class="nc" id="L228">                state = DISABLED;</span>
            }
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (buttonHandler.isPressed()) {</span>
<span class="nc" id="L231">                state |= PRESSED;</span>
            }
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (buttonHandler.isRollover()) {</span>
<span class="nc" id="L234">                state |= MOUSE_OVER;</span>
            }
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (box.isFocusOwner()) {</span>
<span class="nc" id="L237">                state |= FOCUSED;</span>
            }
<span class="nc" id="L239">            return state;</span>
        } else {
            // for editable combos the editor component has the focus not the
            // combo box its self, so we should make the combo paint focused
            // when its editor has focus
<span class="nc" id="L244">            int basicState = SynthLookAndFeel.getComponentState(c);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (box.isEditable() &amp;&amp;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                     box.getEditor().getEditorComponent().isFocusOwner()) {</span>
<span class="nc" id="L247">                basicState |= FOCUSED;</span>
            }
<span class="nc" id="L249">            return basicState;</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected ComboPopup createPopup() {
<span class="nc" id="L258">        SynthComboPopup p = new SynthComboPopup(comboBox);</span>
<span class="nc" id="L259">        p.addPopupMenuListener(buttonHandler);</span>
<span class="nc" id="L260">        return p;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected ListCellRenderer createRenderer() {
<span class="nc" id="L268">        return new SynthComboBoxRenderer();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected ComboBoxEditor createEditor() {
<span class="nc" id="L276">        return new SynthComboBoxEditor();</span>
    }

    //
    // end UI Initialization
    //======================

    /**
     * {@inheritDoc}
     */
    @Override
    public void propertyChange(PropertyChangeEvent e) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (SynthLookAndFeel.shouldUpdateStyle(e)) {</span>
<span class="nc" id="L289">            updateStyle(comboBox);</span>
        }
<span class="nc" id="L291">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected JButton createArrowButton() {
<span class="nc" id="L298">        SynthArrowButton button = new SynthArrowButton(SwingConstants.SOUTH);</span>
<span class="nc" id="L299">        button.setName(&quot;ComboBox.arrowButton&quot;);</span>
<span class="nc" id="L300">        button.setModel(buttonHandler);</span>
<span class="nc" id="L301">        return button;</span>
    }

    //=================================
    // begin ComponentUI Implementation

    /**
     * Notifies this UI delegate to repaint the specified component.
     * This method paints the component background, then calls
     * the {@link #paint(SynthContext,Graphics)} method.
     *
     * &lt;p&gt;In general, this method does not need to be overridden by subclasses.
     * All Look and Feel rendering code should reside in the {@code paint} method.
     *
     * @param g the {@code Graphics} object used for painting
     * @param c the component being painted
     * @see #paint(SynthContext,Graphics)
     */
    @Override
    public void update(Graphics g, JComponent c) {
<span class="nc" id="L321">        SynthContext context = getContext(c);</span>

<span class="nc" id="L323">        SynthLookAndFeel.update(context, g);</span>
<span class="nc" id="L324">        context.getPainter().paintComboBoxBackground(context, g, 0, 0,</span>
<span class="nc" id="L325">                                                  c.getWidth(), c.getHeight());</span>
<span class="nc" id="L326">        paint(context, g);</span>
<span class="nc" id="L327">        context.dispose();</span>
<span class="nc" id="L328">    }</span>

    /**
     * Paints the specified component according to the Look and Feel.
     * &lt;p&gt;This method is not used by Synth Look and Feel.
     * Painting is handled by the {@link #paint(SynthContext,Graphics)} method.
     *
     * @param g the {@code Graphics} object used for painting
     * @param c the component being painted
     * @see #paint(SynthContext,Graphics)
     */
    @Override
    public void paint(Graphics g, JComponent c) {
<span class="nc" id="L341">        SynthContext context = getContext(c);</span>

<span class="nc" id="L343">        paint(context, g);</span>
<span class="nc" id="L344">        context.dispose();</span>
<span class="nc" id="L345">    }</span>

    /**
     * Paints the specified component.
     *
     * @param context context for the component being painted
     * @param g the {@code Graphics} object used for painting
     * @see #update(Graphics,JComponent)
     */
    protected void paint(SynthContext context, Graphics g) {
<span class="nc" id="L355">        hasFocus = comboBox.hasFocus();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if ( !comboBox.isEditable() ) {</span>
<span class="nc" id="L357">            Rectangle r = rectangleForCurrentValue();</span>
<span class="nc" id="L358">            paintCurrentValue(g,r,hasFocus);</span>
        }
<span class="nc" id="L360">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void paintBorder(SynthContext context, Graphics g, int x,
                            int y, int w, int h) {
<span class="nc" id="L368">        context.getPainter().paintComboBoxBorder(context, g, x, y, w, h);</span>
<span class="nc" id="L369">    }</span>

    /**
     * Paints the currently selected item.
     */
    @Override
    public void paintCurrentValue(Graphics g,Rectangle bounds,boolean hasFocus) {
<span class="nc" id="L376">        ListCellRenderer renderer = comboBox.getRenderer();</span>
        Component c;

<span class="nc" id="L379">        c = renderer.getListCellRendererComponent(</span>
<span class="nc" id="L380">                listBox, comboBox.getSelectedItem(), -1, false, false );</span>

        // Fix for 4238829: should lay out the JPanel.
<span class="nc" id="L383">        boolean shouldValidate = false;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (c instanceof JPanel)  {</span>
<span class="nc" id="L385">            shouldValidate = true;</span>
        }

<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (c instanceof UIResource) {</span>
<span class="nc" id="L389">            c.setName(&quot;ComboBox.renderer&quot;);</span>
        }

<span class="nc bnc" id="L392" title="All 4 branches missed.">        boolean force = forceOpaque &amp;&amp; c instanceof JComponent;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (force) {</span>
<span class="nc" id="L394">            ((JComponent)c).setOpaque(false);</span>
        }

<span class="nc" id="L397">        int x = bounds.x, y = bounds.y, w = bounds.width, h = bounds.height;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (padding != null) {</span>
<span class="nc" id="L399">            x = bounds.x + padding.left;</span>
<span class="nc" id="L400">            y = bounds.y + padding.top;</span>
<span class="nc" id="L401">            w = bounds.width - (padding.left + padding.right);</span>
<span class="nc" id="L402">            h = bounds.height - (padding.top + padding.bottom);</span>
        }

<span class="nc" id="L405">        currentValuePane.paintComponent(g, c, comboBox, x, y, w, h, shouldValidate);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (force) {</span>
<span class="nc" id="L408">            ((JComponent)c).setOpaque(true);</span>
        }
<span class="nc" id="L410">    }</span>

    /**
     * @return true if this combo box should act as one big button. Typically
     * only happens when buttonWhenNotEditable is true, and comboBox.isEditable
     * is false.
     */
    private boolean shouldActLikeButton() {
<span class="nc bnc" id="L418" title="All 4 branches missed.">        return buttonWhenNotEditable &amp;&amp; !comboBox.isEditable();</span>
    }

    /**
     * Returns the default size of an empty display area of the combo box using
     * the current renderer and font.
     *
     * This method was overridden to use SynthComboBoxRenderer instead of
     * DefaultListCellRenderer as the default renderer when calculating the
     * size of the combo box. This is used in the case of the combo not having
     * any data.
     *
     * @return the size of an empty display area
     * @see #getDisplaySize
     */
    @Override
    protected Dimension getDefaultSize() {
<span class="nc" id="L435">        SynthComboBoxRenderer r = new SynthComboBoxRenderer();</span>
<span class="nc" id="L436">        Dimension d = getSizeForComponent(r.getListCellRendererComponent(listBox, &quot; &quot;, -1, false, false));</span>
<span class="nc" id="L437">        return new Dimension(d.width, d.height);</span>
    }

    /**
     * From BasicComboBoxRenderer v 1.18.
     *
     * Be aware that SynthFileChooserUIImpl relies on the fact that the default
     * renderer installed on a Synth combo box is a JLabel. If this is changed,
     * then an assert will fail in SynthFileChooserUIImpl
     */
    private class SynthComboBoxRenderer extends JLabel implements ListCellRenderer&lt;Object&gt;, UIResource {
<span class="nc" id="L448">        public SynthComboBoxRenderer() {</span>
<span class="nc" id="L449">            super();</span>
<span class="nc" id="L450">            setText(&quot; &quot;);</span>
<span class="nc" id="L451">        }</span>

        @Override
        public String getName() {
            // SynthComboBoxRenderer should have installed Name while constructor is working.
            // The setName invocation in the SynthComboBoxRenderer() constructor doesn't work
            // because of the opaque property is installed in the constructor based on the
            // component name (see GTKStyle.isOpaque())
<span class="nc" id="L459">            String name = super.getName();</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">            return name == null ? &quot;ComboBox.renderer&quot; : name;</span>
        }

        @Override
        public Component getListCellRendererComponent(JList&lt;?&gt; list, Object value,
                         int index, boolean isSelected, boolean cellHasFocus) {
<span class="nc" id="L467">            setName(&quot;ComboBox.listRenderer&quot;);</span>
<span class="nc" id="L468">            SynthLookAndFeel.resetSelectedUI();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (isSelected) {</span>
<span class="nc" id="L470">                setBackground(list.getSelectionBackground());</span>
<span class="nc" id="L471">                setForeground(list.getSelectionForeground());</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (!useListColors) {</span>
<span class="nc" id="L473">                    SynthLookAndFeel.setSelectedUI(</span>
<span class="nc" id="L474">                         (SynthLabelUI)SynthLookAndFeel.getUIOfType(getUI(),</span>
                         SynthLabelUI.class), isSelected, cellHasFocus,
<span class="nc" id="L476">                         list.isEnabled(), false);</span>
                }
            } else {
<span class="nc" id="L479">                setBackground(list.getBackground());</span>
<span class="nc" id="L480">                setForeground(list.getForeground());</span>
            }

<span class="nc" id="L483">            setFont(list.getFont());</span>

<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (value instanceof Icon) {</span>
<span class="nc" id="L486">                setIcon((Icon)value);</span>
<span class="nc" id="L487">                setText(&quot;&quot;);</span>
            } else {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                String text = (value == null) ? &quot; &quot; : value.toString();</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (&quot;&quot;.equals(text)) {</span>
<span class="nc" id="L492">                    text = &quot; &quot;;</span>
                }
<span class="nc" id="L494">                setText(text);</span>
            }

            // The renderer component should inherit the enabled and
            // orientation state of its parent combobox.  This is
            // especially needed for GTK comboboxes, where the
            // ListCellRenderer's state determines the visual state
            // of the combobox.
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (comboBox != null){</span>
<span class="nc" id="L503">                setEnabled(comboBox.isEnabled());</span>
<span class="nc" id="L504">                setComponentOrientation(comboBox.getComponentOrientation());</span>
            }

<span class="nc" id="L507">            return this;</span>
        }

        @Override
        public void paint(Graphics g) {
<span class="nc" id="L512">            super.paint(g);</span>
<span class="nc" id="L513">            SynthLookAndFeel.resetSelectedUI();</span>
<span class="nc" id="L514">        }</span>
    }


<span class="nc" id="L518">    private static class SynthComboBoxEditor</span>
            extends BasicComboBoxEditor.UIResource {

        @Override public JTextField createEditorComponent() {
<span class="nc" id="L522">            JTextField f = new JTextField(&quot;&quot;, 9);</span>
<span class="nc" id="L523">            f.setName(&quot;ComboBox.textField&quot;);</span>
<span class="nc" id="L524">            return f;</span>
        }
    }


    /**
     * Handles all the logic for treating the combo as a button when it is
     * not editable, and when shouldActLikeButton() is true. This class is a
     * special ButtonModel, and installed on the arrowButton when appropriate.
     * It also is installed as a mouse listener and mouse motion listener on
     * the combo box. In this way, the state between the button and combo
     * are in sync. Whenever one is &quot;over&quot; both are. Whenever one is pressed,
     * both are.
     */
<span class="nc" id="L538">    private final class ButtonHandler extends DefaultButtonModel</span>
            implements MouseListener, PopupMenuListener {
        /**
         * Indicates that the mouse is over the combo or the arrow button.
         * This field only has meaning if buttonWhenNotEnabled is true.
         */
        private boolean over;
        /**
         * Indicates that the combo or arrow button has been pressed. This
         * field only has meaning if buttonWhenNotEnabled is true.
         */
        private boolean pressed;

        //------------------------------------------------------------------
        // State Methods
        //------------------------------------------------------------------

        /**
         * &lt;p&gt;Updates the internal &quot;pressed&quot; state. If shouldActLikeButton()
         * is true, and if this method call will change the internal state,
         * then the combo and button will be repainted.&lt;/p&gt;
         *
         * &lt;p&gt;Note that this method is called either when a press event
         * occurs on the combo box, or on the arrow button.&lt;/p&gt;
         */
        private void updatePressed(boolean p) {
<span class="nc bnc" id="L564" title="All 4 branches missed.">            this.pressed = p &amp;&amp; isEnabled();</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            if (shouldActLikeButton()) {</span>
<span class="nc" id="L566">                comboBox.repaint();</span>
            }
<span class="nc" id="L568">        }</span>

        /**
         * &lt;p&gt;Updates the internal &quot;over&quot; state. If shouldActLikeButton()
         * is true, and if this method call will change the internal state,
         * then the combo and button will be repainted.&lt;/p&gt;
         *
         * &lt;p&gt;Note that this method is called either when a mouseover/mouseoff event
         * occurs on the combo box, or on the arrow button.&lt;/p&gt;
         */
        private void updateOver(boolean o) {
<span class="nc" id="L579">            boolean old = isRollover();</span>
<span class="nc bnc" id="L580" title="All 4 branches missed.">            this.over = o &amp;&amp; isEnabled();</span>
<span class="nc" id="L581">            boolean newo = isRollover();</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">            if (shouldActLikeButton() &amp;&amp; old != newo) {</span>
<span class="nc" id="L583">                comboBox.repaint();</span>
            }
<span class="nc" id="L585">        }</span>

        //------------------------------------------------------------------
        // DefaultButtonModel Methods
        //------------------------------------------------------------------

        /**
         * @inheritDoc
         *
         * Ensures that isPressed() will return true if the combo is pressed,
         * or the arrowButton is pressed, &lt;em&gt;or&lt;/em&gt; if the combo popup is
         * visible. This is the case because a combo box looks pressed when
         * the popup is visible, and so should the arrow button.
         */
        @Override
        public boolean isPressed() {
<span class="nc bnc" id="L601" title="All 2 branches missed.">            boolean b = shouldActLikeButton() ? pressed : super.isPressed();</span>
<span class="nc bnc" id="L602" title="All 6 branches missed.">            return b || (pressedWhenPopupVisible &amp;&amp; comboBox.isPopupVisible());</span>
        }

        /**
         * @inheritDoc
         *
         * Ensures that the armed state is in sync with the pressed state
         * if shouldActLikeButton is true. Without this method, the arrow
         * button will not look pressed when the popup is open, regardless
         * of the result of isPressed() alone.
         */
        @Override
        public boolean isArmed() {
<span class="nc bnc" id="L615" title="All 2 branches missed.">            boolean b = shouldActLikeButton() ||</span>
<span class="nc bnc" id="L616" title="All 4 branches missed.">                        (pressedWhenPopupVisible &amp;&amp; comboBox.isPopupVisible());</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            return b ? isPressed() : super.isArmed();</span>
        }

        /**
         * @inheritDoc
         *
         * Ensures that isRollover() will return true if the combo is
         * rolled over, or the arrowButton is rolled over.
         */
        @Override
        public boolean isRollover() {
<span class="nc bnc" id="L628" title="All 2 branches missed.">            return shouldActLikeButton() ? over : super.isRollover();</span>
        }

        /**
         * @inheritDoc
         *
         * Forwards pressed states to the internal &quot;pressed&quot; field
         */
        @Override
        public void setPressed(boolean b) {
<span class="nc" id="L638">            super.setPressed(b);</span>
<span class="nc" id="L639">            updatePressed(b);</span>
<span class="nc" id="L640">        }</span>

        /**
         * @inheritDoc
         *
         * Forwards rollover states to the internal &quot;over&quot; field
         */
        @Override
        public void setRollover(boolean b) {
<span class="nc" id="L649">            super.setRollover(b);</span>
<span class="nc" id="L650">            updateOver(b);</span>
<span class="nc" id="L651">        }</span>

        //------------------------------------------------------------------
        // MouseListener/MouseMotionListener Methods
        //------------------------------------------------------------------

        @Override
        public void mouseEntered(MouseEvent mouseEvent) {
<span class="nc" id="L659">            updateOver(true);</span>
<span class="nc" id="L660">        }</span>

        @Override
        public void mouseExited(MouseEvent mouseEvent) {
<span class="nc" id="L664">            updateOver(false);</span>
<span class="nc" id="L665">        }</span>

        @Override
        public void mousePressed(MouseEvent mouseEvent) {
<span class="nc" id="L669">            updatePressed(true);</span>
<span class="nc" id="L670">        }</span>

        @Override
        public void mouseReleased(MouseEvent mouseEvent) {
<span class="nc" id="L674">            updatePressed(false);</span>
<span class="nc" id="L675">        }</span>

        @Override
<span class="nc" id="L678">        public void mouseClicked(MouseEvent e) {}</span>

        //------------------------------------------------------------------
        // PopupMenuListener Methods
        //------------------------------------------------------------------

        /**
         * @inheritDoc
         *
         * Ensures that the combo box is repainted when the popup is closed.
         * This avoids a bug where clicking off the combo wasn't causing a repaint,
         * and thus the combo box still looked pressed even when it was not.
         *
         * This bug was only noticed when acting as a button, but may be generally
         * present. If so, remove the if() block
         */
        @Override
        public void popupMenuCanceled(PopupMenuEvent e) {
<span class="nc bnc" id="L696" title="All 4 branches missed.">            if (shouldActLikeButton() || pressedWhenPopupVisible) {</span>
<span class="nc" id="L697">                comboBox.repaint();</span>
            }
<span class="nc" id="L699">        }</span>

        @Override
<span class="nc" id="L702">        public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}</span>
        @Override
<span class="nc" id="L704">        public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}</span>
    }

    /**
     * Handler for repainting combo when editor component gains/looses focus
     */
<span class="nc" id="L710">    private static class EditorFocusHandler implements FocusListener,</span>
            PropertyChangeListener {
        private JComboBox comboBox;
<span class="nc" id="L713">        private ComboBoxEditor editor = null;</span>
<span class="nc" id="L714">        private Component editorComponent = null;</span>

<span class="nc" id="L716">        private EditorFocusHandler(JComboBox comboBox) {</span>
<span class="nc" id="L717">            this.comboBox = comboBox;</span>
<span class="nc" id="L718">            editor = comboBox.getEditor();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (editor != null){</span>
<span class="nc" id="L720">                editorComponent = editor.getEditorComponent();</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (editorComponent != null){</span>
<span class="nc" id="L722">                    editorComponent.addFocusListener(this);</span>
                }
            }
<span class="nc" id="L725">            comboBox.addPropertyChangeListener(&quot;editor&quot;,this);</span>
<span class="nc" id="L726">        }</span>

        public void unregister(){
<span class="nc" id="L729">            comboBox.removePropertyChangeListener(this);</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (editorComponent!=null){</span>
<span class="nc" id="L731">                editorComponent.removeFocusListener(this);</span>
            }
<span class="nc" id="L733">        }</span>

        /** Invoked when a component gains the keyboard focus. */
        public void focusGained(FocusEvent e) {
            // repaint whole combo on focus gain
<span class="nc" id="L738">            comboBox.repaint();</span>
<span class="nc" id="L739">        }</span>

        /** Invoked when a component loses the keyboard focus. */
        public void focusLost(FocusEvent e) {
            // repaint whole combo on focus loss
<span class="nc" id="L744">            comboBox.repaint();</span>
<span class="nc" id="L745">        }</span>

        /**
         * Called when the combos editor changes
         *
         * @param evt A PropertyChangeEvent object describing the event source and
         *            the property that has changed.
         */
        public void propertyChange(PropertyChangeEvent evt) {
<span class="nc" id="L754">            ComboBoxEditor newEditor = comboBox.getEditor();</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (editor != newEditor){</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                if (editorComponent!=null){</span>
<span class="nc" id="L757">                    editorComponent.removeFocusListener(this);</span>
                }
<span class="nc" id="L759">                editor = newEditor;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">                if (editor != null){</span>
<span class="nc" id="L761">                    editorComponent = editor.getEditorComponent();</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">                    if (editorComponent != null){</span>
<span class="nc" id="L763">                        editorComponent.addFocusListener(this);</span>
                    }
                }
            }
<span class="nc" id="L767">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>