<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PerfDataFile.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.perfdata.monitor.protocol.local</a> &gt; <span class="el_source">PerfDataFile.java</span></div><h1>PerfDataFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.protocol.local;

import java.io.File;
import java.io.FilenameFilter;

/**
 * Class to provide translations from the local Vm Identifier
 * name space into the file system name space and vice-versa.
 * &lt;p&gt;
 * Provides a factory for creating a File object to the backing
 * store file for instrumentation shared memory region for a JVM
 * identified by its Local Java Virtual Machine Identifier, or
 * &lt;em&gt;lvmid&lt;/em&gt;.
 *
 * @author Brian Doherty
 * @since 1.5
 * @see java.io.File
 */
public class PerfDataFile {
<span class="nc" id="L45">    private PerfDataFile() { };</span>

    /**
     * The name of the of the system dependent temporary directory
     */
    public static final String tmpDirName;

    /**
     * The file name prefix for PerfData shared memory files.
     * &lt;p&gt;
     * This prefix must be kept in sync with the prefix used by the JVM.
     */
    public static final String dirNamePrefix = &quot;hsperfdata_&quot;;

    /**
     * The directory name pattern for the user directories.
     */
    public static final String userDirNamePattern = &quot;hsperfdata_\\S*&quot;;

    /**
     * The file name pattern for PerfData shared memory files.
     * &lt;p&gt;
     * This pattern must be kept in synch with the file name pattern
     * used by the 1.4.2 and later HotSpot JVM.
     */
    public static final String fileNamePattern = &quot;^[0-9]+$&quot;;

    /**
     * The file name pattern for 1.4.1 PerfData shared memory files.
     * &lt;p&gt;
     * This pattern must be kept in synch with the file name pattern
     * used by the 1.4.1 HotSpot JVM.
     */
    public static final String tmpFileNamePattern =
            &quot;^hsperfdata_[0-9]+(_[1-2]+)?$&quot;;


    /**
     * Get a File object for the instrumentation backing store file
     * for the JVM identified by the given local Vm Identifier.
     * &lt;p&gt;
     * This method looks for the most up to date backing store file for
     * the given &lt;tt&gt;lvmid&lt;/tt&gt;. It will search all the user specific
     * directories in the temporary directory for the host operating
     * system, which may be influenced by platform specific environment
     * variables.
     *
     * @param lvmid  the local Java Virtual Machine Identifier for the target
     * @return File - a File object to the backing store file for the named
     *                shared memory region of the target JVM.
     * @see java.io.File
     * @see #getTempDirectory()
     */
    public static File getFile(int lvmid) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (lvmid == 0) {</span>
            /*
             * lvmid == 0 is used to indicate the current Java Virtual Machine.
             * If the SDK provided an API to get a unique Java Virtual Machine
             * identifier, then a filename could be constructed with that
             * identifier. In absence of such an api, return null.
             */
<span class="nc" id="L106">            return null;</span>
        }

        /*
         * iterate over all files in all directories in tmpDirName that
         * match the file name patterns.
         */
<span class="nc" id="L113">        File tmpDir = new File(tmpDirName);</span>
<span class="nc" id="L114">        String[] files = tmpDir.list(new FilenameFilter() {</span>
            public boolean accept(File dir, String name) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">                if (!name.startsWith(dirNamePrefix)) {</span>
<span class="nc" id="L117">                    return false;</span>
                }
<span class="nc" id="L119">                File candidate = new File(dir, name);</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">                return ((candidate.isDirectory() || candidate.isFile())</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">                        &amp;&amp; candidate.canRead());</span>
            }
        });

<span class="nc" id="L125">        long newestTime = 0;</span>
<span class="nc" id="L126">        File newest = null;</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">        for (int i = 0; i &lt; files.length; i++) {</span>
<span class="nc" id="L129">            File f = new File(tmpDirName + files[i]);</span>
<span class="nc" id="L130">            File candidate = null;</span>

<span class="nc bnc" id="L132" title="All 4 branches missed.">            if (f.exists() &amp;&amp; f.isDirectory()) {</span>
                /*
                 * found a directory matching the name patterns. This
                 * is a 1.4.2 hsperfdata_&lt;user&gt; directory. Check for
                 * file named &lt;lvmid&gt; in that directory
                 */
<span class="nc" id="L138">                String name = Integer.toString(lvmid);</span>
<span class="nc" id="L139">                candidate = new File(f.getName(), name);</span>

<span class="nc bnc" id="L141" title="All 4 branches missed.">            } else if (f.exists() &amp;&amp; f.isFile()) {</span>
                /*
                 * found a file matching the name patterns. This
                 * is a 1.4.1 hsperfdata_&lt;lvmid&gt; file.
                 */
<span class="nc" id="L146">                candidate = f;</span>

            } else {
                // unexpected - let conditional below filter this one out
<span class="nc" id="L150">                candidate = f;</span>
            }

<span class="nc bnc" id="L153" title="All 4 branches missed.">            if (candidate.exists() &amp;&amp; candidate.isFile()</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    &amp;&amp; candidate.canRead()) {</span>
<span class="nc" id="L155">                long modTime = candidate.lastModified();</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (modTime &gt;= newestTime) {</span>
<span class="nc" id="L157">                    newestTime = modTime;</span>
<span class="nc" id="L158">                    newest = candidate;</span>
                }
            }
        }
<span class="nc" id="L162">        return newest;</span>
    }

    /**
     * Return the File object for the backing store file for the specified Java
     * Virtual Machine.
     * &lt;p&gt;
     * This method looks for the most up to date backing store file for
     * the JVM identified by the given user name and lvmid. The directory
     * searched is the temporary directory for the host operating system,
     * which may be influenced by environment variables.
     *
     * @param user   the user name
     * @param lvmid  the local Java Virtual Machine Identifier for the target
     * @return File - a File object to the backing store file for the named
     *                shared memory region of the target JVM.
     * @see java.io.File
     * @see #getTempDirectory()
     */
    public static File getFile(String user, int lvmid) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (lvmid == 0) {</span>
            /*
             * lvmid == 0 is used to indicate the current Java Virtual Machine.
             * If the SDK provided an API to get a unique Java Virtual Machine
             * identifier, then a filename could be constructed with that
             * identifier. In absence of such an api, return null.
             */
<span class="nc" id="L189">            return null;</span>
        }

        // first try for 1.4.2 and later JVMs
<span class="nc" id="L193">        String basename = getTempDirectory(user) + Integer.toString(lvmid);</span>
<span class="nc" id="L194">        File f = new File(basename);</span>

<span class="nc bnc" id="L196" title="All 6 branches missed.">        if (f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead()) {</span>
<span class="nc" id="L197">            return f;</span>
        }

        // No hit on 1.4.2 JVMs, try 1.4.1 files
<span class="nc" id="L201">        long newestTime = 0;</span>
<span class="nc" id="L202">        File newest = null;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (i == 0) {</span>
<span class="nc" id="L205">                basename = getTempDirectory() + Integer.toString(lvmid);</span>
            } else {
<span class="nc" id="L207">                basename = getTempDirectory() + Integer.toString(lvmid)</span>
<span class="nc" id="L208">                           + Integer.toString(i);</span>
            }

<span class="nc" id="L211">            f = new File(basename);</span>

<span class="nc bnc" id="L213" title="All 6 branches missed.">            if (f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead()) {</span>
<span class="nc" id="L214">                long modTime = f.lastModified();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                if (modTime &gt;= newestTime) {</span>
<span class="nc" id="L216">                    newestTime = modTime;</span>
<span class="nc" id="L217">                    newest = f;</span>
                }
            }
        }
<span class="nc" id="L221">        return newest;</span>
    }

    /**
     * Method to extract a local Java Virtual Machine Identifier from the
     * file name of the given File object.
     *
     * @param file A File object representing the name of a
     *             shared memory region for a target JVM
     * @return int - the local Java Virtual Machine Identifier for the target
     *               associated with the file
     * @throws java.lang.IllegalArgumentException Thrown if the file name
     *               does not conform to the expected pattern
     */
    public static int getLocalVmId(File file) {
<span class="nc" id="L236">        int lvmid = 0;</span>

        try {
            // try 1.4.2 and later format first
<span class="nc" id="L240">            return Integer.parseInt(file.getName());</span>
<span class="nc" id="L241">        } catch (NumberFormatException e) { }</span>

        // now try the 1.4.1 format
<span class="nc" id="L244">        String name = file.getName();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (name.startsWith(dirNamePrefix)) {</span>
<span class="nc" id="L246">            int first = name.indexOf('_');</span>
<span class="nc" id="L247">            int last = name.lastIndexOf('_');</span>
            try {
<span class="nc bnc" id="L249" title="All 2 branches missed.">                if (first == last) {</span>
<span class="nc" id="L250">                    return Integer.parseInt(name.substring(first + 1));</span>
                } else {
<span class="nc" id="L252">                    return Integer.parseInt(name.substring(first + 1, last));</span>
                }
<span class="nc" id="L254">            } catch (NumberFormatException e) { }</span>
        }
<span class="nc" id="L256">        throw new IllegalArgumentException(&quot;file name does not match pattern&quot;);</span>
    }

    /**
     * Return the name of the temporary directory being searched for
     * HotSpot PerfData backing store files.
     * &lt;p&gt;
     * This method generally returns the value of the java.io.tmpdir
     * property. However, on some platforms it may return a different
     * directory, as the JVM implementation may store the PerfData backing
     * store files in a different directory for performance reasons.
     *
     * @return String - the name of the temporary directory.
     */
    public static String getTempDirectory() {
<span class="nc" id="L271">        return tmpDirName;</span>
    }

    /**
     * Return the name of the temporary directory to be searched
     * for HotSpot PerfData backing store files for a given user.
     * &lt;p&gt;
     * This method generally returns the name of a subdirectory of
     * the directory indicated in the java.io.tmpdir property. However,
     * on some platforms it may return a different directory, as the
     * JVM implementation may store the PerfData backing store files
     * in a different directory for performance reasons.
     *
     * @return String - the name of the temporary directory.
     */
    public static String getTempDirectory(String user) {
<span class="nc" id="L287">        return tmpDirName + dirNamePrefix + user + File.separator;</span>
    }

    /*
     * this static initializer would not be necessary if the
     * Solaris java.io.tmpdir property were set to /tmp by default
     */
    static {
        /*
         * Why is java.io.tmpdir on Solaris set to &quot;/var/tmp/&quot; when the
         * HotSpot JVM os:get_temp_path() method returns &quot;/tmp/&quot;
         *
         * Why do Solaris and Windows return a string with a trailing
         * file separator character where as Linix does not? (this change
         * seems to have occurred sometime during hopper beta)
         */
<span class="nc" id="L303">        String tmpdir = System.getProperty(&quot;java.io.tmpdir&quot;);</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (tmpdir.compareTo(&quot;/var/tmp/&quot;) == 0) {</span>
             /*
              * shared memory files are created in /tmp. Interestingly,
              * java.io.tmpdir is set to &quot;/var/tmp/&quot; on Solaris and Linux,
              * but os::get_temp_directory() is set to &quot;/tmp/&quot; on these
              * platforms. the java.io.logging packages also makes reference
              * to java.io.tmpdir.
              */
<span class="nc" id="L313">             tmpdir = &quot;/tmp/&quot;;</span>
        }

        /*
         * Assure that the string returned has a trailing File.separator
         * character. This check was added because the Linux implementation
         * changed such that the java.io.tmpdir string no longer terminates
         * with a File.separator character.
         */
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (tmpdir.lastIndexOf(File.separator) != (tmpdir.length()-1)) {</span>
<span class="nc" id="L323">            tmpdir = tmpdir + File.separator;</span>
        }
<span class="nc" id="L325">        tmpDirName = tmpdir;</span>
<span class="nc" id="L326">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>