<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JarFile.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.jar</a> &gt; <span class="el_source">JarFile.java</span></div><h1>JarFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.jar;

import java.io.*;
import java.lang.ref.SoftReference;
import java.net.URL;
import java.util.*;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import java.util.zip.*;
import java.security.CodeSigner;
import java.security.cert.Certificate;
import java.security.AccessController;
import java.security.CodeSource;
import sun.misc.IOUtils;
import sun.security.action.GetPropertyAction;
import sun.security.util.ManifestEntryVerifier;
import sun.misc.SharedSecrets;

/**
 * The &lt;code&gt;JarFile&lt;/code&gt; class is used to read the contents of a jar file
 * from any file that can be opened with &lt;code&gt;java.io.RandomAccessFile&lt;/code&gt;.
 * It extends the class &lt;code&gt;java.util.zip.ZipFile&lt;/code&gt; with support
 * for reading an optional &lt;code&gt;Manifest&lt;/code&gt; entry. The
 * &lt;code&gt;Manifest&lt;/code&gt; can be used to specify meta-information about the
 * jar file and its entries.
 *
 * &lt;p&gt; Unless otherwise noted, passing a &lt;tt&gt;null&lt;/tt&gt; argument to a constructor
 * or method in this class will cause a {@link NullPointerException} to be
 * thrown.
 *
 * @author  David Connelly
 * @see     Manifest
 * @see     java.util.zip.ZipFile
 * @see     java.util.jar.JarEntry
 * @since   1.2
 */
public
class JarFile extends ZipFile {
    private SoftReference&lt;Manifest&gt; manRef;
    private JarEntry manEntry;
    private JarVerifier jv;
    private boolean jvInitialized;
    private boolean verify;

    // indicates if Class-Path attribute present (only valid if hasCheckedSpecialAttributes true)
    private boolean hasClassPathAttribute;
    // true if manifest checked for special attributes
    private volatile boolean hasCheckedSpecialAttributes;

    // Set up JavaUtilJarAccess in SharedSecrets
    static {
<span class="fc" id="L77">        SharedSecrets.setJavaUtilJarAccess(new JavaUtilJarAccessImpl());</span>
    }

    /**
     * The JAR manifest file name.
     */
    public static final String MANIFEST_NAME = &quot;META-INF/MANIFEST.MF&quot;;

    /**
     * Creates a new &lt;code&gt;JarFile&lt;/code&gt; to read from the specified
     * file &lt;code&gt;name&lt;/code&gt;. The &lt;code&gt;JarFile&lt;/code&gt; will be verified if
     * it is signed.
     * @param name the name of the jar file to be opened for reading
     * @throws IOException if an I/O error has occurred
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager
     */
    public JarFile(String name) throws IOException {
<span class="fc" id="L95">        this(new File(name), true, ZipFile.OPEN_READ);</span>
<span class="fc" id="L96">    }</span>

    /**
     * Creates a new &lt;code&gt;JarFile&lt;/code&gt; to read from the specified
     * file &lt;code&gt;name&lt;/code&gt;.
     * @param name the name of the jar file to be opened for reading
     * @param verify whether or not to verify the jar file if
     * it is signed.
     * @throws IOException if an I/O error has occurred
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager
     */
    public JarFile(String name, boolean verify) throws IOException {
<span class="nc" id="L109">        this(new File(name), verify, ZipFile.OPEN_READ);</span>
<span class="nc" id="L110">    }</span>

    /**
     * Creates a new &lt;code&gt;JarFile&lt;/code&gt; to read from the specified
     * &lt;code&gt;File&lt;/code&gt; object. The &lt;code&gt;JarFile&lt;/code&gt; will be verified if
     * it is signed.
     * @param file the jar file to be opened for reading
     * @throws IOException if an I/O error has occurred
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager
     */
    public JarFile(File file) throws IOException {
<span class="fc" id="L122">        this(file, true, ZipFile.OPEN_READ);</span>
<span class="fc" id="L123">    }</span>


    /**
     * Creates a new &lt;code&gt;JarFile&lt;/code&gt; to read from the specified
     * &lt;code&gt;File&lt;/code&gt; object.
     * @param file the jar file to be opened for reading
     * @param verify whether or not to verify the jar file if
     * it is signed.
     * @throws IOException if an I/O error has occurred
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager.
     */
    public JarFile(File file, boolean verify) throws IOException {
<span class="fc" id="L137">        this(file, verify, ZipFile.OPEN_READ);</span>
<span class="fc" id="L138">    }</span>


    /**
     * Creates a new &lt;code&gt;JarFile&lt;/code&gt; to read from the specified
     * &lt;code&gt;File&lt;/code&gt; object in the specified mode.  The mode argument
     * must be either &lt;tt&gt;OPEN_READ&lt;/tt&gt; or &lt;tt&gt;OPEN_READ | OPEN_DELETE&lt;/tt&gt;.
     *
     * @param file the jar file to be opened for reading
     * @param verify whether or not to verify the jar file if
     * it is signed.
     * @param mode the mode in which the file is to be opened
     * @throws IOException if an I/O error has occurred
     * @throws IllegalArgumentException
     *         if the &lt;tt&gt;mode&lt;/tt&gt; argument is invalid
     * @throws SecurityException if access to the file is denied
     *         by the SecurityManager
     * @since 1.3
     */
    public JarFile(File file, boolean verify, int mode) throws IOException {
<span class="fc" id="L158">        super(file, mode);</span>
<span class="fc" id="L159">        this.verify = verify;</span>
<span class="fc" id="L160">    }</span>

    /**
     * Returns the jar file manifest, or &lt;code&gt;null&lt;/code&gt; if none.
     *
     * @return the jar file manifest, or &lt;code&gt;null&lt;/code&gt; if none
     *
     * @throws IllegalStateException
     *         may be thrown if the jar file has been closed
     * @throws IOException  if an I/O error has occurred
     */
    public Manifest getManifest() throws IOException {
<span class="fc" id="L172">        return getManifestFromReference();</span>
    }

    private Manifest getManifestFromReference() throws IOException {
<span class="fc bfc" id="L176" title="All 2 branches covered.">        Manifest man = manRef != null ? manRef.get() : null;</span>

<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (man == null) {</span>

<span class="fc" id="L180">            JarEntry manEntry = getManEntry();</span>

            // If found then load the manifest
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (manEntry != null) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (verify) {</span>
<span class="fc" id="L185">                    byte[] b = getBytes(manEntry);</span>
<span class="fc" id="L186">                    man = new Manifest(new ByteArrayInputStream(b));</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">                    if (!jvInitialized) {</span>
<span class="fc" id="L188">                        jv = new JarVerifier(b);</span>
                    }
<span class="fc" id="L190">                } else {</span>
<span class="fc" id="L191">                    man = new Manifest(super.getInputStream(manEntry));</span>
                }
<span class="fc" id="L193">                manRef = new SoftReference&lt;&gt;(man);</span>
            }
        }
<span class="fc" id="L196">        return man;</span>
    }

    private native String[] getMetaInfEntryNames();

    /**
     * Returns the &lt;code&gt;JarEntry&lt;/code&gt; for the given entry name or
     * &lt;code&gt;null&lt;/code&gt; if not found.
     *
     * @param name the jar file entry name
     * @return the &lt;code&gt;JarEntry&lt;/code&gt; for the given entry name or
     *         &lt;code&gt;null&lt;/code&gt; if not found.
     *
     * @throws IllegalStateException
     *         may be thrown if the jar file has been closed
     *
     * @see java.util.jar.JarEntry
     */
    public JarEntry getJarEntry(String name) {
<span class="fc" id="L215">        return (JarEntry)getEntry(name);</span>
    }

    /**
     * Returns the &lt;code&gt;ZipEntry&lt;/code&gt; for the given entry name or
     * &lt;code&gt;null&lt;/code&gt; if not found.
     *
     * @param name the jar file entry name
     * @return the &lt;code&gt;ZipEntry&lt;/code&gt; for the given entry name or
     *         &lt;code&gt;null&lt;/code&gt; if not found
     *
     * @throws IllegalStateException
     *         may be thrown if the jar file has been closed
     *
     * @see java.util.zip.ZipEntry
     */
    public ZipEntry getEntry(String name) {
<span class="fc" id="L232">        ZipEntry ze = super.getEntry(name);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        if (ze != null) {</span>
<span class="fc" id="L234">            return new JarFileEntry(ze);</span>
        }
<span class="fc" id="L236">        return null;</span>
    }

<span class="fc" id="L239">    private class JarEntryIterator implements Enumeration&lt;JarEntry&gt;,</span>
            Iterator&lt;JarEntry&gt;
    {
<span class="fc" id="L242">        final Enumeration&lt;? extends ZipEntry&gt; e = JarFile.super.entries();</span>

        public boolean hasNext() {
<span class="fc" id="L245">            return e.hasMoreElements();</span>
        }

        public JarEntry next() {
<span class="fc" id="L249">            ZipEntry ze = e.nextElement();</span>
<span class="fc" id="L250">            return new JarFileEntry(ze);</span>
        }

        public boolean hasMoreElements() {
<span class="fc" id="L254">            return hasNext();</span>
        }

        public JarEntry nextElement() {
<span class="fc" id="L258">            return next();</span>
        }
    }

    /**
     * Returns an enumeration of the zip file entries.
     */
    public Enumeration&lt;JarEntry&gt; entries() {
<span class="fc" id="L266">        return new JarEntryIterator();</span>
    }

    @Override
    public Stream&lt;JarEntry&gt; stream() {
<span class="nc" id="L271">        return StreamSupport.stream(Spliterators.spliterator(</span>
<span class="nc" id="L272">                new JarEntryIterator(), size(),</span>
                Spliterator.ORDERED | Spliterator.DISTINCT |
                        Spliterator.IMMUTABLE | Spliterator.NONNULL), false);
    }

    private class JarFileEntry extends JarEntry {
<span class="fc" id="L278">        JarFileEntry(ZipEntry ze) {</span>
<span class="fc" id="L279">            super(ze);</span>
<span class="fc" id="L280">        }</span>
        public Attributes getAttributes() throws IOException {
<span class="nc" id="L282">            Manifest man = JarFile.this.getManifest();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (man != null) {</span>
<span class="nc" id="L284">                return man.getAttributes(getName());</span>
            } else {
<span class="nc" id="L286">                return null;</span>
            }
        }
        public Certificate[] getCertificates() {
            try {
<span class="fc" id="L291">                maybeInstantiateVerifier();</span>
<span class="nc" id="L292">            } catch (IOException e) {</span>
<span class="nc" id="L293">                throw new RuntimeException(e);</span>
<span class="fc" id="L294">            }</span>
<span class="pc bpc" id="L295" title="1 of 4 branches missed.">            if (certs == null &amp;&amp; jv != null) {</span>
<span class="nc" id="L296">                certs = jv.getCerts(JarFile.this, this);</span>
            }
<span class="fc bfc" id="L298" title="All 2 branches covered.">            return certs == null ? null : certs.clone();</span>
        }
        public CodeSigner[] getCodeSigners() {
            try {
<span class="fc" id="L302">                maybeInstantiateVerifier();</span>
<span class="nc" id="L303">            } catch (IOException e) {</span>
<span class="nc" id="L304">                throw new RuntimeException(e);</span>
<span class="fc" id="L305">            }</span>
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">            if (signers == null &amp;&amp; jv != null) {</span>
<span class="nc" id="L307">                signers = jv.getCodeSigners(JarFile.this, this);</span>
            }
<span class="fc bfc" id="L309" title="All 2 branches covered.">            return signers == null ? null : signers.clone();</span>
        }
    }

    /*
     * Ensures that the JarVerifier has been created if one is
     * necessary (i.e., the jar appears to be signed.) This is done as
     * a quick check to avoid processing of the manifest for unsigned
     * jars.
     */
    private void maybeInstantiateVerifier() throws IOException {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (jv != null) {</span>
<span class="fc" id="L321">            return;</span>
        }

<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (verify) {</span>
<span class="fc" id="L325">            String[] names = getMetaInfEntryNames();</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if (names != null) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L328">                    String name = names[i].toUpperCase(Locale.ENGLISH);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">                    if (name.endsWith(&quot;.DSA&quot;) ||</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">                        name.endsWith(&quot;.RSA&quot;) ||</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                        name.endsWith(&quot;.EC&quot;) ||</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                        name.endsWith(&quot;.SF&quot;)) {</span>
                        // Assume since we found a signature-related file
                        // that the jar is signed and that we therefore
                        // need a JarVerifier and Manifest
<span class="fc" id="L336">                        getManifest();</span>
<span class="fc" id="L337">                        return;</span>
                    }
                }
            }
            // No signature-related files; don't instantiate a
            // verifier
<span class="fc" id="L343">            verify = false;</span>
        }
<span class="fc" id="L345">    }</span>


    /*
     * Initializes the verifier object by reading all the manifest
     * entries and passing them to the verifier.
     */
    private void initializeVerifier() {
<span class="fc" id="L353">        ManifestEntryVerifier mev = null;</span>

        // Verify &quot;META-INF/&quot; entries...
        try {
<span class="fc" id="L357">            String[] names = getMetaInfEntryNames();</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (names != null) {</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L360">                    JarEntry e = getJarEntry(names[i]);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                    if (e == null) {</span>
<span class="nc" id="L362">                        throw new JarException(&quot;corrupted jar file&quot;);</span>
                    }
<span class="fc bfc" id="L364" title="All 2 branches covered.">                    if (!e.isDirectory()) {</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                        if (mev == null) {</span>
<span class="fc" id="L366">                            mev = new ManifestEntryVerifier</span>
<span class="fc" id="L367">                                (getManifestFromReference());</span>
                        }
<span class="fc" id="L369">                        byte[] b = getBytes(e);</span>
<span class="pc bpc" id="L370" title="2 of 4 branches missed.">                        if (b != null &amp;&amp; b.length &gt; 0) {</span>
<span class="fc" id="L371">                            jv.beginEntry(e, mev);</span>
<span class="fc" id="L372">                            jv.update(b.length, b, 0, b.length, mev);</span>
<span class="fc" id="L373">                            jv.update(-1, null, 0, 0, mev);</span>
                        }
                    }
                }
            }
<span class="nc" id="L378">        } catch (IOException ex) {</span>
            // if we had an error parsing any blocks, just
            // treat the jar file as being unsigned
<span class="nc" id="L381">            jv = null;</span>
<span class="nc" id="L382">            verify = false;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (JarVerifier.debug != null) {</span>
<span class="nc" id="L384">                JarVerifier.debug.println(&quot;jarfile parsing error!&quot;);</span>
<span class="nc" id="L385">                ex.printStackTrace();</span>
            }
<span class="fc" id="L387">        }</span>

        // if after initializing the verifier we have nothing
        // signed, we null it out.

<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (jv != null) {</span>

<span class="fc" id="L394">            jv.doneWithMeta();</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (JarVerifier.debug != null) {</span>
<span class="fc" id="L396">                JarVerifier.debug.println(&quot;done with meta!&quot;);</span>
            }

<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (jv.nothingToVerify()) {</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (JarVerifier.debug != null) {</span>
<span class="fc" id="L401">                    JarVerifier.debug.println(&quot;nothing to verify!&quot;);</span>
                }
<span class="fc" id="L403">                jv = null;</span>
<span class="fc" id="L404">                verify = false;</span>
            }
        }
<span class="fc" id="L407">    }</span>

    /*
     * Reads all the bytes for a given entry. Used to process the
     * META-INF files.
     */
    private byte[] getBytes(ZipEntry ze) throws IOException {
<span class="pc" id="L414">        try (InputStream is = super.getInputStream(ze)) {</span>
<span class="fc" id="L415">            return IOUtils.readFully(is, (int)ze.getSize(), true);</span>
<span class="pc bpc" id="L416" title="6 of 8 branches missed.">        }</span>
    }

    /**
     * Returns an input stream for reading the contents of the specified
     * zip file entry.
     * @param ze the zip file entry
     * @return an input stream for reading the contents of the specified
     *         zip file entry
     * @throws ZipException if a zip file format error has occurred
     * @throws IOException if an I/O error has occurred
     * @throws SecurityException if any of the jar file entries
     *         are incorrectly signed.
     * @throws IllegalStateException
     *         may be thrown if the jar file has been closed
     */
    public synchronized InputStream getInputStream(ZipEntry ze)
        throws IOException
    {
<span class="fc" id="L435">        maybeInstantiateVerifier();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (jv == null) {</span>
<span class="fc" id="L437">            return super.getInputStream(ze);</span>
        }
<span class="fc bfc" id="L439" title="All 2 branches covered.">        if (!jvInitialized) {</span>
<span class="fc" id="L440">            initializeVerifier();</span>
<span class="fc" id="L441">            jvInitialized = true;</span>
            // could be set to null after a call to
            // initializeVerifier if we have nothing to
            // verify
<span class="fc bfc" id="L445" title="All 2 branches covered.">            if (jv == null)</span>
<span class="fc" id="L446">                return super.getInputStream(ze);</span>
        }

        // wrap a verifier stream around the real stream
<span class="fc" id="L450">        return new JarVerifier.VerifierStream(</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">            getManifestFromReference(),</span>
            ze instanceof JarFileEntry ?
<span class="pc" id="L453">            (JarEntry) ze : getJarEntry(ze.getName()),</span>
<span class="fc" id="L454">            super.getInputStream(ze),</span>
            jv);
    }

    // Statics for hand-coded Boyer-Moore search
<span class="fc" id="L459">    private static final char[] CLASSPATH_CHARS = {'c','l','a','s','s','-','p','a','t','h'};</span>
    // The bad character shift for &quot;class-path&quot;
    private static final int[] CLASSPATH_LASTOCC;
    // The good suffix shift for &quot;class-path&quot;
    private static final int[] CLASSPATH_OPTOSFT;

    static {
<span class="fc" id="L466">        CLASSPATH_LASTOCC = new int[128];</span>
<span class="fc" id="L467">        CLASSPATH_OPTOSFT = new int[10];</span>
<span class="fc" id="L468">        CLASSPATH_LASTOCC[(int)'c'] = 1;</span>
<span class="fc" id="L469">        CLASSPATH_LASTOCC[(int)'l'] = 2;</span>
<span class="fc" id="L470">        CLASSPATH_LASTOCC[(int)'s'] = 5;</span>
<span class="fc" id="L471">        CLASSPATH_LASTOCC[(int)'-'] = 6;</span>
<span class="fc" id="L472">        CLASSPATH_LASTOCC[(int)'p'] = 7;</span>
<span class="fc" id="L473">        CLASSPATH_LASTOCC[(int)'a'] = 8;</span>
<span class="fc" id="L474">        CLASSPATH_LASTOCC[(int)'t'] = 9;</span>
<span class="fc" id="L475">        CLASSPATH_LASTOCC[(int)'h'] = 10;</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">        for (int i=0; i&lt;9; i++)</span>
<span class="fc" id="L477">            CLASSPATH_OPTOSFT[i] = 10;</span>
<span class="fc" id="L478">        CLASSPATH_OPTOSFT[9]=1;</span>
<span class="fc" id="L479">    }</span>

    private JarEntry getManEntry() {
<span class="fc bfc" id="L482" title="All 2 branches covered.">        if (manEntry == null) {</span>
            // First look up manifest entry using standard name
<span class="fc" id="L484">            manEntry = getJarEntry(MANIFEST_NAME);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (manEntry == null) {</span>
                // If not found, then iterate through all the &quot;META-INF/&quot;
                // entries to find a match.
<span class="fc" id="L488">                String[] names = getMetaInfEntryNames();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">                if (names != null) {</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">                    for (int i = 0; i &lt; names.length; i++) {</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">                        if (MANIFEST_NAME.equals(</span>
<span class="fc" id="L492">                                                 names[i].toUpperCase(Locale.ENGLISH))) {</span>
<span class="nc" id="L493">                            manEntry = getJarEntry(names[i]);</span>
<span class="nc" id="L494">                            break;</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L500">        return manEntry;</span>
    }

   /**
    * Returns {@code true} iff this JAR file has a manifest with the
    * Class-Path attribute
    */
    boolean hasClassPathAttribute() throws IOException {
<span class="fc" id="L508">        checkForSpecialAttributes();</span>
<span class="fc" id="L509">        return hasClassPathAttribute;</span>
    }

    /**
     * Returns true if the pattern {@code src} is found in {@code b}.
     * The {@code lastOcc} and {@code optoSft} arrays are the precomputed
     * bad character and good suffix shifts.
     */
    private boolean match(char[] src, byte[] b, int[] lastOcc, int[] optoSft) {
<span class="fc" id="L518">        int len = src.length;</span>
<span class="fc" id="L519">        int last = b.length - len;</span>
<span class="fc" id="L520">        int i = 0;</span>
        next:
<span class="fc bfc" id="L522" title="All 2 branches covered.">        while (i&lt;=last) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            for (int j=(len-1); j&gt;=0; j--) {</span>
<span class="fc" id="L524">                char c = (char) b[i+j];</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                c = (((c-'A')|('Z'-c)) &gt;= 0) ? (char)(c + 32) : c;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                if (c != src[j]) {</span>
<span class="fc" id="L527">                    i += Math.max(j + 1 - lastOcc[c&amp;0x7F], optoSft[j]);</span>
<span class="fc" id="L528">                    continue next;</span>
                 }
            }
<span class="fc" id="L531">            return true;</span>
        }
<span class="fc" id="L533">        return false;</span>
    }

    /**
     * On first invocation, check if the JAR file has the Class-Path
     * attribute. A no-op on subsequent calls.
     */
    private void checkForSpecialAttributes() throws IOException {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (hasCheckedSpecialAttributes) return;</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (!isKnownNotToHaveSpecialAttributes()) {</span>
<span class="fc" id="L543">            JarEntry manEntry = getManEntry();</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">            if (manEntry != null) {</span>
<span class="fc" id="L545">                byte[] b = getBytes(manEntry);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                if (match(CLASSPATH_CHARS, b, CLASSPATH_LASTOCC, CLASSPATH_OPTOSFT))</span>
<span class="fc" id="L547">                    hasClassPathAttribute = true;</span>
            }
        }
<span class="fc" id="L550">        hasCheckedSpecialAttributes = true;</span>
<span class="fc" id="L551">    }</span>

    private static String javaHome;
    private static volatile String[] jarNames;
    private boolean isKnownNotToHaveSpecialAttributes() {
        // Optimize away even scanning of manifest for jar files we
        // deliver which don't have a class-path attribute. If one of
        // these jars is changed to include such an attribute this code
        // must be changed.
<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (javaHome == null) {</span>
<span class="fc" id="L561">            javaHome = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;java.home&quot;));
        }
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (jarNames == null) {</span>
<span class="fc" id="L565">            String[] names = new String[11];</span>
<span class="fc" id="L566">            String fileSep = File.separator;</span>
<span class="fc" id="L567">            int i = 0;</span>
<span class="fc" id="L568">            names[i++] = fileSep + &quot;rt.jar&quot;;</span>
<span class="fc" id="L569">            names[i++] = fileSep + &quot;jsse.jar&quot;;</span>
<span class="fc" id="L570">            names[i++] = fileSep + &quot;jce.jar&quot;;</span>
<span class="fc" id="L571">            names[i++] = fileSep + &quot;charsets.jar&quot;;</span>
<span class="fc" id="L572">            names[i++] = fileSep + &quot;dnsns.jar&quot;;</span>
<span class="fc" id="L573">            names[i++] = fileSep + &quot;zipfs.jar&quot;;</span>
<span class="fc" id="L574">            names[i++] = fileSep + &quot;localedata.jar&quot;;</span>
<span class="fc" id="L575">            names[i++] = fileSep = &quot;cldrdata.jar&quot;;</span>
<span class="fc" id="L576">            names[i++] = fileSep + &quot;sunjce_provider.jar&quot;;</span>
<span class="fc" id="L577">            names[i++] = fileSep + &quot;sunpkcs11.jar&quot;;</span>
<span class="fc" id="L578">            names[i++] = fileSep + &quot;sunec.jar&quot;;</span>
<span class="fc" id="L579">            jarNames = names;</span>
        }

<span class="fc" id="L582">        String name = getName();</span>
<span class="fc" id="L583">        String localJavaHome = javaHome;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">        if (name.startsWith(localJavaHome)) {</span>
<span class="fc" id="L585">            String[] names = jarNames;</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (name.endsWith(names[i])) {</span>
<span class="fc" id="L588">                    return true;</span>
                }
            }
        }
<span class="fc" id="L592">        return false;</span>
    }

    private synchronized void ensureInitialization() {
        try {
<span class="nc" id="L597">            maybeInstantiateVerifier();</span>
<span class="nc" id="L598">        } catch (IOException e) {</span>
<span class="nc" id="L599">            throw new RuntimeException(e);</span>
<span class="nc" id="L600">        }</span>
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if (jv != null &amp;&amp; !jvInitialized) {</span>
<span class="nc" id="L602">            initializeVerifier();</span>
<span class="nc" id="L603">            jvInitialized = true;</span>
        }
<span class="nc" id="L605">    }</span>

    JarEntry newEntry(ZipEntry ze) {
<span class="nc" id="L608">        return new JarFileEntry(ze);</span>
    }

    Enumeration&lt;String&gt; entryNames(CodeSource[] cs) {
<span class="nc" id="L612">        ensureInitialization();</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc" id="L614">            return jv.entryNames(this, cs);</span>
        }

        /*
         * JAR file has no signed content. Is there a non-signing
         * code source?
         */
<span class="nc" id="L621">        boolean includeUnsigned = false;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">        for (int i = 0; i &lt; cs.length; i++) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (cs[i].getCodeSigners() == null) {</span>
<span class="nc" id="L624">                includeUnsigned = true;</span>
<span class="nc" id="L625">                break;</span>
            }
        }
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (includeUnsigned) {</span>
<span class="nc" id="L629">            return unsignedEntryNames();</span>
        } else {
<span class="nc" id="L631">            return new Enumeration&lt;String&gt;() {</span>

                public boolean hasMoreElements() {
<span class="nc" id="L634">                    return false;</span>
                }

                public String nextElement() {
<span class="nc" id="L638">                    throw new NoSuchElementException();</span>
                }
            };
        }
    }

    /**
     * Returns an enumeration of the zip file entries
     * excluding internal JAR mechanism entries and including
     * signed entries missing from the ZIP directory.
     */
    Enumeration&lt;JarEntry&gt; entries2() {
<span class="nc" id="L650">        ensureInitialization();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc" id="L652">            return jv.entries2(this, super.entries());</span>
        }

        // screen out entries which are never signed
<span class="nc" id="L656">        final Enumeration&lt;? extends ZipEntry&gt; enum_ = super.entries();</span>
<span class="nc" id="L657">        return new Enumeration&lt;JarEntry&gt;() {</span>

            ZipEntry entry;

            public boolean hasMoreElements() {
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (entry != null) {</span>
<span class="nc" id="L663">                    return true;</span>
                }
<span class="nc bnc" id="L665" title="All 2 branches missed.">                while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L666">                    ZipEntry ze = enum_.nextElement();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                    if (JarVerifier.isSigningRelated(ze.getName())) {</span>
<span class="nc" id="L668">                        continue;</span>
                    }
<span class="nc" id="L670">                    entry = ze;</span>
<span class="nc" id="L671">                    return true;</span>
                }
<span class="nc" id="L673">                return false;</span>
            }

            public JarFileEntry nextElement() {
<span class="nc bnc" id="L677" title="All 2 branches missed.">                if (hasMoreElements()) {</span>
<span class="nc" id="L678">                    ZipEntry ze = entry;</span>
<span class="nc" id="L679">                    entry = null;</span>
<span class="nc" id="L680">                    return new JarFileEntry(ze);</span>
                }
<span class="nc" id="L682">                throw new NoSuchElementException();</span>
            }
        };
    }

    CodeSource[] getCodeSources(URL url) {
<span class="nc" id="L688">        ensureInitialization();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc" id="L690">            return jv.getCodeSources(this, url);</span>
        }

        /*
         * JAR file has no signed content. Is there a non-signing
         * code source?
         */
<span class="nc" id="L697">        Enumeration&lt;String&gt; unsigned = unsignedEntryNames();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (unsigned.hasMoreElements()) {</span>
<span class="nc" id="L699">            return new CodeSource[]{JarVerifier.getUnsignedCS(url)};</span>
        } else {
<span class="nc" id="L701">            return null;</span>
        }
    }

    private Enumeration&lt;String&gt; unsignedEntryNames() {
<span class="nc" id="L706">        final Enumeration&lt;JarEntry&gt; entries = entries();</span>
<span class="nc" id="L707">        return new Enumeration&lt;String&gt;() {</span>

            String name;

            /*
             * Grab entries from ZIP directory but screen out
             * metadata.
             */
            public boolean hasMoreElements() {
<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (name != null) {</span>
<span class="nc" id="L717">                    return true;</span>
                }
<span class="nc bnc" id="L719" title="All 2 branches missed.">                while (entries.hasMoreElements()) {</span>
                    String value;
<span class="nc" id="L721">                    ZipEntry e = entries.nextElement();</span>
<span class="nc" id="L722">                    value = e.getName();</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">                    if (e.isDirectory() || JarVerifier.isSigningRelated(value)) {</span>
<span class="nc" id="L724">                        continue;</span>
                    }
<span class="nc" id="L726">                    name = value;</span>
<span class="nc" id="L727">                    return true;</span>
                }
<span class="nc" id="L729">                return false;</span>
            }

            public String nextElement() {
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (hasMoreElements()) {</span>
<span class="nc" id="L734">                    String value = name;</span>
<span class="nc" id="L735">                    name = null;</span>
<span class="nc" id="L736">                    return value;</span>
                }
<span class="nc" id="L738">                throw new NoSuchElementException();</span>
            }
        };
    }

    CodeSource getCodeSource(URL url, String name) {
<span class="nc" id="L744">        ensureInitialization();</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (jv.eagerValidation) {</span>
<span class="nc" id="L747">                CodeSource cs = null;</span>
<span class="nc" id="L748">                JarEntry je = getJarEntry(name);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (je != null) {</span>
<span class="nc" id="L750">                    cs = jv.getCodeSource(url, this, je);</span>
                } else {
<span class="nc" id="L752">                    cs = jv.getCodeSource(url, name);</span>
                }
<span class="nc" id="L754">                return cs;</span>
            } else {
<span class="nc" id="L756">                return jv.getCodeSource(url, name);</span>
            }
        }

<span class="nc" id="L760">        return JarVerifier.getUnsignedCS(url);</span>
    }

    void setEagerValidation(boolean eager) {
        try {
<span class="nc" id="L765">            maybeInstantiateVerifier();</span>
<span class="nc" id="L766">        } catch (IOException e) {</span>
<span class="nc" id="L767">            throw new RuntimeException(e);</span>
<span class="nc" id="L768">        }</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc" id="L770">            jv.setEagerValidation(eager);</span>
        }
<span class="nc" id="L772">    }</span>

    List&lt;Object&gt; getManifestDigests() {
<span class="nc" id="L775">        ensureInitialization();</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (jv != null) {</span>
<span class="nc" id="L777">            return jv.getManifestDigests();</span>
        }
<span class="nc" id="L779">        return new ArrayList&lt;Object&gt;();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>