<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Manifest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.jar</a> &gt; <span class="el_source">Manifest.java</span></div><h1>Manifest.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.jar;

import java.io.FilterInputStream;
import java.io.DataOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;

/**
 * The Manifest class is used to maintain Manifest entry names and their
 * associated Attributes. There are main Manifest Attributes as well as
 * per-entry Attributes. For information on the Manifest format, please
 * see the
 * &lt;a href=&quot;../../../../technotes/guides/jar/jar.html&quot;&gt;
 * Manifest format specification&lt;/a&gt;.
 *
 * @author  David Connelly
 * @see     Attributes
 * @since   1.2
 */
public class Manifest implements Cloneable {
    // manifest main attributes
<span class="pc" id="L51">    private Attributes attr = new Attributes();</span>

    // manifest entries
<span class="pc" id="L54">    private Map&lt;String, Attributes&gt; entries = new HashMap&lt;&gt;();</span>

    /**
     * Constructs a new, empty Manifest.
     */
<span class="fc" id="L59">    public Manifest() {</span>
<span class="fc" id="L60">    }</span>

    /**
     * Constructs a new Manifest from the specified input stream.
     *
     * @param is the input stream containing manifest data
     * @throws IOException if an I/O error has occurred
     */
<span class="fc" id="L68">    public Manifest(InputStream is) throws IOException {</span>
<span class="fc" id="L69">        read(is);</span>
<span class="fc" id="L70">    }</span>

    /**
     * Constructs a new Manifest that is a copy of the specified Manifest.
     *
     * @param man the Manifest to copy
     */
<span class="nc" id="L77">    public Manifest(Manifest man) {</span>
<span class="nc" id="L78">        attr.putAll(man.getMainAttributes());</span>
<span class="nc" id="L79">        entries.putAll(man.getEntries());</span>
<span class="nc" id="L80">    }</span>

    /**
     * Returns the main Attributes for the Manifest.
     * @return the main Attributes for the Manifest
     */
    public Attributes getMainAttributes() {
<span class="fc" id="L87">        return attr;</span>
    }

    /**
     * Returns a Map of the entries contained in this Manifest. Each entry
     * is represented by a String name (key) and associated Attributes (value).
     * The Map permits the {@code null} key, but no entry with a null key is
     * created by {@link #read}, nor is such an entry written by using {@link
     * #write}.
     *
     * @return a Map of the entries contained in this Manifest
     */
    public Map&lt;String,Attributes&gt; getEntries() {
<span class="fc" id="L100">        return entries;</span>
    }

    /**
     * Returns the Attributes for the specified entry name.
     * This method is defined as:
     * &lt;pre&gt;
     *      return (Attributes)getEntries().get(name)
     * &lt;/pre&gt;
     * Though {@code null} is a valid {@code name}, when
     * {@code getAttributes(null)} is invoked on a {@code Manifest}
     * obtained from a jar file, {@code null} will be returned.  While jar
     * files themselves do not allow {@code null}-named attributes, it is
     * possible to invoke {@link #getEntries} on a {@code Manifest}, and
     * on that result, invoke {@code put} with a null key and an
     * arbitrary value.  Subsequent invocations of
     * {@code getAttributes(null)} will return the just-{@code put}
     * value.
     * &lt;p&gt;
     * Note that this method does not return the manifest's main attributes;
     * see {@link #getMainAttributes}.
     *
     * @param name entry name
     * @return the Attributes for the specified entry name
     */
    public Attributes getAttributes(String name) {
<span class="fc" id="L126">        return getEntries().get(name);</span>
    }

    /**
     * Clears the main Attributes as well as the entries in this Manifest.
     */
    public void clear() {
<span class="nc" id="L133">        attr.clear();</span>
<span class="nc" id="L134">        entries.clear();</span>
<span class="nc" id="L135">    }</span>

    /**
     * Writes the Manifest to the specified OutputStream.
     * Attributes.Name.MANIFEST_VERSION must be set in
     * MainAttributes prior to invoking this method.
     *
     * @param out the output stream
     * @exception IOException if an I/O error has occurred
     * @see #getMainAttributes
     */
    public void write(OutputStream out) throws IOException {
<span class="fc" id="L147">        DataOutputStream dos = new DataOutputStream(out);</span>
        // Write out the main attributes for the manifest
<span class="fc" id="L149">        attr.writeMain(dos);</span>
        // Now write out the pre-entry attributes
<span class="fc" id="L151">        Iterator&lt;Map.Entry&lt;String, Attributes&gt;&gt; it = entries.entrySet().iterator();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L153">            Map.Entry&lt;String, Attributes&gt; e = it.next();</span>
<span class="fc" id="L154">            StringBuffer buffer = new StringBuffer(&quot;Name: &quot;);</span>
<span class="fc" id="L155">            String value = e.getKey();</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (value != null) {</span>
<span class="fc" id="L157">                byte[] vb = value.getBytes(&quot;UTF8&quot;);</span>
<span class="fc" id="L158">                value = new String(vb, 0, 0, vb.length);</span>
            }
<span class="fc" id="L160">            buffer.append(value);</span>
<span class="fc" id="L161">            buffer.append(&quot;\r\n&quot;);</span>
<span class="fc" id="L162">            make72Safe(buffer);</span>
<span class="fc" id="L163">            dos.writeBytes(buffer.toString());</span>
<span class="fc" id="L164">            e.getValue().write(dos);</span>
<span class="fc" id="L165">        }</span>
<span class="fc" id="L166">        dos.flush();</span>
<span class="fc" id="L167">    }</span>

    /**
     * Adds line breaks to enforce a maximum 72 bytes per line.
     */
    static void make72Safe(StringBuffer line) {
<span class="fc" id="L173">        int length = line.length();</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (length &gt; 72) {</span>
<span class="fc" id="L175">            int index = 70;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            while (index &lt; length - 2) {</span>
<span class="fc" id="L177">                line.insert(index, &quot;\r\n &quot;);</span>
<span class="fc" id="L178">                index += 72;</span>
<span class="fc" id="L179">                length += 3;</span>
            }
        }
<span class="fc" id="L182">        return;</span>
    }

    /**
     * Reads the Manifest from the specified InputStream. The entry
     * names and attributes read will be merged in with the current
     * manifest entries.
     *
     * @param is the input stream
     * @exception IOException if an I/O error has occurred
     */
    public void read(InputStream is) throws IOException {
        // Buffered input stream for reading manifest data
<span class="fc" id="L195">        FastInputStream fis = new FastInputStream(is);</span>
        // Line buffer
<span class="fc" id="L197">        byte[] lbuf = new byte[512];</span>
        // Read the main attributes for the manifest
<span class="fc" id="L199">        attr.read(fis, lbuf);</span>
        // Total number of entries, attributes read
<span class="fc" id="L201">        int ecount = 0, acount = 0;</span>
        // Average size of entry attributes
<span class="fc" id="L203">        int asize = 2;</span>
        // Now parse the manifest entries
        int len;
<span class="fc" id="L206">        String name = null;</span>
<span class="fc" id="L207">        boolean skipEmptyLines = true;</span>
<span class="fc" id="L208">        byte[] lastline = null;</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">        while ((len = fis.readLine(lbuf)) != -1) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (lbuf[--len] != '\n') {</span>
<span class="nc" id="L212">                throw new IOException(&quot;manifest line too long&quot;);</span>
            }
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">            if (len &gt; 0 &amp;&amp; lbuf[len-1] == '\r') {</span>
<span class="fc" id="L215">                --len;</span>
            }
<span class="pc bpc" id="L217" title="3 of 4 branches missed.">            if (len == 0 &amp;&amp; skipEmptyLines) {</span>
<span class="nc" id="L218">                continue;</span>
            }
<span class="fc" id="L220">            skipEmptyLines = false;</span>

<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (name == null) {</span>
<span class="fc" id="L223">                name = parseName(lbuf, len);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if (name == null) {</span>
<span class="nc" id="L225">                    throw new IOException(&quot;invalid manifest format&quot;);</span>
                }
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                if (fis.peek() == ' ') {</span>
                    // name is wrapped
<span class="nc" id="L229">                    lastline = new byte[len - 6];</span>
<span class="nc" id="L230">                    System.arraycopy(lbuf, 6, lastline, 0, len - 6);</span>
<span class="nc" id="L231">                    continue;</span>
                }
            } else {
                // continuation line
<span class="nc" id="L235">                byte[] buf = new byte[lastline.length + len - 1];</span>
<span class="nc" id="L236">                System.arraycopy(lastline, 0, buf, 0, lastline.length);</span>
<span class="nc" id="L237">                System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                if (fis.peek() == ' ') {</span>
                    // name is wrapped
<span class="nc" id="L240">                    lastline = buf;</span>
<span class="nc" id="L241">                    continue;</span>
                }
<span class="nc" id="L243">                name = new String(buf, 0, buf.length, &quot;UTF8&quot;);</span>
<span class="nc" id="L244">                lastline = null;</span>
            }
<span class="fc" id="L246">            Attributes attr = getAttributes(name);</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if (attr == null) {</span>
<span class="fc" id="L248">                attr = new Attributes(asize);</span>
<span class="fc" id="L249">                entries.put(name, attr);</span>
            }
<span class="fc" id="L251">            attr.read(fis, lbuf);</span>
<span class="fc" id="L252">            ecount++;</span>
<span class="fc" id="L253">            acount += attr.size();</span>
            //XXX: Fix for when the average is 0. When it is 0,
            // you get an Attributes object with an initial
            // capacity of 0, which tickles a bug in HashMap.
<span class="fc" id="L257">            asize = Math.max(2, acount / ecount);</span>

<span class="fc" id="L259">            name = null;</span>
<span class="fc" id="L260">            skipEmptyLines = true;</span>
<span class="fc" id="L261">        }</span>
<span class="fc" id="L262">    }</span>

    private String parseName(byte[] lbuf, int len) {
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">        if (toLower(lbuf[0]) == 'n' &amp;&amp; toLower(lbuf[1]) == 'a' &amp;&amp;</span>
<span class="pc bpc" id="L266" title="4 of 8 branches missed.">            toLower(lbuf[2]) == 'm' &amp;&amp; toLower(lbuf[3]) == 'e' &amp;&amp;</span>
            lbuf[4] == ':' &amp;&amp; lbuf[5] == ' ') {
            try {
<span class="fc" id="L269">                return new String(lbuf, 6, len - 6, &quot;UTF8&quot;);</span>
            }
<span class="nc" id="L271">            catch (Exception e) {</span>
            }
        }
<span class="nc" id="L274">        return null;</span>
    }

    private int toLower(int c) {
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">        return (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? 'a' + (c - 'A') : c;</span>
    }

    /**
     * Returns true if the specified Object is also a Manifest and has
     * the same main Attributes and entries.
     *
     * @param o the object to be compared
     * @return true if the specified Object is also a Manifest and has
     * the same main Attributes and entries
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (o instanceof Manifest) {</span>
<span class="nc" id="L291">            Manifest m = (Manifest)o;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            return attr.equals(m.getMainAttributes()) &amp;&amp;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                   entries.equals(m.getEntries());</span>
        } else {
<span class="nc" id="L295">            return false;</span>
        }
    }

    /**
     * Returns the hash code for this Manifest.
     */
    public int hashCode() {
<span class="nc" id="L303">        return attr.hashCode() + entries.hashCode();</span>
    }

    /**
     * Returns a shallow copy of this Manifest.  The shallow copy is
     * implemented as follows:
     * &lt;pre&gt;
     *     public Object clone() { return new Manifest(this); }
     * &lt;/pre&gt;
     * @return a shallow copy of this Manifest
     */
    public Object clone() {
<span class="nc" id="L315">        return new Manifest(this);</span>
    }

    /*
     * A fast buffered input stream for parsing manifest files.
     */
    static class FastInputStream extends FilterInputStream {
        private byte buf[];
<span class="fc" id="L323">        private int count = 0;</span>
<span class="fc" id="L324">        private int pos = 0;</span>

        FastInputStream(InputStream in) {
<span class="fc" id="L327">            this(in, 8192);</span>
<span class="fc" id="L328">        }</span>

        FastInputStream(InputStream in, int size) {
<span class="fc" id="L331">            super(in);</span>
<span class="fc" id="L332">            buf = new byte[size];</span>
<span class="fc" id="L333">        }</span>

        public int read() throws IOException {
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (pos &gt;= count) {</span>
<span class="nc" id="L337">                fill();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (pos &gt;= count) {</span>
<span class="nc" id="L339">                    return -1;</span>
                }
            }
<span class="nc" id="L342">            return Byte.toUnsignedInt(buf[pos++]);</span>
        }

        public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L346">            int avail = count - pos;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (avail &lt;= 0) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (len &gt;= buf.length) {</span>
<span class="nc" id="L349">                    return in.read(b, off, len);</span>
                }
<span class="nc" id="L351">                fill();</span>
<span class="nc" id="L352">                avail = count - pos;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (avail &lt;= 0) {</span>
<span class="nc" id="L354">                    return -1;</span>
                }
            }
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (len &gt; avail) {</span>
<span class="nc" id="L358">                len = avail;</span>
            }
<span class="nc" id="L360">            System.arraycopy(buf, pos, b, off, len);</span>
<span class="nc" id="L361">            pos += len;</span>
<span class="nc" id="L362">            return len;</span>
        }

        /*
         * Reads 'len' bytes from the input stream, or until an end-of-line
         * is reached. Returns the number of bytes read.
         */
        public int readLine(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L370">            byte[] tbuf = this.buf;</span>
<span class="fc" id="L371">            int total = 0;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            while (total &lt; len) {</span>
<span class="fc" id="L373">                int avail = count - pos;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (avail &lt;= 0) {</span>
<span class="fc" id="L375">                    fill();</span>
<span class="fc" id="L376">                    avail = count - pos;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                    if (avail &lt;= 0) {</span>
<span class="fc" id="L378">                        return -1;</span>
                    }
                }
<span class="fc" id="L381">                int n = len - total;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                if (n &gt; avail) {</span>
<span class="fc" id="L383">                    n = avail;</span>
                }
<span class="fc" id="L385">                int tpos = pos;</span>
<span class="fc" id="L386">                int maxpos = tpos + n;</span>
<span class="pc bpc" id="L387" title="1 of 4 branches missed.">                while (tpos &lt; maxpos &amp;&amp; tbuf[tpos++] != '\n') ;</span>
<span class="fc" id="L388">                n = tpos - pos;</span>
<span class="fc" id="L389">                System.arraycopy(tbuf, pos, b, off, n);</span>
<span class="fc" id="L390">                off += n;</span>
<span class="fc" id="L391">                total += n;</span>
<span class="fc" id="L392">                pos = tpos;</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">                if (tbuf[tpos-1] == '\n') {</span>
<span class="fc" id="L394">                    break;</span>
                }
<span class="nc" id="L396">            }</span>
<span class="fc" id="L397">            return total;</span>
        }

        public byte peek() throws IOException {
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (pos == count)</span>
<span class="fc" id="L402">                fill();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (pos == count)</span>
<span class="fc" id="L404">                return -1; // nothing left in buffer</span>
<span class="fc" id="L405">            return buf[pos];</span>
        }

        public int readLine(byte[] b) throws IOException {
<span class="fc" id="L409">            return readLine(b, 0, b.length);</span>
        }

        public long skip(long n) throws IOException {
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc" id="L414">                return 0;</span>
            }
<span class="nc" id="L416">            long avail = count - pos;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (avail &lt;= 0) {</span>
<span class="nc" id="L418">                return in.skip(n);</span>
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (n &gt; avail) {</span>
<span class="nc" id="L421">                n = avail;</span>
            }
<span class="nc" id="L423">            pos += n;</span>
<span class="nc" id="L424">            return n;</span>
        }

        public int available() throws IOException {
<span class="nc" id="L428">            return (count - pos) + in.available();</span>
        }

        public void close() throws IOException {
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (in != null) {</span>
<span class="nc" id="L433">                in.close();</span>
<span class="nc" id="L434">                in = null;</span>
<span class="nc" id="L435">                buf = null;</span>
            }
<span class="nc" id="L437">        }</span>

        private void fill() throws IOException {
<span class="fc" id="L440">            count = pos = 0;</span>
<span class="fc" id="L441">            int n = in.read(buf, 0, buf.length);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (n &gt; 0) {</span>
<span class="fc" id="L443">                count = n;</span>
            }
<span class="fc" id="L445">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>