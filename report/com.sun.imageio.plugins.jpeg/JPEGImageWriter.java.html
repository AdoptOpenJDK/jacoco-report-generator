<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JPEGImageWriter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.jpeg</a> &gt; <span class="el_source">JPEGImageWriter.java</span></div><h1>JPEGImageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.jpeg;

import javax.imageio.IIOException;
import javax.imageio.ImageWriter;
import javax.imageio.ImageWriteParam;
import javax.imageio.IIOImage;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.spi.ImageWriterSpi;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.plugins.jpeg.JPEGImageWriteParam;
import javax.imageio.plugins.jpeg.JPEGQTable;
import javax.imageio.plugins.jpeg.JPEGHuffmanTable;

import org.w3c.dom.Node;

import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.image.SampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.ColorConvertOp;
import java.awt.image.RenderedImage;
import java.awt.image.BufferedImage;
import java.awt.color.ColorSpace;
import java.awt.color.ICC_ColorSpace;
import java.awt.color.ICC_Profile;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.Transparency;

import java.io.IOException;

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

import sun.java2d.Disposer;
import sun.java2d.DisposerRecord;

public class JPEGImageWriter extends ImageWriter {

    ///////// Private variables

<span class="nc" id="L74">    private boolean debug = false;</span>

    /**
     * The following variable contains a pointer to the IJG library
     * structure for this reader.  It is assigned in the constructor
     * and then is passed in to every native call.  It is set to 0
     * by dispose to avoid disposing twice.
     */
<span class="nc" id="L82">    private long structPointer = 0;</span>


    /** The output stream we write to */
<span class="nc" id="L86">    private ImageOutputStream ios = null;</span>

    /** The Raster we will write from */
<span class="nc" id="L89">    private Raster srcRas = null;</span>

    /** An intermediate Raster holding compressor-friendly data */
<span class="nc" id="L92">    private WritableRaster raster = null;</span>

    /**
     * Set to true if we are writing an image with an
     * indexed ColorModel
     */
<span class="nc" id="L98">    private boolean indexed = false;</span>
<span class="nc" id="L99">    private IndexColorModel indexCM = null;</span>

<span class="nc" id="L101">    private boolean convertTosRGB = false;  // Used by PhotoYCC only</span>
<span class="nc" id="L102">    private WritableRaster converted = null;</span>

<span class="nc" id="L104">    private boolean isAlphaPremultiplied = false;</span>
<span class="nc" id="L105">    private ColorModel srcCM = null;</span>

    /**
     * If there are thumbnails to be written, this is the list.
     */
<span class="nc" id="L110">    private List thumbnails = null;</span>

    /**
     * If metadata should include an icc profile, store it here.
     */
<span class="nc" id="L115">    private ICC_Profile iccProfile = null;</span>

<span class="nc" id="L117">    private int sourceXOffset = 0;</span>
<span class="nc" id="L118">    private int sourceYOffset = 0;</span>
<span class="nc" id="L119">    private int sourceWidth = 0;</span>
<span class="nc" id="L120">    private int [] srcBands = null;</span>
<span class="nc" id="L121">    private int sourceHeight = 0;</span>

    /** Used when calling listeners */
<span class="nc" id="L124">    private int currentImage = 0;</span>

<span class="nc" id="L126">    private ColorConvertOp convertOp = null;</span>

<span class="nc" id="L128">    private JPEGQTable [] streamQTables = null;</span>
<span class="nc" id="L129">    private JPEGHuffmanTable[] streamDCHuffmanTables = null;</span>
<span class="nc" id="L130">    private JPEGHuffmanTable[] streamACHuffmanTables = null;</span>

    // Parameters for writing metadata
<span class="nc" id="L133">    private boolean ignoreJFIF = false;  // If it's there, use it</span>
<span class="nc" id="L134">    private boolean forceJFIF = false;  // Add one for the thumbnails</span>
<span class="nc" id="L135">    private boolean ignoreAdobe = false;  // If it's there, use it</span>
<span class="nc" id="L136">    private int newAdobeTransform = JPEG.ADOBE_IMPOSSIBLE;  // Change if needed</span>
<span class="nc" id="L137">    private boolean writeDefaultJFIF = false;</span>
<span class="nc" id="L138">    private boolean writeAdobe = false;</span>
<span class="nc" id="L139">    private JPEGMetadata metadata = null;</span>

<span class="nc" id="L141">    private boolean sequencePrepared = false;</span>

<span class="nc" id="L143">    private int numScans = 0;</span>

    /** The referent to be registered with the Disposer. */
<span class="nc" id="L146">    private Object disposerReferent = new Object();</span>

    /** The DisposerRecord that handles the actual disposal of this writer. */
    private DisposerRecord disposerRecord;

    ///////// End of Private variables

    ///////// Protected variables

    protected static final int WARNING_DEST_IGNORED = 0;
    protected static final int WARNING_STREAM_METADATA_IGNORED = 1;
    protected static final int WARNING_DEST_METADATA_COMP_MISMATCH = 2;
    protected static final int WARNING_DEST_METADATA_JFIF_MISMATCH = 3;
    protected static final int WARNING_DEST_METADATA_ADOBE_MISMATCH = 4;
    protected static final int WARNING_IMAGE_METADATA_JFIF_MISMATCH = 5;
    protected static final int WARNING_IMAGE_METADATA_ADOBE_MISMATCH = 6;
    protected static final int WARNING_METADATA_NOT_JPEG_FOR_RASTER = 7;
    protected static final int WARNING_NO_BANDS_ON_INDEXED = 8;
    protected static final int WARNING_ILLEGAL_THUMBNAIL = 9;
    protected static final int WARNING_IGNORING_THUMBS = 10;
    protected static final int WARNING_FORCING_JFIF = 11;
    protected static final int WARNING_THUMB_CLIPPED = 12;
    protected static final int WARNING_METADATA_ADJUSTED_FOR_THUMB = 13;
    protected static final int WARNING_NO_RGB_THUMB_AS_INDEXED = 14;
    protected static final int WARNING_NO_GRAY_THUMB_AS_INDEXED = 15;

    private static final int MAX_WARNING = WARNING_NO_GRAY_THUMB_AS_INDEXED;

    ///////// End of Protected variables

    ///////// static initializer

    static {
<span class="nc" id="L179">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L180">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="nc" id="L182">                    System.loadLibrary(&quot;jpeg&quot;);</span>
<span class="nc" id="L183">                    return null;</span>
                }
            });
<span class="nc" id="L186">        initWriterIDs(JPEGQTable.class,</span>
                      JPEGHuffmanTable.class);
    }

    //////// Public API

    public JPEGImageWriter(ImageWriterSpi originator) {
<span class="nc" id="L193">        super(originator);</span>
<span class="nc" id="L194">        structPointer = initJPEGImageWriter();</span>
<span class="nc" id="L195">        disposerRecord = new JPEGWriterDisposerRecord(structPointer);</span>
<span class="nc" id="L196">        Disposer.addRecord(disposerReferent, disposerRecord);</span>
<span class="nc" id="L197">    }</span>

    public void setOutput(Object output) {
<span class="nc" id="L200">        setThreadLock();</span>
        try {
<span class="nc" id="L202">            cbLock.check();</span>

<span class="nc" id="L204">            super.setOutput(output); // validates output</span>
<span class="nc" id="L205">            resetInternalState();</span>
<span class="nc" id="L206">            ios = (ImageOutputStream) output; // so this will always work</span>
            // Set the native destination
<span class="nc" id="L208">            setDest(structPointer);</span>
        } finally {
<span class="nc" id="L210">            clearThreadLock();</span>
<span class="nc" id="L211">        }</span>
<span class="nc" id="L212">    }</span>

    public ImageWriteParam getDefaultWriteParam() {
<span class="nc" id="L215">        return new JPEGImageWriteParam(null);</span>
    }

    public IIOMetadata getDefaultStreamMetadata(ImageWriteParam param) {
<span class="nc" id="L219">        setThreadLock();</span>
        try {
<span class="nc" id="L221">            return new JPEGMetadata(param, this);</span>
        } finally {
<span class="nc" id="L223">            clearThreadLock();</span>
        }
    }

    public IIOMetadata
        getDefaultImageMetadata(ImageTypeSpecifier imageType,
                                ImageWriteParam param) {
<span class="nc" id="L230">        setThreadLock();</span>
        try {
<span class="nc" id="L232">            return new JPEGMetadata(imageType, param, this);</span>
        } finally {
<span class="nc" id="L234">            clearThreadLock();</span>
        }
    }

    public IIOMetadata convertStreamMetadata(IIOMetadata inData,
                                             ImageWriteParam param) {
        // There isn't much we can do.  If it's one of ours, then
        // return it.  Otherwise just return null.  We use it only
        // for tables, so we can't get a default and modify it,
        // as this will usually not be what is intended.
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (inData instanceof JPEGMetadata) {</span>
<span class="nc" id="L245">            JPEGMetadata jpegData = (JPEGMetadata) inData;</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (jpegData.isStream) {</span>
<span class="nc" id="L247">                return inData;</span>
            }
        }
<span class="nc" id="L250">        return null;</span>
    }

    public IIOMetadata
        convertImageMetadata(IIOMetadata inData,
                             ImageTypeSpecifier imageType,
                             ImageWriteParam param) {
<span class="nc" id="L257">        setThreadLock();</span>
        try {
<span class="nc" id="L259">            return convertImageMetadataOnThread(inData, imageType, param);</span>
        } finally {
<span class="nc" id="L261">            clearThreadLock();</span>
        }
    }

    private IIOMetadata
        convertImageMetadataOnThread(IIOMetadata inData,
                                     ImageTypeSpecifier imageType,
                                     ImageWriteParam param) {
        // If it's one of ours, just return it
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (inData instanceof JPEGMetadata) {</span>
<span class="nc" id="L271">            JPEGMetadata jpegData = (JPEGMetadata) inData;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            if (!jpegData.isStream) {</span>
<span class="nc" id="L273">                return inData;</span>
            } else {
                // Can't convert stream metadata to image metadata
                // XXX Maybe this should put out a warning?
<span class="nc" id="L277">                return null;</span>
            }
        }
        // If it's not one of ours, create a default and set it from
        // the standard tree from the input, if it exists.
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (inData.isStandardMetadataFormatSupported()) {</span>
<span class="nc" id="L283">            String formatName =</span>
                IIOMetadataFormatImpl.standardMetadataFormatName;
<span class="nc" id="L285">            Node tree = inData.getAsTree(formatName);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (tree != null) {</span>
<span class="nc" id="L287">                JPEGMetadata jpegData = new JPEGMetadata(imageType,</span>
                                                         param,
                                                         this);
                try {
<span class="nc" id="L291">                    jpegData.setFromTree(formatName, tree);</span>
<span class="nc" id="L292">                } catch (IIOInvalidTreeException e) {</span>
                    // Other plug-in generates bogus standard tree
                    // XXX Maybe this should put out a warning?
<span class="nc" id="L295">                    return null;</span>
<span class="nc" id="L296">                }</span>

<span class="nc" id="L298">                return jpegData;</span>
            }
        }
<span class="nc" id="L301">        return null;</span>
    }

    public int getNumThumbnailsSupported(ImageTypeSpecifier imageType,
                                         ImageWriteParam param,
                                         IIOMetadata streamMetadata,
                                         IIOMetadata imageMetadata) {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (jfifOK(imageType, param, streamMetadata, imageMetadata)) {</span>
<span class="nc" id="L309">            return Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L311">        return 0;</span>
    }

<span class="nc" id="L314">    static final Dimension [] preferredThumbSizes = {new Dimension(1, 1),</span>
                                                     new Dimension(255, 255)};

    public Dimension[] getPreferredThumbnailSizes(ImageTypeSpecifier imageType,
                                                  ImageWriteParam param,
                                                  IIOMetadata streamMetadata,
                                                  IIOMetadata imageMetadata) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (jfifOK(imageType, param, streamMetadata, imageMetadata)) {</span>
<span class="nc" id="L322">            return (Dimension [])preferredThumbSizes.clone();</span>
        }
<span class="nc" id="L324">        return null;</span>
    }

    private boolean jfifOK(ImageTypeSpecifier imageType,
                           ImageWriteParam param,
                           IIOMetadata streamMetadata,
                           IIOMetadata imageMetadata) {
        // If the image type and metadata are JFIF compatible, return true
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if ((imageType != null) &amp;&amp;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            (!JPEG.isJFIFcompliant(imageType, true))) {</span>
<span class="nc" id="L334">            return false;</span>
        }
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (imageMetadata != null) {</span>
<span class="nc" id="L337">            JPEGMetadata metadata = null;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (imageMetadata instanceof JPEGMetadata) {</span>
<span class="nc" id="L339">                metadata = (JPEGMetadata) imageMetadata;</span>
            } else {
<span class="nc" id="L341">                metadata = (JPEGMetadata)convertImageMetadata(imageMetadata,</span>
                                                              imageType,
                                                              param);
            }
            // metadata must have a jfif node
<span class="nc" id="L346">            if (metadata.findMarkerSegment</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                (JFIFMarkerSegment.class, true) == null){</span>
<span class="nc" id="L348">                return false;</span>
            }
        }
<span class="nc" id="L351">        return true;</span>
    }

    public boolean canWriteRasters() {
<span class="nc" id="L355">        return true;</span>
    }

    public void write(IIOMetadata streamMetadata,
                      IIOImage image,
                      ImageWriteParam param) throws IOException {
<span class="nc" id="L361">        setThreadLock();</span>
        try {
<span class="nc" id="L363">            cbLock.check();</span>

<span class="nc" id="L365">            writeOnThread(streamMetadata, image, param);</span>
        } finally {
<span class="nc" id="L367">            clearThreadLock();</span>
<span class="nc" id="L368">        }</span>
<span class="nc" id="L369">    }</span>

    private void writeOnThread(IIOMetadata streamMetadata,
                      IIOImage image,
                      ImageWriteParam param) throws IOException {

<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (ios == null) {</span>
<span class="nc" id="L376">            throw new IllegalStateException(&quot;Output has not been set!&quot;);</span>
        }

<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L380">            throw new IllegalArgumentException(&quot;image is null!&quot;);</span>
        }

        // if streamMetadata is not null, issue a warning
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (streamMetadata != null) {</span>
<span class="nc" id="L385">            warningOccurred(WARNING_STREAM_METADATA_IGNORED);</span>
        }

        // Obtain the raster and image, if there is one
<span class="nc" id="L389">        boolean rasterOnly = image.hasRaster();</span>

<span class="nc" id="L391">        RenderedImage rimage = null;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (rasterOnly) {</span>
<span class="nc" id="L393">            srcRas = image.getRaster();</span>
        } else {
<span class="nc" id="L395">            rimage = image.getRenderedImage();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (rimage instanceof BufferedImage) {</span>
                // Use the Raster directly.
<span class="nc" id="L398">                srcRas = ((BufferedImage)rimage).getRaster();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            } else if (rimage.getNumXTiles() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                       rimage.getNumYTiles() == 1)</span>
            {
                // Get the unique tile.
<span class="nc" id="L403">                srcRas = rimage.getTile(rimage.getMinTileX(),</span>
<span class="nc" id="L404">                                        rimage.getMinTileY());</span>

                // Ensure the Raster has dimensions of the image,
                // as the tile dimensions might differ.
<span class="nc bnc" id="L408" title="All 2 branches missed.">                if (srcRas.getWidth() != rimage.getWidth() ||</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                    srcRas.getHeight() != rimage.getHeight())</span>
                {
<span class="nc" id="L411">                    srcRas = srcRas.createChild(srcRas.getMinX(),</span>
<span class="nc" id="L412">                                                srcRas.getMinY(),</span>
<span class="nc" id="L413">                                                rimage.getWidth(),</span>
<span class="nc" id="L414">                                                rimage.getHeight(),</span>
<span class="nc" id="L415">                                                srcRas.getMinX(),</span>
<span class="nc" id="L416">                                                srcRas.getMinY(),</span>
                                                null);
                }
            } else {
                // Image is tiled so get a contiguous raster by copying.
<span class="nc" id="L421">                srcRas = rimage.getData();</span>
            }
        }

        // Now determine if we are using a band subset

        // By default, we are using all source bands
<span class="nc" id="L428">        int numSrcBands = srcRas.getNumBands();</span>
<span class="nc" id="L429">        indexed = false;</span>
<span class="nc" id="L430">        indexCM = null;</span>
<span class="nc" id="L431">        ColorModel cm = null;</span>
<span class="nc" id="L432">        ColorSpace cs = null;</span>
<span class="nc" id="L433">        isAlphaPremultiplied = false;</span>
<span class="nc" id="L434">        srcCM = null;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (!rasterOnly) {</span>
<span class="nc" id="L436">            cm = rimage.getColorModel();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            if (cm != null) {</span>
<span class="nc" id="L438">                cs = cm.getColorSpace();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (cm instanceof IndexColorModel) {</span>
<span class="nc" id="L440">                    indexed = true;</span>
<span class="nc" id="L441">                    indexCM = (IndexColorModel) cm;</span>
<span class="nc" id="L442">                    numSrcBands = cm.getNumComponents();</span>
                }
<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (cm.isAlphaPremultiplied()) {</span>
<span class="nc" id="L445">                    isAlphaPremultiplied = true;</span>
<span class="nc" id="L446">                    srcCM = cm;</span>
                }
            }
        }

<span class="nc" id="L451">        srcBands = JPEG.bandOffsets[numSrcBands-1];</span>
<span class="nc" id="L452">        int numBandsUsed = numSrcBands;</span>
        // Consult the param to determine if we're writing a subset

<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L456">            int[] sBands = param.getSourceBands();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (sBands != null) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (indexed) {</span>
<span class="nc" id="L459">                    warningOccurred(WARNING_NO_BANDS_ON_INDEXED);</span>
                } else {
<span class="nc" id="L461">                    srcBands = sBands;</span>
<span class="nc" id="L462">                    numBandsUsed = srcBands.length;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                    if (numBandsUsed &gt; numSrcBands) {</span>
<span class="nc" id="L464">                        throw new IIOException</span>
                        (&quot;ImageWriteParam specifies too many source bands&quot;);
                    }
                }
            }
        }

<span class="nc bnc" id="L471" title="All 2 branches missed.">        boolean usingBandSubset = (numBandsUsed != numSrcBands);</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">        boolean fullImage = ((!rasterOnly) &amp;&amp; (!usingBandSubset));</span>

<span class="nc" id="L474">        int [] bandSizes = null;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (!indexed) {</span>
<span class="nc" id="L476">            bandSizes = srcRas.getSampleModel().getSampleSize();</span>
            // If this is a subset, we must adjust bandSizes
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (usingBandSubset) {</span>
<span class="nc" id="L479">                int [] temp = new int [numBandsUsed];</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                for (int i = 0; i &lt; numBandsUsed; i++) {</span>
<span class="nc" id="L481">                    temp[i] = bandSizes[srcBands[i]];</span>
                }
<span class="nc" id="L483">                bandSizes = temp;</span>
<span class="nc" id="L484">            }</span>
        } else {
<span class="nc" id="L486">            int [] tempSize = srcRas.getSampleModel().getSampleSize();</span>
<span class="nc" id="L487">            bandSizes = new int [numSrcBands];</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">            for (int i = 0; i &lt; numSrcBands; i++) {</span>
<span class="nc" id="L489">                bandSizes[i] = tempSize[0];  // All the same</span>
            }
        }

<span class="nc bnc" id="L493" title="All 2 branches missed.">        for (int i = 0; i &lt; bandSizes.length; i++) {</span>
            // 4450894 part 1: The IJG libraries are compiled so they only
            // handle &lt;= 8-bit samples.  We now check the band sizes and throw
            // an exception for images, such as USHORT_GRAY, with &gt; 8 bits
            // per sample.
<span class="nc bnc" id="L498" title="All 4 branches missed.">            if (bandSizes[i] &lt;= 0 || bandSizes[i] &gt; 8) {</span>
<span class="nc" id="L499">                throw new IIOException(&quot;Illegal band size: should be 0 &lt; size &lt;= 8&quot;);</span>
            }
            // 4450894 part 2: We expand IndexColorModel images to full 24-
            // or 32-bit in grabPixels() for each scanline.  For indexed
            // images such as BYTE_BINARY, we need to ensure that we update
            // bandSizes to account for the scaling from 1-bit band sizes
            // to 8-bit.
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (indexed) {</span>
<span class="nc" id="L507">                bandSizes[i] = 8;</span>
            }
        }

<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L512">            System.out.println(&quot;numSrcBands is &quot; + numSrcBands);</span>
<span class="nc" id="L513">            System.out.println(&quot;numBandsUsed is &quot; + numBandsUsed);</span>
<span class="nc" id="L514">            System.out.println(&quot;usingBandSubset is &quot; + usingBandSubset);</span>
<span class="nc" id="L515">            System.out.println(&quot;fullImage is &quot; + fullImage);</span>
<span class="nc" id="L516">            System.out.print(&quot;Band sizes:&quot;);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">            for (int i = 0; i&lt; bandSizes.length; i++) {</span>
<span class="nc" id="L518">                System.out.print(&quot; &quot; + bandSizes[i]);</span>
            }
<span class="nc" id="L520">            System.out.println();</span>
        }

        // Destination type, if there is one
<span class="nc" id="L524">        ImageTypeSpecifier destType = null;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L526">            destType = param.getDestinationType();</span>
            // Ignore dest type if we are writing a complete image
<span class="nc bnc" id="L528" title="All 4 branches missed.">            if ((fullImage) &amp;&amp; (destType != null)) {</span>
<span class="nc" id="L529">                warningOccurred(WARNING_DEST_IGNORED);</span>
<span class="nc" id="L530">                destType = null;</span>
            }
        }

        // Examine the param

<span class="nc" id="L536">        sourceXOffset = srcRas.getMinX();</span>
<span class="nc" id="L537">        sourceYOffset = srcRas.getMinY();</span>
<span class="nc" id="L538">        int imageWidth = srcRas.getWidth();</span>
<span class="nc" id="L539">        int imageHeight = srcRas.getHeight();</span>
<span class="nc" id="L540">        sourceWidth = imageWidth;</span>
<span class="nc" id="L541">        sourceHeight = imageHeight;</span>
<span class="nc" id="L542">        int periodX = 1;</span>
<span class="nc" id="L543">        int periodY = 1;</span>
<span class="nc" id="L544">        int gridX = 0;</span>
<span class="nc" id="L545">        int gridY = 0;</span>
<span class="nc" id="L546">        JPEGQTable [] qTables = null;</span>
<span class="nc" id="L547">        JPEGHuffmanTable[] DCHuffmanTables = null;</span>
<span class="nc" id="L548">        JPEGHuffmanTable[] ACHuffmanTables = null;</span>
<span class="nc" id="L549">        boolean optimizeHuffman = false;</span>
<span class="nc" id="L550">        JPEGImageWriteParam jparam = null;</span>
<span class="nc" id="L551">        int progressiveMode = ImageWriteParam.MODE_DISABLED;</span>

<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (param != null) {</span>

<span class="nc" id="L555">            Rectangle sourceRegion = param.getSourceRegion();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (sourceRegion != null) {</span>
<span class="nc" id="L557">                Rectangle imageBounds = new Rectangle(sourceXOffset,</span>
                                                      sourceYOffset,
                                                      sourceWidth,
                                                      sourceHeight);
<span class="nc" id="L561">                sourceRegion = sourceRegion.intersection(imageBounds);</span>
<span class="nc" id="L562">                sourceXOffset = sourceRegion.x;</span>
<span class="nc" id="L563">                sourceYOffset = sourceRegion.y;</span>
<span class="nc" id="L564">                sourceWidth = sourceRegion.width;</span>
<span class="nc" id="L565">                sourceHeight = sourceRegion.height;</span>
            }

<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (sourceWidth + sourceXOffset &gt; imageWidth) {</span>
<span class="nc" id="L569">                sourceWidth = imageWidth - sourceXOffset;</span>
            }
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (sourceHeight + sourceYOffset &gt; imageHeight) {</span>
<span class="nc" id="L572">                sourceHeight = imageHeight - sourceYOffset;</span>
            }

<span class="nc" id="L575">            periodX = param.getSourceXSubsampling();</span>
<span class="nc" id="L576">            periodY = param.getSourceYSubsampling();</span>
<span class="nc" id="L577">            gridX = param.getSubsamplingXOffset();</span>
<span class="nc" id="L578">            gridY = param.getSubsamplingYOffset();</span>

<span class="nc bnc" id="L580" title="All 4 branches missed.">            switch(param.getCompressionMode()) {</span>
            case ImageWriteParam.MODE_DISABLED:
<span class="nc" id="L582">                throw new IIOException(&quot;JPEG compression cannot be disabled&quot;);</span>
            case ImageWriteParam.MODE_EXPLICIT:
<span class="nc" id="L584">                float quality = param.getCompressionQuality();</span>
<span class="nc" id="L585">                quality = JPEG.convertToLinearQuality(quality);</span>
<span class="nc" id="L586">                qTables = new JPEGQTable[2];</span>
<span class="nc" id="L587">                qTables[0] = JPEGQTable.K1Luminance.getScaledInstance</span>
<span class="nc" id="L588">                    (quality, true);</span>
<span class="nc" id="L589">                qTables[1] = JPEGQTable.K2Chrominance.getScaledInstance</span>
<span class="nc" id="L590">                    (quality, true);</span>
<span class="nc" id="L591">                break;</span>
            case ImageWriteParam.MODE_DEFAULT:
<span class="nc" id="L593">                qTables = new JPEGQTable[2];</span>
<span class="nc" id="L594">                qTables[0] = JPEGQTable.K1Div2Luminance;</span>
<span class="nc" id="L595">                qTables[1] = JPEGQTable.K2Div2Chrominance;</span>
                break;
            // We'll handle the metadata case later
            }

<span class="nc" id="L600">            progressiveMode = param.getProgressiveMode();</span>

<span class="nc bnc" id="L602" title="All 2 branches missed.">            if (param instanceof JPEGImageWriteParam) {</span>
<span class="nc" id="L603">                jparam = (JPEGImageWriteParam)param;</span>
<span class="nc" id="L604">                optimizeHuffman = jparam.getOptimizeHuffmanTables();</span>
            }
        }

        // Now examine the metadata
<span class="nc" id="L609">        IIOMetadata mdata = image.getMetadata();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (mdata != null) {</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (mdata instanceof JPEGMetadata) {</span>
<span class="nc" id="L612">                metadata = (JPEGMetadata) mdata;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L614">                    System.out.println</span>
<span class="nc" id="L615">                        (&quot;We have metadata, and it's JPEG metadata&quot;);</span>
                }
            } else {
<span class="nc bnc" id="L618" title="All 2 branches missed.">                if (!rasterOnly) {</span>
<span class="nc" id="L619">                    ImageTypeSpecifier type = destType;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">                    if (type == null) {</span>
<span class="nc" id="L621">                        type = new ImageTypeSpecifier(rimage);</span>
                    }
<span class="nc" id="L623">                    metadata = (JPEGMetadata) convertImageMetadata(mdata,</span>
                                                                   type,
                                                                   param);
<span class="nc" id="L626">                } else {</span>
<span class="nc" id="L627">                    warningOccurred(WARNING_METADATA_NOT_JPEG_FOR_RASTER);</span>
                }
            }
        }

        // First set a default state

<span class="nc" id="L634">        ignoreJFIF = false;  // If it's there, use it</span>
<span class="nc" id="L635">        ignoreAdobe = false;  // If it's there, use it</span>
<span class="nc" id="L636">        newAdobeTransform = JPEG.ADOBE_IMPOSSIBLE;  // Change if needed</span>
<span class="nc" id="L637">        writeDefaultJFIF = false;</span>
<span class="nc" id="L638">        writeAdobe = false;</span>

        // By default we'll do no conversion:
<span class="nc" id="L641">        int inCsType = JPEG.JCS_UNKNOWN;</span>
<span class="nc" id="L642">        int outCsType = JPEG.JCS_UNKNOWN;</span>

<span class="nc" id="L644">        JFIFMarkerSegment jfif = null;</span>
<span class="nc" id="L645">        AdobeMarkerSegment adobe = null;</span>
<span class="nc" id="L646">        SOFMarkerSegment sof = null;</span>

<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (metadata != null) {</span>
<span class="nc" id="L649">            jfif = (JFIFMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L650">                (JFIFMarkerSegment.class, true);</span>
<span class="nc" id="L651">            adobe = (AdobeMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L652">                (AdobeMarkerSegment.class, true);</span>
<span class="nc" id="L653">            sof = (SOFMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L654">                (SOFMarkerSegment.class, true);</span>
        }

<span class="nc" id="L657">        iccProfile = null;  // By default don't write one</span>
<span class="nc" id="L658">        convertTosRGB = false;  // PhotoYCC does this</span>
<span class="nc" id="L659">        converted = null;</span>

<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (destType != null) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (numBandsUsed != destType.getNumBands()) {</span>
<span class="nc" id="L663">                throw new IIOException</span>
                    (&quot;Number of source bands != number of destination bands&quot;);
            }
<span class="nc" id="L666">            cs = destType.getColorModel().getColorSpace();</span>
            // Check the metadata against the destination type
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (metadata != null) {</span>
<span class="nc" id="L669">                checkSOFBands(sof, numBandsUsed);</span>

<span class="nc" id="L671">                checkJFIF(jfif, destType, false);</span>
                // Do we want to write an ICC profile?
<span class="nc bnc" id="L673" title="All 4 branches missed.">                if ((jfif != null) &amp;&amp; (ignoreJFIF == false)) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    if (JPEG.isNonStandardICC(cs)) {</span>
<span class="nc" id="L675">                        iccProfile = ((ICC_ColorSpace) cs).getProfile();</span>
                    }
                }
<span class="nc" id="L678">                checkAdobe(adobe, destType, false);</span>

            } else { // no metadata, but there is a dest type
                // If we can add a JFIF or an Adobe marker segment, do so
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (JPEG.isJFIFcompliant(destType, false)) {</span>
<span class="nc" id="L683">                    writeDefaultJFIF = true;</span>
                    // Do we want to write an ICC profile?
<span class="nc bnc" id="L685" title="All 2 branches missed.">                    if (JPEG.isNonStandardICC(cs)) {</span>
<span class="nc" id="L686">                        iccProfile = ((ICC_ColorSpace) cs).getProfile();</span>
                    }
                } else {
<span class="nc" id="L689">                    int transform = JPEG.transformForType(destType, false);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                    if (transform != JPEG.ADOBE_IMPOSSIBLE) {</span>
<span class="nc" id="L691">                        writeAdobe = true;</span>
<span class="nc" id="L692">                        newAdobeTransform = transform;</span>
                    }
                }
                // re-create the metadata
<span class="nc" id="L696">                metadata = new JPEGMetadata(destType, null, this);</span>
            }
<span class="nc" id="L698">            inCsType = getSrcCSType(destType);</span>
<span class="nc" id="L699">            outCsType = getDefaultDestCSType(destType);</span>
        } else { // no destination type
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (metadata == null) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (fullImage) {  // no dest, no metadata, full image</span>
                    // Use default metadata matching the image and param
<span class="nc" id="L704">                    metadata = new JPEGMetadata(new ImageTypeSpecifier(rimage),</span>
                                                param, this);
<span class="nc" id="L706">                    if (metadata.findMarkerSegment</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                        (JFIFMarkerSegment.class, true) != null) {</span>
<span class="nc" id="L708">                        cs = rimage.getColorModel().getColorSpace();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                        if (JPEG.isNonStandardICC(cs)) {</span>
<span class="nc" id="L710">                            iccProfile = ((ICC_ColorSpace) cs).getProfile();</span>
                        }
                    }

<span class="nc" id="L714">                    inCsType = getSrcCSType(rimage);</span>
<span class="nc" id="L715">                    outCsType = getDefaultDestCSType(rimage);</span>
                }
                // else no dest, no metadata, not an image,
                // so no special headers, no color conversion
            } else { // no dest type, but there is metadata
<span class="nc" id="L720">                checkSOFBands(sof, numBandsUsed);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                if (fullImage) {  // no dest, metadata, image</span>
                    // Check that the metadata and the image match

<span class="nc" id="L724">                    ImageTypeSpecifier inputType =</span>
                        new ImageTypeSpecifier(rimage);

<span class="nc" id="L727">                    inCsType = getSrcCSType(rimage);</span>

<span class="nc bnc" id="L729" title="All 2 branches missed.">                    if (cm != null) {</span>
<span class="nc" id="L730">                        boolean alpha = cm.hasAlpha();</span>
<span class="nc bnc" id="L731" title="All 4 branches missed.">                        switch (cs.getType()) {</span>
                        case ColorSpace.TYPE_GRAY:
<span class="nc bnc" id="L733" title="All 2 branches missed.">                            if (!alpha) {</span>
<span class="nc" id="L734">                                outCsType = JPEG.JCS_GRAYSCALE;</span>
                            } else {
<span class="nc bnc" id="L736" title="All 2 branches missed.">                                if (jfif != null) {</span>
<span class="nc" id="L737">                                    ignoreJFIF = true;</span>
<span class="nc" id="L738">                                    warningOccurred</span>
<span class="nc" id="L739">                                    (WARNING_IMAGE_METADATA_JFIF_MISMATCH);</span>
                                }
                                // out colorspace remains unknown
                            }
<span class="nc bnc" id="L743" title="All 4 branches missed.">                            if ((adobe != null)</span>
                                &amp;&amp; (adobe.transform != JPEG.ADOBE_UNKNOWN)) {
<span class="nc" id="L745">                                newAdobeTransform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc" id="L746">                                warningOccurred</span>
<span class="nc" id="L747">                                (WARNING_IMAGE_METADATA_ADOBE_MISMATCH);</span>
                            }
                            break;
                        case ColorSpace.TYPE_RGB:
<span class="nc bnc" id="L751" title="All 2 branches missed.">                            if (!alpha) {</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                                if (jfif != null) {</span>
<span class="nc" id="L753">                                    outCsType = JPEG.JCS_YCbCr;</span>
<span class="nc bnc" id="L754" title="All 6 branches missed.">                                    if (JPEG.isNonStandardICC(cs)</span>
                                        || ((cs instanceof ICC_ColorSpace)
                                            &amp;&amp; (jfif.iccSegment != null))) {
<span class="nc" id="L757">                                        iccProfile =</span>
<span class="nc" id="L758">                                            ((ICC_ColorSpace) cs).getProfile();</span>
                                    }
<span class="nc bnc" id="L760" title="All 2 branches missed.">                                } else if (adobe != null) {</span>
<span class="nc bnc" id="L761" title="All 3 branches missed.">                                    switch (adobe.transform) {</span>
                                    case JPEG.ADOBE_UNKNOWN:
<span class="nc" id="L763">                                        outCsType = JPEG.JCS_RGB;</span>
<span class="nc" id="L764">                                        break;</span>
                                    case JPEG.ADOBE_YCC:
<span class="nc" id="L766">                                        outCsType = JPEG.JCS_YCbCr;</span>
<span class="nc" id="L767">                                        break;</span>
                                    default:
<span class="nc" id="L769">                                        warningOccurred</span>
<span class="nc" id="L770">                                        (WARNING_IMAGE_METADATA_ADOBE_MISMATCH);</span>
<span class="nc" id="L771">                                        newAdobeTransform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc" id="L772">                                        outCsType = JPEG.JCS_RGB;</span>
<span class="nc" id="L773">                                        break;</span>
                                    }
                                } else {
                                    // consult the ids
<span class="nc" id="L777">                                    int outCS = sof.getIDencodedCSType();</span>
                                    // if they don't resolve it,
                                    // consult the sampling factors
<span class="nc bnc" id="L780" title="All 2 branches missed.">                                    if (outCS != JPEG.JCS_UNKNOWN) {</span>
<span class="nc" id="L781">                                        outCsType = outCS;</span>
                                    } else {
<span class="nc" id="L783">                                        boolean subsampled =</span>
<span class="nc" id="L784">                                        isSubsampled(sof.componentSpecs);</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">                                        if (subsampled) {</span>
<span class="nc" id="L786">                                            outCsType = JPEG.JCS_YCbCr;</span>
                                        } else {
<span class="nc" id="L788">                                            outCsType = JPEG.JCS_RGB;</span>
                                        }
                                    }
<span class="nc" id="L791">                                }</span>
                            } else { // RGBA
<span class="nc bnc" id="L793" title="All 2 branches missed.">                                if (jfif != null) {</span>
<span class="nc" id="L794">                                    ignoreJFIF = true;</span>
<span class="nc" id="L795">                                    warningOccurred</span>
<span class="nc" id="L796">                                    (WARNING_IMAGE_METADATA_JFIF_MISMATCH);</span>
                                }
<span class="nc bnc" id="L798" title="All 2 branches missed.">                                if (adobe != null) {</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                                    if (adobe.transform</span>
                                        != JPEG.ADOBE_UNKNOWN) {
<span class="nc" id="L801">                                        newAdobeTransform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc" id="L802">                                        warningOccurred</span>
<span class="nc" id="L803">                                        (WARNING_IMAGE_METADATA_ADOBE_MISMATCH);</span>
                                    }
<span class="nc" id="L805">                                    outCsType = JPEG.JCS_RGBA;</span>
                                } else {
                                    // consult the ids
<span class="nc" id="L808">                                    int outCS = sof.getIDencodedCSType();</span>
                                    // if they don't resolve it,
                                    // consult the sampling factors
<span class="nc bnc" id="L811" title="All 2 branches missed.">                                    if (outCS != JPEG.JCS_UNKNOWN) {</span>
<span class="nc" id="L812">                                        outCsType = outCS;</span>
                                    } else {
<span class="nc" id="L814">                                        boolean subsampled =</span>
<span class="nc" id="L815">                                        isSubsampled(sof.componentSpecs);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">                                        outCsType = subsampled ?</span>
                                            JPEG.JCS_YCbCrA : JPEG.JCS_RGBA;
                                    }
                                }
                            }
<span class="nc" id="L821">                            break;</span>
                        case ColorSpace.TYPE_3CLR:
<span class="nc bnc" id="L823" title="All 2 branches missed.">                            if (cs == JPEG.JCS.getYCC()) {</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                                if (!alpha) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                                    if (jfif != null) {</span>
<span class="nc" id="L826">                                        convertTosRGB = true;</span>
<span class="nc" id="L827">                                        convertOp =</span>
                                        new ColorConvertOp(cs,
                                                           JPEG.JCS.sRGB,
                                                           null);
<span class="nc" id="L831">                                        outCsType = JPEG.JCS_YCbCr;</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                                    } else if (adobe != null) {</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">                                        if (adobe.transform</span>
                                            != JPEG.ADOBE_YCC) {
<span class="nc" id="L835">                                            newAdobeTransform = JPEG.ADOBE_YCC;</span>
<span class="nc" id="L836">                                            warningOccurred</span>
<span class="nc" id="L837">                                            (WARNING_IMAGE_METADATA_ADOBE_MISMATCH);</span>
                                        }
<span class="nc" id="L839">                                        outCsType = JPEG.JCS_YCC;</span>
                                    } else {
<span class="nc" id="L841">                                        outCsType = JPEG.JCS_YCC;</span>
                                    }
                                } else { // PhotoYCCA
<span class="nc bnc" id="L844" title="All 2 branches missed.">                                    if (jfif != null) {</span>
<span class="nc" id="L845">                                        ignoreJFIF = true;</span>
<span class="nc" id="L846">                                        warningOccurred</span>
<span class="nc" id="L847">                                        (WARNING_IMAGE_METADATA_JFIF_MISMATCH);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                                    } else if (adobe != null) {</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                                        if (adobe.transform</span>
                                            != JPEG.ADOBE_UNKNOWN) {
<span class="nc" id="L851">                                            newAdobeTransform</span>
                                            = JPEG.ADOBE_UNKNOWN;
<span class="nc" id="L853">                                            warningOccurred</span>
<span class="nc" id="L854">                                            (WARNING_IMAGE_METADATA_ADOBE_MISMATCH);</span>
                                        }
                                    }
<span class="nc" id="L857">                                    outCsType = JPEG.JCS_YCCA;</span>
                                }
                            }
                        }
                    }
                } // else no dest, metadata, not an image.  Defaults ok
            }
        }

<span class="nc" id="L866">        boolean metadataProgressive = false;</span>
<span class="nc" id="L867">        int [] scans = null;</span>

<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (metadata != null) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">            if (sof == null) {</span>
<span class="nc" id="L871">                sof = (SOFMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L872">                    (SOFMarkerSegment.class, true);</span>
            }
<span class="nc bnc" id="L874" title="All 4 branches missed.">            if ((sof != null) &amp;&amp; (sof.tag == JPEG.SOF2)) {</span>
<span class="nc" id="L875">                metadataProgressive = true;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                if (progressiveMode == ImageWriteParam.MODE_COPY_FROM_METADATA) {</span>
<span class="nc" id="L877">                    scans = collectScans(metadata, sof);  // Might still be null</span>
                } else {
<span class="nc" id="L879">                    numScans = 0;</span>
                }
            }
<span class="nc bnc" id="L882" title="All 2 branches missed.">            if (jfif == null) {</span>
<span class="nc" id="L883">                jfif = (JFIFMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L884">                    (JFIFMarkerSegment.class, true);</span>
            }
        }

<span class="nc" id="L888">        thumbnails = image.getThumbnails();</span>
<span class="nc" id="L889">        int numThumbs = image.getNumThumbnails();</span>
<span class="nc" id="L890">        forceJFIF = false;</span>
        // determine if thumbnails can be written
        // If we are going to add a default JFIF marker segment,
        // then thumbnails can be written
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (!writeDefaultJFIF) {</span>
            // If there is no metadata, then we can't write thumbnails
<span class="nc bnc" id="L896" title="All 2 branches missed.">            if (metadata == null) {</span>
<span class="nc" id="L897">                thumbnails = null;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">                if (numThumbs != 0) {</span>
<span class="nc" id="L899">                    warningOccurred(WARNING_IGNORING_THUMBS);</span>
                }
            } else {
                // There is metadata
                // If we are writing a raster or subbands,
                // then the user must specify JFIF on the metadata
<span class="nc bnc" id="L905" title="All 2 branches missed.">                if (fullImage == false) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    if (jfif == null) {</span>
<span class="nc" id="L907">                        thumbnails = null;  // Or we can't include thumbnails</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                        if (numThumbs != 0) {</span>
<span class="nc" id="L909">                            warningOccurred(WARNING_IGNORING_THUMBS);</span>
                        }
                    }
                } else {  // It is a full image, and there is metadata
<span class="nc bnc" id="L913" title="All 2 branches missed.">                    if (jfif == null) {  // Not JFIF</span>
                        // Can it have JFIF?
<span class="nc bnc" id="L915" title="All 4 branches missed.">                        if ((outCsType == JPEG.JCS_GRAYSCALE)</span>
                            || (outCsType == JPEG.JCS_YCbCr)) {
<span class="nc bnc" id="L917" title="All 2 branches missed.">                            if (numThumbs != 0) {</span>
<span class="nc" id="L918">                                forceJFIF = true;</span>
<span class="nc" id="L919">                                warningOccurred(WARNING_FORCING_JFIF);</span>
                            }
                        } else {  // Nope, not JFIF-compatible
<span class="nc" id="L922">                            thumbnails = null;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                            if (numThumbs != 0) {</span>
<span class="nc" id="L924">                                warningOccurred(WARNING_IGNORING_THUMBS);</span>
                            }
                        }
                    }
                }
            }
        }

        // Set up a boolean to indicate whether we need to call back to
        // write metadata
<span class="nc bnc" id="L934" title="All 6 branches missed.">        boolean haveMetadata =</span>
            ((metadata != null) || writeDefaultJFIF || writeAdobe);

        // Now that we have dealt with metadata, finalize our tables set up

        // Are we going to write tables?  By default, yes.
<span class="nc" id="L940">        boolean writeDQT = true;</span>
<span class="nc" id="L941">        boolean writeDHT = true;</span>

        // But if the metadata has no tables, no.
<span class="nc" id="L944">        DQTMarkerSegment dqt = null;</span>
<span class="nc" id="L945">        DHTMarkerSegment dht = null;</span>

<span class="nc" id="L947">        int restartInterval = 0;</span>

<span class="nc bnc" id="L949" title="All 2 branches missed.">        if (metadata != null) {</span>
<span class="nc" id="L950">            dqt = (DQTMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L951">                (DQTMarkerSegment.class, true);</span>
<span class="nc" id="L952">            dht = (DHTMarkerSegment) metadata.findMarkerSegment</span>
<span class="nc" id="L953">                (DHTMarkerSegment.class, true);</span>
<span class="nc" id="L954">            DRIMarkerSegment dri =</span>
                (DRIMarkerSegment) metadata.findMarkerSegment
<span class="nc" id="L956">                (DRIMarkerSegment.class, true);</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (dri != null) {</span>
<span class="nc" id="L958">                restartInterval = dri.restartInterval;</span>
            }

<span class="nc bnc" id="L961" title="All 2 branches missed.">            if (dqt == null) {</span>
<span class="nc" id="L962">                writeDQT = false;</span>
            }
<span class="nc bnc" id="L964" title="All 2 branches missed.">            if (dht == null) {</span>
<span class="nc" id="L965">                writeDHT = false;  // Ignored if optimizeHuffman is true</span>
            }
        }

        // Whether we write tables or not, we need to figure out which ones
        // to use
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (qTables == null) { // Get them from metadata, or use defaults</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">            if (dqt != null) {</span>
<span class="nc" id="L973">                qTables = collectQTablesFromMetadata(metadata);</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            } else if (streamQTables != null) {</span>
<span class="nc" id="L975">                qTables = streamQTables;</span>
<span class="nc bnc" id="L976" title="All 4 branches missed.">            } else if ((jparam != null) &amp;&amp; (jparam.areTablesSet())) {</span>
<span class="nc" id="L977">                qTables = jparam.getQTables();</span>
            } else {
<span class="nc" id="L979">                qTables = JPEG.getDefaultQTables();</span>
            }

        }

        // If we are optimizing, we don't want any tables.
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (optimizeHuffman == false) {</span>
            // If they were for progressive scans, we can't use them.
<span class="nc bnc" id="L987" title="All 4 branches missed.">            if ((dht != null) &amp;&amp; (metadataProgressive == false)) {</span>
<span class="nc" id="L988">                DCHuffmanTables = collectHTablesFromMetadata(metadata, true);</span>
<span class="nc" id="L989">                ACHuffmanTables = collectHTablesFromMetadata(metadata, false);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            } else if (streamDCHuffmanTables != null) {</span>
<span class="nc" id="L991">                DCHuffmanTables = streamDCHuffmanTables;</span>
<span class="nc" id="L992">                ACHuffmanTables = streamACHuffmanTables;</span>
<span class="nc bnc" id="L993" title="All 4 branches missed.">            } else if ((jparam != null) &amp;&amp; (jparam.areTablesSet())) {</span>
<span class="nc" id="L994">                DCHuffmanTables = jparam.getDCHuffmanTables();</span>
<span class="nc" id="L995">                ACHuffmanTables = jparam.getACHuffmanTables();</span>
            } else {
<span class="nc" id="L997">                DCHuffmanTables = JPEG.getDefaultHuffmanTables(true);</span>
<span class="nc" id="L998">                ACHuffmanTables = JPEG.getDefaultHuffmanTables(false);</span>
            }
        }

        // By default, ids are 1 - N, no subsampling
<span class="nc" id="L1003">        int [] componentIds = new int[numBandsUsed];</span>
<span class="nc" id="L1004">        int [] HsamplingFactors = new int[numBandsUsed];</span>
<span class="nc" id="L1005">        int [] VsamplingFactors = new int[numBandsUsed];</span>
<span class="nc" id="L1006">        int [] QtableSelectors = new int[numBandsUsed];</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        for (int i = 0; i &lt; numBandsUsed; i++) {</span>
<span class="nc" id="L1008">            componentIds[i] = i+1; // JFIF compatible</span>
<span class="nc" id="L1009">            HsamplingFactors[i] = 1;</span>
<span class="nc" id="L1010">            VsamplingFactors[i] = 1;</span>
<span class="nc" id="L1011">            QtableSelectors[i] = 0;</span>
        }

        // Now override them with the contents of sof, if there is one,
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        if (sof != null) {</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            for (int i = 0; i &lt; numBandsUsed; i++) {</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                if (forceJFIF == false) {  // else use JFIF-compatible default</span>
<span class="nc" id="L1018">                    componentIds[i] = sof.componentSpecs[i].componentId;</span>
                }
<span class="nc" id="L1020">                HsamplingFactors[i] = sof.componentSpecs[i].HsamplingFactor;</span>
<span class="nc" id="L1021">                VsamplingFactors[i] = sof.componentSpecs[i].VsamplingFactor;</span>
<span class="nc" id="L1022">                QtableSelectors[i] = sof.componentSpecs[i].QtableSelector;</span>
            }
        }

<span class="nc" id="L1026">        sourceXOffset += gridX;</span>
<span class="nc" id="L1027">        sourceWidth -= gridX;</span>
<span class="nc" id="L1028">        sourceYOffset += gridY;</span>
<span class="nc" id="L1029">        sourceHeight -= gridY;</span>

<span class="nc" id="L1031">        int destWidth = (sourceWidth + periodX - 1)/periodX;</span>
<span class="nc" id="L1032">        int destHeight = (sourceHeight + periodY - 1)/periodY;</span>

        // Create an appropriate 1-line databuffer for writing
<span class="nc" id="L1035">        int lineSize = sourceWidth*numBandsUsed;</span>

<span class="nc" id="L1037">        DataBufferByte buffer = new DataBufferByte(lineSize);</span>

        // Create a raster from that
<span class="nc" id="L1040">        int [] bandOffs = JPEG.bandOffsets[numBandsUsed-1];</span>

<span class="nc" id="L1042">        raster = Raster.createInterleavedRaster(buffer,</span>
                                                sourceWidth, 1,
                                                lineSize,
                                                numBandsUsed,
                                                bandOffs,
                                                null);

        // Call the writer, who will call back for every scanline

<span class="nc" id="L1051">        processImageStarted(currentImage);</span>

<span class="nc" id="L1053">        boolean aborted = false;</span>

<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L1056">            System.out.println(&quot;inCsType: &quot; + inCsType);</span>
<span class="nc" id="L1057">            System.out.println(&quot;outCsType: &quot; + outCsType);</span>
        }

        // Note that getData disables acceleration on buffer, but it is
        // just a 1-line intermediate data transfer buffer that does not
        // affect the acceleration of the source image.
<span class="nc" id="L1063">        aborted = writeImage(structPointer,</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                             buffer.getData(),</span>
                             inCsType, outCsType,
                             numBandsUsed,
                             bandSizes,
                             sourceWidth,
                             destWidth, destHeight,
                             periodX, periodY,
                             qTables,
                             writeDQT,
                             DCHuffmanTables,
                             ACHuffmanTables,
                             writeDHT,
                             optimizeHuffman,
                             (progressiveMode
                              != ImageWriteParam.MODE_DISABLED),
                             numScans,
                             scans,
                             componentIds,
                             HsamplingFactors,
                             VsamplingFactors,
                             QtableSelectors,
                             haveMetadata,
                             restartInterval);

<span class="nc" id="L1088">        cbLock.lock();</span>
        try {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (aborted) {</span>
<span class="nc" id="L1091">                processWriteAborted();</span>
            } else {
<span class="nc" id="L1093">                processImageComplete();</span>
            }

<span class="nc" id="L1096">            ios.flush();</span>
        } finally {
<span class="nc" id="L1098">            cbLock.unlock();</span>
<span class="nc" id="L1099">        }</span>
<span class="nc" id="L1100">        currentImage++;  // After a successful write</span>
<span class="nc" id="L1101">    }</span>

    public void prepareWriteSequence(IIOMetadata streamMetadata)
        throws IOException {
<span class="nc" id="L1105">        setThreadLock();</span>
        try {
<span class="nc" id="L1107">            cbLock.check();</span>

<span class="nc" id="L1109">            prepareWriteSequenceOnThread(streamMetadata);</span>
        } finally {
<span class="nc" id="L1111">            clearThreadLock();</span>
<span class="nc" id="L1112">        }</span>
<span class="nc" id="L1113">    }</span>

    private void prepareWriteSequenceOnThread(IIOMetadata streamMetadata)
        throws IOException {
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if (ios == null) {</span>
<span class="nc" id="L1118">            throw new IllegalStateException(&quot;Output has not been set!&quot;);</span>
        }

        /*
         * from jpeg_metadata.html:
         * If no stream metadata is supplied to
         * &lt;code&gt;ImageWriter.prepareWriteSequence&lt;/code&gt;, then no
         * tables-only image is written.  If stream metadata containing
         * no tables is supplied to
         * &lt;code&gt;ImageWriter.prepareWriteSequence&lt;/code&gt;, then a tables-only
         * image containing default visually lossless tables is written.
         */
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        if (streamMetadata != null) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            if (streamMetadata instanceof JPEGMetadata) {</span>
                // write a complete tables-only image at the beginning of
                // the stream.
<span class="nc" id="L1134">                JPEGMetadata jmeta = (JPEGMetadata) streamMetadata;</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">                if (jmeta.isStream == false) {</span>
<span class="nc" id="L1136">                    throw new IllegalArgumentException</span>
                        (&quot;Invalid stream metadata object.&quot;);
                }
                // Check that we are
                // at the beginning of the stream, or can go there, and haven't
                // written out the metadata already.
<span class="nc bnc" id="L1142" title="All 2 branches missed.">                if (currentImage != 0) {</span>
<span class="nc" id="L1143">                    throw new IIOException</span>
                        (&quot;JPEG Stream metadata must precede all images&quot;);
                }
<span class="nc bnc" id="L1146" title="All 2 branches missed.">                if (sequencePrepared == true) {</span>
<span class="nc" id="L1147">                    throw new IIOException(&quot;Stream metadata already written!&quot;);</span>
                }

                // Set the tables
                // If the metadata has no tables, use default tables.
<span class="nc" id="L1152">                streamQTables = collectQTablesFromMetadata(jmeta);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L1154">                    System.out.println(&quot;after collecting from stream metadata, &quot;</span>
                                       + &quot;streamQTables.length is &quot;
                                       + streamQTables.length);
                }
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                if (streamQTables == null) {</span>
<span class="nc" id="L1159">                    streamQTables = JPEG.getDefaultQTables();</span>
                }
<span class="nc" id="L1161">                streamDCHuffmanTables =</span>
<span class="nc" id="L1162">                    collectHTablesFromMetadata(jmeta, true);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">                if (streamDCHuffmanTables == null) {</span>
<span class="nc" id="L1164">                    streamDCHuffmanTables = JPEG.getDefaultHuffmanTables(true);</span>
                }
<span class="nc" id="L1166">                streamACHuffmanTables =</span>
<span class="nc" id="L1167">                    collectHTablesFromMetadata(jmeta, false);</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                if (streamACHuffmanTables == null) {</span>
<span class="nc" id="L1169">                    streamACHuffmanTables = JPEG.getDefaultHuffmanTables(false);</span>
                }

                // Now write them out
<span class="nc" id="L1173">                writeTables(structPointer,</span>
                            streamQTables,
                            streamDCHuffmanTables,
                            streamACHuffmanTables);
<span class="nc" id="L1177">            } else {</span>
<span class="nc" id="L1178">                throw new IIOException(&quot;Stream metadata must be JPEG metadata&quot;);</span>
            }
        }
<span class="nc" id="L1181">        sequencePrepared = true;</span>
<span class="nc" id="L1182">    }</span>

    public void writeToSequence(IIOImage image, ImageWriteParam param)
        throws IOException {
<span class="nc" id="L1186">        setThreadLock();</span>
        try {
<span class="nc" id="L1188">            cbLock.check();</span>

<span class="nc bnc" id="L1190" title="All 2 branches missed.">            if (sequencePrepared == false) {</span>
<span class="nc" id="L1191">                throw new IllegalStateException(&quot;sequencePrepared not called!&quot;);</span>
            }
            // In the case of JPEG this does nothing different from write
<span class="nc" id="L1194">            write(null, image, param);</span>
        } finally {
<span class="nc" id="L1196">            clearThreadLock();</span>
<span class="nc" id="L1197">        }</span>
<span class="nc" id="L1198">    }</span>

    public void endWriteSequence() throws IOException {
<span class="nc" id="L1201">        setThreadLock();</span>
        try {
<span class="nc" id="L1203">            cbLock.check();</span>

<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (sequencePrepared == false) {</span>
<span class="nc" id="L1206">                throw new IllegalStateException(&quot;sequencePrepared not called!&quot;);</span>
            }
<span class="nc" id="L1208">            sequencePrepared = false;</span>
        } finally {
<span class="nc" id="L1210">            clearThreadLock();</span>
<span class="nc" id="L1211">        }</span>
<span class="nc" id="L1212">    }</span>

    public synchronized void abort() {
<span class="nc" id="L1215">        setThreadLock();</span>
        try {
            /**
             * NB: we do not check the call back lock here, we allow to abort
             * the reader any time.
             */
<span class="nc" id="L1221">            super.abort();</span>
<span class="nc" id="L1222">            abortWrite(structPointer);</span>
        } finally {
<span class="nc" id="L1224">            clearThreadLock();</span>
<span class="nc" id="L1225">        }</span>
<span class="nc" id="L1226">    }</span>

    private void resetInternalState() {
        // reset C structures
<span class="nc" id="L1230">        resetWriter(structPointer);</span>

        // reset local Java structures
<span class="nc" id="L1233">        srcRas = null;</span>
<span class="nc" id="L1234">        raster = null;</span>
<span class="nc" id="L1235">        convertTosRGB = false;</span>
<span class="nc" id="L1236">        currentImage = 0;</span>
<span class="nc" id="L1237">        numScans = 0;</span>
<span class="nc" id="L1238">        metadata = null;</span>
<span class="nc" id="L1239">    }</span>

    public void reset() {
<span class="nc" id="L1242">        setThreadLock();</span>
        try {
<span class="nc" id="L1244">            cbLock.check();</span>

<span class="nc" id="L1246">            super.reset();</span>
        } finally {
<span class="nc" id="L1248">            clearThreadLock();</span>
<span class="nc" id="L1249">        }</span>
<span class="nc" id="L1250">    }</span>

    public void dispose() {
<span class="nc" id="L1253">        setThreadLock();</span>
        try {
<span class="nc" id="L1255">            cbLock.check();</span>

<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (structPointer != 0) {</span>
<span class="nc" id="L1258">                disposerRecord.dispose();</span>
<span class="nc" id="L1259">                structPointer = 0;</span>
            }
        } finally {
<span class="nc" id="L1262">            clearThreadLock();</span>
<span class="nc" id="L1263">        }</span>
<span class="nc" id="L1264">    }</span>

    ////////// End of public API

    ///////// Package-access API

    /**
     * Called by the native code or other classes to signal a warning.
     * The code is used to lookup a localized message to be used when
     * sending warnings to listeners.
     */
    void warningOccurred(int code) {
<span class="nc" id="L1276">        cbLock.lock();</span>
        try {
<span class="nc bnc" id="L1278" title="All 4 branches missed.">            if ((code &lt; 0) || (code &gt; MAX_WARNING)){</span>
<span class="nc" id="L1279">                throw new InternalError(&quot;Invalid warning index&quot;);</span>
            }
<span class="nc" id="L1281">            processWarningOccurred</span>
<span class="nc" id="L1282">                (currentImage,</span>
                 &quot;com.sun.imageio.plugins.jpeg.JPEGImageWriterResources&quot;,
<span class="nc" id="L1284">                Integer.toString(code));</span>
        } finally {
<span class="nc" id="L1286">            cbLock.unlock();</span>
<span class="nc" id="L1287">        }</span>
<span class="nc" id="L1288">    }</span>

    /**
     * The library has it's own error facility that emits warning messages.
     * This routine is called by the native code when it has already
     * formatted a string for output.
     * XXX  For truly complete localization of all warning messages,
     * the sun_jpeg_output_message routine in the native code should
     * send only the codes and parameters to a method here in Java,
     * which will then format and send the warnings, using localized
     * strings.  This method will have to deal with all the parameters
     * and formats (%u with possibly large numbers, %02d, %02x, etc.)
     * that actually occur in the JPEG library.  For now, this prevents
     * library warnings from being printed to stderr.
     */
    void warningWithMessage(String msg) {
<span class="nc" id="L1304">        cbLock.lock();</span>
        try {
<span class="nc" id="L1306">            processWarningOccurred(currentImage, msg);</span>
        } finally {
<span class="nc" id="L1308">            cbLock.unlock();</span>
<span class="nc" id="L1309">        }</span>
<span class="nc" id="L1310">    }</span>

    void thumbnailStarted(int thumbnailIndex) {
<span class="nc" id="L1313">        cbLock.lock();</span>
        try {
<span class="nc" id="L1315">            processThumbnailStarted(currentImage, thumbnailIndex);</span>
        } finally {
<span class="nc" id="L1317">            cbLock.unlock();</span>
<span class="nc" id="L1318">        }</span>
<span class="nc" id="L1319">    }</span>

    // Provide access to protected superclass method
    void thumbnailProgress(float percentageDone) {
<span class="nc" id="L1323">        cbLock.lock();</span>
        try {
<span class="nc" id="L1325">            processThumbnailProgress(percentageDone);</span>
        } finally {
<span class="nc" id="L1327">            cbLock.unlock();</span>
<span class="nc" id="L1328">        }</span>
<span class="nc" id="L1329">    }</span>

    // Provide access to protected superclass method
    void thumbnailComplete() {
<span class="nc" id="L1333">        cbLock.lock();</span>
        try {
<span class="nc" id="L1335">            processThumbnailComplete();</span>
        } finally {
<span class="nc" id="L1337">            cbLock.unlock();</span>
<span class="nc" id="L1338">        }</span>
<span class="nc" id="L1339">    }</span>

    ///////// End of Package-access API

    ///////// Private methods

    ///////// Metadata handling

    private void checkSOFBands(SOFMarkerSegment sof, int numBandsUsed)
        throws IIOException {
        // Does the metadata frame header, if any, match numBandsUsed?
<span class="nc bnc" id="L1350" title="All 2 branches missed.">        if (sof != null) {</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">            if (sof.componentSpecs.length != numBandsUsed) {</span>
<span class="nc" id="L1352">                throw new IIOException</span>
                    (&quot;Metadata components != number of destination bands&quot;);
            }
        }
<span class="nc" id="L1356">    }</span>

    private void checkJFIF(JFIFMarkerSegment jfif,
                           ImageTypeSpecifier type,
                           boolean input) {
<span class="nc bnc" id="L1361" title="All 2 branches missed.">        if (jfif != null) {</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (!JPEG.isJFIFcompliant(type, input)) {</span>
<span class="nc" id="L1363">                ignoreJFIF = true;  // type overrides metadata</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                warningOccurred(input</span>
                                ? WARNING_IMAGE_METADATA_JFIF_MISMATCH
                                : WARNING_DEST_METADATA_JFIF_MISMATCH);
            }
        }
<span class="nc" id="L1369">    }</span>

    private void checkAdobe(AdobeMarkerSegment adobe,
                           ImageTypeSpecifier type,
                           boolean input) {
<span class="nc bnc" id="L1374" title="All 2 branches missed.">        if (adobe != null) {</span>
<span class="nc" id="L1375">            int rightTransform = JPEG.transformForType(type, input);</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">            if (adobe.transform != rightTransform) {</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">                warningOccurred(input</span>
                                ? WARNING_IMAGE_METADATA_ADOBE_MISMATCH
                                : WARNING_DEST_METADATA_ADOBE_MISMATCH);
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                if (rightTransform == JPEG.ADOBE_IMPOSSIBLE) {</span>
<span class="nc" id="L1381">                    ignoreAdobe = true;</span>
                } else {
<span class="nc" id="L1383">                    newAdobeTransform = rightTransform;</span>
                }
            }
        }
<span class="nc" id="L1387">    }</span>

    /**
     * Collect all the scan info from the given metadata, and
     * organize it into the scan info array required by the
     * IJG libray.  It is much simpler to parse out this
     * data in Java and then just copy the data in C.
     */
    private int [] collectScans(JPEGMetadata metadata,
                                SOFMarkerSegment sof) {
<span class="nc" id="L1397">        List segments = new ArrayList();</span>
<span class="nc" id="L1398">        int SCAN_SIZE = 9;</span>
<span class="nc" id="L1399">        int MAX_COMPS_PER_SCAN = 4;</span>
<span class="nc" id="L1400">        for (Iterator iter = metadata.markerSequence.iterator();</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">             iter.hasNext();) {</span>
<span class="nc" id="L1402">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">            if (seg instanceof SOSMarkerSegment) {</span>
<span class="nc" id="L1404">                segments.add(seg);</span>
            }
<span class="nc" id="L1406">        }</span>
<span class="nc" id="L1407">        int [] retval = null;</span>
<span class="nc" id="L1408">        numScans = 0;</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (!segments.isEmpty()) {</span>
<span class="nc" id="L1410">            numScans = segments.size();</span>
<span class="nc" id="L1411">            retval = new int [numScans*SCAN_SIZE];</span>
<span class="nc" id="L1412">            int index = 0;</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">            for (int i = 0; i &lt; numScans; i++) {</span>
<span class="nc" id="L1414">                SOSMarkerSegment sos = (SOSMarkerSegment) segments.get(i);</span>
<span class="nc" id="L1415">                retval[index++] = sos.componentSpecs.length; // num comps</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">                for (int j = 0; j &lt; MAX_COMPS_PER_SCAN; j++) {</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                    if (j &lt; sos.componentSpecs.length) {</span>
<span class="nc" id="L1418">                        int compSel = sos.componentSpecs[j].componentSelector;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                        for (int k = 0; k &lt; sof.componentSpecs.length; k++) {</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">                            if (compSel == sof.componentSpecs[k].componentId) {</span>
<span class="nc" id="L1421">                                retval[index++] = k;</span>
<span class="nc" id="L1422">                                break; // out of for over sof comps</span>
                            }
                        }
<span class="nc" id="L1425">                    } else {</span>
<span class="nc" id="L1426">                        retval[index++] = 0;</span>
                    }
                }
<span class="nc" id="L1429">                retval[index++] = sos.startSpectralSelection;</span>
<span class="nc" id="L1430">                retval[index++] = sos.endSpectralSelection;</span>
<span class="nc" id="L1431">                retval[index++] = sos.approxHigh;</span>
<span class="nc" id="L1432">                retval[index++] = sos.approxLow;</span>
            }
        }
<span class="nc" id="L1435">        return retval;</span>
    }

    /**
     * Finds all DQT marker segments and returns all the q
     * tables as a single array of JPEGQTables.
     */
    private JPEGQTable [] collectQTablesFromMetadata
        (JPEGMetadata metadata) {
<span class="nc" id="L1444">        ArrayList tables = new ArrayList();</span>
<span class="nc" id="L1445">        Iterator iter = metadata.markerSequence.iterator();</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1447">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (seg instanceof DQTMarkerSegment) {</span>
<span class="nc" id="L1449">                DQTMarkerSegment dqt =</span>
                    (DQTMarkerSegment) seg;
<span class="nc" id="L1451">                tables.addAll(dqt.tables);</span>
            }
<span class="nc" id="L1453">        }</span>
<span class="nc" id="L1454">        JPEGQTable [] retval = null;</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">        if (tables.size() != 0) {</span>
<span class="nc" id="L1456">            retval = new JPEGQTable[tables.size()];</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">            for (int i = 0; i &lt; retval.length; i++) {</span>
<span class="nc" id="L1458">                retval[i] =</span>
<span class="nc" id="L1459">                    new JPEGQTable(((DQTMarkerSegment.Qtable)tables.get(i)).data);</span>
            }
        }
<span class="nc" id="L1462">        return retval;</span>
    }

    /**
     * Finds all DHT marker segments and returns all the q
     * tables as a single array of JPEGQTables.  The metadata
     * must not be for a progressive image, or an exception
     * will be thrown when two Huffman tables with the same
     * table id are encountered.
     */
    private JPEGHuffmanTable[] collectHTablesFromMetadata
        (JPEGMetadata metadata, boolean wantDC) throws IIOException {
<span class="nc" id="L1474">        ArrayList tables = new ArrayList();</span>
<span class="nc" id="L1475">        Iterator iter = metadata.markerSequence.iterator();</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1477">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (seg instanceof DHTMarkerSegment) {</span>
<span class="nc" id="L1479">                DHTMarkerSegment dht =</span>
                    (DHTMarkerSegment) seg;
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                for (int i = 0; i &lt; dht.tables.size(); i++) {</span>
<span class="nc" id="L1482">                    DHTMarkerSegment.Htable htable =</span>
<span class="nc" id="L1483">                        (DHTMarkerSegment.Htable) dht.tables.get(i);</span>
<span class="nc bnc" id="L1484" title="All 4 branches missed.">                    if (htable.tableClass == (wantDC ? 0 : 1)) {</span>
<span class="nc" id="L1485">                        tables.add(htable);</span>
                    }
                }
            }
<span class="nc" id="L1489">        }</span>
<span class="nc" id="L1490">        JPEGHuffmanTable [] retval = null;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        if (tables.size() != 0) {</span>
<span class="nc" id="L1492">            DHTMarkerSegment.Htable [] htables =</span>
<span class="nc" id="L1493">                new DHTMarkerSegment.Htable[tables.size()];</span>
<span class="nc" id="L1494">            tables.toArray(htables);</span>
<span class="nc" id="L1495">            retval = new JPEGHuffmanTable[tables.size()];</span>
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            for (int i = 0; i &lt; retval.length; i++) {</span>
<span class="nc" id="L1497">                retval[i] = null;</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">                for (int j = 0; j &lt; tables.size(); j++) {</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                    if (htables[j].tableID == i) {</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">                        if (retval[i] != null) {</span>
<span class="nc" id="L1501">                            throw new IIOException(&quot;Metadata has duplicate Htables!&quot;);</span>
                        }
<span class="nc" id="L1503">                        retval[i] = new JPEGHuffmanTable(htables[j].numCodes,</span>
                                                         htables[j].values);
                    }
                }
            }
        }

<span class="nc" id="L1510">        return retval;</span>
    }

    /////////// End of metadata handling

    ////////////// ColorSpace conversion

    private int getSrcCSType(ImageTypeSpecifier type) {
<span class="nc" id="L1518">         return getSrcCSType(type.getColorModel());</span>
    }

    private int getSrcCSType(RenderedImage rimage) {
<span class="nc" id="L1522">        return getSrcCSType(rimage.getColorModel());</span>
    }

    private int getSrcCSType(ColorModel cm) {
<span class="nc" id="L1526">        int retval = JPEG.JCS_UNKNOWN;</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if (cm != null) {</span>
<span class="nc" id="L1528">            boolean alpha = cm.hasAlpha();</span>
<span class="nc" id="L1529">            ColorSpace cs = cm.getColorSpace();</span>
<span class="nc bnc" id="L1530" title="All 6 branches missed.">            switch (cs.getType()) {</span>
            case ColorSpace.TYPE_GRAY:
<span class="nc" id="L1532">                retval = JPEG.JCS_GRAYSCALE;</span>
<span class="nc" id="L1533">                break;</span>
            case ColorSpace.TYPE_RGB:
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1536">                    retval = JPEG.JCS_RGBA;</span>
                } else {
<span class="nc" id="L1538">                    retval = JPEG.JCS_RGB;</span>
                }
<span class="nc" id="L1540">                break;</span>
            case ColorSpace.TYPE_YCbCr:
<span class="nc bnc" id="L1542" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1543">                    retval = JPEG.JCS_YCbCrA;</span>
                } else {
<span class="nc" id="L1545">                    retval = JPEG.JCS_YCbCr;</span>
                }
<span class="nc" id="L1547">                break;</span>
            case ColorSpace.TYPE_3CLR:
<span class="nc bnc" id="L1549" title="All 2 branches missed.">                if (cs == JPEG.JCS.getYCC()) {</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">                    if (alpha) {</span>
<span class="nc" id="L1551">                        retval = JPEG.JCS_YCCA;</span>
                    } else {
<span class="nc" id="L1553">                        retval = JPEG.JCS_YCC;</span>
                    }
                }
            case ColorSpace.TYPE_CMYK:
<span class="nc" id="L1557">                retval = JPEG.JCS_CMYK;</span>
                break;
            }
        }
<span class="nc" id="L1561">        return retval;</span>
    }

    private int getDestCSType(ImageTypeSpecifier destType) {
<span class="nc" id="L1565">        ColorModel cm = destType.getColorModel();</span>
<span class="nc" id="L1566">        boolean alpha = cm.hasAlpha();</span>
<span class="nc" id="L1567">        ColorSpace cs = cm.getColorSpace();</span>
<span class="nc" id="L1568">        int retval = JPEG.JCS_UNKNOWN;</span>
<span class="nc bnc" id="L1569" title="All 6 branches missed.">        switch (cs.getType()) {</span>
        case ColorSpace.TYPE_GRAY:
<span class="nc" id="L1571">                retval = JPEG.JCS_GRAYSCALE;</span>
<span class="nc" id="L1572">                break;</span>
            case ColorSpace.TYPE_RGB:
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1575">                    retval = JPEG.JCS_RGBA;</span>
                } else {
<span class="nc" id="L1577">                    retval = JPEG.JCS_RGB;</span>
                }
<span class="nc" id="L1579">                break;</span>
            case ColorSpace.TYPE_YCbCr:
<span class="nc bnc" id="L1581" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1582">                    retval = JPEG.JCS_YCbCrA;</span>
                } else {
<span class="nc" id="L1584">                    retval = JPEG.JCS_YCbCr;</span>
                }
<span class="nc" id="L1586">                break;</span>
            case ColorSpace.TYPE_3CLR:
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                if (cs == JPEG.JCS.getYCC()) {</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">                    if (alpha) {</span>
<span class="nc" id="L1590">                        retval = JPEG.JCS_YCCA;</span>
                    } else {
<span class="nc" id="L1592">                        retval = JPEG.JCS_YCC;</span>
                    }
                }
            case ColorSpace.TYPE_CMYK:
<span class="nc" id="L1596">                retval = JPEG.JCS_CMYK;</span>
                break;
            }
<span class="nc" id="L1599">        return retval;</span>
        }

    private int getDefaultDestCSType(ImageTypeSpecifier type) {
<span class="nc" id="L1603">        return getDefaultDestCSType(type.getColorModel());</span>
    }

    private int getDefaultDestCSType(RenderedImage rimage) {
<span class="nc" id="L1607">        return getDefaultDestCSType(rimage.getColorModel());</span>
    }

    private int getDefaultDestCSType(ColorModel cm) {
<span class="nc" id="L1611">        int retval = JPEG.JCS_UNKNOWN;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (cm != null) {</span>
<span class="nc" id="L1613">            boolean alpha = cm.hasAlpha();</span>
<span class="nc" id="L1614">            ColorSpace cs = cm.getColorSpace();</span>
<span class="nc bnc" id="L1615" title="All 6 branches missed.">            switch (cs.getType()) {</span>
            case ColorSpace.TYPE_GRAY:
<span class="nc" id="L1617">                retval = JPEG.JCS_GRAYSCALE;</span>
<span class="nc" id="L1618">                break;</span>
            case ColorSpace.TYPE_RGB:
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1621">                    retval = JPEG.JCS_YCbCrA;</span>
                } else {
<span class="nc" id="L1623">                    retval = JPEG.JCS_YCbCr;</span>
                }
<span class="nc" id="L1625">                break;</span>
            case ColorSpace.TYPE_YCbCr:
<span class="nc bnc" id="L1627" title="All 2 branches missed.">                if (alpha) {</span>
<span class="nc" id="L1628">                    retval = JPEG.JCS_YCbCrA;</span>
                } else {
<span class="nc" id="L1630">                    retval = JPEG.JCS_YCbCr;</span>
                }
<span class="nc" id="L1632">                break;</span>
            case ColorSpace.TYPE_3CLR:
<span class="nc bnc" id="L1634" title="All 2 branches missed.">                if (cs == JPEG.JCS.getYCC()) {</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">                    if (alpha) {</span>
<span class="nc" id="L1636">                        retval = JPEG.JCS_YCCA;</span>
                    } else {
<span class="nc" id="L1638">                        retval = JPEG.JCS_YCC;</span>
                    }
                }
            case ColorSpace.TYPE_CMYK:
<span class="nc" id="L1642">                retval = JPEG.JCS_YCCK;</span>
                break;
            }
        }
<span class="nc" id="L1646">        return retval;</span>
    }

    private boolean isSubsampled(SOFMarkerSegment.ComponentSpec [] specs) {
<span class="nc" id="L1650">        int hsamp0 = specs[0].HsamplingFactor;</span>
<span class="nc" id="L1651">        int vsamp0 = specs[0].VsamplingFactor;</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        for (int i = 1; i &lt; specs.length; i++) {</span>
<span class="nc bnc" id="L1653" title="All 4 branches missed.">            if ((specs[i].HsamplingFactor != hsamp0) ||</span>
                (specs[i].HsamplingFactor != hsamp0))
<span class="nc" id="L1655">                return true;</span>
        }
<span class="nc" id="L1657">        return false;</span>
    }

    ////////////// End of ColorSpace conversion

    ////////////// Native methods and callbacks

    /** Sets up static native structures. */
    private static native void initWriterIDs(Class qTableClass,
                                             Class huffClass);

    /** Sets up per-writer native structure and returns a pointer to it. */
    private native long initJPEGImageWriter();

    /** Sets up native structures for output stream */
    private native void setDest(long structPointer);

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the write was aborted.
     */
    private native boolean writeImage(long structPointer,
                                      byte [] data,
                                      int inCsType, int outCsType,
                                      int numBands,
                                      int [] bandSizes,
                                      int srcWidth,
                                      int destWidth, int destHeight,
                                      int stepX, int stepY,
                                      JPEGQTable [] qtables,
                                      boolean writeDQT,
                                      JPEGHuffmanTable[] DCHuffmanTables,
                                      JPEGHuffmanTable[] ACHuffmanTables,
                                      boolean writeDHT,
                                      boolean optimizeHuffman,
                                      boolean progressive,
                                      int numScans,
                                      int [] scans,
                                      int [] componentIds,
                                      int [] HsamplingFactors,
                                      int [] VsamplingFactors,
                                      int [] QtableSelectors,
                                      boolean haveMetadata,
                                      int restartInterval);


    /**
     * Writes the metadata out when called by the native code,
     * which will have already written the header to the stream
     * and established the library state.  This is simpler than
     * breaking the write call in two.
     */
    private void writeMetadata() throws IOException {
<span class="nc bnc" id="L1709" title="All 2 branches missed.">        if (metadata == null) {</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">            if (writeDefaultJFIF) {</span>
<span class="nc" id="L1711">                JFIFMarkerSegment.writeDefaultJFIF(ios,</span>
                                                   thumbnails,
                                                   iccProfile,
                                                   this);
            }
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            if (writeAdobe) {</span>
<span class="nc" id="L1717">                AdobeMarkerSegment.writeAdobeSegment(ios, newAdobeTransform);</span>
            }
        } else {
<span class="nc" id="L1720">            metadata.writeToStream(ios,</span>
                                   ignoreJFIF,
                                   forceJFIF,
                                   thumbnails,
                                   iccProfile,
                                   ignoreAdobe,
                                   newAdobeTransform,
                                   this);
        }
<span class="nc" id="L1729">    }</span>

    /**
     * Write out a tables-only image to the stream.
     */
    private native void writeTables(long structPointer,
                                    JPEGQTable [] qtables,
                                    JPEGHuffmanTable[] DCHuffmanTables,
                                    JPEGHuffmanTable[] ACHuffmanTables);

    /**
     * Put the scanline y of the source ROI view Raster into the
     * 1-line Raster for writing.  This handles ROI and band
     * rearrangements, and expands indexed images.  Subsampling is
     * done in the native code.
     * This is called by the native code.
     */
    private void grabPixels(int y) {

<span class="nc" id="L1748">        Raster sourceLine = null;</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">        if (indexed) {</span>
<span class="nc" id="L1750">            sourceLine = srcRas.createChild(sourceXOffset,</span>
                                            sourceYOffset+y,
                                            sourceWidth, 1,
                                            0, 0,
                                            new int [] {0});
            // If the image has BITMASK transparency, we need to make sure
            // it gets converted to 32-bit ARGB, because the JPEG encoder
            // relies upon the full 8-bit alpha channel.
<span class="nc" id="L1758">            boolean forceARGB =</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">                (indexCM.getTransparency() != Transparency.OPAQUE);</span>
<span class="nc" id="L1760">            BufferedImage temp = indexCM.convertToIntDiscrete(sourceLine,</span>
                                                              forceARGB);
<span class="nc" id="L1762">            sourceLine = temp.getRaster();</span>
<span class="nc" id="L1763">        } else {</span>
<span class="nc" id="L1764">            sourceLine = srcRas.createChild(sourceXOffset,</span>
                                            sourceYOffset+y,
                                            sourceWidth, 1,
                                            0, 0,
                                            srcBands);
        }
<span class="nc bnc" id="L1770" title="All 2 branches missed.">        if (convertTosRGB) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L1772">                System.out.println(&quot;Converting to sRGB&quot;);</span>
            }
            // The first time through, converted is null, so
            // a new raster is allocated.  It is then reused
            // on subsequent lines.
<span class="nc" id="L1777">            converted = convertOp.filter(sourceLine, converted);</span>
<span class="nc" id="L1778">            sourceLine = converted;</span>
        }
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1781">            WritableRaster wr = sourceLine.createCompatibleWritableRaster();</span>
<span class="nc" id="L1782">            int[] data = null;</span>
<span class="nc" id="L1783">            data = sourceLine.getPixels(sourceLine.getMinX(), sourceLine.getMinY(),</span>
<span class="nc" id="L1784">                                        sourceLine.getWidth(), sourceLine.getHeight(),</span>
                                        data);
<span class="nc" id="L1786">            wr.setPixels(sourceLine.getMinX(), sourceLine.getMinY(),</span>
<span class="nc" id="L1787">                         sourceLine.getWidth(), sourceLine.getHeight(),</span>
                         data);
<span class="nc" id="L1789">            srcCM.coerceData(wr, false);</span>
<span class="nc" id="L1790">            sourceLine = wr.createChild(wr.getMinX(), wr.getMinY(),</span>
<span class="nc" id="L1791">                                        wr.getWidth(), wr.getHeight(),</span>
                                        0, 0,
                                        srcBands);
        }
<span class="nc" id="L1795">        raster.setRect(sourceLine);</span>
<span class="nc bnc" id="L1796" title="All 4 branches missed.">        if ((y &gt; 7) &amp;&amp; (y%8 == 0)) {  // Every 8 scanlines</span>
<span class="nc" id="L1797">            cbLock.lock();</span>
            try {
<span class="nc" id="L1799">                processImageProgress((float) y / (float) sourceHeight * 100.0F);</span>
            } finally {
<span class="nc" id="L1801">                cbLock.unlock();</span>
<span class="nc" id="L1802">            }</span>
        }
<span class="nc" id="L1804">    }</span>

    /** Aborts the current write in the native code */
    private native void abortWrite(long structPointer);

    /** Resets native structures */
    private native void resetWriter(long structPointer);

    /** Releases native structures */
    private static native void disposeWriter(long structPointer);

    private static class JPEGWriterDisposerRecord implements DisposerRecord {
        private long pData;

<span class="nc" id="L1818">        public JPEGWriterDisposerRecord(long pData) {</span>
<span class="nc" id="L1819">            this.pData = pData;</span>
<span class="nc" id="L1820">        }</span>

        public synchronized void dispose() {
<span class="nc bnc" id="L1823" title="All 2 branches missed.">            if (pData != 0) {</span>
<span class="nc" id="L1824">                disposeWriter(pData);</span>
<span class="nc" id="L1825">                pData = 0;</span>
            }
<span class="nc" id="L1827">        }</span>
    }

    /**
     * This method is called from native code in order to write encoder
     * output to the destination.
     *
     * We block any attempt to change the writer state during this
     * method, in order to prevent a corruption of the native encoder
     * state.
     */
    private void writeOutputData(byte[] data, int offset, int len)
            throws IOException
    {
<span class="nc" id="L1841">        cbLock.lock();</span>
        try {
<span class="nc" id="L1843">            ios.write(data, offset, len);</span>
        } finally {
<span class="nc" id="L1845">            cbLock.unlock();</span>
<span class="nc" id="L1846">        }</span>
<span class="nc" id="L1847">    }</span>

<span class="nc" id="L1849">    private Thread theThread = null;</span>
<span class="nc" id="L1850">    private int theLockCount = 0;</span>

    private synchronized void setThreadLock() {
<span class="nc" id="L1853">        Thread currThread = Thread.currentThread();</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">        if (theThread != null) {</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">            if (theThread != currThread) {</span>
                // it looks like that this reader instance is used
                // by multiple threads.
<span class="nc" id="L1858">                throw new IllegalStateException(&quot;Attempt to use instance of &quot; +</span>
                                                this + &quot; locked on thread &quot; +
                                                theThread + &quot; from thread &quot; +
                                                currThread);
            } else {
<span class="nc" id="L1863">                theLockCount ++;</span>
            }
        } else {
<span class="nc" id="L1866">            theThread = currThread;</span>
<span class="nc" id="L1867">            theLockCount = 1;</span>
        }
<span class="nc" id="L1869">    }</span>

    private synchronized void clearThreadLock() {
<span class="nc" id="L1872">        Thread currThread = Thread.currentThread();</span>
<span class="nc bnc" id="L1873" title="All 4 branches missed.">        if (theThread == null || theThread != currThread) {</span>
<span class="nc" id="L1874">            throw new IllegalStateException(&quot;Attempt to clear thread lock form wrong thread. &quot; +</span>
                                            &quot;Locked thread: &quot; + theThread +
                                            &quot;; current thread: &quot; + currThread);
        }
<span class="nc" id="L1878">        theLockCount --;</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        if (theLockCount == 0) {</span>
<span class="nc" id="L1880">            theThread = null;</span>
        }
<span class="nc" id="L1882">    }</span>

<span class="nc" id="L1884">    private CallBackLock cbLock = new CallBackLock();</span>

    private static class CallBackLock {

        private State lockState;

<span class="nc" id="L1890">        CallBackLock() {</span>
<span class="nc" id="L1891">            lockState = State.Unlocked;</span>
<span class="nc" id="L1892">        }</span>

        void check() {
<span class="nc bnc" id="L1895" title="All 2 branches missed.">            if (lockState != State.Unlocked) {</span>
<span class="nc" id="L1896">                throw new IllegalStateException(&quot;Access to the writer is not allowed&quot;);</span>
            }
<span class="nc" id="L1898">        }</span>

        private void lock() {
<span class="nc" id="L1901">            lockState = State.Locked;</span>
<span class="nc" id="L1902">        }</span>

        private void unlock() {
<span class="nc" id="L1905">            lockState = State.Unlocked;</span>
<span class="nc" id="L1906">        }</span>

<span class="nc" id="L1908">        private static enum State {</span>
<span class="nc" id="L1909">            Unlocked,</span>
<span class="nc" id="L1910">            Locked</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>