<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JPEGMetadata.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.jpeg</a> &gt; <span class="el_source">JPEGMetadata.java</span></div><h1>JPEGMetadata.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.jpeg;

import javax.imageio.ImageTypeSpecifier;
import javax.imageio.ImageWriteParam;
import javax.imageio.IIOException;
import javax.imageio.stream.ImageInputStream;
import javax.imageio.stream.ImageOutputStream;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataNode;
import javax.imageio.metadata.IIOMetadataFormat;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.plugins.jpeg.JPEGQTable;
import javax.imageio.plugins.jpeg.JPEGHuffmanTable;
import javax.imageio.plugins.jpeg.JPEGImageWriteParam;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.ListIterator;
import java.io.IOException;
import java.awt.color.ICC_Profile;
import java.awt.color.ICC_ColorSpace;
import java.awt.color.ColorSpace;
import java.awt.image.ColorModel;
import java.awt.Point;

/**
 * Metadata for the JPEG plug-in.
 */
public class JPEGMetadata extends IIOMetadata implements Cloneable {

    //////// Private variables

    private static final boolean debug = false;

    /**
     * A copy of &lt;code&gt;markerSequence&lt;/code&gt;, created the first time the
     * &lt;code&gt;markerSequence&lt;/code&gt; is modified.  This is used by reset
     * to restore the original state.
     */
<span class="nc" id="L72">    private List resetSequence = null;</span>

    /**
     * Set to &lt;code&gt;true&lt;/code&gt; when reading a thumbnail stored as
     * JPEG.  This is used to enforce the prohibition of JFIF thumbnails
     * containing any JFIF marker segments, and to ensure generation of
     * a correct native subtree during &lt;code&gt;getAsTree&lt;/code&gt;.
     */
<span class="nc" id="L80">    private boolean inThumb = false;</span>

    /**
     * Set by the chroma node construction method to signal the
     * presence or absence of an alpha channel to the transparency
     * node construction method.  Used only when constructing a
     * standard metadata tree.
     */
    private boolean hasAlpha;

    //////// end of private variables

    /////// Package-access variables

    /**
     * All data is a list of &lt;code&gt;MarkerSegment&lt;/code&gt; objects.
     * When accessing the list, use the tag to identify the particular
     * subclass.  Any JFIF marker segment must be the first element
     * of the list if it is present, and any JFXX or APP2ICC marker
     * segments are subordinate to the JFIF marker segment.  This
     * list is package visible so that the writer can access it.
     * @see #MarkerSegment
     */
<span class="nc" id="L103">    List markerSequence = new ArrayList();</span>

    /**
     * Indicates whether this object represents stream or image
     * metadata.  Package-visible so the writer can see it.
     */
    final boolean isStream;

    /////// End of package-access variables

    /////// Constructors

    /**
     * Constructor containing code shared by other constructors.
     */
    JPEGMetadata(boolean isStream, boolean inThumb) {
<span class="nc" id="L119">        super(true,  // Supports standard format</span>
              JPEG.nativeImageMetadataFormatName,  // and a native format
              JPEG.nativeImageMetadataFormatClassName,
              null, null);  // No other formats
<span class="nc" id="L123">        this.inThumb = inThumb;</span>
        // But if we are stream metadata, adjust the variables
<span class="nc" id="L125">        this.isStream = isStream;</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (isStream) {</span>
<span class="nc" id="L127">            nativeMetadataFormatName = JPEG.nativeStreamMetadataFormatName;</span>
<span class="nc" id="L128">            nativeMetadataFormatClassName =</span>
                JPEG.nativeStreamMetadataFormatClassName;
        }
<span class="nc" id="L131">    }</span>

    /*
     * Constructs a &lt;code&gt;JPEGMetadata&lt;/code&gt; object by reading the
     * contents of an &lt;code&gt;ImageInputStream&lt;/code&gt;.  Has package-only
     * access.
     *
     * @param isStream A boolean indicating whether this object will be
     * stream or image metadata.
     * @param isThumb A boolean indicating whether this metadata object
     * is for an image or for a thumbnail stored as JPEG.
     * @param iis An &lt;code&gt;ImageInputStream&lt;/code&gt; from which to read
     * the metadata.
     * @param reader The &lt;code&gt;JPEGImageReader&lt;/code&gt; calling this
     * constructor, to which warnings should be sent.
     */
    JPEGMetadata(boolean isStream,
                 boolean isThumb,
                 ImageInputStream iis,
                 JPEGImageReader reader) throws IOException {
<span class="nc" id="L151">        this(isStream, isThumb);</span>

<span class="nc" id="L153">        JPEGBuffer buffer = new JPEGBuffer(iis);</span>

<span class="nc" id="L155">        buffer.loadBuf(0);</span>

        // The first three bytes should be FF, SOI, FF
<span class="nc bnc" id="L158" title="All 6 branches missed.">        if (((buffer.buf[0] &amp; 0xff) != 0xff)</span>
            || ((buffer.buf[1] &amp; 0xff) != JPEG.SOI)
            || ((buffer.buf[2] &amp; 0xff) != 0xff)) {
<span class="nc" id="L161">            throw new IIOException (&quot;Image format error&quot;);</span>
        }

<span class="nc" id="L164">        boolean done = false;</span>
<span class="nc" id="L165">        buffer.bufAvail -=2;  // Next byte should be the ff before a marker</span>
<span class="nc" id="L166">        buffer.bufPtr = 2;</span>
<span class="nc" id="L167">        MarkerSegment newGuy = null;</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        while (!done) {</span>
            byte [] buf;
            int ptr;
<span class="nc" id="L171">            buffer.loadBuf(1);</span>
            if (debug) {
                System.out.println(&quot;top of loop&quot;);
                buffer.print(10);
            }
<span class="nc" id="L176">            buffer.scanForFF(reader);</span>
<span class="nc bnc" id="L177" title="All 13 branches missed.">            switch (buffer.buf[buffer.bufPtr] &amp; 0xff) {</span>
            case 0:
                if (debug) {
                    System.out.println(&quot;Skipping 0&quot;);
                }
<span class="nc" id="L182">                buffer.bufAvail--;</span>
<span class="nc" id="L183">                buffer.bufPtr++;</span>
<span class="nc" id="L184">                break;</span>
            case JPEG.SOF0:
            case JPEG.SOF1:
            case JPEG.SOF2:
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (isStream) {</span>
<span class="nc" id="L189">                    throw new IIOException</span>
                        (&quot;SOF not permitted in stream metadata&quot;);
                }
<span class="nc" id="L192">                newGuy = new SOFMarkerSegment(buffer);</span>
<span class="nc" id="L193">                break;</span>
            case JPEG.DQT:
<span class="nc" id="L195">                newGuy = new DQTMarkerSegment(buffer);</span>
<span class="nc" id="L196">                break;</span>
            case JPEG.DHT:
<span class="nc" id="L198">                newGuy = new DHTMarkerSegment(buffer);</span>
<span class="nc" id="L199">                break;</span>
            case JPEG.DRI:
<span class="nc" id="L201">                newGuy = new DRIMarkerSegment(buffer);</span>
<span class="nc" id="L202">                break;</span>
            case JPEG.APP0:
                // Either JFIF, JFXX, or unknown APP0
<span class="nc" id="L205">                buffer.loadBuf(8); // tag, length, id</span>
<span class="nc" id="L206">                buf = buffer.buf;</span>
<span class="nc" id="L207">                ptr = buffer.bufPtr;</span>
<span class="nc bnc" id="L208" title="All 10 branches missed.">                if ((buf[ptr+3] == 'J')</span>
                    &amp;&amp; (buf[ptr+4] == 'F')
                    &amp;&amp; (buf[ptr+5] == 'I')
                    &amp;&amp; (buf[ptr+6] == 'F')
                    &amp;&amp; (buf[ptr+7] == 0)) {
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (inThumb) {</span>
<span class="nc" id="L214">                        reader.warningOccurred</span>
<span class="nc" id="L215">                            (JPEGImageReader.WARNING_NO_JFIF_IN_THUMB);</span>
                        // Leave newGuy null
                        // Read a dummy to skip the segment
<span class="nc" id="L218">                        JFIFMarkerSegment dummy =</span>
                            new JFIFMarkerSegment(buffer);
<span class="nc bnc" id="L220" title="All 2 branches missed.">                    } else if (isStream) {</span>
<span class="nc" id="L221">                        throw new IIOException</span>
                            (&quot;JFIF not permitted in stream metadata&quot;);
<span class="nc bnc" id="L223" title="All 2 branches missed.">                    } else if (markerSequence.isEmpty() == false) {</span>
<span class="nc" id="L224">                        throw new IIOException</span>
                            (&quot;JFIF APP0 must be first marker after SOI&quot;);
                    } else {
<span class="nc" id="L227">                        newGuy = new JFIFMarkerSegment(buffer);</span>
                    }
<span class="nc bnc" id="L229" title="All 10 branches missed.">                } else if ((buf[ptr+3] == 'J')</span>
                           &amp;&amp; (buf[ptr+4] == 'F')
                           &amp;&amp; (buf[ptr+5] == 'X')
                           &amp;&amp; (buf[ptr+6] == 'X')
                           &amp;&amp; (buf[ptr+7] == 0)) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">                    if (isStream) {</span>
<span class="nc" id="L235">                        throw new IIOException</span>
                            (&quot;JFXX not permitted in stream metadata&quot;);
                    }
<span class="nc bnc" id="L238" title="All 2 branches missed.">                    if (inThumb) {</span>
<span class="nc" id="L239">                        throw new IIOException</span>
                          (&quot;JFXX markers not allowed in JFIF JPEG thumbnail&quot;);
                    }
<span class="nc" id="L242">                    JFIFMarkerSegment jfif =</span>
                        (JFIFMarkerSegment) findMarkerSegment
<span class="nc" id="L244">                               (JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    if (jfif == null) {</span>
<span class="nc" id="L246">                        throw new IIOException</span>
                            (&quot;JFXX encountered without prior JFIF!&quot;);
                    }
<span class="nc" id="L249">                    jfif.addJFXX(buffer, reader);</span>
                    // newGuy remains null
<span class="nc" id="L251">                } else {</span>
<span class="nc" id="L252">                    newGuy = new MarkerSegment(buffer);</span>
<span class="nc" id="L253">                    newGuy.loadData(buffer);</span>
                }
<span class="nc" id="L255">                break;</span>
            case JPEG.APP2:
                // Either an ICC profile or unknown APP2
<span class="nc" id="L258">                buffer.loadBuf(15); // tag, length, id</span>
<span class="nc bnc" id="L259" title="All 24 branches missed.">                if ((buffer.buf[buffer.bufPtr+3] == 'I')</span>
                    &amp;&amp; (buffer.buf[buffer.bufPtr+4] == 'C')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+5] == 'C')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+6] == '_')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+7] == 'P')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+8] == 'R')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+9] == 'O')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+10] == 'F')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+11] == 'I')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+12] == 'L')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+13] == 'E')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+14] == 0)
                    ) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">                    if (isStream) {</span>
<span class="nc" id="L273">                        throw new IIOException</span>
                            (&quot;ICC profiles not permitted in stream metadata&quot;);
                    }

<span class="nc" id="L277">                    JFIFMarkerSegment jfif =</span>
                        (JFIFMarkerSegment) findMarkerSegment
<span class="nc" id="L279">                        (JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (jfif == null) {</span>
<span class="nc" id="L281">                        newGuy = new MarkerSegment(buffer);</span>
<span class="nc" id="L282">                        newGuy.loadData(buffer);</span>
                    } else {
<span class="nc" id="L284">                        jfif.addICC(buffer);</span>
                    }
                    // newGuy remains null
<span class="nc" id="L287">                } else {</span>
<span class="nc" id="L288">                    newGuy = new MarkerSegment(buffer);</span>
<span class="nc" id="L289">                    newGuy.loadData(buffer);</span>
                }
<span class="nc" id="L291">                break;</span>
            case JPEG.APP14:
                // Either Adobe or unknown APP14
<span class="nc" id="L294">                buffer.loadBuf(8); // tag, length, id</span>
<span class="nc bnc" id="L295" title="All 10 branches missed.">                if ((buffer.buf[buffer.bufPtr+3] == 'A')</span>
                    &amp;&amp; (buffer.buf[buffer.bufPtr+4] == 'd')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+5] == 'o')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+6] == 'b')
                    &amp;&amp; (buffer.buf[buffer.bufPtr+7] == 'e')) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    if (isStream) {</span>
<span class="nc" id="L301">                        throw new IIOException</span>
                      (&quot;Adobe APP14 markers not permitted in stream metadata&quot;);
                    }
<span class="nc" id="L304">                    newGuy = new AdobeMarkerSegment(buffer);</span>
                } else {
<span class="nc" id="L306">                    newGuy = new MarkerSegment(buffer);</span>
<span class="nc" id="L307">                    newGuy.loadData(buffer);</span>
                }

<span class="nc" id="L310">                break;</span>
            case JPEG.COM:
<span class="nc" id="L312">                newGuy = new COMMarkerSegment(buffer);</span>
<span class="nc" id="L313">                break;</span>
            case JPEG.SOS:
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (isStream) {</span>
<span class="nc" id="L316">                    throw new IIOException</span>
                        (&quot;SOS not permitted in stream metadata&quot;);
                }
<span class="nc" id="L319">                newGuy = new SOSMarkerSegment(buffer);</span>
<span class="nc" id="L320">                break;</span>
            case JPEG.RST0:
            case JPEG.RST1:
            case JPEG.RST2:
            case JPEG.RST3:
            case JPEG.RST4:
            case JPEG.RST5:
            case JPEG.RST6:
            case JPEG.RST7:
                if (debug) {
                    System.out.println(&quot;Restart Marker&quot;);
                }
<span class="nc" id="L332">                buffer.bufPtr++; // Just skip it</span>
<span class="nc" id="L333">                buffer.bufAvail--;</span>
<span class="nc" id="L334">                break;</span>
            case JPEG.EOI:
<span class="nc" id="L336">                done = true;</span>
<span class="nc" id="L337">                buffer.bufPtr++;</span>
<span class="nc" id="L338">                buffer.bufAvail--;</span>
<span class="nc" id="L339">                break;</span>
            default:
<span class="nc" id="L341">                newGuy = new MarkerSegment(buffer);</span>
<span class="nc" id="L342">                newGuy.loadData(buffer);</span>
<span class="nc" id="L343">                newGuy.unknown = true;</span>
                break;
            }
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (newGuy != null) {</span>
<span class="nc" id="L347">                markerSequence.add(newGuy);</span>
                if (debug) {
                    newGuy.print();
                }
<span class="nc" id="L351">                newGuy = null;</span>
            }
<span class="nc" id="L353">        }</span>

        // Now that we've read up to the EOI, we need to push back
        // whatever is left in the buffer, so that the next read
        // in the native code will work.

<span class="nc" id="L359">        buffer.pushBack();</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (!isConsistent()) {</span>
<span class="nc" id="L362">            throw new IIOException(&quot;Inconsistent metadata read from stream&quot;);</span>
        }
<span class="nc" id="L364">    }</span>

    /**
     * Constructs a default stream &lt;code&gt;JPEGMetadata&lt;/code&gt; object appropriate
     * for the given write parameters.
     */
    JPEGMetadata(ImageWriteParam param, JPEGImageWriter writer) {
<span class="nc" id="L371">        this(true, false);</span>

<span class="nc" id="L373">        JPEGImageWriteParam jparam = null;</span>

<span class="nc bnc" id="L375" title="All 4 branches missed.">        if ((param != null) &amp;&amp; (param instanceof JPEGImageWriteParam)) {</span>
<span class="nc" id="L376">            jparam = (JPEGImageWriteParam) param;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (!jparam.areTablesSet()) {</span>
<span class="nc" id="L378">                jparam = null;</span>
            }
        }
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (jparam != null) {</span>
<span class="nc" id="L382">            markerSequence.add(new DQTMarkerSegment(jparam.getQTables()));</span>
<span class="nc" id="L383">            markerSequence.add</span>
<span class="nc" id="L384">                (new DHTMarkerSegment(jparam.getDCHuffmanTables(),</span>
<span class="nc" id="L385">                                      jparam.getACHuffmanTables()));</span>
        } else {
            // default tables.
<span class="nc" id="L388">            markerSequence.add(new DQTMarkerSegment(JPEG.getDefaultQTables()));</span>
<span class="nc" id="L389">            markerSequence.add(new DHTMarkerSegment(JPEG.getDefaultHuffmanTables(true),</span>
<span class="nc" id="L390">                                                    JPEG.getDefaultHuffmanTables(false)));</span>
        }

        // Defensive programming
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (!isConsistent()) {</span>
<span class="nc" id="L395">            throw new InternalError(&quot;Default stream metadata is inconsistent&quot;);</span>
        }
<span class="nc" id="L397">    }</span>

    /**
     * Constructs a default image &lt;code&gt;JPEGMetadata&lt;/code&gt; object appropriate
     * for the given image type and write parameters.
     */
    JPEGMetadata(ImageTypeSpecifier imageType,
                 ImageWriteParam param,
                 JPEGImageWriter writer) {
<span class="nc" id="L406">        this(false, false);</span>

<span class="nc" id="L408">        boolean wantJFIF = true;</span>
<span class="nc" id="L409">        boolean wantAdobe = false;</span>
<span class="nc" id="L410">        int transform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc" id="L411">        boolean willSubsample = true;</span>
<span class="nc" id="L412">        boolean wantICC = false;</span>
<span class="nc" id="L413">        boolean wantProg = false;</span>
<span class="nc" id="L414">        boolean wantOptimized = false;</span>
<span class="nc" id="L415">        boolean wantExtended = false;</span>
<span class="nc" id="L416">        boolean wantQTables = true;</span>
<span class="nc" id="L417">        boolean wantHTables = true;</span>
<span class="nc" id="L418">        float quality = JPEG.DEFAULT_QUALITY;</span>
<span class="nc" id="L419">        byte[] componentIDs = { 1, 2, 3, 4};</span>
<span class="nc" id="L420">        int numComponents = 0;</span>

<span class="nc" id="L422">        ImageTypeSpecifier destType = null;</span>

<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L425">            destType = param.getDestinationType();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (destType != null) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                if (imageType != null) {</span>
                    // Ignore the destination type.
<span class="nc" id="L429">                    writer.warningOccurred</span>
<span class="nc" id="L430">                        (JPEGImageWriter.WARNING_DEST_IGNORED);</span>
<span class="nc" id="L431">                    destType = null;</span>
                }
            }
            // The only progressive mode that makes sense here is MODE_DEFAULT
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (param.canWriteProgressive()) {</span>
                // the param may not be one of ours, so it may return false.
                // If so, the following would throw an exception
<span class="nc bnc" id="L438" title="All 2 branches missed.">                if (param.getProgressiveMode() == ImageWriteParam.MODE_DEFAULT) {</span>
<span class="nc" id="L439">                    wantProg = true;</span>
<span class="nc" id="L440">                    wantOptimized = true;</span>
<span class="nc" id="L441">                    wantHTables = false;</span>
                }
            }

<span class="nc bnc" id="L445" title="All 2 branches missed.">            if (param instanceof JPEGImageWriteParam) {</span>
<span class="nc" id="L446">                JPEGImageWriteParam jparam = (JPEGImageWriteParam) param;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (jparam.areTablesSet()) {</span>
<span class="nc" id="L448">                    wantQTables = false;  // If the param has them, metadata shouldn't</span>
<span class="nc" id="L449">                    wantHTables = false;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if ((jparam.getDCHuffmanTables().length &gt; 2)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                            || (jparam.getACHuffmanTables().length &gt; 2)) {</span>
<span class="nc" id="L452">                        wantExtended = true;</span>
                    }
                }
                // Progressive forces optimized, regardless of param setting
                // so consult the param re optimized only if not progressive
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (!wantProg) {</span>
<span class="nc" id="L458">                    wantOptimized = jparam.getOptimizeHuffmanTables();</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                    if (wantOptimized) {</span>
<span class="nc" id="L460">                        wantHTables = false;</span>
                    }
                }
            }

            // compression quality should determine the q tables.  Note that this
            // will be ignored if we already decided not to create any.
            // Again, the param may not be one of ours, so we must check that it
            // supports compression settings
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (param.canWriteCompressed()) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (param.getCompressionMode() == ImageWriteParam.MODE_EXPLICIT) {</span>
<span class="nc" id="L471">                    quality = param.getCompressionQuality();</span>
                }
            }
        }

        // We are done with the param, now for the image types

<span class="nc" id="L478">        ColorSpace cs = null;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (destType != null) {</span>
<span class="nc" id="L480">            ColorModel cm = destType.getColorModel();</span>
<span class="nc" id="L481">            numComponents = cm.getNumComponents();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            boolean hasExtraComponents = (cm.getNumColorComponents() != numComponents);</span>
<span class="nc" id="L483">            boolean hasAlpha = cm.hasAlpha();</span>
<span class="nc" id="L484">            cs = cm.getColorSpace();</span>
<span class="nc" id="L485">            int type = cs.getType();</span>
<span class="nc bnc" id="L486" title="All 5 branches missed.">            switch(type) {</span>
            case ColorSpace.TYPE_GRAY:
<span class="nc" id="L488">                willSubsample = false;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (hasExtraComponents) {  // e.g. alpha</span>
<span class="nc" id="L490">                    wantJFIF = false;</span>
                }
                break;
            case ColorSpace.TYPE_3CLR:
<span class="nc bnc" id="L494" title="All 2 branches missed.">                if (cs == JPEG.JCS.getYCC()) {</span>
<span class="nc" id="L495">                    wantJFIF = false;</span>
<span class="nc" id="L496">                    componentIDs[0] = (byte) 'Y';</span>
<span class="nc" id="L497">                    componentIDs[1] = (byte) 'C';</span>
<span class="nc" id="L498">                    componentIDs[2] = (byte) 'c';</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (hasAlpha) {</span>
<span class="nc" id="L500">                        componentIDs[3] = (byte) 'A';</span>
                    }
                }
                break;
            case ColorSpace.TYPE_YCbCr:
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (hasExtraComponents) { // e.g. K or alpha</span>
<span class="nc" id="L506">                    wantJFIF = false;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                    if (!hasAlpha) { // Not alpha, so must be K</span>
<span class="nc" id="L508">                        wantAdobe = true;</span>
<span class="nc" id="L509">                        transform = JPEG.ADOBE_YCCK;</span>
                    }
                }
                break;
            case ColorSpace.TYPE_RGB:  // with or without alpha
<span class="nc" id="L514">                wantJFIF = false;</span>
<span class="nc" id="L515">                wantAdobe = true;</span>
<span class="nc" id="L516">                willSubsample = false;</span>
<span class="nc" id="L517">                componentIDs[0] = (byte) 'R';</span>
<span class="nc" id="L518">                componentIDs[1] = (byte) 'G';</span>
<span class="nc" id="L519">                componentIDs[2] = (byte) 'B';</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (hasAlpha) {</span>
<span class="nc" id="L521">                    componentIDs[3] = (byte) 'A';</span>
                }
                break;
            default:
                // Everything else is not subsampled, gets no special marker,
                // and component ids are 1 - N
<span class="nc" id="L527">                wantJFIF = false;</span>
<span class="nc" id="L528">                willSubsample = false;</span>
            }
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (imageType != null) {</span>
<span class="nc" id="L531">            ColorModel cm = imageType.getColorModel();</span>
<span class="nc" id="L532">            numComponents = cm.getNumComponents();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            boolean hasExtraComponents = (cm.getNumColorComponents() != numComponents);</span>
<span class="nc" id="L534">            boolean hasAlpha = cm.hasAlpha();</span>
<span class="nc" id="L535">            cs = cm.getColorSpace();</span>
<span class="nc" id="L536">            int type = cs.getType();</span>
<span class="nc bnc" id="L537" title="All 6 branches missed.">            switch(type) {</span>
            case ColorSpace.TYPE_GRAY:
<span class="nc" id="L539">                willSubsample = false;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                if (hasExtraComponents) {  // e.g. alpha</span>
<span class="nc" id="L541">                    wantJFIF = false;</span>
                }
                break;
            case ColorSpace.TYPE_RGB:  // with or without alpha
                // without alpha we just accept the JFIF defaults
<span class="nc bnc" id="L546" title="All 2 branches missed.">                if (hasAlpha) {</span>
<span class="nc" id="L547">                    wantJFIF = false;</span>
                }
                break;
            case ColorSpace.TYPE_3CLR:
<span class="nc" id="L551">                wantJFIF = false;</span>
<span class="nc" id="L552">                willSubsample = false;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (cs.equals(ColorSpace.getInstance(ColorSpace.CS_PYCC))) {</span>
<span class="nc" id="L554">                    willSubsample = true;</span>
<span class="nc" id="L555">                    wantAdobe = true;</span>
<span class="nc" id="L556">                    componentIDs[0] = (byte) 'Y';</span>
<span class="nc" id="L557">                    componentIDs[1] = (byte) 'C';</span>
<span class="nc" id="L558">                    componentIDs[2] = (byte) 'c';</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                    if (hasAlpha) {</span>
<span class="nc" id="L560">                        componentIDs[3] = (byte) 'A';</span>
                    }
                }
                break;
            case ColorSpace.TYPE_YCbCr:
<span class="nc bnc" id="L565" title="All 2 branches missed.">                if (hasExtraComponents) { // e.g. K or alpha</span>
<span class="nc" id="L566">                    wantJFIF = false;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    if (!hasAlpha) {  // then it must be K</span>
<span class="nc" id="L568">                        wantAdobe = true;</span>
<span class="nc" id="L569">                        transform = JPEG.ADOBE_YCCK;</span>
                    }
                }
                break;
            case ColorSpace.TYPE_CMYK:
<span class="nc" id="L574">                wantJFIF = false;</span>
<span class="nc" id="L575">                wantAdobe = true;</span>
<span class="nc" id="L576">                transform = JPEG.ADOBE_YCCK;</span>
<span class="nc" id="L577">                break;</span>

            default:
                // Everything else is not subsampled, gets no special marker,
                // and component ids are 0 - N
<span class="nc" id="L582">                wantJFIF = false;</span>
<span class="nc" id="L583">                willSubsample = false;</span>
            }

        }

        // do we want an ICC profile?
<span class="nc bnc" id="L589" title="All 4 branches missed.">        if (wantJFIF &amp;&amp; JPEG.isNonStandardICC(cs)) {</span>
<span class="nc" id="L590">            wantICC = true;</span>
        }

        // Now step through the markers, consulting our variables.
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (wantJFIF) {</span>
<span class="nc" id="L595">            JFIFMarkerSegment jfif = new JFIFMarkerSegment();</span>
<span class="nc" id="L596">            markerSequence.add(jfif);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">            if (wantICC) {</span>
                try {
<span class="nc" id="L599">                    jfif.addICC((ICC_ColorSpace)cs);</span>
<span class="nc" id="L600">                } catch (IOException e) {} // Can't happen here</span>
            }
        }
        // Adobe
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (wantAdobe) {</span>
<span class="nc" id="L605">            markerSequence.add(new AdobeMarkerSegment(transform));</span>
        }

        // dqt
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (wantQTables) {</span>
<span class="nc" id="L610">            markerSequence.add(new DQTMarkerSegment(quality, willSubsample));</span>
        }

        // dht
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (wantHTables) {</span>
<span class="nc" id="L615">            markerSequence.add(new DHTMarkerSegment(willSubsample));</span>
        }

        // sof
<span class="nc" id="L619">        markerSequence.add(new SOFMarkerSegment(wantProg,</span>
                                                wantExtended,
                                                willSubsample,
                                                componentIDs,
                                                numComponents));

        // sos
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (!wantProg) {  // Default progression scans are done in the writer</span>
<span class="nc" id="L627">            markerSequence.add(new SOSMarkerSegment(willSubsample,</span>
                                                    componentIDs,
                                                    numComponents));
        }

        // Defensive programming
<span class="nc bnc" id="L633" title="All 2 branches missed.">        if (!isConsistent()) {</span>
<span class="nc" id="L634">            throw new InternalError(&quot;Default image metadata is inconsistent&quot;);</span>
        }
<span class="nc" id="L636">    }</span>

    ////// End of constructors

    // Utilities for dealing with the marker sequence.
    // The first ones have package access for access from the writer.

    /**
     * Returns the first MarkerSegment object in the list
     * with the given tag, or null if none is found.
     */
    MarkerSegment findMarkerSegment(int tag) {
<span class="nc" id="L648">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L650">            MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (seg.tag == tag) {</span>
<span class="nc" id="L652">                return seg;</span>
            }
<span class="nc" id="L654">        }</span>
<span class="nc" id="L655">        return null;</span>
    }

    /**
     * Returns the first or last MarkerSegment object in the list
     * of the given class, or null if none is found.
     */
    MarkerSegment findMarkerSegment(Class cls, boolean first) {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (first) {</span>
<span class="nc" id="L664">            Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L666">                MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (cls.isInstance(seg)) {</span>
<span class="nc" id="L668">                    return seg;</span>
                }
<span class="nc" id="L670">            }</span>
<span class="nc" id="L671">        } else {</span>
<span class="nc" id="L672">            ListIterator iter = markerSequence.listIterator(markerSequence.size());</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            while (iter.hasPrevious()) {</span>
<span class="nc" id="L674">                MarkerSegment seg = (MarkerSegment)iter.previous();</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                if (cls.isInstance(seg)) {</span>
<span class="nc" id="L676">                    return seg;</span>
                }
<span class="nc" id="L678">            }</span>
        }
<span class="nc" id="L680">        return null;</span>
    }

    /**
     * Returns the index of the first or last MarkerSegment in the list
     * of the given class, or -1 if none is found.
     */
    private int findMarkerSegmentPosition(Class cls, boolean first) {
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (first) {</span>
<span class="nc" id="L689">            ListIterator iter = markerSequence.listIterator();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            for (int i = 0; iter.hasNext(); i++) {</span>
<span class="nc" id="L691">                MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                if (cls.isInstance(seg)) {</span>
<span class="nc" id="L693">                    return i;</span>
                }
            }
<span class="nc" id="L696">        } else {</span>
<span class="nc" id="L697">            ListIterator iter = markerSequence.listIterator(markerSequence.size());</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            for (int i = markerSequence.size()-1; iter.hasPrevious(); i--) {</span>
<span class="nc" id="L699">                MarkerSegment seg = (MarkerSegment)iter.previous();</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                if (cls.isInstance(seg)) {</span>
<span class="nc" id="L701">                    return i;</span>
                }
            }
        }
<span class="nc" id="L705">        return -1;</span>
    }

    private int findLastUnknownMarkerSegmentPosition() {
<span class="nc" id="L709">        ListIterator iter = markerSequence.listIterator(markerSequence.size());</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        for (int i = markerSequence.size()-1; iter.hasPrevious(); i--) {</span>
<span class="nc" id="L711">            MarkerSegment seg = (MarkerSegment)iter.previous();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (seg.unknown == true) {</span>
<span class="nc" id="L713">                return i;</span>
            }
        }
<span class="nc" id="L716">        return -1;</span>
    }

    // Implement Cloneable, but restrict access

    protected Object clone() {
<span class="nc" id="L722">        JPEGMetadata newGuy = null;</span>
        try {
<span class="nc" id="L724">            newGuy = (JPEGMetadata) super.clone();</span>
<span class="nc" id="L725">        } catch (CloneNotSupportedException e) {} // won't happen</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (markerSequence != null) {</span>
<span class="nc" id="L727">            newGuy.markerSequence = (List) cloneSequence();</span>
        }
<span class="nc" id="L729">        newGuy.resetSequence = null;</span>
<span class="nc" id="L730">        return newGuy;</span>
    }

    /**
     * Returns a deep copy of the current marker sequence.
     */
    private List cloneSequence() {
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (markerSequence == null) {</span>
<span class="nc" id="L738">            return null;</span>
        }
<span class="nc" id="L740">        List retval = new ArrayList(markerSequence.size());</span>
<span class="nc" id="L741">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L743">            MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc" id="L744">            retval.add(seg.clone());</span>
<span class="nc" id="L745">        }</span>

<span class="nc" id="L747">        return retval;</span>
    }


    // Tree methods

    public Node getAsTree(String formatName) {
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L755">            throw new IllegalArgumentException(&quot;null formatName!&quot;);</span>
        }
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (isStream) {</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (formatName.equals(JPEG.nativeStreamMetadataFormatName)) {</span>
<span class="nc" id="L759">                return getNativeTree();</span>
            }
        } else {
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (formatName.equals(JPEG.nativeImageMetadataFormatName)) {</span>
<span class="nc" id="L763">                return getNativeTree();</span>
            }
<span class="nc" id="L765">            if (formatName.equals</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                    (IIOMetadataFormatImpl.standardMetadataFormatName)) {</span>
<span class="nc" id="L767">                return getStandardTree();</span>
            }
        }
<span class="nc" id="L770">        throw  new IllegalArgumentException(&quot;Unsupported format name: &quot;</span>
                                                + formatName);
    }

    IIOMetadataNode getNativeTree() {
        IIOMetadataNode root;
        IIOMetadataNode top;
<span class="nc" id="L777">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (isStream) {</span>
<span class="nc" id="L779">            root = new IIOMetadataNode(JPEG.nativeStreamMetadataFormatName);</span>
<span class="nc" id="L780">            top = root;</span>
        } else {
<span class="nc" id="L782">            IIOMetadataNode sequence = new IIOMetadataNode(&quot;markerSequence&quot;);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (!inThumb) {</span>
<span class="nc" id="L784">                root = new IIOMetadataNode(JPEG.nativeImageMetadataFormatName);</span>
<span class="nc" id="L785">                IIOMetadataNode header = new IIOMetadataNode(&quot;JPEGvariety&quot;);</span>
<span class="nc" id="L786">                root.appendChild(header);</span>
<span class="nc" id="L787">                JFIFMarkerSegment jfif = (JFIFMarkerSegment)</span>
<span class="nc" id="L788">                    findMarkerSegment(JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                if (jfif != null) {</span>
<span class="nc" id="L790">                    iter.next();  // JFIF must be first, so this skips it</span>
<span class="nc" id="L791">                    header.appendChild(jfif.getNativeNode());</span>
                }
<span class="nc" id="L793">                root.appendChild(sequence);</span>
<span class="nc" id="L794">            } else {</span>
<span class="nc" id="L795">                root = sequence;</span>
            }
<span class="nc" id="L797">            top = sequence;</span>
        }
<span class="nc bnc" id="L799" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L800">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc" id="L801">            top.appendChild(seg.getNativeNode());</span>
<span class="nc" id="L802">        }</span>
<span class="nc" id="L803">        return root;</span>
    }

    // Standard tree node methods

    protected IIOMetadataNode getStandardChromaNode() {
<span class="nc" id="L809">        hasAlpha = false;  // Unless we find otherwise</span>

        // Colorspace type - follow the rules in the spec
        // First get the SOF marker segment, if there is one
<span class="nc" id="L813">        SOFMarkerSegment sof = (SOFMarkerSegment)</span>
<span class="nc" id="L814">            findMarkerSegment(SOFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (sof == null) {</span>
            // No image, so no chroma
<span class="nc" id="L817">            return null;</span>
        }

<span class="nc" id="L820">        IIOMetadataNode chroma = new IIOMetadataNode(&quot;Chroma&quot;);</span>
<span class="nc" id="L821">        IIOMetadataNode csType = new IIOMetadataNode(&quot;ColorSpaceType&quot;);</span>
<span class="nc" id="L822">        chroma.appendChild(csType);</span>

        // get the number of channels
<span class="nc" id="L825">        int numChannels = sof.componentSpecs.length;</span>

<span class="nc" id="L827">        IIOMetadataNode numChanNode = new IIOMetadataNode(&quot;NumChannels&quot;);</span>
<span class="nc" id="L828">        chroma.appendChild(numChanNode);</span>
<span class="nc" id="L829">        numChanNode.setAttribute(&quot;value&quot;, Integer.toString(numChannels));</span>

        // is there a JFIF marker segment?
<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (findMarkerSegment(JFIFMarkerSegment.class, true) != null) {</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            if (numChannels == 1) {</span>
<span class="nc" id="L834">                csType.setAttribute(&quot;name&quot;, &quot;GRAY&quot;);</span>
            } else {
<span class="nc" id="L836">                csType.setAttribute(&quot;name&quot;, &quot;YCbCr&quot;);</span>
            }
<span class="nc" id="L838">            return chroma;</span>
        }

        // How about an Adobe marker segment?
<span class="nc" id="L842">        AdobeMarkerSegment adobe =</span>
<span class="nc" id="L843">            (AdobeMarkerSegment) findMarkerSegment(AdobeMarkerSegment.class, true);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (adobe != null){</span>
<span class="nc bnc" id="L845" title="All 4 branches missed.">            switch (adobe.transform) {</span>
            case JPEG.ADOBE_YCCK:
<span class="nc" id="L847">                csType.setAttribute(&quot;name&quot;, &quot;YCCK&quot;);</span>
<span class="nc" id="L848">                break;</span>
            case JPEG.ADOBE_YCC:
<span class="nc" id="L850">                csType.setAttribute(&quot;name&quot;, &quot;YCbCr&quot;);</span>
<span class="nc" id="L851">                break;</span>
            case JPEG.ADOBE_UNKNOWN:
<span class="nc bnc" id="L853" title="All 2 branches missed.">                if (numChannels == 3) {</span>
<span class="nc" id="L854">                    csType.setAttribute(&quot;name&quot;, &quot;RGB&quot;);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">                } else if (numChannels == 4) {</span>
<span class="nc" id="L856">                    csType.setAttribute(&quot;name&quot;, &quot;CMYK&quot;);</span>
                }
                break;
            }
<span class="nc" id="L860">            return chroma;</span>
        }

        // Neither marker.  Check components
<span class="nc bnc" id="L864" title="All 2 branches missed.">        if (numChannels &lt; 3) {</span>
<span class="nc" id="L865">            csType.setAttribute(&quot;name&quot;, &quot;GRAY&quot;);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (numChannels == 2) {</span>
<span class="nc" id="L867">                hasAlpha = true;</span>
            }
<span class="nc" id="L869">            return chroma;</span>
        }

<span class="nc" id="L872">        boolean idsAreJFIF = true;</span>

<span class="nc bnc" id="L874" title="All 2 branches missed.">        for (int i = 0; i &lt; sof.componentSpecs.length; i++) {</span>
<span class="nc" id="L875">            int id = sof.componentSpecs[i].componentId;</span>
<span class="nc bnc" id="L876" title="All 4 branches missed.">            if ((id &lt; 1) || (id &gt;= sof.componentSpecs.length)) {</span>
<span class="nc" id="L877">                idsAreJFIF = false;</span>
            }
        }

<span class="nc bnc" id="L881" title="All 2 branches missed.">        if (idsAreJFIF) {</span>
<span class="nc" id="L882">            csType.setAttribute(&quot;name&quot;, &quot;YCbCr&quot;);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (numChannels == 4) {</span>
<span class="nc" id="L884">                hasAlpha = true;</span>
            }
<span class="nc" id="L886">            return chroma;</span>
        }

        // Check against the letters
<span class="nc bnc" id="L890" title="All 6 branches missed.">        if ((sof.componentSpecs[0].componentId == 'R')</span>
            &amp;&amp; (sof.componentSpecs[1].componentId == 'G')
            &amp;&amp; (sof.componentSpecs[2].componentId == 'B')){

<span class="nc" id="L894">            csType.setAttribute(&quot;name&quot;, &quot;RGB&quot;);</span>
<span class="nc bnc" id="L895" title="All 4 branches missed.">            if ((numChannels == 4)</span>
                &amp;&amp; (sof.componentSpecs[3].componentId == 'A')) {
<span class="nc" id="L897">                hasAlpha = true;</span>
            }
<span class="nc" id="L899">            return chroma;</span>
        }

<span class="nc bnc" id="L902" title="All 6 branches missed.">        if ((sof.componentSpecs[0].componentId == 'Y')</span>
            &amp;&amp; (sof.componentSpecs[1].componentId == 'C')
            &amp;&amp; (sof.componentSpecs[2].componentId == 'c')){

<span class="nc" id="L906">            csType.setAttribute(&quot;name&quot;, &quot;PhotoYCC&quot;);</span>
<span class="nc bnc" id="L907" title="All 4 branches missed.">            if ((numChannels == 4)</span>
                &amp;&amp; (sof.componentSpecs[3].componentId == 'A')) {
<span class="nc" id="L909">                hasAlpha = true;</span>
            }
<span class="nc" id="L911">            return chroma;</span>
        }

        // Finally, 3-channel subsampled are YCbCr, unsubsampled are RGB
        // 4-channel subsampled are YCbCrA, unsubsampled are CMYK

<span class="nc" id="L917">        boolean subsampled = false;</span>

<span class="nc" id="L919">        int hfactor = sof.componentSpecs[0].HsamplingFactor;</span>
<span class="nc" id="L920">        int vfactor = sof.componentSpecs[0].VsamplingFactor;</span>

<span class="nc bnc" id="L922" title="All 2 branches missed.">        for (int i = 1; i&lt;sof.componentSpecs.length; i++) {</span>
<span class="nc bnc" id="L923" title="All 4 branches missed.">            if ((sof.componentSpecs[i].HsamplingFactor != hfactor)</span>
                || (sof.componentSpecs[i].VsamplingFactor != vfactor)){
<span class="nc" id="L925">                subsampled = true;</span>
<span class="nc" id="L926">                break;</span>
            }
        }

<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (subsampled) {</span>
<span class="nc" id="L931">            csType.setAttribute(&quot;name&quot;, &quot;YCbCr&quot;);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (numChannels == 4) {</span>
<span class="nc" id="L933">                hasAlpha = true;</span>
            }
<span class="nc" id="L935">            return chroma;</span>
        }

        // Not subsampled.  numChannels &lt; 3 is taken care of above
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (numChannels == 3) {</span>
<span class="nc" id="L940">            csType.setAttribute(&quot;name&quot;, &quot;RGB&quot;);</span>
        } else {
<span class="nc" id="L942">            csType.setAttribute(&quot;name&quot;, &quot;CMYK&quot;);</span>
        }

<span class="nc" id="L945">        return chroma;</span>
    }

    protected IIOMetadataNode getStandardCompressionNode() {

<span class="nc" id="L950">        IIOMetadataNode compression = new IIOMetadataNode(&quot;Compression&quot;);</span>

        // CompressionTypeName
<span class="nc" id="L953">        IIOMetadataNode name = new IIOMetadataNode(&quot;CompressionTypeName&quot;);</span>
<span class="nc" id="L954">        name.setAttribute(&quot;value&quot;, &quot;JPEG&quot;);</span>
<span class="nc" id="L955">        compression.appendChild(name);</span>

        // Lossless - false
<span class="nc" id="L958">        IIOMetadataNode lossless = new IIOMetadataNode(&quot;Lossless&quot;);</span>
<span class="nc" id="L959">        lossless.setAttribute(&quot;value&quot;, &quot;FALSE&quot;);</span>
<span class="nc" id="L960">        compression.appendChild(lossless);</span>

        // NumProgressiveScans - count sos segments
<span class="nc" id="L963">        int sosCount = 0;</span>
<span class="nc" id="L964">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L966">            MarkerSegment ms = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if (ms.tag == JPEG.SOS) {</span>
<span class="nc" id="L968">                sosCount++;</span>
            }
<span class="nc" id="L970">        }</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (sosCount != 0) {</span>
<span class="nc" id="L972">            IIOMetadataNode prog = new IIOMetadataNode(&quot;NumProgressiveScans&quot;);</span>
<span class="nc" id="L973">            prog.setAttribute(&quot;value&quot;, Integer.toString(sosCount));</span>
<span class="nc" id="L974">            compression.appendChild(prog);</span>
        }

<span class="nc" id="L977">        return compression;</span>
    }

    protected IIOMetadataNode getStandardDimensionNode() {
        // If we have a JFIF marker segment, we know a little
        // otherwise all we know is the orientation, which is always normal
<span class="nc" id="L983">        IIOMetadataNode dim = new IIOMetadataNode(&quot;Dimension&quot;);</span>
<span class="nc" id="L984">        IIOMetadataNode orient = new IIOMetadataNode(&quot;ImageOrientation&quot;);</span>
<span class="nc" id="L985">        orient.setAttribute(&quot;value&quot;, &quot;normal&quot;);</span>
<span class="nc" id="L986">        dim.appendChild(orient);</span>

<span class="nc" id="L988">        JFIFMarkerSegment jfif =</span>
<span class="nc" id="L989">            (JFIFMarkerSegment) findMarkerSegment(JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (jfif != null) {</span>

            // Aspect Ratio is width of pixel / height of pixel
            float aspectRatio;
<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (jfif.resUnits == 0) {</span>
                // In this case they just encode aspect ratio directly
<span class="nc" id="L996">                aspectRatio = ((float) jfif.Xdensity)/jfif.Ydensity;</span>
            } else {
                // They are true densities (e.g. dpi) and must be inverted
<span class="nc" id="L999">                aspectRatio = ((float) jfif.Ydensity)/jfif.Xdensity;</span>
            }
<span class="nc" id="L1001">            IIOMetadataNode aspect = new IIOMetadataNode(&quot;PixelAspectRatio&quot;);</span>
<span class="nc" id="L1002">            aspect.setAttribute(&quot;value&quot;, Float.toString(aspectRatio));</span>
<span class="nc" id="L1003">            dim.insertBefore(aspect, orient);</span>

            // Pixel size
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (jfif.resUnits != 0) {</span>
                // 1 == dpi, 2 == dpc
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                float scale = (jfif.resUnits == 1) ? 25.4F : 10.0F;</span>

<span class="nc" id="L1010">                IIOMetadataNode horiz =</span>
                    new IIOMetadataNode(&quot;HorizontalPixelSize&quot;);
<span class="nc" id="L1012">                horiz.setAttribute(&quot;value&quot;,</span>
<span class="nc" id="L1013">                                   Float.toString(scale/jfif.Xdensity));</span>
<span class="nc" id="L1014">                dim.appendChild(horiz);</span>

<span class="nc" id="L1016">                IIOMetadataNode vert =</span>
                    new IIOMetadataNode(&quot;VerticalPixelSize&quot;);
<span class="nc" id="L1018">                vert.setAttribute(&quot;value&quot;,</span>
<span class="nc" id="L1019">                                  Float.toString(scale/jfif.Ydensity));</span>
<span class="nc" id="L1020">                dim.appendChild(vert);</span>
            }
        }
<span class="nc" id="L1023">        return dim;</span>
    }

    protected IIOMetadataNode getStandardTextNode() {
<span class="nc" id="L1027">        IIOMetadataNode text = null;</span>
        // Add a text entry for each COM Marker Segment
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (findMarkerSegment(JPEG.COM) != null) {</span>
<span class="nc" id="L1030">            text = new IIOMetadataNode(&quot;Text&quot;);</span>
<span class="nc" id="L1031">            Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            while (iter.hasNext()) {</span>
<span class="nc" id="L1033">                MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                if (seg.tag == JPEG.COM) {</span>
<span class="nc" id="L1035">                    COMMarkerSegment com = (COMMarkerSegment) seg;</span>
<span class="nc" id="L1036">                    IIOMetadataNode entry = new IIOMetadataNode(&quot;TextEntry&quot;);</span>
<span class="nc" id="L1037">                    entry.setAttribute(&quot;keyword&quot;, &quot;comment&quot;);</span>
<span class="nc" id="L1038">                    entry.setAttribute(&quot;value&quot;, com.getComment());</span>
<span class="nc" id="L1039">                text.appendChild(entry);</span>
                }
<span class="nc" id="L1041">            }</span>
        }
<span class="nc" id="L1043">        return text;</span>
    }

    protected IIOMetadataNode getStandardTransparencyNode() {
<span class="nc" id="L1047">        IIOMetadataNode trans = null;</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        if (hasAlpha == true) {</span>
<span class="nc" id="L1049">            trans = new IIOMetadataNode(&quot;Transparency&quot;);</span>
<span class="nc" id="L1050">            IIOMetadataNode alpha = new IIOMetadataNode(&quot;Alpha&quot;);</span>
<span class="nc" id="L1051">            alpha.setAttribute(&quot;value&quot;, &quot;nonpremultiplied&quot;); // Always assume</span>
<span class="nc" id="L1052">            trans.appendChild(alpha);</span>
        }
<span class="nc" id="L1054">        return trans;</span>
    }

    // Editing

    public boolean isReadOnly() {
<span class="nc" id="L1060">        return false;</span>
    }

    public void mergeTree(String formatName, Node root)
        throws IIOInvalidTreeException {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L1066">            throw new IllegalArgumentException(&quot;null formatName!&quot;);</span>
        }
<span class="nc bnc" id="L1068" title="All 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L1069">            throw new IllegalArgumentException(&quot;null root!&quot;);</span>
        }
<span class="nc" id="L1071">        List copy = null;</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        if (resetSequence == null) {</span>
<span class="nc" id="L1073">            resetSequence = cloneSequence();  // Deep copy</span>
<span class="nc" id="L1074">            copy = resetSequence;  // Avoid cloning twice</span>
        } else {
<span class="nc" id="L1076">            copy = cloneSequence();</span>
        }
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (isStream &amp;&amp;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            (formatName.equals(JPEG.nativeStreamMetadataFormatName))) {</span>
<span class="nc" id="L1080">                mergeNativeTree(root);</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        } else if (!isStream &amp;&amp;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                   (formatName.equals(JPEG.nativeImageMetadataFormatName))) {</span>
<span class="nc" id="L1083">            mergeNativeTree(root);</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        } else if (!isStream &amp;&amp;</span>
                   (formatName.equals
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                    (IIOMetadataFormatImpl.standardMetadataFormatName))) {</span>
<span class="nc" id="L1087">            mergeStandardTree(root);</span>
        } else {
<span class="nc" id="L1089">            throw  new IllegalArgumentException(&quot;Unsupported format name: &quot;</span>
                                                + formatName);
        }
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (!isConsistent()) {</span>
<span class="nc" id="L1093">            markerSequence = copy;</span>
<span class="nc" id="L1094">            throw new IIOInvalidTreeException</span>
                (&quot;Merged tree is invalid; original restored&quot;, root);
        }
<span class="nc" id="L1097">    }</span>

    private void mergeNativeTree(Node root) throws IIOInvalidTreeException {
<span class="nc" id="L1100">        String name = root.getNodeName();</span>
<span class="nc bnc" id="L1101" title="All 4 branches missed.">        if (name != ((isStream) ? JPEG.nativeStreamMetadataFormatName</span>
                                : JPEG.nativeImageMetadataFormatName)) {
<span class="nc" id="L1103">            throw new IIOInvalidTreeException(&quot;Invalid root node name: &quot; + name,</span>
                                              root);
        }
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (root.getChildNodes().getLength() != 2) { // JPEGvariety and markerSequence</span>
<span class="nc" id="L1107">            throw new IIOInvalidTreeException(</span>
                &quot;JPEGvariety and markerSequence nodes must be present&quot;, root);
        }
<span class="nc" id="L1110">        mergeJFIFsubtree(root.getFirstChild());</span>
<span class="nc" id="L1111">        mergeSequenceSubtree(root.getLastChild());</span>
<span class="nc" id="L1112">    }</span>

    /**
     * Merge a JFIF subtree into the marker sequence, if the subtree
     * is non-empty.
     * If a JFIF marker exists, update it from the subtree.
     * If none exists, create one from the subtree and insert it at the
     * beginning of the marker sequence.
     */
    private void mergeJFIFsubtree(Node JPEGvariety)
        throws IIOInvalidTreeException {
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (JPEGvariety.getChildNodes().getLength() != 0) {</span>
<span class="nc" id="L1124">            Node jfifNode = JPEGvariety.getFirstChild();</span>
            // is there already a jfif marker segment?
<span class="nc" id="L1126">            JFIFMarkerSegment jfifSeg =</span>
<span class="nc" id="L1127">                (JFIFMarkerSegment) findMarkerSegment(JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if (jfifSeg != null) {</span>
<span class="nc" id="L1129">                jfifSeg.updateFromNativeNode(jfifNode, false);</span>
            } else {
                // Add it as the first element in the list.
<span class="nc" id="L1132">                markerSequence.add(0, new JFIFMarkerSegment(jfifNode));</span>
            }
        }
<span class="nc" id="L1135">    }</span>

    private void mergeSequenceSubtree(Node sequenceTree)
        throws IIOInvalidTreeException {
<span class="nc" id="L1139">        NodeList children = sequenceTree.getChildNodes();</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L1141">            Node node = children.item(i);</span>
<span class="nc" id="L1142">            String name = node.getNodeName();</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">            if (name.equals(&quot;dqt&quot;)) {</span>
<span class="nc" id="L1144">                mergeDQTNode(node);</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">            } else if (name.equals(&quot;dht&quot;)) {</span>
<span class="nc" id="L1146">                mergeDHTNode(node);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            } else if (name.equals(&quot;dri&quot;)) {</span>
<span class="nc" id="L1148">                mergeDRINode(node);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            } else if (name.equals(&quot;com&quot;)) {</span>
<span class="nc" id="L1150">                mergeCOMNode(node);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            } else if (name.equals(&quot;app14Adobe&quot;)) {</span>
<span class="nc" id="L1152">                mergeAdobeNode(node);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            } else if (name.equals(&quot;unknown&quot;)) {</span>
<span class="nc" id="L1154">                mergeUnknownNode(node);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">            } else if (name.equals(&quot;sof&quot;)) {</span>
<span class="nc" id="L1156">                mergeSOFNode(node);</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            } else if (name.equals(&quot;sos&quot;)) {</span>
<span class="nc" id="L1158">                mergeSOSNode(node);</span>
            } else {
<span class="nc" id="L1160">                throw new IIOInvalidTreeException(&quot;Invalid node: &quot; + name, node);</span>
            }
        }
<span class="nc" id="L1163">    }</span>

    /**
     * Merge the given DQT node into the marker sequence.  If there already
     * exist DQT marker segments in the sequence, then each table in the
     * node replaces the first table, in any DQT segment, with the same
     * table id.  If none of the existing DQT segments contain a table with
     * the same id, then the table is added to the last existing DQT segment.
     * If there are no DQT segments, then a new one is created and added
     * as follows:
     * If there are DHT segments, the new DQT segment is inserted before the
     * first one.
     * If there are no DHT segments, the new DQT segment is inserted before
     * an SOF segment, if there is one.
     * If there is no SOF segment, the new DQT segment is inserted before
     * the first SOS segment, if there is one.
     * If there is no SOS segment, the new DQT segment is added to the end
     * of the sequence.
     */
    private void mergeDQTNode(Node node) throws IIOInvalidTreeException {
        // First collect any existing DQT nodes into a local list
<span class="nc" id="L1184">        ArrayList oldDQTs = new ArrayList();</span>
<span class="nc" id="L1185">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1187">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">            if (seg instanceof DQTMarkerSegment) {</span>
<span class="nc" id="L1189">                oldDQTs.add(seg);</span>
            }
<span class="nc" id="L1191">        }</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        if (!oldDQTs.isEmpty()) {</span>
<span class="nc" id="L1193">            NodeList children = node.getChildNodes();</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">            for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L1195">                Node child = children.item(i);</span>
<span class="nc" id="L1196">                int childID = MarkerSegment.getAttributeValue(child,</span>
                                                              null,
                                                              &quot;qtableId&quot;,
                                                              0, 3,
                                                              true);
<span class="nc" id="L1201">                DQTMarkerSegment dqt = null;</span>
<span class="nc" id="L1202">                int tableIndex = -1;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                for (int j = 0; j &lt; oldDQTs.size(); j++) {</span>
<span class="nc" id="L1204">                    DQTMarkerSegment testDQT = (DQTMarkerSegment) oldDQTs.get(j);</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                    for (int k = 0; k &lt; testDQT.tables.size(); k++) {</span>
<span class="nc" id="L1206">                        DQTMarkerSegment.Qtable testTable =</span>
<span class="nc" id="L1207">                            (DQTMarkerSegment.Qtable) testDQT.tables.get(k);</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                        if (childID == testTable.tableID) {</span>
<span class="nc" id="L1209">                            dqt = testDQT;</span>
<span class="nc" id="L1210">                            tableIndex = k;</span>
<span class="nc" id="L1211">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                    if (dqt != null) break;</span>
                }
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                if (dqt != null) {</span>
<span class="nc" id="L1217">                    dqt.tables.set(tableIndex, dqt.getQtableFromNode(child));</span>
                } else {
<span class="nc" id="L1219">                    dqt = (DQTMarkerSegment) oldDQTs.get(oldDQTs.size()-1);</span>
<span class="nc" id="L1220">                    dqt.tables.add(dqt.getQtableFromNode(child));</span>
                }
            }
<span class="nc" id="L1223">        } else {</span>
<span class="nc" id="L1224">            DQTMarkerSegment newGuy = new DQTMarkerSegment(node);</span>
<span class="nc" id="L1225">            int firstDHT = findMarkerSegmentPosition(DHTMarkerSegment.class, true);</span>
<span class="nc" id="L1226">            int firstSOF = findMarkerSegmentPosition(SOFMarkerSegment.class, true);</span>
<span class="nc" id="L1227">            int firstSOS = findMarkerSegmentPosition(SOSMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">            if (firstDHT != -1) {</span>
<span class="nc" id="L1229">                markerSequence.add(firstDHT, newGuy);</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            } else if (firstSOF != -1) {</span>
<span class="nc" id="L1231">                markerSequence.add(firstSOF, newGuy);</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            } else if (firstSOS != -1) {</span>
<span class="nc" id="L1233">                markerSequence.add(firstSOS, newGuy);</span>
            } else {
<span class="nc" id="L1235">                markerSequence.add(newGuy);</span>
            }
        }
<span class="nc" id="L1238">    }</span>

    /**
     * Merge the given DHT node into the marker sequence.  If there already
     * exist DHT marker segments in the sequence, then each table in the
     * node replaces the first table, in any DHT segment, with the same
     * table class and table id.  If none of the existing DHT segments contain
     * a table with the same class and id, then the table is added to the last
     * existing DHT segment.
     * If there are no DHT segments, then a new one is created and added
     * as follows:
     * If there are DQT segments, the new DHT segment is inserted immediately
     * following the last DQT segment.
     * If there are no DQT segments, the new DHT segment is inserted before
     * an SOF segment, if there is one.
     * If there is no SOF segment, the new DHT segment is inserted before
     * the first SOS segment, if there is one.
     * If there is no SOS segment, the new DHT segment is added to the end
     * of the sequence.
     */
    private void mergeDHTNode(Node node) throws IIOInvalidTreeException {
        // First collect any existing DQT nodes into a local list
<span class="nc" id="L1260">        ArrayList oldDHTs = new ArrayList();</span>
<span class="nc" id="L1261">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1263">            MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1264" title="All 2 branches missed.">            if (seg instanceof DHTMarkerSegment) {</span>
<span class="nc" id="L1265">                oldDHTs.add(seg);</span>
            }
<span class="nc" id="L1267">        }</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (!oldDHTs.isEmpty()) {</span>
<span class="nc" id="L1269">            NodeList children = node.getChildNodes();</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">            for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L1271">                Node child = children.item(i);</span>
<span class="nc" id="L1272">                NamedNodeMap attrs = child.getAttributes();</span>
<span class="nc" id="L1273">                int childID = MarkerSegment.getAttributeValue(child,</span>
                                                              attrs,
                                                              &quot;htableId&quot;,
                                                              0, 3,
                                                              true);
<span class="nc" id="L1278">                int childClass = MarkerSegment.getAttributeValue(child,</span>
                                                                 attrs,
                                                                 &quot;class&quot;,
                                                                 0, 1,
                                                                 true);
<span class="nc" id="L1283">                DHTMarkerSegment dht = null;</span>
<span class="nc" id="L1284">                int tableIndex = -1;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                for (int j = 0; j &lt; oldDHTs.size(); j++) {</span>
<span class="nc" id="L1286">                    DHTMarkerSegment testDHT = (DHTMarkerSegment) oldDHTs.get(j);</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">                    for (int k = 0; k &lt; testDHT.tables.size(); k++) {</span>
<span class="nc" id="L1288">                        DHTMarkerSegment.Htable testTable =</span>
<span class="nc" id="L1289">                            (DHTMarkerSegment.Htable) testDHT.tables.get(k);</span>
<span class="nc bnc" id="L1290" title="All 4 branches missed.">                        if ((childID == testTable.tableID) &amp;&amp;</span>
                            (childClass == testTable.tableClass)) {
<span class="nc" id="L1292">                            dht = testDHT;</span>
<span class="nc" id="L1293">                            tableIndex = k;</span>
<span class="nc" id="L1294">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                    if (dht != null) break;</span>
                }
<span class="nc bnc" id="L1299" title="All 2 branches missed.">                if (dht != null) {</span>
<span class="nc" id="L1300">                    dht.tables.set(tableIndex, dht.getHtableFromNode(child));</span>
                } else {
<span class="nc" id="L1302">                    dht = (DHTMarkerSegment) oldDHTs.get(oldDHTs.size()-1);</span>
<span class="nc" id="L1303">                    dht.tables.add(dht.getHtableFromNode(child));</span>
                }
            }
<span class="nc" id="L1306">        } else {</span>
<span class="nc" id="L1307">            DHTMarkerSegment newGuy = new DHTMarkerSegment(node);</span>
<span class="nc" id="L1308">            int lastDQT = findMarkerSegmentPosition(DQTMarkerSegment.class, false);</span>
<span class="nc" id="L1309">            int firstSOF = findMarkerSegmentPosition(SOFMarkerSegment.class, true);</span>
<span class="nc" id="L1310">            int firstSOS = findMarkerSegmentPosition(SOSMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if (lastDQT != -1) {</span>
<span class="nc" id="L1312">                markerSequence.add(lastDQT+1, newGuy);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">            } else if (firstSOF != -1) {</span>
<span class="nc" id="L1314">                markerSequence.add(firstSOF, newGuy);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">            } else if (firstSOS != -1) {</span>
<span class="nc" id="L1316">                markerSequence.add(firstSOS, newGuy);</span>
            } else {
<span class="nc" id="L1318">                markerSequence.add(newGuy);</span>
            }
        }
<span class="nc" id="L1321">    }</span>

    /**
     * Merge the given DRI node into the marker sequence.
     * If there already exists a DRI marker segment, the restart interval
     * value is updated.
     * If there is no DRI segment, then a new one is created and added as
     * follows:
     * If there is an SOF segment, the new DRI segment is inserted before
     * it.
     * If there is no SOF segment, the new DRI segment is inserted before
     * the first SOS segment, if there is one.
     * If there is no SOS segment, the new DRI segment is added to the end
     * of the sequence.
     */
    private void mergeDRINode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1337">        DRIMarkerSegment dri =</span>
<span class="nc" id="L1338">            (DRIMarkerSegment) findMarkerSegment(DRIMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">        if (dri != null) {</span>
<span class="nc" id="L1340">            dri.updateFromNativeNode(node, false);</span>
        } else {
<span class="nc" id="L1342">            DRIMarkerSegment newGuy = new DRIMarkerSegment(node);</span>
<span class="nc" id="L1343">            int firstSOF = findMarkerSegmentPosition(SOFMarkerSegment.class, true);</span>
<span class="nc" id="L1344">            int firstSOS = findMarkerSegmentPosition(SOSMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">            if (firstSOF != -1) {</span>
<span class="nc" id="L1346">                markerSequence.add(firstSOF, newGuy);</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            } else if (firstSOS != -1) {</span>
<span class="nc" id="L1348">                markerSequence.add(firstSOS, newGuy);</span>
            } else {
<span class="nc" id="L1350">                markerSequence.add(newGuy);</span>
            }
        }
<span class="nc" id="L1353">    }</span>

    /**
     * Merge the given COM node into the marker sequence.
     * A new COM marker segment is created and added to the sequence
     * using insertCOMMarkerSegment.
     */
    private void mergeCOMNode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1361">        COMMarkerSegment newGuy = new COMMarkerSegment(node);</span>
<span class="nc" id="L1362">        insertCOMMarkerSegment(newGuy);</span>
<span class="nc" id="L1363">    }</span>

     /**
      * Insert a new COM marker segment into an appropriate place in the
      * marker sequence, as follows:
      * If there already exist COM marker segments, the new one is inserted
      * after the last one.
      * If there are no COM segments, the new COM segment is inserted after the
      * JFIF segment, if there is one.
      * If there is no JFIF segment, the new COM segment is inserted after the
      * Adobe marker segment, if there is one.
      * If there is no Adobe segment, the new COM segment is inserted
      * at the beginning of the sequence.
      */
    private void insertCOMMarkerSegment(COMMarkerSegment newGuy) {
<span class="nc" id="L1378">        int lastCOM = findMarkerSegmentPosition(COMMarkerSegment.class, false);</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">        boolean hasJFIF = (findMarkerSegment(JFIFMarkerSegment.class, true) != null);</span>
<span class="nc" id="L1380">        int firstAdobe = findMarkerSegmentPosition(AdobeMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">        if (lastCOM != -1) {</span>
<span class="nc" id="L1382">            markerSequence.add(lastCOM+1, newGuy);</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        } else if (hasJFIF) {</span>
<span class="nc" id="L1384">            markerSequence.add(1, newGuy);  // JFIF is always 0</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        } else if (firstAdobe != -1) {</span>
<span class="nc" id="L1386">            markerSequence.add(firstAdobe+1, newGuy);</span>
        } else {
<span class="nc" id="L1388">            markerSequence.add(0, newGuy);</span>
        }
<span class="nc" id="L1390">    }</span>

    /**
     * Merge the given Adobe APP14 node into the marker sequence.
     * If there already exists an Adobe marker segment, then its attributes
     * are updated from the node.
     * If there is no Adobe segment, then a new one is created and added
     * using insertAdobeMarkerSegment.
     */
    private void mergeAdobeNode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1400">        AdobeMarkerSegment adobe =</span>
<span class="nc" id="L1401">            (AdobeMarkerSegment) findMarkerSegment(AdobeMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if (adobe != null) {</span>
<span class="nc" id="L1403">            adobe.updateFromNativeNode(node, false);</span>
        } else {
<span class="nc" id="L1405">            AdobeMarkerSegment newGuy = new AdobeMarkerSegment(node);</span>
<span class="nc" id="L1406">            insertAdobeMarkerSegment(newGuy);</span>
        }
<span class="nc" id="L1408">    }</span>

    /**
     * Insert the given AdobeMarkerSegment into the marker sequence, as
     * follows (we assume there is no Adobe segment yet):
     * If there is a JFIF segment, then the new Adobe segment is inserted
     * after it.
     * If there is no JFIF segment, the new Adobe segment is inserted after the
     * last Unknown segment, if there are any.
     * If there are no Unknown segments, the new Adobe segment is inserted
     * at the beginning of the sequence.
     */
    private void insertAdobeMarkerSegment(AdobeMarkerSegment newGuy) {
<span class="nc" id="L1421">        boolean hasJFIF =</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">            (findMarkerSegment(JFIFMarkerSegment.class, true) != null);</span>
<span class="nc" id="L1423">        int lastUnknown = findLastUnknownMarkerSegmentPosition();</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">        if (hasJFIF) {</span>
<span class="nc" id="L1425">            markerSequence.add(1, newGuy);  // JFIF is always 0</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">        } else if (lastUnknown != -1) {</span>
<span class="nc" id="L1427">            markerSequence.add(lastUnknown+1, newGuy);</span>
        } else {
<span class="nc" id="L1429">            markerSequence.add(0, newGuy);</span>
        }
<span class="nc" id="L1431">    }</span>

    /**
     * Merge the given Unknown node into the marker sequence.
     * A new Unknown marker segment is created and added to the sequence as
     * follows:
     * If there already exist Unknown marker segments, the new one is inserted
     * after the last one.
     * If there are no Unknown marker segments, the new Unknown marker segment
     * is inserted after the JFIF segment, if there is one.
     * If there is no JFIF segment, the new Unknown segment is inserted before
     * the Adobe marker segment, if there is one.
     * If there is no Adobe segment, the new Unknown segment is inserted
     * at the beginning of the sequence.
     */
    private void mergeUnknownNode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1447">        MarkerSegment newGuy = new MarkerSegment(node);</span>
<span class="nc" id="L1448">        int lastUnknown = findLastUnknownMarkerSegmentPosition();</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        boolean hasJFIF = (findMarkerSegment(JFIFMarkerSegment.class, true) != null);</span>
<span class="nc" id="L1450">        int firstAdobe = findMarkerSegmentPosition(AdobeMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        if (lastUnknown != -1) {</span>
<span class="nc" id="L1452">            markerSequence.add(lastUnknown+1, newGuy);</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        } else if (hasJFIF) {</span>
<span class="nc" id="L1454">            markerSequence.add(1, newGuy);  // JFIF is always 0</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">        } if (firstAdobe != -1) {</span>
<span class="nc" id="L1456">            markerSequence.add(firstAdobe, newGuy);</span>
        } else {
<span class="nc" id="L1458">            markerSequence.add(0, newGuy);</span>
        }
<span class="nc" id="L1460">    }</span>

    /**
     * Merge the given SOF node into the marker sequence.
     * If there already exists an SOF marker segment in the sequence, then
     * its values are updated from the node.
     * If there is no SOF segment, then a new one is created and added as
     * follows:
     * If there are any SOS segments, the new SOF segment is inserted before
     * the first one.
     * If there is no SOS segment, the new SOF segment is added to the end
     * of the sequence.
     *
     */
    private void mergeSOFNode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1475">        SOFMarkerSegment sof =</span>
<span class="nc" id="L1476">            (SOFMarkerSegment) findMarkerSegment(SOFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if (sof != null) {</span>
<span class="nc" id="L1478">            sof.updateFromNativeNode(node, false);</span>
        } else {
<span class="nc" id="L1480">            SOFMarkerSegment newGuy = new SOFMarkerSegment(node);</span>
<span class="nc" id="L1481">            int firstSOS = findMarkerSegmentPosition(SOSMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (firstSOS != -1) {</span>
<span class="nc" id="L1483">                markerSequence.add(firstSOS, newGuy);</span>
            } else {
<span class="nc" id="L1485">                markerSequence.add(newGuy);</span>
            }
        }
<span class="nc" id="L1488">    }</span>

    /**
     * Merge the given SOS node into the marker sequence.
     * If there already exists a single SOS marker segment, then the values
     * are updated from the node.
     * If there are more than one existing SOS marker segments, then an
     * IIOInvalidTreeException is thrown, as SOS segments cannot be merged
     * into a set of progressive scans.
     * If there are no SOS marker segments, a new one is created and added
     * to the end of the sequence.
     */
    private void mergeSOSNode(Node node) throws IIOInvalidTreeException {
<span class="nc" id="L1501">        SOSMarkerSegment firstSOS =</span>
<span class="nc" id="L1502">            (SOSMarkerSegment) findMarkerSegment(SOSMarkerSegment.class, true);</span>
<span class="nc" id="L1503">        SOSMarkerSegment lastSOS =</span>
<span class="nc" id="L1504">            (SOSMarkerSegment) findMarkerSegment(SOSMarkerSegment.class, false);</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">        if (firstSOS != null) {</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (firstSOS != lastSOS) {</span>
<span class="nc" id="L1507">                throw new IIOInvalidTreeException</span>
                    (&quot;Can't merge SOS node into a tree with &gt; 1 SOS node&quot;, node);
            }
<span class="nc" id="L1510">            firstSOS.updateFromNativeNode(node, false);</span>
        } else {
<span class="nc" id="L1512">            markerSequence.add(new SOSMarkerSegment(node));</span>
        }
<span class="nc" id="L1514">    }</span>

    private boolean transparencyDone;

    private void mergeStandardTree(Node root) throws IIOInvalidTreeException {
<span class="nc" id="L1519">        transparencyDone = false;</span>
<span class="nc" id="L1520">        NodeList children = root.getChildNodes();</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L1522">            Node node = children.item(i);</span>
<span class="nc" id="L1523">            String name = node.getNodeName();</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">            if (name.equals(&quot;Chroma&quot;)) {</span>
<span class="nc" id="L1525">                mergeStandardChromaNode(node, children);</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">            } else if (name.equals(&quot;Compression&quot;)) {</span>
<span class="nc" id="L1527">                mergeStandardCompressionNode(node);</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">            } else if (name.equals(&quot;Data&quot;)) {</span>
<span class="nc" id="L1529">                mergeStandardDataNode(node);</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">            } else if (name.equals(&quot;Dimension&quot;)) {</span>
<span class="nc" id="L1531">                mergeStandardDimensionNode(node);</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            } else if (name.equals(&quot;Document&quot;)) {</span>
<span class="nc" id="L1533">                mergeStandardDocumentNode(node);</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">            } else if (name.equals(&quot;Text&quot;)) {</span>
<span class="nc" id="L1535">                mergeStandardTextNode(node);</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">            } else if (name.equals(&quot;Transparency&quot;)) {</span>
<span class="nc" id="L1537">                mergeStandardTransparencyNode(node);</span>
            } else {
<span class="nc" id="L1539">                throw new IIOInvalidTreeException(&quot;Invalid node: &quot; + name, node);</span>
            }
        }
<span class="nc" id="L1542">    }</span>

    /*
     * In general, it could be possible to convert all non-pixel data to some
     * textual form and include it in comments, but then this would create the
     * expectation that these comment forms be recognized by the reader, thus
     * creating a defacto extension to JPEG metadata capabilities.  This is
     * probably best avoided, so the following convert only text nodes to
     * comments, and lose the keywords as well.
     */

    private void mergeStandardChromaNode(Node node, NodeList siblings)
        throws IIOInvalidTreeException {
        // ColorSpaceType can change the target colorspace for compression
        // This must take any transparency node into account as well, as
        // that affects the number of channels (if alpha is present).  If
        // a transparency node is dealt with here, set a flag to indicate
        // this to the transparency processor below.  If we discover that
        // the nodes are not in order, throw an exception as the tree is
        // invalid.

<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (transparencyDone) {</span>
<span class="nc" id="L1564">            throw new IIOInvalidTreeException</span>
                (&quot;Transparency node must follow Chroma node&quot;, node);
        }

<span class="nc" id="L1568">        Node csType = node.getFirstChild();</span>
<span class="nc bnc" id="L1569" title="All 4 branches missed.">        if ((csType == null) || !csType.getNodeName().equals(&quot;ColorSpaceType&quot;)) {</span>
            // If there is no ColorSpaceType node, we have nothing to do
<span class="nc" id="L1571">            return;</span>
        }

<span class="nc" id="L1574">        String csName = csType.getAttributes().getNamedItem(&quot;name&quot;).getNodeValue();</span>

<span class="nc" id="L1576">        int numChannels = 0;</span>
<span class="nc" id="L1577">        boolean wantJFIF = false;</span>
<span class="nc" id="L1578">        boolean wantAdobe = false;</span>
<span class="nc" id="L1579">        int transform = 0;</span>
<span class="nc" id="L1580">        boolean willSubsample = false;</span>
<span class="nc" id="L1581">        byte [] ids = {1, 2, 3, 4};  // JFIF compatible</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">        if (csName.equals(&quot;GRAY&quot;)) {</span>
<span class="nc" id="L1583">            numChannels = 1;</span>
<span class="nc" id="L1584">            wantJFIF = true;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">        } else if (csName.equals(&quot;YCbCr&quot;)) {</span>
<span class="nc" id="L1586">            numChannels = 3;</span>
<span class="nc" id="L1587">            wantJFIF = true;</span>
<span class="nc" id="L1588">            willSubsample = true;</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        } else if (csName.equals(&quot;PhotoYCC&quot;)) {</span>
<span class="nc" id="L1590">            numChannels = 3;</span>
<span class="nc" id="L1591">            wantAdobe = true;</span>
<span class="nc" id="L1592">            transform = JPEG.ADOBE_YCC;</span>
<span class="nc" id="L1593">            ids[0] = (byte) 'Y';</span>
<span class="nc" id="L1594">            ids[1] = (byte) 'C';</span>
<span class="nc" id="L1595">            ids[2] = (byte) 'c';</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">        } else if (csName.equals(&quot;RGB&quot;)) {</span>
<span class="nc" id="L1597">            numChannels = 3;</span>
<span class="nc" id="L1598">            wantAdobe = true;</span>
<span class="nc" id="L1599">            transform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc" id="L1600">            ids[0] = (byte) 'R';</span>
<span class="nc" id="L1601">            ids[1] = (byte) 'G';</span>
<span class="nc" id="L1602">            ids[2] = (byte) 'B';</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        } else if ((csName.equals(&quot;XYZ&quot;))</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                   || (csName.equals(&quot;Lab&quot;))</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                   || (csName.equals(&quot;Luv&quot;))</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                   || (csName.equals(&quot;YxY&quot;))</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">                   || (csName.equals(&quot;HSV&quot;))</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                   || (csName.equals(&quot;HLS&quot;))</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                   || (csName.equals(&quot;CMY&quot;))</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                   || (csName.equals(&quot;3CLR&quot;))) {</span>
<span class="nc" id="L1611">            numChannels = 3;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        } else if (csName.equals(&quot;YCCK&quot;)) {</span>
<span class="nc" id="L1613">            numChannels = 4;</span>
<span class="nc" id="L1614">            wantAdobe = true;</span>
<span class="nc" id="L1615">            transform = JPEG.ADOBE_YCCK;</span>
<span class="nc" id="L1616">            willSubsample = true;</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">        } else if (csName.equals(&quot;CMYK&quot;)) {</span>
<span class="nc" id="L1618">            numChannels = 4;</span>
<span class="nc" id="L1619">            wantAdobe = true;</span>
<span class="nc" id="L1620">            transform = JPEG.ADOBE_UNKNOWN;</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">        } else if (csName.equals(&quot;4CLR&quot;)) {</span>
<span class="nc" id="L1622">            numChannels = 4;</span>
        } else { // We can't handle them, so don't modify any metadata
<span class="nc" id="L1624">            return;</span>
        }

<span class="nc" id="L1627">        boolean wantAlpha = false;</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        for (int i = 0; i &lt; siblings.getLength(); i++) {</span>
<span class="nc" id="L1629">            Node trans = siblings.item(i);</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">            if (trans.getNodeName().equals(&quot;Transparency&quot;)) {</span>
<span class="nc" id="L1631">                wantAlpha = wantAlpha(trans);</span>
<span class="nc" id="L1632">                break;  // out of for</span>
            }
        }

<span class="nc bnc" id="L1636" title="All 2 branches missed.">        if (wantAlpha) {</span>
<span class="nc" id="L1637">            numChannels++;</span>
<span class="nc" id="L1638">            wantJFIF = false;</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">            if (ids[0] == (byte) 'R') {</span>
<span class="nc" id="L1640">                ids[3] = (byte) 'A';</span>
<span class="nc" id="L1641">                wantAdobe = false;</span>
            }
        }

<span class="nc" id="L1645">        JFIFMarkerSegment jfif =</span>
<span class="nc" id="L1646">            (JFIFMarkerSegment) findMarkerSegment(JFIFMarkerSegment.class, true);</span>
<span class="nc" id="L1647">        AdobeMarkerSegment adobe =</span>
<span class="nc" id="L1648">            (AdobeMarkerSegment) findMarkerSegment(AdobeMarkerSegment.class, true);</span>
<span class="nc" id="L1649">        SOFMarkerSegment sof =</span>
<span class="nc" id="L1650">            (SOFMarkerSegment) findMarkerSegment(SOFMarkerSegment.class, true);</span>
<span class="nc" id="L1651">        SOSMarkerSegment sos =</span>
<span class="nc" id="L1652">            (SOSMarkerSegment) findMarkerSegment(SOSMarkerSegment.class, true);</span>

        // If the metadata specifies progressive, then the number of channels
        // must match, so that we can modify all the existing SOS marker segments.
        // If they don't match, we don't know what to do with SOS so we can't do
        // the merge.  We then just return silently.
        // An exception would not be appropriate.  A warning might, but we have
        // nowhere to send it to.
<span class="nc bnc" id="L1660" title="All 4 branches missed.">        if ((sof != null) &amp;&amp; (sof.tag == JPEG.SOF2)) { // Progressive</span>
<span class="nc bnc" id="L1661" title="All 4 branches missed.">            if ((sof.componentSpecs.length != numChannels) &amp;&amp; (sos != null)) {</span>
<span class="nc" id="L1662">                return;</span>
            }
        }

        // JFIF header might be removed
<span class="nc bnc" id="L1667" title="All 4 branches missed.">        if (!wantJFIF &amp;&amp; (jfif != null)) {</span>
<span class="nc" id="L1668">            markerSequence.remove(jfif);</span>
        }

        // Now add a JFIF if we do want one, but only if it isn't stream metadata
<span class="nc bnc" id="L1672" title="All 4 branches missed.">        if (wantJFIF &amp;&amp; !isStream) {</span>
<span class="nc" id="L1673">            markerSequence.add(0, new JFIFMarkerSegment());</span>
        }

        // Adobe header might be removed or the transform modified, if it isn't
        // stream metadata
<span class="nc bnc" id="L1678" title="All 2 branches missed.">        if (wantAdobe) {</span>
<span class="nc bnc" id="L1679" title="All 4 branches missed.">            if ((adobe == null) &amp;&amp; !isStream) {</span>
<span class="nc" id="L1680">                adobe = new AdobeMarkerSegment(transform);</span>
<span class="nc" id="L1681">                insertAdobeMarkerSegment(adobe);</span>
            } else {
<span class="nc" id="L1683">                adobe.transform = transform;</span>
            }
<span class="nc bnc" id="L1685" title="All 2 branches missed.">        } else if (adobe != null) {</span>
<span class="nc" id="L1686">            markerSequence.remove(adobe);</span>
        }

<span class="nc" id="L1689">        boolean updateQtables = false;</span>
<span class="nc" id="L1690">        boolean updateHtables = false;</span>

<span class="nc" id="L1692">        boolean progressive = false;</span>

<span class="nc" id="L1694">        int [] subsampledSelectors = {0, 1, 1, 0 } ;</span>
<span class="nc" id="L1695">        int [] nonSubsampledSelectors = { 0, 0, 0, 0};</span>

<span class="nc bnc" id="L1697" title="All 2 branches missed.">        int [] newTableSelectors = willSubsample</span>
                                   ? subsampledSelectors
                                   : nonSubsampledSelectors;

        // Keep the old componentSpecs array
<span class="nc" id="L1702">        SOFMarkerSegment.ComponentSpec [] oldCompSpecs = null;</span>
        // SOF might be modified
<span class="nc bnc" id="L1704" title="All 2 branches missed.">        if (sof != null) {</span>
<span class="nc" id="L1705">            oldCompSpecs = sof.componentSpecs;</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">            progressive = (sof.tag == JPEG.SOF2);</span>
            // Now replace the SOF with a new one; it might be the same, but
            // this is easier.
<span class="nc" id="L1709">            markerSequence.set(markerSequence.indexOf(sof),</span>
                               new SOFMarkerSegment(progressive,
                                                    false, // we never need extended
                                                    willSubsample,
                                                    ids,
                                                    numChannels));

            // Now suss out if subsampling changed and set the boolean for
            // updating the q tables
            // if the old componentSpec q table selectors don't match
            // the new ones, update the qtables.  The new selectors are already
            // in place in the new SOF segment above.
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            for (int i = 0; i &lt; oldCompSpecs.length; i++) {</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">                if (oldCompSpecs[i].QtableSelector != newTableSelectors[i]) {</span>
<span class="nc" id="L1723">                    updateQtables = true;</span>
                }
            }

<span class="nc bnc" id="L1727" title="All 2 branches missed.">            if (progressive) {</span>
                // if the component ids are different, update all the existing scans
                // ignore Huffman tables
<span class="nc" id="L1730">                boolean idsDiffer = false;</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                for (int i = 0; i &lt; oldCompSpecs.length; i++) {</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">                    if (ids[i] != oldCompSpecs[i].componentId) {</span>
<span class="nc" id="L1733">                        idsDiffer = true;</span>
                    }
                }
<span class="nc bnc" id="L1736" title="All 2 branches missed.">                if (idsDiffer) {</span>
                    // update the ids in each SOS marker segment
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                    for (Iterator iter = markerSequence.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1739">                        MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                        if (seg instanceof SOSMarkerSegment) {</span>
<span class="nc" id="L1741">                            SOSMarkerSegment target = (SOSMarkerSegment) seg;</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">                            for (int i = 0; i &lt; target.componentSpecs.length; i++) {</span>
<span class="nc" id="L1743">                                int oldSelector =</span>
                                    target.componentSpecs[i].componentSelector;
                                // Find the position in the old componentSpecs array
                                // of the old component with the old selector
                                // and replace the component selector with the
                                // new id at the same position, as these match
                                // the new component specs array in the SOF created
                                // above.
<span class="nc bnc" id="L1751" title="All 2 branches missed.">                                for (int j = 0; j &lt; oldCompSpecs.length; j++) {</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                                    if (oldCompSpecs[j].componentId == oldSelector) {</span>
<span class="nc" id="L1753">                                        target.componentSpecs[i].componentSelector =</span>
                                            ids[j];
                                    }
                                }
                            }
                        }
<span class="nc" id="L1759">                    }</span>
                }
<span class="nc" id="L1761">            } else {</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                if (sos != null) {</span>
                    // htables - if the old htable selectors don't match the new ones,
                    // update the tables.
<span class="nc bnc" id="L1765" title="All 2 branches missed.">                    for (int i = 0; i &lt; sos.componentSpecs.length; i++) {</span>
<span class="nc bnc" id="L1766" title="All 4 branches missed.">                        if ((sos.componentSpecs[i].dcHuffTable</span>
                             != newTableSelectors[i])
                            || (sos.componentSpecs[i].acHuffTable
                                != newTableSelectors[i])) {
<span class="nc" id="L1770">                            updateHtables = true;</span>
                        }
                    }

                    // Might be the same as the old one, but this is easier.
<span class="nc" id="L1775">                    markerSequence.set(markerSequence.indexOf(sos),</span>
                               new SOSMarkerSegment(willSubsample,
                                                    ids,
                                                    numChannels));
                }
            }
        } else {
            // should be stream metadata if there isn't an SOF, but check it anyway
<span class="nc bnc" id="L1783" title="All 2 branches missed.">            if (isStream) {</span>
                // update tables - routines below check if it's really necessary
<span class="nc" id="L1785">                updateQtables = true;</span>
<span class="nc" id="L1786">                updateHtables = true;</span>
            }
        }

<span class="nc bnc" id="L1790" title="All 2 branches missed.">        if (updateQtables) {</span>
<span class="nc" id="L1791">            List tableSegments = new ArrayList();</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">            for (Iterator iter = markerSequence.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1793">                MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if (seg instanceof DQTMarkerSegment) {</span>
<span class="nc" id="L1795">                    tableSegments.add(seg);</span>
                }
<span class="nc" id="L1797">            }</span>
            // If there are no tables, don't add them, as the metadata encodes an
            // abbreviated stream.
            // If we are not subsampling, we just need one, so don't do anything
<span class="nc bnc" id="L1801" title="All 4 branches missed.">            if (!tableSegments.isEmpty() &amp;&amp; willSubsample) {</span>
                // Is it really necessary?  There should be at least 2 tables.
                // If there is only one, assume it's a scaled &quot;standard&quot;
                // luminance table, extract the scaling factor, and generate a
                // scaled &quot;standard&quot; chrominance table.

                // Find the table with selector 1.
<span class="nc" id="L1808">                boolean found = false;</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                for (Iterator iter = tableSegments.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1810">                    DQTMarkerSegment testdqt = (DQTMarkerSegment) iter.next();</span>
<span class="nc" id="L1811">                    for (Iterator tabiter = testdqt.tables.iterator();</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">                         tabiter.hasNext();) {</span>
<span class="nc" id="L1813">                        DQTMarkerSegment.Qtable tab =</span>
<span class="nc" id="L1814">                            (DQTMarkerSegment.Qtable) tabiter.next();</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">                        if (tab.tableID == 1) {</span>
<span class="nc" id="L1816">                            found = true;</span>
                        }
<span class="nc" id="L1818">                    }</span>
<span class="nc" id="L1819">                }</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                if (!found) {</span>
                    //    find the table with selector 0.  There should be one.
<span class="nc" id="L1822">                    DQTMarkerSegment.Qtable table0 = null;</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                    for (Iterator iter = tableSegments.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1824">                        DQTMarkerSegment testdqt = (DQTMarkerSegment) iter.next();</span>
<span class="nc" id="L1825">                        for (Iterator tabiter = testdqt.tables.iterator();</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">                             tabiter.hasNext();) {</span>
<span class="nc" id="L1827">                            DQTMarkerSegment.Qtable tab =</span>
<span class="nc" id="L1828">                                (DQTMarkerSegment.Qtable) tabiter.next();</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">                            if (tab.tableID == 0) {</span>
<span class="nc" id="L1830">                                table0 = tab;</span>
                            }
<span class="nc" id="L1832">                        }</span>
<span class="nc" id="L1833">                    }</span>

                    // Assuming that the table with id 0 is a luminance table,
                    // compute a new chrominance table of the same quality and
                    // add it to the last DQT segment
<span class="nc" id="L1838">                    DQTMarkerSegment dqt =</span>
<span class="nc" id="L1839">                        (DQTMarkerSegment) tableSegments.get(tableSegments.size()-1);</span>
<span class="nc" id="L1840">                    dqt.tables.add(dqt.getChromaForLuma(table0));</span>
                }
            }
        }

<span class="nc bnc" id="L1845" title="All 2 branches missed.">        if (updateHtables) {</span>
<span class="nc" id="L1846">            List tableSegments = new ArrayList();</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            for (Iterator iter = markerSequence.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1848">                MarkerSegment seg = (MarkerSegment) iter.next();</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">                if (seg instanceof DHTMarkerSegment) {</span>
<span class="nc" id="L1850">                    tableSegments.add(seg);</span>
                }
<span class="nc" id="L1852">            }</span>
            // If there are no tables, don't add them, as the metadata encodes an
            // abbreviated stream.
            // If we are not subsampling, we just need one, so don't do anything
<span class="nc bnc" id="L1856" title="All 4 branches missed.">            if (!tableSegments.isEmpty() &amp;&amp; willSubsample) {</span>
                // Is it really necessary?  There should be at least 2 dc and 2 ac
                // tables.  If there is only one, add a
                // &quot;standard &quot; chrominance table.

                // find a table with selector 1. AC/DC is irrelevant
<span class="nc" id="L1862">                boolean found = false;</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">                for (Iterator iter = tableSegments.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1864">                    DHTMarkerSegment testdht = (DHTMarkerSegment) iter.next();</span>
<span class="nc" id="L1865">                    for (Iterator tabiter = testdht.tables.iterator();</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">                         tabiter.hasNext();) {</span>
<span class="nc" id="L1867">                        DHTMarkerSegment.Htable tab =</span>
<span class="nc" id="L1868">                            (DHTMarkerSegment.Htable) tabiter.next();</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">                        if (tab.tableID == 1) {</span>
<span class="nc" id="L1870">                            found = true;</span>
                        }
<span class="nc" id="L1872">                    }</span>
<span class="nc" id="L1873">                }</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">                if (!found) {</span>
                    // Create new standard dc and ac chrominance tables and add them
                    // to the last DHT segment
<span class="nc" id="L1877">                    DHTMarkerSegment lastDHT =</span>
<span class="nc" id="L1878">                        (DHTMarkerSegment) tableSegments.get(tableSegments.size()-1);</span>
<span class="nc" id="L1879">                    lastDHT.addHtable(JPEGHuffmanTable.StdDCLuminance, true, 1);</span>
<span class="nc" id="L1880">                    lastDHT.addHtable(JPEGHuffmanTable.StdACLuminance, true, 1);</span>
                }
            }
        }
<span class="nc" id="L1884">    }</span>

    private boolean wantAlpha(Node transparency) {
<span class="nc" id="L1887">        boolean returnValue = false;</span>
<span class="nc" id="L1888">        Node alpha = transparency.getFirstChild();  // Alpha must be first if present</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">        if (alpha.getNodeName().equals(&quot;Alpha&quot;)) {</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">            if (alpha.hasAttributes()) {</span>
<span class="nc" id="L1891">                String value =</span>
<span class="nc" id="L1892">                    alpha.getAttributes().getNamedItem(&quot;value&quot;).getNodeValue();</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                if (!value.equals(&quot;none&quot;)) {</span>
<span class="nc" id="L1894">                    returnValue = true;</span>
                }
            }
        }
<span class="nc" id="L1898">        transparencyDone = true;</span>
<span class="nc" id="L1899">        return returnValue;</span>
    }

    private void mergeStandardCompressionNode(Node node)
        throws IIOInvalidTreeException {
        // NumProgressiveScans is ignored.  Progression must be enabled on the
        // ImageWriteParam.
        // No-op
<span class="nc" id="L1907">    }</span>

    private void mergeStandardDataNode(Node node)
        throws IIOInvalidTreeException {
        // No-op
<span class="nc" id="L1912">    }</span>

    private void mergeStandardDimensionNode(Node node)
        throws IIOInvalidTreeException {
        // Pixel Aspect Ratio or pixel size can be incorporated if there is,
        // or can be, a JFIF segment
<span class="nc" id="L1918">        JFIFMarkerSegment jfif =</span>
<span class="nc" id="L1919">            (JFIFMarkerSegment) findMarkerSegment(JFIFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1920" title="All 2 branches missed.">        if (jfif == null) {</span>
            // Can there be one?
            // Criteria:
            // SOF must be present with 1 or 3 channels, (stream metadata fails this)
            //     Component ids must be JFIF compatible.
<span class="nc" id="L1925">            boolean canHaveJFIF = false;</span>
<span class="nc" id="L1926">            SOFMarkerSegment sof =</span>
<span class="nc" id="L1927">                (SOFMarkerSegment) findMarkerSegment(SOFMarkerSegment.class, true);</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">            if (sof != null) {</span>
<span class="nc" id="L1929">                int numChannels = sof.componentSpecs.length;</span>
<span class="nc bnc" id="L1930" title="All 4 branches missed.">                if ((numChannels == 1) || (numChannels == 3)) {</span>
<span class="nc" id="L1931">                    canHaveJFIF = true; // remaining tests are negative</span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">                    for (int i = 0; i &lt; sof.componentSpecs.length; i++) {</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">                        if (sof.componentSpecs[i].componentId != i+1)</span>
<span class="nc" id="L1934">                            canHaveJFIF = false;</span>
                    }
                    // if Adobe present, transform = ADOBE_UNKNOWN for 1-channel,
                    //     ADOBE_YCC for 3-channel.
<span class="nc" id="L1938">                    AdobeMarkerSegment adobe =</span>
<span class="nc" id="L1939">                        (AdobeMarkerSegment) findMarkerSegment(AdobeMarkerSegment.class,</span>
                                                               true);
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                    if (adobe != null) {</span>
<span class="nc bnc" id="L1942" title="All 4 branches missed.">                        if (adobe.transform != ((numChannels == 1)</span>
                                                ? JPEG.ADOBE_UNKNOWN
                                                : JPEG.ADOBE_YCC)) {
<span class="nc" id="L1945">                            canHaveJFIF = false;</span>
                        }
                    }
                }
            }
            // If so, create one and insert it into the sequence.  Note that
            // default is just pixel ratio at 1:1
<span class="nc bnc" id="L1952" title="All 2 branches missed.">            if (canHaveJFIF) {</span>
<span class="nc" id="L1953">                jfif = new JFIFMarkerSegment();</span>
<span class="nc" id="L1954">                markerSequence.add(0, jfif);</span>
            }
        }
<span class="nc bnc" id="L1957" title="All 2 branches missed.">        if (jfif != null) {</span>
<span class="nc" id="L1958">            NodeList children = node.getChildNodes();</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">            for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L1960">                Node child = children.item(i);</span>
<span class="nc" id="L1961">                NamedNodeMap attrs = child.getAttributes();</span>
<span class="nc" id="L1962">                String name = child.getNodeName();</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                if (name.equals(&quot;PixelAspectRatio&quot;)) {</span>
<span class="nc" id="L1964">                    String valueString = attrs.getNamedItem(&quot;value&quot;).getNodeValue();</span>
<span class="nc" id="L1965">                    float value = Float.parseFloat(valueString);</span>
<span class="nc" id="L1966">                    Point p = findIntegerRatio(value);</span>
<span class="nc" id="L1967">                    jfif.resUnits = JPEG.DENSITY_UNIT_ASPECT_RATIO;</span>
<span class="nc" id="L1968">                    jfif.Xdensity = p.x;</span>
<span class="nc" id="L1969">                    jfif.Xdensity = p.y;</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                } else if (name.equals(&quot;HorizontalPixelSize&quot;)) {</span>
<span class="nc" id="L1971">                    String valueString = attrs.getNamedItem(&quot;value&quot;).getNodeValue();</span>
<span class="nc" id="L1972">                    float value = Float.parseFloat(valueString);</span>
                    // Convert from mm/dot to dots/cm
<span class="nc" id="L1974">                    int dpcm = (int) Math.round(1.0/(value*10.0));</span>
<span class="nc" id="L1975">                    jfif.resUnits = JPEG.DENSITY_UNIT_DOTS_CM;</span>
<span class="nc" id="L1976">                    jfif.Xdensity = dpcm;</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                } else if (name.equals(&quot;VerticalPixelSize&quot;)) {</span>
<span class="nc" id="L1978">                    String valueString = attrs.getNamedItem(&quot;value&quot;).getNodeValue();</span>
<span class="nc" id="L1979">                    float value = Float.parseFloat(valueString);</span>
                    // Convert from mm/dot to dots/cm
<span class="nc" id="L1981">                    int dpcm = (int) Math.round(1.0/(value*10.0));</span>
<span class="nc" id="L1982">                    jfif.resUnits = JPEG.DENSITY_UNIT_DOTS_CM;</span>
<span class="nc" id="L1983">                    jfif.Ydensity = dpcm;</span>
                }

            }
        }
<span class="nc" id="L1988">    }</span>

    /*
     * Return a pair of integers whose ratio (x/y) approximates the given
     * float value.
     */
    private static Point findIntegerRatio(float value) {
<span class="nc" id="L1995">        float epsilon = 0.005F;</span>

        // Normalize
<span class="nc" id="L1998">        value = Math.abs(value);</span>

        // Deal with min case
<span class="nc bnc" id="L2001" title="All 2 branches missed.">        if (value &lt;= epsilon) {</span>
<span class="nc" id="L2002">            return new Point(1, 255);</span>
        }

        // Deal with max case
<span class="nc bnc" id="L2006" title="All 2 branches missed.">        if (value &gt;= 255) {</span>
<span class="nc" id="L2007">            return new Point(255, 1);</span>
        }

        // Remember if we invert
<span class="nc" id="L2011">        boolean inverted = false;</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">        if (value &lt; 1.0) {</span>
<span class="nc" id="L2013">            value = 1.0F/value;</span>
<span class="nc" id="L2014">            inverted = true;</span>
        }

        // First approximation
<span class="nc" id="L2018">        int y = 1;</span>
<span class="nc" id="L2019">        int x = (int) Math.round(value);</span>

<span class="nc" id="L2021">        float ratio = (float) x;</span>
<span class="nc" id="L2022">        float delta = Math.abs(value - ratio);</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">        while (delta &gt; epsilon) { // not close enough</span>
            // Increment y and compute a new x
<span class="nc" id="L2025">            y++;</span>
<span class="nc" id="L2026">            x = (int) Math.round(y*value);</span>
<span class="nc" id="L2027">            ratio = (float)x/(float)y;</span>
<span class="nc" id="L2028">            delta = Math.abs(value - ratio);</span>
        }
<span class="nc bnc" id="L2030" title="All 2 branches missed.">        return inverted ? new Point(y, x) : new Point(x, y);</span>
    }

    private void mergeStandardDocumentNode(Node node)
        throws IIOInvalidTreeException {
        // No-op
<span class="nc" id="L2036">    }</span>

    private void mergeStandardTextNode(Node node)
        throws IIOInvalidTreeException {
        // Convert to comments.  For the moment ignore the encoding issue.
        // Ignore keywords, language, and encoding (for the moment).
        // If compression tag is present, use only entries with &quot;none&quot;.
<span class="nc" id="L2043">        NodeList children = node.getChildNodes();</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">        for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L2045">            Node child = children.item(i);</span>
<span class="nc" id="L2046">            NamedNodeMap attrs = child.getAttributes();</span>
<span class="nc" id="L2047">            Node comp = attrs.getNamedItem(&quot;compression&quot;);</span>
<span class="nc" id="L2048">            boolean copyIt = true;</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">            if (comp != null) {</span>
<span class="nc" id="L2050">                String compString = comp.getNodeValue();</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">                if (!compString.equals(&quot;none&quot;)) {</span>
<span class="nc" id="L2052">                    copyIt = false;</span>
                }
            }
<span class="nc bnc" id="L2055" title="All 2 branches missed.">            if (copyIt) {</span>
<span class="nc" id="L2056">                String value = attrs.getNamedItem(&quot;value&quot;).getNodeValue();</span>
<span class="nc" id="L2057">                COMMarkerSegment com = new COMMarkerSegment(value);</span>
<span class="nc" id="L2058">                insertCOMMarkerSegment(com);</span>
            }
        }
<span class="nc" id="L2061">    }</span>

    private void mergeStandardTransparencyNode(Node node)
        throws IIOInvalidTreeException {
        // This might indicate that an alpha channel is being added or removed.
        // The nodes must appear in order, and a Chroma node will process any
        // transparency, so process it here only if there was no Chroma node
        // Do nothing for stream metadata
<span class="nc bnc" id="L2069" title="All 4 branches missed.">        if (!transparencyDone &amp;&amp; !isStream) {</span>
<span class="nc" id="L2070">            boolean wantAlpha = wantAlpha(node);</span>
            // do we have alpha already?  If the number of channels is 2 or 4,
            // we do, as we don't support CMYK, nor can we add alpha to it
            // The number of channels can be determined from the SOF
<span class="nc" id="L2074">            JFIFMarkerSegment jfif = (JFIFMarkerSegment) findMarkerSegment</span>
<span class="nc" id="L2075">                (JFIFMarkerSegment.class, true);</span>
<span class="nc" id="L2076">            AdobeMarkerSegment adobe = (AdobeMarkerSegment) findMarkerSegment</span>
<span class="nc" id="L2077">                (AdobeMarkerSegment.class, true);</span>
<span class="nc" id="L2078">            SOFMarkerSegment sof = (SOFMarkerSegment) findMarkerSegment</span>
<span class="nc" id="L2079">                (SOFMarkerSegment.class, true);</span>
<span class="nc" id="L2080">            SOSMarkerSegment sos = (SOSMarkerSegment) findMarkerSegment</span>
<span class="nc" id="L2081">                (SOSMarkerSegment.class, true);</span>

            // We can do nothing for progressive, as we don't know how to
            // modify the scans.
<span class="nc bnc" id="L2085" title="All 4 branches missed.">            if ((sof != null) &amp;&amp; (sof.tag == JPEG.SOF2)) { // Progressive</span>
<span class="nc" id="L2086">                return;</span>
            }

            // Do we already have alpha?  We can tell by the number of channels
            // We must have an sof, or we can't do anything further
<span class="nc bnc" id="L2091" title="All 2 branches missed.">            if (sof != null) {</span>
<span class="nc" id="L2092">                int numChannels = sof.componentSpecs.length;</span>
<span class="nc bnc" id="L2093" title="All 4 branches missed.">                boolean hadAlpha = (numChannels == 2) || (numChannels == 4);</span>
                // proceed only if the old state and the new state differ
<span class="nc bnc" id="L2095" title="All 2 branches missed.">                if (hadAlpha != wantAlpha) {</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                    if (wantAlpha) {  // Adding alpha</span>
<span class="nc" id="L2097">                        numChannels++;</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                        if (jfif != null) {</span>
<span class="nc" id="L2099">                            markerSequence.remove(jfif);</span>
                        }

                        // If an adobe marker is present, transform must be UNKNOWN
<span class="nc bnc" id="L2103" title="All 2 branches missed.">                        if (adobe != null) {</span>
<span class="nc" id="L2104">                            adobe.transform = JPEG.ADOBE_UNKNOWN;</span>
                        }

                        // Add a component spec with appropriate parameters to SOF
<span class="nc" id="L2108">                        SOFMarkerSegment.ComponentSpec [] newSpecs =</span>
                            new SOFMarkerSegment.ComponentSpec[numChannels];
<span class="nc bnc" id="L2110" title="All 2 branches missed.">                        for (int i = 0; i &lt; sof.componentSpecs.length; i++) {</span>
<span class="nc" id="L2111">                            newSpecs[i] = sof.componentSpecs[i];</span>
                        }
<span class="nc" id="L2113">                        byte oldFirstID = (byte) sof.componentSpecs[0].componentId;</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">                        byte newID = (byte) ((oldFirstID &gt; 1) ? 'A' : 4);</span>
<span class="nc" id="L2115">                        newSpecs[numChannels-1] =</span>
<span class="nc" id="L2116">                            sof.getComponentSpec(newID,</span>
                                sof.componentSpecs[0].HsamplingFactor,
                                sof.componentSpecs[0].QtableSelector);

<span class="nc" id="L2120">                        sof.componentSpecs = newSpecs;</span>

                        // Add a component spec with appropriate parameters to SOS
<span class="nc" id="L2123">                        SOSMarkerSegment.ScanComponentSpec [] newScanSpecs =</span>
                            new SOSMarkerSegment.ScanComponentSpec [numChannels];
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                        for (int i = 0; i &lt; sos.componentSpecs.length; i++) {</span>
<span class="nc" id="L2126">                            newScanSpecs[i] = sos.componentSpecs[i];</span>
                        }
<span class="nc" id="L2128">                        newScanSpecs[numChannels-1] =</span>
<span class="nc" id="L2129">                            sos.getScanComponentSpec (newID, 0);</span>
<span class="nc" id="L2130">                        sos.componentSpecs = newScanSpecs;</span>
<span class="nc" id="L2131">                    } else {  // Removing alpha</span>
<span class="nc" id="L2132">                        numChannels--;</span>
                        // Remove a component spec from SOF
<span class="nc" id="L2134">                        SOFMarkerSegment.ComponentSpec [] newSpecs =</span>
                            new SOFMarkerSegment.ComponentSpec[numChannels];
<span class="nc bnc" id="L2136" title="All 2 branches missed.">                        for (int i = 0; i &lt; numChannels; i++) {</span>
<span class="nc" id="L2137">                            newSpecs[i] = sof.componentSpecs[i];</span>
                        }
<span class="nc" id="L2139">                        sof.componentSpecs = newSpecs;</span>

                        // Remove a component spec from SOS
<span class="nc" id="L2142">                        SOSMarkerSegment.ScanComponentSpec [] newScanSpecs =</span>
                            new SOSMarkerSegment.ScanComponentSpec [numChannels];
<span class="nc bnc" id="L2144" title="All 2 branches missed.">                        for (int i = 0; i &lt; numChannels; i++) {</span>
<span class="nc" id="L2145">                            newScanSpecs[i] = sos.componentSpecs[i];</span>
                        }
<span class="nc" id="L2147">                        sos.componentSpecs = newScanSpecs;</span>
                    }
                }
            }
        }
<span class="nc" id="L2152">    }</span>


    public void setFromTree(String formatName, Node root)
        throws IIOInvalidTreeException {
<span class="nc bnc" id="L2157" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L2158">            throw new IllegalArgumentException(&quot;null formatName!&quot;);</span>
        }
<span class="nc bnc" id="L2160" title="All 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L2161">            throw new IllegalArgumentException(&quot;null root!&quot;);</span>
        }
<span class="nc bnc" id="L2163" title="All 2 branches missed.">        if (isStream &amp;&amp;</span>
<span class="nc bnc" id="L2164" title="All 2 branches missed.">            (formatName.equals(JPEG.nativeStreamMetadataFormatName))) {</span>
<span class="nc" id="L2165">            setFromNativeTree(root);</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">        } else if (!isStream &amp;&amp;</span>
<span class="nc bnc" id="L2167" title="All 2 branches missed.">                   (formatName.equals(JPEG.nativeImageMetadataFormatName))) {</span>
<span class="nc" id="L2168">            setFromNativeTree(root);</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">        } else if (!isStream &amp;&amp;</span>
                   (formatName.equals
<span class="nc bnc" id="L2171" title="All 2 branches missed.">                    (IIOMetadataFormatImpl.standardMetadataFormatName))) {</span>
            // In this case a reset followed by a merge is correct
<span class="nc" id="L2173">            super.setFromTree(formatName, root);</span>
        } else {
<span class="nc" id="L2175">            throw  new IllegalArgumentException(&quot;Unsupported format name: &quot;</span>
                                                + formatName);
        }
<span class="nc" id="L2178">    }</span>

    private void setFromNativeTree(Node root) throws IIOInvalidTreeException {
<span class="nc bnc" id="L2181" title="All 2 branches missed.">        if (resetSequence == null) {</span>
<span class="nc" id="L2182">            resetSequence = markerSequence;</span>
        }
<span class="nc" id="L2184">        markerSequence = new ArrayList();</span>

        // Build a whole new marker sequence from the tree

<span class="nc" id="L2188">        String name = root.getNodeName();</span>
<span class="nc bnc" id="L2189" title="All 4 branches missed.">        if (name != ((isStream) ? JPEG.nativeStreamMetadataFormatName</span>
                                : JPEG.nativeImageMetadataFormatName)) {
<span class="nc" id="L2191">            throw new IIOInvalidTreeException(&quot;Invalid root node name: &quot; + name,</span>
                                              root);
        }
<span class="nc bnc" id="L2194" title="All 2 branches missed.">        if (!isStream) {</span>
<span class="nc bnc" id="L2195" title="All 2 branches missed.">            if (root.getChildNodes().getLength() != 2) { // JPEGvariety and markerSequence</span>
<span class="nc" id="L2196">                throw new IIOInvalidTreeException(</span>
                    &quot;JPEGvariety and markerSequence nodes must be present&quot;, root);
            }

<span class="nc" id="L2200">            Node JPEGvariety = root.getFirstChild();</span>

<span class="nc bnc" id="L2202" title="All 2 branches missed.">            if (JPEGvariety.getChildNodes().getLength() != 0) {</span>
<span class="nc" id="L2203">                markerSequence.add(new JFIFMarkerSegment(JPEGvariety.getFirstChild()));</span>
            }
        }

<span class="nc bnc" id="L2207" title="All 2 branches missed.">        Node markerSequenceNode = isStream ? root : root.getLastChild();</span>
<span class="nc" id="L2208">        setFromMarkerSequenceNode(markerSequenceNode);</span>

<span class="nc" id="L2210">    }</span>

    void setFromMarkerSequenceNode(Node markerSequenceNode)
        throws IIOInvalidTreeException{

<span class="nc" id="L2215">        NodeList children = markerSequenceNode.getChildNodes();</span>
        // for all the children, add a marker segment
<span class="nc bnc" id="L2217" title="All 2 branches missed.">        for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L2218">            Node node = children.item(i);</span>
<span class="nc" id="L2219">            String childName = node.getNodeName();</span>
<span class="nc bnc" id="L2220" title="All 2 branches missed.">            if (childName.equals(&quot;dqt&quot;)) {</span>
<span class="nc" id="L2221">                markerSequence.add(new DQTMarkerSegment(node));</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">            } else if (childName.equals(&quot;dht&quot;)) {</span>
<span class="nc" id="L2223">                markerSequence.add(new DHTMarkerSegment(node));</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">            } else if (childName.equals(&quot;dri&quot;)) {</span>
<span class="nc" id="L2225">                markerSequence.add(new DRIMarkerSegment(node));</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">            } else if (childName.equals(&quot;com&quot;)) {</span>
<span class="nc" id="L2227">                markerSequence.add(new COMMarkerSegment(node));</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">            } else if (childName.equals(&quot;app14Adobe&quot;)) {</span>
<span class="nc" id="L2229">                markerSequence.add(new AdobeMarkerSegment(node));</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">            } else if (childName.equals(&quot;unknown&quot;)) {</span>
<span class="nc" id="L2231">                markerSequence.add(new MarkerSegment(node));</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            } else if (childName.equals(&quot;sof&quot;)) {</span>
<span class="nc" id="L2233">                markerSequence.add(new SOFMarkerSegment(node));</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            } else if (childName.equals(&quot;sos&quot;)) {</span>
<span class="nc" id="L2235">                markerSequence.add(new SOSMarkerSegment(node));</span>
            } else {
<span class="nc bnc" id="L2237" title="All 2 branches missed.">                throw new IIOInvalidTreeException(&quot;Invalid &quot;</span>
                    + (isStream ? &quot;stream &quot; : &quot;image &quot;) + &quot;child: &quot;
                    + childName, node);
            }
        }
<span class="nc" id="L2242">    }</span>

    /**
     * Check that this metadata object is in a consistent state and
     * return &lt;code&gt;true&lt;/code&gt; if it is or &lt;code&gt;false&lt;/code&gt;
     * otherwise.  All the constructors and modifiers should call
     * this method at the end to guarantee that the data is always
     * consistent, as the writer relies on this.
     */
    private boolean isConsistent() {
<span class="nc" id="L2252">        SOFMarkerSegment sof =</span>
<span class="nc" id="L2253">            (SOFMarkerSegment) findMarkerSegment(SOFMarkerSegment.class,</span>
                                                 true);
<span class="nc" id="L2255">        JFIFMarkerSegment jfif =</span>
<span class="nc" id="L2256">            (JFIFMarkerSegment) findMarkerSegment(JFIFMarkerSegment.class,</span>
                                                  true);
<span class="nc" id="L2258">        AdobeMarkerSegment adobe =</span>
<span class="nc" id="L2259">            (AdobeMarkerSegment) findMarkerSegment(AdobeMarkerSegment.class,</span>
                                                   true);
<span class="nc" id="L2261">        boolean retval = true;</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">        if (!isStream) {</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">            if (sof != null) {</span>
                // SOF numBands = total scan bands
<span class="nc" id="L2265">                int numSOFBands = sof.componentSpecs.length;</span>
<span class="nc" id="L2266">                int numScanBands = countScanBands();</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">                if (numScanBands != 0) {  // No SOS is OK</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">                    if (numScanBands != numSOFBands) {</span>
<span class="nc" id="L2269">                        retval = false;</span>
                    }
                }
                // If JFIF is present, component ids are 1-3, bands are 1 or 3
<span class="nc bnc" id="L2273" title="All 2 branches missed.">                if (jfif != null) {</span>
<span class="nc bnc" id="L2274" title="All 4 branches missed.">                    if ((numSOFBands != 1) &amp;&amp; (numSOFBands != 3)) {</span>
<span class="nc" id="L2275">                        retval = false;</span>
                    }
<span class="nc bnc" id="L2277" title="All 2 branches missed.">                    for (int i = 0; i &lt; numSOFBands; i++) {</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">                        if (sof.componentSpecs[i].componentId != i+1) {</span>
<span class="nc" id="L2279">                            retval = false;</span>
                        }
                    }

                    // If both JFIF and Adobe are present,
                    // Adobe transform == unknown for gray,
                    // YCC for 3-chan.
<span class="nc bnc" id="L2286" title="All 10 branches missed.">                    if ((adobe != null)</span>
                        &amp;&amp; (((numSOFBands == 1)
                             &amp;&amp; (adobe.transform != JPEG.ADOBE_UNKNOWN))
                            || ((numSOFBands == 3)
                                &amp;&amp; (adobe.transform != JPEG.ADOBE_YCC)))) {
<span class="nc" id="L2291">                        retval = false;</span>
                    }
                }
<span class="nc" id="L2294">            } else {</span>
                // stream can't have jfif, adobe, sof, or sos
<span class="nc" id="L2296">                SOSMarkerSegment sos =</span>
<span class="nc" id="L2297">                    (SOSMarkerSegment) findMarkerSegment(SOSMarkerSegment.class,</span>
                                                         true);
<span class="nc bnc" id="L2299" title="All 8 branches missed.">                if ((jfif != null) || (adobe != null)</span>
                    || (sof != null) || (sos != null)) {
<span class="nc" id="L2301">                    retval = false;</span>
                }
            }
        }
<span class="nc" id="L2305">        return retval;</span>
    }

    /**
     * Returns the total number of bands referenced in all SOS marker
     * segments, including 0 if there are no SOS marker segments.
     */
    private int countScanBands() {
<span class="nc" id="L2313">        List ids = new ArrayList();</span>
<span class="nc" id="L2314">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L2316">            MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">            if (seg instanceof SOSMarkerSegment) {</span>
<span class="nc" id="L2318">                SOSMarkerSegment sos = (SOSMarkerSegment) seg;</span>
<span class="nc" id="L2319">                SOSMarkerSegment.ScanComponentSpec [] specs = sos.componentSpecs;</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                for (int i = 0; i &lt; specs.length; i++) {</span>
<span class="nc" id="L2321">                    Integer id = new Integer(specs[i].componentSelector);</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">                    if (!ids.contains(id)) {</span>
<span class="nc" id="L2323">                        ids.add(id);</span>
                    }
                }
            }
<span class="nc" id="L2327">        }</span>

<span class="nc" id="L2329">        return ids.size();</span>
    }

    ///// Writer support

    void writeToStream(ImageOutputStream ios,
                       boolean ignoreJFIF,
                       boolean forceJFIF,
                       List thumbnails,
                       ICC_Profile iccProfile,
                       boolean ignoreAdobe,
                       int newAdobeTransform,
                       JPEGImageWriter writer)
        throws IOException {
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        if (forceJFIF) {</span>
            // Write a default JFIF segment, including thumbnails
            // This won't be duplicated below because forceJFIF will be
            // set only if there is no JFIF present already.
<span class="nc" id="L2347">            JFIFMarkerSegment.writeDefaultJFIF(ios,</span>
                                               thumbnails,
                                               iccProfile,
                                               writer);
<span class="nc bnc" id="L2351" title="All 4 branches missed.">            if ((ignoreAdobe == false)</span>
                &amp;&amp; (newAdobeTransform != JPEG.ADOBE_IMPOSSIBLE)) {
<span class="nc bnc" id="L2353" title="All 4 branches missed.">                if ((newAdobeTransform != JPEG.ADOBE_UNKNOWN)</span>
                    &amp;&amp; (newAdobeTransform != JPEG.ADOBE_YCC)) {
                    // Not compatible, so ignore Adobe.
<span class="nc" id="L2356">                    ignoreAdobe = true;</span>
<span class="nc" id="L2357">                    writer.warningOccurred</span>
<span class="nc" id="L2358">                        (JPEGImageWriter.WARNING_METADATA_ADJUSTED_FOR_THUMB);</span>
                }
            }
        }
        // Iterate over each MarkerSegment
<span class="nc" id="L2363">        Iterator iter = markerSequence.iterator();</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        while(iter.hasNext()) {</span>
<span class="nc" id="L2365">            MarkerSegment seg = (MarkerSegment)iter.next();</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (seg instanceof JFIFMarkerSegment) {</span>
<span class="nc bnc" id="L2367" title="All 2 branches missed.">                if (ignoreJFIF == false) {</span>
<span class="nc" id="L2368">                    JFIFMarkerSegment jfif = (JFIFMarkerSegment) seg;</span>
<span class="nc" id="L2369">                    jfif.writeWithThumbs(ios, thumbnails, writer);</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">                    if (iccProfile != null) {</span>
<span class="nc" id="L2371">                        JFIFMarkerSegment.writeICC(iccProfile, ios);</span>
                    }
<span class="nc" id="L2373">                } // Otherwise ignore it, as requested</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">            } else if (seg instanceof AdobeMarkerSegment) {</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">                if (ignoreAdobe == false) {</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">                    if (newAdobeTransform != JPEG.ADOBE_IMPOSSIBLE) {</span>
<span class="nc" id="L2377">                        AdobeMarkerSegment newAdobe =</span>
<span class="nc" id="L2378">                            (AdobeMarkerSegment) seg.clone();</span>
<span class="nc" id="L2379">                        newAdobe.transform = newAdobeTransform;</span>
<span class="nc" id="L2380">                        newAdobe.write(ios);</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">                    } else if (forceJFIF) {</span>
                        // If adobe isn't JFIF compatible, ignore it
<span class="nc" id="L2383">                        AdobeMarkerSegment adobe = (AdobeMarkerSegment) seg;</span>
<span class="nc bnc" id="L2384" title="All 4 branches missed.">                        if ((adobe.transform == JPEG.ADOBE_UNKNOWN)</span>
                            || (adobe.transform == JPEG.ADOBE_YCC)) {
<span class="nc" id="L2386">                            adobe.write(ios);</span>
                        } else {
<span class="nc" id="L2388">                            writer.warningOccurred</span>
<span class="nc" id="L2389">                         (JPEGImageWriter.WARNING_METADATA_ADJUSTED_FOR_THUMB);</span>
                        }
<span class="nc" id="L2391">                    } else {</span>
<span class="nc" id="L2392">                        seg.write(ios);</span>
                    }
                } // Otherwise ignore it, as requested
            } else {
<span class="nc" id="L2396">                seg.write(ios);</span>
            }
<span class="nc" id="L2398">        }</span>
<span class="nc" id="L2399">    }</span>

    //// End of writer support

    public void reset() {
<span class="nc bnc" id="L2404" title="All 2 branches missed.">        if (resetSequence != null) {  // Otherwise no need to reset</span>
<span class="nc" id="L2405">            markerSequence = resetSequence;</span>
<span class="nc" id="L2406">            resetSequence = null;</span>
        }
<span class="nc" id="L2408">    }</span>

    public void print() {
<span class="nc bnc" id="L2411" title="All 2 branches missed.">        for (int i = 0; i &lt; markerSequence.size(); i++) {</span>
<span class="nc" id="L2412">            MarkerSegment seg = (MarkerSegment) markerSequence.get(i);</span>
<span class="nc" id="L2413">            seg.print();</span>
        }
<span class="nc" id="L2415">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>