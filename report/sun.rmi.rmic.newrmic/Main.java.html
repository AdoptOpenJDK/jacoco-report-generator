<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.rmi.rmic.newrmic</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.rmic.newrmic;

import com.sun.javadoc.ClassDoc;
import com.sun.javadoc.RootDoc;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import sun.rmi.rmic.newrmic.jrmp.JrmpGenerator;
import sun.tools.util.CommandLine;

/**
 * The rmic front end.  This class contains the &quot;main&quot; method for rmic
 * command line invocation.
 *
 * A Main instance contains the stream to output error messages and
 * other diagnostics to.
 *
 * An rmic compilation batch (for example, one rmic command line
 * invocation) is executed by invoking the &quot;compile&quot; method of a Main
 * instance.
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 *
 * NOTE: If and when there is a J2SE API for invoking SDK tools, this
 * class should be updated to support that API.
 *
 * NOTE: This class is the front end for a &quot;new&quot; rmic implementation,
 * which uses javadoc and the doclet API for reading class files and
 * javac for compiling generated source files.  This implementation is
 * incomplete: it lacks any CORBA-based back end implementations, and
 * thus the command line options &quot;-idl&quot;, &quot;-iiop&quot;, and their related
 * options are not yet supported.  The front end for the &quot;old&quot;,
 * oldjavac-based rmic implementation is sun.rmi.rmic.Main.
 *
 * @author Peter Jones
 **/
<span class="nc bnc" id="L76" title="All 2 branches missed.">public class Main {</span>

    /*
     * Implementation note:
     *
     * In order to use the doclet API to read class files, much of
     * this implementation of rmic executes as a doclet within an
     * invocation of javadoc.  This class is used as the doclet class
     * for such javadoc invocations, via its static &quot;start&quot; and
     * &quot;optionLength&quot; methods.  There is one javadoc invocation per
     * rmic compilation batch.
     *
     * The only guaranteed way to pass data to a doclet through a
     * javadoc invocation is through doclet-specific options on the
     * javadoc &quot;command line&quot;.  Rather than passing numerous pieces of
     * individual data in string form as javadoc options, we use a
     * single doclet-specific option (&quot;-batchID&quot;) to pass a numeric
     * identifier that uniquely identifies the rmic compilation batch
     * that the javadoc invocation is for, and that identifier can
     * then be used as a key in a global table to retrieve an object
     * containing all of batch-specific data (rmic command line
     * arguments, etc.).
     */

    /** guards &quot;batchCount&quot; */
<span class="nc" id="L101">    private static final Object batchCountLock = new Object();</span>

    /** number of batches run; used to generated batch IDs */
<span class="nc" id="L104">    private static long batchCount = 0;</span>

    /** maps batch ID to batch data */
<span class="nc" id="L107">    private static final Map&lt;Long,Batch&gt; batchTable =</span>
<span class="nc" id="L108">        Collections.synchronizedMap(new HashMap&lt;Long,Batch&gt;());</span>

    /** stream to output error messages and other diagnostics to */
    private final PrintStream out;

    /** name of this program, to use in error messages */
    private final String program;

    /**
     * Command line entry point.
     **/
    public static void main(String[] args) {
<span class="nc" id="L120">        Main rmic = new Main(System.err, &quot;rmic&quot;);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        System.exit(rmic.compile(args) ? 0 : 1);</span>
<span class="nc" id="L122">    }</span>

    /**
     * Creates a Main instance that writes output to the specified
     * stream.  The specified program name is used in error messages.
     **/
<span class="nc" id="L128">    public Main(OutputStream out, String program) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        this.out = out instanceof PrintStream ?</span>
            (PrintStream) out : new PrintStream(out);
<span class="nc" id="L131">        this.program = program;</span>
<span class="nc" id="L132">    }</span>

    /**
     * Compiles a batch of input classes, as given by the specified
     * command line arguments.  Protocol-specific generators are
     * determined by the choice options on the command line.  Returns
     * true if successful, or false if an error occurred.
     *
     * NOTE: This method is retained for transitional consistency with
     * previous implementations.
     **/
    public boolean compile(String[] args) {
<span class="nc" id="L144">        long startTime = System.currentTimeMillis();</span>

        long batchID;
<span class="nc" id="L147">        synchronized (batchCountLock) {</span>
<span class="nc" id="L148">            batchID = batchCount++;     // assign batch ID</span>
<span class="nc" id="L149">        }</span>

        // process command line
<span class="nc" id="L152">        Batch batch = parseArgs(args);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (batch == null) {</span>
<span class="nc" id="L154">            return false;               // terminate if error occurred</span>
        }

        /*
         * With the batch data retrievable in the global table, run
         * javadoc to continue the rest of the batch's compliation as
         * a doclet.
         */
        boolean status;
        try {
<span class="nc" id="L164">            batchTable.put(batchID, batch);</span>
<span class="nc" id="L165">            status = invokeJavadoc(batch, batchID);</span>
        } finally {
<span class="nc" id="L167">            batchTable.remove(batchID);</span>
<span class="nc" id="L168">        }</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (batch.verbose) {</span>
<span class="nc" id="L171">            long deltaTime = System.currentTimeMillis() - startTime;</span>
<span class="nc" id="L172">            output(Resources.getText(&quot;rmic.done_in&quot;,</span>
<span class="nc" id="L173">                                     Long.toString(deltaTime)));</span>
        }

<span class="nc" id="L176">        return status;</span>
    }

    /**
     * Prints the specified string to the output stream of this Main
     * instance.
     **/
    public void output(String msg) {
<span class="nc" id="L184">        out.println(msg);</span>
<span class="nc" id="L185">    }</span>

    /**
     * Prints an error message to the output stream of this Main
     * instance.  The first argument is used as a key in rmic's
     * resource bundle, and the rest of the arguments are used as
     * arguments in the formatting of the resource string.
     **/
    public void error(String msg, String... args) {
<span class="nc" id="L194">        output(Resources.getText(msg, args));</span>
<span class="nc" id="L195">    }</span>

    /**
     * Prints rmic's usage message to the output stream of this Main
     * instance.
     *
     * This method is public so that it can be used by the &quot;parseArgs&quot;
     * methods of Generator implementations.
     **/
    public void usage() {
<span class="nc" id="L205">        error(&quot;rmic.usage&quot;, program);</span>
<span class="nc" id="L206">    }</span>

    /**
     * Processes rmic command line arguments.  Returns a Batch object
     * representing the command line arguments if successful, or null
     * if an error occurred.  Processed elements of the args array are
     * set to null.
     **/
    private Batch parseArgs(String[] args) {
<span class="nc" id="L215">        Batch batch = new Batch();</span>

        /*
         * Pre-process command line for @file arguments.
         */
        try {
<span class="nc" id="L221">            args = CommandLine.parse(args);</span>
<span class="nc" id="L222">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L223">            error(&quot;rmic.cant.read&quot;, e.getMessage());</span>
<span class="nc" id="L224">            return null;</span>
<span class="nc" id="L225">        } catch (IOException e) {</span>
<span class="nc" id="L226">            e.printStackTrace(out);</span>
<span class="nc" id="L227">            return null;</span>
<span class="nc" id="L228">        }</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (args[i] == null) {</span>
                // already processed by a generator
<span class="nc" id="L234">                continue;</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-Xnew&quot;)) {</span>
                // we're already using the &quot;new&quot; implementation
<span class="nc" id="L238">                args[i] = null;</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-show&quot;)) {</span>
                // obselete: fail
<span class="nc" id="L242">                error(&quot;rmic.option.unsupported&quot;, args[i]);</span>
<span class="nc" id="L243">                usage();</span>
<span class="nc" id="L244">                return null;</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-O&quot;)) {</span>
                // obselete: warn but tolerate
<span class="nc" id="L248">                error(&quot;rmic.option.unsupported&quot;, args[i]);</span>
<span class="nc" id="L249">                args[i] = null;</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-debug&quot;)) {</span>
                // obselete: warn but tolerate
<span class="nc" id="L253">                error(&quot;rmic.option.unsupported&quot;, args[i]);</span>
<span class="nc" id="L254">                args[i] = null;</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-depend&quot;)) {</span>
                // obselete: warn but tolerate
                // REMIND: should this fail instead?
<span class="nc" id="L259">                error(&quot;rmic.option.unsupported&quot;, args[i]);</span>
<span class="nc" id="L260">                args[i] = null;</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-keep&quot;) ||</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                       args[i].equals(&quot;-keepgenerated&quot;))</span>
            {
<span class="nc" id="L265">                batch.keepGenerated = true;</span>
<span class="nc" id="L266">                args[i] = null;</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-g&quot;)) {</span>
<span class="nc" id="L269">                batch.debug = true;</span>
<span class="nc" id="L270">                args[i] = null;</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-nowarn&quot;)) {</span>
<span class="nc" id="L273">                batch.noWarn = true;</span>
<span class="nc" id="L274">                args[i] = null;</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-nowrite&quot;)) {</span>
<span class="nc" id="L277">                batch.noWrite = true;</span>
<span class="nc" id="L278">                args[i] = null;</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-verbose&quot;)) {</span>
<span class="nc" id="L281">                batch.verbose = true;</span>
<span class="nc" id="L282">                args[i] = null;</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-Xnocompile&quot;)) {</span>
<span class="nc" id="L285">                batch.noCompile = true;</span>
<span class="nc" id="L286">                batch.keepGenerated = true;</span>
<span class="nc" id="L287">                args[i] = null;</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-bootclasspath&quot;)) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if ((i + 1) &gt;= args.length) {</span>
<span class="nc" id="L291">                    error(&quot;rmic.option.requires.argument&quot;, args[i]);</span>
<span class="nc" id="L292">                    usage();</span>
<span class="nc" id="L293">                    return null;</span>
                }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                if (batch.bootClassPath != null) {</span>
<span class="nc" id="L296">                    error(&quot;rmic.option.already.seen&quot;, args[i]);</span>
<span class="nc" id="L297">                    usage();</span>
<span class="nc" id="L298">                    return null;</span>
                }
<span class="nc" id="L300">                args[i] = null;</span>
<span class="nc" id="L301">                batch.bootClassPath = args[++i];</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">                assert batch.bootClassPath != null;</span>
<span class="nc" id="L303">                args[i] = null;</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-extdirs&quot;)) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if ((i + 1) &gt;= args.length) {</span>
<span class="nc" id="L307">                    error(&quot;rmic.option.requires.argument&quot;, args[i]);</span>
<span class="nc" id="L308">                    usage();</span>
<span class="nc" id="L309">                    return null;</span>
                }
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (batch.extDirs != null) {</span>
<span class="nc" id="L312">                    error(&quot;rmic.option.already.seen&quot;, args[i]);</span>
<span class="nc" id="L313">                    usage();</span>
<span class="nc" id="L314">                    return null;</span>
                }
<span class="nc" id="L316">                args[i] = null;</span>
<span class="nc" id="L317">                batch.extDirs = args[++i];</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">                assert batch.extDirs != null;</span>
<span class="nc" id="L319">                args[i] = null;</span>

<span class="nc bnc" id="L321" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-classpath&quot;)) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">                if ((i + 1) &gt;= args.length) {</span>
<span class="nc" id="L323">                    error(&quot;rmic.option.requires.argument&quot;, args[i]);</span>
<span class="nc" id="L324">                    usage();</span>
<span class="nc" id="L325">                    return null;</span>
                }
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (batch.classPath != null) {</span>
<span class="nc" id="L328">                    error(&quot;rmic.option.already.seen&quot;, args[i]);</span>
<span class="nc" id="L329">                    usage();</span>
<span class="nc" id="L330">                    return null;</span>
                }
<span class="nc" id="L332">                args[i] = null;</span>
<span class="nc" id="L333">                batch.classPath = args[++i];</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">                assert batch.classPath != null;</span>
<span class="nc" id="L335">                args[i] = null;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-d&quot;)) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if ((i + 1) &gt;= args.length) {</span>
<span class="nc" id="L339">                    error(&quot;rmic.option.requires.argument&quot;, args[i]);</span>
<span class="nc" id="L340">                    usage();</span>
<span class="nc" id="L341">                    return null;</span>
                }
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (batch.destDir != null) {</span>
<span class="nc" id="L344">                    error(&quot;rmic.option.already.seen&quot;, args[i]);</span>
<span class="nc" id="L345">                    usage();</span>
<span class="nc" id="L346">                    return null;</span>
                }
<span class="nc" id="L348">                args[i] = null;</span>
<span class="nc" id="L349">                batch.destDir = new File(args[++i]);</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">                assert batch.destDir != null;</span>
<span class="nc" id="L351">                args[i] = null;</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                if (!batch.destDir.exists()) {</span>
<span class="nc" id="L353">                    error(&quot;rmic.no.such.directory&quot;, batch.destDir.getPath());</span>
<span class="nc" id="L354">                    usage();</span>
<span class="nc" id="L355">                    return null;</span>
                }

<span class="nc bnc" id="L358" title="All 2 branches missed.">            } else if (args[i].equals(&quot;-v1.1&quot;) ||</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                       args[i].equals(&quot;-vcompat&quot;) ||</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">                       args[i].equals(&quot;-v1.2&quot;))</span>
            {
<span class="nc" id="L362">                Generator gen = new JrmpGenerator();</span>
<span class="nc" id="L363">                batch.generators.add(gen);</span>
                // JrmpGenerator only requires base BatchEnvironment class
<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (!gen.parseArgs(args, this)) {</span>
<span class="nc" id="L366">                    return null;</span>
                }

<span class="nc bnc" id="L369" title="All 2 branches missed.">            } else if (args[i].equalsIgnoreCase(&quot;-iiop&quot;)) {</span>
<span class="nc" id="L370">                error(&quot;rmic.option.unimplemented&quot;, args[i]);</span>
<span class="nc" id="L371">                return null;</span>

                // Generator gen = new IiopGenerator();
                // batch.generators.add(gen);
                // if (!batch.envClass.isAssignableFrom(gen.envClass())) {
                //   error(&quot;rmic.cannot.use.both&quot;,
                //         batch.envClass.getName(), gen.envClass().getName());
                //   return null;
                // }
                // batch.envClass = gen.envClass();
                // if (!gen.parseArgs(args, this)) {
                //   return null;
                // }

<span class="nc bnc" id="L385" title="All 2 branches missed.">            } else if (args[i].equalsIgnoreCase(&quot;-idl&quot;)) {</span>
<span class="nc" id="L386">                error(&quot;rmic.option.unimplemented&quot;, args[i]);</span>
<span class="nc" id="L387">                return null;</span>

                // see implementation sketch above

<span class="nc bnc" id="L391" title="All 2 branches missed.">            } else if (args[i].equalsIgnoreCase(&quot;-xprint&quot;)) {</span>
<span class="nc" id="L392">                error(&quot;rmic.option.unimplemented&quot;, args[i]);</span>
<span class="nc" id="L393">                return null;</span>

                // see implementation sketch above
            }
        }

        /*
         * At this point, all that remains non-null in the args
         * array are input class names or illegal options.
         */
<span class="nc bnc" id="L403" title="All 2 branches missed.">        for (int i = 0; i &lt; args.length; i++) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (args[i] != null) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                if (args[i].startsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L406">                    error(&quot;rmic.no.such.option&quot;, args[i]);</span>
<span class="nc" id="L407">                    usage();</span>
<span class="nc" id="L408">                    return null;</span>
                } else {
<span class="nc" id="L410">                    batch.classes.add(args[i]);</span>
                }
            }
        }
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (batch.classes.isEmpty()) {</span>
<span class="nc" id="L415">            usage();</span>
<span class="nc" id="L416">            return null;</span>
        }

        /*
         * If options did not specify at least one protocol-specific
         * generator, then JRMP is the default.
         */
<span class="nc bnc" id="L423" title="All 2 branches missed.">        if (batch.generators.isEmpty()) {</span>
<span class="nc" id="L424">            batch.generators.add(new JrmpGenerator());</span>
        }
<span class="nc" id="L426">        return batch;</span>
    }

    /**
     * Doclet class entry point.
     **/
    public static boolean start(RootDoc rootDoc) {

        /*
         * Find batch ID among javadoc options, and retrieve
         * corresponding batch data from global table.
         */
<span class="nc" id="L438">        long batchID = -1;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">        for (String[] option : rootDoc.options()) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (option[0].equals(&quot;-batchID&quot;)) {</span>
                try {
<span class="nc" id="L442">                    batchID = Long.parseLong(option[1]);</span>
<span class="nc" id="L443">                } catch (NumberFormatException e) {</span>
<span class="nc" id="L444">                    throw new AssertionError(e);</span>
<span class="nc" id="L445">                }</span>
            }
        }
<span class="nc" id="L448">        Batch batch = batchTable.get(batchID);</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">        assert batch != null;</span>

        /*
         * Construct batch environment using class agreed upon by
         * generator implementations.
         */
        BatchEnvironment env;
        try {
<span class="nc" id="L457">            Constructor&lt;? extends BatchEnvironment&gt; cons =</span>
<span class="nc" id="L458">                batch.envClass.getConstructor(new Class&lt;?&gt;[] { RootDoc.class });</span>
<span class="nc" id="L459">            env = cons.newInstance(rootDoc);</span>
<span class="nc" id="L460">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L461">            throw new AssertionError(e);</span>
<span class="nc" id="L462">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L463">            throw new AssertionError(e);</span>
<span class="nc" id="L464">        } catch (InstantiationException e) {</span>
<span class="nc" id="L465">            throw new AssertionError(e);</span>
<span class="nc" id="L466">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L467">            throw new AssertionError(e);</span>
<span class="nc" id="L468">        }</span>

<span class="nc" id="L470">        env.setVerbose(batch.verbose);</span>

        /*
         * Determine the destination directory (the top of the package
         * hierarchy) for the output of this batch; if no destination
         * directory was specified on the command line, then the
         * default is the current working directory.
         */
<span class="nc" id="L478">        File destDir = batch.destDir;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (destDir == null) {</span>
<span class="nc" id="L480">            destDir = new File(System.getProperty(&quot;user.dir&quot;));</span>
        }

        /*
         * Run each input class through each generator.
         */
<span class="nc bnc" id="L486" title="All 2 branches missed.">        for (String inputClassName : batch.classes) {</span>
<span class="nc" id="L487">            ClassDoc inputClass = rootDoc.classNamed(inputClassName);</span>
            try {
<span class="nc bnc" id="L489" title="All 2 branches missed.">                for (Generator gen : batch.generators) {</span>
<span class="nc" id="L490">                    gen.generate(env, inputClass, destDir);</span>
<span class="nc" id="L491">                }</span>
<span class="nc" id="L492">            } catch (NullPointerException e) {</span>
                /*
                 * We assume that this means that some class that was
                 * needed (perhaps even a bootstrap class) was not
                 * found, and that javadoc has already reported this
                 * as an error.  There is nothing for us to do here
                 * but try to continue with the next input class.
                 *
                 * REMIND: More explicit error checking throughout
                 * would be preferable, however.
                 */
<span class="nc" id="L503">            }</span>
<span class="nc" id="L504">        }</span>

        /*
         * Compile any generated source files, if configured to do so.
         */
<span class="nc" id="L509">        boolean status = true;</span>
<span class="nc" id="L510">        List&lt;File&gt; generatedFiles = env.generatedFiles();</span>
<span class="nc bnc" id="L511" title="All 6 branches missed.">        if (!batch.noCompile &amp;&amp; !batch.noWrite &amp;&amp; !generatedFiles.isEmpty()) {</span>
<span class="nc" id="L512">            status = batch.enclosingMain().invokeJavac(batch, generatedFiles);</span>
        }

        /*
         * Delete any generated source files, if configured to do so.
         */
<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (!batch.keepGenerated) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            for (File file : generatedFiles) {</span>
<span class="nc" id="L520">                file.delete();</span>
<span class="nc" id="L521">            }</span>
        }

<span class="nc" id="L524">        return status;</span>
    }

    /**
     * Doclet class method that indicates that this doclet class
     * recognizes (only) the &quot;-batchID&quot; option on the javadoc command
     * line, and that the &quot;-batchID&quot; option comprises two arguments on
     * the javadoc command line.
     **/
    public static int optionLength(String option) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (option.equals(&quot;-batchID&quot;)) {</span>
<span class="nc" id="L535">            return 2;</span>
        } else {
<span class="nc" id="L537">            return 0;</span>
        }
    }

    /**
     * Runs the javadoc tool to invoke this class as a doclet, passing
     * command line options derived from the specified batch data and
     * indicating the specified batch ID.
     *
     * NOTE: This method currently uses a J2SE-internal API to run
     * javadoc.  If and when there is a J2SE API for invoking SDK
     * tools, this method should be updated to use that API instead.
     **/
    private boolean invokeJavadoc(Batch batch, long batchID) {
<span class="nc" id="L551">        List&lt;String&gt; javadocArgs = new ArrayList&lt;String&gt;();</span>

        // include all types, regardless of language-level access
<span class="nc" id="L554">        javadocArgs.add(&quot;-private&quot;);</span>

        // inputs are class names, not source files
<span class="nc" id="L557">        javadocArgs.add(&quot;-Xclasses&quot;);</span>

        // reproduce relevant options from rmic invocation
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (batch.verbose) {</span>
<span class="nc" id="L561">            javadocArgs.add(&quot;-verbose&quot;);</span>
        }
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (batch.bootClassPath != null) {</span>
<span class="nc" id="L564">            javadocArgs.add(&quot;-bootclasspath&quot;);</span>
<span class="nc" id="L565">            javadocArgs.add(batch.bootClassPath);</span>
        }
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (batch.extDirs != null) {</span>
<span class="nc" id="L568">            javadocArgs.add(&quot;-extdirs&quot;);</span>
<span class="nc" id="L569">            javadocArgs.add(batch.extDirs);</span>
        }
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (batch.classPath != null) {</span>
<span class="nc" id="L572">            javadocArgs.add(&quot;-classpath&quot;);</span>
<span class="nc" id="L573">            javadocArgs.add(batch.classPath);</span>
        }

        // specify batch ID
<span class="nc" id="L577">        javadocArgs.add(&quot;-batchID&quot;);</span>
<span class="nc" id="L578">        javadocArgs.add(Long.toString(batchID));</span>

        /*
         * Run javadoc on union of rmic input classes and all
         * generators' bootstrap classes, so that they will all be
         * available to the doclet code.
         */
<span class="nc" id="L585">        Set&lt;String&gt; classNames = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (Generator gen : batch.generators) {</span>
<span class="nc" id="L587">            classNames.addAll(gen.bootstrapClassNames());</span>
<span class="nc" id="L588">        }</span>
<span class="nc" id="L589">        classNames.addAll(batch.classes);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (String s : classNames) {</span>
<span class="nc" id="L591">            javadocArgs.add(s);</span>
<span class="nc" id="L592">        }</span>

        // run javadoc with our program name and output stream
<span class="nc" id="L595">        int status = com.sun.tools.javadoc.Main.execute(</span>
            program,
            new PrintWriter(out, true),
            new PrintWriter(out, true),
            new PrintWriter(out, true),
<span class="nc" id="L600">            this.getClass().getName(),          // doclet class is this class</span>
<span class="nc" id="L601">            javadocArgs.toArray(new String[javadocArgs.size()]));</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        return status == 0;</span>
    }

    /**
     * Runs the javac tool to compile the specified source files,
     * passing command line options derived from the specified batch
     * data.
     *
     * NOTE: This method currently uses a J2SE-internal API to run
     * javac.  If and when there is a J2SE API for invoking SDK tools,
     * this method should be updated to use that API instead.
     **/
    private boolean invokeJavac(Batch batch, List&lt;File&gt; files) {
<span class="nc" id="L615">        List&lt;String&gt; javacArgs = new ArrayList&lt;String&gt;();</span>

        // rmic never wants to display javac warnings
<span class="nc" id="L618">        javacArgs.add(&quot;-nowarn&quot;);</span>

        // reproduce relevant options from rmic invocation
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (batch.debug) {</span>
<span class="nc" id="L622">            javacArgs.add(&quot;-g&quot;);</span>
        }
<span class="nc bnc" id="L624" title="All 2 branches missed.">        if (batch.verbose) {</span>
<span class="nc" id="L625">            javacArgs.add(&quot;-verbose&quot;);</span>
        }
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if (batch.bootClassPath != null) {</span>
<span class="nc" id="L628">            javacArgs.add(&quot;-bootclasspath&quot;);</span>
<span class="nc" id="L629">            javacArgs.add(batch.bootClassPath);</span>
        }
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (batch.extDirs != null) {</span>
<span class="nc" id="L632">            javacArgs.add(&quot;-extdirs&quot;);</span>
<span class="nc" id="L633">            javacArgs.add(batch.extDirs);</span>
        }
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (batch.classPath != null) {</span>
<span class="nc" id="L636">            javacArgs.add(&quot;-classpath&quot;);</span>
<span class="nc" id="L637">            javacArgs.add(batch.classPath);</span>
        }

        /*
         * For now, rmic still always produces class files that have a
         * class file format version compatible with JDK 1.1.
         */
<span class="nc" id="L644">        javacArgs.add(&quot;-source&quot;);</span>
<span class="nc" id="L645">        javacArgs.add(&quot;1.3&quot;);</span>
<span class="nc" id="L646">        javacArgs.add(&quot;-target&quot;);</span>
<span class="nc" id="L647">        javacArgs.add(&quot;1.1&quot;);</span>

        // add source files to compile
<span class="nc bnc" id="L650" title="All 2 branches missed.">        for (File file : files) {</span>
<span class="nc" id="L651">            javacArgs.add(file.getPath());</span>
<span class="nc" id="L652">        }</span>

        // run javac with our output stream
<span class="nc" id="L655">        int status = com.sun.tools.javac.Main.compile(</span>
<span class="nc" id="L656">            javacArgs.toArray(new String[javacArgs.size()]),</span>
            new PrintWriter(out, true));
<span class="nc bnc" id="L658" title="All 2 branches missed.">        return status == 0;</span>
    }

    /**
     * The data for an rmic compliation batch: the processed command
     * line arguments.
     **/
    private class Batch {
<span class="nc" id="L666">        boolean keepGenerated = false;  // -keep or -keepgenerated</span>
<span class="nc" id="L667">        boolean debug = false;          // -g</span>
<span class="nc" id="L668">        boolean noWarn = false;         // -nowarn</span>
<span class="nc" id="L669">        boolean noWrite = false;        // -nowrite</span>
<span class="nc" id="L670">        boolean verbose = false;        // -verbose</span>
<span class="nc" id="L671">        boolean noCompile = false;      // -Xnocompile</span>
<span class="nc" id="L672">        String bootClassPath = null;    // -bootclasspath</span>
<span class="nc" id="L673">        String extDirs = null;          // -extdirs</span>
<span class="nc" id="L674">        String classPath = null;        // -classpath</span>
<span class="nc" id="L675">        File destDir = null;            // -d</span>
<span class="nc" id="L676">        List&lt;Generator&gt; generators = new ArrayList&lt;Generator&gt;();</span>
<span class="nc" id="L677">        Class&lt;? extends BatchEnvironment&gt; envClass = BatchEnvironment.class;</span>
<span class="nc" id="L678">        List&lt;String&gt; classes = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L680">        Batch() { }</span>

        /**
         * Returns the Main instance for this batch.
         **/
        Main enclosingMain() {
<span class="nc" id="L686">            return Main.this;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>