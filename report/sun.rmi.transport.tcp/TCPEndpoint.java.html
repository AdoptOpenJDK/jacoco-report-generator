<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TCPEndpoint.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.transport.tcp</a> &gt; <span class="el_source">TCPEndpoint.java</span></div><h1>TCPEndpoint.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.rmi.transport.tcp;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.rmi.ConnectIOException;
import java.rmi.RemoteException;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.security.AccessController;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import sun.rmi.runtime.Log;
import sun.rmi.runtime.NewThreadAction;
import sun.rmi.transport.Channel;
import sun.rmi.transport.Endpoint;
import sun.rmi.transport.Target;
import sun.rmi.transport.Transport;
import sun.security.action.GetBooleanAction;
import sun.security.action.GetIntegerAction;
import sun.security.action.GetPropertyAction;

/**
 * TCPEndpoint represents some communication endpoint for an address
 * space (VM).
 *
 * @author Ann Wollrath
 */
public class TCPEndpoint implements Endpoint {
    /** IP address or host name */
    private String host;
    /** port number */
    private int port;
    /** custom client socket factory (null if not custom factory) */
    private final RMIClientSocketFactory csf;
    /** custom server socket factory (null if not custom factory) */
    private final RMIServerSocketFactory ssf;

    /** if local, the port number to listen on */
<span class="fc" id="L74">    private int listenPort = -1;</span>
    /** if local, the transport object associated with this endpoint */
<span class="fc" id="L76">    private TCPTransport transport = null;</span>

    /** the local host name */
    private static String localHost;
    /** true if real local host name is known yet */
    private static boolean localHostKnown;

    // this should be a *private* method since it is privileged
    private static int getInt(String name, int def) {
<span class="nc" id="L85">        return AccessController.doPrivileged(new GetIntegerAction(name, def));</span>
    }

    // this should be a *private* method since it is privileged
    private static boolean getBoolean(String name) {
<span class="fc" id="L90">        return AccessController.doPrivileged(new GetBooleanAction(name));</span>
    }

    /**
     * Returns the value of the java.rmi.server.hostname property.
     */
    private static String getHostnameProperty() {
<span class="fc" id="L97">        return AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;java.rmi.server.hostname&quot;));
    }

    /**
     * Find host name of local machine.  Property &quot;java.rmi.server.hostname&quot;
     * is used if set, so server administrator can compensate for the possible
     * inablility to get fully qualified host name from VM.
     */
    static {
<span class="fc" id="L107">        localHostKnown = true;</span>
<span class="fc" id="L108">        localHost = getHostnameProperty();</span>

        // could try querying CGI program here?
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (localHost == null) {</span>
            try {
<span class="fc" id="L113">                InetAddress localAddr = InetAddress.getLocalHost();</span>
<span class="fc" id="L114">                byte[] raw = localAddr.getAddress();</span>
<span class="pc bpc" id="L115" title="4 of 8 branches missed.">                if ((raw[0] == 127) &amp;&amp;</span>
                    (raw[1] ==   0) &amp;&amp;
                    (raw[2] ==   0) &amp;&amp;
                    (raw[3] ==   1)) {
<span class="fc" id="L119">                    localHostKnown = false;</span>
                }

                /* if the user wishes to use a fully qualified domain
                 * name then attempt to find one.
                 */
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                if (getBoolean(&quot;java.rmi.server.useLocalHostName&quot;)) {</span>
<span class="nc" id="L126">                    localHost = FQDN.attemptFQDN(localAddr);</span>
                } else {
                    /* default to using ip addresses, names will
                     * work across seperate domains.
                     */
<span class="fc" id="L131">                    localHost = localAddr.getHostAddress();</span>
                }
<span class="nc" id="L133">            } catch (Exception e) {</span>
<span class="nc" id="L134">                localHostKnown = false;</span>
<span class="nc" id="L135">                localHost = null;</span>
<span class="fc" id="L136">            }</span>
        }

<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="fc" id="L140">            TCPTransport.tcpLog.log(Log.BRIEF,</span>
                &quot;localHostKnown = &quot; + localHostKnown +
                &quot;, localHost = &quot; + localHost);
        }
    }

    /** maps an endpoint key containing custom socket factories to
     * their own unique endpoint */
    // TBD: should this be a weak hash table?
    private static final
<span class="fc" id="L150">        Map&lt;TCPEndpoint,LinkedList&lt;TCPEndpoint&gt;&gt; localEndpoints =</span>
        new HashMap&lt;&gt;();

    /**
     * Create an endpoint for a specified host and port.
     * This should not be used by external classes to create endpoints
     * for servers in this VM; use getLocalEndpoint instead.
     */
    public TCPEndpoint(String host, int port) {
<span class="fc" id="L159">        this(host, port, null, null);</span>
<span class="fc" id="L160">    }</span>

    /**
     * Create a custom socket factory endpoint for a specified host and port.
     * This should not be used by external classes to create endpoints
     * for servers in this VM; use getLocalEndpoint instead.
     */
    public TCPEndpoint(String host, int port, RMIClientSocketFactory csf,
                       RMIServerSocketFactory ssf)
<span class="fc" id="L169">    {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (host == null)</span>
<span class="fc" id="L171">            host = &quot;&quot;;</span>
<span class="fc" id="L172">        this.host = host;</span>
<span class="fc" id="L173">        this.port = port;</span>
<span class="fc" id="L174">        this.csf = csf;</span>
<span class="fc" id="L175">        this.ssf = ssf;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Get an endpoint for the local address space on specified port.
     * If port number is 0, it returns shared default endpoint object
     * whose host name and port may or may not have been determined.
     */
    public static TCPEndpoint getLocalEndpoint(int port) {
<span class="fc" id="L184">        return getLocalEndpoint(port, null, null);</span>
    }

    public static TCPEndpoint getLocalEndpoint(int port,
                                               RMIClientSocketFactory csf,
                                               RMIServerSocketFactory ssf)
    {
        /*
         * Find mapping for an endpoint key to the list of local unique
         * endpoints for this client/server socket factory pair (perhaps
         * null) for the specific port.
         */
<span class="fc" id="L196">        TCPEndpoint ep = null;</span>

<span class="fc" id="L198">        synchronized (localEndpoints) {</span>
<span class="fc" id="L199">            TCPEndpoint endpointKey = new TCPEndpoint(null, port, csf, ssf);</span>
<span class="fc" id="L200">            LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);</span>
<span class="fc" id="L201">            String localHost = resampleLocalHost();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (epList == null) {</span>
                /*
                 * Create new endpoint list.
                 */
<span class="fc" id="L207">                ep = new TCPEndpoint(localHost, port, csf, ssf);</span>
<span class="fc" id="L208">                epList = new LinkedList&lt;TCPEndpoint&gt;();</span>
<span class="fc" id="L209">                epList.add(ep);</span>
<span class="fc" id="L210">                ep.listenPort = port;</span>
<span class="fc" id="L211">                ep.transport = new TCPTransport(epList);</span>
<span class="fc" id="L212">                localEndpoints.put(endpointKey, epList);</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">                if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="fc" id="L215">                    TCPTransport.tcpLog.log(Log.BRIEF,</span>
                        &quot;created local endpoint for socket factory &quot; + ssf +
                        &quot; on port &quot; + port);
                }
            } else {
<span class="fc" id="L220">                synchronized (epList) {</span>
<span class="fc" id="L221">                    ep = epList.getLast();</span>
<span class="fc" id="L222">                    String lastHost = ep.host;</span>
<span class="fc" id="L223">                    int lastPort =  ep.port;</span>
<span class="fc" id="L224">                    TCPTransport lastTransport = ep.transport;</span>
                    // assert (localHost == null ^ lastHost != null)
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">                    if (localHost != null &amp;&amp; !localHost.equals(lastHost)) {</span>
                        /*
                         * Hostname has been updated; add updated endpoint
                         * to list.
                         */
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                        if (lastPort != 0) {</span>
                            /*
                             * Remove outdated endpoints only if the
                             * port has already been set on those endpoints.
                             */
<span class="fc" id="L236">                            epList.clear();</span>
                        }
<span class="fc" id="L238">                        ep = new TCPEndpoint(localHost, lastPort, csf, ssf);</span>
<span class="fc" id="L239">                        ep.listenPort = port;</span>
<span class="fc" id="L240">                        ep.transport = lastTransport;</span>
<span class="fc" id="L241">                        epList.add(ep);</span>
                    }
<span class="pc" id="L243">                }</span>
            }
<span class="pc" id="L245">        }</span>

<span class="fc" id="L247">        return ep;</span>
    }

    /**
     * Resamples the local hostname and returns the possibly-updated
     * local hostname.
     */
    private static String resampleLocalHost() {

<span class="fc" id="L256">        String hostnameProperty = getHostnameProperty();</span>

<span class="fc" id="L258">        synchronized (localEndpoints) {</span>
            // assert(localHostKnown ^ (localHost == null))

<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (hostnameProperty != null) {</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">                if (!localHostKnown) {</span>
                    /*
                     * If the local hostname is unknown, update ALL
                     * existing endpoints with the new hostname.
                     */
<span class="nc" id="L267">                    setLocalHost(hostnameProperty);</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                } else if (!hostnameProperty.equals(localHost)) {</span>
                    /*
                     * Only update the localHost field for reference
                     * in future endpoint creation.
                     */
<span class="fc" id="L273">                    localHost = hostnameProperty;</span>

<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                    if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="nc" id="L276">                        TCPTransport.tcpLog.log(Log.BRIEF,</span>
                            &quot;updated local hostname to: &quot; + localHost);
                    }
                }
            }
<span class="fc" id="L281">            return localHost;</span>
<span class="nc" id="L282">        }</span>
    }

    /**
     * Set the local host name, if currently unknown.
     */
    static void setLocalHost(String host) {
        // assert (host != null)

<span class="fc" id="L291">        synchronized (localEndpoints) {</span>
            /*
             * If host is not known, change the host field of ALL
             * the local endpoints.
             */
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (!localHostKnown) {</span>
<span class="fc" id="L297">                localHost = host;</span>
<span class="fc" id="L298">                localHostKnown = true;</span>

<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="fc" id="L301">                    TCPTransport.tcpLog.log(Log.BRIEF,</span>
                        &quot;local host set to &quot; + host);
                }
<span class="fc bfc" id="L304" title="All 2 branches covered.">                for (LinkedList&lt;TCPEndpoint&gt; epList : localEndpoints.values())</span>
                {
<span class="fc" id="L306">                    synchronized (epList) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                        for (TCPEndpoint ep : epList) {</span>
<span class="fc" id="L308">                            ep.host = host;</span>
<span class="fc" id="L309">                        }</span>
<span class="pc" id="L310">                    }</span>
<span class="fc" id="L311">                }</span>
            }
<span class="pc" id="L313">        }</span>
<span class="fc" id="L314">    }</span>

    /**
     * Set the port of the (shared) default endpoint object.
     * When first created, it contains port 0 because the transport
     * hasn't tried to listen to get assigned a port, or if listening
     * failed, a port hasn't been assigned from the server.
     */
    static void setDefaultPort(int port, RMIClientSocketFactory csf,
                               RMIServerSocketFactory ssf)
    {
<span class="fc" id="L325">        TCPEndpoint endpointKey = new TCPEndpoint(null, 0, csf, ssf);</span>

<span class="fc" id="L327">        synchronized (localEndpoints) {</span>
<span class="fc" id="L328">            LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);</span>

<span class="fc" id="L330">            synchronized (epList) {</span>
<span class="fc" id="L331">                int size = epList.size();</span>
<span class="fc" id="L332">                TCPEndpoint lastEp = epList.getLast();</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">                for (TCPEndpoint ep : epList) {</span>
<span class="fc" id="L335">                    ep.port = port;</span>
<span class="fc" id="L336">                }</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                if (size &gt; 1) {</span>
                    /*
                     * Remove all but the last element of the list
                     * (which contains the most recent hostname).
                     */
<span class="nc" id="L342">                    epList.clear();</span>
<span class="nc" id="L343">                    epList.add(lastEp);</span>
                }
<span class="pc" id="L345">            }</span>

            /*
             * Allow future exports to use the actual bound port
             * explicitly (see 6269166).
             */
<span class="fc" id="L351">            TCPEndpoint newEndpointKey = new TCPEndpoint(null, port, csf, ssf);</span>
<span class="fc" id="L352">            localEndpoints.put(newEndpointKey, epList);</span>

<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="fc" id="L355">                TCPTransport.tcpLog.log(Log.BRIEF,</span>
                    &quot;default port for server socket factory &quot; + ssf +
                    &quot; and client socket factory &quot; + csf +
                    &quot; set to &quot; + port);
            }
<span class="pc" id="L360">        }</span>
<span class="fc" id="L361">    }</span>

    /**
     * Returns transport for making connections to remote endpoints;
     * (here, the default transport at port 0 is used).
     */
    public Transport getOutboundTransport() {
<span class="fc" id="L368">        TCPEndpoint localEndpoint = getLocalEndpoint(0, null, null);</span>
<span class="fc" id="L369">        return localEndpoint.transport;</span>
    }

    /**
     * Returns the current list of known transports.
     * The returned list is an unshared collection of Transports,
     * including all transports which may have channels to remote
     * endpoints.
     */
    private static Collection&lt;TCPTransport&gt; allKnownTransports() {
        // Loop through local endpoints, getting the transport of each one.
        Set&lt;TCPTransport&gt; s;
<span class="fc" id="L381">        synchronized (localEndpoints) {</span>
            // presize s to number of localEndpoints
<span class="fc" id="L383">            s = new HashSet&lt;TCPTransport&gt;(localEndpoints.size());</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (LinkedList&lt;TCPEndpoint&gt; epList : localEndpoints.values()) {</span>
                /*
                 * Each local endpoint has its transport added to s.
                 * Note: the transport is the same for all endpoints
                 * in the list, so it is okay to pick any one of them.
                 */
<span class="fc" id="L390">                TCPEndpoint ep = epList.getFirst();</span>
<span class="fc" id="L391">                s.add(ep.transport);</span>
<span class="fc" id="L392">            }</span>
<span class="pc" id="L393">        }</span>
<span class="fc" id="L394">        return s;</span>
    }

    /**
     * Release idle outbound connections to reduce demand on I/O resources.
     * All transports are asked to release excess connections.
     */
    public static void shedConnectionCaches() {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (TCPTransport transport : allKnownTransports()) {</span>
<span class="fc" id="L403">            transport.shedConnectionCaches();</span>
<span class="fc" id="L404">        }</span>
<span class="fc" id="L405">    }</span>

    /**
     * Export the object to accept incoming calls.
     */
    public void exportObject(Target target) throws RemoteException {
<span class="fc" id="L411">        transport.exportObject(target);</span>
<span class="fc" id="L412">    }</span>

    /**
     * Returns a channel for this (remote) endpoint.
     */
    public Channel getChannel() {
<span class="fc" id="L418">        return getOutboundTransport().getChannel(this);</span>
    }

    /**
     * Returns address for endpoint
     */
    public String getHost() {
<span class="fc" id="L425">        return host;</span>
    }

    /**
     * Returns the port for this endpoint.  If this endpoint was
     * created as a server endpoint (using getLocalEndpoint) for a
     * default/anonymous port and its inbound transport has started
     * listening, this method returns (instead of zero) the actual
     * bound port suitable for passing to clients.
     **/
    public int getPort() {
<span class="fc" id="L436">        return port;</span>
    }

    /**
     * Returns the port that this endpoint's inbound transport listens
     * on, if this endpoint was created as a server endpoint (using
     * getLocalEndpoint).  If this endpoint was created for the
     * default/anonymous port, then this method returns zero even if
     * the transport has started listening.
     **/
    public int getListenPort() {
<span class="fc" id="L447">        return listenPort;</span>
    }

    /**
     * Returns the transport for incoming connections to this
     * endpoint, if this endpoint was created as a server endpoint
     * (using getLocalEndpoint).
     **/
    public Transport getInboundTransport() {
<span class="fc" id="L456">        return transport;</span>
    }

    /**
     * Get the client socket factory associated with this endpoint.
     */
    public RMIClientSocketFactory getClientSocketFactory() {
<span class="fc" id="L463">        return csf;</span>
    }

    /**
     * Get the server socket factory associated with this endpoint.
     */
    public RMIServerSocketFactory getServerSocketFactory() {
<span class="fc" id="L470">        return ssf;</span>
    }

    /**
     * Return string representation for endpoint.
     */
    public String toString() {
<span class="fc bfc" id="L477" title="All 4 branches covered.">        return &quot;[&quot; + host + &quot;:&quot; + port +</span>
            (ssf != null ? &quot;,&quot; + ssf : &quot;&quot;) +
            (csf != null ? &quot;,&quot; + csf : &quot;&quot;) +
            &quot;]&quot;;
    }

    public int hashCode() {
<span class="fc" id="L484">        return port;</span>
    }

    public boolean equals(Object obj) {
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof TCPEndpoint)) {</span>
<span class="fc" id="L489">            TCPEndpoint ep = (TCPEndpoint) obj;</span>
<span class="pc bpc" id="L490" title="1 of 4 branches missed.">            if (port != ep.port || !host.equals(ep.host))</span>
<span class="fc" id="L491">                return false;</span>
<span class="fc bfc" id="L492" title="All 12 branches covered.">            if (((csf == null) ^ (ep.csf == null)) ||</span>
                ((ssf == null) ^ (ep.ssf == null)))
<span class="fc" id="L494">                return false;</span>
            /*
             * Fix for 4254510: perform socket factory *class* equality check
             * before socket factory equality check to avoid passing
             * a potentially naughty socket factory to this endpoint's
             * {client,server} socket factory equals method.
             */
<span class="fc bfc" id="L501" title="All 2 branches covered.">            if ((csf != null) &amp;&amp;</span>
<span class="pc bpc" id="L502" title="1 of 4 branches missed.">                !(csf.getClass() == ep.csf.getClass() &amp;&amp; csf.equals(ep.csf)))</span>
<span class="fc" id="L503">                return false;</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">            if ((ssf != null) &amp;&amp;</span>
<span class="pc bpc" id="L505" title="1 of 4 branches missed.">                !(ssf.getClass() == ep.ssf.getClass() &amp;&amp; ssf.equals(ep.ssf)))</span>
<span class="fc" id="L506">                return false;</span>
<span class="fc" id="L507">            return true;</span>
        } else {
<span class="nc" id="L509">            return false;</span>
        }
    }

    /* codes for the self-describing formats of wire representation */
    private static final int FORMAT_HOST_PORT           = 0;
    private static final int FORMAT_HOST_PORT_FACTORY   = 1;

    /**
     * Write endpoint to output stream.
     */
    public void write(ObjectOutput out) throws IOException {
<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (csf == null) {</span>
<span class="fc" id="L522">            out.writeByte(FORMAT_HOST_PORT);</span>
<span class="fc" id="L523">            out.writeUTF(host);</span>
<span class="fc" id="L524">            out.writeInt(port);</span>
        } else {
<span class="fc" id="L526">            out.writeByte(FORMAT_HOST_PORT_FACTORY);</span>
<span class="fc" id="L527">            out.writeUTF(host);</span>
<span class="fc" id="L528">            out.writeInt(port);</span>
<span class="fc" id="L529">            out.writeObject(csf);</span>
        }
<span class="fc" id="L531">    }</span>

    /**
     * Get the endpoint from the input stream.
     * @param in the input stream
     * @exception IOException If id could not be read (due to stream failure)
     */
    public static TCPEndpoint read(ObjectInput in)
        throws IOException, ClassNotFoundException
    {
        String host;
        int port;
<span class="fc" id="L543">        RMIClientSocketFactory csf = null;</span>

<span class="fc" id="L545">        byte format = in.readByte();</span>
<span class="pc bpc" id="L546" title="1 of 3 branches missed.">        switch (format) {</span>
          case FORMAT_HOST_PORT:
<span class="fc" id="L548">            host = in.readUTF();</span>
<span class="fc" id="L549">            port = in.readInt();</span>
<span class="fc" id="L550">            break;</span>

          case FORMAT_HOST_PORT_FACTORY:
<span class="fc" id="L553">            host = in.readUTF();</span>
<span class="fc" id="L554">            port = in.readInt();</span>
<span class="fc" id="L555">            csf = (RMIClientSocketFactory) in.readObject();</span>
<span class="fc" id="L556">          break;</span>

          default:
<span class="nc" id="L559">            throw new IOException(&quot;invalid endpoint format&quot;);</span>
        }
<span class="fc" id="L561">        return new TCPEndpoint(host, port, csf, null);</span>
    }

    /**
     * Write endpoint to output stream in older format used by
     * UnicastRef for JDK1.1 compatibility.
     */
    public void writeHostPortFormat(DataOutput out) throws IOException {
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        if (csf != null) {</span>
<span class="nc" id="L570">            throw new InternalError(&quot;TCPEndpoint.writeHostPortFormat: &quot; +</span>
                &quot;called for endpoint with non-null socket factory&quot;);
        }
<span class="fc" id="L573">        out.writeUTF(host);</span>
<span class="fc" id="L574">        out.writeInt(port);</span>
<span class="fc" id="L575">    }</span>

    /**
     * Create a new endpoint from input stream data.
     * @param in the input stream
     */
    public static TCPEndpoint readHostPortFormat(DataInput in)
        throws IOException
    {
<span class="fc" id="L584">        String host = in.readUTF();</span>
<span class="fc" id="L585">        int port = in.readInt();</span>
<span class="fc" id="L586">        return new TCPEndpoint(host, port);</span>
    }

    private static RMISocketFactory chooseFactory() {
<span class="fc" id="L590">        RMISocketFactory sf = RMISocketFactory.getSocketFactory();</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (sf == null) {</span>
<span class="fc" id="L592">            sf = TCPTransport.defaultSocketFactory;</span>
        }
<span class="fc" id="L594">        return sf;</span>
    }

    /**
     * Open and return new client socket connection to endpoint.
     */
    Socket newSocket() throws RemoteException {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L602">            TCPTransport.tcpLog.log(Log.VERBOSE,</span>
                &quot;opening socket to &quot; + this);
        }

        Socket socket;

        try {
<span class="fc" id="L609">            RMIClientSocketFactory clientFactory = csf;</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            if (clientFactory == null) {</span>
<span class="fc" id="L611">                clientFactory = chooseFactory();</span>
            }
<span class="fc" id="L613">            socket = clientFactory.createSocket(host, port);</span>

<span class="nc" id="L615">        } catch (java.net.UnknownHostException e) {</span>
<span class="nc" id="L616">            throw new java.rmi.UnknownHostException(</span>
                &quot;Unknown host: &quot; + host, e);
<span class="fc" id="L618">        } catch (java.net.ConnectException e) {</span>
<span class="fc" id="L619">            throw new java.rmi.ConnectException(</span>
                &quot;Connection refused to host: &quot; + host, e);
<span class="fc" id="L621">        } catch (IOException e) {</span>
            // We might have simply run out of file descriptors
            try {
<span class="fc" id="L624">                TCPEndpoint.shedConnectionCaches();</span>
                // REMIND: should we retry createSocket?
<span class="nc" id="L626">            } catch (OutOfMemoryError | Exception mem) {</span>
                // don't quit if out of memory
                // or shed fails non-catastrophically
<span class="fc" id="L629">            }</span>

<span class="fc" id="L631">            throw new ConnectIOException(&quot;Exception creating connection to: &quot; +</span>
                host, e);
<span class="fc" id="L633">        }</span>

        // set socket to disable Nagle's algorithm (always send immediately)
        // TBD: should this be left up to socket factory instead?
        try {
<span class="fc" id="L638">            socket.setTcpNoDelay(true);</span>
<span class="nc" id="L639">        } catch (Exception e) {</span>
            // if we fail to set this, ignore and proceed anyway
<span class="fc" id="L641">        }</span>

        // fix 4187495: explicitly set SO_KEEPALIVE to prevent client hangs
        try {
<span class="fc" id="L645">            socket.setKeepAlive(true);</span>
<span class="nc" id="L646">        } catch (Exception e) {</span>
            // ignore and proceed
<span class="fc" id="L648">        }</span>

<span class="fc" id="L650">        return socket;</span>
    }

    /**
     * Return new server socket to listen for connections on this endpoint.
     */
    ServerSocket newServerSocket() throws IOException {
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L658">            TCPTransport.tcpLog.log(Log.VERBOSE,</span>
                &quot;creating server socket on &quot; + this);
        }

<span class="fc" id="L662">        RMIServerSocketFactory serverFactory = ssf;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        if (serverFactory == null) {</span>
<span class="fc" id="L664">            serverFactory = chooseFactory();</span>
        }
<span class="fc" id="L666">        ServerSocket server = serverFactory.createServerSocket(listenPort);</span>

        // if we listened on an anonymous port, set the default port
        // (for this socket factory)
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (listenPort == 0)</span>
<span class="fc" id="L671">            setDefaultPort(server.getLocalPort(), csf, ssf);</span>

<span class="fc" id="L673">        return server;</span>
    }

    /**
     * The class FQDN encapsulates a routine that makes a best effort
     * attempt to retrieve the fully qualified domain name of the local
     * host.
     *
     * @author  Laird Dornin
     */
    private static class FQDN implements Runnable {

        /**
         * strings in which we can store discovered fqdn
         */
        private String reverseLookup;

        private String hostAddress;

<span class="nc" id="L692">        private FQDN(String hostAddress) {</span>
<span class="nc" id="L693">            this.hostAddress = hostAddress;</span>
<span class="nc" id="L694">        }</span>

        /**
         * Do our best to obtain a fully qualified hostname for the local
         * host.  Perform the following steps to get a localhostname:
         *
         * 1. InetAddress.getLocalHost().getHostName() - if contains
         *    '.' use as FQDN
         * 2. if no '.' query name service for FQDN in a thread
         *    Note: We query the name service for an FQDN by creating
         *    an InetAddress via a stringified copy of the local ip
         *    address; this creates an InetAddress with a null hostname.
         *    Asking for the hostname of this InetAddress causes a name
         *    service lookup.
         *
         * 3. if name service takes too long to return, use ip address
         * 4. if name service returns but response contains no '.'
         *    default to ipaddress.
         */
        static String attemptFQDN(InetAddress localAddr)
            throws java.net.UnknownHostException
        {

<span class="nc" id="L717">            String hostName = localAddr.getHostName();</span>

<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (hostName.indexOf('.') &lt; 0 ) {</span>

<span class="nc" id="L721">                String hostAddress = localAddr.getHostAddress();</span>
<span class="nc" id="L722">                FQDN f = new FQDN(hostAddress);</span>

<span class="nc" id="L724">                int nameServiceTimeOut =</span>
<span class="nc" id="L725">                    TCPEndpoint.getInt(&quot;sun.rmi.transport.tcp.localHostNameTimeOut&quot;,</span>
                                       10000);

                try {
<span class="nc" id="L729">                    synchronized(f) {</span>
<span class="nc" id="L730">                        f.getFQDN();</span>

                        /* wait to obtain an FQDN */
<span class="nc" id="L733">                        f.wait(nameServiceTimeOut);</span>
<span class="nc" id="L734">                    }</span>
<span class="nc" id="L735">                } catch (InterruptedException e) {</span>
                    /* propagate the exception to the caller */
<span class="nc" id="L737">                    Thread.currentThread().interrupt();</span>
<span class="nc" id="L738">                }</span>
<span class="nc" id="L739">                hostName = f.getHost();</span>

<span class="nc bnc" id="L741" title="All 4 branches missed.">                if ((hostName == null) || (hostName.equals(&quot;&quot;))</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                    || (hostName.indexOf('.') &lt; 0 )) {</span>

<span class="nc" id="L744">                    hostName = hostAddress;</span>
                }
            }
<span class="nc" id="L747">            return hostName;</span>
        }

        /**
         * Method that that will start a thread to wait to retrieve a
         * fully qualified domain name from a name service.  The spawned
         * thread may never return but we have marked it as a daemon so the vm
         * will terminate appropriately.
         */
        private void getFQDN() {

            /* FQDN finder will run in RMI threadgroup. */
<span class="nc" id="L759">            Thread t = AccessController.doPrivileged(</span>
                new NewThreadAction(FQDN.this, &quot;FQDN Finder&quot;, true));
<span class="nc" id="L761">            t.start();</span>
<span class="nc" id="L762">        }</span>

        private synchronized String getHost() {
<span class="nc" id="L765">            return reverseLookup;</span>
        }

        /**
         * thread to query a name service for the fqdn of this host.
         */
        public void run()  {

<span class="nc" id="L773">            String name = null;</span>

            try {
<span class="nc" id="L776">                name = InetAddress.getByName(hostAddress).getHostName();</span>
<span class="nc" id="L777">            } catch (java.net.UnknownHostException e) {</span>
            } finally {
<span class="nc" id="L779">                synchronized(this) {</span>
<span class="nc" id="L780">                    reverseLookup = name;</span>
<span class="nc" id="L781">                    this.notify();</span>
<span class="nc" id="L782">                }</span>
<span class="nc" id="L783">            }</span>
<span class="nc" id="L784">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>