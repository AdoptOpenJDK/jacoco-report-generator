<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BasicAttribute.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.naming.directory</a> &gt; <span class="el_source">BasicAttribute.java</span></div><h1>BasicAttribute.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.directory;

import java.util.Vector;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.lang.reflect.Array;

import javax.naming.NamingException;
import javax.naming.NamingEnumeration;
import javax.naming.OperationNotSupportedException;

/**
  * This class provides a basic implementation of the &lt;tt&gt;Attribute&lt;/tt&gt; interface.
  *&lt;p&gt;
  * This implementation does not support the schema methods
  * &lt;tt&gt;getAttributeDefinition()&lt;/tt&gt; and &lt;tt&gt;getAttributeSyntaxDefinition()&lt;/tt&gt;.
  * They simply throw &lt;tt&gt;OperationNotSupportedException&lt;/tt&gt;.
  * Subclasses of &lt;tt&gt;BasicAttribute&lt;/tt&gt; should override these methods if they
  * support them.
  *&lt;p&gt;
  * The &lt;tt&gt;BasicAttribute&lt;/tt&gt; class by default uses &lt;tt&gt;Object.equals()&lt;/tt&gt; to
  * determine equality of attribute values when testing for equality or
  * when searching for values, &lt;em&gt;except&lt;/em&gt; when the value is an array.
  * For an array, each element of the array is checked using &lt;tt&gt;Object.equals()&lt;/tt&gt;.
  * Subclasses of &lt;tt&gt;BasicAttribute&lt;/tt&gt; can make use of schema information
  * when doing similar equality checks by overriding methods
  * in which such use of schema is meaningful.
  * Similarly, the &lt;tt&gt;BasicAttribute&lt;/tt&gt; class by default returns the values passed to its
  * constructor and/or manipulated using the add/remove methods.
  * Subclasses of &lt;tt&gt;BasicAttribute&lt;/tt&gt; can override &lt;tt&gt;get()&lt;/tt&gt; and &lt;tt&gt;getAll()&lt;/tt&gt;
  * to get the values dynamically from the directory (or implement
  * the &lt;tt&gt;Attribute&lt;/tt&gt; interface directly instead of subclassing &lt;tt&gt;BasicAttribute&lt;/tt&gt;).
  *&lt;p&gt;
  * Note that updates to &lt;tt&gt;BasicAttribute&lt;/tt&gt; (such as adding or removing a value)
  * does not affect the corresponding representation of the attribute
  * in the directory.  Updates to the directory can only be effected
  * using operations in the &lt;tt&gt;DirContext&lt;/tt&gt; interface.
  *&lt;p&gt;
  * A &lt;tt&gt;BasicAttribute&lt;/tt&gt; instance is not synchronized against concurrent
  * multithreaded access. Multiple threads trying to access and modify a
  * &lt;tt&gt;BasicAttribute&lt;/tt&gt; should lock the object.
  *
  * @author Rosanna Lee
  * @author Scott Seligman
  * @since 1.3
  */
public class BasicAttribute implements Attribute {
    /**
     * Holds the attribute's id. It is initialized by the public constructor and
     * cannot be null unless methods in BasicAttribute that use attrID
     * have been overridden.
     * @serial
     */
    protected String attrID;

    /**
     * Holds the attribute's values. Initialized by public constructors.
     * Cannot be null unless methods in BasicAttribute that use
     * values have been overridden.
     */
    protected transient Vector&lt;Object&gt; values;

    /**
     * A flag for recording whether this attribute's values are ordered.
     * @serial
     */
<span class="fc" id="L92">    protected boolean ordered = false;</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public Object clone() {
        BasicAttribute attr;
        try {
<span class="nc" id="L98">            attr = (BasicAttribute)super.clone();</span>
<span class="nc" id="L99">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L100">            attr = new BasicAttribute(attrID, ordered);</span>
<span class="nc" id="L101">        }</span>
<span class="nc" id="L102">        attr.values = (Vector&lt;Object&gt;)values.clone();</span>
<span class="nc" id="L103">        return attr;</span>
    }

    /**
      * Determines whether obj is equal to this attribute.
      * Two attributes are equal if their attribute-ids, syntaxes
      * and values are equal.
      * If the attribute values are unordered, the order that the values were added
      * are irrelevant. If the attribute values are ordered, then the
      * order the values must match.
      * If obj is null or not an Attribute, false is returned.
      *&lt;p&gt;
      * By default &lt;tt&gt;Object.equals()&lt;/tt&gt; is used when comparing the attribute
      * id and its values except when a value is an array. For an array,
      * each element of the array is checked using &lt;tt&gt;Object.equals()&lt;/tt&gt;.
      * A subclass may override this to make
      * use of schema syntax information and matching rules,
      * which define what it means for two attributes to be equal.
      * How and whether a subclass makes
      * use of the schema information is determined by the subclass.
      * If a subclass overrides &lt;tt&gt;equals()&lt;/tt&gt;, it should also override
      * &lt;tt&gt;hashCode()&lt;/tt&gt;
      * such that two attributes that are equal have the same hash code.
      *
      * @param obj      The possibly null object to check.
      * @return true if obj is equal to this attribute; false otherwise.
      * @see #hashCode
      * @see #contains
      */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if ((obj != null) &amp;&amp; (obj instanceof Attribute)) {</span>
<span class="nc" id="L134">            Attribute target = (Attribute)obj;</span>

            // Check order first
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (isOrdered() != target.isOrdered()) {</span>
<span class="nc" id="L138">                return false;</span>
            }
            int len;
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (attrID.equals(target.getID()) &amp;&amp;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                (len=size()) == target.size()) {</span>
                try {
<span class="nc bnc" id="L144" title="All 2 branches missed.">                    if (isOrdered()) {</span>
                        // Go through both list of values
<span class="nc bnc" id="L146" title="All 2 branches missed.">                        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                            if (!valueEquals(get(i), target.get(i))) {</span>
<span class="nc" id="L148">                                return false;</span>
                            }
                        }
                    } else {
                        // order is not relevant; check for existence
<span class="nc" id="L153">                        Enumeration&lt;?&gt; theirs = target.getAll();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                        while (theirs.hasMoreElements()) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                            if (find(theirs.nextElement()) &lt; 0)</span>
<span class="nc" id="L156">                                return false;</span>
                        }
                    }
<span class="nc" id="L159">                } catch (NamingException e) {</span>
<span class="nc" id="L160">                    return false;</span>
<span class="nc" id="L161">                }</span>
<span class="nc" id="L162">                return true;</span>
            }
        }
<span class="nc" id="L165">        return false;</span>
    }

    /**
      * Calculates the hash code of this attribute.
      *&lt;p&gt;
      * The hash code is computed by adding the hash code of
      * the attribute's id and that of all of its values except for
      * values that are arrays.
      * For an array, the hash code of each element of the array is summed.
      * If a subclass overrides &lt;tt&gt;hashCode()&lt;/tt&gt;, it should override
      * &lt;tt&gt;equals()&lt;/tt&gt;
      * as well so that two attributes that are equal have the same hash code.
      *
      * @return an int representing the hash code of this attribute.
      * @see #equals
      */
    public int hashCode() {
<span class="nc" id="L183">        int hash = attrID.hashCode();</span>
<span class="nc" id="L184">        int num = values.size();</span>
        Object val;
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (int i = 0; i &lt; num; i ++) {</span>
<span class="nc" id="L187">            val = values.elementAt(i);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (val != null) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (val.getClass().isArray()) {</span>
                    Object it;
<span class="nc" id="L191">                    int len = Array.getLength(val);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    for (int j = 0 ; j &lt; len ; j++) {</span>
<span class="nc" id="L193">                        it = Array.get(val, j);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                        if (it != null) {</span>
<span class="nc" id="L195">                            hash += it.hashCode();</span>
                        }
                    }
<span class="nc" id="L198">                } else {</span>
<span class="nc" id="L199">                    hash += val.hashCode();</span>
                }
            }
        }
<span class="nc" id="L203">        return hash;</span>
    }

    /**
      * Generates the string representation of this attribute.
      * The string consists of the attribute's id and its values.
      * This string is meant for debugging and not meant to be
      * interpreted programmatically.
      * @return The non-null string representation of this attribute.
      */
    public String toString() {
<span class="nc" id="L214">        StringBuffer answer = new StringBuffer(attrID + &quot;: &quot;);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (values.size() == 0) {</span>
<span class="nc" id="L216">            answer.append(&quot;No values&quot;);</span>
        } else {
<span class="nc" id="L218">            boolean start = true;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            for (Enumeration&lt;Object&gt; e = values.elements(); e.hasMoreElements(); ) {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (!start)</span>
<span class="nc" id="L221">                    answer.append(&quot;, &quot;);</span>
<span class="nc" id="L222">                answer.append(e.nextElement());</span>
<span class="nc" id="L223">                start = false;</span>
            }
        }
<span class="nc" id="L226">        return answer.toString();</span>
    }

    /**
      * Constructs a new instance of an unordered attribute with no value.
      *
      * @param id The attribute's id. It cannot be null.
      */
    public BasicAttribute(String id) {
<span class="fc" id="L235">        this(id, false);</span>
<span class="fc" id="L236">    }</span>

    /**
      * Constructs a new instance of an unordered attribute with a single value.
      *
      * @param id The attribute's id. It cannot be null.
      * @param value The attribute's value. If null, a null
      *        value is added to the attribute.
      */
    public BasicAttribute(String id, Object value) {
<span class="nc" id="L246">        this(id, value, false);</span>
<span class="nc" id="L247">    }</span>

    /**
      * Constructs a new instance of a possibly ordered attribute with no value.
      *
      * @param id The attribute's id. It cannot be null.
      * @param ordered true means the attribute's values will be ordered;
      * false otherwise.
      */
<span class="fc" id="L256">    public BasicAttribute(String id, boolean ordered) {</span>
<span class="fc" id="L257">        attrID = id;</span>
<span class="fc" id="L258">        values = new Vector&lt;&gt;();</span>
<span class="fc" id="L259">        this.ordered = ordered;</span>
<span class="fc" id="L260">    }</span>

    /**
      * Constructs a new instance of a possibly ordered attribute with a
      * single value.
      *
      * @param id The attribute's id. It cannot be null.
      * @param value The attribute's value. If null, a null
      *        value is added to the attribute.
      * @param ordered true means the attribute's values will be ordered;
      * false otherwise.
      */
    public BasicAttribute(String id, Object value, boolean ordered) {
<span class="nc" id="L273">        this(id, ordered);</span>
<span class="nc" id="L274">        values.addElement(value);</span>
<span class="nc" id="L275">    }</span>

    /**
      * Retrieves an enumeration of this attribute's values.
      *&lt;p&gt;
      * By default, the values returned are those passed to the
      * constructor and/or manipulated using the add/replace/remove methods.
      * A subclass may override this to retrieve the values dynamically
      * from the directory.
      */
    public NamingEnumeration&lt;?&gt; getAll() throws NamingException {
<span class="nc" id="L286">      return new ValuesEnumImpl();</span>
    }

    /**
      * Retrieves one of this attribute's values.
      *&lt;p&gt;
      * By default, the value returned is one of those passed to the
      * constructor and/or manipulated using the add/replace/remove methods.
      * A subclass may override this to retrieve the value dynamically
      * from the directory.
      */
    public Object get() throws NamingException {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (values.size() == 0) {</span>
<span class="nc" id="L299">            throw new</span>
<span class="nc" id="L300">        NoSuchElementException(&quot;Attribute &quot; + getID() + &quot; has no value&quot;);</span>
        } else {
<span class="nc" id="L302">            return values.elementAt(0);</span>
        }
    }

    public int size() {
<span class="fc" id="L307">      return values.size();</span>
    }

    public String getID() {
<span class="nc" id="L311">        return attrID;</span>
    }

    /**
      * Determines whether a value is in this attribute.
      *&lt;p&gt;
      * By default,
      * &lt;tt&gt;Object.equals()&lt;/tt&gt; is used when comparing &lt;tt&gt;attrVal&lt;/tt&gt;
      * with this attribute's values except when &lt;tt&gt;attrVal&lt;/tt&gt; is an array.
      * For an array, each element of the array is checked using
      * &lt;tt&gt;Object.equals()&lt;/tt&gt;.
      * A subclass may use schema information to determine equality.
      */
    public boolean contains(Object attrVal) {
<span class="nc bnc" id="L325" title="All 2 branches missed.">        return (find(attrVal) &gt;= 0);</span>
    }

    // For finding first element that has a null in JDK1.1 Vector.
    // In the Java 2 platform, can just replace this with Vector.indexOf(target);
    private int find(Object target) {
        Class&lt;?&gt; cl;
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L333">            int ct = values.size();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            for (int i = 0 ; i &lt; ct ; i++) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (values.elementAt(i) == null)</span>
<span class="nc" id="L336">                    return i;</span>
            }
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        } else if ((cl=target.getClass()).isArray()) {</span>
<span class="nc" id="L339">            int ct = values.size();</span>
            Object it;
<span class="nc bnc" id="L341" title="All 2 branches missed.">            for (int i = 0 ; i &lt; ct ; i++) {</span>
<span class="nc" id="L342">                it = values.elementAt(i);</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">                if (it != null &amp;&amp; cl == it.getClass()</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                    &amp;&amp; arrayEquals(target, it))</span>
<span class="nc" id="L345">                    return i;</span>
            }
<span class="nc" id="L347">        } else {</span>
<span class="fc" id="L348">            return values.indexOf(target, 0);</span>
        }
<span class="nc" id="L350">        return -1;  // not found</span>
    }

    /**
     * Determines whether two attribute values are equal.
     * Use arrayEquals for arrays and &lt;tt&gt;Object.equals()&lt;/tt&gt; otherwise.
     */
    private static boolean valueEquals(Object obj1, Object obj2) {
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (obj1 == obj2) {</span>
<span class="nc" id="L359">            return true; // object references are equal</span>
        }
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (obj1 == null) {</span>
<span class="nc" id="L362">            return false; // obj2 was not false</span>
        }
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (obj1.getClass().isArray() &amp;&amp;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            obj2.getClass().isArray()) {</span>
<span class="nc" id="L366">            return arrayEquals(obj1, obj2);</span>
        }
<span class="nc" id="L368">        return (obj1.equals(obj2));</span>
    }

    /**
     * Determines whether two arrays are equal by comparing each of their
     * elements using &lt;tt&gt;Object.equals()&lt;/tt&gt;.
     */
    private static boolean arrayEquals(Object a1, Object a2) {
        int len;
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if ((len = Array.getLength(a1)) != Array.getLength(a2))</span>
<span class="nc" id="L378">            return false;</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">        for (int j = 0; j &lt; len; j++) {</span>
<span class="nc" id="L381">            Object i1 = Array.get(a1, j);</span>
<span class="nc" id="L382">            Object i2 = Array.get(a2, j);</span>
<span class="nc bnc" id="L383" title="All 4 branches missed.">            if (i1 == null || i2 == null) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                if (i1 != i2)</span>
<span class="nc" id="L385">                    return false;</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            } else if (!i1.equals(i2)) {</span>
<span class="nc" id="L387">                return false;</span>
            }
        }
<span class="nc" id="L390">        return true;</span>
    }

    /**
      * Adds a new value to this attribute.
      *&lt;p&gt;
      * By default, &lt;tt&gt;Object.equals()&lt;/tt&gt; is used when comparing &lt;tt&gt;attrVal&lt;/tt&gt;
      * with this attribute's values except when &lt;tt&gt;attrVal&lt;/tt&gt; is an array.
      * For an array, each element of the array is checked using
      * &lt;tt&gt;Object.equals()&lt;/tt&gt;.
      * A subclass may use schema information to determine equality.
      */
    public boolean add(Object attrVal) {
<span class="pc bpc" id="L403" title="2 of 4 branches missed.">        if (isOrdered() || (find(attrVal) &lt; 0)) {</span>
<span class="fc" id="L404">            values.addElement(attrVal);</span>
<span class="fc" id="L405">            return true;</span>
        } else {
<span class="nc" id="L407">            return false;</span>
        }
    }

    /**
      * Removes a specified value from this attribute.
      *&lt;p&gt;
      * By default, &lt;tt&gt;Object.equals()&lt;/tt&gt; is used when comparing &lt;tt&gt;attrVal&lt;/tt&gt;
      * with this attribute's values except when &lt;tt&gt;attrVal&lt;/tt&gt; is an array.
      * For an array, each element of the array is checked using
      * &lt;tt&gt;Object.equals()&lt;/tt&gt;.
      * A subclass may use schema information to determine equality.
      */
    public boolean remove(Object attrval) {
        // For the Java 2 platform, can just use &quot;return removeElement(attrval);&quot;
        // Need to do the following to handle null case

<span class="nc" id="L424">        int i = find(attrval);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (i &gt;= 0) {</span>
<span class="nc" id="L426">            values.removeElementAt(i);</span>
<span class="nc" id="L427">            return true;</span>
        }
<span class="nc" id="L429">        return false;</span>
    }

    public void clear() {
<span class="nc" id="L433">        values.setSize(0);</span>
<span class="nc" id="L434">    }</span>

//  ---- ordering methods

    public boolean isOrdered() {
<span class="fc" id="L439">        return ordered;</span>
    }

    public Object get(int ix) throws NamingException {
<span class="fc" id="L443">        return values.elementAt(ix);</span>
    }

    public Object remove(int ix) {
<span class="nc" id="L447">        Object answer = values.elementAt(ix);</span>
<span class="nc" id="L448">        values.removeElementAt(ix);</span>
<span class="nc" id="L449">        return answer;</span>
    }

    public void add(int ix, Object attrVal) {
<span class="nc bnc" id="L453" title="All 4 branches missed.">        if (!isOrdered() &amp;&amp; contains(attrVal)) {</span>
<span class="nc" id="L454">            throw new IllegalStateException(</span>
                &quot;Cannot add duplicate to unordered attribute&quot;);
        }
<span class="nc" id="L457">        values.insertElementAt(attrVal, ix);</span>
<span class="nc" id="L458">    }</span>

    public Object set(int ix, Object attrVal) {
<span class="nc bnc" id="L461" title="All 4 branches missed.">        if (!isOrdered() &amp;&amp; contains(attrVal)) {</span>
<span class="nc" id="L462">            throw new IllegalStateException(</span>
                &quot;Cannot add duplicate to unordered attribute&quot;);
        }

<span class="nc" id="L466">        Object answer = values.elementAt(ix);</span>
<span class="nc" id="L467">        values.setElementAt(attrVal, ix);</span>
<span class="nc" id="L468">        return answer;</span>
    }

// ----------------- Schema methods

    /**
      * Retrieves the syntax definition associated with this attribute.
      *&lt;p&gt;
      * This method by default throws OperationNotSupportedException. A subclass
      * should override this method if it supports schema.
      */
    public DirContext getAttributeSyntaxDefinition() throws NamingException {
<span class="nc" id="L480">            throw new OperationNotSupportedException(&quot;attribute syntax&quot;);</span>
    }

    /**
      * Retrieves this attribute's schema definition.
      *&lt;p&gt;
      * This method by default throws OperationNotSupportedException. A subclass
      * should override this method if it supports schema.
      */
    public DirContext getAttributeDefinition() throws NamingException {
<span class="nc" id="L490">        throw new OperationNotSupportedException(&quot;attribute definition&quot;);</span>
    }


//  ---- serialization methods

    /**
     * Overridden to avoid exposing implementation details
     * @serialData Default field (the attribute ID -- a String),
     * followed by the number of values (an int), and the
     * individual values.
     */
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
<span class="nc" id="L504">        s.defaultWriteObject(); // write out the attrID</span>
<span class="nc" id="L505">        s.writeInt(values.size());</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        for (int i = 0; i &lt; values.size(); i++) {</span>
<span class="nc" id="L507">            s.writeObject(values.elementAt(i));</span>
        }
<span class="nc" id="L509">    }</span>

    /**
     * Overridden to avoid exposing implementation details.
     */
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L516">        s.defaultReadObject();  // read in the attrID</span>
<span class="nc" id="L517">        int n = s.readInt();    // number of values</span>
<span class="nc" id="L518">        values = new Vector&lt;&gt;(n);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        while (--n &gt;= 0) {</span>
<span class="nc" id="L520">            values.addElement(s.readObject());</span>
        }
<span class="nc" id="L522">    }</span>


    class ValuesEnumImpl implements NamingEnumeration&lt;Object&gt; {
        Enumeration&lt;Object&gt; list;

<span class="nc" id="L528">        ValuesEnumImpl() {</span>
<span class="nc" id="L529">            list = values.elements();</span>
<span class="nc" id="L530">        }</span>

        public boolean hasMoreElements() {
<span class="nc" id="L533">            return list.hasMoreElements();</span>
        }

        public Object nextElement() {
<span class="nc" id="L537">            return(list.nextElement());</span>
        }

        public Object next() throws NamingException {
<span class="nc" id="L541">            return list.nextElement();</span>
        }

        public boolean hasMore() throws NamingException {
<span class="nc" id="L545">            return list.hasMoreElements();</span>
        }

        public void close() throws NamingException {
<span class="nc" id="L549">            list = null;</span>
<span class="nc" id="L550">        }</span>
    }

    /**
     * Use serialVersionUID from JNDI 1.1.1 for interoperability.
     */
    private static final long serialVersionUID = 6743528196119291326L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>