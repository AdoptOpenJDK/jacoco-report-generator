<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Logger.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.logging</a> &gt; <span class="el_source">Logger.java</span></div><h1>Logger.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package java.util.logging;

import java.lang.ref.WeakReference;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Supplier;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;

/**
 * A Logger object is used to log messages for a specific
 * system or application component.  Loggers are normally named,
 * using a hierarchical dot-separated namespace.  Logger names
 * can be arbitrary strings, but they should normally be based on
 * the package name or class name of the logged component, such
 * as java.net or javax.swing.  In addition it is possible to create
 * &quot;anonymous&quot; Loggers that are not stored in the Logger namespace.
 * &lt;p&gt;
 * Logger objects may be obtained by calls on one of the getLogger
 * factory methods.  These will either create a new Logger or
 * return a suitable existing Logger. It is important to note that
 * the Logger returned by one of the {@code getLogger} factory methods
 * may be garbage collected at any time if a strong reference to the
 * Logger is not kept.
 * &lt;p&gt;
 * Logging messages will be forwarded to registered Handler
 * objects, which can forward the messages to a variety of
 * destinations, including consoles, files, OS logs, etc.
 * &lt;p&gt;
 * Each Logger keeps track of a &quot;parent&quot; Logger, which is its
 * nearest existing ancestor in the Logger namespace.
 * &lt;p&gt;
 * Each Logger has a &quot;Level&quot; associated with it.  This reflects
 * a minimum Level that this logger cares about.  If a Logger's
 * level is set to &lt;tt&gt;null&lt;/tt&gt;, then its effective level is inherited
 * from its parent, which may in turn obtain it recursively from its
 * parent, and so on up the tree.
 * &lt;p&gt;
 * The log level can be configured based on the properties from the
 * logging configuration file, as described in the description
 * of the LogManager class.  However it may also be dynamically changed
 * by calls on the Logger.setLevel method.  If a logger's level is
 * changed the change may also affect child loggers, since any child
 * logger that has &lt;tt&gt;null&lt;/tt&gt; as its level will inherit its
 * effective level from its parent.
 * &lt;p&gt;
 * On each logging call the Logger initially performs a cheap
 * check of the request level (e.g., SEVERE or FINE) against the
 * effective log level of the logger.  If the request level is
 * lower than the log level, the logging call returns immediately.
 * &lt;p&gt;
 * After passing this initial (cheap) test, the Logger will allocate
 * a LogRecord to describe the logging message.  It will then call a
 * Filter (if present) to do a more detailed check on whether the
 * record should be published.  If that passes it will then publish
 * the LogRecord to its output Handlers.  By default, loggers also
 * publish to their parent's Handlers, recursively up the tree.
 * &lt;p&gt;
 * Each Logger may have a {@code ResourceBundle} associated with it.
 * The {@code ResourceBundle} may be specified by name, using the
 * {@link #getLogger(java.lang.String, java.lang.String)} factory
 * method, or by value - using the {@link
 * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method.
 * This bundle will be used for localizing logging messages.
 * If a Logger does not have its own {@code ResourceBundle} or resource bundle
 * name, then it will inherit the {@code ResourceBundle} or resource bundle name
 * from its parent, recursively up the tree.
 * &lt;p&gt;
 * Most of the logger output methods take a &quot;msg&quot; argument.  This
 * msg argument may be either a raw value or a localization key.
 * During formatting, if the logger has (or inherits) a localization
 * {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for
 * the msg string, then the msg string is replaced by the localized value.
 * Otherwise the original msg string is used.  Typically, formatters use
 * java.text.MessageFormat style formatting to format parameters, so
 * for example a format string &quot;{0} {1}&quot; would format two parameters
 * as strings.
 * &lt;p&gt;
 * A set of methods alternatively take a &quot;msgSupplier&quot; instead of a &quot;msg&quot;
 * argument.  These methods take a {@link Supplier}{@code &lt;String&gt;} function
 * which is invoked to construct the desired log message only when the message
 * actually is to be logged based on the effective log level thus eliminating
 * unnecessary message construction. For example, if the developer wants to
 * log system health status for diagnosis, with the String-accepting version,
 * the code would look like:
 &lt;pre&gt;&lt;code&gt;

   class DiagnosisMessages {
     static String systemHealthStatus() {
       // collect system health information
       ...
     }
   }
   ...
   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());
&lt;/code&gt;&lt;/pre&gt;
 * With the above code, the health status is collected unnecessarily even when
 * the log level FINER is disabled. With the Supplier-accepting version as
 * below, the status will only be collected when the log level FINER is
 * enabled.
 &lt;pre&gt;&lt;code&gt;

   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);
&lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * When looking for a {@code ResourceBundle}, the logger will first look at
 * whether a bundle was specified using {@link
 * #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then
 * only whether a resource bundle name was specified through the {@link
 * #getLogger(java.lang.String, java.lang.String) getLogger} factory method.
 * If no {@code ResourceBundle} or no resource bundle name is found,
 * then it will use the nearest {@code ResourceBundle} or resource bundle
 * name inherited from its parent tree.&lt;br&gt;
 * When a {@code ResourceBundle} was inherited or specified through the
 * {@link
 * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then
 * that {@code ResourceBundle} will be used. Otherwise if the logger only
 * has or inherited a resource bundle name, then that resource bundle name
 * will be mapped to a {@code ResourceBundle} object, using the default Locale
 * at the time of logging.
 * &lt;br id=&quot;ResourceBundleMapping&quot;&gt;When mapping resource bundle names to
 * {@code ResourceBundle} objects, the logger will first try to use the
 * Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class
 * loader} to map the given resource bundle name to a {@code ResourceBundle}.
 * If the thread context class loader is {@code null}, it will try the
 * {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader}
 * instead.  If the {@code ResourceBundle} is still not found, it will use the
 * class loader of the first caller of the {@link
 * #getLogger(java.lang.String, java.lang.String) getLogger} factory method.
 * &lt;p&gt;
 * Formatting (including localization) is the responsibility of
 * the output Handler, which will typically call a Formatter.
 * &lt;p&gt;
 * Note that formatting need not occur synchronously.  It may be delayed
 * until a LogRecord is actually written to an external sink.
 * &lt;p&gt;
 * The logging methods are grouped in five main categories:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;p&gt;
 *     There are a set of &quot;log&quot; methods that take a log level, a message
 *     string, and optionally some parameters to the message string.
 * &lt;li&gt;&lt;p&gt;
 *     There are a set of &quot;logp&quot; methods (for &quot;log precise&quot;) that are
 *     like the &quot;log&quot; methods, but also take an explicit source class name
 *     and method name.
 * &lt;li&gt;&lt;p&gt;
 *     There are a set of &quot;logrb&quot; method (for &quot;log with resource bundle&quot;)
 *     that are like the &quot;logp&quot; method, but also take an explicit resource
 *     bundle object for use in localizing the log message.
 * &lt;li&gt;&lt;p&gt;
 *     There are convenience methods for tracing method entries (the
 *     &quot;entering&quot; methods), method returns (the &quot;exiting&quot; methods) and
 *     throwing exceptions (the &quot;throwing&quot; methods).
 * &lt;li&gt;&lt;p&gt;
 *     Finally, there are a set of convenience methods for use in the
 *     very simplest cases, when a developer simply wants to log a
 *     simple string at a given log level.  These methods are named
 *     after the standard Level names (&quot;severe&quot;, &quot;warning&quot;, &quot;info&quot;, etc.)
 *     and take a single argument, a message string.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * For the methods that do not take an explicit source name and
 * method name, the Logging framework will make a &quot;best effort&quot;
 * to determine which class and method called into the logging method.
 * However, it is important to realize that this automatically inferred
 * information may only be approximate (or may even be quite wrong!).
 * Virtual machines are allowed to do extensive optimizations when
 * JITing and may entirely remove stack frames, making it impossible
 * to reliably locate the calling class and method.
 * &lt;P&gt;
 * All methods on Logger are multi-thread safe.
 * &lt;p&gt;
 * &lt;b&gt;Subclassing Information:&lt;/b&gt; Note that a LogManager class may
 * provide its own implementation of named Loggers for any point in
 * the namespace.  Therefore, any subclasses of Logger (unless they
 * are implemented in conjunction with a new LogManager class) should
 * take care to obtain a Logger instance from the LogManager class and
 * should delegate operations such as &quot;isLoggable&quot; and &quot;log(LogRecord)&quot;
 * to that instance.  Note that in order to intercept all logging
 * output, subclasses need only override the log(LogRecord) method.
 * All the other logging methods are implemented as calls on this
 * log(LogRecord) method.
 *
 * @since 1.4
 */
public class Logger {
<span class="fc" id="L219">    private static final Handler emptyHandlers[] = new Handler[0];</span>
<span class="fc" id="L220">    private static final int offValue = Level.OFF.intValue();</span>
    private LogManager manager;
    private String name;
<span class="fc" id="L223">    private final CopyOnWriteArrayList&lt;Handler&gt; handlers =</span>
        new CopyOnWriteArrayList&lt;&gt;();
    private String resourceBundleName;  // Base name of the bundle.
    private ResourceBundle userBundle;  // Bundle set through setResourceBundle.
<span class="fc" id="L227">    private volatile boolean useParentHandlers = true;</span>
    private volatile Filter filter;
    private boolean anonymous;

    // Cache to speed up behavior of findResourceBundle:
    private ResourceBundle catalog;     // Cached resource bundle
    private String catalogName;         // name associated with catalog
    private Locale catalogLocale;       // locale associated with catalog

    // The fields relating to parent-child relationships and levels
    // are managed under a separate lock, the treeLock.
<span class="fc" id="L238">    private static final Object treeLock = new Object();</span>
    // We keep weak references from parents to children, but strong
    // references from children to parents.
    private volatile Logger parent;    // our nearest parent.
    private ArrayList&lt;LogManager.LoggerWeakRef&gt; kids;   // WeakReferences to loggers that have us as parent
    private volatile Level levelObject;
    private volatile int levelValue;  // current effective level value
    private WeakReference&lt;ClassLoader&gt; callersClassLoaderRef;

    /**
     * GLOBAL_LOGGER_NAME is a name for the global logger.
     *
     * @since 1.6
     */
    public static final String GLOBAL_LOGGER_NAME = &quot;global&quot;;

    /**
     * Return global logger object with the name Logger.GLOBAL_LOGGER_NAME.
     *
     * @return global logger object
     * @since 1.7
     */
    public static final Logger getGlobal() {
        // In order to break a cyclic dependence between the LogManager
        // and Logger static initializers causing deadlocks, the global
        // logger is created with a special constructor that does not
        // initialize its log manager.
        //
        // If an application calls Logger.getGlobal() before any logger
        // has been initialized, it is therefore possible that the
        // LogManager class has not been initialized yet, and therefore
        // Logger.global.manager will be null.
        //
        // In order to finish the initialization of the global logger, we
        // will therefore call LogManager.getLogManager() here.
        //
        // To prevent race conditions we also need to call
        // LogManager.getLogManager() unconditionally here.
        // Indeed we cannot rely on the observed value of global.manager,
        // because global.manager will become not null somewhere during
        // the initialization of LogManager.
        // If two threads are calling getGlobal() concurrently, one thread
        // will see global.manager null and call LogManager.getLogManager(),
        // but the other thread could come in at a time when global.manager
        // is already set although ensureLogManagerInitialized is not finished
        // yet...
        // Calling LogManager.getLogManager() unconditionally will fix that.

<span class="fc" id="L286">        LogManager.getLogManager();</span>

        // Now the global LogManager should be initialized,
        // and the global logger should have been added to
        // it, unless we were called within the constructor of a LogManager
        // subclass installed as LogManager, in which case global.manager
        // would still be null, and global will be lazily initialized later on.

<span class="fc" id="L294">        return global;</span>
    }

    /**
     * The &quot;global&quot; Logger object is provided as a convenience to developers
     * who are making casual use of the Logging package.  Developers
     * who are making serious use of the logging package (for example
     * in products) should create and use their own Logger objects,
     * with appropriate names, so that logging can be controlled on a
     * suitable per-Logger granularity. Developers also need to keep a
     * strong reference to their Logger objects to prevent them from
     * being garbage collected.
     * &lt;p&gt;
     * @deprecated Initialization of this field is prone to deadlocks.
     * The field must be initialized by the Logger class initialization
     * which may cause deadlocks with the LogManager class initialization.
     * In such cases two class initialization wait for each other to complete.
     * The preferred way to get the global logger object is via the call
     * &lt;code&gt;Logger.getGlobal()&lt;/code&gt;.
     * For compatibility with old JDK versions where the
     * &lt;code&gt;Logger.getGlobal()&lt;/code&gt; is not available use the call
     * &lt;code&gt;Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)&lt;/code&gt;
     * or &lt;code&gt;Logger.getLogger(&quot;global&quot;)&lt;/code&gt;.
     */
    @Deprecated
<span class="fc" id="L319">    public static final Logger global = new Logger(GLOBAL_LOGGER_NAME);</span>

    /**
     * Protected method to construct a logger for a named subsystem.
     * &lt;p&gt;
     * The logger will be initially configured with a null Level
     * and with useParentHandlers set to true.
     *
     * @param   name    A name for the logger.  This should
     *                          be a dot-separated name and should normally
     *                          be based on the package name or class name
     *                          of the subsystem, such as java.net
     *                          or javax.swing.  It may be null for anonymous Loggers.
     * @param   resourceBundleName  name of ResourceBundle to be used for localizing
     *                          messages for this logger.  May be null if none
     *                          of the messages require localization.
     * @throws MissingResourceException if the resourceBundleName is non-null and
     *             no corresponding resource can be found.
     */
    protected Logger(String name, String resourceBundleName) {
<span class="fc" id="L339">        this(name, resourceBundleName, null, LogManager.getLogManager());</span>
<span class="fc" id="L340">    }</span>

<span class="fc" id="L342">    Logger(String name, String resourceBundleName, Class&lt;?&gt; caller, LogManager manager) {</span>
<span class="fc" id="L343">        this.manager = manager;</span>
<span class="fc" id="L344">        setupResourceInfo(resourceBundleName, caller);</span>
<span class="fc" id="L345">        this.name = name;</span>
<span class="fc" id="L346">        levelValue = Level.INFO.intValue();</span>
<span class="fc" id="L347">    }</span>

    private void setCallersClassLoaderRef(Class&lt;?&gt; caller) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">        ClassLoader callersClassLoader = ((caller != null)</span>
<span class="fc" id="L351">                                         ? caller.getClassLoader()</span>
                                         : null);
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (callersClassLoader != null) {</span>
<span class="fc" id="L354">            this.callersClassLoaderRef = new WeakReference&lt;&gt;(callersClassLoader);</span>
        }
<span class="fc" id="L356">    }</span>

    private ClassLoader getCallersClassLoader() {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        return (callersClassLoaderRef != null)</span>
<span class="fc" id="L360">                ? callersClassLoaderRef.get()</span>
                : null;
    }

    // This constructor is used only to create the global Logger.
    // It is needed to break a cyclic dependence between the LogManager
    // and Logger static initializers causing deadlocks.
<span class="fc" id="L367">    private Logger(String name) {</span>
        // The manager field is not initialized here.
<span class="fc" id="L369">        this.name = name;</span>
<span class="fc" id="L370">        levelValue = Level.INFO.intValue();</span>
<span class="fc" id="L371">    }</span>

    // It is called from LoggerContext.addLocalLogger() when the logger
    // is actually added to a LogManager.
    void setLogManager(LogManager manager) {
<span class="fc" id="L376">        this.manager = manager;</span>
<span class="fc" id="L377">    }</span>

    private void checkPermission() throws SecurityException {
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (!anonymous) {</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (manager == null) {</span>
                // Complete initialization of the global Logger.
<span class="nc" id="L383">                manager = LogManager.getLogManager();</span>
            }
<span class="fc" id="L385">            manager.checkPermission();</span>
        }
<span class="fc" id="L387">    }</span>

    // Until all JDK code converted to call sun.util.logging.PlatformLogger
    // (see 7054233), we need to determine if Logger.getLogger is to add
    // a system logger or user logger.
    //
    // As an interim solution, if the immediate caller whose caller loader is
    // null, we assume it's a system logger and add it to the system context.
    // These system loggers only set the resource bundle to the given
    // resource bundle name (rather than the default system resource bundle).
<span class="nc" id="L397">    private static class SystemLoggerHelper {</span>
<span class="fc" id="L398">        static boolean disableCallerCheck = getBooleanProperty(&quot;sun.util.logging.disableCallerCheck&quot;);</span>
        private static boolean getBooleanProperty(final String key) {
<span class="fc" id="L400">            String s = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
                @Override
                public String run() {
<span class="fc" id="L403">                    return System.getProperty(key);</span>
                }
            });
<span class="fc" id="L406">            return Boolean.valueOf(s);</span>
        }
    }

    private static Logger demandLogger(String name, String resourceBundleName, Class&lt;?&gt; caller) {
<span class="fc" id="L411">        LogManager manager = LogManager.getLogManager();</span>
<span class="fc" id="L412">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L413" title="1 of 4 branches missed.">        if (sm != null &amp;&amp; !SystemLoggerHelper.disableCallerCheck) {</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (caller.getClassLoader() == null) {</span>
<span class="fc" id="L415">                return manager.demandSystemLogger(name, resourceBundleName);</span>
            }
        }
<span class="fc" id="L418">        return manager.demandLogger(name, resourceBundleName, caller);</span>
        // ends up calling new Logger(name, resourceBundleName, caller)
        // iff the logger doesn't exist already
    }

    /**
     * Find or create a logger for a named subsystem.  If a logger has
     * already been created with the given name it is returned.  Otherwise
     * a new logger is created.
     * &lt;p&gt;
     * If a new logger is created its log level will be configured
     * based on the LogManager configuration and it will configured
     * to also send logging output to its parent's Handlers.  It will
     * be registered in the LogManager global namespace.
     * &lt;p&gt;
     * Note: The LogManager may only retain a weak reference to the newly
     * created Logger. It is important to understand that a previously
     * created Logger with the given name may be garbage collected at any
     * time if there is no strong reference to the Logger. In particular,
     * this means that two back-to-back calls like
     * {@code getLogger(&quot;MyLogger&quot;).log(...)} may use different Logger
     * objects named &quot;MyLogger&quot; if there is no strong reference to the
     * Logger named &quot;MyLogger&quot; elsewhere in the program.
     *
     * @param   name            A name for the logger.  This should
     *                          be a dot-separated name and should normally
     *                          be based on the package name or class name
     *                          of the subsystem, such as java.net
     *                          or javax.swing
     * @return a suitable Logger
     * @throws NullPointerException if the name is null.
     */

    // Synchronization is not required here. All synchronization for
    // adding a new Logger object is handled by LogManager.addLogger().
    @CallerSensitive
    public static Logger getLogger(String name) {
        // This method is intentionally not a wrapper around a call
        // to getLogger(name, resourceBundleName). If it were then
        // this sequence:
        //
        //     getLogger(&quot;JDK&quot;, &quot;resourceBundleForJDK&quot;);
        //     getLogger(&quot;JDK&quot;);
        //
        // would throw an IllegalArgumentException in the second call
        // because the wrapper would result in an attempt to replace
        // the existing &quot;resourceBundleForJDK&quot; with null.
<span class="fc" id="L465">        return demandLogger(name, null, Reflection.getCallerClass());</span>
    }

    /**
     * Find or create a logger for a named subsystem.  If a logger has
     * already been created with the given name it is returned.  Otherwise
     * a new logger is created.
     * &lt;p&gt;
     * If a new logger is created its log level will be configured
     * based on the LogManager and it will configured to also send logging
     * output to its parent's Handlers.  It will be registered in
     * the LogManager global namespace.
     * &lt;p&gt;
     * Note: The LogManager may only retain a weak reference to the newly
     * created Logger. It is important to understand that a previously
     * created Logger with the given name may be garbage collected at any
     * time if there is no strong reference to the Logger. In particular,
     * this means that two back-to-back calls like
     * {@code getLogger(&quot;MyLogger&quot;, ...).log(...)} may use different Logger
     * objects named &quot;MyLogger&quot; if there is no strong reference to the
     * Logger named &quot;MyLogger&quot; elsewhere in the program.
     * &lt;p&gt;
     * If the named Logger already exists and does not yet have a
     * localization resource bundle then the given resource bundle
     * name is used.  If the named Logger already exists and has
     * a different resource bundle name then an IllegalArgumentException
     * is thrown.
     * &lt;p&gt;
     * @param   name    A name for the logger.  This should
     *                          be a dot-separated name and should normally
     *                          be based on the package name or class name
     *                          of the subsystem, such as java.net
     *                          or javax.swing
     * @param   resourceBundleName  name of ResourceBundle to be used for localizing
     *                          messages for this logger. May be {@code null}
     *                          if none of the messages require localization.
     * @return a suitable Logger
     * @throws MissingResourceException if the resourceBundleName is non-null and
     *             no corresponding resource can be found.
     * @throws IllegalArgumentException if the Logger already exists and uses
     *             a different resource bundle name; or if
     *             {@code resourceBundleName} is {@code null} but the named
     *             logger has a resource bundle set.
     * @throws NullPointerException if the name is null.
     */

    // Synchronization is not required here. All synchronization for
    // adding a new Logger object is handled by LogManager.addLogger().
    @CallerSensitive
    public static Logger getLogger(String name, String resourceBundleName) {
<span class="fc" id="L515">        Class&lt;?&gt; callerClass = Reflection.getCallerClass();</span>
<span class="fc" id="L516">        Logger result = demandLogger(name, resourceBundleName, callerClass);</span>

        // MissingResourceException or IllegalArgumentException can be
        // thrown by setupResourceInfo().
        // We have to set the callers ClassLoader here in case demandLogger
        // above found a previously created Logger.  This can happen, for
        // example, if Logger.getLogger(name) is called and subsequently
        // Logger.getLogger(name, resourceBundleName) is called.  In this case
        // we won't necessarily have the correct classloader saved away, so
        // we need to set it here, too.

<span class="fc" id="L527">        result.setupResourceInfo(resourceBundleName, callerClass);</span>
<span class="fc" id="L528">        return result;</span>
    }

    // package-private
    // Add a platform logger to the system context.
    // i.e. caller of sun.util.logging.PlatformLogger.getLogger
    static Logger getPlatformLogger(String name) {
<span class="fc" id="L535">        LogManager manager = LogManager.getLogManager();</span>

        // all loggers in the system context will default to
        // the system logger's resource bundle
<span class="fc" id="L539">        Logger result = manager.demandSystemLogger(name, SYSTEM_LOGGER_RB_NAME);</span>
<span class="fc" id="L540">        return result;</span>
    }

    /**
     * Create an anonymous Logger.  The newly created Logger is not
     * registered in the LogManager namespace.  There will be no
     * access checks on updates to the logger.
     * &lt;p&gt;
     * This factory method is primarily intended for use from applets.
     * Because the resulting Logger is anonymous it can be kept private
     * by the creating class.  This removes the need for normal security
     * checks, which in turn allows untrusted applet code to update
     * the control state of the Logger.  For example an applet can do
     * a setLevel or an addHandler on an anonymous Logger.
     * &lt;p&gt;
     * Even although the new logger is anonymous, it is configured
     * to have the root logger (&quot;&quot;) as its parent.  This means that
     * by default it inherits its effective level and handlers
     * from the root logger. Changing its parent via the
     * {@link #setParent(java.util.logging.Logger) setParent} method
     * will still require the security permission specified by that method.
     * &lt;p&gt;
     *
     * @return a newly created private Logger
     */
    public static Logger getAnonymousLogger() {
<span class="fc" id="L566">        return getAnonymousLogger(null);</span>
    }

    /**
     * Create an anonymous Logger.  The newly created Logger is not
     * registered in the LogManager namespace.  There will be no
     * access checks on updates to the logger.
     * &lt;p&gt;
     * This factory method is primarily intended for use from applets.
     * Because the resulting Logger is anonymous it can be kept private
     * by the creating class.  This removes the need for normal security
     * checks, which in turn allows untrusted applet code to update
     * the control state of the Logger.  For example an applet can do
     * a setLevel or an addHandler on an anonymous Logger.
     * &lt;p&gt;
     * Even although the new logger is anonymous, it is configured
     * to have the root logger (&quot;&quot;) as its parent.  This means that
     * by default it inherits its effective level and handlers
     * from the root logger.  Changing its parent via the
     * {@link #setParent(java.util.logging.Logger) setParent} method
     * will still require the security permission specified by that method.
     * &lt;p&gt;
     * @param   resourceBundleName  name of ResourceBundle to be used for localizing
     *                          messages for this logger.
     *          May be null if none of the messages require localization.
     * @return a newly created private Logger
     * @throws MissingResourceException if the resourceBundleName is non-null and
     *             no corresponding resource can be found.
     */

    // Synchronization is not required here. All synchronization for
    // adding a new anonymous Logger object is handled by doSetParent().
    @CallerSensitive
    public static Logger getAnonymousLogger(String resourceBundleName) {
<span class="fc" id="L600">        LogManager manager = LogManager.getLogManager();</span>
        // cleanup some Loggers that have been GC'ed
<span class="fc" id="L602">        manager.drainLoggerRefQueueBounded();</span>
<span class="fc" id="L603">        Logger result = new Logger(null, resourceBundleName,</span>
<span class="fc" id="L604">                                   Reflection.getCallerClass(), manager);</span>
<span class="fc" id="L605">        result.anonymous = true;</span>
<span class="fc" id="L606">        Logger root = manager.getLogger(&quot;&quot;);</span>
<span class="fc" id="L607">        result.doSetParent(root);</span>
<span class="fc" id="L608">        return result;</span>
    }

    /**
     * Retrieve the localization resource bundle for this
     * logger.
     * This method will return a {@code ResourceBundle} that was either
     * set by the {@link
     * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method or
     * &lt;a href=&quot;#ResourceBundleMapping&quot;&gt;mapped from the
     * the resource bundle name&lt;/a&gt; set via the {@link
     * Logger#getLogger(java.lang.String, java.lang.String) getLogger} factory
     * method for the current default locale.
     * &lt;br&gt;Note that if the result is {@code null}, then the Logger will use a resource
     * bundle or resource bundle name inherited from its parent.
     *
     * @return localization bundle (may be {@code null})
     */
    public ResourceBundle getResourceBundle() {
<span class="fc" id="L627">        return findResourceBundle(getResourceBundleName(), true);</span>
    }

    /**
     * Retrieve the localization resource bundle name for this
     * logger.
     * This is either the name specified through the {@link
     * #getLogger(java.lang.String, java.lang.String) getLogger} factory method,
     * or the {@linkplain ResourceBundle#getBaseBundleName() base name} of the
     * ResourceBundle set through {@link
     * #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method.
     * &lt;br&gt;Note that if the result is {@code null}, then the Logger will use a resource
     * bundle or resource bundle name inherited from its parent.
     *
     * @return localization bundle name (may be {@code null})
     */
    public String getResourceBundleName() {
<span class="fc" id="L644">        return resourceBundleName;</span>
    }

    /**
     * Set a filter to control output on this Logger.
     * &lt;P&gt;
     * After passing the initial &quot;level&quot; check, the Logger will
     * call this Filter to check if a log record should really
     * be published.
     *
     * @param   newFilter  a filter object (may be null)
     * @throws  SecurityException if a security manager exists,
     *          this logger is not anonymous, and the caller
     *          does not have LoggingPermission(&quot;control&quot;).
     */
    public void setFilter(Filter newFilter) throws SecurityException {
<span class="fc" id="L660">        checkPermission();</span>
<span class="fc" id="L661">        filter = newFilter;</span>
<span class="fc" id="L662">    }</span>

    /**
     * Get the current filter for this Logger.
     *
     * @return  a filter object (may be null)
     */
    public Filter getFilter() {
<span class="fc" id="L670">        return filter;</span>
    }

    /**
     * Log a LogRecord.
     * &lt;p&gt;
     * All the other logging methods in this class call through
     * this method to actually perform any logging.  Subclasses can
     * override this single method to capture all log activity.
     *
     * @param record the LogRecord to be published
     */
    public void log(LogRecord record) {
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">        if (!isLoggable(record.getLevel())) {</span>
<span class="nc" id="L684">            return;</span>
        }
<span class="fc" id="L686">        Filter theFilter = filter;</span>
<span class="pc bpc" id="L687" title="3 of 4 branches missed.">        if (theFilter != null &amp;&amp; !theFilter.isLoggable(record)) {</span>
<span class="nc" id="L688">            return;</span>
        }

        // Post the LogRecord to all our Handlers, and then to
        // our parents' handlers, all the way up the tree.

<span class="fc" id="L694">        Logger logger = this;</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">        while (logger != null) {</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">            for (Handler handler : logger.getHandlers()) {</span>
<span class="fc" id="L697">                handler.publish(record);</span>
            }

<span class="fc bfc" id="L700" title="All 2 branches covered.">            if (!logger.getUseParentHandlers()) {</span>
<span class="fc" id="L701">                break;</span>
            }

<span class="fc" id="L704">            logger = logger.getParent();</span>
        }
<span class="fc" id="L706">    }</span>

    // private support method for logging.
    // We fill in the logger name, resource bundle name, and
    // resource bundle and then call &quot;void log(LogRecord)&quot;.
    private void doLog(LogRecord lr) {
<span class="fc" id="L712">        lr.setLoggerName(name);</span>
<span class="fc" id="L713">        final ResourceBundle bundle = getEffectiveResourceBundle();</span>
<span class="fc" id="L714">        final String ebname = getEffectiveResourceBundleName();</span>
<span class="fc bfc" id="L715" title="All 4 branches covered.">        if (ebname != null &amp;&amp; bundle != null) {</span>
<span class="fc" id="L716">            lr.setResourceBundleName(ebname);</span>
<span class="fc" id="L717">            lr.setResourceBundle(bundle);</span>
        }
<span class="fc" id="L719">        log(lr);</span>
<span class="fc" id="L720">    }</span>


    //================================================================
    // Start of convenience methods WITHOUT className and methodName
    //================================================================

    /**
     * Log a message, with no arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void log(Level level, String msg) {
<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L739">            return;</span>
        }
<span class="fc" id="L741">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L742">        doLog(lr);</span>
<span class="fc" id="L743">    }</span>

    /**
     * Log a message, which is only to be constructed if the logging level
     * is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     */
    public void log(Level level, Supplier&lt;String&gt; msgSupplier) {
<span class="nc bnc" id="L759" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L760">            return;</span>
        }
<span class="nc" id="L762">        LogRecord lr = new LogRecord(level, msgSupplier.get());</span>
<span class="nc" id="L763">        doLog(lr);</span>
<span class="nc" id="L764">    }</span>

    /**
     * Log a message, with one object parameter.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   msg     The string message (or a key in the message catalog)
     * @param   param1  parameter to the message
     */
    public void log(Level level, String msg, Object param1) {
<span class="fc bfc" id="L778" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L779">            return;</span>
        }
<span class="fc" id="L781">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L782">        Object params[] = { param1 };</span>
<span class="fc" id="L783">        lr.setParameters(params);</span>
<span class="fc" id="L784">        doLog(lr);</span>
<span class="fc" id="L785">    }</span>

    /**
     * Log a message, with an array of object arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   msg     The string message (or a key in the message catalog)
     * @param   params  array of parameters to the message
     */
    public void log(Level level, String msg, Object params[]) {
<span class="fc bfc" id="L799" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L800">            return;</span>
        }
<span class="fc" id="L802">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L803">        lr.setParameters(params);</span>
<span class="fc" id="L804">        doLog(lr);</span>
<span class="fc" id="L805">    }</span>

    /**
     * Log a message, with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given arguments are stored in a LogRecord
     * which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   msg     The string message (or a key in the message catalog)
     * @param   thrown  Throwable associated with log message.
     */
    public void log(Level level, String msg, Throwable thrown) {
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L825">            return;</span>
        }
<span class="fc" id="L827">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L828">        lr.setThrown(thrown);</span>
<span class="fc" id="L829">        doLog(lr);</span>
<span class="fc" id="L830">    }</span>

    /**
     * Log a lazily constructed message, with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message level then the
     * message is constructed by invoking the provided supplier function. The
     * message and the given {@link Throwable} are then stored in a {@link
     * LogRecord} which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   thrown  Throwable associated with log message.
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void log(Level level, Throwable thrown, Supplier&lt;String&gt; msgSupplier) {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L853">            return;</span>
        }
<span class="nc" id="L855">        LogRecord lr = new LogRecord(level, msgSupplier.get());</span>
<span class="nc" id="L856">        lr.setThrown(thrown);</span>
<span class="nc" id="L857">        doLog(lr);</span>
<span class="nc" id="L858">    }</span>

    //================================================================
    // Start of convenience methods WITH className and methodName
    //================================================================

    /**
     * Log a message, specifying source class and method,
     * with no arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void logp(Level level, String sourceClass, String sourceMethod, String msg) {
<span class="fc bfc" id="L878" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L879">            return;</span>
        }
<span class="fc" id="L881">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L882">        lr.setSourceClassName(sourceClass);</span>
<span class="fc" id="L883">        lr.setSourceMethodName(sourceMethod);</span>
<span class="fc" id="L884">        doLog(lr);</span>
<span class="fc" id="L885">    }</span>

    /**
     * Log a lazily constructed message, specifying source class and method,
     * with no arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void logp(Level level, String sourceClass, String sourceMethod,
                     Supplier&lt;String&gt; msgSupplier) {
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L906">            return;</span>
        }
<span class="nc" id="L908">        LogRecord lr = new LogRecord(level, msgSupplier.get());</span>
<span class="nc" id="L909">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L910">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L911">        doLog(lr);</span>
<span class="nc" id="L912">    }</span>

    /**
     * Log a message, specifying source class and method,
     * with a single object parameter to the log message.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   msg      The string message (or a key in the message catalog)
     * @param   param1    Parameter to the log message.
     */
    public void logp(Level level, String sourceClass, String sourceMethod,
                                                String msg, Object param1) {
<span class="fc bfc" id="L930" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L931">            return;</span>
        }
<span class="fc" id="L933">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L934">        lr.setSourceClassName(sourceClass);</span>
<span class="fc" id="L935">        lr.setSourceMethodName(sourceMethod);</span>
<span class="fc" id="L936">        Object params[] = { param1 };</span>
<span class="fc" id="L937">        lr.setParameters(params);</span>
<span class="fc" id="L938">        doLog(lr);</span>
<span class="fc" id="L939">    }</span>

    /**
     * Log a message, specifying source class and method,
     * with an array of object arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   msg     The string message (or a key in the message catalog)
     * @param   params  Array of parameters to the message
     */
    public void logp(Level level, String sourceClass, String sourceMethod,
                                                String msg, Object params[]) {
<span class="fc bfc" id="L957" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L958">            return;</span>
        }
<span class="fc" id="L960">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L961">        lr.setSourceClassName(sourceClass);</span>
<span class="fc" id="L962">        lr.setSourceMethodName(sourceMethod);</span>
<span class="fc" id="L963">        lr.setParameters(params);</span>
<span class="fc" id="L964">        doLog(lr);</span>
<span class="fc" id="L965">    }</span>

    /**
     * Log a message, specifying source class and method,
     * with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given arguments are stored in a LogRecord
     * which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   msg     The string message (or a key in the message catalog)
     * @param   thrown  Throwable associated with log message.
     */
    public void logp(Level level, String sourceClass, String sourceMethod,
                     String msg, Throwable thrown) {
<span class="fc bfc" id="L988" title="All 2 branches covered.">        if (!isLoggable(level)) {</span>
<span class="fc" id="L989">            return;</span>
        }
<span class="fc" id="L991">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="fc" id="L992">        lr.setSourceClassName(sourceClass);</span>
<span class="fc" id="L993">        lr.setSourceMethodName(sourceMethod);</span>
<span class="fc" id="L994">        lr.setThrown(thrown);</span>
<span class="fc" id="L995">        doLog(lr);</span>
<span class="fc" id="L996">    }</span>

    /**
     * Log a lazily constructed message, specifying source class and method,
     * with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message level then the
     * message is constructed by invoking the provided supplier function. The
     * message and the given {@link Throwable} are then stored in a {@link
     * LogRecord} which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   thrown  Throwable associated with log message.
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void logp(Level level, String sourceClass, String sourceMethod,
                     Throwable thrown, Supplier&lt;String&gt; msgSupplier) {
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1023">            return;</span>
        }
<span class="nc" id="L1025">        LogRecord lr = new LogRecord(level, msgSupplier.get());</span>
<span class="nc" id="L1026">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1027">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1028">        lr.setThrown(thrown);</span>
<span class="nc" id="L1029">        doLog(lr);</span>
<span class="nc" id="L1030">    }</span>


    //=========================================================================
    // Start of convenience methods WITH className, methodName and bundle name.
    //=========================================================================

    // Private support method for logging for &quot;logrb&quot; methods.
    // We fill in the logger name, resource bundle name, and
    // resource bundle and then call &quot;void log(LogRecord)&quot;.
    private void doLog(LogRecord lr, String rbname) {
<span class="nc" id="L1041">        lr.setLoggerName(name);</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (rbname != null) {</span>
<span class="nc" id="L1043">            lr.setResourceBundleName(rbname);</span>
<span class="nc" id="L1044">            lr.setResourceBundle(findResourceBundle(rbname, false));</span>
        }
<span class="nc" id="L1046">        log(lr);</span>
<span class="nc" id="L1047">    }</span>

    // Private support method for logging for &quot;logrb&quot; methods.
    private void doLog(LogRecord lr, ResourceBundle rb) {
<span class="nc" id="L1051">        lr.setLoggerName(name);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        if (rb != null) {</span>
<span class="nc" id="L1053">            lr.setResourceBundleName(rb.getBaseBundleName());</span>
<span class="nc" id="L1054">            lr.setResourceBundle(rb);</span>
        }
<span class="nc" id="L1056">        log(lr);</span>
<span class="nc" id="L1057">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle name
     * with no arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * The msg string is localized using the named resource bundle.  If the
     * resource bundle name is null, or an empty String or invalid
     * then the msg string is not localized.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   bundleName     name of resource bundle to localize msg,
     *                         can be null
     * @param   msg     The string message (or a key in the message catalog)
     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,
     * java.lang.String, java.util.ResourceBundle, java.lang.String,
     * java.lang.Object...)} instead.
     */
    @Deprecated
    public void logrb(Level level, String sourceClass, String sourceMethod,
                                String bundleName, String msg) {
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1085">            return;</span>
        }
<span class="nc" id="L1087">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1088">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1089">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1090">        doLog(lr, bundleName);</span>
<span class="nc" id="L1091">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle name,
     * with a single object parameter to the log message.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * The msg string is localized using the named resource bundle.  If the
     * resource bundle name is null, or an empty String or invalid
     * then the msg string is not localized.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   bundleName     name of resource bundle to localize msg,
     *                         can be null
     * @param   msg      The string message (or a key in the message catalog)
     * @param   param1    Parameter to the log message.
     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,
     *   java.lang.String, java.util.ResourceBundle, java.lang.String,
     *   java.lang.Object...)} instead
     */
    @Deprecated
    public void logrb(Level level, String sourceClass, String sourceMethod,
                                String bundleName, String msg, Object param1) {
<span class="nc bnc" id="L1119" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1120">            return;</span>
        }
<span class="nc" id="L1122">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1123">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1124">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1125">        Object params[] = { param1 };</span>
<span class="nc" id="L1126">        lr.setParameters(params);</span>
<span class="nc" id="L1127">        doLog(lr, bundleName);</span>
<span class="nc" id="L1128">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle name,
     * with an array of object arguments.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * The msg string is localized using the named resource bundle.  If the
     * resource bundle name is null, or an empty String or invalid
     * then the msg string is not localized.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   bundleName     name of resource bundle to localize msg,
     *                         can be null.
     * @param   msg     The string message (or a key in the message catalog)
     * @param   params  Array of parameters to the message
     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,
     *      java.lang.String, java.util.ResourceBundle, java.lang.String,
     *      java.lang.Object...)} instead.
     */
    @Deprecated
    public void logrb(Level level, String sourceClass, String sourceMethod,
                                String bundleName, String msg, Object params[]) {
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1157">            return;</span>
        }
<span class="nc" id="L1159">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1160">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1161">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1162">        lr.setParameters(params);</span>
<span class="nc" id="L1163">        doLog(lr, bundleName);</span>
<span class="nc" id="L1164">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle,
     * with an optional list of message parameters.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then a corresponding LogRecord is created and forwarded
     * to all the registered output Handler objects.
     * &lt;p&gt;
     * The {@code msg} string is localized using the given resource bundle.
     * If the resource bundle is {@code null}, then the {@code msg} string is not
     * localized.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    Name of the class that issued the logging request
     * @param   sourceMethod   Name of the method that issued the logging request
     * @param   bundle         Resource bundle to localize {@code msg},
     *                         can be {@code null}.
     * @param   msg     The string message (or a key in the message catalog)
     * @param   params  Parameters to the message (optional, may be none).
     * @since 1.8
     */
    public void logrb(Level level, String sourceClass, String sourceMethod,
                      ResourceBundle bundle, String msg, Object... params) {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1190">            return;</span>
        }
<span class="nc" id="L1192">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1193">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1194">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc bnc" id="L1195" title="All 4 branches missed.">        if (params != null &amp;&amp; params.length != 0) {</span>
<span class="nc" id="L1196">            lr.setParameters(params);</span>
        }
<span class="nc" id="L1198">        doLog(lr, bundle);</span>
<span class="nc" id="L1199">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle name,
     * with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given arguments are stored in a LogRecord
     * which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * The msg string is localized using the named resource bundle.  If the
     * resource bundle name is null, or an empty String or invalid
     * then the msg string is not localized.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that issued the logging request
     * @param   bundleName     name of resource bundle to localize msg,
     *                         can be null
     * @param   msg     The string message (or a key in the message catalog)
     * @param   thrown  Throwable associated with log message.
     * @deprecated Use {@link #logrb(java.util.logging.Level, java.lang.String,
     *     java.lang.String, java.util.ResourceBundle, java.lang.String,
     *     java.lang.Throwable)} instead.
     */
    @Deprecated
    public void logrb(Level level, String sourceClass, String sourceMethod,
                                        String bundleName, String msg, Throwable thrown) {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1233">            return;</span>
        }
<span class="nc" id="L1235">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1236">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1237">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1238">        lr.setThrown(thrown);</span>
<span class="nc" id="L1239">        doLog(lr, bundleName);</span>
<span class="nc" id="L1240">    }</span>

    /**
     * Log a message, specifying source class, method, and resource bundle,
     * with associated Throwable information.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given arguments are stored in a LogRecord
     * which is forwarded to all registered output handlers.
     * &lt;p&gt;
     * The {@code msg} string is localized using the given resource bundle.
     * If the resource bundle is {@code null}, then the {@code msg} string is not
     * localized.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   level   One of the message level identifiers, e.g., SEVERE
     * @param   sourceClass    Name of the class that issued the logging request
     * @param   sourceMethod   Name of the method that issued the logging request
     * @param   bundle         Resource bundle to localize {@code msg},
     *                         can be {@code null}
     * @param   msg     The string message (or a key in the message catalog)
     * @param   thrown  Throwable associated with the log message.
     * @since 1.8
     */
    public void logrb(Level level, String sourceClass, String sourceMethod,
                      ResourceBundle bundle, String msg, Throwable thrown) {
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        if (!isLoggable(level)) {</span>
<span class="nc" id="L1271">            return;</span>
        }
<span class="nc" id="L1273">        LogRecord lr = new LogRecord(level, msg);</span>
<span class="nc" id="L1274">        lr.setSourceClassName(sourceClass);</span>
<span class="nc" id="L1275">        lr.setSourceMethodName(sourceMethod);</span>
<span class="nc" id="L1276">        lr.setThrown(thrown);</span>
<span class="nc" id="L1277">        doLog(lr, bundle);</span>
<span class="nc" id="L1278">    }</span>

    //======================================================================
    // Start of convenience methods for logging method entries and returns.
    //======================================================================

    /**
     * Log a method entry.
     * &lt;p&gt;
     * This is a convenience method that can be used to log entry
     * to a method.  A LogRecord with message &quot;ENTRY&quot;, log level
     * FINER, and the given sourceMethod and sourceClass is logged.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that is being entered
     */
    public void entering(String sourceClass, String sourceMethod) {
<span class="fc" id="L1295">        logp(Level.FINER, sourceClass, sourceMethod, &quot;ENTRY&quot;);</span>
<span class="fc" id="L1296">    }</span>

    /**
     * Log a method entry, with one parameter.
     * &lt;p&gt;
     * This is a convenience method that can be used to log entry
     * to a method.  A LogRecord with message &quot;ENTRY {0}&quot;, log level
     * FINER, and the given sourceMethod, sourceClass, and parameter
     * is logged.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that is being entered
     * @param   param1         parameter to the method being entered
     */
    public void entering(String sourceClass, String sourceMethod, Object param1) {
<span class="fc" id="L1311">        logp(Level.FINER, sourceClass, sourceMethod, &quot;ENTRY {0}&quot;, param1);</span>
<span class="fc" id="L1312">    }</span>

    /**
     * Log a method entry, with an array of parameters.
     * &lt;p&gt;
     * This is a convenience method that can be used to log entry
     * to a method.  A LogRecord with message &quot;ENTRY&quot; (followed by a
     * format {N} indicator for each entry in the parameter array),
     * log level FINER, and the given sourceMethod, sourceClass, and
     * parameters is logged.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of method that is being entered
     * @param   params         array of parameters to the method being entered
     */
    public void entering(String sourceClass, String sourceMethod, Object params[]) {
<span class="fc" id="L1328">        String msg = &quot;ENTRY&quot;;</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">        if (params == null ) {</span>
<span class="nc" id="L1330">           logp(Level.FINER, sourceClass, sourceMethod, msg);</span>
<span class="nc" id="L1331">           return;</span>
        }
<span class="fc bfc" id="L1333" title="All 2 branches covered.">        if (!isLoggable(Level.FINER)) return;</span>
<span class="fc bfc" id="L1334" title="All 2 branches covered.">        for (int i = 0; i &lt; params.length; i++) {</span>
<span class="fc" id="L1335">            msg = msg + &quot; {&quot; + i + &quot;}&quot;;</span>
        }
<span class="fc" id="L1337">        logp(Level.FINER, sourceClass, sourceMethod, msg, params);</span>
<span class="fc" id="L1338">    }</span>

    /**
     * Log a method return.
     * &lt;p&gt;
     * This is a convenience method that can be used to log returning
     * from a method.  A LogRecord with message &quot;RETURN&quot;, log level
     * FINER, and the given sourceMethod and sourceClass is logged.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of the method
     */
    public void exiting(String sourceClass, String sourceMethod) {
<span class="fc" id="L1351">        logp(Level.FINER, sourceClass, sourceMethod, &quot;RETURN&quot;);</span>
<span class="fc" id="L1352">    }</span>


    /**
     * Log a method return, with result object.
     * &lt;p&gt;
     * This is a convenience method that can be used to log returning
     * from a method.  A LogRecord with message &quot;RETURN {0}&quot;, log level
     * FINER, and the gives sourceMethod, sourceClass, and result
     * object is logged.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod   name of the method
     * @param   result  Object that is being returned
     */
    public void exiting(String sourceClass, String sourceMethod, Object result) {
<span class="fc" id="L1368">        logp(Level.FINER, sourceClass, sourceMethod, &quot;RETURN {0}&quot;, result);</span>
<span class="fc" id="L1369">    }</span>

    /**
     * Log throwing an exception.
     * &lt;p&gt;
     * This is a convenience method to log that a method is
     * terminating by throwing an exception.  The logging is done
     * using the FINER level.
     * &lt;p&gt;
     * If the logger is currently enabled for the given message
     * level then the given arguments are stored in a LogRecord
     * which is forwarded to all registered output handlers.  The
     * LogRecord's message is set to &quot;THROW&quot;.
     * &lt;p&gt;
     * Note that the thrown argument is stored in the LogRecord thrown
     * property, rather than the LogRecord parameters property.  Thus it is
     * processed specially by output Formatters and is not treated
     * as a formatting parameter to the LogRecord message property.
     * &lt;p&gt;
     * @param   sourceClass    name of class that issued the logging request
     * @param   sourceMethod  name of the method.
     * @param   thrown  The Throwable that is being thrown.
     */
    public void throwing(String sourceClass, String sourceMethod, Throwable thrown) {
<span class="fc bfc" id="L1393" title="All 2 branches covered.">        if (!isLoggable(Level.FINER)) {</span>
<span class="fc" id="L1394">            return;</span>
        }
<span class="fc" id="L1396">        LogRecord lr = new LogRecord(Level.FINER, &quot;THROW&quot;);</span>
<span class="fc" id="L1397">        lr.setSourceClassName(sourceClass);</span>
<span class="fc" id="L1398">        lr.setSourceMethodName(sourceMethod);</span>
<span class="fc" id="L1399">        lr.setThrown(thrown);</span>
<span class="fc" id="L1400">        doLog(lr);</span>
<span class="fc" id="L1401">    }</span>

    //=======================================================================
    // Start of simple convenience methods using level names as method names
    //=======================================================================

    /**
     * Log a SEVERE message.
     * &lt;p&gt;
     * If the logger is currently enabled for the SEVERE message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void severe(String msg) {
<span class="fc" id="L1417">        log(Level.SEVERE, msg);</span>
<span class="fc" id="L1418">    }</span>

    /**
     * Log a WARNING message.
     * &lt;p&gt;
     * If the logger is currently enabled for the WARNING message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void warning(String msg) {
<span class="fc" id="L1430">        log(Level.WARNING, msg);</span>
<span class="fc" id="L1431">    }</span>

    /**
     * Log an INFO message.
     * &lt;p&gt;
     * If the logger is currently enabled for the INFO message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void info(String msg) {
<span class="fc" id="L1443">        log(Level.INFO, msg);</span>
<span class="fc" id="L1444">    }</span>

    /**
     * Log a CONFIG message.
     * &lt;p&gt;
     * If the logger is currently enabled for the CONFIG message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void config(String msg) {
<span class="fc" id="L1456">        log(Level.CONFIG, msg);</span>
<span class="fc" id="L1457">    }</span>

    /**
     * Log a FINE message.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINE message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void fine(String msg) {
<span class="fc" id="L1469">        log(Level.FINE, msg);</span>
<span class="fc" id="L1470">    }</span>

    /**
     * Log a FINER message.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINER message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void finer(String msg) {
<span class="fc" id="L1482">        log(Level.FINER, msg);</span>
<span class="fc" id="L1483">    }</span>

    /**
     * Log a FINEST message.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINEST message
     * level then the given message is forwarded to all the
     * registered output Handler objects.
     * &lt;p&gt;
     * @param   msg     The string message (or a key in the message catalog)
     */
    public void finest(String msg) {
<span class="fc" id="L1495">        log(Level.FINEST, msg);</span>
<span class="fc" id="L1496">    }</span>

    //=======================================================================
    // Start of simple convenience methods using level names as method names
    // and use Supplier&lt;String&gt;
    //=======================================================================

    /**
     * Log a SEVERE message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the SEVERE message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void severe(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1517">        log(Level.SEVERE, msgSupplier);</span>
<span class="nc" id="L1518">    }</span>

    /**
     * Log a WARNING message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the WARNING message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void warning(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1534">        log(Level.WARNING, msgSupplier);</span>
<span class="nc" id="L1535">    }</span>

    /**
     * Log a INFO message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the INFO message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void info(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1551">        log(Level.INFO, msgSupplier);</span>
<span class="nc" id="L1552">    }</span>

    /**
     * Log a CONFIG message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the CONFIG message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void config(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1568">        log(Level.CONFIG, msgSupplier);</span>
<span class="nc" id="L1569">    }</span>

    /**
     * Log a FINE message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINE message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void fine(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1585">        log(Level.FINE, msgSupplier);</span>
<span class="nc" id="L1586">    }</span>

    /**
     * Log a FINER message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINER message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void finer(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1602">        log(Level.FINER, msgSupplier);</span>
<span class="nc" id="L1603">    }</span>

    /**
     * Log a FINEST message, which is only to be constructed if the logging
     * level is such that the message will actually be logged.
     * &lt;p&gt;
     * If the logger is currently enabled for the FINEST message
     * level then the message is constructed by invoking the provided
     * supplier function and forwarded to all the registered output
     * Handler objects.
     * &lt;p&gt;
     * @param   msgSupplier   A function, which when called, produces the
     *                        desired log message
     * @since   1.8
     */
    public void finest(Supplier&lt;String&gt; msgSupplier) {
<span class="nc" id="L1619">        log(Level.FINEST, msgSupplier);</span>
<span class="nc" id="L1620">    }</span>

    //================================================================
    // End of convenience methods
    //================================================================

    /**
     * Set the log level specifying which message levels will be
     * logged by this logger.  Message levels lower than this
     * value will be discarded.  The level value Level.OFF
     * can be used to turn off logging.
     * &lt;p&gt;
     * If the new level is null, it means that this node should
     * inherit its level from its nearest ancestor with a specific
     * (non-null) level value.
     *
     * @param newLevel   the new value for the log level (may be null)
     * @throws  SecurityException if a security manager exists,
     *          this logger is not anonymous, and the caller
     *          does not have LoggingPermission(&quot;control&quot;).
     */
    public void setLevel(Level newLevel) throws SecurityException {
<span class="fc" id="L1642">        checkPermission();</span>
<span class="fc" id="L1643">        synchronized (treeLock) {</span>
<span class="fc" id="L1644">            levelObject = newLevel;</span>
<span class="fc" id="L1645">            updateEffectiveLevel();</span>
<span class="pc" id="L1646">        }</span>
<span class="fc" id="L1647">    }</span>

    final boolean isLevelInitialized() {
<span class="fc bfc" id="L1650" title="All 2 branches covered.">        return levelObject != null;</span>
    }

    /**
     * Get the log Level that has been specified for this Logger.
     * The result may be null, which means that this logger's
     * effective level will be inherited from its parent.
     *
     * @return  this Logger's level
     */
    public Level getLevel() {
<span class="fc" id="L1661">        return levelObject;</span>
    }

    /**
     * Check if a message of the given level would actually be logged
     * by this logger.  This check is based on the Loggers effective level,
     * which may be inherited from its parent.
     *
     * @param   level   a message logging level
     * @return  true if the given message level is currently being logged.
     */
    public boolean isLoggable(Level level) {
<span class="pc bpc" id="L1673" title="1 of 4 branches missed.">        if (level.intValue() &lt; levelValue || levelValue == offValue) {</span>
<span class="fc" id="L1674">            return false;</span>
        }
<span class="fc" id="L1676">        return true;</span>
    }

    /**
     * Get the name for this logger.
     * @return logger name.  Will be null for anonymous Loggers.
     */
    public String getName() {
<span class="fc" id="L1684">        return name;</span>
    }

    /**
     * Add a log Handler to receive logging messages.
     * &lt;p&gt;
     * By default, Loggers also send their output to their parent logger.
     * Typically the root Logger is configured with a set of Handlers
     * that essentially act as default handlers for all loggers.
     *
     * @param   handler a logging Handler
     * @throws  SecurityException if a security manager exists,
     *          this logger is not anonymous, and the caller
     *          does not have LoggingPermission(&quot;control&quot;).
     */
    public void addHandler(Handler handler) throws SecurityException {
        // Check for null handler
<span class="fc" id="L1701">        handler.getClass();</span>
<span class="fc" id="L1702">        checkPermission();</span>
<span class="fc" id="L1703">        handlers.add(handler);</span>
<span class="fc" id="L1704">    }</span>

    /**
     * Remove a log Handler.
     * &lt;P&gt;
     * Returns silently if the given Handler is not found or is null
     *
     * @param   handler a logging Handler
     * @throws  SecurityException if a security manager exists,
     *          this logger is not anonymous, and the caller
     *          does not have LoggingPermission(&quot;control&quot;).
     */
    public void removeHandler(Handler handler) throws SecurityException {
<span class="fc" id="L1717">        checkPermission();</span>
<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L1719">            return;</span>
        }
<span class="fc" id="L1721">        handlers.remove(handler);</span>
<span class="fc" id="L1722">    }</span>

    /**
     * Get the Handlers associated with this logger.
     * &lt;p&gt;
     * @return  an array of all registered Handlers
     */
    public Handler[] getHandlers() {
<span class="fc" id="L1730">        return handlers.toArray(emptyHandlers);</span>
    }

    /**
     * Specify whether or not this logger should send its output
     * to its parent Logger.  This means that any LogRecords will
     * also be written to the parent's Handlers, and potentially
     * to its parent, recursively up the namespace.
     *
     * @param useParentHandlers   true if output is to be sent to the
     *          logger's parent.
     * @throws  SecurityException if a security manager exists,
     *          this logger is not anonymous, and the caller
     *          does not have LoggingPermission(&quot;control&quot;).
     */
    public void setUseParentHandlers(boolean useParentHandlers) {
<span class="fc" id="L1746">        checkPermission();</span>
<span class="fc" id="L1747">        this.useParentHandlers = useParentHandlers;</span>
<span class="fc" id="L1748">    }</span>

    /**
     * Discover whether or not this logger is sending its output
     * to its parent logger.
     *
     * @return  true if output is to be sent to the logger's parent
     */
    public boolean getUseParentHandlers() {
<span class="fc" id="L1757">        return useParentHandlers;</span>
    }

    static final String SYSTEM_LOGGER_RB_NAME = &quot;sun.util.logging.resources.logging&quot;;

    private static ResourceBundle findSystemResourceBundle(final Locale locale) {
        // the resource bundle is in a restricted package
<span class="fc" id="L1764">        return AccessController.doPrivileged(new PrivilegedAction&lt;ResourceBundle&gt;() {</span>
            @Override
            public ResourceBundle run() {
                try {
<span class="fc" id="L1768">                    return ResourceBundle.getBundle(SYSTEM_LOGGER_RB_NAME,</span>
                                                    locale,
<span class="fc" id="L1770">                                                    ClassLoader.getSystemClassLoader());</span>
<span class="nc" id="L1771">                } catch (MissingResourceException e) {</span>
<span class="nc" id="L1772">                    throw new InternalError(e.toString());</span>
                }
            }
        });
    }

    /**
     * Private utility method to map a resource bundle name to an
     * actual resource bundle, using a simple one-entry cache.
     * Returns null for a null name.
     * May also return null if we can't find the resource bundle and
     * there is no suitable previous cached value.
     *
     * @param name the ResourceBundle to locate
     * @param userCallersClassLoader if true search using the caller's ClassLoader
     * @return ResourceBundle specified by name or null if not found
     */
    private synchronized ResourceBundle findResourceBundle(String name,
                                                           boolean useCallersClassLoader) {
        // For all lookups, we first check the thread context class loader
        // if it is set.  If not, we use the system classloader.  If we
        // still haven't found it we use the callersClassLoaderRef if it
        // is set and useCallersClassLoader is true.  We set
        // callersClassLoaderRef initially upon creating the logger with a
        // non-null resource bundle name.

        // Return a null bundle for a null name.
<span class="fc bfc" id="L1799" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L1800">            return null;</span>
        }

<span class="fc" id="L1803">        Locale currentLocale = Locale.getDefault();</span>

        // Normally we should hit on our simple one entry cache.
<span class="fc bfc" id="L1806" title="All 2 branches covered.">        if (userBundle != null &amp;&amp;</span>
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">                name.equals(resourceBundleName)) {</span>
<span class="fc" id="L1808">            return userBundle;</span>
<span class="pc bpc" id="L1809" title="1 of 4 branches missed.">        } else if (catalog != null &amp;&amp; currentLocale.equals(catalogLocale)</span>
<span class="pc bpc" id="L1810" title="1 of 2 branches missed.">                &amp;&amp; name.equals(catalogName)) {</span>
<span class="fc" id="L1811">            return catalog;</span>
        }

<span class="fc bfc" id="L1814" title="All 2 branches covered.">        if (name.equals(SYSTEM_LOGGER_RB_NAME)) {</span>
<span class="fc" id="L1815">            catalog = findSystemResourceBundle(currentLocale);</span>
<span class="fc" id="L1816">            catalogName = name;</span>
<span class="fc" id="L1817">            catalogLocale = currentLocale;</span>
<span class="fc" id="L1818">            return catalog;</span>
        }

        // Use the thread's context ClassLoader.  If there isn't one, use the
        // {@linkplain java.lang.ClassLoader#getSystemClassLoader() system ClassLoader}.
<span class="fc" id="L1823">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">        if (cl == null) {</span>
<span class="nc" id="L1825">            cl = ClassLoader.getSystemClassLoader();</span>
        }
        try {
<span class="fc" id="L1828">            catalog = ResourceBundle.getBundle(name, currentLocale, cl);</span>
<span class="fc" id="L1829">            catalogName = name;</span>
<span class="fc" id="L1830">            catalogLocale = currentLocale;</span>
<span class="fc" id="L1831">            return catalog;</span>
<span class="fc" id="L1832">        } catch (MissingResourceException ex) {</span>
            // We can't find the ResourceBundle in the default
            // ClassLoader.  Drop through.
        }

<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">        if (useCallersClassLoader) {</span>
            // Try with the caller's ClassLoader
<span class="fc" id="L1839">            ClassLoader callersClassLoader = getCallersClassLoader();</span>

<span class="pc bpc" id="L1841" title="1 of 4 branches missed.">            if (callersClassLoader == null || callersClassLoader == cl) {</span>
<span class="fc" id="L1842">                return null;</span>
            }

            try {
<span class="fc" id="L1846">                catalog = ResourceBundle.getBundle(name, currentLocale,</span>
                                                   callersClassLoader);
<span class="fc" id="L1848">                catalogName = name;</span>
<span class="fc" id="L1849">                catalogLocale = currentLocale;</span>
<span class="fc" id="L1850">                return catalog;</span>
<span class="fc" id="L1851">            } catch (MissingResourceException ex) {</span>
<span class="fc" id="L1852">                return null; // no luck</span>
            }
        } else {
<span class="nc" id="L1855">            return null;</span>
        }
    }

    // Private utility method to initialize our one entry
    // resource bundle name cache and the callers ClassLoader
    // Note: for consistency reasons, we are careful to check
    // that a suitable ResourceBundle exists before setting the
    // resourceBundleName field.
    // Synchronized to prevent races in setting the fields.
    private synchronized void setupResourceInfo(String name,
                                                Class&lt;?&gt; callersClass) {
<span class="fc bfc" id="L1867" title="All 2 branches covered.">        if (resourceBundleName != null) {</span>
            // this Logger already has a ResourceBundle

<span class="fc bfc" id="L1870" title="All 2 branches covered.">            if (resourceBundleName.equals(name)) {</span>
                // the names match so there is nothing more to do
<span class="fc" id="L1872">                return;</span>
            }

            // cannot change ResourceBundles once they are set
<span class="fc" id="L1876">            throw new IllegalArgumentException(</span>
                resourceBundleName + &quot; != &quot; + name);
        }

<span class="fc bfc" id="L1880" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L1881">            return;</span>
        }

<span class="fc" id="L1884">        setCallersClassLoaderRef(callersClass);</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">        if (findResourceBundle(name, true) == null) {</span>
            // We've failed to find an expected ResourceBundle.
            // unset the caller's ClassLoader since we were unable to find the
            // the bundle using it
<span class="fc" id="L1889">            this.callersClassLoaderRef = null;</span>
<span class="fc" id="L1890">            throw new MissingResourceException(&quot;Can't find &quot; + name + &quot; bundle&quot;,</span>
                                                name, &quot;&quot;);
        }
<span class="fc" id="L1893">        resourceBundleName = name;</span>
<span class="fc" id="L1894">    }</span>

    /**
     * Sets a resource bundle on this logger.
     * All messages will be logged using the given resource bundle for its
     * specific {@linkplain ResourceBundle#getLocale locale}.
     * @param bundle The resource bundle that this logger shall use.
     * @throws NullPointerException if the given bundle is {@code null}.
     * @throws IllegalArgumentException if the given bundle doesn't have a
     *         {@linkplain ResourceBundle#getBaseBundleName base name},
     *         or if this logger already has a resource bundle set but
     *         the given bundle has a different base name.
     * @throws SecurityException if a security manager exists,
     *         this logger is not anonymous, and the caller
     *         does not have LoggingPermission(&quot;control&quot;).
     * @since 1.8
     */
    public void setResourceBundle(ResourceBundle bundle) {
<span class="fc" id="L1912">        checkPermission();</span>

        // Will throw NPE if bundle is null.
<span class="fc" id="L1915">        final String baseName = bundle.getBaseBundleName();</span>

        // bundle must have a name
<span class="pc bpc" id="L1918" title="1 of 4 branches missed.">        if (baseName == null || baseName.isEmpty()) {</span>
<span class="fc" id="L1919">            throw new IllegalArgumentException(&quot;resource bundle must have a name&quot;);</span>
        }

<span class="fc" id="L1922">        synchronized (this) {</span>
<span class="fc bfc" id="L1923" title="All 2 branches covered.">            final boolean canReplaceResourceBundle = resourceBundleName == null</span>
<span class="fc bfc" id="L1924" title="All 2 branches covered.">                    || resourceBundleName.equals(baseName);</span>

<span class="fc bfc" id="L1926" title="All 2 branches covered.">            if (!canReplaceResourceBundle) {</span>
<span class="fc" id="L1927">                throw new IllegalArgumentException(&quot;can't replace resource bundle&quot;);</span>
            }


<span class="fc" id="L1931">            userBundle = bundle;</span>
<span class="fc" id="L1932">            resourceBundleName = baseName;</span>
<span class="fc" id="L1933">        }</span>
<span class="fc" id="L1934">    }</span>

    /**
     * Return the parent for this Logger.
     * &lt;p&gt;
     * This method returns the nearest extant parent in the namespace.
     * Thus if a Logger is called &quot;a.b.c.d&quot;, and a Logger called &quot;a.b&quot;
     * has been created but no logger &quot;a.b.c&quot; exists, then a call of
     * getParent on the Logger &quot;a.b.c.d&quot; will return the Logger &quot;a.b&quot;.
     * &lt;p&gt;
     * The result will be null if it is called on the root Logger
     * in the namespace.
     *
     * @return nearest existing parent Logger
     */
    public Logger getParent() {
        // Note: this used to be synchronized on treeLock.  However, this only
        // provided memory semantics, as there was no guarantee that the caller
        // would synchronize on treeLock (in fact, there is no way for external
        // callers to so synchronize).  Therefore, we have made parent volatile
        // instead.
<span class="fc" id="L1955">        return parent;</span>
    }

    /**
     * Set the parent for this Logger.  This method is used by
     * the LogManager to update a Logger when the namespace changes.
     * &lt;p&gt;
     * It should not be called from application code.
     * &lt;p&gt;
     * @param  parent   the new parent logger
     * @throws  SecurityException  if a security manager exists and if
     *          the caller does not have LoggingPermission(&quot;control&quot;).
     */
    public void setParent(Logger parent) {
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L1970">            throw new NullPointerException();</span>
        }

        // check permission for all loggers, including anonymous loggers
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">        if (manager == null) {</span>
<span class="nc" id="L1975">            manager = LogManager.getLogManager();</span>
        }
<span class="fc" id="L1977">        manager.checkPermission();</span>

<span class="fc" id="L1979">        doSetParent(parent);</span>
<span class="fc" id="L1980">    }</span>

    // Private method to do the work for parenting a child
    // Logger onto a parent logger.
    private void doSetParent(Logger newParent) {

        // System.err.println(&quot;doSetParent \&quot;&quot; + getName() + &quot;\&quot; \&quot;&quot;
        //                              + newParent.getName() + &quot;\&quot;&quot;);

<span class="fc" id="L1989">        synchronized (treeLock) {</span>

            // Remove ourself from any previous parent.
<span class="fc" id="L1992">            LogManager.LoggerWeakRef ref = null;</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">            if (parent != null) {</span>
                // assert parent.kids != null;
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">                for (Iterator&lt;LogManager.LoggerWeakRef&gt; iter = parent.kids.iterator(); iter.hasNext(); ) {</span>
<span class="fc" id="L1996">                    ref = iter.next();</span>
<span class="fc" id="L1997">                    Logger kid =  ref.get();</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">                    if (kid == this) {</span>
                        // ref is used down below to complete the reparenting
<span class="fc" id="L2000">                        iter.remove();</span>
<span class="fc" id="L2001">                        break;</span>
                    } else {
<span class="fc" id="L2003">                        ref = null;</span>
                    }
<span class="fc" id="L2005">                }</span>
                // We have now removed ourself from our parents' kids.
            }

            // Set our new parent.
<span class="fc" id="L2010">            parent = newParent;</span>
<span class="fc bfc" id="L2011" title="All 2 branches covered.">            if (parent.kids == null) {</span>
<span class="fc" id="L2012">                parent.kids = new ArrayList&lt;&gt;(2);</span>
            }
<span class="fc bfc" id="L2014" title="All 2 branches covered.">            if (ref == null) {</span>
                // we didn't have a previous parent
<span class="fc" id="L2016">                ref = manager.new LoggerWeakRef(this);</span>
            }
<span class="fc" id="L2018">            ref.setParentRef(new WeakReference&lt;&gt;(parent));</span>
<span class="fc" id="L2019">            parent.kids.add(ref);</span>

            // As a result of the reparenting, the effective level
            // may have changed for us and our children.
<span class="fc" id="L2023">            updateEffectiveLevel();</span>

<span class="pc" id="L2025">        }</span>
<span class="fc" id="L2026">    }</span>

    // Package-level method.
    // Remove the weak reference for the specified child Logger from the
    // kid list. We should only be called from LoggerWeakRef.dispose().
    final void removeChildLogger(LogManager.LoggerWeakRef child) {
<span class="fc" id="L2032">        synchronized (treeLock) {</span>
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">            for (Iterator&lt;LogManager.LoggerWeakRef&gt; iter = kids.iterator(); iter.hasNext(); ) {</span>
<span class="fc" id="L2034">                LogManager.LoggerWeakRef ref = iter.next();</span>
<span class="fc bfc" id="L2035" title="All 2 branches covered.">                if (ref == child) {</span>
<span class="fc" id="L2036">                    iter.remove();</span>
<span class="fc" id="L2037">                    return;</span>
                }
<span class="fc" id="L2039">            }</span>
<span class="nc" id="L2040">        }</span>
<span class="nc" id="L2041">    }</span>

    // Recalculate the effective level for this node and
    // recursively for our children.

    private void updateEffectiveLevel() {
        // assert Thread.holdsLock(treeLock);

        // Figure out our current effective level.
        int newLevelValue;
<span class="fc bfc" id="L2051" title="All 2 branches covered.">        if (levelObject != null) {</span>
<span class="fc" id="L2052">            newLevelValue = levelObject.intValue();</span>
        } else {
<span class="fc bfc" id="L2054" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L2055">                newLevelValue = parent.levelValue;</span>
            } else {
                // This may happen during initialization.
<span class="fc" id="L2058">                newLevelValue = Level.INFO.intValue();</span>
            }
        }

        // If our effective value hasn't changed, we're done.
<span class="fc bfc" id="L2063" title="All 2 branches covered.">        if (levelValue == newLevelValue) {</span>
<span class="fc" id="L2064">            return;</span>
        }

<span class="fc" id="L2067">        levelValue = newLevelValue;</span>

        // System.err.println(&quot;effective level: \&quot;&quot; + getName() + &quot;\&quot; := &quot; + level);

        // Recursively update the level on each of our kids.
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        if (kids != null) {</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">            for (int i = 0; i &lt; kids.size(); i++) {</span>
<span class="fc" id="L2074">                LogManager.LoggerWeakRef ref = kids.get(i);</span>
<span class="fc" id="L2075">                Logger kid =  ref.get();</span>
<span class="pc bpc" id="L2076" title="1 of 2 branches missed.">                if (kid != null) {</span>
<span class="fc" id="L2077">                    kid.updateEffectiveLevel();</span>
                }
            }
        }
<span class="fc" id="L2081">    }</span>


    // Private method to get the potentially inherited
    // resource bundle name for this Logger.
    // May return null
    private String getEffectiveResourceBundleName() {
<span class="fc" id="L2088">        Logger target = this;</span>
<span class="fc bfc" id="L2089" title="All 2 branches covered.">        while (target != null) {</span>
<span class="fc" id="L2090">            String rbn = target.getResourceBundleName();</span>
<span class="fc bfc" id="L2091" title="All 2 branches covered.">            if (rbn != null) {</span>
<span class="fc" id="L2092">                return rbn;</span>
            }
<span class="fc" id="L2094">            target = target.getParent();</span>
<span class="fc" id="L2095">        }</span>
<span class="fc" id="L2096">        return null;</span>
    }


    private ResourceBundle getEffectiveResourceBundle() {
<span class="fc" id="L2101">        Logger target = this;</span>
<span class="fc bfc" id="L2102" title="All 2 branches covered.">        if (SYSTEM_LOGGER_RB_NAME.equals(resourceBundleName)) return null;</span>
<span class="fc" id="L2103">        ResourceBundle localRB = getResourceBundle();</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">        if (localRB != null) {</span>
<span class="fc" id="L2105">            return localRB;</span>
        }

<span class="fc bfc" id="L2108" title="All 2 branches covered.">        while (target != null) {</span>
<span class="fc" id="L2109">            final ResourceBundle rb = target.userBundle;</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">            if (rb != null) {</span>
<span class="fc" id="L2111">                return rb;</span>
            }
<span class="fc" id="L2113">            final String rbn = target.getResourceBundleName();</span>
<span class="fc bfc" id="L2114" title="All 2 branches covered.">            if (rbn != null) {</span>
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">                if (!SYSTEM_LOGGER_RB_NAME.equals(rbn)) {</span>
<span class="fc" id="L2116">                    return findResourceBundle(rbn, true);</span>
                } else {
<span class="nc" id="L2118">                    return null;</span>
                }
            }
<span class="fc" id="L2121">            target = target.getParent();</span>
<span class="fc" id="L2122">        }</span>
<span class="fc" id="L2123">        return null;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>