<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LogManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.logging</a> &gt; <span class="el_source">LogManager.java</span></div><h1>LogManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package java.util.logging;

import java.io.*;
import java.util.*;
import java.security.*;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.beans.PropertyChangeListener;
import sun.misc.JavaAWTAccess;
import sun.misc.SharedSecrets;

/**
 * There is a single global LogManager object that is used to
 * maintain a set of shared state about Loggers and log services.
 * &lt;p&gt;
 * This LogManager object:
 * &lt;ul&gt;
 * &lt;li&gt; Manages a hierarchical namespace of Logger objects.  All
 *      named Loggers are stored in this namespace.
 * &lt;li&gt; Manages a set of logging control properties.  These are
 *      simple key-value pairs that can be used by Handlers and
 *      other logging objects to configure themselves.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The global LogManager object can be retrieved using LogManager.getLogManager().
 * The LogManager object is created during class initialization and
 * cannot subsequently be changed.
 * &lt;p&gt;
 * At startup the LogManager class is located using the
 * java.util.logging.manager system property.
 * &lt;p&gt;
 * The LogManager defines two optional system properties that allow control over
 * the initial configuration:
 * &lt;ul&gt;
 * &lt;li&gt;&quot;java.util.logging.config.class&quot;
 * &lt;li&gt;&quot;java.util.logging.config.file&quot;
 * &lt;/ul&gt;
 * These two properties may be specified on the command line to the &quot;java&quot;
 * command, or as system property definitions passed to JNI_CreateJavaVM.
 * &lt;p&gt;
 * If the &quot;java.util.logging.config.class&quot; property is set, then the
 * property value is treated as a class name.  The given class will be
 * loaded, an object will be instantiated, and that object's constructor
 * is responsible for reading in the initial configuration.  (That object
 * may use other system properties to control its configuration.)  The
 * alternate configuration class can use &lt;tt&gt;readConfiguration(InputStream)&lt;/tt&gt;
 * to define properties in the LogManager.
 * &lt;p&gt;
 * If &quot;java.util.logging.config.class&quot; property is &lt;b&gt;not&lt;/b&gt; set,
 * then the &quot;java.util.logging.config.file&quot; system property can be used
 * to specify a properties file (in java.util.Properties format). The
 * initial logging configuration will be read from this file.
 * &lt;p&gt;
 * If neither of these properties is defined then the LogManager uses its
 * default configuration. The default configuration is typically loaded from the
 * properties file &quot;{@code lib/logging.properties}&quot; in the Java installation
 * directory.
 * &lt;p&gt;
 * The properties for loggers and Handlers will have names starting
 * with the dot-separated name for the handler or logger.
 * &lt;p&gt;
 * The global logging properties may include:
 * &lt;ul&gt;
 * &lt;li&gt;A property &quot;handlers&quot;.  This defines a whitespace or comma separated
 * list of class names for handler classes to load and register as
 * handlers on the root Logger (the Logger named &quot;&quot;).  Each class
 * name must be for a Handler class which has a default constructor.
 * Note that these Handlers may be created lazily, when they are
 * first used.
 *
 * &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.handlers&quot;. This defines a whitespace or
 * comma separated list of class names for handlers classes to
 * load and register as handlers to the specified logger. Each class
 * name must be for a Handler class which has a default constructor.
 * Note that these Handlers may be created lazily, when they are
 * first used.
 *
 * &lt;li&gt;A property &quot;&amp;lt;logger&amp;gt;.useParentHandlers&quot;. This defines a boolean
 * value. By default every logger calls its parent in addition to
 * handling the logging message itself, this often result in messages
 * being handled by the root logger as well. When setting this property
 * to false a Handler needs to be configured for this logger otherwise
 * no logging messages are delivered.
 *
 * &lt;li&gt;A property &quot;config&quot;.  This property is intended to allow
 * arbitrary configuration code to be run.  The property defines a
 * whitespace or comma separated list of class names.  A new instance will be
 * created for each named class.  The default constructor of each class
 * may execute arbitrary code to update the logging configuration, such as
 * setting logger levels, adding handlers, adding filters, etc.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Note that all classes loaded during LogManager configuration are
 * first searched on the system class path before any user class path.
 * That includes the LogManager class, any config classes, and any
 * handler classes.
 * &lt;p&gt;
 * Loggers are organized into a naming hierarchy based on their
 * dot separated names.  Thus &quot;a.b.c&quot; is a child of &quot;a.b&quot;, but
 * &quot;a.b1&quot; and a.b2&quot; are peers.
 * &lt;p&gt;
 * All properties whose names end with &quot;.level&quot; are assumed to define
 * log levels for Loggers.  Thus &quot;foo.level&quot; defines a log level for
 * the logger called &quot;foo&quot; and (recursively) for any of its children
 * in the naming hierarchy.  Log Levels are applied in the order they
 * are defined in the properties file.  Thus level settings for child
 * nodes in the tree should come after settings for their parents.
 * The property name &quot;.level&quot; can be used to set the level for the
 * root of the tree.
 * &lt;p&gt;
 * All methods on the LogManager object are multi-thread safe.
 *
 * @since 1.4
*/

<span class="fc bfc" id="L145" title="All 2 branches covered.">public class LogManager {</span>
    // The global LogManager object
    private static final LogManager manager;

<span class="fc" id="L149">    private Properties props = new Properties();</span>
<span class="fc" id="L150">    private final static Level defaultLevel = Level.INFO;</span>

    // The map of the registered listeners. The map value is the registration
    // count to allow for cases where the same listener is registered many times.
<span class="fc" id="L154">    private final Map&lt;Object,Integer&gt; listenerMap = new HashMap&lt;&gt;();</span>

    // LoggerContext for system loggers and user loggers
<span class="fc" id="L157">    private final LoggerContext systemContext = new SystemLoggerContext();</span>
<span class="fc" id="L158">    private final LoggerContext userContext = new LoggerContext();</span>
    // non final field - make it volatile to make sure that other threads
    // will see the new value once ensureLogManagerInitialized() has finished
    // executing.
    private volatile Logger rootLogger;
    // Have we done the primordial reading of the configuration file?
    // (Must be done after a suitable amount of java.lang.System
    // initialization has been done)
    private volatile boolean readPrimordialConfiguration;
    // Have we initialized global (root) handlers yet?
    // This gets set to false in readConfiguration
<span class="fc" id="L169">    private boolean initializedGlobalHandlers = true;</span>
    // True if JVM death is imminent and the exit hook has been called.
    private boolean deathImminent;

    static {
<span class="fc" id="L174">        manager = AccessController.doPrivileged(new PrivilegedAction&lt;LogManager&gt;() {</span>
            @Override
            public LogManager run() {
<span class="fc" id="L177">                LogManager mgr = null;</span>
<span class="fc" id="L178">                String cname = null;</span>
                try {
<span class="fc" id="L180">                    cname = System.getProperty(&quot;java.util.logging.manager&quot;);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                    if (cname != null) {</span>
                        try {
<span class="fc" id="L183">                            Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader()</span>
<span class="fc" id="L184">                                    .loadClass(cname);</span>
<span class="fc" id="L185">                            mgr = (LogManager) clz.newInstance();</span>
<span class="nc" id="L186">                        } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L187">                            Class&lt;?&gt; clz = Thread.currentThread()</span>
<span class="nc" id="L188">                                    .getContextClassLoader().loadClass(cname);</span>
<span class="nc" id="L189">                            mgr = (LogManager) clz.newInstance();</span>
<span class="fc" id="L190">                        }</span>
                    }
<span class="fc" id="L192">                } catch (Exception ex) {</span>
<span class="fc" id="L193">                    System.err.println(&quot;Could not load Logmanager \&quot;&quot; + cname + &quot;\&quot;&quot;);</span>
<span class="fc" id="L194">                    ex.printStackTrace();</span>
<span class="fc" id="L195">                }</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (mgr == null) {</span>
<span class="fc" id="L197">                    mgr = new LogManager();</span>
                }
<span class="fc" id="L199">                return mgr;</span>

            }
        });
    }


    // This private class is used as a shutdown hook.
    // It does a &quot;reset&quot; to close all open handlers.
    private class Cleaner extends Thread {

<span class="fc" id="L210">        private Cleaner() {</span>
            /* Set context class loader to null in order to avoid
             * keeping a strong reference to an application classloader.
             */
<span class="fc" id="L214">            this.setContextClassLoader(null);</span>
<span class="fc" id="L215">        }</span>

        @Override
        public void run() {
            // This is to ensure the LogManager.&lt;clinit&gt; is completed
            // before synchronized block. Otherwise deadlocks are possible.
<span class="fc" id="L221">            LogManager mgr = manager;</span>

            // If the global handlers haven't been initialized yet, we
            // don't want to initialize them just so we can close them!
<span class="fc" id="L225">            synchronized (LogManager.this) {</span>
                // Note that death is imminent.
<span class="fc" id="L227">                deathImminent = true;</span>
<span class="fc" id="L228">                initializedGlobalHandlers = true;</span>
<span class="pc" id="L229">            }</span>

            // Do a reset to close all active handlers.
<span class="fc" id="L232">            reset();</span>
<span class="fc" id="L233">        }</span>
    }


    /**
     * Protected constructor.  This is protected so that container applications
     * (such as J2EE containers) can subclass the object.  It is non-public as
     * it is intended that there only be one LogManager object, whose value is
     * retrieved by calling LogManager.getLogManager.
     */
<span class="fc" id="L243">    protected LogManager() {</span>
        // Add a shutdown hook to close the global handlers.
        try {
<span class="fc" id="L246">            Runtime.getRuntime().addShutdownHook(new Cleaner());</span>
<span class="nc" id="L247">        } catch (IllegalStateException e) {</span>
            // If the VM is already shutting down,
            // We do not need to register shutdownHook.
<span class="fc" id="L250">        }</span>
<span class="fc" id="L251">    }</span>

    /**
     * Lazy initialization: if this instance of manager is the global
     * manager then this method will read the initial configuration and
     * add the root logger and global logger by calling addLogger().
     *
     * Note that it is subtly different from what we do in LoggerContext.
     * In LoggerContext we're patching up the logger context tree in order to add
     * the root and global logger *to the context tree*.
     *
     * For this to work, addLogger() must have already have been called
     * once on the LogManager instance for the default logger being
     * added.
     *
     * This is why ensureLogManagerInitialized() needs to be called before
     * any logger is added to any logger context.
     *
     */
<span class="fc" id="L270">    private boolean initializedCalled = false;</span>
<span class="fc" id="L271">    private volatile boolean initializationDone = false;</span>
    final void ensureLogManagerInitialized() {
<span class="fc" id="L273">        final LogManager owner = this;</span>
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">        if (initializationDone || owner != manager) {</span>
            // we don't want to do this twice, and we don't want to do
            // this on private manager instances.
<span class="fc" id="L277">            return;</span>
        }

        // Maybe another thread has called ensureLogManagerInitialized()
        // before us and is still executing it. If so we will block until
        // the log manager has finished initialized, then acquire the monitor,
        // notice that initializationDone is now true and return.
        // Otherwise - we have come here first! We will acquire the monitor,
        // see that initializationDone is still false, and perform the
        // initialization.
        //
<span class="fc" id="L288">        synchronized(this) {</span>
            // If initializedCalled is true it means that we're already in
            // the process of initializing the LogManager in this thread.
            // There has been a recursive call to ensureLogManagerInitialized().
<span class="fc bfc" id="L292" title="All 2 branches covered.">            final boolean isRecursiveInitialization = (initializedCalled == true);</span>

<span class="pc bpc" id="L294" title="1 of 6 branches missed.">            assert initializedCalled || !initializationDone</span>
                    : &quot;Initialization can't be done if initialized has not been called!&quot;;

<span class="pc bpc" id="L297" title="1 of 4 branches missed.">            if (isRecursiveInitialization || initializationDone) {</span>
                // If isRecursiveInitialization is true it means that we're
                // already in the process of initializing the LogManager in
                // this thread. There has been a recursive call to
                // ensureLogManagerInitialized(). We should not proceed as
                // it would lead to infinite recursion.
                //
                // If initializationDone is true then it means the manager
                // has finished initializing; just return: we're done.
<span class="fc" id="L306">                return;</span>
            }
            // Calling addLogger below will in turn call requiresDefaultLogger()
            // which will call ensureLogManagerInitialized().
            // We use initializedCalled to break the recursion.
<span class="fc" id="L311">            initializedCalled = true;</span>
            try {
<span class="fc bfc" id="L313" title="All 2 branches covered.">                AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
                    @Override
                    public Object run() {
<span class="pc bpc" id="L316" title="1 of 4 branches missed.">                        assert rootLogger == null;</span>
<span class="pc bpc" id="L317" title="2 of 6 branches missed.">                        assert initializedCalled &amp;&amp; !initializationDone;</span>

                        // Read configuration.
<span class="fc" id="L320">                        owner.readPrimordialConfiguration();</span>

                        // Create and retain Logger for the root of the namespace.
<span class="fc" id="L323">                        owner.rootLogger = owner.new RootLogger();</span>
<span class="fc" id="L324">                        owner.addLogger(owner.rootLogger);</span>

                        // Adding the global Logger.
                        // Do not call Logger.getGlobal() here as this might trigger
                        // subtle inter-dependency issues.
                        @SuppressWarnings(&quot;deprecation&quot;)
<span class="fc" id="L330">                        final Logger global = Logger.global;</span>

                        // Make sure the global logger will be registered in the
                        // global manager
<span class="fc" id="L334">                        owner.addLogger(global);</span>
<span class="fc" id="L335">                        return null;</span>
                    }
                });
            } finally {
<span class="pc" id="L339">                initializationDone = true;</span>
<span class="fc" id="L340">            }</span>
<span class="pc" id="L341">        }</span>
<span class="fc" id="L342">    }</span>

    /**
     * Returns the global LogManager object.
     * @return the global LogManager object
     */
    public static LogManager getLogManager() {
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (manager != null) {</span>
<span class="fc" id="L350">            manager.ensureLogManagerInitialized();</span>
        }
<span class="fc" id="L352">        return manager;</span>
    }

    private void readPrimordialConfiguration() {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (!readPrimordialConfiguration) {</span>
<span class="fc" id="L357">            synchronized (this) {</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                if (!readPrimordialConfiguration) {</span>
                    // If System.in/out/err are null, it's a good
                    // indication that we're still in the
                    // bootstrapping phase
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                    if (System.out == null) {</span>
<span class="nc" id="L363">                        return;</span>
                    }
<span class="fc" id="L365">                    readPrimordialConfiguration = true;</span>

                    try {
<span class="fc" id="L368">                        AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                                @Override
                                public Void run() throws Exception {
<span class="fc" id="L371">                                    readConfiguration();</span>

                                    // Platform loggers begin to delegate to java.util.logging.Logger
<span class="fc" id="L374">                                    sun.util.logging.PlatformLogger.redirectPlatformLoggers();</span>
<span class="fc" id="L375">                                    return null;</span>
                                }
                            });
<span class="nc" id="L378">                    } catch (Exception ex) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                        assert false : &quot;Exception raised while reading logging configuration: &quot; + ex;</span>
<span class="fc" id="L380">                    }</span>
                }
<span class="pc" id="L382">            }</span>
        }
<span class="fc" id="L384">    }</span>

    /**
     * Adds an event listener to be invoked when the logging
     * properties are re-read. Adding multiple instances of
     * the same event Listener results in multiple entries
     * in the property event listener table.
     *
     * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; This method is omitted from this class in all subset
     * Profiles of Java SE that do not include the {@code java.beans} package.
     * &lt;/p&gt;
     *
     * @param l  event listener
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     * @exception NullPointerException if the PropertyChangeListener is null.
     * @deprecated The dependency on {@code PropertyChangeListener} creates a
     *             significant impediment to future modularization of the Java
     *             platform. This method will be removed in a future release.
     *             The global {@code LogManager} can detect changes to the
     *             logging configuration by overridding the {@link
     *             #readConfiguration readConfiguration} method.
     */
    @Deprecated
    public void addPropertyChangeListener(PropertyChangeListener l) throws SecurityException {
<span class="fc" id="L409">        PropertyChangeListener listener = Objects.requireNonNull(l);</span>
<span class="fc" id="L410">        checkPermission();</span>
<span class="fc" id="L411">        synchronized (listenerMap) {</span>
            // increment the registration count if already registered
<span class="fc" id="L413">            Integer value = listenerMap.get(listener);</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            value = (value == null) ? 1 : (value + 1);</span>
<span class="fc" id="L415">            listenerMap.put(listener, value);</span>
<span class="pc" id="L416">        }</span>
<span class="fc" id="L417">    }</span>

    /**
     * Removes an event listener for property change events.
     * If the same listener instance has been added to the listener table
     * through multiple invocations of &lt;CODE&gt;addPropertyChangeListener&lt;/CODE&gt;,
     * then an equivalent number of
     * &lt;CODE&gt;removePropertyChangeListener&lt;/CODE&gt; invocations are required to remove
     * all instances of that listener from the listener table.
     * &lt;P&gt;
     * Returns silently if the given listener is not found.
     *
     * &lt;p&gt;&lt;b&gt;WARNING:&lt;/b&gt; This method is omitted from this class in all subset
     * Profiles of Java SE that do not include the {@code java.beans} package.
     * &lt;/p&gt;
     *
     * @param l  event listener (can be null)
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     * @deprecated The dependency on {@code PropertyChangeListener} creates a
     *             significant impediment to future modularization of the Java
     *             platform. This method will be removed in a future release.
     *             The global {@code LogManager} can detect changes to the
     *             logging configuration by overridding the {@link
     *             #readConfiguration readConfiguration} method.
     */
    @Deprecated
    public void removePropertyChangeListener(PropertyChangeListener l) throws SecurityException {
<span class="fc" id="L445">        checkPermission();</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (l != null) {</span>
<span class="fc" id="L447">            PropertyChangeListener listener = l;</span>
<span class="fc" id="L448">            synchronized (listenerMap) {</span>
<span class="fc" id="L449">                Integer value = listenerMap.get(listener);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                if (value != null) {</span>
                    // remove from map if registration count is 1, otherwise
                    // just decrement its count
<span class="fc" id="L453">                    int i = value.intValue();</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    if (i == 1) {</span>
<span class="fc" id="L455">                        listenerMap.remove(listener);</span>
                    } else {
<span class="pc bpc" id="L457" title="2 of 4 branches missed.">                        assert i &gt; 1;</span>
<span class="fc" id="L458">                        listenerMap.put(listener, i - 1);</span>
                    }
                }
<span class="pc" id="L461">            }</span>
        }
<span class="fc" id="L463">    }</span>

    // LoggerContext maps from AppContext
<span class="fc" id="L466">    private WeakHashMap&lt;Object, LoggerContext&gt; contextsMap = null;</span>

    // Returns the LoggerContext for the user code (i.e. application or AppContext).
    // Loggers are isolated from each AppContext.
    private LoggerContext getUserContext() {
<span class="fc" id="L471">        LoggerContext context = null;</span>

<span class="fc" id="L473">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc" id="L474">        JavaAWTAccess javaAwtAccess = SharedSecrets.getJavaAWTAccess();</span>
<span class="fc bfc" id="L475" title="All 4 branches covered.">        if (sm != null &amp;&amp; javaAwtAccess != null) {</span>
            // for each applet, it has its own LoggerContext isolated from others
<span class="fc" id="L477">            synchronized (javaAwtAccess) {</span>
                // find the AppContext of the applet code
                // will be null if we are in the main app context.
<span class="fc" id="L480">                final Object ecx = javaAwtAccess.getAppletContext();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (ecx != null) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                    if (contextsMap == null) {</span>
<span class="fc" id="L483">                        contextsMap = new WeakHashMap&lt;&gt;();</span>
                    }
<span class="fc" id="L485">                    context = contextsMap.get(ecx);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">                    if (context == null) {</span>
                        // Create a new LoggerContext for the applet.
<span class="fc" id="L488">                        context = new LoggerContext();</span>
<span class="fc" id="L489">                        contextsMap.put(ecx, context);</span>
                    }
                }
<span class="pc" id="L492">            }</span>
        }
        // for standalone app, return userContext
<span class="fc bfc" id="L495" title="All 2 branches covered.">        return context != null ? context : userContext;</span>
    }

    // The system context.
    final LoggerContext getSystemContext() {
<span class="fc" id="L500">        return systemContext;</span>
    }

    private List&lt;LoggerContext&gt; contexts() {
<span class="fc" id="L504">        List&lt;LoggerContext&gt; cxs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L505">        cxs.add(getSystemContext());</span>
<span class="fc" id="L506">        cxs.add(getUserContext());</span>
<span class="fc" id="L507">        return cxs;</span>
    }

    // Find or create a specified logger instance. If a logger has
    // already been created with the given name it is returned.
    // Otherwise a new logger instance is created and registered
    // in the LogManager global namespace.
    // This method will always return a non-null Logger object.
    // Synchronization is not required here. All synchronization for
    // adding a new Logger object is handled by addLogger().
    //
    // This method must delegate to the LogManager implementation to
    // add a new Logger or return the one that has been added previously
    // as a LogManager subclass may override the addLogger, getLogger,
    // readConfiguration, and other methods.
    Logger demandLogger(String name, String resourceBundleName, Class&lt;?&gt; caller) {
<span class="fc" id="L523">        Logger result = getLogger(name);</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (result == null) {</span>
            // only allocate the new logger once
<span class="fc" id="L526">            Logger newLogger = new Logger(name, resourceBundleName, caller, this);</span>
            do {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">                if (addLogger(newLogger)) {</span>
                    // We successfully added the new Logger that we
                    // created above so return it without refetching.
<span class="fc" id="L531">                    return newLogger;</span>
                }

                // We didn't add the new Logger that we created above
                // because another thread added a Logger with the same
                // name after our null check above and before our call
                // to addLogger(). We have to refetch the Logger because
                // addLogger() returns a boolean instead of the Logger
                // reference itself. However, if the thread that created
                // the other Logger is not holding a strong reference to
                // the other Logger, then it is possible for the other
                // Logger to be GC'ed after we saw it in addLogger() and
                // before we can refetch it. If it has been GC'ed then
                // we'll just loop around and try again.
<span class="nc" id="L545">                result = getLogger(name);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            } while (result == null);</span>
        }
<span class="fc" id="L548">        return result;</span>
    }

    Logger demandSystemLogger(String name, String resourceBundleName) {
        // Add a system logger in the system context's namespace
<span class="fc" id="L553">        final Logger sysLogger = getSystemContext().demandLogger(name, resourceBundleName);</span>

        // Add the system logger to the LogManager's namespace if not exist
        // so that there is only one single logger of the given name.
        // System loggers are visible to applications unless a logger of
        // the same name has been added.
        Logger logger;
        do {
            // First attempt to call addLogger instead of getLogger
            // This would avoid potential bug in custom LogManager.getLogger
            // implementation that adds a logger if does not exist
<span class="fc bfc" id="L564" title="All 2 branches covered.">            if (addLogger(sysLogger)) {</span>
                // successfully added the new system logger
<span class="fc" id="L566">                logger = sysLogger;</span>
            } else {
<span class="fc" id="L568">                logger = getLogger(name);</span>
            }
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">        } while (logger == null);</span>

        // LogManager will set the sysLogger's handlers via LogManager.addLogger method.
<span class="pc bpc" id="L573" title="3 of 4 branches missed.">        if (logger != sysLogger &amp;&amp; sysLogger.getHandlers().length == 0) {</span>
            // if logger already exists but handlers not set
<span class="nc" id="L575">            final Logger l = logger;</span>
<span class="nc" id="L576">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                @Override
                public Void run() {
<span class="nc bnc" id="L579" title="All 2 branches missed.">                    for (Handler hdl : l.getHandlers()) {</span>
<span class="nc" id="L580">                        sysLogger.addHandler(hdl);</span>
                    }
<span class="nc" id="L582">                    return null;</span>
                }
            });
        }
<span class="fc" id="L586">        return sysLogger;</span>
    }

    // LoggerContext maintains the logger namespace per context.
    // The default LogManager implementation has one system context and user
    // context.  The system context is used to maintain the namespace for
    // all system loggers and is queried by the system code.  If a system logger
    // doesn't exist in the user context, it'll also be added to the user context.
    // The user context is queried by the user code and all other loggers are
    // added in the user context.
<span class="fc bfc" id="L596" title="All 2 branches covered.">    class LoggerContext {</span>
        // Table of named Loggers that maps names to Loggers.
<span class="fc" id="L598">        private final Hashtable&lt;String,LoggerWeakRef&gt; namedLoggers = new Hashtable&lt;&gt;();</span>
        // Tree of named Loggers
        private final LogNode root;
<span class="fc" id="L601">        private LoggerContext() {</span>
<span class="fc" id="L602">            this.root = new LogNode(null, this);</span>
<span class="fc" id="L603">        }</span>


        // Tells whether default loggers are required in this context.
        // If true, the default loggers will be lazily added.
        final boolean requiresDefaultLoggers() {
<span class="fc bfc" id="L609" title="All 2 branches covered.">            final boolean requiresDefaultLoggers = (getOwner() == manager);</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            if (requiresDefaultLoggers) {</span>
<span class="fc" id="L611">                getOwner().ensureLogManagerInitialized();</span>
            }
<span class="fc" id="L613">            return requiresDefaultLoggers;</span>
        }

        // This context's LogManager.
        final LogManager getOwner() {
<span class="fc" id="L618">            return LogManager.this;</span>
        }

        // This context owner's root logger, which if not null, and if
        // the context requires default loggers, will be added to the context
        // logger's tree.
        final Logger getRootLogger() {
<span class="fc" id="L625">            return getOwner().rootLogger;</span>
        }

        // The global logger, which if not null, and if
        // the context requires default loggers, will be added to the context
        // logger's tree.
        final Logger getGlobalLogger() {
            @SuppressWarnings(&quot;deprecated&quot;) // avoids initialization cycles.
<span class="fc" id="L633">            final Logger global = Logger.global;</span>
<span class="fc" id="L634">            return global;</span>
        }

        Logger demandLogger(String name, String resourceBundleName) {
            // a LogManager subclass may have its own implementation to add and
            // get a Logger.  So delegate to the LogManager to do the work.
<span class="fc" id="L640">            final LogManager owner = getOwner();</span>
<span class="fc" id="L641">            return owner.demandLogger(name, resourceBundleName, null);</span>
        }


        // Due to subtle deadlock issues getUserContext() no longer
        // calls addLocalLogger(rootLogger);
        // Therefore - we need to add the default loggers later on.
        // Checks that the context is properly initialized
        // This is necessary before calling e.g. find(name)
        // or getLoggerNames()
        //
        private void ensureInitialized() {
<span class="fc bfc" id="L653" title="All 2 branches covered.">            if (requiresDefaultLoggers()) {</span>
                // Ensure that the root and global loggers are set.
<span class="fc" id="L655">                ensureDefaultLogger(getRootLogger());</span>
<span class="fc" id="L656">                ensureDefaultLogger(getGlobalLogger());</span>
            }
<span class="fc" id="L658">        }</span>


        synchronized Logger findLogger(String name) {
            // ensure that this context is properly initialized before
            // looking for loggers.
<span class="fc" id="L664">            ensureInitialized();</span>
<span class="fc" id="L665">            LoggerWeakRef ref = namedLoggers.get(name);</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (ref == null) {</span>
<span class="fc" id="L667">                return null;</span>
            }
<span class="fc" id="L669">            Logger logger = ref.get();</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (logger == null) {</span>
                // Hashtable holds stale weak reference
                // to a logger which has been GC-ed.
<span class="fc" id="L673">                removeLogger(name);</span>
            }
<span class="fc" id="L675">            return logger;</span>
        }

        // This method is called before adding a logger to the
        // context.
        // 'logger' is the context that will be added.
        // This method will ensure that the defaults loggers are added
        // before adding 'logger'.
        //
        private void ensureAllDefaultLoggers(Logger logger) {
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (requiresDefaultLoggers()) {</span>
<span class="fc" id="L686">                final String name = logger.getName();</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                if (!name.isEmpty()) {</span>
<span class="fc" id="L688">                    ensureDefaultLogger(getRootLogger());</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    if (!Logger.GLOBAL_LOGGER_NAME.equals(name)) {</span>
<span class="fc" id="L690">                        ensureDefaultLogger(getGlobalLogger());</span>
                    }
                }
            }
<span class="fc" id="L694">        }</span>

        private void ensureDefaultLogger(Logger logger) {
            // Used for lazy addition of root logger and global logger
            // to a LoggerContext.

            // This check is simple sanity: we do not want that this
            // method be called for anything else than Logger.global
            // or owner.rootLogger.
<span class="pc bpc" id="L703" title="1 of 6 branches missed.">            if (!requiresDefaultLoggers() || logger == null</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">                    || logger != Logger.global &amp;&amp; logger != LogManager.this.rootLogger) {</span>

                // the case where we have a non null logger which is neither
                // Logger.global nor manager.rootLogger indicates a serious
                // issue - as ensureDefaultLogger should never be called
                // with any other loggers than one of these two (or null - if
                // e.g manager.rootLogger is not yet initialized)...
<span class="pc bpc" id="L711" title="1 of 4 branches missed.">                assert logger == null;</span>

<span class="fc" id="L713">                return;</span>
            }

            // Adds the logger if it's not already there.
<span class="fc bfc" id="L717" title="All 2 branches covered.">            if (!namedLoggers.containsKey(logger.getName())) {</span>
                // It is important to prevent addLocalLogger to
                // call ensureAllDefaultLoggers when we're in the process
                // off adding one of those default loggers - as this would
                // immediately cause a stack overflow.
                // Therefore we must pass addDefaultLoggersIfNeeded=false,
                // even if requiresDefaultLoggers is true.
<span class="fc" id="L724">                addLocalLogger(logger, false);</span>
            }
<span class="fc" id="L726">        }</span>

        boolean addLocalLogger(Logger logger) {
            // no need to add default loggers if it's not required
<span class="fc" id="L730">            return addLocalLogger(logger, requiresDefaultLoggers());</span>
        }

        // Add a logger to this context.  This method will only set its level
        // and process parent loggers.  It doesn't set its handlers.
        synchronized boolean addLocalLogger(Logger logger, boolean addDefaultLoggersIfNeeded) {
            // addDefaultLoggersIfNeeded serves to break recursion when adding
            // default loggers. If we're adding one of the default loggers
            // (we're being called from ensureDefaultLogger()) then
            // addDefaultLoggersIfNeeded will be false: we don't want to
            // call ensureAllDefaultLoggers again.
            //
            // Note: addDefaultLoggersIfNeeded can also be false when
            //       requiresDefaultLoggers is false - since calling
            //       ensureAllDefaultLoggers would have no effect in this case.
<span class="fc bfc" id="L745" title="All 2 branches covered.">            if (addDefaultLoggersIfNeeded) {</span>
<span class="fc" id="L746">                ensureAllDefaultLoggers(logger);</span>
            }

<span class="fc" id="L749">            final String name = logger.getName();</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L751">                throw new NullPointerException();</span>
            }
<span class="fc" id="L753">            LoggerWeakRef ref = namedLoggers.get(name);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (ref != null) {</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">                if (ref.get() == null) {</span>
                    // It's possible that the Logger was GC'ed after a
                    // drainLoggerRefQueueBounded() call above so allow
                    // a new one to be registered.
<span class="nc" id="L759">                    removeLogger(name);</span>
                } else {
                    // We already have a registered logger with the given name.
<span class="fc" id="L762">                    return false;</span>
                }
            }

            // We're adding a new logger.
            // Note that we are creating a weak reference here.
<span class="fc" id="L768">            final LogManager owner = getOwner();</span>
<span class="fc" id="L769">            logger.setLogManager(owner);</span>
<span class="fc" id="L770">            ref = owner.new LoggerWeakRef(logger);</span>
<span class="fc" id="L771">            namedLoggers.put(name, ref);</span>

            // Apply any initial level defined for the new logger, unless
            // the logger's level is already initialized
<span class="fc" id="L775">            Level level = owner.getLevelProperty(name + &quot;.level&quot;, null);</span>
<span class="fc bfc" id="L776" title="All 4 branches covered.">            if (level != null &amp;&amp; !logger.isLevelInitialized()) {</span>
<span class="fc" id="L777">                doSetLevel(logger, level);</span>
            }

            // instantiation of the handler is done in the LogManager.addLogger
            // implementation as a handler class may be only visible to LogManager
            // subclass for the custom log manager case
<span class="fc" id="L783">            processParentHandlers(logger, name);</span>

            // Find the new node and its parent.
<span class="fc" id="L786">            LogNode node = getNode(name);</span>
<span class="fc" id="L787">            node.loggerRef = ref;</span>
<span class="fc" id="L788">            Logger parent = null;</span>
<span class="fc" id="L789">            LogNode nodep = node.parent;</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            while (nodep != null) {</span>
<span class="fc" id="L791">                LoggerWeakRef nodeRef = nodep.loggerRef;</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">                if (nodeRef != null) {</span>
<span class="fc" id="L793">                    parent = nodeRef.get();</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                    if (parent != null) {</span>
<span class="fc" id="L795">                        break;</span>
                    }
                }
<span class="fc" id="L798">                nodep = nodep.parent;</span>
<span class="fc" id="L799">            }</span>

<span class="fc bfc" id="L801" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L802">                doSetParent(logger, parent);</span>
            }
            // Walk over the children and tell them we are their new parent.
<span class="fc" id="L805">            node.walkAndSetParent(logger);</span>
            // new LogNode is ready so tell the LoggerWeakRef about it
<span class="fc" id="L807">            ref.setNode(node);</span>
<span class="fc" id="L808">            return true;</span>
        }

        // note: all calls to removeLogger are synchronized on LogManager's
        // intrinsic lock
        void removeLogger(String name) {
<span class="fc" id="L814">            namedLoggers.remove(name);</span>
<span class="fc" id="L815">        }</span>

        synchronized Enumeration&lt;String&gt; getLoggerNames() {
            // ensure that this context is properly initialized before
            // returning logger names.
<span class="fc" id="L820">            ensureInitialized();</span>
<span class="fc" id="L821">            return namedLoggers.keys();</span>
        }

        // If logger.getUseParentHandlers() returns 'true' and any of the logger's
        // parents have levels or handlers defined, make sure they are instantiated.
        private void processParentHandlers(final Logger logger, final String name) {
<span class="fc" id="L827">            final LogManager owner = getOwner();</span>
<span class="fc" id="L828">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                @Override
                public Void run() {
<span class="fc bfc" id="L831" title="All 2 branches covered.">                    if (logger != owner.rootLogger) {</span>
<span class="fc" id="L832">                        boolean useParent = owner.getBooleanProperty(name + &quot;.useParentHandlers&quot;, true);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">                        if (!useParent) {</span>
<span class="fc" id="L834">                            logger.setUseParentHandlers(false);</span>
                        }
                    }
<span class="fc" id="L837">                    return null;</span>
                }
            });

<span class="fc" id="L841">            int ix = 1;</span>
            for (;;) {
<span class="fc" id="L843">                int ix2 = name.indexOf(&quot;.&quot;, ix);</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">                if (ix2 &lt; 0) {</span>
<span class="fc" id="L845">                    break;</span>
                }
<span class="fc" id="L847">                String pname = name.substring(0, ix2);</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">                if (owner.getProperty(pname + &quot;.level&quot;) != null ||</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">                    owner.getProperty(pname + &quot;.handlers&quot;) != null) {</span>
                    // This pname has a level/handlers definition.
                    // Make sure it exists.
<span class="fc" id="L852">                    demandLogger(pname, null);</span>
                }
<span class="fc" id="L854">                ix = ix2+1;</span>
<span class="fc" id="L855">            }</span>
<span class="fc" id="L856">        }</span>

        // Gets a node in our tree of logger nodes.
        // If necessary, create it.
        LogNode getNode(String name) {
<span class="pc bpc" id="L861" title="1 of 4 branches missed.">            if (name == null || name.equals(&quot;&quot;)) {</span>
<span class="fc" id="L862">                return root;</span>
            }
<span class="fc" id="L864">            LogNode node = root;</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            while (name.length() &gt; 0) {</span>
<span class="fc" id="L866">                int ix = name.indexOf(&quot;.&quot;);</span>
                String head;
<span class="fc bfc" id="L868" title="All 2 branches covered.">                if (ix &gt; 0) {</span>
<span class="fc" id="L869">                    head = name.substring(0, ix);</span>
<span class="fc" id="L870">                    name = name.substring(ix + 1);</span>
                } else {
<span class="fc" id="L872">                    head = name;</span>
<span class="fc" id="L873">                    name = &quot;&quot;;</span>
                }
<span class="fc bfc" id="L875" title="All 2 branches covered.">                if (node.children == null) {</span>
<span class="fc" id="L876">                    node.children = new HashMap&lt;&gt;();</span>
                }
<span class="fc" id="L878">                LogNode child = node.children.get(head);</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                if (child == null) {</span>
<span class="fc" id="L880">                    child = new LogNode(node, this);</span>
<span class="fc" id="L881">                    node.children.put(head, child);</span>
                }
<span class="fc" id="L883">                node = child;</span>
<span class="fc" id="L884">            }</span>
<span class="fc" id="L885">            return node;</span>
        }
    }

<span class="fc" id="L889">    final class SystemLoggerContext extends LoggerContext {</span>
        // Add a system logger in the system context's namespace as well as
        // in the LogManager's namespace if not exist so that there is only
        // one single logger of the given name.  System loggers are visible
        // to applications unless a logger of the same name has been added.
        @Override
        Logger demandLogger(String name, String resourceBundleName) {
<span class="fc" id="L896">            Logger result = findLogger(name);</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (result == null) {</span>
                // only allocate the new system logger once
<span class="fc" id="L899">                Logger newLogger = new Logger(name, resourceBundleName, null, getOwner());</span>
                do {
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">                    if (addLocalLogger(newLogger)) {</span>
                        // We successfully added the new Logger that we
                        // created above so return it without refetching.
<span class="fc" id="L904">                        result = newLogger;</span>
                    } else {
                        // We didn't add the new Logger that we created above
                        // because another thread added a Logger with the same
                        // name after our null check above and before our call
                        // to addLogger(). We have to refetch the Logger because
                        // addLogger() returns a boolean instead of the Logger
                        // reference itself. However, if the thread that created
                        // the other Logger is not holding a strong reference to
                        // the other Logger, then it is possible for the other
                        // Logger to be GC'ed after we saw it in addLogger() and
                        // before we can refetch it. If it has been GC'ed then
                        // we'll just loop around and try again.
<span class="nc" id="L917">                        result = findLogger(name);</span>
                    }
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">                } while (result == null);</span>
            }
<span class="fc" id="L921">            return result;</span>
        }
    }

    // Add new per logger handlers.
    // We need to raise privilege here. All our decisions will
    // be made based on the logging configuration, which can
    // only be modified by trusted code.
    private void loadLoggerHandlers(final Logger logger, final String name,
                                    final String handlersPropertyName)
    {
<span class="fc" id="L932">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
            @Override
            public Object run() {
<span class="fc" id="L935">                String names[] = parseClassNames(handlersPropertyName);</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">                for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L937">                    String word = names[i];</span>
                    try {
<span class="fc" id="L939">                        Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(word);</span>
<span class="fc" id="L940">                        Handler hdl = (Handler) clz.newInstance();</span>
                        // Check if there is a property defining the
                        // this handler's level.
<span class="fc" id="L943">                        String levs = getProperty(word + &quot;.level&quot;);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">                        if (levs != null) {</span>
<span class="fc" id="L945">                            Level l = Level.findLevel(levs);</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">                            if (l != null) {</span>
<span class="fc" id="L947">                                hdl.setLevel(l);</span>
                            } else {
                                // Probably a bad level. Drop through.
<span class="nc" id="L950">                                System.err.println(&quot;Can't set level for &quot; + word);</span>
                            }
                        }
                        // Add this Handler to the logger
<span class="fc" id="L954">                        logger.addHandler(hdl);</span>
<span class="nc" id="L955">                    } catch (Exception ex) {</span>
<span class="nc" id="L956">                        System.err.println(&quot;Can't load log handler \&quot;&quot; + word + &quot;\&quot;&quot;);</span>
<span class="nc" id="L957">                        System.err.println(&quot;&quot; + ex);</span>
<span class="nc" id="L958">                        ex.printStackTrace();</span>
<span class="fc" id="L959">                    }</span>
                }
<span class="fc" id="L961">                return null;</span>
            }
        });
<span class="fc" id="L964">    }</span>


    // loggerRefQueue holds LoggerWeakRef objects for Logger objects
    // that have been GC'ed.
<span class="fc" id="L969">    private final ReferenceQueue&lt;Logger&gt; loggerRefQueue</span>
        = new ReferenceQueue&lt;&gt;();

    // Package-level inner class.
    // Helper class for managing WeakReferences to Logger objects.
    //
    // LogManager.namedLoggers
    //     - has weak references to all named Loggers
    //     - namedLoggers keeps the LoggerWeakRef objects for the named
    //       Loggers around until we can deal with the book keeping for
    //       the named Logger that is being GC'ed.
    // LogManager.LogNode.loggerRef
    //     - has a weak reference to a named Logger
    //     - the LogNode will also keep the LoggerWeakRef objects for
    //       the named Loggers around; currently LogNodes never go away.
    // Logger.kids
    //     - has a weak reference to each direct child Logger; this
    //       includes anonymous and named Loggers
    //     - anonymous Loggers are always children of the rootLogger
    //       which is a strong reference; rootLogger.kids keeps the
    //       LoggerWeakRef objects for the anonymous Loggers around
    //       until we can deal with the book keeping.
    //
    final class LoggerWeakRef extends WeakReference&lt;Logger&gt; {
        private String                name;       // for namedLoggers cleanup
        private LogNode               node;       // for loggerRef cleanup
        private WeakReference&lt;Logger&gt; parentRef;  // for kids cleanup

<span class="fc" id="L997">        LoggerWeakRef(Logger logger) {</span>
<span class="fc" id="L998">            super(logger, loggerRefQueue);</span>

<span class="fc" id="L1000">            name = logger.getName();  // save for namedLoggers cleanup</span>
<span class="fc" id="L1001">        }</span>

        // dispose of this LoggerWeakRef object
        void dispose() {
<span class="fc bfc" id="L1005" title="All 2 branches covered.">            if (node != null) {</span>
                // if we have a LogNode, then we were a named Logger
                // so clear namedLoggers weak ref to us
<span class="fc" id="L1008">                node.context.removeLogger(name);</span>
<span class="fc" id="L1009">                name = null;  // clear our ref to the Logger's name</span>

<span class="fc" id="L1011">                node.loggerRef = null;  // clear LogNode's weak ref to us</span>
<span class="fc" id="L1012">                node = null;            // clear our ref to LogNode</span>
            }

<span class="fc bfc" id="L1015" title="All 2 branches covered.">            if (parentRef != null) {</span>
                // this LoggerWeakRef has or had a parent Logger
<span class="fc" id="L1017">                Logger parent = parentRef.get();</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">                if (parent != null) {</span>
                    // the parent Logger is still there so clear the
                    // parent Logger's weak ref to us
<span class="fc" id="L1021">                    parent.removeChildLogger(this);</span>
                }
<span class="fc" id="L1023">                parentRef = null;  // clear our weak ref to the parent Logger</span>
            }
<span class="fc" id="L1025">        }</span>

        // set the node field to the specified value
        void setNode(LogNode node) {
<span class="fc" id="L1029">            this.node = node;</span>
<span class="fc" id="L1030">        }</span>

        // set the parentRef field to the specified value
        void setParentRef(WeakReference&lt;Logger&gt; parentRef) {
<span class="fc" id="L1034">            this.parentRef = parentRef;</span>
<span class="fc" id="L1035">        }</span>
    }

    // Package-level method.
    // Drain some Logger objects that have been GC'ed.
    //
    // drainLoggerRefQueueBounded() is called by addLogger() below
    // and by Logger.getAnonymousLogger(String) so we'll drain up to
    // MAX_ITERATIONS GC'ed Loggers for every Logger we add.
    //
    // On a WinXP VMware client, a MAX_ITERATIONS value of 400 gives
    // us about a 50/50 mix in increased weak ref counts versus
    // decreased weak ref counts in the AnonLoggerWeakRefLeak test.
    // Here are stats for cleaning up sets of 400 anonymous Loggers:
    //   - test duration 1 minute
    //   - sample size of 125 sets of 400
    //   - average: 1.99 ms
    //   - minimum: 0.57 ms
    //   - maximum: 25.3 ms
    //
    // The same config gives us a better decreased weak ref count
    // than increased weak ref count in the LoggerWeakRefLeak test.
    // Here are stats for cleaning up sets of 400 named Loggers:
    //   - test duration 2 minutes
    //   - sample size of 506 sets of 400
    //   - average: 0.57 ms
    //   - minimum: 0.02 ms
    //   - maximum: 10.9 ms
    //
    private final static int MAX_ITERATIONS = 400;
    final synchronized void drainLoggerRefQueueBounded() {
<span class="fc bfc" id="L1066" title="All 2 branches covered.">        for (int i = 0; i &lt; MAX_ITERATIONS; i++) {</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">            if (loggerRefQueue == null) {</span>
                // haven't finished loading LogManager yet
<span class="nc" id="L1069">                break;</span>
            }

<span class="fc" id="L1072">            LoggerWeakRef ref = (LoggerWeakRef) loggerRefQueue.poll();</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">            if (ref == null) {</span>
<span class="fc" id="L1074">                break;</span>
            }
            // a Logger object has been GC'ed so clean it up
<span class="fc" id="L1077">            ref.dispose();</span>
        }
<span class="fc" id="L1079">    }</span>

    /**
     * Add a named logger.  This does nothing and returns false if a logger
     * with the same name is already registered.
     * &lt;p&gt;
     * The Logger factory methods call this method to register each
     * newly created Logger.
     * &lt;p&gt;
     * The application should retain its own reference to the Logger
     * object to avoid it being garbage collected.  The LogManager
     * may only retain a weak reference.
     *
     * @param   logger the new logger.
     * @return  true if the argument logger was registered successfully,
     *          false if a logger of that name already exists.
     * @exception NullPointerException if the logger name is null.
     */
    public boolean addLogger(Logger logger) {
<span class="fc" id="L1098">        final String name = logger.getName();</span>
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L1100">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1102">        drainLoggerRefQueueBounded();</span>
<span class="fc" id="L1103">        LoggerContext cx = getUserContext();</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">        if (cx.addLocalLogger(logger)) {</span>
            // Do we have a per logger handler too?
            // Note: this will add a 200ms penalty
<span class="fc" id="L1107">            loadLoggerHandlers(logger, name, name + &quot;.handlers&quot;);</span>
<span class="fc" id="L1108">            return true;</span>
        } else {
<span class="fc" id="L1110">            return false;</span>
        }
    }

    // Private method to set a level on a logger.
    // If necessary, we raise privilege before doing the call.
    private static void doSetLevel(final Logger logger, final Level level) {
<span class="fc" id="L1117">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">        if (sm == null) {</span>
            // There is no security manager, so things are easy.
<span class="fc" id="L1120">            logger.setLevel(level);</span>
<span class="fc" id="L1121">            return;</span>
        }
        // There is a security manager.  Raise privilege before
        // calling setLevel.
<span class="nc" id="L1125">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
            @Override
            public Object run() {
<span class="nc" id="L1128">                logger.setLevel(level);</span>
<span class="nc" id="L1129">                return null;</span>
            }});
<span class="nc" id="L1131">    }</span>

    // Private method to set a parent on a logger.
    // If necessary, we raise privilege before doing the setParent call.
    private static void doSetParent(final Logger logger, final Logger parent) {
<span class="fc" id="L1136">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        if (sm == null) {</span>
            // There is no security manager, so things are easy.
<span class="fc" id="L1139">            logger.setParent(parent);</span>
<span class="fc" id="L1140">            return;</span>
        }
        // There is a security manager.  Raise privilege before
        // calling setParent.
<span class="fc" id="L1144">        AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
            @Override
            public Object run() {
<span class="fc" id="L1147">                logger.setParent(parent);</span>
<span class="fc" id="L1148">                return null;</span>
            }});
<span class="fc" id="L1150">    }</span>

    /**
     * Method to find a named logger.
     * &lt;p&gt;
     * Note that since untrusted code may create loggers with
     * arbitrary names this method should not be relied on to
     * find Loggers for security sensitive logging.
     * It is also important to note that the Logger associated with the
     * String {@code name} may be garbage collected at any time if there
     * is no strong reference to the Logger. The caller of this method
     * must check the return value for null in order to properly handle
     * the case where the Logger has been garbage collected.
     * &lt;p&gt;
     * @param name name of the logger
     * @return  matching logger or null if none is found
     */
    public Logger getLogger(String name) {
<span class="fc" id="L1168">        return getUserContext().findLogger(name);</span>
    }

    /**
     * Get an enumeration of known logger names.
     * &lt;p&gt;
     * Note:  Loggers may be added dynamically as new classes are loaded.
     * This method only reports on the loggers that are currently registered.
     * It is also important to note that this method only returns the name
     * of a Logger, not a strong reference to the Logger itself.
     * The returned String does nothing to prevent the Logger from being
     * garbage collected. In particular, if the returned name is passed
     * to {@code LogManager.getLogger()}, then the caller must check the
     * return value from {@code LogManager.getLogger()} for null to properly
     * handle the case where the Logger has been garbage collected in the
     * time since its name was returned by this method.
     * &lt;p&gt;
     * @return  enumeration of logger name strings
     */
    public Enumeration&lt;String&gt; getLoggerNames() {
<span class="nc" id="L1188">        return getUserContext().getLoggerNames();</span>
    }

    /**
     * Reinitialize the logging properties and reread the logging configuration.
     * &lt;p&gt;
     * The same rules are used for locating the configuration properties
     * as are used at startup.  So normally the logging properties will
     * be re-read from the same file that was used at startup.
     * &lt;P&gt;
     * Any log level definitions in the new configuration file will be
     * applied using Logger.setLevel(), if the target Logger exists.
     * &lt;p&gt;
     * A PropertyChangeEvent will be fired after the properties are read.
     *
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     * @exception  IOException if there are IO problems reading the configuration.
     */
    public void readConfiguration() throws IOException, SecurityException {
<span class="fc" id="L1208">        checkPermission();</span>

        // if a configuration class is specified, load it and use it.
<span class="fc" id="L1211">        String cname = System.getProperty(&quot;java.util.logging.config.class&quot;);</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">        if (cname != null) {</span>
            try {
                // Instantiate the named class.  It is its constructor's
                // responsibility to initialize the logging configuration, by
                // calling readConfiguration(InputStream) with a suitable stream.
                try {
<span class="nc" id="L1218">                    Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(cname);</span>
<span class="nc" id="L1219">                    clz.newInstance();</span>
<span class="nc" id="L1220">                    return;</span>
<span class="nc" id="L1221">                } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L1222">                    Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(cname);</span>
<span class="nc" id="L1223">                    clz.newInstance();</span>
<span class="nc" id="L1224">                    return;</span>
                }
<span class="nc" id="L1226">            } catch (Exception ex) {</span>
<span class="nc" id="L1227">                System.err.println(&quot;Logging configuration class \&quot;&quot; + cname + &quot;\&quot; failed&quot;);</span>
<span class="nc" id="L1228">                System.err.println(&quot;&quot; + ex);</span>
                // keep going and useful config file.
            }
        }

<span class="fc" id="L1233">        String fname = System.getProperty(&quot;java.util.logging.config.file&quot;);</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        if (fname == null) {</span>
<span class="fc" id="L1235">            fname = System.getProperty(&quot;java.home&quot;);</span>
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">            if (fname == null) {</span>
<span class="nc" id="L1237">                throw new Error(&quot;Can't find java.home ??&quot;);</span>
            }
<span class="fc" id="L1239">            File f = new File(fname, &quot;lib&quot;);</span>
<span class="fc" id="L1240">            f = new File(f, &quot;logging.properties&quot;);</span>
<span class="fc" id="L1241">            fname = f.getCanonicalPath();</span>
        }
<span class="pc" id="L1243">        try (final InputStream in = new FileInputStream(fname)) {</span>
<span class="fc" id="L1244">            final BufferedInputStream bin = new BufferedInputStream(in);</span>
<span class="fc" id="L1245">            readConfiguration(bin);</span>
<span class="pc bpc" id="L1246" title="6 of 8 branches missed.">        }</span>
<span class="fc" id="L1247">    }</span>

    /**
     * Reset the logging configuration.
     * &lt;p&gt;
     * For all named loggers, the reset operation removes and closes
     * all Handlers and (except for the root logger) sets the level
     * to null.  The root logger's level is set to Level.INFO.
     *
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     */

    public void reset() throws SecurityException {
<span class="fc" id="L1261">        checkPermission();</span>
<span class="fc" id="L1262">        synchronized (this) {</span>
<span class="fc" id="L1263">            props = new Properties();</span>
            // Since we are doing a reset we no longer want to initialize
            // the global handlers, if they haven't been initialized yet.
<span class="fc" id="L1266">            initializedGlobalHandlers = true;</span>
<span class="pc" id="L1267">        }</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">        for (LoggerContext cx : contexts()) {</span>
<span class="fc" id="L1269">            Enumeration&lt;String&gt; enum_ = cx.getLoggerNames();</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">            while (enum_.hasMoreElements()) {</span>
<span class="fc" id="L1271">                String name = enum_.nextElement();</span>
<span class="fc" id="L1272">                Logger logger = cx.findLogger(name);</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">                if (logger != null) {</span>
<span class="fc" id="L1274">                    resetLogger(logger);</span>
                }
<span class="fc" id="L1276">            }</span>
<span class="fc" id="L1277">        }</span>
<span class="fc" id="L1278">    }</span>

    // Private method to reset an individual target logger.
    private void resetLogger(Logger logger) {
        // Close all the Logger's handlers.
<span class="fc" id="L1283">        Handler[] targets = logger.getHandlers();</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        for (int i = 0; i &lt; targets.length; i++) {</span>
<span class="fc" id="L1285">            Handler h = targets[i];</span>
<span class="fc" id="L1286">            logger.removeHandler(h);</span>
            try {
<span class="fc" id="L1288">                h.close();</span>
<span class="nc" id="L1289">            } catch (Exception ex) {</span>
                // Problems closing a handler?  Keep going...
<span class="fc" id="L1291">            }</span>
        }
<span class="fc" id="L1293">        String name = logger.getName();</span>
<span class="pc bpc" id="L1294" title="1 of 4 branches missed.">        if (name != null &amp;&amp; name.equals(&quot;&quot;)) {</span>
            // This is the root logger.
<span class="fc" id="L1296">            logger.setLevel(defaultLevel);</span>
        } else {
<span class="fc" id="L1298">            logger.setLevel(null);</span>
        }
<span class="fc" id="L1300">    }</span>

    // get a list of whitespace separated classnames from a property.
    private String[] parseClassNames(String propertyName) {
<span class="fc" id="L1304">        String hands = getProperty(propertyName);</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">        if (hands == null) {</span>
<span class="fc" id="L1306">            return new String[0];</span>
        }
<span class="fc" id="L1308">        hands = hands.trim();</span>
<span class="fc" id="L1309">        int ix = 0;</span>
<span class="fc" id="L1310">        final List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">        while (ix &lt; hands.length()) {</span>
<span class="fc" id="L1312">            int end = ix;</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            while (end &lt; hands.length()) {</span>
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">                if (Character.isWhitespace(hands.charAt(end))) {</span>
<span class="nc" id="L1315">                    break;</span>
                }
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">                if (hands.charAt(end) == ',') {</span>
<span class="nc" id="L1318">                    break;</span>
                }
<span class="fc" id="L1320">                end++;</span>
            }
<span class="fc" id="L1322">            String word = hands.substring(ix, end);</span>
<span class="fc" id="L1323">            ix = end+1;</span>
<span class="fc" id="L1324">            word = word.trim();</span>
<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">            if (word.length() == 0) {</span>
<span class="nc" id="L1326">                continue;</span>
            }
<span class="fc" id="L1328">            result.add(word);</span>
<span class="fc" id="L1329">        }</span>
<span class="fc" id="L1330">        return result.toArray(new String[result.size()]);</span>
    }

    /**
     * Reinitialize the logging properties and reread the logging configuration
     * from the given stream, which should be in java.util.Properties format.
     * A PropertyChangeEvent will be fired after the properties are read.
     * &lt;p&gt;
     * Any log level definitions in the new configuration file will be
     * applied using Logger.setLevel(), if the target Logger exists.
     *
     * @param ins       stream to read properties from
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     * @exception  IOException if there are problems reading from the stream.
     */
    public void readConfiguration(InputStream ins) throws IOException, SecurityException {
<span class="fc" id="L1347">        checkPermission();</span>
<span class="fc" id="L1348">        reset();</span>

        // Load the properties
<span class="fc" id="L1351">        props.load(ins);</span>
        // Instantiate new configuration objects.
<span class="fc" id="L1353">        String names[] = parseClassNames(&quot;config&quot;);</span>

<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc" id="L1356">            String word = names[i];</span>
            try {
<span class="nc" id="L1358">                Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(word);</span>
<span class="nc" id="L1359">                clz.newInstance();</span>
<span class="nc" id="L1360">            } catch (Exception ex) {</span>
<span class="nc" id="L1361">                System.err.println(&quot;Can't load config class \&quot;&quot; + word + &quot;\&quot;&quot;);</span>
<span class="nc" id="L1362">                System.err.println(&quot;&quot; + ex);</span>
                // ex.printStackTrace();
<span class="nc" id="L1364">            }</span>
        }

        // Set levels on any pre-existing loggers, based on the new properties.
<span class="fc" id="L1368">        setLevelsOnExistingLoggers();</span>

        // Notify any interested parties that our properties have changed.
        // We first take a copy of the listener map so that we aren't holding any
        // locks when calling the listeners.
<span class="fc" id="L1373">        Map&lt;Object,Integer&gt; listeners = null;</span>
<span class="fc" id="L1374">        synchronized (listenerMap) {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">            if (!listenerMap.isEmpty())</span>
<span class="fc" id="L1376">                listeners = new HashMap&lt;&gt;(listenerMap);</span>
<span class="pc" id="L1377">        }</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">        if (listeners != null) {</span>
<span class="pc bpc" id="L1379" title="2 of 4 branches missed.">            assert Beans.isBeansPresent();</span>
<span class="fc" id="L1380">            Object ev = Beans.newPropertyChangeEvent(LogManager.class, null, null, null);</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">            for (Map.Entry&lt;Object,Integer&gt; entry : listeners.entrySet()) {</span>
<span class="fc" id="L1382">                Object listener = entry.getKey();</span>
<span class="fc" id="L1383">                int count = entry.getValue().intValue();</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L1385">                    Beans.invokePropertyChange(listener, ev);</span>
                }
<span class="fc" id="L1387">            }</span>
        }


        // Note that we need to reinitialize global handles when
        // they are first referenced.
<span class="fc" id="L1393">        synchronized (this) {</span>
<span class="fc" id="L1394">            initializedGlobalHandlers = false;</span>
<span class="pc" id="L1395">        }</span>
<span class="fc" id="L1396">    }</span>

    /**
     * Get the value of a logging property.
     * The method returns null if the property is not found.
     * @param name      property name
     * @return          property value
     */
    public String getProperty(String name) {
<span class="fc" id="L1405">        return props.getProperty(name);</span>
    }

    // Package private method to get a String property.
    // If the property is not defined we return the given
    // default value.
    String getStringProperty(String name, String defaultValue) {
<span class="fc" id="L1412">        String val = getProperty(name);</span>
<span class="fc bfc" id="L1413" title="All 2 branches covered.">        if (val == null) {</span>
<span class="fc" id="L1414">            return defaultValue;</span>
        }
<span class="fc" id="L1416">        return val.trim();</span>
    }

    // Package private method to get an integer property.
    // If the property is not defined or cannot be parsed
    // we return the given default value.
    int getIntProperty(String name, int defaultValue) {
<span class="fc" id="L1423">        String val = getProperty(name);</span>
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        if (val == null) {</span>
<span class="fc" id="L1425">            return defaultValue;</span>
        }
        try {
<span class="fc" id="L1428">            return Integer.parseInt(val.trim());</span>
<span class="nc" id="L1429">        } catch (Exception ex) {</span>
<span class="nc" id="L1430">            return defaultValue;</span>
        }
    }

    // Package private method to get a boolean property.
    // If the property is not defined or cannot be parsed
    // we return the given default value.
    boolean getBooleanProperty(String name, boolean defaultValue) {
<span class="fc" id="L1438">        String val = getProperty(name);</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">        if (val == null) {</span>
<span class="fc" id="L1440">            return defaultValue;</span>
        }
<span class="fc" id="L1442">        val = val.toLowerCase();</span>
<span class="pc bpc" id="L1443" title="2 of 4 branches missed.">        if (val.equals(&quot;true&quot;) || val.equals(&quot;1&quot;)) {</span>
<span class="nc" id="L1444">            return true;</span>
<span class="pc bpc" id="L1445" title="3 of 4 branches missed.">        } else if (val.equals(&quot;false&quot;) || val.equals(&quot;0&quot;)) {</span>
<span class="fc" id="L1446">            return false;</span>
        }
<span class="nc" id="L1448">        return defaultValue;</span>
    }

    // Package private method to get a Level property.
    // If the property is not defined or cannot be parsed
    // we return the given default value.
    Level getLevelProperty(String name, Level defaultValue) {
<span class="fc" id="L1455">        String val = getProperty(name);</span>
<span class="fc bfc" id="L1456" title="All 2 branches covered.">        if (val == null) {</span>
<span class="fc" id="L1457">            return defaultValue;</span>
        }
<span class="fc" id="L1459">        Level l = Level.findLevel(val.trim());</span>
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">        return l != null ? l : defaultValue;</span>
    }

    // Package private method to get a filter property.
    // We return an instance of the class named by the &quot;name&quot;
    // property. If the property is not defined or has problems
    // we return the defaultValue.
    Filter getFilterProperty(String name, Filter defaultValue) {
<span class="fc" id="L1468">        String val = getProperty(name);</span>
        try {
<span class="pc bpc" id="L1470" title="1 of 2 branches missed.">            if (val != null) {</span>
<span class="nc" id="L1471">                Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(val);</span>
<span class="nc" id="L1472">                return (Filter) clz.newInstance();</span>
            }
<span class="nc" id="L1474">        } catch (Exception ex) {</span>
            // We got one of a variety of exceptions in creating the
            // class or creating an instance.
            // Drop through.
<span class="fc" id="L1478">        }</span>
        // We got an exception.  Return the defaultValue.
<span class="fc" id="L1480">        return defaultValue;</span>
    }


    // Package private method to get a formatter property.
    // We return an instance of the class named by the &quot;name&quot;
    // property. If the property is not defined or has problems
    // we return the defaultValue.
    Formatter getFormatterProperty(String name, Formatter defaultValue) {
<span class="fc" id="L1489">        String val = getProperty(name);</span>
        try {
<span class="fc bfc" id="L1491" title="All 2 branches covered.">            if (val != null) {</span>
<span class="fc" id="L1492">                Class&lt;?&gt; clz = ClassLoader.getSystemClassLoader().loadClass(val);</span>
<span class="fc" id="L1493">                return (Formatter) clz.newInstance();</span>
            }
<span class="nc" id="L1495">        } catch (Exception ex) {</span>
            // We got one of a variety of exceptions in creating the
            // class or creating an instance.
            // Drop through.
<span class="fc" id="L1499">        }</span>
        // We got an exception.  Return the defaultValue.
<span class="fc" id="L1501">        return defaultValue;</span>
    }

    // Private method to load the global handlers.
    // We do the real work lazily, when the global handlers
    // are first used.
    private synchronized void initializeGlobalHandlers() {
<span class="fc bfc" id="L1508" title="All 2 branches covered.">        if (initializedGlobalHandlers) {</span>
<span class="fc" id="L1509">            return;</span>
        }

<span class="fc" id="L1512">        initializedGlobalHandlers = true;</span>

<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">        if (deathImminent) {</span>
            // Aaargh...
            // The VM is shutting down and our exit hook has been called.
            // Avoid allocating global handlers.
<span class="nc" id="L1518">            return;</span>
        }
<span class="fc" id="L1520">        loadLoggerHandlers(rootLogger, null, &quot;handlers&quot;);</span>
<span class="fc" id="L1521">    }</span>

<span class="fc" id="L1523">    private final Permission controlPermission = new LoggingPermission(&quot;control&quot;, null);</span>

    void checkPermission() {
<span class="fc" id="L1526">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1527" title="All 2 branches covered.">        if (sm != null)</span>
<span class="fc" id="L1528">            sm.checkPermission(controlPermission);</span>
<span class="fc" id="L1529">    }</span>

    /**
     * Check that the current context is trusted to modify the logging
     * configuration.  This requires LoggingPermission(&quot;control&quot;).
     * &lt;p&gt;
     * If the check fails we throw a SecurityException, otherwise
     * we return normally.
     *
     * @exception  SecurityException  if a security manager exists and if
     *             the caller does not have LoggingPermission(&quot;control&quot;).
     */
    public void checkAccess() throws SecurityException {
<span class="nc" id="L1542">        checkPermission();</span>
<span class="nc" id="L1543">    }</span>

    // Nested class to represent a node in our tree of named loggers.
    private static class LogNode {
        HashMap&lt;String,LogNode&gt; children;
        LoggerWeakRef loggerRef;
        LogNode parent;
        final LoggerContext context;

<span class="fc" id="L1552">        LogNode(LogNode parent, LoggerContext context) {</span>
<span class="fc" id="L1553">            this.parent = parent;</span>
<span class="fc" id="L1554">            this.context = context;</span>
<span class="fc" id="L1555">        }</span>

        // Recursive method to walk the tree below a node and set
        // a new parent logger.
        void walkAndSetParent(Logger parent) {
<span class="fc bfc" id="L1560" title="All 2 branches covered.">            if (children == null) {</span>
<span class="fc" id="L1561">                return;</span>
            }
<span class="fc" id="L1563">            Iterator&lt;LogNode&gt; values = children.values().iterator();</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">            while (values.hasNext()) {</span>
<span class="fc" id="L1565">                LogNode node = values.next();</span>
<span class="fc" id="L1566">                LoggerWeakRef ref = node.loggerRef;</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">                Logger logger = (ref == null) ? null : ref.get();</span>
<span class="fc bfc" id="L1568" title="All 2 branches covered.">                if (logger == null) {</span>
<span class="fc" id="L1569">                    node.walkAndSetParent(parent);</span>
                } else {
<span class="fc" id="L1571">                    doSetParent(logger, parent);</span>
                }
<span class="fc" id="L1573">            }</span>
<span class="fc" id="L1574">        }</span>
    }

    // We use a subclass of Logger for the root logger, so
    // that we only instantiate the global handlers when they
    // are first needed.
    private final class RootLogger extends Logger {
<span class="fc" id="L1581">        private RootLogger() {</span>
            // We do not call the protected Logger two args constructor here,
            // to avoid calling LogManager.getLogManager() from within the
            // RootLogger constructor.
<span class="fc" id="L1585">            super(&quot;&quot;, null, null, LogManager.this);</span>
<span class="fc" id="L1586">            setLevel(defaultLevel);</span>
<span class="fc" id="L1587">        }</span>

        @Override
        public void log(LogRecord record) {
            // Make sure that the global handlers have been instantiated.
<span class="nc" id="L1592">            initializeGlobalHandlers();</span>
<span class="nc" id="L1593">            super.log(record);</span>
<span class="nc" id="L1594">        }</span>

        @Override
        public void addHandler(Handler h) {
<span class="fc" id="L1598">            initializeGlobalHandlers();</span>
<span class="fc" id="L1599">            super.addHandler(h);</span>
<span class="fc" id="L1600">        }</span>

        @Override
        public void removeHandler(Handler h) {
<span class="fc" id="L1604">            initializeGlobalHandlers();</span>
<span class="fc" id="L1605">            super.removeHandler(h);</span>
<span class="fc" id="L1606">        }</span>

        @Override
        public Handler[] getHandlers() {
<span class="fc" id="L1610">            initializeGlobalHandlers();</span>
<span class="fc" id="L1611">            return super.getHandlers();</span>
        }
    }


    // Private method to be called when the configuration has
    // changed to apply any level settings to any pre-existing loggers.
    synchronized private void setLevelsOnExistingLoggers() {
<span class="fc" id="L1619">        Enumeration&lt;?&gt; enum_ = props.propertyNames();</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">        while (enum_.hasMoreElements()) {</span>
<span class="fc" id="L1621">            String key = (String)enum_.nextElement();</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">            if (!key.endsWith(&quot;.level&quot;)) {</span>
                // Not a level definition.
<span class="fc" id="L1624">                continue;</span>
            }
<span class="fc" id="L1626">            int ix = key.length() - 6;</span>
<span class="fc" id="L1627">            String name = key.substring(0, ix);</span>
<span class="fc" id="L1628">            Level level = getLevelProperty(key, null);</span>
<span class="pc bpc" id="L1629" title="1 of 2 branches missed.">            if (level == null) {</span>
<span class="nc" id="L1630">                System.err.println(&quot;Bad level value for property: &quot; + key);</span>
<span class="nc" id="L1631">                continue;</span>
            }
<span class="fc bfc" id="L1633" title="All 2 branches covered.">            for (LoggerContext cx : contexts()) {</span>
<span class="fc" id="L1634">                Logger l = cx.findLogger(name);</span>
<span class="fc bfc" id="L1635" title="All 2 branches covered.">                if (l == null) {</span>
<span class="fc" id="L1636">                    continue;</span>
                }
<span class="fc" id="L1638">                l.setLevel(level);</span>
<span class="fc" id="L1639">            }</span>
<span class="fc" id="L1640">        }</span>
<span class="fc" id="L1641">    }</span>

    // Management Support
<span class="fc" id="L1644">    private static LoggingMXBean loggingMXBean = null;</span>
    /**
     * String representation of the
     * {@link javax.management.ObjectName} for the management interface
     * for the logging facility.
     *
     * @see java.lang.management.PlatformLoggingMXBean
     * @see java.util.logging.LoggingMXBean
     *
     * @since 1.5
     */
    public final static String LOGGING_MXBEAN_NAME
        = &quot;java.util.logging:type=Logging&quot;;

    /**
     * Returns &lt;tt&gt;LoggingMXBean&lt;/tt&gt; for managing loggers.
     * An alternative way to manage loggers is through the
     * {@link java.lang.management.PlatformLoggingMXBean} interface
     * that can be obtained by calling:
     * &lt;pre&gt;
     *     PlatformLoggingMXBean logging = {@link java.lang.management.ManagementFactory#getPlatformMXBean(Class)
     *         ManagementFactory.getPlatformMXBean}(PlatformLoggingMXBean.class);
     * &lt;/pre&gt;
     *
     * @return a {@link LoggingMXBean} object.
     *
     * @see java.lang.management.PlatformLoggingMXBean
     * @since 1.5
     */
    public static synchronized LoggingMXBean getLoggingMXBean() {
<span class="nc bnc" id="L1674" title="All 2 branches missed.">        if (loggingMXBean == null) {</span>
<span class="nc" id="L1675">            loggingMXBean =  new Logging();</span>
        }
<span class="nc" id="L1677">        return loggingMXBean;</span>
    }

    /**
     * A class that provides access to the java.beans.PropertyChangeListener
     * and java.beans.PropertyChangeEvent without creating a static dependency
     * on java.beans. This class can be removed once the addPropertyChangeListener
     * and removePropertyChangeListener methods are removed.
     */
<span class="nc" id="L1686">    private static class Beans {</span>
<span class="fc" id="L1687">        private static final Class&lt;?&gt; propertyChangeListenerClass =</span>
<span class="fc" id="L1688">            getClass(&quot;java.beans.PropertyChangeListener&quot;);</span>

<span class="fc" id="L1690">        private static final Class&lt;?&gt; propertyChangeEventClass =</span>
<span class="fc" id="L1691">            getClass(&quot;java.beans.PropertyChangeEvent&quot;);</span>

<span class="fc" id="L1693">        private static final Method propertyChangeMethod =</span>
<span class="fc" id="L1694">            getMethod(propertyChangeListenerClass,</span>
                      &quot;propertyChange&quot;,
                      propertyChangeEventClass);

<span class="fc" id="L1698">        private static final Constructor&lt;?&gt; propertyEventCtor =</span>
<span class="fc" id="L1699">            getConstructor(propertyChangeEventClass,</span>
                           Object.class,
                           String.class,
                           Object.class,
                           Object.class);

        private static Class&lt;?&gt; getClass(String name) {
            try {
<span class="fc" id="L1707">                return Class.forName(name, true, Beans.class.getClassLoader());</span>
<span class="nc" id="L1708">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1709">                return null;</span>
            }
        }
        private static Constructor&lt;?&gt; getConstructor(Class&lt;?&gt; c, Class&lt;?&gt;... types) {
            try {
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">                return (c == null) ? null : c.getDeclaredConstructor(types);</span>
<span class="nc" id="L1715">            } catch (NoSuchMethodException x) {</span>
<span class="nc" id="L1716">                throw new AssertionError(x);</span>
            }
        }

        private static Method getMethod(Class&lt;?&gt; c, String name, Class&lt;?&gt;... types) {
            try {
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">                return (c == null) ? null : c.getMethod(name, types);</span>
<span class="nc" id="L1723">            } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L1724">                throw new AssertionError(e);</span>
            }
        }

        /**
         * Returns {@code true} if java.beans is present.
         */
        static boolean isBeansPresent() {
<span class="pc bpc" id="L1732" title="2 of 4 branches missed.">            return propertyChangeListenerClass != null &amp;&amp;</span>
                   propertyChangeEventClass != null;
        }

        /**
         * Returns a new PropertyChangeEvent with the given source, property
         * name, old and new values.
         */
        static Object newPropertyChangeEvent(Object source, String prop,
                                             Object oldValue, Object newValue)
        {
            try {
<span class="fc" id="L1744">                return propertyEventCtor.newInstance(source, prop, oldValue, newValue);</span>
<span class="nc" id="L1745">            } catch (InstantiationException | IllegalAccessException x) {</span>
<span class="nc" id="L1746">                throw new AssertionError(x);</span>
<span class="nc" id="L1747">            } catch (InvocationTargetException x) {</span>
<span class="nc" id="L1748">                Throwable cause = x.getCause();</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">                if (cause instanceof Error)</span>
<span class="nc" id="L1750">                    throw (Error)cause;</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">                if (cause instanceof RuntimeException)</span>
<span class="nc" id="L1752">                    throw (RuntimeException)cause;</span>
<span class="nc" id="L1753">                throw new AssertionError(x);</span>
            }
        }

        /**
         * Invokes the given PropertyChangeListener's propertyChange method
         * with the given event.
         */
        static void invokePropertyChange(Object listener, Object ev) {
            try {
<span class="fc" id="L1763">                propertyChangeMethod.invoke(listener, ev);</span>
<span class="nc" id="L1764">            } catch (IllegalAccessException x) {</span>
<span class="nc" id="L1765">                throw new AssertionError(x);</span>
<span class="nc" id="L1766">            } catch (InvocationTargetException x) {</span>
<span class="nc" id="L1767">                Throwable cause = x.getCause();</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">                if (cause instanceof Error)</span>
<span class="nc" id="L1769">                    throw (Error)cause;</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">                if (cause instanceof RuntimeException)</span>
<span class="nc" id="L1771">                    throw (RuntimeException)cause;</span>
<span class="nc" id="L1772">                throw new AssertionError(x);</span>
<span class="fc" id="L1773">            }</span>
<span class="fc" id="L1774">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>