<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LogRecord.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.logging</a> &gt; <span class="el_source">LogRecord.java</span></div><h1>LogRecord.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.logging;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.io.*;

import sun.misc.JavaLangAccess;
import sun.misc.SharedSecrets;

/**
 * LogRecord objects are used to pass logging requests between
 * the logging framework and individual log Handlers.
 * &lt;p&gt;
 * When a LogRecord is passed into the logging framework it
 * logically belongs to the framework and should no longer be
 * used or updated by the client application.
 * &lt;p&gt;
 * Note that if the client application has not specified an
 * explicit source method name and source class name, then the
 * LogRecord class will infer them automatically when they are
 * first accessed (due to a call on getSourceMethodName or
 * getSourceClassName) by analyzing the call stack.  Therefore,
 * if a logging Handler wants to pass off a LogRecord to another
 * thread, or to transmit it over RMI, and if it wishes to subsequently
 * obtain method name or class name information it should call
 * one of getSourceClassName or getSourceMethodName to force
 * the values to be filled in.
 * &lt;p&gt;
 * &lt;b&gt; Serialization notes:&lt;/b&gt;
 * &lt;ul&gt;
 * &lt;li&gt;The LogRecord class is serializable.
 *
 * &lt;li&gt; Because objects in the parameters array may not be serializable,
 * during serialization all objects in the parameters array are
 * written as the corresponding Strings (using Object.toString).
 *
 * &lt;li&gt; The ResourceBundle is not transmitted as part of the serialized
 * form, but the resource bundle name is, and the recipient object's
 * readObject method will attempt to locate a suitable resource bundle.
 *
 * &lt;/ul&gt;
 *
 * @since 1.4
 */

public class LogRecord implements java.io.Serializable {
<span class="fc" id="L72">    private static final AtomicLong globalSequenceNumber</span>
        = new AtomicLong(0);

    /**
     * The default value of threadID will be the current thread's
     * thread id, for ease of correlation, unless it is greater than
     * MIN_SEQUENTIAL_THREAD_ID, in which case we try harder to keep
     * our promise to keep threadIDs unique by avoiding collisions due
     * to 32-bit wraparound.  Unfortunately, LogRecord.getThreadID()
     * returns int, while Thread.getId() returns long.
     */
    private static final int MIN_SEQUENTIAL_THREAD_ID = Integer.MAX_VALUE / 2;

<span class="fc" id="L85">    private static final AtomicInteger nextThreadId</span>
        = new AtomicInteger(MIN_SEQUENTIAL_THREAD_ID);

<span class="fc" id="L88">    private static final ThreadLocal&lt;Integer&gt; threadIds = new ThreadLocal&lt;&gt;();</span>

    /**
     * @serial Logging message level
     */
    private Level level;

    /**
     * @serial Sequence number
     */
    private long sequenceNumber;

    /**
     * @serial Class that issued logging call
     */
    private String sourceClassName;

    /**
     * @serial Method that issued logging call
     */
    private String sourceMethodName;

    /**
     * @serial Non-localized raw message text
     */
    private String message;

    /**
     * @serial Thread ID for thread that issued logging call.
     */
    private int threadID;

    /**
     * @serial Event time in milliseconds since 1970
     */
    private long millis;

    /**
     * @serial The Throwable (if any) associated with log message
     */
    private Throwable thrown;

    /**
     * @serial Name of the source Logger.
     */
    private String loggerName;

    /**
     * @serial Resource bundle name to localized log message.
     */
    private String resourceBundleName;

    private transient boolean needToInferCaller;
    private transient Object parameters[];
    private transient ResourceBundle resourceBundle;

    /**
     * Returns the default value for a new LogRecord's threadID.
     */
    private int defaultThreadID() {
<span class="fc" id="L148">        long tid = Thread.currentThread().getId();</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (tid &lt; MIN_SEQUENTIAL_THREAD_ID) {</span>
<span class="fc" id="L150">            return (int) tid;</span>
        } else {
<span class="nc" id="L152">            Integer id = threadIds.get();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (id == null) {</span>
<span class="nc" id="L154">                id = nextThreadId.getAndIncrement();</span>
<span class="nc" id="L155">                threadIds.set(id);</span>
            }
<span class="nc" id="L157">            return id;</span>
        }
    }

    /**
     * Construct a LogRecord with the given level and message values.
     * &lt;p&gt;
     * The sequence property will be initialized with a new unique value.
     * These sequence values are allocated in increasing order within a VM.
     * &lt;p&gt;
     * The millis property will be initialized to the current time.
     * &lt;p&gt;
     * The thread ID property will be initialized with a unique ID for
     * the current thread.
     * &lt;p&gt;
     * All other properties will be initialized to &quot;null&quot;.
     *
     * @param level  a logging level value
     * @param msg  the raw non-localized logging message (may be null)
     */
<span class="fc" id="L177">    public LogRecord(Level level, String msg) {</span>
        // Make sure level isn't null, by calling random method.
<span class="fc" id="L179">        level.getClass();</span>
<span class="fc" id="L180">        this.level = level;</span>
<span class="fc" id="L181">        message = msg;</span>
        // Assign a thread ID and a unique sequence number.
<span class="fc" id="L183">        sequenceNumber = globalSequenceNumber.getAndIncrement();</span>
<span class="fc" id="L184">        threadID = defaultThreadID();</span>
<span class="fc" id="L185">        millis = System.currentTimeMillis();</span>
<span class="fc" id="L186">        needToInferCaller = true;</span>
<span class="fc" id="L187">   }</span>

    /**
     * Get the source Logger's name.
     *
     * @return source logger name (may be null)
     */
    public String getLoggerName() {
<span class="fc" id="L195">        return loggerName;</span>
    }

    /**
     * Set the source Logger's name.
     *
     * @param name   the source logger name (may be null)
     */
    public void setLoggerName(String name) {
<span class="fc" id="L204">        loggerName = name;</span>
<span class="fc" id="L205">    }</span>

    /**
     * Get the localization resource bundle
     * &lt;p&gt;
     * This is the ResourceBundle that should be used to localize
     * the message string before formatting it.  The result may
     * be null if the message is not localizable, or if no suitable
     * ResourceBundle is available.
     * @return the localization resource bundle
     */
    public ResourceBundle getResourceBundle() {
<span class="fc" id="L217">        return resourceBundle;</span>
    }

    /**
     * Set the localization resource bundle.
     *
     * @param bundle  localization bundle (may be null)
     */
    public void setResourceBundle(ResourceBundle bundle) {
<span class="fc" id="L226">        resourceBundle = bundle;</span>
<span class="fc" id="L227">    }</span>

    /**
     * Get the localization resource bundle name
     * &lt;p&gt;
     * This is the name for the ResourceBundle that should be
     * used to localize the message string before formatting it.
     * The result may be null if the message is not localizable.
     * @return the localization resource bundle name
     */
    public String getResourceBundleName() {
<span class="fc" id="L238">        return resourceBundleName;</span>
    }

    /**
     * Set the localization resource bundle name.
     *
     * @param name  localization bundle name (may be null)
     */
    public void setResourceBundleName(String name) {
<span class="fc" id="L247">        resourceBundleName = name;</span>
<span class="fc" id="L248">    }</span>

    /**
     * Get the logging message level, for example Level.SEVERE.
     * @return the logging message level
     */
    public Level getLevel() {
<span class="fc" id="L255">        return level;</span>
    }

    /**
     * Set the logging message level, for example Level.SEVERE.
     * @param level the logging message level
     */
    public void setLevel(Level level) {
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (level == null) {</span>
<span class="nc" id="L264">            throw new NullPointerException();</span>
        }
<span class="nc" id="L266">        this.level = level;</span>
<span class="nc" id="L267">    }</span>

    /**
     * Get the sequence number.
     * &lt;p&gt;
     * Sequence numbers are normally assigned in the LogRecord
     * constructor, which assigns unique sequence numbers to
     * each new LogRecord in increasing order.
     * @return the sequence number
     */
    public long getSequenceNumber() {
<span class="fc" id="L278">        return sequenceNumber;</span>
    }

    /**
     * Set the sequence number.
     * &lt;p&gt;
     * Sequence numbers are normally assigned in the LogRecord constructor,
     * so it should not normally be necessary to use this method.
     * @param seq the sequence number
     */
    public void setSequenceNumber(long seq) {
<span class="nc" id="L289">        sequenceNumber = seq;</span>
<span class="nc" id="L290">    }</span>

    /**
     * Get the  name of the class that (allegedly) issued the logging request.
     * &lt;p&gt;
     * Note that this sourceClassName is not verified and may be spoofed.
     * This information may either have been provided as part of the
     * logging call, or it may have been inferred automatically by the
     * logging framework.  In the latter case, the information may only
     * be approximate and may in fact describe an earlier call on the
     * stack frame.
     * &lt;p&gt;
     * May be null if no information could be obtained.
     *
     * @return the source class name
     */
    public String getSourceClassName() {
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (needToInferCaller) {</span>
<span class="fc" id="L308">            inferCaller();</span>
        }
<span class="fc" id="L310">        return sourceClassName;</span>
    }

    /**
     * Set the name of the class that (allegedly) issued the logging request.
     *
     * @param sourceClassName the source class name (may be null)
     */
    public void setSourceClassName(String sourceClassName) {
<span class="fc" id="L319">        this.sourceClassName = sourceClassName;</span>
<span class="fc" id="L320">        needToInferCaller = false;</span>
<span class="fc" id="L321">    }</span>

    /**
     * Get the  name of the method that (allegedly) issued the logging request.
     * &lt;p&gt;
     * Note that this sourceMethodName is not verified and may be spoofed.
     * This information may either have been provided as part of the
     * logging call, or it may have been inferred automatically by the
     * logging framework.  In the latter case, the information may only
     * be approximate and may in fact describe an earlier call on the
     * stack frame.
     * &lt;p&gt;
     * May be null if no information could be obtained.
     *
     * @return the source method name
     */
    public String getSourceMethodName() {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (needToInferCaller) {</span>
<span class="nc" id="L339">            inferCaller();</span>
        }
<span class="fc" id="L341">        return sourceMethodName;</span>
    }

    /**
     * Set the name of the method that (allegedly) issued the logging request.
     *
     * @param sourceMethodName the source method name (may be null)
     */
    public void setSourceMethodName(String sourceMethodName) {
<span class="fc" id="L350">        this.sourceMethodName = sourceMethodName;</span>
<span class="fc" id="L351">        needToInferCaller = false;</span>
<span class="fc" id="L352">    }</span>

    /**
     * Get the &quot;raw&quot; log message, before localization or formatting.
     * &lt;p&gt;
     * May be null, which is equivalent to the empty string &quot;&quot;.
     * &lt;p&gt;
     * This message may be either the final text or a localization key.
     * &lt;p&gt;
     * During formatting, if the source logger has a localization
     * ResourceBundle and if that ResourceBundle has an entry for
     * this message string, then the message string is replaced
     * with the localized value.
     *
     * @return the raw message string
     */
    public String getMessage() {
<span class="fc" id="L369">        return message;</span>
    }

    /**
     * Set the &quot;raw&quot; log message, before localization or formatting.
     *
     * @param message the raw message string (may be null)
     */
    public void setMessage(String message) {
<span class="nc" id="L378">        this.message = message;</span>
<span class="nc" id="L379">    }</span>

    /**
     * Get the parameters to the log message.
     *
     * @return the log message parameters.  May be null if
     *                  there are no parameters.
     */
    public Object[] getParameters() {
<span class="fc" id="L388">        return parameters;</span>
    }

    /**
     * Set the parameters to the log message.
     *
     * @param parameters the log message parameters. (may be null)
     */
    public void setParameters(Object parameters[]) {
<span class="fc" id="L397">        this.parameters = parameters;</span>
<span class="fc" id="L398">    }</span>

    /**
     * Get an identifier for the thread where the message originated.
     * &lt;p&gt;
     * This is a thread identifier within the Java VM and may or
     * may not map to any operating system ID.
     *
     * @return thread ID
     */
    public int getThreadID() {
<span class="fc" id="L409">        return threadID;</span>
    }

    /**
     * Set an identifier for the thread where the message originated.
     * @param threadID  the thread ID
     */
    public void setThreadID(int threadID) {
<span class="nc" id="L417">        this.threadID = threadID;</span>
<span class="nc" id="L418">    }</span>

    /**
     * Get event time in milliseconds since 1970.
     *
     * @return event time in millis since 1970
     */
    public long getMillis() {
<span class="fc" id="L426">        return millis;</span>
    }

    /**
     * Set event time.
     *
     * @param millis event time in millis since 1970
     */
    public void setMillis(long millis) {
<span class="nc" id="L435">        this.millis = millis;</span>
<span class="nc" id="L436">    }</span>

    /**
     * Get any throwable associated with the log record.
     * &lt;p&gt;
     * If the event involved an exception, this will be the
     * exception object. Otherwise null.
     *
     * @return a throwable
     */
    public Throwable getThrown() {
<span class="fc" id="L447">        return thrown;</span>
    }

    /**
     * Set a throwable associated with the log event.
     *
     * @param thrown  a throwable (may be null)
     */
    public void setThrown(Throwable thrown) {
<span class="fc" id="L456">        this.thrown = thrown;</span>
<span class="fc" id="L457">    }</span>

    private static final long serialVersionUID = 5372048053134512534L;

    /**
     * @serialData Default fields, followed by a two byte version number
     * (major byte, followed by minor byte), followed by information on
     * the log record parameter array.  If there is no parameter array,
     * then -1 is written.  If there is a parameter array (possible of zero
     * length) then the array length is written as an integer, followed
     * by String values for each parameter.  If a parameter is null, then
     * a null String is written.  Otherwise the output of Object.toString()
     * is written.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // We have to call defaultWriteObject first.
<span class="nc" id="L473">        out.defaultWriteObject();</span>

        // Write our version number.
<span class="nc" id="L476">        out.writeByte(1);</span>
<span class="nc" id="L477">        out.writeByte(0);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (parameters == null) {</span>
<span class="nc" id="L479">            out.writeInt(-1);</span>
<span class="nc" id="L480">            return;</span>
        }
<span class="nc" id="L482">        out.writeInt(parameters.length);</span>
        // Write string values for the parameters.
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (parameters[i] == null) {</span>
<span class="nc" id="L486">                out.writeObject(null);</span>
            } else {
<span class="nc" id="L488">                out.writeObject(parameters[i].toString());</span>
            }
        }
<span class="nc" id="L491">    }</span>

    private void readObject(ObjectInputStream in)
                        throws IOException, ClassNotFoundException {
        // We have to call defaultReadObject first.
<span class="nc" id="L496">        in.defaultReadObject();</span>

        // Read version number.
<span class="nc" id="L499">        byte major = in.readByte();</span>
<span class="nc" id="L500">        byte minor = in.readByte();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (major != 1) {</span>
<span class="nc" id="L502">            throw new IOException(&quot;LogRecord: bad version: &quot; + major + &quot;.&quot; + minor);</span>
        }
<span class="nc" id="L504">        int len = in.readInt();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (len == -1) {</span>
<span class="nc" id="L506">            parameters = null;</span>
        } else {
<span class="nc" id="L508">            parameters = new Object[len];</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="nc" id="L510">                parameters[i] = in.readObject();</span>
            }
        }
        // If necessary, try to regenerate the resource bundle.
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (resourceBundleName != null) {</span>
            try {
<span class="nc" id="L516">                resourceBundle = ResourceBundle.getBundle(resourceBundleName);</span>
<span class="nc" id="L517">            } catch (MissingResourceException ex) {</span>
                // This is not a good place to throw an exception,
                // so we simply leave the resourceBundle null.
<span class="nc" id="L520">                resourceBundle = null;</span>
<span class="nc" id="L521">            }</span>
        }

<span class="nc" id="L524">        needToInferCaller = false;</span>
<span class="nc" id="L525">    }</span>

    // Private method to infer the caller's class and method names
    private void inferCaller() {
<span class="fc" id="L529">        needToInferCaller = false;</span>
<span class="fc" id="L530">        JavaLangAccess access = SharedSecrets.getJavaLangAccess();</span>
<span class="fc" id="L531">        Throwable throwable = new Throwable();</span>
<span class="fc" id="L532">        int depth = access.getStackTraceDepth(throwable);</span>

<span class="fc" id="L534">        boolean lookingForLogger = true;</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        for (int ix = 0; ix &lt; depth; ix++) {</span>
            // Calling getStackTraceElement directly prevents the VM
            // from paying the cost of building the entire stack frame.
<span class="fc" id="L538">            StackTraceElement frame =</span>
<span class="fc" id="L539">                access.getStackTraceElement(throwable, ix);</span>
<span class="fc" id="L540">            String cname = frame.getClassName();</span>
<span class="fc" id="L541">            boolean isLoggerImpl = isLoggerImplFrame(cname);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (lookingForLogger) {</span>
                // Skip all frames until we have found the first logger frame.
<span class="fc bfc" id="L544" title="All 2 branches covered.">                if (isLoggerImpl) {</span>
<span class="fc" id="L545">                    lookingForLogger = false;</span>
                }
            } else {
<span class="fc bfc" id="L548" title="All 2 branches covered.">                if (!isLoggerImpl) {</span>
                    // skip reflection call
<span class="pc bpc" id="L550" title="2 of 4 branches missed.">                    if (!cname.startsWith(&quot;java.lang.reflect.&quot;) &amp;&amp; !cname.startsWith(&quot;sun.reflect.&quot;)) {</span>
                       // We've found the relevant frame.
<span class="fc" id="L552">                       setSourceClassName(cname);</span>
<span class="fc" id="L553">                       setSourceMethodName(frame.getMethodName());</span>
<span class="fc" id="L554">                       return;</span>
                    }
                }
            }
        }
        // We haven't found a suitable frame, so just punt.  This is
        // OK as we are only committed to making a &quot;best effort&quot; here.
<span class="nc" id="L561">    }</span>

    private boolean isLoggerImplFrame(String cname) {
        // the log record could be created for a platform logger
<span class="fc bfc" id="L565" title="All 2 branches covered.">        return (cname.equals(&quot;java.util.logging.Logger&quot;) ||</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">                cname.startsWith(&quot;java.util.logging.LoggingProxyImpl&quot;) ||</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                cname.startsWith(&quot;sun.util.logging.&quot;));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>