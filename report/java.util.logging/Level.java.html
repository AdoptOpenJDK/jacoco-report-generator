<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Level.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.logging</a> &gt; <span class="el_source">Level.java</span></div><h1>Level.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.util.logging;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

/**
 * The Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * &lt;p&gt;
 * Clients should normally use the predefined Level constants such
 * as Level.SEVERE.
 * &lt;p&gt;
 * The levels in descending order are:
 * &lt;ul&gt;
 * &lt;li&gt;SEVERE (highest value)
 * &lt;li&gt;WARNING
 * &lt;li&gt;INFO
 * &lt;li&gt;CONFIG
 * &lt;li&gt;FINE
 * &lt;li&gt;FINER
 * &lt;li&gt;FINEST  (lowest value)
 * &lt;/ul&gt;
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 * &lt;p&gt;
 * It is possible for third parties to define additional logging
 * levels by subclassing Level.  In such cases subclasses should
 * take care to chose unique integer level values and to ensure that
 * they maintain the Object uniqueness property across serialization
 * by defining a suitable readResolve method.
 *
 * @since 1.4
 */

public class Level implements java.io.Serializable {
    private static final String defaultBundle = &quot;sun.util.loggingresources.logging&quot;;

    /**
     * @serial  The non-localized name of the level.
     */
    private final String name;

    /**
     * @serial  The integer value of the level.
     */
    private final int value;

    /**
     * @serial The resource bundle name to be used in localizing the level name.
     */
    private final String resourceBundleName;

    // localized level name
    private transient String localizedLevelName;
    private transient Locale cachedLocale;

    /**
     * OFF is a special level that can be used to turn off logging.
     * This level is initialized to &lt;CODE&gt;Integer.MAX_VALUE&lt;/CODE&gt;.
     */
<span class="fc" id="L92">    public static final Level OFF = new Level(&quot;OFF&quot;,Integer.MAX_VALUE, defaultBundle);</span>

    /**
     * SEVERE is a message level indicating a serious failure.
     * &lt;p&gt;
     * In general SEVERE messages should describe events that are
     * of considerable importance and which will prevent normal
     * program execution.   They should be reasonably intelligible
     * to end users and to system administrators.
     * This level is initialized to &lt;CODE&gt;1000&lt;/CODE&gt;.
     */
<span class="fc" id="L103">    public static final Level SEVERE = new Level(&quot;SEVERE&quot;,1000, defaultBundle);</span>

    /**
     * WARNING is a message level indicating a potential problem.
     * &lt;p&gt;
     * In general WARNING messages should describe events that will
     * be of interest to end users or system managers, or which
     * indicate potential problems.
     * This level is initialized to &lt;CODE&gt;900&lt;/CODE&gt;.
     */
<span class="fc" id="L113">    public static final Level WARNING = new Level(&quot;WARNING&quot;, 900, defaultBundle);</span>

    /**
     * INFO is a message level for informational messages.
     * &lt;p&gt;
     * Typically INFO messages will be written to the console
     * or its equivalent.  So the INFO level should only be
     * used for reasonably significant messages that will
     * make sense to end users and system administrators.
     * This level is initialized to &lt;CODE&gt;800&lt;/CODE&gt;.
     */
<span class="fc" id="L124">    public static final Level INFO = new Level(&quot;INFO&quot;, 800, defaultBundle);</span>

    /**
     * CONFIG is a message level for static configuration messages.
     * &lt;p&gt;
     * CONFIG messages are intended to provide a variety of static
     * configuration information, to assist in debugging problems
     * that may be associated with particular configurations.
     * For example, CONFIG message might include the CPU type,
     * the graphics depth, the GUI look-and-feel, etc.
     * This level is initialized to &lt;CODE&gt;700&lt;/CODE&gt;.
     */
<span class="fc" id="L136">    public static final Level CONFIG = new Level(&quot;CONFIG&quot;, 700, defaultBundle);</span>

    /**
     * FINE is a message level providing tracing information.
     * &lt;p&gt;
     * All of FINE, FINER, and FINEST are intended for relatively
     * detailed tracing.  The exact meaning of the three levels will
     * vary between subsystems, but in general, FINEST should be used
     * for the most voluminous detailed output, FINER for somewhat
     * less detailed output, and FINE for the  lowest volume (and
     * most important) messages.
     * &lt;p&gt;
     * In general the FINE level should be used for information
     * that will be broadly interesting to developers who do not have
     * a specialized interest in the specific subsystem.
     * &lt;p&gt;
     * FINE messages might include things like minor (recoverable)
     * failures.  Issues indicating potential performance problems
     * are also worth logging as FINE.
     * This level is initialized to &lt;CODE&gt;500&lt;/CODE&gt;.
     */
<span class="fc" id="L157">    public static final Level FINE = new Level(&quot;FINE&quot;, 500, defaultBundle);</span>

    /**
     * FINER indicates a fairly detailed tracing message.
     * By default logging calls for entering, returning, or throwing
     * an exception are traced at this level.
     * This level is initialized to &lt;CODE&gt;400&lt;/CODE&gt;.
     */
<span class="fc" id="L165">    public static final Level FINER = new Level(&quot;FINER&quot;, 400, defaultBundle);</span>

    /**
     * FINEST indicates a highly detailed tracing message.
     * This level is initialized to &lt;CODE&gt;300&lt;/CODE&gt;.
     */
<span class="fc" id="L171">    public static final Level FINEST = new Level(&quot;FINEST&quot;, 300, defaultBundle);</span>

    /**
     * ALL indicates that all messages should be logged.
     * This level is initialized to &lt;CODE&gt;Integer.MIN_VALUE&lt;/CODE&gt;.
     */
<span class="fc" id="L177">    public static final Level ALL = new Level(&quot;ALL&quot;, Integer.MIN_VALUE, defaultBundle);</span>

    /**
     * Create a named Level with a given integer value.
     * &lt;p&gt;
     * Note that this constructor is &quot;protected&quot; to allow subclassing.
     * In general clients of logging should use one of the constant Level
     * objects such as SEVERE or FINEST.  However, if clients need to
     * add new logging levels, they may subclass Level and define new
     * constants.
     * @param name  the name of the Level, for example &quot;SEVERE&quot;.
     * @param value an integer value for the level.
     * @throws NullPointerException if the name is null
     */
    protected Level(String name, int value) {
<span class="fc" id="L192">        this(name, value, null);</span>
<span class="fc" id="L193">    }</span>

    /**
     * Create a named Level with a given integer value and a
     * given localization resource name.
     * &lt;p&gt;
     * @param name  the name of the Level, for example &quot;SEVERE&quot;.
     * @param value an integer value for the level.
     * @param resourceBundleName name of a resource bundle to use in
     *    localizing the given name. If the resourceBundleName is null
     *    or an empty string, it is ignored.
     * @throws NullPointerException if the name is null
     */
    protected Level(String name, int value, String resourceBundleName) {
<span class="fc" id="L207">        this(name, value, resourceBundleName, true);</span>
<span class="fc" id="L208">    }</span>

    // private constructor to specify whether this instance should be added
    // to the KnownLevel list from which Level.parse method does its look up
<span class="fc" id="L212">    private Level(String name, int value, String resourceBundleName, boolean visible) {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L214">            throw new NullPointerException();</span>
        }
<span class="fc" id="L216">        this.name = name;</span>
<span class="fc" id="L217">        this.value = value;</span>
<span class="fc" id="L218">        this.resourceBundleName = resourceBundleName;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        this.localizedLevelName = resourceBundleName == null ? name : null;</span>
<span class="fc" id="L220">        this.cachedLocale = null;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (visible) {</span>
<span class="fc" id="L222">            KnownLevel.add(this);</span>
        }
<span class="fc" id="L224">    }</span>

    /**
     * Return the level's localization resource bundle name, or
     * null if no localization bundle is defined.
     *
     * @return localization resource bundle name
     */
    public String getResourceBundleName() {
<span class="nc" id="L233">        return resourceBundleName;</span>
    }

    /**
     * Return the non-localized string name of the Level.
     *
     * @return non-localized name
     */
    public String getName() {
<span class="fc" id="L242">        return name;</span>
    }

    /**
     * Return the localized string name of the Level, for
     * the current default locale.
     * &lt;p&gt;
     * If no localization information is available, the
     * non-localized name is returned.
     *
     * @return localized name
     */
    public String getLocalizedName() {
<span class="fc" id="L255">        return getLocalizedLevelName();</span>
    }

    // package-private getLevelName() is used by the implementation
    // instead of getName() to avoid calling the subclass's version
    final String getLevelName() {
<span class="fc" id="L261">        return this.name;</span>
    }

    private String computeLocalizedLevelName(Locale newLocale) {
<span class="fc" id="L265">        ResourceBundle rb = ResourceBundle.getBundle(resourceBundleName, newLocale);</span>
<span class="fc" id="L266">        final String localizedName = rb.getString(name);</span>

<span class="fc" id="L268">        final boolean isDefaultBundle = defaultBundle.equals(resourceBundleName);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (!isDefaultBundle) return localizedName;</span>

        // This is a trick to determine whether the name has been translated
        // or not. If it has not been translated, we need to use Locale.ROOT
        // when calling toUpperCase().
<span class="fc" id="L274">        final Locale rbLocale = rb.getLocale();</span>
<span class="fc" id="L275">        final Locale locale =</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                Locale.ROOT.equals(rbLocale)</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">                || name.equals(localizedName.toUpperCase(Locale.ROOT))</span>
                ? Locale.ROOT : rbLocale;

        // ALL CAPS in a resource bundle's message indicates no translation
        // needed per Oracle translation guideline.  To workaround this
        // in Oracle JDK implementation, convert the localized level name
        // to uppercase for compatibility reason.
<span class="fc bfc" id="L284" title="All 2 branches covered.">        return Locale.ROOT.equals(locale) ? name : localizedName.toUpperCase(locale);</span>
    }

    // Avoid looking up the localizedLevelName twice if we already
    // have it.
    final String getCachedLocalizedLevelName() {

<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (localizedLevelName != null) {</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (cachedLocale != null) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">                if (cachedLocale.equals(Locale.getDefault())) {</span>
                    // OK: our cached value was looked up with the same
                    //     locale. We can use it.
<span class="fc" id="L296">                    return localizedLevelName;</span>
                }
            }
        }

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (resourceBundleName == null) {</span>
            // No resource bundle: just use the name.
<span class="nc" id="L303">            return name;</span>
        }

        // We need to compute the localized name.
        // Either because it's the first time, or because our cached
        // value is for a different locale. Just return null.
<span class="fc" id="L309">        return null;</span>
    }

    final synchronized String getLocalizedLevelName() {

        // See if we have a cached localized name
<span class="fc" id="L315">        final String cachedLocalizedName = getCachedLocalizedLevelName();</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (cachedLocalizedName != null) {</span>
<span class="fc" id="L317">            return cachedLocalizedName;</span>
        }

        // No cached localized name or cache invalid.
        // Need to compute the localized name.
<span class="fc" id="L322">        final Locale newLocale = Locale.getDefault();</span>
        try {
<span class="fc" id="L324">            localizedLevelName = computeLocalizedLevelName(newLocale);</span>
<span class="fc" id="L325">        } catch (Exception ex) {</span>
<span class="fc" id="L326">            localizedLevelName = name;</span>
<span class="fc" id="L327">        }</span>
<span class="fc" id="L328">        cachedLocale = newLocale;</span>
<span class="fc" id="L329">        return localizedLevelName;</span>
    }

    // Returns a mirrored Level object that matches the given name as
    // specified in the Level.parse method.  Returns null if not found.
    //
    // It returns the same Level object as the one returned by Level.parse
    // method if the given name is a non-localized name or integer.
    //
    // If the name is a localized name, findLevel and parse method may
    // return a different level value if there is a custom Level subclass
    // that overrides Level.getLocalizedName() to return a different string
    // than what's returned by the default implementation.
    //
    static Level findLevel(String name) {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L345">            throw new NullPointerException();</span>
        }

        KnownLevel level;

        // Look for a known Level with the given non-localized name.
<span class="fc" id="L351">        level = KnownLevel.findByName(name);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (level != null) {</span>
<span class="fc" id="L353">            return level.mirroredLevel;</span>
        }

        // Now, check if the given name is an integer.  If so,
        // first look for a Level with the given value and then
        // if necessary create one.
        try {
<span class="nc" id="L360">            int x = Integer.parseInt(name);</span>
<span class="nc" id="L361">            level = KnownLevel.findByValue(x);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (level == null) {</span>
                // add new Level
<span class="nc" id="L364">                Level levelObject = new Level(name, x);</span>
<span class="nc" id="L365">                level = KnownLevel.findByValue(x);</span>
            }
<span class="nc" id="L367">            return level.mirroredLevel;</span>
<span class="nc" id="L368">        } catch (NumberFormatException ex) {</span>
            // Not an integer.
            // Drop through.
        }

<span class="nc" id="L373">        level = KnownLevel.findByLocalizedLevelName(name);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (level != null) {</span>
<span class="nc" id="L375">            return level.mirroredLevel;</span>
        }

<span class="nc" id="L378">        return null;</span>
    }

    /**
     * Returns a string representation of this Level.
     *
     * @return the non-localized name of the Level, for example &quot;INFO&quot;.
     */
    @Override
    public final String toString() {
<span class="fc" id="L388">        return name;</span>
    }

    /**
     * Get the integer value for this level.  This integer value
     * can be used for efficient ordering comparisons between
     * Level objects.
     * @return the integer value for this level.
     */
    public final int intValue() {
<span class="fc" id="L398">        return value;</span>
    }

    private static final long serialVersionUID = -8176160795706313070L;

    // Serialization magic to prevent &quot;doppelgangers&quot;.
    // This is a performance optimization.
    private Object readResolve() {
<span class="nc" id="L406">        KnownLevel o = KnownLevel.matches(this);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (o != null) {</span>
<span class="nc" id="L408">            return o.levelObject;</span>
        }

        // Woops.  Whoever sent us this object knows
        // about a new log level.  Add it to our list.
<span class="nc" id="L413">        Level level = new Level(this.name, this.value, this.resourceBundleName);</span>
<span class="nc" id="L414">        return level;</span>
    }

    /**
     * Parse a level name string into a Level.
     * &lt;p&gt;
     * The argument string may consist of either a level name
     * or an integer value.
     * &lt;p&gt;
     * For example:
     * &lt;ul&gt;
     * &lt;li&gt;     &quot;SEVERE&quot;
     * &lt;li&gt;     &quot;1000&quot;
     * &lt;/ul&gt;
     *
     * @param  name   string to be parsed
     * @throws NullPointerException if the name is null
     * @throws IllegalArgumentException if the value is not valid.
     * Valid values are integers between &lt;CODE&gt;Integer.MIN_VALUE&lt;/CODE&gt;
     * and &lt;CODE&gt;Integer.MAX_VALUE&lt;/CODE&gt;, and all known level names.
     * Known names are the levels defined by this class (e.g., &lt;CODE&gt;FINE&lt;/CODE&gt;,
     * &lt;CODE&gt;FINER&lt;/CODE&gt;, &lt;CODE&gt;FINEST&lt;/CODE&gt;), or created by this class with
     * appropriate package access, or new levels defined or created
     * by subclasses.
     *
     * @return The parsed value. Passing an integer that corresponds to a known name
     * (e.g., 700) will return the associated name (e.g., &lt;CODE&gt;CONFIG&lt;/CODE&gt;).
     * Passing an integer that does not (e.g., 1) will return a new level name
     * initialized to that value.
     */
    public static synchronized Level parse(String name) throws IllegalArgumentException {
        // Check that name is not null.
<span class="fc" id="L446">        name.length();</span>

        KnownLevel level;

        // Look for a known Level with the given non-localized name.
<span class="fc" id="L451">        level = KnownLevel.findByName(name);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (level != null) {</span>
<span class="fc" id="L453">            return level.levelObject;</span>
        }

        // Now, check if the given name is an integer.  If so,
        // first look for a Level with the given value and then
        // if necessary create one.
        try {
<span class="fc" id="L460">            int x = Integer.parseInt(name);</span>
<span class="fc" id="L461">            level = KnownLevel.findByValue(x);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (level == null) {</span>
                // add new Level
<span class="fc" id="L464">                Level levelObject = new Level(name, x);</span>
<span class="fc" id="L465">                level = KnownLevel.findByValue(x);</span>
            }
<span class="fc" id="L467">            return level.levelObject;</span>
<span class="fc" id="L468">        } catch (NumberFormatException ex) {</span>
            // Not an integer.
            // Drop through.
        }

        // Finally, look for a known level with the given localized name,
        // in the current default locale.
        // This is relatively expensive, but not excessively so.
<span class="fc" id="L476">        level = KnownLevel.findByLocalizedLevelName(name);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (level != null) {</span>
<span class="fc" id="L478">            return level.levelObject;</span>
        }

        // OK, we've tried everything and failed
<span class="nc" id="L482">        throw new IllegalArgumentException(&quot;Bad level \&quot;&quot; + name + &quot;\&quot;&quot;);</span>
    }

    /**
     * Compare two objects for value equality.
     * @return true if and only if the two objects have the same level value.
     */
    @Override
    public boolean equals(Object ox) {
        try {
<span class="fc" id="L492">            Level lx = (Level)ox;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">            return (lx.value == this.value);</span>
<span class="nc" id="L494">        } catch (Exception ex) {</span>
<span class="nc" id="L495">            return false;</span>
        }
    }

    /**
     * Generate a hashcode.
     * @return a hashcode based on the level value
     */
    @Override
    public int hashCode() {
<span class="nc" id="L505">        return this.value;</span>
    }

    // KnownLevel class maintains the global list of all known levels.
    // The API allows multiple custom Level instances of the same name/value
    // be created. This class provides convenient methods to find a level
    // by a given name, by a given value, or by a given localized name.
    //
    // KnownLevel wraps the following Level objects:
    // 1. levelObject:   standard Level object or custom Level object
    // 2. mirroredLevel: Level object representing the level specified in the
    //                   logging configuration.
    //
    // Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
    // are non-final but the name and resource bundle name are parameters to
    // the Level constructor.  Use the mirroredLevel object instead of the
    // levelObject to prevent the logging framework to execute foreign code
    // implemented by untrusted Level subclass.
    //
    // Implementation Notes:
    // If Level.getName, Level.getLocalizedName, Level.getResourceBundleName methods
    // were final, the following KnownLevel implementation can be removed.
    // Future API change should take this into consideration.
    static final class KnownLevel {
<span class="fc" id="L529">        private static Map&lt;String, List&lt;KnownLevel&gt;&gt; nameToLevels = new HashMap&lt;&gt;();</span>
<span class="fc" id="L530">        private static Map&lt;Integer, List&lt;KnownLevel&gt;&gt; intToLevels = new HashMap&lt;&gt;();</span>
        final Level levelObject;     // instance of Level class or Level subclass
        final Level mirroredLevel;   // mirror of the custom Level
<span class="fc" id="L533">        KnownLevel(Level l) {</span>
<span class="fc" id="L534">            this.levelObject = l;</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            if (l.getClass() == Level.class) {</span>
<span class="fc" id="L536">                this.mirroredLevel = l;</span>
            } else {
                // this mirrored level object is hidden
<span class="fc" id="L539">                this.mirroredLevel = new Level(l.name, l.value, l.resourceBundleName, false);</span>
            }
<span class="fc" id="L541">        }</span>

        static synchronized void add(Level l) {
            // the mirroredLevel object is always added to the list
            // before the custom Level instance
<span class="fc" id="L546">            KnownLevel o = new KnownLevel(l);</span>
<span class="fc" id="L547">            List&lt;KnownLevel&gt; list = nameToLevels.get(l.name);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L549">                list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L550">                nameToLevels.put(l.name, list);</span>
            }
<span class="fc" id="L552">            list.add(o);</span>

<span class="fc" id="L554">            list = intToLevels.get(l.value);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (list == null) {</span>
<span class="fc" id="L556">                list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L557">                intToLevels.put(l.value, list);</span>
            }
<span class="fc" id="L559">            list.add(o);</span>
<span class="fc" id="L560">        }</span>

        // Returns a KnownLevel with the given non-localized name.
        static synchronized KnownLevel findByName(String name) {
<span class="fc" id="L564">            List&lt;KnownLevel&gt; list = nameToLevels.get(name);</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">            if (list != null) {</span>
<span class="fc" id="L566">                return list.get(0);</span>
            }
<span class="fc" id="L568">            return null;</span>
        }

        // Returns a KnownLevel with the given value.
        static synchronized KnownLevel findByValue(int value) {
<span class="fc" id="L573">            List&lt;KnownLevel&gt; list = intToLevels.get(value);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (list != null) {</span>
<span class="fc" id="L575">                return list.get(0);</span>
            }
<span class="fc" id="L577">            return null;</span>
        }

        // Returns a KnownLevel with the given localized name matching
        // by calling the Level.getLocalizedLevelName() method (i.e. found
        // from the resourceBundle associated with the Level object).
        // This method does not call Level.getLocalizedName() that may
        // be overridden in a subclass implementation
        static synchronized KnownLevel findByLocalizedLevelName(String name) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            for (List&lt;KnownLevel&gt; levels : nameToLevels.values()) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                for (KnownLevel l : levels) {</span>
<span class="fc" id="L588">                    String lname = l.levelObject.getLocalizedLevelName();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">                    if (name.equals(lname)) {</span>
<span class="fc" id="L590">                        return l;</span>
                    }
<span class="fc" id="L592">                }</span>
<span class="fc" id="L593">            }</span>
<span class="nc" id="L594">            return null;</span>
        }

        static synchronized KnownLevel matches(Level l) {
<span class="nc" id="L598">            List&lt;KnownLevel&gt; list = nameToLevels.get(l.name);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (list != null) {</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                for (KnownLevel level : list) {</span>
<span class="nc" id="L601">                    Level other = level.mirroredLevel;</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                    if (l.value == other.value &amp;&amp;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                           (l.resourceBundleName == other.resourceBundleName ||</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                               (l.resourceBundleName != null &amp;&amp;</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                                l.resourceBundleName.equals(other.resourceBundleName)))) {</span>
<span class="nc" id="L606">                        return level;</span>
                    }
<span class="nc" id="L608">                }</span>
            }
<span class="nc" id="L610">            return null;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>