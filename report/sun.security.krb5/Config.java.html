<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Config.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.krb5</a> &gt; <span class="el_source">Config.java</span></div><h1>Config.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */
package sun.security.krb5;

import java.io.File;
import java.io.FileInputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.ArrayList;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import sun.net.dns.ResolverConfiguration;
import sun.security.krb5.internal.crypto.EType;
import sun.security.krb5.internal.Krb5;

/**
 * This class maintains key-value pairs of Kerberos configurable constants
 * from configuration file or from user specified system properties.
 */

public class Config {

    /*
     * Only allow a single instance of Config.
     */
<span class="fc" id="L63">    private static Config singleton = null;</span>

    /*
     * Hashtable used to store configuration information.
     */
<span class="fc" id="L68">    private Hashtable&lt;String,Object&gt; stanzaTable = new Hashtable&lt;&gt;();</span>

<span class="fc" id="L70">    private static boolean DEBUG = sun.security.krb5.internal.Krb5.DEBUG;</span>

    // these are used for hexdecimal calculation.
    private static final int BASE16_0 = 1;
    private static final int BASE16_1 = 16;
    private static final int BASE16_2 = 16 * 16;
    private static final int BASE16_3 = 16 * 16 * 16;

    /**
     * Specified by system properties. Must be both null or non-null.
     */
    private final String defaultRealm;
    private final String defaultKDC;

    // used for native interface
    private static native String getWindowsDirectory(boolean isSystem);


    /**
     * Gets an instance of Config class. One and only one instance (the
     * singleton) is returned.
     *
     * @exception KrbException if error occurs when constructing a Config
     * instance. Possible causes would be either of java.security.krb5.realm or
     * java.security.krb5.kdc not specified, error reading configuration file.
     */
    public static synchronized Config getInstance() throws KrbException {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (singleton == null) {</span>
<span class="fc" id="L98">            singleton = new Config();</span>
        }
<span class="fc" id="L100">        return singleton;</span>
    }

    /**
     * Refresh and reload the Configuration. This could involve,
     * for example reading the Configuration file again or getting
     * the java.security.krb5.* system properties again. This method
     * also tries its best to update static fields in other classes
     * that depend on the configuration.
     *
     * @exception KrbException if error occurs when constructing a Config
     * instance. Possible causes would be either of java.security.krb5.realm or
     * java.security.krb5.kdc not specified, error reading configuration file.
     */

    public static synchronized void refresh() throws KrbException {
<span class="fc" id="L116">        singleton = new Config();</span>
<span class="fc" id="L117">        KdcComm.initStatic();</span>
<span class="fc" id="L118">        EType.initStatic();</span>
<span class="fc" id="L119">        Checksum.initStatic();</span>
<span class="fc" id="L120">    }</span>


    private static boolean isMacosLionOrBetter() {
        // split the &quot;10.x.y&quot; version number
<span class="fc" id="L125">        String osname = getProperty(&quot;os.name&quot;);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (!osname.contains(&quot;OS X&quot;)) {</span>
<span class="fc" id="L127">            return false;</span>
        }

<span class="nc" id="L130">        String osVersion = getProperty(&quot;os.version&quot;);</span>
<span class="nc" id="L131">        String[] fragments = osVersion.split(&quot;\\.&quot;);</span>

        // sanity check the &quot;10.&quot; part of the version
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (!fragments[0].equals(&quot;10&quot;)) return false;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (fragments.length &lt; 2) return false;</span>

        // check if Mac OS X 10.7(.y)
        try {
<span class="nc" id="L139">            int minorVers = Integer.parseInt(fragments[1]);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (minorVers &gt;= 7) return true;</span>
<span class="nc" id="L141">        } catch (NumberFormatException e) {</span>
            // was not an integer
<span class="nc" id="L143">        }</span>

<span class="nc" id="L145">        return false;</span>
    }

    /**
     * Private constructor - can not be instantiated externally.
     */
<span class="fc" id="L151">    private Config() throws KrbException {</span>
        /*
         * If either one system property is specified, we throw exception.
         */
<span class="fc" id="L155">        String tmp = getProperty(&quot;java.security.krb5.kdc&quot;);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (tmp != null) {</span>
            // The user can specify a list of kdc hosts separated by &quot;:&quot;
<span class="fc" id="L158">            defaultKDC = tmp.replace(':', ' ');</span>
        } else {
<span class="fc" id="L160">            defaultKDC = null;</span>
        }
<span class="fc" id="L162">        defaultRealm = getProperty(&quot;java.security.krb5.realm&quot;);</span>
<span class="pc bpc" id="L163" title="2 of 8 branches missed.">        if ((defaultKDC == null &amp;&amp; defaultRealm != null) ||</span>
            (defaultRealm == null &amp;&amp; defaultKDC != null)) {
<span class="nc" id="L165">            throw new KrbException</span>
                (&quot;System property java.security.krb5.kdc and &quot; +
                 &quot;java.security.krb5.realm both must be set or &quot; +
                 &quot;neither must be set.&quot;);
        }

        // Always read the Kerberos configuration file
        try {
            List&lt;String&gt; configFile;
<span class="fc" id="L174">            String fileName = getJavaFileName();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (fileName != null) {</span>
<span class="fc" id="L176">                configFile = loadConfigFile(fileName);</span>
<span class="fc" id="L177">                stanzaTable = parseStanzaTable(configFile);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (DEBUG) {</span>
<span class="fc" id="L179">                    System.out.println(&quot;Loaded from Java config&quot;);</span>
                }
            } else {
<span class="fc" id="L182">                boolean found = false;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                if (isMacosLionOrBetter()) {</span>
                    try {
<span class="nc" id="L185">                        stanzaTable = SCDynamicStoreConfig.getConfig();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                        if (DEBUG) {</span>
<span class="nc" id="L187">                            System.out.println(&quot;Loaded from SCDynamicStoreConfig&quot;);</span>
                        }
<span class="nc" id="L189">                        found = true;</span>
<span class="nc" id="L190">                    } catch (IOException ioe) {</span>
                        // OK. Will go on with file
<span class="nc" id="L192">                    }</span>
                }
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if (!found) {</span>
<span class="nc" id="L195">                    fileName = getNativeFileName();</span>
<span class="nc" id="L196">                    configFile = loadConfigFile(fileName);</span>
<span class="nc" id="L197">                    stanzaTable = parseStanzaTable(configFile);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if (DEBUG) {</span>
<span class="nc" id="L199">                        System.out.println(&quot;Loaded from native config&quot;);</span>
                    }
                }
            }
<span class="fc" id="L203">        } catch (IOException ioe) {</span>
            // I/O error, mostly like krb5.conf missing.
            // No problem. We'll use DNS or system property etc.
<span class="fc" id="L206">        }</span>
<span class="fc" id="L207">    }</span>

    /**
     * Gets the last-defined string value for the specified keys.
     * @param keys the keys, as an array from section name, sub-section names
     * (if any), to value name.
     * @return the value. When there are multiple values for the same key,
     * returns the last one. {@code null} is returned if not all the keys are
     * defined. For example, {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;)} will
     * return null if &quot;forwardable&quot; is not defined in [libdefaults], and
     * {@code get(&quot;realms&quot;, &quot;R&quot;, &quot;kdc&quot;)} will return null if &quot;R&quot; is not
     * defined in [realms] or &quot;kdc&quot; is not defined for &quot;R&quot;.
     * @throws IllegalArgumentException if any of the keys is illegal, either
     * because a key not the last one is not a (sub)section name or the last
     * key is still a section name. For example, {@code get(&quot;libdefaults&quot;)}
     * throws this exception because [libdefaults] is a section name instead of
     * a value name, and {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;, &quot;tail&quot;)}
     * also throws this exception because &quot;forwardable&quot; is already a value name
     * and has no sub-key at all (given &quot;forwardable&quot; is defined, otherwise,
     * this method has no knowledge if it's a value name or a section name),
     */
    public String get(String... keys) {
<span class="fc" id="L229">        Vector&lt;String&gt; v = getString0(keys);</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (v == null) return null;</span>
<span class="fc" id="L231">        return v.lastElement();</span>
    }

    /**
     * Gets all values for the specified keys.
     * @throws IllegalArgumentException if any of the keys is illegal
     *         (See {@link #get})
     */
    public String getAll(String... keys) {
<span class="fc" id="L240">        Vector&lt;String&gt; v = getString0(keys);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (v == null) return null;</span>
<span class="fc" id="L242">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L243">        boolean first = true;</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (String s: v) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (first) {</span>
<span class="fc" id="L246">                sb.append(s);</span>
<span class="fc" id="L247">                first = false;</span>
            } else {
<span class="fc" id="L249">                sb.append(' ').append(s);</span>
            }
<span class="fc" id="L251">        }</span>
<span class="fc" id="L252">        return sb.toString();</span>
    }

    /**
     * Returns true if keys exists, can be either final string(s) or sub-stanza
     * @throws IllegalArgumentException if any of the keys is illegal
     *         (See {@link #get})
     */
    public boolean exists(String... keys) {
<span class="fc bfc" id="L261" title="All 2 branches covered.">        return get0(keys) != null;</span>
    }

    // Returns final string value(s) for given keys.
    @SuppressWarnings(&quot;unchecked&quot;)
    private Vector&lt;String&gt; getString0(String... keys) {
        try {
<span class="fc" id="L268">            return (Vector&lt;String&gt;)get0(keys);</span>
<span class="nc" id="L269">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L270">            throw new IllegalArgumentException(cce);</span>
        }
    }

    // Internal method. Returns the value for keys, which can be a sub-stanza
    // or final string value(s).
    // The only method (except for toString) that reads stanzaTable directly.
    @SuppressWarnings(&quot;unchecked&quot;)
    private Object get0(String... keys) {
<span class="fc" id="L279">        Object current = stanzaTable;</span>
        try {
<span class="fc bfc" id="L281" title="All 2 branches covered.">            for (String key: keys) {</span>
<span class="fc" id="L282">                current = ((Hashtable&lt;String,Object&gt;)current).get(key);</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (current == null) return null;</span>
            }
<span class="fc" id="L285">            return current;</span>
<span class="nc" id="L286">        } catch (ClassCastException cce) {</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(cce);</span>
        }
    }

    /**
     * Gets the int value for the specified keys.
     * @param keys the keys
     * @return the int value, Integer.MIN_VALUE is returned if it cannot be
     * found or the value is not a legal integer.
     * @throw IllegalArgumentException if any of the keys is illegal
     * @see #get(java.lang.String[])
     */
    public int getIntValue(String... keys) {
<span class="fc" id="L300">        String result = get(keys);</span>
<span class="fc" id="L301">        int value = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (result != null) {</span>
            try {
<span class="fc" id="L304">                value = parseIntValue(result);</span>
<span class="nc" id="L305">            } catch (NumberFormatException e) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L307">                    System.out.println(&quot;Exception in getting value of &quot; +</span>
<span class="nc" id="L308">                                       Arrays.toString(keys) + &quot; &quot; +</span>
<span class="nc" id="L309">                                       e.getMessage());</span>
<span class="nc" id="L310">                    System.out.println(&quot;Setting &quot; + Arrays.toString(keys) +</span>
                                       &quot; to minimum value&quot;);
                }
<span class="nc" id="L313">                value = Integer.MIN_VALUE;</span>
<span class="fc" id="L314">            }</span>
        }
<span class="fc" id="L316">        return value;</span>
    }

    /**
     * Gets the boolean value for the specified keys.
     * @param keys the keys
     * @return the boolean value, false is returned if it cannot be
     * found or the value is not &quot;true&quot; (case insensitive).
     * @throw IllegalArgumentException if any of the keys is illegal
     * @see #get(java.lang.String[])
     */
    public boolean getBooleanValue(String... keys) {
<span class="fc" id="L328">        String val = get(keys);</span>
<span class="pc bpc" id="L329" title="1 of 4 branches missed.">        if (val != null &amp;&amp; val.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="fc" id="L330">            return true;</span>
        } else {
<span class="fc" id="L332">            return false;</span>
        }
    }

    /**
     * Parses a string to an integer. The convertible strings include the
     * string representations of positive integers, negative integers, and
     * hex decimal integers.  Valid inputs are, e.g., -1234, +1234,
     * 0x40000.
     *
     * @param input the String to be converted to an Integer.
     * @return an numeric value represented by the string
     * @exception NumberFormationException if the String does not contain a
     * parsable integer.
     */
    private int parseIntValue(String input) throws NumberFormatException {
<span class="fc" id="L348">        int value = 0;</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (input.startsWith(&quot;+&quot;)) {</span>
<span class="nc" id="L350">            String temp = input.substring(1);</span>
<span class="nc" id="L351">            return Integer.parseInt(temp);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        } else if (input.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L353">            String temp = input.substring(2);</span>
<span class="fc" id="L354">            char[] chars = temp.toCharArray();</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (chars.length &gt; 8) {</span>
<span class="nc" id="L356">                throw new NumberFormatException();</span>
            } else {
<span class="fc bfc" id="L358" title="All 2 branches covered.">                for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="fc" id="L359">                    int index = chars.length - i - 1;</span>
<span class="pc bpc" id="L360" title="14 of 17 branches missed.">                    switch (chars[i]) {</span>
                    case '0':
<span class="fc" id="L362">                        value += 0;</span>
<span class="fc" id="L363">                        break;</span>
                    case '1':
<span class="fc" id="L365">                        value += 1 * getBase(index);</span>
<span class="fc" id="L366">                        break;</span>
                    case '2':
<span class="nc" id="L368">                        value += 2 * getBase(index);</span>
<span class="nc" id="L369">                        break;</span>
                    case '3':
<span class="nc" id="L371">                        value += 3 * getBase(index);</span>
<span class="nc" id="L372">                        break;</span>
                    case '4':
<span class="nc" id="L374">                        value += 4 * getBase(index);</span>
<span class="nc" id="L375">                        break;</span>
                    case '5':
<span class="fc" id="L377">                        value += 5 * getBase(index);</span>
<span class="fc" id="L378">                        break;</span>
                    case '6':
<span class="nc" id="L380">                        value += 6 * getBase(index);</span>
<span class="nc" id="L381">                        break;</span>
                    case '7':
<span class="nc" id="L383">                        value += 7 * getBase(index);</span>
<span class="nc" id="L384">                        break;</span>
                    case '8':
<span class="nc" id="L386">                        value += 8 * getBase(index);</span>
<span class="nc" id="L387">                        break;</span>
                    case '9':
<span class="nc" id="L389">                        value += 9 * getBase(index);</span>
<span class="nc" id="L390">                        break;</span>
                    case 'a':
                    case 'A':
<span class="nc" id="L393">                        value += 10 * getBase(index);</span>
<span class="nc" id="L394">                        break;</span>
                    case 'b':
                    case 'B':
<span class="nc" id="L397">                        value += 11 * getBase(index);</span>
<span class="nc" id="L398">                        break;</span>
                    case 'c':
                    case 'C':
<span class="nc" id="L401">                        value += 12 * getBase(index);</span>
<span class="nc" id="L402">                        break;</span>
                    case 'd':
                    case 'D':
<span class="nc" id="L405">                        value += 13 * getBase(index);</span>
<span class="nc" id="L406">                        break;</span>
                    case 'e':
                    case 'E':
<span class="nc" id="L409">                        value += 14 * getBase(index);</span>
<span class="nc" id="L410">                        break;</span>
                    case 'f':
                    case 'F':
<span class="nc" id="L413">                        value += 15 * getBase(index);</span>
<span class="nc" id="L414">                        break;</span>
                    default:
<span class="nc" id="L416">                        throw new NumberFormatException(&quot;Invalid numerical format&quot;);</span>
                    }
                }
            }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (value &lt; 0) {</span>
<span class="nc" id="L421">                throw new NumberFormatException(&quot;Data overflow.&quot;);</span>
            }
<span class="fc" id="L423">        } else {</span>
<span class="fc" id="L424">            value = Integer.parseInt(input);</span>
        }
<span class="fc" id="L426">        return value;</span>
    }

    private int getBase(int i) {
<span class="fc" id="L430">        int result = 16;</span>
<span class="pc bpc" id="L431" title="3 of 5 branches missed.">        switch (i) {</span>
        case 0:
<span class="nc" id="L433">            result = BASE16_0;</span>
<span class="nc" id="L434">            break;</span>
        case 1:
<span class="fc" id="L436">            result = BASE16_1;</span>
<span class="fc" id="L437">            break;</span>
        case 2:
<span class="nc" id="L439">            result = BASE16_2;</span>
<span class="nc" id="L440">            break;</span>
        case 3:
<span class="nc" id="L442">            result = BASE16_3;</span>
<span class="nc" id="L443">            break;</span>
        default:
<span class="fc bfc" id="L445" title="All 2 branches covered.">            for (int j = 1; j &lt; i; j++) {</span>
<span class="fc" id="L446">                result *= 16;</span>
            }
        }
<span class="fc" id="L449">        return result;</span>
    }

    /**
     * Reads lines to the memory from the configuration file.
     *
     * Configuration file contains information about the default realm,
     * ticket parameters, location of the KDC and the admin server for
     * known realms, etc. The file is divided into sections. Each section
     * contains one or more name/value pairs with one pair per line. A
     * typical file would be:
     * &lt;pre&gt;
     * [libdefaults]
     *          default_realm = EXAMPLE.COM
     *          default_tgs_enctypes = des-cbc-md5
     *          default_tkt_enctypes = des-cbc-md5
     * [realms]
     *          EXAMPLE.COM = {
     *                  kdc = kerberos.example.com
     *                  kdc = kerberos-1.example.com
     *                  admin_server = kerberos.example.com
     *                  }
     *          SAMPLE_COM = {
     *                  kdc = orange.sample.com
     *                  admin_server = orange.sample.com
     *                  }
     * [domain_realm]
     *          blue.sample.com = TEST.SAMPLE.COM
     *          .backup.com     = EXAMPLE.COM
     * &lt;/pre&gt;
     * @return an ordered list of strings representing the config file after
     * some initial processing, including:&lt;ol&gt;
     * &lt;li&gt; Comment lines and empty lines are removed
     * &lt;li&gt; &quot;{&quot; not at the end of a line is appended to the previous line
     * &lt;li&gt; The content of a section is also placed between &quot;{&quot; and &quot;}&quot;.
     * &lt;li&gt; Lines are trimmed&lt;/ol&gt;
     * @throws IOException if there is an I/O error
     * @throws KrbException if there is a file format error
     */
    private List&lt;String&gt; loadConfigFile(final String fileName)
            throws IOException, KrbException {
        try {
<span class="fc" id="L491">            List&lt;String&gt; v = new ArrayList&lt;&gt;();</span>
<span class="pc" id="L492">            try (BufferedReader br = new BufferedReader(new InputStreamReader(</span>
<span class="fc" id="L493">                AccessController.doPrivileged(</span>
<span class="fc" id="L494">                    new PrivilegedExceptionAction&lt;FileInputStream&gt; () {</span>
                        public FileInputStream run() throws IOException {
<span class="fc" id="L496">                            return new FileInputStream(fileName);</span>
                        }
                    })))) {
                String line;
<span class="fc" id="L500">                String previous = null;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">                while ((line = br.readLine()) != null) {</span>
<span class="fc" id="L502">                    line = line.trim();</span>
<span class="fc bfc" id="L503" title="All 4 branches covered.">                    if (line.startsWith(&quot;#&quot;) || line.isEmpty()) {</span>
                        // ignore comments and blank line
                        // Comments start with #.
<span class="fc" id="L506">                        continue;</span>
                    }
                    // In practice, a subsection might look like:
                    //      [realms]
                    //      EXAMPLE.COM =
                    //      {
                    //          kdc = kerberos.example.com
                    //          ...
                    //      }
                    // Before parsed into stanza table, it needs to be
                    // converted into a canonicalized style (no indent):
                    //      realms = {
                    //          EXAMPLE.COM = {
                    //              kdc = kerberos.example.com
                    //              ...
                    //          }
                    //      }
                    //
<span class="fc bfc" id="L524" title="All 2 branches covered.">                    if (line.startsWith(&quot;[&quot;)) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                        if (!line.endsWith(&quot;]&quot;)) {</span>
<span class="nc" id="L526">                            throw new KrbException(&quot;Illegal config content:&quot;</span>
                                    + line);
                        }
<span class="fc bfc" id="L529" title="All 2 branches covered.">                        if (previous != null) {</span>
<span class="fc" id="L530">                            v.add(previous);</span>
<span class="fc" id="L531">                            v.add(&quot;}&quot;);</span>
                        }
<span class="fc" id="L533">                        String title = line.substring(</span>
<span class="fc" id="L534">                                1, line.length()-1).trim();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                        if (title.isEmpty()) {</span>
<span class="nc" id="L536">                            throw new KrbException(&quot;Illegal config content:&quot;</span>
                                    + line);
                        }
<span class="fc" id="L539">                        previous = title + &quot; = {&quot;;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                    } else if (line.startsWith(&quot;{&quot;)) {</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                        if (previous == null) {</span>
<span class="nc" id="L542">                            throw new KrbException(</span>
                                &quot;Config file should not start with \&quot;{\&quot;&quot;);
                        }
<span class="fc" id="L545">                        previous += &quot; {&quot;;</span>
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">                        if (line.length() &gt; 1) {</span>
                            // { and content on the same line
<span class="nc" id="L548">                            v.add(previous);</span>
<span class="nc" id="L549">                            previous = line.substring(1).trim();</span>
                        }
                    } else {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">                        if (previous == null) {</span>
<span class="nc" id="L553">                            throw new KrbException(</span>
                                &quot;Config file must starts with a section&quot;);
                        }
<span class="fc" id="L556">                        v.add(previous);</span>
<span class="fc" id="L557">                        previous = line;</span>
                    }
                }
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                if (previous != null) {</span>
<span class="fc" id="L561">                    v.add(previous);</span>
<span class="fc" id="L562">                    v.add(&quot;}&quot;);</span>
                }
<span class="pc bpc" id="L564" title="6 of 8 branches missed.">            }</span>
<span class="fc" id="L565">            return v;</span>
<span class="fc" id="L566">        } catch (java.security.PrivilegedActionException pe) {</span>
<span class="fc" id="L567">            throw (IOException)pe.getException();</span>
        }
    }

    /**
     * Parses stanza names and values from configuration file to
     * stanzaTable (Hashtable). Hashtable key would be stanza names,
     * (libdefaults, realms, domain_realms, etc), and the hashtable value
     * would be another hashtable which contains the key-value pairs under
     * a stanza name. The value of this sub-hashtable can be another hashtable
     * containing another sub-sub-section or a vector of strings for
     * final values (even if there is only one value defined).
     * &lt;p&gt;
     * For duplicates section names, the latter overwrites the former. For
     * duplicate value names, the values are in a vector in its appearing order.
     * &lt;/ol&gt;
     * Please note that this behavior is Java traditional. and it is
     * not the same as the MIT krb5 behavior, where:&lt;ol&gt;
     * &lt;li&gt;Duplicated root sections will be merged
     * &lt;li&gt;For duplicated sub-sections, the former overwrites the latter
     * &lt;li&gt;Duplicate keys for values are always saved in a vector
     * &lt;/ol&gt;
     * @param v the strings in the file, never null, might be empty
     * @throws KrbException if there is a file format error
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private Hashtable&lt;String,Object&gt; parseStanzaTable(List&lt;String&gt; v)
            throws KrbException {
<span class="fc" id="L595">        Hashtable&lt;String,Object&gt; current = stanzaTable;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">        for (String line: v) {</span>
            // There are 3 kinds of lines
            // 1. a = b
            // 2. a = {
            // 3. }
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (line.equals(&quot;}&quot;)) {</span>
                // Go back to parent, see below
<span class="fc" id="L603">                current = (Hashtable&lt;String,Object&gt;)current.remove(&quot; PARENT &quot;);</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">                if (current == null) {</span>
<span class="nc" id="L605">                    throw new KrbException(&quot;Unmatched close brace&quot;);</span>
                }
            } else {
<span class="fc" id="L608">                int pos = line.indexOf('=');</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">                if (pos &lt; 0) {</span>
<span class="nc" id="L610">                    throw new KrbException(&quot;Illegal config content:&quot; + line);</span>
                }
<span class="fc" id="L612">                String key = line.substring(0, pos).trim();</span>
<span class="fc" id="L613">                String value = trimmed(line.substring(pos+1));</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">                if (value.equals(&quot;{&quot;)) {</span>
                    Hashtable&lt;String,Object&gt; subTable;
<span class="fc bfc" id="L616" title="All 2 branches covered.">                    if (current == stanzaTable) {</span>
<span class="fc" id="L617">                        key = key.toLowerCase(Locale.US);</span>
                    }
<span class="fc" id="L619">                    subTable = new Hashtable&lt;&gt;();</span>
<span class="fc" id="L620">                    current.put(key, subTable);</span>
                    // A special entry for its parent. Put whitespaces around,
                    // so will never be confused with a normal key
<span class="fc" id="L623">                    subTable.put(&quot; PARENT &quot;, current);</span>
<span class="fc" id="L624">                    current = subTable;</span>
<span class="fc" id="L625">                } else {</span>
                    Vector&lt;String&gt; values;
<span class="fc bfc" id="L627" title="All 2 branches covered.">                    if (current.containsKey(key)) {</span>
<span class="fc" id="L628">                        Object obj = current.get(key);</span>
                        // If a key first shows as a section and then a value,
                        // this is illegal. However, we haven't really forbid
                        // first value then section, which the final result
                        // is a section.
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                        if (!(obj instanceof Vector)) {</span>
<span class="nc" id="L634">                            throw new KrbException(&quot;Key &quot; + key</span>
                                    + &quot;used for both value and section&quot;);
                        }
<span class="fc" id="L637">                        values = (Vector&lt;String&gt;)current.get(key);</span>
<span class="fc" id="L638">                    } else {</span>
<span class="fc" id="L639">                        values = new Vector&lt;String&gt;();</span>
<span class="fc" id="L640">                        current.put(key, values);</span>
                    }
<span class="fc" id="L642">                    values.add(value);</span>
                }
            }
<span class="fc" id="L645">        }</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (current != stanzaTable) {</span>
<span class="nc" id="L647">            throw new KrbException(&quot;Not closed&quot;);</span>
        }
<span class="fc" id="L649">        return current;</span>
    }

    /**
     * Gets the default Java configuration file name.
     *
     * If the system property &quot;java.security.krb5.conf&quot; is defined, we'll
     * use its value, no matter if the file exists or not. Otherwise, we
     * will look at $JAVA_HOME/lib/security directory with &quot;krb5.conf&quot; name,
     * and return it if the file exists.
     *
     * The method returns null if it cannot find a Java config file.
     */
    private String getJavaFileName() {
<span class="fc" id="L663">        String name = getProperty(&quot;java.security.krb5.conf&quot;);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc" id="L665">            name = getProperty(&quot;java.home&quot;) + File.separator +</span>
                                &quot;lib&quot; + File.separator + &quot;security&quot; +
                                File.separator + &quot;krb5.conf&quot;;
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">            if (!fileExists(name)) {</span>
<span class="fc" id="L669">                name = null;</span>
            }
        }
<span class="fc bfc" id="L672" title="All 2 branches covered.">        if (DEBUG) {</span>
<span class="fc" id="L673">            System.out.println(&quot;Java config name: &quot; + name);</span>
        }
<span class="fc" id="L675">        return name;</span>
    }

    /**
     * Gets the default native configuration file name.
     *
     * Depending on the OS type, the method returns the default native
     * kerberos config file name, which is at windows directory with
     * the name of &quot;krb5.ini&quot; for Windows, /etc/krb5/krb5.conf for Solaris,
     * /etc/krb5.conf otherwise. Mac OSX X has a different file name.
     *
     * Note: When the Terminal Service is started in Windows (from 2003),
     * there are two kinds of Windows directories: A system one (say,
     * C:\Windows), and a user-private one (say, C:\Users\Me\Windows).
     * We will first look for krb5.ini in the user-private one. If not
     * found, try the system one instead.
     *
     * This method will always return a non-null non-empty file name,
     * even if that file does not exist.
     */
    private String getNativeFileName() {
<span class="fc" id="L696">        String name = null;</span>
<span class="fc" id="L697">        String osname = getProperty(&quot;os.name&quot;);</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        if (osname.startsWith(&quot;Windows&quot;)) {</span>
            try {
<span class="nc" id="L700">                Credentials.ensureLoaded();</span>
<span class="nc" id="L701">            } catch (Exception e) {</span>
                // ignore exceptions
<span class="nc" id="L703">            }</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (Credentials.alreadyLoaded) {</span>
<span class="nc" id="L705">                String path = getWindowsDirectory(false);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                if (path != null) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                    if (path.endsWith(&quot;\\&quot;)) {</span>
<span class="nc" id="L708">                        path = path + &quot;krb5.ini&quot;;</span>
                    } else {
<span class="nc" id="L710">                        path = path + &quot;\\krb5.ini&quot;;</span>
                    }
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    if (fileExists(path)) {</span>
<span class="nc" id="L713">                        name = path;</span>
                    }
                }
<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (name == null) {</span>
<span class="nc" id="L717">                    path = getWindowsDirectory(true);</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                    if (path != null) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                        if (path.endsWith(&quot;\\&quot;)) {</span>
<span class="nc" id="L720">                            path = path + &quot;krb5.ini&quot;;</span>
                        } else {
<span class="nc" id="L722">                            path = path + &quot;\\krb5.ini&quot;;</span>
                        }
<span class="nc" id="L724">                        name = path;</span>
                    }
                }
            }
<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L729">                name = &quot;c:\\winnt\\krb5.ini&quot;;</span>
            }
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        } else if (osname.startsWith(&quot;SunOS&quot;)) {</span>
<span class="nc" id="L732">            name =  &quot;/etc/krb5/krb5.conf&quot;;</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        } else if (osname.contains(&quot;OS X&quot;)) {</span>
<span class="nc" id="L734">            name = findMacosConfigFile();</span>
        } else {
<span class="fc" id="L736">            name =  &quot;/etc/krb5.conf&quot;;</span>
        }
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L739">            System.out.println(&quot;Native config name: &quot; + name);</span>
        }
<span class="fc" id="L741">        return name;</span>
    }

    private static String getProperty(String property) {
<span class="fc" id="L745">        return java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(property));
    }

    private String findMacosConfigFile() {
<span class="nc" id="L750">        String userHome = getProperty(&quot;user.home&quot;);</span>
        final String PREF_FILE = &quot;/Library/Preferences/edu.mit.Kerberos&quot;;
<span class="nc" id="L752">        String userPrefs = userHome + PREF_FILE;</span>

<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (fileExists(userPrefs)) {</span>
<span class="nc" id="L755">            return userPrefs;</span>
        }

<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (fileExists(PREF_FILE)) {</span>
<span class="nc" id="L759">            return PREF_FILE;</span>
        }

<span class="nc" id="L762">        return &quot;/etc/krb5.conf&quot;;</span>
    }

    private static String trimmed(String s) {
<span class="fc" id="L766">        s = s.trim();</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if (s.isEmpty()) return s;</span>
<span class="pc bpc" id="L768" title="1 of 4 branches missed.">        if (s.charAt(0) == '&quot;' &amp;&amp; s.charAt(s.length()-1) == '&quot;' ||</span>
<span class="pc bpc" id="L769" title="3 of 4 branches missed.">                s.charAt(0) == '\'' &amp;&amp; s.charAt(s.length()-1) == '\'') {</span>
<span class="fc" id="L770">            s = s.substring(1, s.length()-1).trim();</span>
        }
<span class="fc" id="L772">        return s;</span>
    }

    /**
     * For testing purpose. This method lists all information being parsed from
     * the configuration file to the hashtable.
     */
    public void listTable() {
<span class="fc" id="L780">        System.out.println(this);</span>
<span class="fc" id="L781">    }</span>

    /**
     * Returns all etypes specified in krb5.conf for the given configName,
     * or all the builtin defaults. This result is always non-empty.
     * If no etypes are found, an exception is thrown.
     */
    public int[] defaultEtype(String configName) throws KrbException {
        String default_enctypes;
<span class="fc" id="L790">        default_enctypes = get(&quot;libdefaults&quot;, configName);</span>
        int[] etype;
<span class="fc bfc" id="L792" title="All 2 branches covered.">        if (default_enctypes == null) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">            if (DEBUG) {</span>
<span class="fc" id="L794">                System.out.println(&quot;Using builtin default etypes for &quot; +</span>
                    configName);
            }
<span class="fc" id="L797">            etype = EType.getBuiltInDefaults();</span>
        } else {
<span class="fc" id="L799">            String delim = &quot; &quot;;</span>
            StringTokenizer st;
<span class="fc bfc" id="L801" title="All 2 branches covered.">            for (int j = 0; j &lt; default_enctypes.length(); j++) {</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                if (default_enctypes.substring(j, j + 1).equals(&quot;,&quot;)) {</span>
                    // only two delimiters are allowed to use
                    // according to Kerberos DCE doc.
<span class="nc" id="L805">                    delim = &quot;,&quot;;</span>
<span class="nc" id="L806">                    break;</span>
                }
            }
<span class="fc" id="L809">            st = new StringTokenizer(default_enctypes, delim);</span>
<span class="fc" id="L810">            int len = st.countTokens();</span>
<span class="fc" id="L811">            ArrayList&lt;Integer&gt; ls = new ArrayList&lt;&gt;(len);</span>
            int type;
<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L814">                type = Config.getType(st.nextToken());</span>
<span class="pc bpc" id="L815" title="1 of 4 branches missed.">                if (type != -1 &amp;&amp; EType.isSupported(type)) {</span>
<span class="fc" id="L816">                    ls.add(type);</span>
                }
            }
<span class="fc bfc" id="L819" title="All 2 branches covered.">            if (ls.isEmpty()) {</span>
<span class="fc" id="L820">                throw new KrbException(&quot;no supported default etypes for &quot;</span>
                        + configName);
            } else {
<span class="fc" id="L823">                etype = new int[ls.size()];</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">                for (int i = 0; i &lt; etype.length; i++) {</span>
<span class="fc" id="L825">                    etype[i] = ls.get(i);</span>
                }
            }
        }

<span class="fc bfc" id="L830" title="All 2 branches covered.">        if (DEBUG) {</span>
<span class="fc" id="L831">            System.out.print(&quot;default etypes for &quot; + configName + &quot;:&quot;);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">            for (int i = 0; i &lt; etype.length; i++) {</span>
<span class="fc" id="L833">                System.out.print(&quot; &quot; + etype[i]);</span>
            }
<span class="fc" id="L835">            System.out.println(&quot;.&quot;);</span>
        }
<span class="fc" id="L837">        return etype;</span>
    }


    /**
     * Get the etype and checksum value for the specified encryption and
     * checksum type.
     *
     */
    /*
     * This method converts the string representation of encryption type and
     * checksum type to int value that can be later used by EType and
     * Checksum classes.
     */
    public static int getType(String input) {
<span class="fc" id="L852">        int result = -1;</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L854">            return result;</span>
        }
<span class="pc bpc" id="L856" title="1 of 4 branches missed.">        if (input.startsWith(&quot;d&quot;) || (input.startsWith(&quot;D&quot;))) {</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">            if (input.equalsIgnoreCase(&quot;des-cbc-crc&quot;)) {</span>
<span class="nc" id="L858">                result = EncryptedData.ETYPE_DES_CBC_CRC;</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;des-cbc-md5&quot;)) {</span>
<span class="fc" id="L860">                result = EncryptedData.ETYPE_DES_CBC_MD5;</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;des-mac&quot;)) {</span>
<span class="nc" id="L862">                result = Checksum.CKSUMTYPE_DES_MAC;</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;des-mac-k&quot;)) {</span>
<span class="nc" id="L864">                result = Checksum.CKSUMTYPE_DES_MAC_K;</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;des-cbc-md4&quot;)) {</span>
<span class="nc" id="L866">                result = EncryptedData.ETYPE_DES_CBC_MD4;</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;des3-cbc-sha1&quot;) ||</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;des3-hmac-sha1&quot;) ||</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;des3-cbc-sha1-kd&quot;) ||</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;des3-cbc-hmac-sha1-kd&quot;)) {</span>
<span class="nc" id="L871">                result = EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD;</span>
            }
<span class="pc bpc" id="L873" title="3 of 4 branches missed.">        } else if (input.startsWith(&quot;a&quot;) || (input.startsWith(&quot;A&quot;))) {</span>
            // AES
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">            if (input.equalsIgnoreCase(&quot;aes128-cts&quot;) ||</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;aes128-cts-hmac-sha1-96&quot;)) {</span>
<span class="fc" id="L877">                result = EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96;</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;aes256-cts&quot;) ||</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;aes256-cts-hmac-sha1-96&quot;)) {</span>
<span class="nc" id="L880">                result = EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96;</span>
            // ARCFOUR-HMAC
<span class="nc bnc" id="L882" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;arcfour-hmac&quot;) ||</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                   input.equalsIgnoreCase(&quot;arcfour-hmac-md5&quot;)) {</span>
<span class="nc" id="L884">                result = EncryptedData.ETYPE_ARCFOUR_HMAC;</span>
            }
        // RC4-HMAC
<span class="nc bnc" id="L887" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;rc4-hmac&quot;)) {</span>
<span class="nc" id="L888">            result = EncryptedData.ETYPE_ARCFOUR_HMAC;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;CRC32&quot;)) {</span>
<span class="nc" id="L890">            result = Checksum.CKSUMTYPE_CRC32;</span>
<span class="nc bnc" id="L891" title="All 4 branches missed.">        } else if (input.startsWith(&quot;r&quot;) || (input.startsWith(&quot;R&quot;))) {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if (input.equalsIgnoreCase(&quot;rsa-md5&quot;)) {</span>
<span class="nc" id="L893">                result = Checksum.CKSUMTYPE_RSA_MD5;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">            } else if (input.equalsIgnoreCase(&quot;rsa-md5-des&quot;)) {</span>
<span class="nc" id="L895">                result = Checksum.CKSUMTYPE_RSA_MD5_DES;</span>
            }
<span class="nc bnc" id="L897" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-des3-kd&quot;)) {</span>
<span class="nc" id="L898">            result = Checksum.CKSUMTYPE_HMAC_SHA1_DES3_KD;</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes128&quot;)) {</span>
<span class="nc" id="L900">            result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES128;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes256&quot;)) {</span>
<span class="nc" id="L902">            result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES256;</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;hmac-md5-rc4&quot;) ||</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;hmac-md5-arcfour&quot;) ||</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                input.equalsIgnoreCase(&quot;hmac-md5-enc&quot;)) {</span>
<span class="nc" id="L906">            result = Checksum.CKSUMTYPE_HMAC_MD5_ARCFOUR;</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">        } else if (input.equalsIgnoreCase(&quot;NULL&quot;)) {</span>
<span class="nc" id="L908">            result = EncryptedData.ETYPE_NULL;</span>
        }

<span class="fc" id="L911">        return result;</span>
    }

    /**
     * Resets the default kdc realm.
     * We do not need to synchronize these methods since assignments are atomic
     *
     * This method was useless. Kept here in case some class still calls it.
     */
    public void resetDefaultRealm(String realm) {
<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L922">            System.out.println(&quot;&gt;&gt;&gt; Config try resetting default kdc &quot; + realm);</span>
        }
<span class="nc" id="L924">    }</span>

    /**
     * Check to use addresses in tickets
     * use addresses if &quot;no_addresses&quot; or &quot;noaddresses&quot; is set to false
     */
    public boolean useAddresses() {
<span class="fc" id="L931">        boolean useAddr = false;</span>
        // use addresses if &quot;no_addresses&quot; is set to false
<span class="fc" id="L933">        String value = get(&quot;libdefaults&quot;, &quot;no_addresses&quot;);</span>
<span class="pc bpc" id="L934" title="3 of 4 branches missed.">        useAddr = (value != null &amp;&amp; value.equalsIgnoreCase(&quot;false&quot;));</span>
<span class="pc bpc" id="L935" title="1 of 2 branches missed.">        if (useAddr == false) {</span>
            // use addresses if &quot;noaddresses&quot; is set to false
<span class="fc" id="L937">            value = get(&quot;libdefaults&quot;, &quot;noaddresses&quot;);</span>
<span class="pc bpc" id="L938" title="1 of 4 branches missed.">            useAddr = (value != null &amp;&amp; value.equalsIgnoreCase(&quot;false&quot;));</span>
        }
<span class="fc" id="L940">        return useAddr;</span>
    }

    /**
     * Check if need to use DNS to locate Kerberos services
     */
    private boolean useDNS(String name) {
<span class="fc" id="L947">        String value = get(&quot;libdefaults&quot;, name);</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L949">            value = get(&quot;libdefaults&quot;, &quot;dns_fallback&quot;);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            if (&quot;false&quot;.equalsIgnoreCase(value)) {</span>
<span class="fc" id="L951">                return false;</span>
            } else {
<span class="fc" id="L953">                return true;</span>
            }
        } else {
<span class="fc" id="L956">            return value.equalsIgnoreCase(&quot;true&quot;);</span>
        }
    }

    /**
     * Check if need to use DNS to locate the KDC
     */
    private boolean useDNS_KDC() {
<span class="fc" id="L964">        return useDNS(&quot;dns_lookup_kdc&quot;);</span>
    }

    /*
     * Check if need to use DNS to locate the Realm
     */
    private boolean useDNS_Realm() {
<span class="fc" id="L971">        return useDNS(&quot;dns_lookup_realm&quot;);</span>
    }

    /**
     * Gets default realm.
     * @throws KrbException where no realm can be located
     * @return the default realm, always non null
     */
    public String getDefaultRealm() throws KrbException {
<span class="fc bfc" id="L980" title="All 2 branches covered.">        if (defaultRealm != null) {</span>
<span class="fc" id="L981">            return defaultRealm;</span>
        }
<span class="fc" id="L983">        Exception cause = null;</span>
<span class="fc" id="L984">        String realm = get(&quot;libdefaults&quot;, &quot;default_realm&quot;);</span>
<span class="fc bfc" id="L985" title="All 4 branches covered.">        if ((realm == null) &amp;&amp; useDNS_Realm()) {</span>
            // use DNS to locate Kerberos realm
            try {
<span class="nc" id="L988">                realm = getRealmFromDNS();</span>
<span class="fc" id="L989">            } catch (KrbException ke) {</span>
<span class="fc" id="L990">                cause = ke;</span>
<span class="nc" id="L991">            }</span>
        }
<span class="fc bfc" id="L993" title="All 2 branches covered.">        if (realm == null) {</span>
<span class="fc" id="L994">            realm = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L995">                    new java.security.PrivilegedAction&lt;String&gt;() {</span>
                @Override
                public String run() {
<span class="fc" id="L998">                    String osname = System.getProperty(&quot;os.name&quot;);</span>
<span class="pc bpc" id="L999" title="1 of 2 branches missed.">                    if (osname.startsWith(&quot;Windows&quot;)) {</span>
<span class="nc" id="L1000">                        return System.getenv(&quot;USERDNSDOMAIN&quot;);</span>
                    }
<span class="fc" id="L1002">                    return null;</span>
                }
            });
        }
<span class="fc bfc" id="L1006" title="All 2 branches covered.">        if (realm == null) {</span>
<span class="fc" id="L1007">            KrbException ke = new KrbException(&quot;Cannot locate default realm&quot;);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">            if (cause != null) {</span>
<span class="fc" id="L1009">                ke.initCause(cause);</span>
            }
<span class="fc" id="L1011">            throw ke;</span>
        }
<span class="fc" id="L1013">        return realm;</span>
    }

    /**
     * Returns a list of KDC's with each KDC separated by a space
     *
     * @param realm the realm for which the KDC list is desired
     * @throws KrbException if there's no way to find KDC for the realm
     * @return the list of KDCs separated by a space, always non null
     */
    public String getKDCList(String realm) throws KrbException {
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">        if (realm == null) {</span>
<span class="nc" id="L1025">            realm = getDefaultRealm();</span>
        }
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        if (realm.equalsIgnoreCase(defaultRealm)) {</span>
<span class="fc" id="L1028">            return defaultKDC;</span>
        }
<span class="fc" id="L1030">        Exception cause = null;</span>
<span class="fc" id="L1031">        String kdcs = getAll(&quot;realms&quot;, realm, &quot;kdc&quot;);</span>
<span class="pc bpc" id="L1032" title="1 of 4 branches missed.">        if ((kdcs == null) &amp;&amp; useDNS_KDC()) {</span>
            // use DNS to locate KDC
            try {
<span class="fc" id="L1035">                kdcs = getKDCFromDNS(realm);</span>
<span class="fc" id="L1036">            } catch (KrbException ke) {</span>
<span class="fc" id="L1037">                cause = ke;</span>
<span class="fc" id="L1038">            }</span>
        }
<span class="fc bfc" id="L1040" title="All 2 branches covered.">        if (kdcs == null) {</span>
<span class="fc" id="L1041">            kdcs = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L1042">                    new java.security.PrivilegedAction&lt;String&gt;() {</span>
                @Override
                public String run() {
<span class="fc" id="L1045">                    String osname = System.getProperty(&quot;os.name&quot;);</span>
<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">                    if (osname.startsWith(&quot;Windows&quot;)) {</span>
<span class="nc" id="L1047">                        String logonServer = System.getenv(&quot;LOGONSERVER&quot;);</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                        if (logonServer != null</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                                &amp;&amp; logonServer.startsWith(&quot;\\\\&quot;)) {</span>
<span class="nc" id="L1050">                            logonServer = logonServer.substring(2);</span>
                        }
<span class="nc" id="L1052">                        return logonServer;</span>
                    }
<span class="fc" id="L1054">                    return null;</span>
                }
            });
        }
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (kdcs == null) {</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">            if (defaultKDC != null) {</span>
<span class="fc" id="L1060">                return defaultKDC;</span>
            }
<span class="fc" id="L1062">            KrbException ke = new KrbException(&quot;Cannot locate KDC&quot;);</span>
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">            if (cause != null) {</span>
<span class="fc" id="L1064">                ke.initCause(cause);</span>
            }
<span class="fc" id="L1066">            throw ke;</span>
        }
<span class="fc" id="L1068">        return kdcs;</span>
    }

    /**
     * Locate Kerberos realm using DNS
     *
     * @return the Kerberos realm
     */
    private String getRealmFromDNS() throws KrbException {
        // use DNS to locate Kerberos realm
<span class="fc" id="L1078">        String realm = null;</span>
<span class="fc" id="L1079">        String hostName = null;</span>
        try {
<span class="fc" id="L1081">            hostName = InetAddress.getLocalHost().getCanonicalHostName();</span>
<span class="nc" id="L1082">        } catch (UnknownHostException e) {</span>
<span class="nc" id="L1083">            KrbException ke = new KrbException(Krb5.KRB_ERR_GENERIC,</span>
<span class="nc" id="L1084">                &quot;Unable to locate Kerberos realm: &quot; + e.getMessage());</span>
<span class="nc" id="L1085">            ke.initCause(e);</span>
<span class="nc" id="L1086">            throw (ke);</span>
<span class="fc" id="L1087">        }</span>
        // get the domain realm mapping from the configuration
<span class="fc" id="L1089">        String mapRealm = PrincipalName.mapHostToRealm(hostName);</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">        if (mapRealm == null) {</span>
            // No match. Try search and/or domain in /etc/resolv.conf
<span class="fc" id="L1092">            List&lt;String&gt; srchlist = ResolverConfiguration.open().searchlist();</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">            for (String domain: srchlist) {</span>
<span class="nc" id="L1094">                realm = checkRealm(domain);</span>
<span class="nc bnc" id="L1095" title="All 2 branches missed.">                if (realm != null) {</span>
<span class="nc" id="L1096">                    break;</span>
                }
<span class="nc" id="L1098">            }</span>
<span class="fc" id="L1099">        } else {</span>
<span class="nc" id="L1100">            realm = checkRealm(mapRealm);</span>
        }
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">        if (realm == null) {</span>
<span class="fc" id="L1103">            throw new KrbException(Krb5.KRB_ERR_GENERIC,</span>
                                &quot;Unable to locate Kerberos realm&quot;);
        }
<span class="nc" id="L1106">        return realm;</span>
    }

    /**
     * Check if the provided realm is the correct realm
     * @return the realm if correct, or null otherwise
     */
    private static String checkRealm(String mapRealm) {
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1115">            System.out.println(&quot;getRealmFromDNS: trying &quot; + mapRealm);</span>
        }
<span class="nc" id="L1117">        String[] records = null;</span>
<span class="nc" id="L1118">        String newRealm = mapRealm;</span>
<span class="nc bnc" id="L1119" title="All 4 branches missed.">        while ((records == null) &amp;&amp; (newRealm != null)) {</span>
            // locate DNS TXT record
<span class="nc" id="L1121">            records = KrbServiceLocator.getKerberosService(newRealm);</span>
<span class="nc" id="L1122">            newRealm = Realm.parseRealmComponent(newRealm);</span>
            // if no DNS TXT records found, try again using sub-realm
        }
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if (records != null) {</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            for (int i = 0; i &lt; records.length; i++) {</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">                if (records[i].equalsIgnoreCase(mapRealm)) {</span>
<span class="nc" id="L1128">                    return records[i];</span>
                }
            }
        }
<span class="nc" id="L1132">        return null;</span>
    }

    /**
     * Locate KDC using DNS
     *
     * @param realm the realm for which the master KDC is desired
     * @return the KDC
     */
    private String getKDCFromDNS(String realm) throws KrbException {
        // use DNS to locate KDC
<span class="fc" id="L1143">        String kdcs = &quot;&quot;;</span>
<span class="fc" id="L1144">        String[] srvs = null;</span>
        // locate DNS SRV record using UDP
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L1147">            System.out.println(&quot;getKDCFromDNS using UDP&quot;);</span>
        }
<span class="fc" id="L1149">        srvs = KrbServiceLocator.getKerberosService(realm, &quot;_udp&quot;);</span>
<span class="fc bfc" id="L1150" title="All 2 branches covered.">        if (srvs == null) {</span>
            // locate DNS SRV record using TCP
<span class="pc bpc" id="L1152" title="1 of 2 branches missed.">            if (DEBUG) {</span>
<span class="nc" id="L1153">                System.out.println(&quot;getKDCFromDNS using TCP&quot;);</span>
            }
<span class="fc" id="L1155">            srvs = KrbServiceLocator.getKerberosService(realm, &quot;_tcp&quot;);</span>
        }
<span class="fc bfc" id="L1157" title="All 2 branches covered.">        if (srvs == null) {</span>
            // no DNS SRV records
<span class="fc" id="L1159">            throw new KrbException(Krb5.KRB_ERR_GENERIC,</span>
                &quot;Unable to locate KDC for realm &quot; + realm);
        }
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">        if (srvs.length == 0) {</span>
<span class="nc" id="L1163">            return null;</span>
        }
<span class="fc bfc" id="L1165" title="All 2 branches covered.">        for (int i = 0; i &lt; srvs.length; i++) {</span>
<span class="fc" id="L1166">            kdcs += srvs[i].trim() + &quot; &quot;;</span>
        }
<span class="fc" id="L1168">        kdcs = kdcs.trim();</span>
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">        if (kdcs.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1170">            return null;</span>
        }
<span class="fc" id="L1172">        return kdcs;</span>
    }

    private boolean fileExists(String name) {
<span class="fc" id="L1176">        return java.security.AccessController.doPrivileged(</span>
                                new FileExistsAction(name));
    }

    static class FileExistsAction
        implements java.security.PrivilegedAction&lt;Boolean&gt; {

        private String fileName;

<span class="fc" id="L1185">        public FileExistsAction(String fileName) {</span>
<span class="fc" id="L1186">            this.fileName = fileName;</span>
<span class="fc" id="L1187">        }</span>

        public Boolean run() {
<span class="fc" id="L1190">            return new File(fileName).exists();</span>
        }
    }

    // Shows the content of the Config object for debug purpose.
    //
    // {
    //      libdefaults = {
    //          default_realm = R
    //      }
    //      realms = {
    //          R = {
    //              kdc = [k1,k2]
    //          }
    //      }
    // }

    @Override
    public String toString() {
<span class="fc" id="L1209">        StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L1210">        toStringInternal(&quot;&quot;, stanzaTable, sb);</span>
<span class="fc" id="L1211">        return sb.toString();</span>
    }
    private static void toStringInternal(String prefix, Object obj,
            StringBuffer sb) {
<span class="pc bpc" id="L1215" title="1 of 2 branches missed.">        if (obj instanceof String) {</span>
            // A string value, just print it
<span class="nc" id="L1217">            sb.append(obj).append('\n');</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">        } else if (obj instanceof Hashtable) {</span>
            // A table, start a new sub-section...
<span class="fc" id="L1220">            Hashtable&lt;?, ?&gt; tab = (Hashtable&lt;?, ?&gt;)obj;</span>
<span class="fc" id="L1221">            sb.append(&quot;{\n&quot;);</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">            for (Object o: tab.keySet()) {</span>
                // ...indent, print &quot;key = &quot;, and
<span class="fc" id="L1224">                sb.append(prefix).append(&quot;    &quot;).append(o).append(&quot; = &quot;);</span>
                // ...go recursively into value
<span class="fc" id="L1226">                toStringInternal(prefix + &quot;    &quot;, tab.get(o), sb);</span>
<span class="fc" id="L1227">            }</span>
<span class="fc" id="L1228">            sb.append(prefix).append(&quot;}\n&quot;);</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">        } else if (obj instanceof Vector) {</span>
            // A vector of strings, print them inside [ and ]
<span class="fc" id="L1231">            Vector&lt;?&gt; v = (Vector&lt;?&gt;)obj;</span>
<span class="fc" id="L1232">            sb.append(&quot;[&quot;);</span>
<span class="fc" id="L1233">            boolean first = true;</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">            for (Object o: v.toArray()) {</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">                if (!first) sb.append(&quot;,&quot;);</span>
<span class="fc" id="L1236">                sb.append(o);</span>
<span class="fc" id="L1237">                first = false;</span>
            }
<span class="fc" id="L1239">            sb.append(&quot;]\n&quot;);</span>
        }
<span class="fc" id="L1241">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>