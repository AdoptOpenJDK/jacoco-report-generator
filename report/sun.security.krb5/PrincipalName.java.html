<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PrincipalName.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.krb5</a> &gt; <span class="el_source">PrincipalName.java</span></div><h1>PrincipalName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */

package sun.security.krb5;

import sun.security.krb5.internal.*;
import sun.security.util.*;
import java.net.*;
import java.util.Vector;
import java.util.Locale;
import java.io.IOException;
import java.math.BigInteger;
import java.util.Arrays;
import sun.security.krb5.internal.ccache.CCacheOutputStream;
import sun.security.krb5.internal.util.KerberosString;


/**
 * Implements the ASN.1 PrincipalName type and its realm in a single class.
 * &lt;xmp&gt;
 *    Realm           ::= KerberosString
 *
 *    PrincipalName   ::= SEQUENCE {
 *            name-type       [0] Int32,
 *            name-string     [1] SEQUENCE OF KerberosString
 *    }
 * &lt;/xmp&gt;
 * This class is immutable.
 * @see Realm
 */
public class PrincipalName implements Cloneable {

    //name types

    /**
     * Name type not known
     */
    public static final int KRB_NT_UNKNOWN =   0;

    /**
     * Just the name of the principal as in DCE, or for users
     */
    public static final int KRB_NT_PRINCIPAL = 1;

    /**
     * Service and other unique instance (krbtgt)
     */
    public static final int KRB_NT_SRV_INST =  2;

    /**
     * Service with host name as instance (telnet, rcommands)
     */
    public static final int KRB_NT_SRV_HST =   3;

    /**
     * Service with host as remaining components
     */
    public static final int KRB_NT_SRV_XHST =  4;

    /**
     * Unique ID
     */
    public static final int KRB_NT_UID = 5;

    /**
     * TGS Name
     */
    public static final String TGS_DEFAULT_SRV_NAME = &quot;krbtgt&quot;;
    public static final int TGS_DEFAULT_NT = KRB_NT_SRV_INST;

    public static final char NAME_COMPONENT_SEPARATOR = '/';
    public static final char NAME_REALM_SEPARATOR = '@';
    public static final char REALM_COMPONENT_SEPARATOR = '.';

    public static final String NAME_COMPONENT_SEPARATOR_STR = &quot;/&quot;;
    public static final String NAME_REALM_SEPARATOR_STR = &quot;@&quot;;
    public static final String REALM_COMPONENT_SEPARATOR_STR = &quot;.&quot;;

    // Instance fields.

    /**
     * The name type, from PrincipalName's name-type field.
     */
    private final int nameType;

    /**
     * The name strings, from PrincipalName's name-strings field. This field
     * must be neither null nor empty. Each entry of it must also be neither
     * null nor empty. Make sure to clone the field when it's passed in or out.
     */
    private final String[] nameStrings;

    /**
     * The realm this principal belongs to.
     */
    private final Realm nameRealm;      // not null

    // cached default salt, not used in clone
<span class="fc" id="L127">    private transient String salt = null;</span>

    // There are 3 basic constructors. All other constructors must call them.
    // All basic constructors must call validateNameStrings.
    // 1. From name components
    // 2. From name
    // 3. From DER encoding

    /**
     * Creates a PrincipalName.
     */
<span class="fc" id="L138">    public PrincipalName(int nameType, String[] nameStrings, Realm nameRealm) {</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (nameRealm == null) {</span>
<span class="nc" id="L140">            throw new IllegalArgumentException(&quot;Null realm not allowed&quot;);</span>
        }
<span class="fc" id="L142">        validateNameStrings(nameStrings);</span>
<span class="fc" id="L143">        this.nameType = nameType;</span>
<span class="fc" id="L144">        this.nameStrings = nameStrings.clone();</span>
<span class="fc" id="L145">        this.nameRealm = nameRealm;</span>
<span class="fc" id="L146">    }</span>

    // This method is called by Windows NativeCred.c
    public PrincipalName(String[] nameParts, String realm) throws RealmException {
<span class="nc" id="L150">        this(KRB_NT_UNKNOWN, nameParts, new Realm(realm));</span>
<span class="nc" id="L151">    }</span>

    public PrincipalName(String[] nameParts, int type)
            throws IllegalArgumentException, RealmException {
<span class="nc" id="L155">        this(type, nameParts, Realm.getDefault());</span>
<span class="nc" id="L156">    }</span>

    // Validate a nameStrings argument
    private static void validateNameStrings(String[] ns) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (ns == null) {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(&quot;Null nameStrings not allowed&quot;);</span>
        }
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (ns.length == 0) {</span>
<span class="nc" id="L164">            throw new IllegalArgumentException(&quot;Empty nameStrings not allowed&quot;);</span>
        }
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (String s: ns) {</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L168">                throw new IllegalArgumentException(&quot;Null nameString not allowed&quot;);</span>
            }
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (s.isEmpty()) {</span>
<span class="fc" id="L171">                throw new IllegalArgumentException(&quot;Empty nameString not allowed&quot;);</span>
            }
        }
<span class="fc" id="L174">    }</span>

    public Object clone() {
        try {
<span class="fc" id="L178">            PrincipalName pName = (PrincipalName) super.clone();</span>
<span class="fc" id="L179">            UNSAFE.putObject(this, NAME_STRINGS_OFFSET, nameStrings.clone());</span>
<span class="fc" id="L180">            return pName;</span>
<span class="nc" id="L181">        } catch (CloneNotSupportedException ex) {</span>
<span class="nc" id="L182">            throw new AssertionError(&quot;Should never happen&quot;);</span>
        }
    }

    private static final long NAME_STRINGS_OFFSET;
    private static final sun.misc.Unsafe UNSAFE;
    static {
        try {
<span class="fc" id="L190">            sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L191">            NAME_STRINGS_OFFSET = unsafe.objectFieldOffset(</span>
<span class="fc" id="L192">                    PrincipalName.class.getDeclaredField(&quot;nameStrings&quot;));</span>
<span class="fc" id="L193">            UNSAFE = unsafe;</span>
<span class="nc" id="L194">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L195">            throw new Error(e);</span>
<span class="fc" id="L196">        }</span>
<span class="fc" id="L197">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (this == o) {</span>
<span class="nc" id="L202">            return true;</span>
        }
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (o instanceof PrincipalName) {</span>
<span class="fc" id="L205">            PrincipalName other = (PrincipalName)o;</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            return nameRealm.equals(other.nameRealm) &amp;&amp;</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                    Arrays.equals(nameStrings, other.nameStrings);</span>
        }
<span class="nc" id="L209">        return false;</span>
    }

    /**
     * Returns the ASN.1 encoding of the
     * &lt;xmp&gt;
     * PrincipalName    ::= SEQUENCE {
     *          name-type       [0] Int32,
     *          name-string     [1] SEQUENCE OF KerberosString
     * }
     *
     * KerberosString   ::= GeneralString (IA5String)
     * &lt;/xmp&gt;
     *
     * &lt;p&gt;
     * This definition reflects the Network Working Group RFC 4120
     * specification available at
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;
     * http://www.ietf.org/rfc/rfc4120.txt&lt;/a&gt;.
     *
     * @param encoding a Der-encoded data.
     * @param realm the realm for this name
     * @exception Asn1Exception if an error occurs while decoding
     * an ASN1 encoded data.
     * @exception Asn1Exception if there is an ASN1 encoding error
     * @exception IOException if an I/O error occurs
     * @exception IllegalArgumentException if encoding is null
     * reading encoded data.
     */
    public PrincipalName(DerValue encoding, Realm realm)
<span class="fc" id="L239">            throws Asn1Exception, IOException {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (realm == null) {</span>
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;Null realm not allowed&quot;);</span>
        }
<span class="fc" id="L243">        nameRealm = realm;</span>
        DerValue der;
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (encoding == null) {</span>
<span class="nc" id="L246">            throw new IllegalArgumentException(&quot;Null encoding not allowed&quot;);</span>
        }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (encoding.getTag() != DerValue.tag_Sequence) {</span>
<span class="nc" id="L249">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        }
<span class="fc" id="L251">        der = encoding.getData().getDerValue();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if ((der.getTag() &amp; 0x1F) == 0x00) {</span>
<span class="fc" id="L253">            BigInteger bint = der.getData().getBigInteger();</span>
<span class="fc" id="L254">            nameType = bint.intValue();</span>
<span class="fc" id="L255">        } else {</span>
<span class="nc" id="L256">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        }
<span class="fc" id="L258">        der = encoding.getData().getDerValue();</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if ((der.getTag() &amp; 0x01F) == 0x01) {</span>
<span class="fc" id="L260">            DerValue subDer = der.getData().getDerValue();</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            if (subDer.getTag() != DerValue.tag_SequenceOf) {</span>
<span class="nc" id="L262">                throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
            }
<span class="fc" id="L264">            Vector&lt;String&gt; v = new Vector&lt;&gt;();</span>
            DerValue subSubDer;
<span class="fc bfc" id="L266" title="All 2 branches covered.">            while(subDer.getData().available() &gt; 0) {</span>
<span class="fc" id="L267">                subSubDer = subDer.getData().getDerValue();</span>
<span class="fc" id="L268">                String namePart = new KerberosString(subSubDer).toString();</span>
<span class="fc" id="L269">                v.addElement(namePart);</span>
<span class="fc" id="L270">            }</span>
<span class="fc" id="L271">            nameStrings = new String[v.size()];</span>
<span class="fc" id="L272">            v.copyInto(nameStrings);</span>
<span class="fc" id="L273">            validateNameStrings(nameStrings);</span>
<span class="fc" id="L274">        } else  {</span>
<span class="nc" id="L275">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        }
<span class="fc" id="L277">    }</span>

    /**
     * Parse (unmarshal) a &lt;code&gt;PrincipalName&lt;/code&gt; from a DER
     * input stream.  This form
     * parsing might be used when expanding a value which is part of
     * a constructed sequence and uses explicitly tagged type.
     *
     * @exception Asn1Exception on error.
     * @param data the Der input stream value, which contains one or
     * more marshaled value.
     * @param explicitTag tag number.
     * @param optional indicate if this data field is optional
     * @param realm the realm for the name
     * @return an instance of &lt;code&gt;PrincipalName&lt;/code&gt;, or null if the
     * field is optional and missing.
     */
    public static PrincipalName parse(DerInputStream data,
                                      byte explicitTag, boolean
                                      optional,
                                      Realm realm)
        throws Asn1Exception, IOException, RealmException {

<span class="fc bfc" id="L300" title="All 4 branches covered.">        if ((optional) &amp;&amp; (((byte)data.peekByte() &amp; (byte)0x1F) !=</span>
                           explicitTag))
<span class="fc" id="L302">            return null;</span>
<span class="fc" id="L303">        DerValue der = data.getDerValue();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (explicitTag != (der.getTag() &amp; (byte)0x1F)) {</span>
<span class="nc" id="L305">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        } else {
<span class="fc" id="L307">            DerValue subDer = der.getData().getDerValue();</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">            if (realm == null) {</span>
<span class="nc" id="L309">                realm = Realm.getDefault();</span>
            }
<span class="fc" id="L311">            return new PrincipalName(subDer, realm);</span>
        }
    }


    // XXX Error checkin consistent with MIT krb5_parse_name
    // Code repetition, realm parsed again by class Realm
    private static String[] parseName(String name) {

<span class="fc" id="L320">        Vector&lt;String&gt; tempStrings = new Vector&lt;&gt;();</span>
<span class="fc" id="L321">        String temp = name;</span>
<span class="fc" id="L322">        int i = 0;</span>
<span class="fc" id="L323">        int componentStart = 0;</span>
        String component;

<span class="fc bfc" id="L326" title="All 2 branches covered.">        while (i &lt; temp.length()) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (temp.charAt(i) == NAME_COMPONENT_SEPARATOR) {</span>
                /*
                 * If this separator is escaped then don't treat it
                 * as a separator
                 */
<span class="fc bfc" id="L332" title="All 4 branches covered.">                if (i &gt; 0 &amp;&amp; temp.charAt(i - 1) == '\\') {</span>
<span class="fc" id="L333">                    temp = temp.substring(0, i - 1) +</span>
<span class="fc" id="L334">                        temp.substring(i, temp.length());</span>
<span class="fc" id="L335">                    continue;</span>
                }
                else {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                    if (componentStart &lt;= i) {</span>
<span class="fc" id="L339">                        component = temp.substring(componentStart, i);</span>
<span class="fc" id="L340">                        tempStrings.addElement(component);</span>
                    }
<span class="fc" id="L342">                    componentStart = i + 1;</span>
                }
            } else {
<span class="fc bfc" id="L345" title="All 2 branches covered.">                if (temp.charAt(i) == NAME_REALM_SEPARATOR) {</span>
                    /*
                     * If this separator is escaped then don't treat it
                     * as a separator
                     */
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">                    if (i &gt; 0 &amp;&amp; temp.charAt(i - 1) == '\\') {</span>
<span class="fc" id="L351">                        temp = temp.substring(0, i - 1) +</span>
<span class="fc" id="L352">                            temp.substring(i, temp.length());</span>
<span class="fc" id="L353">                        continue;</span>
                    } else {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">                        if (componentStart &lt; i) {</span>
<span class="fc" id="L356">                            component = temp.substring(componentStart, i);</span>
<span class="fc" id="L357">                            tempStrings.addElement(component);</span>
                        }
<span class="fc" id="L359">                        componentStart = i + 1;</span>
<span class="fc" id="L360">                        break;</span>
                    }
                }
            }
<span class="fc" id="L364">            i++;</span>
        }

<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (i == temp.length()) {</span>
<span class="fc" id="L368">            component = temp.substring(componentStart, i);</span>
<span class="fc" id="L369">            tempStrings.addElement(component);</span>
        }

<span class="fc" id="L372">        String[] result = new String[tempStrings.size()];</span>
<span class="fc" id="L373">        tempStrings.copyInto(result);</span>
<span class="fc" id="L374">        return result;</span>
    }

    /**
     * Constructs a PrincipalName from a string.
     * @param name the name
     * @param type the type
     * @param realm the realm, null if not known. Note that when realm is not
     * null, it will be always used even if there is a realm part in name. When
     * realm is null, will read realm part from name, or try to map a realm
     * (for KRB_NT_SRV_HST), or use the default realm, or fail
     * @throws RealmException
     */
    public PrincipalName(String name, int type, String realm)
<span class="fc" id="L388">            throws RealmException {</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L390">            throw new IllegalArgumentException(&quot;Null name not allowed&quot;);</span>
        }
<span class="fc" id="L392">        String[] nameParts = parseName(name);</span>
<span class="fc" id="L393">        validateNameStrings(nameParts);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (realm == null) {</span>
<span class="fc" id="L395">            realm = Realm.parseRealmAtSeparator(name);</span>
        }
<span class="pc bpc" id="L397" title="1 of 3 branches missed.">        switch (type) {</span>
        case KRB_NT_SRV_HST:
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">            if (nameParts.length &gt;= 2) {</span>
<span class="fc" id="L400">                String hostName = nameParts[1];</span>
                try {
                    // RFC4120 does not recommend canonicalizing a hostname.
                    // However, for compatibility reason, we will try
                    // canonicalize it and see if the output looks better.

<span class="fc" id="L406">                    String canonicalized = (InetAddress.getByName(hostName)).</span>
<span class="fc" id="L407">                            getCanonicalHostName();</span>

                    // Looks if canonicalized is a longer format of hostName,
                    // we accept cases like
                    //     bunny -&gt; bunny.rabbit.hole
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">                    if (canonicalized.toLowerCase(Locale.ENGLISH).startsWith(</span>
<span class="fc" id="L413">                                hostName.toLowerCase(Locale.ENGLISH)+&quot;.&quot;)) {</span>
<span class="nc" id="L414">                        hostName = canonicalized;</span>
                    }
<span class="fc" id="L416">                } catch (UnknownHostException e) {</span>
                    // no canonicalization, use old
<span class="fc" id="L418">                }</span>
<span class="fc" id="L419">                nameParts[1] = hostName.toLowerCase(Locale.ENGLISH);</span>
            }
<span class="fc" id="L421">            nameStrings = nameParts;</span>
<span class="fc" id="L422">            nameType = type;</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">            if (realm != null) {</span>
<span class="fc" id="L425">                nameRealm = new Realm(realm);</span>
            } else {
                // We will try to get realm name from the mapping in
                // the configuration. If it is not specified
                // we will use the default realm. This nametype does
                // not allow a realm to be specified. The name string must of
                // the form service@host and this is internally changed into
                // service/host by Kerberos
<span class="fc" id="L433">                String mapRealm =  mapHostToRealm(nameParts[1]);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                if (mapRealm != null) {</span>
<span class="fc" id="L435">                    nameRealm = new Realm(mapRealm);</span>
                } else {
<span class="fc" id="L437">                    nameRealm = Realm.getDefault();</span>
                }
            }
<span class="fc" id="L440">            break;</span>
        case KRB_NT_UNKNOWN:
        case KRB_NT_PRINCIPAL:
        case KRB_NT_SRV_INST:
        case KRB_NT_SRV_XHST:
        case KRB_NT_UID:
<span class="fc" id="L446">            nameStrings = nameParts;</span>
<span class="fc" id="L447">            nameType = type;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">            if (realm != null) {</span>
<span class="fc" id="L449">                nameRealm = new Realm(realm);</span>
            } else {
<span class="fc" id="L451">                nameRealm = Realm.getDefault();</span>
            }
<span class="fc" id="L453">            break;</span>
        default:
<span class="nc" id="L455">            throw new IllegalArgumentException(&quot;Illegal name type&quot;);</span>
        }
<span class="fc" id="L457">    }</span>

    public PrincipalName(String name, int type) throws RealmException {
<span class="fc" id="L460">        this(name, type, (String)null);</span>
<span class="fc" id="L461">    }</span>

    public PrincipalName(String name) throws RealmException {
<span class="fc" id="L464">        this(name, KRB_NT_UNKNOWN);</span>
<span class="fc" id="L465">    }</span>

    public PrincipalName(String name, String realm) throws RealmException {
<span class="nc" id="L468">        this(name, KRB_NT_UNKNOWN, realm);</span>
<span class="nc" id="L469">    }</span>

    public static PrincipalName tgsService(String r1, String r2)
            throws KrbException {
<span class="fc" id="L473">        return new PrincipalName(PrincipalName.KRB_NT_SRV_INST,</span>
                new String[] {PrincipalName.TGS_DEFAULT_SRV_NAME, r1},
                new Realm(r2));
    }

    public String getRealmAsString() {
<span class="fc" id="L479">        return getRealmString();</span>
    }

    public String getPrincipalNameAsString() {
<span class="nc" id="L483">        StringBuffer temp = new StringBuffer(nameStrings[0]);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (int i = 1; i &lt; nameStrings.length; i++)</span>
<span class="nc" id="L485">            temp.append(nameStrings[i]);</span>
<span class="nc" id="L486">        return temp.toString();</span>
    }

    public int hashCode() {
<span class="nc" id="L490">        return toString().hashCode();</span>
    }

    public String getName() {
<span class="fc" id="L494">        return toString();</span>
    }

    public int getNameType() {
<span class="fc" id="L498">        return nameType;</span>
    }

    public String[] getNameStrings() {
<span class="fc" id="L502">        return nameStrings.clone();</span>
    }

    public byte[][] toByteArray() {
<span class="nc" id="L506">        byte[][] result = new byte[nameStrings.length][];</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">        for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="nc" id="L508">            result[i] = new byte[nameStrings[i].length()];</span>
<span class="nc" id="L509">            result[i] = nameStrings[i].getBytes();</span>
        }
<span class="nc" id="L511">        return result;</span>
    }

    public String getRealmString() {
<span class="fc" id="L515">        return nameRealm.toString();</span>
    }

    public Realm getRealm() {
<span class="fc" id="L519">        return nameRealm;</span>
    }

    public String getSalt() {
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (salt == null) {</span>
<span class="fc" id="L524">            StringBuffer salt = new StringBuffer();</span>
<span class="fc" id="L525">            salt.append(nameRealm.toString());</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">            for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="fc" id="L527">                salt.append(nameStrings[i]);</span>
            }
<span class="fc" id="L529">            return salt.toString();</span>
        }
<span class="nc" id="L531">        return salt;</span>
    }

    public String toString() {
<span class="fc" id="L535">        StringBuffer str = new StringBuffer();</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">            if (i &gt; 0)</span>
<span class="fc" id="L538">                str.append(&quot;/&quot;);</span>
<span class="fc" id="L539">            str.append(nameStrings[i]);</span>
        }
<span class="fc" id="L541">        str.append(&quot;@&quot;);</span>
<span class="fc" id="L542">        str.append(nameRealm.toString());</span>
<span class="fc" id="L543">        return str.toString();</span>
    }

    public String getNameString() {
<span class="nc" id="L547">        StringBuffer str = new StringBuffer();</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (i &gt; 0)</span>
<span class="nc" id="L550">                str.append(&quot;/&quot;);</span>
<span class="nc" id="L551">            str.append(nameStrings[i]);</span>
        }
<span class="nc" id="L553">        return str.toString();</span>
    }

    /**
     * Encodes a &lt;code&gt;PrincipalName&lt;/code&gt; object. Note that only the type and
     * names are encoded. To encode the realm, call getRealm().asn1Encode().
     * @return the byte array of the encoded PrncipalName object.
     * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
     * @exception IOException if an I/O error occurs while reading encoded data.
     *
     */
    public byte[] asn1Encode() throws Asn1Exception, IOException {
<span class="fc" id="L565">        DerOutputStream bytes = new DerOutputStream();</span>
<span class="fc" id="L566">        DerOutputStream temp = new DerOutputStream();</span>
<span class="fc" id="L567">        BigInteger bint = BigInteger.valueOf(this.nameType);</span>
<span class="fc" id="L568">        temp.putInteger(bint);</span>
<span class="fc" id="L569">        bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x00), temp);</span>
<span class="fc" id="L570">        temp = new DerOutputStream();</span>
<span class="fc" id="L571">        DerValue der[] = new DerValue[nameStrings.length];</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="fc" id="L573">            der[i] = new KerberosString(nameStrings[i]).toDerValue();</span>
        }
<span class="fc" id="L575">        temp.putSequence(der);</span>
<span class="fc" id="L576">        bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true, (byte)0x01), temp);</span>
<span class="fc" id="L577">        temp = new DerOutputStream();</span>
<span class="fc" id="L578">        temp.write(DerValue.tag_Sequence, bytes);</span>
<span class="fc" id="L579">        return temp.toByteArray();</span>
    }


    /**
     * Checks if two &lt;code&gt;PrincipalName&lt;/code&gt; objects have identical values in their corresponding data fields.
     *
     * @param pname the other &lt;code&gt;PrincipalName&lt;/code&gt; object.
     * @return true if two have identical values, otherwise, return false.
     */
    // It is used in &lt;code&gt;sun.security.krb5.internal.ccache&lt;/code&gt; package.
    public boolean match(PrincipalName pname) {
<span class="fc" id="L591">        boolean matched = true;</span>
        //name type is just a hint, no two names can be the same ignoring name type.
        // if (this.nameType != pname.nameType) {
        //      matched = false;
        // }
<span class="pc bpc" id="L596" title="2 of 4 branches missed.">        if ((this.nameRealm != null) &amp;&amp; (pname.nameRealm != null)) {</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (!(this.nameRealm.toString().equalsIgnoreCase(pname.nameRealm.toString()))) {</span>
<span class="fc" id="L598">                matched = false;</span>
            }
        }
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (this.nameStrings.length != pname.nameStrings.length) {</span>
<span class="fc" id="L602">            matched = false;</span>
        } else {
<span class="fc bfc" id="L604" title="All 2 branches covered.">            for (int i = 0; i &lt; this.nameStrings.length; i++) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                if (!(this.nameStrings[i].equalsIgnoreCase(pname.nameStrings[i]))) {</span>
<span class="fc" id="L606">                    matched = false;</span>
                }
            }
        }
<span class="fc" id="L610">        return matched;</span>
    }

    /**
     * Writes data field values of &lt;code&gt;PrincipalName&lt;/code&gt; in FCC format to an output stream.
     *
     * @param cos a &lt;code&gt;CCacheOutputStream&lt;/code&gt; for writing data.
     * @exception IOException if an I/O exception occurs.
     * @see sun.security.krb5.internal.ccache.CCacheOutputStream
     */
    public void writePrincipal(CCacheOutputStream cos) throws IOException {
<span class="nc" id="L621">        cos.write32(nameType);</span>
<span class="nc" id="L622">        cos.write32(nameStrings.length);</span>
<span class="nc" id="L623">        byte[] realmBytes = null;</span>
<span class="nc" id="L624">        realmBytes = nameRealm.toString().getBytes();</span>
<span class="nc" id="L625">        cos.write32(realmBytes.length);</span>
<span class="nc" id="L626">        cos.write(realmBytes, 0, realmBytes.length);</span>
<span class="nc" id="L627">        byte[] bytes = null;</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">        for (int i = 0; i &lt; nameStrings.length; i++) {</span>
<span class="nc" id="L629">            bytes = nameStrings[i].getBytes();</span>
<span class="nc" id="L630">            cos.write32(bytes.length);</span>
<span class="nc" id="L631">            cos.write(bytes, 0, bytes.length);</span>
        }
<span class="nc" id="L633">    }</span>

    /**
     * Returns the instance component of a name.
     * In a multi-component name such as a KRB_NT_SRV_INST
     * name, the second component is returned.
     * Null is returned if there are not two or more
     * components in the name.
     * @returns instance component of a multi-component name.
     */
    public String getInstanceComponent()
    {
<span class="nc bnc" id="L645" title="All 4 branches missed.">        if (nameStrings != null &amp;&amp; nameStrings.length &gt;= 2)</span>
            {
<span class="nc" id="L647">                return new String(nameStrings[1]);</span>
            }

<span class="nc" id="L650">        return null;</span>
    }

    static String mapHostToRealm(String name) {
<span class="fc" id="L654">        String result = null;</span>
        try {
<span class="fc" id="L656">            String subname = null;</span>
<span class="fc" id="L657">            Config c = Config.getInstance();</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">            if ((result = c.get(&quot;domain_realm&quot;, name)) != null)</span>
<span class="nc" id="L659">                return result;</span>
            else {
<span class="fc bfc" id="L661" title="All 2 branches covered.">                for (int i = 1; i &lt; name.length(); i++) {</span>
<span class="pc bpc" id="L662" title="1 of 4 branches missed.">                    if ((name.charAt(i) == '.') &amp;&amp; (i != name.length() - 1)) { //mapping could be .ibm.com = AUSTIN.IBM.COM</span>
<span class="fc" id="L663">                        subname = name.substring(i);</span>
<span class="fc" id="L664">                        result = c.get(&quot;domain_realm&quot;, subname);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                        if (result != null) {</span>
<span class="fc" id="L666">                            break;</span>
                        }
                        else {
<span class="fc" id="L669">                            subname = name.substring(i + 1);      //or mapping could be ibm.com = AUSTIN.IBM.COM</span>
<span class="fc" id="L670">                            result = c.get(&quot;domain_realm&quot;, subname);</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                            if (result != null) {</span>
<span class="nc" id="L672">                                break;</span>
                            }
                        }
                    }
                }
            }
<span class="nc" id="L678">        } catch (KrbException e) {</span>
<span class="fc" id="L679">        }</span>
<span class="fc" id="L680">        return result;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>