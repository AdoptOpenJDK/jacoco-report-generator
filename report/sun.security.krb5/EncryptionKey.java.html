<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EncryptionKey.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.krb5</a> &gt; <span class="el_source">EncryptionKey.java</span></div><h1>EncryptionKey.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */

package sun.security.krb5;

import sun.security.util.*;
import sun.security.krb5.internal.*;
import sun.security.krb5.internal.crypto.*;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.Arrays;
import sun.security.krb5.internal.ktab.KeyTab;
import sun.security.krb5.internal.ccache.CCacheOutputStream;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.DESedeKeySpec;

/**
 * This class encapsulates the concept of an EncryptionKey. An encryption
 * key is defined in RFC 4120 as:
 *
 * EncryptionKey   ::= SEQUENCE {
 *         keytype         [0] Int32 -- actually encryption type --,
 *         keyvalue        [1] OCTET STRING
 * }
 *
 * keytype
 *     This field specifies the encryption type of the encryption key
 *     that follows in the keyvalue field.  Although its name is
 *     &quot;keytype&quot;, it actually specifies an encryption type.  Previously,
 *     multiple cryptosystems that performed encryption differently but
 *     were capable of using keys with the same characteristics were
 *     permitted to share an assigned number to designate the type of
 *     key; this usage is now deprecated.
 *
 * keyvalue
 *     This field contains the key itself, encoded as an octet string.
 */

public class EncryptionKey
    implements Cloneable {

<span class="fc" id="L70">    public static final EncryptionKey NULL_KEY =</span>
        new EncryptionKey(new byte[] {}, EncryptedData.ETYPE_NULL, null);

    private int keyType;
    private byte[] keyValue;
    private Integer kvno; // not part of ASN1 encoding;

<span class="fc" id="L77">    private static final boolean DEBUG = Krb5.DEBUG;</span>

    public synchronized int getEType() {
<span class="fc" id="L80">        return keyType;</span>
    }

    public final Integer getKeyVersionNumber() {
<span class="fc" id="L84">        return kvno;</span>
    }

    /**
     * Returns the raw key bytes, not in any ASN.1 encoding.
     */
    public final byte[] getBytes() {
        // This method cannot be called outside sun.security, hence no
        // cloning. getEncoded() calls this method.
<span class="fc" id="L93">        return keyValue;</span>
    }

    public synchronized Object clone() {
<span class="fc" id="L97">        return new EncryptionKey(keyValue, keyType, kvno);</span>
    }

    /**
     * Obtains all versions of the secret key of the principal from a
     * keytab.
     *
     * @Param princ the principal whose secret key is desired
     * @param keytab the path to the keytab file. A value of null
     * will be accepted to indicate that the default path should be
     * searched.
     * @returns an array of secret keys or null if none were found.
     */
    public static EncryptionKey[] acquireSecretKeys(PrincipalName princ,
                                                    String keytab) {

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (princ == null)</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(</span>
                &quot;Cannot have null pricipal name to look in keytab.&quot;);

        // KeyTab getInstance(keytab) will call KeyTab.getInstance()
        // if keytab is null
<span class="nc" id="L119">        KeyTab ktab = KeyTab.getInstance(keytab);</span>
<span class="nc" id="L120">        return ktab.readServiceKeys(princ);</span>
    }

    /**
     * Obtains a key for a given etype of a principal with possible new salt
     * and s2kparams
     * @param cname NOT null
     * @param password NOT null
     * @param etype
     * @param snp can be NULL
     * @returns never null
     */
    public static EncryptionKey acquireSecretKey(PrincipalName cname,
            char[] password, int etype, PAData.SaltAndParams snp)
            throws KrbException {
        String salt;
        byte[] s2kparams;
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (snp != null) {</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">            salt = snp.salt != null ? snp.salt : cname.getSalt();</span>
<span class="fc" id="L139">            s2kparams = snp.params;</span>
        } else {
<span class="nc" id="L141">            salt = cname.getSalt();</span>
<span class="nc" id="L142">            s2kparams = null;</span>
        }
<span class="fc" id="L144">        return acquireSecretKey(password, salt, etype, s2kparams);</span>
    }

    /**
     * Obtains a key for a given etype with salt and optional s2kparams
     * @param password NOT null
     * @param salt NOT null
     * @param etype
     * @param s2kparams can be NULL
     * @returns never null
     */
    public static EncryptionKey acquireSecretKey(char[] password,
            String salt, int etype, byte[] s2kparams)
            throws KrbException {

<span class="fc" id="L159">        return new EncryptionKey(</span>
<span class="fc" id="L160">                        stringToKey(password, salt, s2kparams, etype),</span>
                        etype, null);
    }

    /**
     * Generate a list of keys using the given principal and password.
     * Construct a key for each configured etype.
     * Caller is responsible for clearing password.
     */
    /*
     * Usually, when keyType is decoded from ASN.1 it will contain a
     * value indicating what the algorithm to be used is. However, when
     * converting from a password to a key for the AS-EXCHANGE, this
     * keyType will not be available. Use builtin list of default etypes
     * as the default in that case. If default_tkt_enctypes was set in
     * the libdefaults of krb5.conf, then use that sequence.
     */
    public static EncryptionKey[] acquireSecretKeys(char[] password,
            String salt) throws KrbException {

<span class="fc" id="L180">        int[] etypes = EType.getDefaults(&quot;default_tkt_enctypes&quot;);</span>

<span class="fc" id="L182">        EncryptionKey[] encKeys = new EncryptionKey[etypes.length];</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (int i = 0; i &lt; etypes.length; i++) {</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">            if (EType.isSupported(etypes[i])) {</span>
<span class="fc" id="L185">                encKeys[i] = new EncryptionKey(</span>
<span class="fc" id="L186">                        stringToKey(password, salt, null, etypes[i]),</span>
                        etypes[i], null);
            } else {
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (DEBUG) {</span>
<span class="nc" id="L190">                    System.out.println(&quot;Encryption Type &quot; +</span>
<span class="nc" id="L191">                        EType.toString(etypes[i]) +</span>
                        &quot; is not supported/enabled&quot;);
                }
            }
        }
<span class="fc" id="L196">        return encKeys;</span>
    }

    // Used in Krb5AcceptCredential, self
    public EncryptionKey(byte[] keyValue,
                         int keyType,
<span class="fc" id="L202">                         Integer kvno) {</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (keyValue != null) {</span>
<span class="fc" id="L205">            this.keyValue = new byte[keyValue.length];</span>
<span class="fc" id="L206">            System.arraycopy(keyValue, 0, this.keyValue, 0, keyValue.length);</span>
        } else {
<span class="nc" id="L208">            throw new IllegalArgumentException(&quot;EncryptionKey: &quot; +</span>
                                               &quot;Key bytes cannot be null!&quot;);
        }
<span class="fc" id="L211">        this.keyType = keyType;</span>
<span class="fc" id="L212">        this.kvno = kvno;</span>
<span class="fc" id="L213">    }</span>

    /**
     * Constructs an EncryptionKey by using the specified key type and key
     * value.  It is used to recover the key when retrieving data from
     * credential cache file.
     *
     */
     // Used in JSSE (KerberosWrapper), Credentials,
     // javax.security.auth.kerberos.KeyImpl
    public EncryptionKey(int keyType,
                         byte[] keyValue) {
<span class="fc" id="L225">        this(keyValue, keyType, null);</span>
<span class="fc" id="L226">    }</span>

    private static byte[] stringToKey(char[] password, String salt,
        byte[] s2kparams, int keyType) throws KrbCryptoException {

<span class="fc" id="L231">        char[] slt = salt.toCharArray();</span>
<span class="fc" id="L232">        char[] pwsalt = new char[password.length + slt.length];</span>
<span class="fc" id="L233">        System.arraycopy(password, 0, pwsalt, 0, password.length);</span>
<span class="fc" id="L234">        System.arraycopy(slt, 0, pwsalt, password.length, slt.length);</span>
<span class="fc" id="L235">        Arrays.fill(slt, '0');</span>

        try {
<span class="pc bpc" id="L238" title="2 of 6 branches missed.">            switch (keyType) {</span>
                case EncryptedData.ETYPE_DES_CBC_CRC:
                case EncryptedData.ETYPE_DES_CBC_MD5:
<span class="fc" id="L241">                        return Des.string_to_key_bytes(pwsalt);</span>

                case EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD:
<span class="fc" id="L244">                        return Des3.stringToKey(pwsalt);</span>

                case EncryptedData.ETYPE_ARCFOUR_HMAC:
<span class="fc" id="L247">                        return ArcFourHmac.stringToKey(password);</span>

                case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="fc" id="L250">                        return Aes128.stringToKey(password, salt, s2kparams);</span>

                case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L253">                        return Aes256.stringToKey(password, salt, s2kparams);</span>

                default:
<span class="nc" id="L256">                        throw new IllegalArgumentException(&quot;encryption type &quot; +</span>
<span class="nc" id="L257">                        EType.toString(keyType) + &quot; not supported&quot;);</span>
            }

<span class="nc" id="L260">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L261">            KrbCryptoException ke = new KrbCryptoException(e.getMessage());</span>
<span class="nc" id="L262">            ke.initCause(e);</span>
<span class="nc" id="L263">            throw ke;</span>
        } finally {
<span class="pc" id="L265">            Arrays.fill(pwsalt, '0');</span>
        }
    }

    // Used in javax.security.auth.kerberos.KeyImpl
    public EncryptionKey(char[] password,
                         String salt,
<span class="fc" id="L272">                         String algorithm) throws KrbCryptoException {</span>

<span class="pc bpc" id="L274" title="2 of 4 branches missed.">        if (algorithm == null || algorithm.equalsIgnoreCase(&quot;DES&quot;)) {</span>
<span class="nc" id="L275">            keyType = EncryptedData.ETYPE_DES_CBC_MD5;</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        } else if (algorithm.equalsIgnoreCase(&quot;DESede&quot;)) {</span>
<span class="nc" id="L277">            keyType = EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        } else if (algorithm.equalsIgnoreCase(&quot;AES128&quot;)) {</span>
<span class="fc" id="L279">            keyType = EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        } else if (algorithm.equalsIgnoreCase(&quot;ArcFourHmac&quot;)) {</span>
<span class="nc" id="L281">            keyType = EncryptedData.ETYPE_ARCFOUR_HMAC;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        } else if (algorithm.equalsIgnoreCase(&quot;AES256&quot;)) {</span>
<span class="nc" id="L283">            keyType = EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96;</span>
            // validate if AES256 is enabled
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (!EType.isSupported(keyType)) {</span>
<span class="nc" id="L286">                throw new IllegalArgumentException(&quot;Algorithm &quot; + algorithm +</span>
                        &quot; not enabled&quot;);
            }
        } else {
<span class="nc" id="L290">            throw new IllegalArgumentException(&quot;Algorithm &quot; + algorithm +</span>
                &quot; not supported&quot;);
        }

<span class="fc" id="L294">        keyValue = stringToKey(password, salt, null, keyType);</span>
<span class="fc" id="L295">        kvno = null;</span>
<span class="fc" id="L296">    }</span>

    /**
     * Generates a sub-sessionkey from a given session key.
     *
     * Used in AcceptSecContextToken and KrbApReq by acceptor- and initiator-
     * side respectively.
     */
<span class="fc" id="L304">    public EncryptionKey(EncryptionKey key) throws KrbCryptoException {</span>
        // generate random sub-session key
<span class="fc" id="L306">        keyValue = Confounder.bytes(key.keyValue.length);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (int i = 0; i &lt; keyValue.length; i++) {</span>
<span class="fc" id="L308">          keyValue[i] ^= key.keyValue[i];</span>
        }
<span class="fc" id="L310">        keyType = key.keyType;</span>

        // check for key parity and weak keys
        try {
            // check for DES key
<span class="pc bpc" id="L315" title="2 of 4 branches missed.">            if ((keyType == EncryptedData.ETYPE_DES_CBC_MD5) ||</span>
                (keyType == EncryptedData.ETYPE_DES_CBC_CRC)) {
                // fix DES key parity
<span class="nc bnc" id="L318" title="All 2 branches missed.">                if (!DESKeySpec.isParityAdjusted(keyValue, 0)) {</span>
<span class="nc" id="L319">                    keyValue = Des.set_parity(keyValue);</span>
                }
                // check for weak key
<span class="nc bnc" id="L322" title="All 2 branches missed.">                if (DESKeySpec.isWeak(keyValue, 0)) {</span>
<span class="nc" id="L323">                    keyValue[7] = (byte)(keyValue[7] ^ 0xF0);</span>
                }
            }
            // check for 3DES key
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if (keyType == EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD) {</span>
                // fix 3DES key parity
<span class="nc bnc" id="L329" title="All 2 branches missed.">                if (!DESedeKeySpec.isParityAdjusted(keyValue, 0)) {</span>
<span class="nc" id="L330">                    keyValue = Des3.parityFix(keyValue);</span>
                }
                // check for weak keys
<span class="nc" id="L333">                byte[] oneKey = new byte[8];</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                for (int i=0; i&lt;keyValue.length; i+=8) {</span>
<span class="nc" id="L335">                    System.arraycopy(keyValue, i, oneKey, 0, 8);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                    if (DESKeySpec.isWeak(oneKey, 0)) {</span>
<span class="nc" id="L337">                        keyValue[i+7] = (byte)(keyValue[i+7] ^ 0xF0);</span>
                    }
                }
            }
<span class="nc" id="L341">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L342">            KrbCryptoException ke = new KrbCryptoException(e.getMessage());</span>
<span class="nc" id="L343">            ke.initCause(e);</span>
<span class="nc" id="L344">            throw ke;</span>
<span class="fc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    /**
     * Constructs an instance of EncryptionKey type.
     * @param encoding a single DER-encoded value.
     * @exception Asn1Exception if an error occurs while decoding an ASN1
     * encoded data.
     * @exception IOException if an I/O error occurs while reading encoded
     * data.
     *
     *
     */
         // Used in javax.security.auth.kerberos.KeyImpl
<span class="fc" id="L359">    public EncryptionKey(DerValue encoding) throws Asn1Exception, IOException {</span>
        DerValue der;
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if (encoding.getTag() != DerValue.tag_Sequence) {</span>
<span class="nc" id="L362">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        }
<span class="fc" id="L364">        der = encoding.getData().getDerValue();</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if ((der.getTag() &amp; (byte)0x1F) == (byte)0x00) {</span>
<span class="fc" id="L366">            keyType = der.getData().getBigInteger().intValue();</span>
        }
        else
<span class="nc" id="L369">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
<span class="fc" id="L370">        der = encoding.getData().getDerValue();</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if ((der.getTag() &amp; (byte)0x1F) == (byte)0x01) {</span>
<span class="fc" id="L372">            keyValue = der.getData().getOctetString();</span>
        }
        else
<span class="nc" id="L375">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (der.getData().available() &gt; 0) {</span>
<span class="nc" id="L377">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        }
<span class="fc" id="L379">    }</span>

    /**
     * Returns the ASN.1 encoding of this EncryptionKey.
     *
     * &lt;xmp&gt;
     * EncryptionKey ::=   SEQUENCE {
     *                             keytype[0]    INTEGER,
     *                             keyvalue[1]   OCTET STRING }
     * &lt;/xmp&gt;
     *
     * &lt;p&gt;
     * This definition reflects the Network Working Group RFC 4120
     * specification available at
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;
     * http://www.ietf.org/rfc/rfc4120.txt&lt;/a&gt;.
     *
     * @return byte array of encoded EncryptionKey object.
     * @exception Asn1Exception if an error occurs while decoding an ASN1
     * encoded data.
     * @exception IOException if an I/O error occurs while reading encoded
     * data.
     *
     */
    public synchronized byte[] asn1Encode() throws Asn1Exception, IOException {
<span class="fc" id="L404">        DerOutputStream bytes = new DerOutputStream();</span>
<span class="fc" id="L405">        DerOutputStream temp = new DerOutputStream();</span>
<span class="fc" id="L406">        temp.putInteger(keyType);</span>
<span class="fc" id="L407">        bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,</span>
                                       (byte)0x00), temp);
<span class="fc" id="L409">        temp = new DerOutputStream();</span>
<span class="fc" id="L410">        temp.putOctetString(keyValue);</span>
<span class="fc" id="L411">        bytes.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,</span>
                                       (byte)0x01), temp);
<span class="fc" id="L413">        temp = new DerOutputStream();</span>
<span class="fc" id="L414">        temp.write(DerValue.tag_Sequence, bytes);</span>
<span class="fc" id="L415">        return temp.toByteArray();</span>
    }

    public synchronized void destroy() {
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if (keyValue != null)</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">            for (int i = 0; i &lt; keyValue.length; i++)</span>
<span class="fc" id="L421">                keyValue[i] = 0;</span>
<span class="fc" id="L422">    }</span>


    /**
     * Parse (unmarshal) an Encryption key from a DER input stream.  This form
     * parsing might be used when expanding a value which is part of
     * a constructed sequence and uses explicitly tagged type.
     *
     * @param data the Der input stream value, which contains one or more
     * marshaled value.
     * @param explicitTag tag number.
     * @param optional indicate if this data field is optional
     * @exception Asn1Exception if an error occurs while decoding an ASN1
     * encoded data.
     * @exception IOException if an I/O error occurs while reading encoded
     * data.
     * @return an instance of EncryptionKey.
     *
     */
    public static EncryptionKey parse(DerInputStream data, byte
                                      explicitTag, boolean optional) throws
                                      Asn1Exception, IOException {
<span class="fc bfc" id="L444" title="All 4 branches covered.">        if ((optional) &amp;&amp; (((byte)data.peekByte() &amp; (byte)0x1F) !=</span>
                           explicitTag)) {
<span class="fc" id="L446">            return null;</span>
        }
<span class="fc" id="L448">        DerValue der = data.getDerValue();</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (explicitTag != (der.getTag() &amp; (byte)0x1F))  {</span>
<span class="nc" id="L450">            throw new Asn1Exception(Krb5.ASN1_BAD_ID);</span>
        } else {
<span class="fc" id="L452">            DerValue subDer = der.getData().getDerValue();</span>
<span class="fc" id="L453">            return new EncryptionKey(subDer);</span>
        }
    }

    /**
     * Writes key value in FCC format to a &lt;code&gt;CCacheOutputStream&lt;/code&gt;.
     *
     * @param cos a &lt;code&gt;CCacheOutputStream&lt;/code&gt; to be written to.
     * @exception IOException if an I/O exception occurs.
     * @see sun.security.krb5.internal.ccache.CCacheOutputStream
     *
     */
    public synchronized void writeKey(CCacheOutputStream cos)
        throws IOException {

<span class="nc" id="L468">        cos.write16(keyType);</span>
        // we use KRB5_FCC_FVNO_3
<span class="nc" id="L470">        cos.write16(keyType); // key type is recorded twice.</span>
<span class="nc" id="L471">        cos.write32(keyValue.length);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        for (int i = 0; i &lt; keyValue.length; i++) {</span>
<span class="nc" id="L473">            cos.write8(keyValue[i]);</span>
        }
<span class="nc" id="L475">    }</span>

    public String toString() {
<span class="nc bnc" id="L478" title="All 4 branches missed.">        return new String(&quot;EncryptionKey: keyType=&quot; + keyType</span>
                          + &quot; kvno=&quot; + kvno
                          + &quot; keyValue (hex dump)=&quot;
                          + (keyValue == null || keyValue.length == 0 ?
                        &quot; Empty Key&quot; : '\n'
<span class="nc" id="L483">                        + Krb5.hexDumper.encodeBuffer(keyValue)</span>
                        + '\n'));
    }

    /**
     * Find a key with given etype
     */
    public static EncryptionKey findKey(int etype, EncryptionKey[] keys)
            throws KrbException {
<span class="fc" id="L492">        return findKey(etype, null, keys);</span>
    }

    /**
     * Determines if a kvno matches another kvno. Used in the method
     * findKey(type, kvno, keys). Always returns true if either input
     * is null or zero, in case any side does not have kvno info available.
     *
     * Note: zero is included because N/A is not a legal value for kvno
     * in javax.security.auth.kerberos.KerberosKey. Therefore, the info
     * that the kvno is N/A might be lost when converting between this
     * class and KerberosKey.
     */
    private static boolean versionMatches(Integer v1, Integer v2) {
<span class="pc bpc" id="L506" title="7 of 8 branches missed.">        if (v1 == null || v1 == 0 || v2 == null || v2 == 0) {</span>
<span class="fc" id="L507">            return true;</span>
        }
<span class="nc" id="L509">        return v1.equals(v2);</span>
    }

    /**
     * Find a key with given etype and kvno
     * @param kvno if null, return any (first?) key
     */
    public static EncryptionKey findKey(int etype, Integer kvno, EncryptionKey[] keys)
        throws KrbException {

        // check if encryption type is supported
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        if (!EType.isSupported(etype)) {</span>
<span class="nc" id="L521">            throw new KrbException(&quot;Encryption type &quot; +</span>
<span class="nc" id="L522">                EType.toString(etype) + &quot; is not supported/enabled&quot;);</span>
        }

        int ktype;
<span class="fc" id="L526">        boolean etypeFound = false;</span>

        // When no matched kvno is found, returns tke key of the same
        // etype with the highest kvno
<span class="fc" id="L530">        int kvno_found = 0;</span>
<span class="fc" id="L531">        EncryptionKey key_found = null;</span>

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L534">            ktype = keys[i].getEType();</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">            if (EType.isSupported(ktype)) {</span>
<span class="fc" id="L536">                Integer kv = keys[i].getKeyVersionNumber();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                if (etype == ktype) {</span>
<span class="fc" id="L538">                    etypeFound = true;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                    if (versionMatches(kvno, kv)) {</span>
<span class="fc" id="L540">                        return keys[i];</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                    } else if (kv &gt; kvno_found) {</span>
                        // kv is not null
<span class="nc" id="L543">                        key_found = keys[i];</span>
<span class="nc" id="L544">                        kvno_found = kv;</span>
                    }
                }
            }
        }

        // Key not found.
        // allow DES key to be used for the DES etypes
<span class="nc bnc" id="L552" title="All 4 branches missed.">        if ((etype == EncryptedData.ETYPE_DES_CBC_CRC ||</span>
            etype == EncryptedData.ETYPE_DES_CBC_MD5)) {
<span class="nc bnc" id="L554" title="All 2 branches missed.">            for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="nc" id="L555">                ktype = keys[i].getEType();</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">                if (ktype == EncryptedData.ETYPE_DES_CBC_CRC ||</span>
                        ktype == EncryptedData.ETYPE_DES_CBC_MD5) {
<span class="nc" id="L558">                    Integer kv = keys[i].getKeyVersionNumber();</span>
<span class="nc" id="L559">                    etypeFound = true;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                    if (versionMatches(kvno, kv)) {</span>
<span class="nc" id="L561">                        return new EncryptionKey(etype, keys[i].getBytes());</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    } else if (kv &gt; kvno_found) {</span>
<span class="nc" id="L563">                        key_found = new EncryptionKey(etype, keys[i].getBytes());</span>
<span class="nc" id="L564">                        kvno_found = kv;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L569" title="All 2 branches missed.">        if (etypeFound) {</span>
<span class="nc" id="L570">            return key_found;</span>
            // For compatibility, will not fail here.
            //throw new KrbException(Krb5.KRB_AP_ERR_BADKEYVER);
        }
<span class="nc" id="L574">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>