<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DateTimeTextProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.format</a> &gt; <span class="el_source">DateTimeTextProvider.java</span></div><h1>DateTimeTextProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2011-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.format;

import static java.time.temporal.ChronoField.AMPM_OF_DAY;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.ERA;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;

import java.time.chrono.Chronology;
import java.time.chrono.IsoChronology;
import java.time.chrono.JapaneseChronology;
import java.time.temporal.ChronoField;
import java.time.temporal.IsoFields;
import java.time.temporal.TemporalField;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.ResourceBundle;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import sun.util.locale.provider.CalendarDataUtility;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleResources;

/**
 * A provider to obtain the textual form of a date-time field.
 *
 * @implSpec
 * Implementations must be thread-safe.
 * Implementations should cache the textual information.
 *
 * @since 1.8
 */
class DateTimeTextProvider {

    /** Cache. */
<span class="nc" id="L106">    private static final ConcurrentMap&lt;Entry&lt;TemporalField, Locale&gt;, Object&gt; CACHE = new ConcurrentHashMap&lt;&gt;(16, 0.75f, 2);</span>
    /** Comparator. */
<span class="nc" id="L108">    private static final Comparator&lt;Entry&lt;String, Long&gt;&gt; COMPARATOR = new Comparator&lt;Entry&lt;String, Long&gt;&gt;() {</span>
        @Override
        public int compare(Entry&lt;String, Long&gt; obj1, Entry&lt;String, Long&gt; obj2) {
<span class="nc" id="L111">            return obj2.getKey().length() - obj1.getKey().length();  // longest to shortest</span>
        }
    };

<span class="nc" id="L115">    DateTimeTextProvider() {}</span>

    /**
     * Gets the provider of text.
     *
     * @return the provider, not null
     */
    static DateTimeTextProvider getInstance() {
<span class="nc" id="L123">        return new DateTimeTextProvider();</span>
    }

    /**
     * Gets the text for the specified field, locale and style
     * for the purpose of formatting.
     * &lt;p&gt;
     * The text associated with the value is returned.
     * The null return value should be used if there is no applicable text, or
     * if the text would be a numeric representation of the value.
     *
     * @param field  the field to get text for, not null
     * @param value  the field value to get text for, not null
     * @param style  the style to get text for, not null
     * @param locale  the locale to get text for, not null
     * @return the text for the field value, null if no text found
     */
    public String getText(TemporalField field, long value, TextStyle style, Locale locale) {
<span class="nc" id="L141">        Object store = findStore(field, locale);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (store instanceof LocaleStore) {</span>
<span class="nc" id="L143">            return ((LocaleStore) store).getText(value, style);</span>
        }
<span class="nc" id="L145">        return null;</span>
    }

    /**
     * Gets the text for the specified chrono, field, locale and style
     * for the purpose of formatting.
     * &lt;p&gt;
     * The text associated with the value is returned.
     * The null return value should be used if there is no applicable text, or
     * if the text would be a numeric representation of the value.
     *
     * @param chrono  the Chronology to get text for, not null
     * @param field  the field to get text for, not null
     * @param value  the field value to get text for, not null
     * @param style  the style to get text for, not null
     * @param locale  the locale to get text for, not null
     * @return the text for the field value, null if no text found
     */
    public String getText(Chronology chrono, TemporalField field, long value,
                                    TextStyle style, Locale locale) {
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if (chrono == IsoChronology.INSTANCE</span>
                || !(field instanceof ChronoField)) {
<span class="nc" id="L167">            return getText(field, value, style, locale);</span>
        }

        int fieldIndex;
        int fieldValue;
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (field == ERA) {</span>
<span class="nc" id="L173">            fieldIndex = Calendar.ERA;</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (chrono == JapaneseChronology.INSTANCE) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (value == -999) {</span>
<span class="nc" id="L176">                    fieldValue = 0;</span>
                } else {
<span class="nc" id="L178">                    fieldValue = (int) value + 2;</span>
                }
            } else {
<span class="nc" id="L181">                fieldValue = (int) value;</span>
            }
<span class="nc bnc" id="L183" title="All 2 branches missed.">        } else if (field == MONTH_OF_YEAR) {</span>
<span class="nc" id="L184">            fieldIndex = Calendar.MONTH;</span>
<span class="nc" id="L185">            fieldValue = (int) value - 1;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        } else if (field == DAY_OF_WEEK) {</span>
<span class="nc" id="L187">            fieldIndex = Calendar.DAY_OF_WEEK;</span>
<span class="nc" id="L188">            fieldValue = (int) value + 1;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (fieldValue &gt; 7) {</span>
<span class="nc" id="L190">                fieldValue = Calendar.SUNDAY;</span>
            }
<span class="nc bnc" id="L192" title="All 2 branches missed.">        } else if (field == AMPM_OF_DAY) {</span>
<span class="nc" id="L193">            fieldIndex = Calendar.AM_PM;</span>
<span class="nc" id="L194">            fieldValue = (int) value;</span>
        } else {
<span class="nc" id="L196">            return null;</span>
        }
<span class="nc" id="L198">        return CalendarDataUtility.retrieveJavaTimeFieldValueName(</span>
<span class="nc" id="L199">                chrono.getCalendarType(), fieldIndex, fieldValue, style.toCalendarStyle(), locale);</span>
    }

    /**
     * Gets an iterator of text to field for the specified field, locale and style
     * for the purpose of parsing.
     * &lt;p&gt;
     * The iterator must be returned in order from the longest text to the shortest.
     * &lt;p&gt;
     * The null return value should be used if there is no applicable parsable text, or
     * if the text would be a numeric representation of the value.
     * Text can only be parsed if all the values for that field-style-locale combination are unique.
     *
     * @param field  the field to get text for, not null
     * @param style  the style to get text for, null for all parsable text
     * @param locale  the locale to get text for, not null
     * @return the iterator of text to field pairs, in order from longest text to shortest text,
     *  null if the field or style is not parsable
     */
    public Iterator&lt;Entry&lt;String, Long&gt;&gt; getTextIterator(TemporalField field, TextStyle style, Locale locale) {
<span class="nc" id="L219">        Object store = findStore(field, locale);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (store instanceof LocaleStore) {</span>
<span class="nc" id="L221">            return ((LocaleStore) store).getTextIterator(style);</span>
        }
<span class="nc" id="L223">        return null;</span>
    }

    /**
     * Gets an iterator of text to field for the specified chrono, field, locale and style
     * for the purpose of parsing.
     * &lt;p&gt;
     * The iterator must be returned in order from the longest text to the shortest.
     * &lt;p&gt;
     * The null return value should be used if there is no applicable parsable text, or
     * if the text would be a numeric representation of the value.
     * Text can only be parsed if all the values for that field-style-locale combination are unique.
     *
     * @param chrono  the Chronology to get text for, not null
     * @param field  the field to get text for, not null
     * @param style  the style to get text for, null for all parsable text
     * @param locale  the locale to get text for, not null
     * @return the iterator of text to field pairs, in order from longest text to shortest text,
     *  null if the field or style is not parsable
     */
    public Iterator&lt;Entry&lt;String, Long&gt;&gt; getTextIterator(Chronology chrono, TemporalField field,
                                                         TextStyle style, Locale locale) {
<span class="nc bnc" id="L245" title="All 4 branches missed.">        if (chrono == IsoChronology.INSTANCE</span>
                || !(field instanceof ChronoField)) {
<span class="nc" id="L247">            return getTextIterator(field, style, locale);</span>
        }

        int fieldIndex;
<span class="nc bnc" id="L251" title="All 5 branches missed.">        switch ((ChronoField)field) {</span>
        case ERA:
<span class="nc" id="L253">            fieldIndex = Calendar.ERA;</span>
<span class="nc" id="L254">            break;</span>
        case MONTH_OF_YEAR:
<span class="nc" id="L256">            fieldIndex = Calendar.MONTH;</span>
<span class="nc" id="L257">            break;</span>
        case DAY_OF_WEEK:
<span class="nc" id="L259">            fieldIndex = Calendar.DAY_OF_WEEK;</span>
<span class="nc" id="L260">            break;</span>
        case AMPM_OF_DAY:
<span class="nc" id="L262">            fieldIndex = Calendar.AM_PM;</span>
<span class="nc" id="L263">            break;</span>
        default:
<span class="nc" id="L265">            return null;</span>
        }

<span class="nc bnc" id="L268" title="All 2 branches missed.">        int calendarStyle = (style == null) ? Calendar.ALL_STYLES : style.toCalendarStyle();</span>
<span class="nc" id="L269">        Map&lt;String, Integer&gt; map = CalendarDataUtility.retrieveJavaTimeFieldValueNames(</span>
<span class="nc" id="L270">                chrono.getCalendarType(), fieldIndex, calendarStyle, locale);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L272">            return null;</span>
        }
<span class="nc" id="L274">        List&lt;Entry&lt;String, Long&gt;&gt; list = new ArrayList&lt;&gt;(map.size());</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">        switch (fieldIndex) {</span>
        case Calendar.ERA:
<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L278">                int era = entry.getValue();</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                if (chrono == JapaneseChronology.INSTANCE) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                    if (era == 0) {</span>
<span class="nc" id="L281">                        era = -999;</span>
                    } else {
<span class="nc" id="L283">                        era -= 2;</span>
                    }
                }
<span class="nc" id="L286">                list.add(createEntry(entry.getKey(), (long)era));</span>
<span class="nc" id="L287">            }</span>
<span class="nc" id="L288">            break;</span>
        case Calendar.MONTH:
<span class="nc bnc" id="L290" title="All 2 branches missed.">            for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L291">                list.add(createEntry(entry.getKey(), (long)(entry.getValue() + 1)));</span>
<span class="nc" id="L292">            }</span>
<span class="nc" id="L293">            break;</span>
        case Calendar.DAY_OF_WEEK:
<span class="nc bnc" id="L295" title="All 2 branches missed.">            for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L296">                list.add(createEntry(entry.getKey(), (long)toWeekDay(entry.getValue())));</span>
<span class="nc" id="L297">            }</span>
<span class="nc" id="L298">            break;</span>
        default:
<span class="nc bnc" id="L300" title="All 2 branches missed.">            for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L301">                list.add(createEntry(entry.getKey(), (long)entry.getValue()));</span>
<span class="nc" id="L302">            }</span>
            break;
        }
<span class="nc" id="L305">        return list.iterator();</span>
    }

    private Object findStore(TemporalField field, Locale locale) {
<span class="nc" id="L309">        Entry&lt;TemporalField, Locale&gt; key = createEntry(field, locale);</span>
<span class="nc" id="L310">        Object store = CACHE.get(key);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (store == null) {</span>
<span class="nc" id="L312">            store = createStore(field, locale);</span>
<span class="nc" id="L313">            CACHE.putIfAbsent(key, store);</span>
<span class="nc" id="L314">            store = CACHE.get(key);</span>
        }
<span class="nc" id="L316">        return store;</span>
    }

    private static int toWeekDay(int calWeekDay) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (calWeekDay == Calendar.SUNDAY) {</span>
<span class="nc" id="L321">            return 7;</span>
        } else {
<span class="nc" id="L323">            return calWeekDay - 1;</span>
        }
    }

    private Object createStore(TemporalField field, Locale locale) {
<span class="nc" id="L328">        Map&lt;TextStyle, Map&lt;Long, String&gt;&gt; styleMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (field == ERA) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            for (TextStyle textStyle : TextStyle.values()) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                if (textStyle.isStandalone()) {</span>
                    // Stand-alone isn't applicable to era names.
<span class="nc" id="L333">                    continue;</span>
                }
<span class="nc" id="L335">                Map&lt;String, Integer&gt; displayNames = CalendarDataUtility.retrieveJavaTimeFieldValueNames(</span>
<span class="nc" id="L336">                        &quot;gregory&quot;, Calendar.ERA, textStyle.toCalendarStyle(), locale);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                if (displayNames != null) {</span>
<span class="nc" id="L338">                    Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                    for (Entry&lt;String, Integer&gt; entry : displayNames.entrySet()) {</span>
<span class="nc" id="L340">                        map.put((long) entry.getValue(), entry.getKey());</span>
<span class="nc" id="L341">                    }</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                    if (!map.isEmpty()) {</span>
<span class="nc" id="L343">                        styleMap.put(textStyle, map);</span>
                    }
                }
            }
<span class="nc" id="L347">            return new LocaleStore(styleMap);</span>
        }

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (field == MONTH_OF_YEAR) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            for (TextStyle textStyle : TextStyle.values()) {</span>
<span class="nc" id="L352">                Map&lt;String, Integer&gt; displayNames = CalendarDataUtility.retrieveJavaTimeFieldValueNames(</span>
<span class="nc" id="L353">                        &quot;gregory&quot;, Calendar.MONTH, textStyle.toCalendarStyle(), locale);</span>
<span class="nc" id="L354">                Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                if (displayNames != null) {</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">                    for (Entry&lt;String, Integer&gt; entry : displayNames.entrySet()) {</span>
<span class="nc" id="L357">                        map.put((long) (entry.getValue() + 1), entry.getKey());</span>
<span class="nc" id="L358">                    }</span>

                } else {
                    // Narrow names may have duplicated names, such as &quot;J&quot; for January, Jun, July.
                    // Get names one by one in that case.
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    for (int month = Calendar.JANUARY; month &lt;= Calendar.DECEMBER; month++) {</span>
                        String name;
<span class="nc" id="L365">                        name = CalendarDataUtility.retrieveJavaTimeFieldValueName(</span>
<span class="nc" id="L366">                                &quot;gregory&quot;, Calendar.MONTH, month, textStyle.toCalendarStyle(), locale);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                        if (name == null) {</span>
<span class="nc" id="L368">                            break;</span>
                        }
<span class="nc" id="L370">                        map.put((long) (month + 1), name);</span>
                    }
                }
<span class="nc bnc" id="L373" title="All 2 branches missed.">                if (!map.isEmpty()) {</span>
<span class="nc" id="L374">                    styleMap.put(textStyle, map);</span>
                }
            }
<span class="nc" id="L377">            return new LocaleStore(styleMap);</span>
        }

<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (field == DAY_OF_WEEK) {</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            for (TextStyle textStyle : TextStyle.values()) {</span>
<span class="nc" id="L382">                Map&lt;String, Integer&gt; displayNames = CalendarDataUtility.retrieveJavaTimeFieldValueNames(</span>
<span class="nc" id="L383">                        &quot;gregory&quot;, Calendar.DAY_OF_WEEK, textStyle.toCalendarStyle(), locale);</span>
<span class="nc" id="L384">                Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (displayNames != null) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    for (Entry&lt;String, Integer&gt; entry : displayNames.entrySet()) {</span>
<span class="nc" id="L387">                        map.put((long)toWeekDay(entry.getValue()), entry.getKey());</span>
<span class="nc" id="L388">                    }</span>

                } else {
                    // Narrow names may have duplicated names, such as &quot;S&quot; for Sunday and Saturday.
                    // Get names one by one in that case.
<span class="nc bnc" id="L393" title="All 2 branches missed.">                    for (int wday = Calendar.SUNDAY; wday &lt;= Calendar.SATURDAY; wday++) {</span>
                        String name;
<span class="nc" id="L395">                        name = CalendarDataUtility.retrieveJavaTimeFieldValueName(</span>
<span class="nc" id="L396">                            &quot;gregory&quot;, Calendar.DAY_OF_WEEK, wday, textStyle.toCalendarStyle(), locale);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                        if (name == null) {</span>
<span class="nc" id="L398">                            break;</span>
                        }
<span class="nc" id="L400">                        map.put((long)toWeekDay(wday), name);</span>
                    }
                }
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (!map.isEmpty()) {</span>
<span class="nc" id="L404">                    styleMap.put(textStyle, map);</span>
                }
            }
<span class="nc" id="L407">            return new LocaleStore(styleMap);</span>
        }

<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (field == AMPM_OF_DAY) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            for (TextStyle textStyle : TextStyle.values()) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (textStyle.isStandalone()) {</span>
                    // Stand-alone isn't applicable to AM/PM.
<span class="nc" id="L414">                    continue;</span>
                }
<span class="nc" id="L416">                Map&lt;String, Integer&gt; displayNames = CalendarDataUtility.retrieveJavaTimeFieldValueNames(</span>
<span class="nc" id="L417">                        &quot;gregory&quot;, Calendar.AM_PM, textStyle.toCalendarStyle(), locale);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if (displayNames != null) {</span>
<span class="nc" id="L419">                    Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                    for (Entry&lt;String, Integer&gt; entry : displayNames.entrySet()) {</span>
<span class="nc" id="L421">                        map.put((long) entry.getValue(), entry.getKey());</span>
<span class="nc" id="L422">                    }</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                    if (!map.isEmpty()) {</span>
<span class="nc" id="L424">                        styleMap.put(textStyle, map);</span>
                    }
                }
            }
<span class="nc" id="L428">            return new LocaleStore(styleMap);</span>
        }

<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (field == IsoFields.QUARTER_OF_YEAR) {</span>
            // The order of keys must correspond to the TextStyle.values() order.
<span class="nc" id="L433">            final String[] keys = {</span>
                &quot;QuarterNames&quot;,
                &quot;standalone.QuarterNames&quot;,
                &quot;QuarterAbbreviations&quot;,
                &quot;standalone.QuarterAbbreviations&quot;,
                &quot;QuarterNarrows&quot;,
                &quot;standalone.QuarterNarrows&quot;,
            };
<span class="nc bnc" id="L441" title="All 2 branches missed.">            for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="nc" id="L442">                String[] names = getLocalizedResource(keys[i], locale);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if (names != null) {</span>
<span class="nc" id="L444">                    Map&lt;Long, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                    for (int q = 0; q &lt; names.length; q++) {</span>
<span class="nc" id="L446">                        map.put((long) (q + 1), names[q]);</span>
                    }
<span class="nc" id="L448">                    styleMap.put(TextStyle.values()[i], map);</span>
                }
            }
<span class="nc" id="L451">            return new LocaleStore(styleMap);</span>
        }

<span class="nc" id="L454">        return &quot;&quot;;  // null marker for map</span>
    }

    /**
     * Helper method to create an immutable entry.
     *
     * @param text  the text, not null
     * @param field  the field, not null
     * @return the entry, not null
     */
    private static &lt;A, B&gt; Entry&lt;A, B&gt; createEntry(A text, B field) {
<span class="nc" id="L465">        return new SimpleImmutableEntry&lt;&gt;(text, field);</span>
    }

    /**
     * Returns the localized resource of the given key and locale, or null
     * if no localized resource is available.
     *
     * @param key  the key of the localized resource, not null
     * @param locale  the locale, not null
     * @return the localized resource, or null if not available
     * @throws NullPointerException if key or locale is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; T getLocalizedResource(String key, Locale locale) {
<span class="nc" id="L479">        LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased()</span>
<span class="nc" id="L480">                                    .getLocaleResources(locale);</span>
<span class="nc" id="L481">        ResourceBundle rb = lr.getJavaTimeFormatData();</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        return rb.containsKey(key) ? (T) rb.getObject(key) : null;</span>
    }

    /**
     * Stores the text for a single locale.
     * &lt;p&gt;
     * Some fields have a textual representation, such as day-of-week or month-of-year.
     * These textual representations can be captured in this class for printing
     * and parsing.
     * &lt;p&gt;
     * This class is immutable and thread-safe.
     */
    static final class LocaleStore {
        /**
         * Map of value to text.
         */
        private final Map&lt;TextStyle, Map&lt;Long, String&gt;&gt; valueTextMap;
        /**
         * Parsable data.
         */
        private final Map&lt;TextStyle, List&lt;Entry&lt;String, Long&gt;&gt;&gt; parsable;

        /**
         * Constructor.
         *
         * @param valueTextMap  the map of values to text to store, assigned and not altered, not null
         */
<span class="nc" id="L509">        LocaleStore(Map&lt;TextStyle, Map&lt;Long, String&gt;&gt; valueTextMap) {</span>
<span class="nc" id="L510">            this.valueTextMap = valueTextMap;</span>
<span class="nc" id="L511">            Map&lt;TextStyle, List&lt;Entry&lt;String, Long&gt;&gt;&gt; map = new HashMap&lt;&gt;();</span>
<span class="nc" id="L512">            List&lt;Entry&lt;String, Long&gt;&gt; allList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            for (Map.Entry&lt;TextStyle, Map&lt;Long, String&gt;&gt; vtmEntry : valueTextMap.entrySet()) {</span>
<span class="nc" id="L514">                Map&lt;String, Entry&lt;String, Long&gt;&gt; reverse = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                for (Map.Entry&lt;Long, String&gt; entry : vtmEntry.getValue().entrySet()) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                    if (reverse.put(entry.getValue(), createEntry(entry.getValue(), entry.getKey())) != null) {</span>
                        // TODO: BUG: this has no effect
<span class="nc" id="L518">                        continue;  // not parsable, try next style</span>
                    }
<span class="nc" id="L520">                }</span>
<span class="nc" id="L521">                List&lt;Entry&lt;String, Long&gt;&gt; list = new ArrayList&lt;&gt;(reverse.values());</span>
<span class="nc" id="L522">                Collections.sort(list, COMPARATOR);</span>
<span class="nc" id="L523">                map.put(vtmEntry.getKey(), list);</span>
<span class="nc" id="L524">                allList.addAll(list);</span>
<span class="nc" id="L525">                map.put(null, allList);</span>
<span class="nc" id="L526">            }</span>
<span class="nc" id="L527">            Collections.sort(allList, COMPARATOR);</span>
<span class="nc" id="L528">            this.parsable = map;</span>
<span class="nc" id="L529">        }</span>

        /**
         * Gets the text for the specified field value, locale and style
         * for the purpose of printing.
         *
         * @param value  the value to get text for, not null
         * @param style  the style to get text for, not null
         * @return the text for the field value, null if no text found
         */
        String getText(long value, TextStyle style) {
<span class="nc" id="L540">            Map&lt;Long, String&gt; map = valueTextMap.get(style);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            return map != null ? map.get(value) : null;</span>
        }

        /**
         * Gets an iterator of text to field for the specified style for the purpose of parsing.
         * &lt;p&gt;
         * The iterator must be returned in order from the longest text to the shortest.
         *
         * @param style  the style to get text for, null for all parsable text
         * @return the iterator of text to field pairs, in order from longest text to shortest text,
         *  null if the style is not parsable
         */
        Iterator&lt;Entry&lt;String, Long&gt;&gt; getTextIterator(TextStyle style) {
<span class="nc" id="L554">            List&lt;Entry&lt;String, Long&gt;&gt; list = parsable.get(style);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            return list != null ? list.iterator() : null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>