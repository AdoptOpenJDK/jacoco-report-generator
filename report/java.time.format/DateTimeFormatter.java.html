<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DateTimeFormatter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.format</a> &gt; <span class="el_source">DateTimeFormatter.java</span></div><h1>DateTimeFormatter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.format;

import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.DAY_OF_WEEK;
import static java.time.temporal.ChronoField.DAY_OF_YEAR;
import static java.time.temporal.ChronoField.HOUR_OF_DAY;
import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.NANO_OF_SECOND;
import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
import static java.time.temporal.ChronoField.YEAR;

import java.io.IOException;
import java.text.FieldPosition;
import java.text.Format;
import java.text.ParseException;
import java.text.ParsePosition;
import java.time.DateTimeException;
import java.time.Period;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.chrono.Chronology;
import java.time.chrono.IsoChronology;
import java.time.format.DateTimeFormatterBuilder.CompositePrinterParser;
import java.time.temporal.ChronoField;
import java.time.temporal.IsoFields;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalField;
import java.time.temporal.TemporalQuery;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/**
 * Formatter for printing and parsing date-time objects.
 * &lt;p&gt;
 * This class provides the main application entry point for printing and parsing
 * and provides common implementations of {@code DateTimeFormatter}:
 * &lt;ul&gt;
 * &lt;li&gt;Using predefined constants, such as {@link #ISO_LOCAL_DATE}&lt;/li&gt;
 * &lt;li&gt;Using pattern letters, such as {@code uuuu-MMM-dd}&lt;/li&gt;
 * &lt;li&gt;Using localized styles, such as {@code long} or {@code medium}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * More complex formatters are provided by
 * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.
 *
 * &lt;p&gt;
 * The main date-time classes provide two methods - one for formatting,
 * {@code format(DateTimeFormatter formatter)}, and one for parsing,
 * {@code parse(CharSequence text, DateTimeFormatter formatter)}.
 * &lt;p&gt;For example:
 * &lt;blockquote&gt;&lt;pre&gt;
 *  String text = date.toString(formatter);
 *  LocalDate date = LocalDate.parse(text, formatter);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * In addition to the format, formatters can be created with desired Locale,
 * Chronology, ZoneId, and DecimalStyle.
 * &lt;p&gt;
 * The {@link #withLocale withLocale} method returns a new formatter that
 * overrides the locale. The locale affects some aspects of formatting and
 * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a
 * formatter that uses the locale specific date format.
 * &lt;p&gt;
 * The {@link #withChronology withChronology} method returns a new formatter
 * that overrides the chronology. If overridden, the date-time value is
 * converted to the chronology before formatting. During parsing the date-time
 * value is converted to the chronology before it is returned.
 * &lt;p&gt;
 * The {@link #withZone withZone} method returns a new formatter that overrides
 * the zone. If overridden, the date-time value is converted to a ZonedDateTime
 * with the requested ZoneId before formatting. During parsing the ZoneId is
 * applied before the value is returned.
 * &lt;p&gt;
 * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that
 * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for
 * formatting and parsing.
 * &lt;p&gt;
 * Some applications may need to use the older {@link Format java.text.Format}
 * class for formatting. The {@link #toFormat()} method returns an
 * implementation of {@code java.text.Format}.
 *
 * &lt;h3 id=&quot;predefined&quot;&gt;Predefined Formatters&lt;/h3&gt;
 * &lt;table summary=&quot;Predefined Formatters&quot; cellpadding=&quot;2&quot; cellspacing=&quot;3&quot; border=&quot;0&quot; &gt;
 * &lt;thead&gt;
 * &lt;tr class=&quot;tableSubHeadingColor&quot;&gt;
 * &lt;th class=&quot;colFirst&quot; align=&quot;left&quot;&gt;Formatter&lt;/th&gt;
 * &lt;th class=&quot;colFirst&quot; align=&quot;left&quot;&gt;Description&lt;/th&gt;
 * &lt;th class=&quot;colLast&quot; align=&quot;left&quot;&gt;Example&lt;/th&gt;
 * &lt;/tr&gt;
 * &lt;/thead&gt;
 * &lt;tbody&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt;{@link #ofLocalizedDate ofLocalizedDate(dateStyle)} &lt;/td&gt;
 * &lt;td&gt; Formatter with date style from the locale &lt;/td&gt;
 * &lt;td&gt; '2011-12-03'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} &lt;/td&gt;
 * &lt;td&gt; Formatter with time style from the locale &lt;/td&gt;
 * &lt;td&gt; '10:15:30'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} &lt;/td&gt;
 * &lt;td&gt; Formatter with a style for date and time from the locale&lt;/td&gt;
 * &lt;td&gt; '3 Jun 2008 11:05:30'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}
 * &lt;/td&gt;
 * &lt;td&gt; Formatter with date and time styles from the locale &lt;/td&gt;
 * &lt;td&gt; '3 Jun 2008 11:05'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #BASIC_ISO_DATE}&lt;/td&gt;
 * &lt;td&gt;Basic ISO date &lt;/td&gt; &lt;td&gt;'20111203'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_LOCAL_DATE}&lt;/td&gt;
 * &lt;td&gt; ISO Local Date &lt;/td&gt;
 * &lt;td&gt;'2011-12-03'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_OFFSET_DATE}&lt;/td&gt;
 * &lt;td&gt; ISO Date with offset &lt;/td&gt;
 * &lt;td&gt;'2011-12-03+01:00'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_DATE}&lt;/td&gt;
 * &lt;td&gt; ISO Date with or without offset &lt;/td&gt;
 * &lt;td&gt; '2011-12-03+01:00'; '2011-12-03'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_LOCAL_TIME}&lt;/td&gt;
 * &lt;td&gt; Time without offset &lt;/td&gt;
 * &lt;td&gt;'10:15:30'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_OFFSET_TIME}&lt;/td&gt;
 * &lt;td&gt; Time with offset &lt;/td&gt;
 * &lt;td&gt;'10:15:30+01:00'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_TIME}&lt;/td&gt;
 * &lt;td&gt; Time with or without offset &lt;/td&gt;
 * &lt;td&gt;'10:15:30+01:00'; '10:15:30'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_LOCAL_DATE_TIME}&lt;/td&gt;
 * &lt;td&gt; ISO Local Date and Time &lt;/td&gt;
 * &lt;td&gt;'2011-12-03T10:15:30'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_OFFSET_DATE_TIME}&lt;/td&gt;
 * &lt;td&gt; Date Time with Offset
 * &lt;/td&gt;&lt;td&gt;2011-12-03T10:15:30+01:00'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_ZONED_DATE_TIME}&lt;/td&gt;
 * &lt;td&gt; Zoned Date Time &lt;/td&gt;
 * &lt;td&gt;'2011-12-03T10:15:30+01:00[Europe/Paris]'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_DATE_TIME}&lt;/td&gt;
 * &lt;td&gt; Date and time with ZoneId &lt;/td&gt;
 * &lt;td&gt;'2011-12-03T10:15:30+01:00[Europe/Paris]'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_ORDINAL_DATE}&lt;/td&gt;
 * &lt;td&gt; Year and day of year &lt;/td&gt;
 * &lt;td&gt;'2012-337'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_WEEK_DATE}&lt;/td&gt;
 * &lt;td&gt; Year and Week &lt;/td&gt;
 * &lt;td&gt;2012-W48-6'&lt;/td&gt;&lt;/tr&gt;
 * &lt;tr class=&quot;altColor&quot;&gt;
 * &lt;td&gt; {@link #ISO_INSTANT}&lt;/td&gt;
 * &lt;td&gt; Date and Time of an Instant &lt;/td&gt;
 * &lt;td&gt;'2011-12-03T10:15:30Z' &lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;tr class=&quot;rowColor&quot;&gt;
 * &lt;td&gt; {@link #RFC_1123_DATE_TIME}&lt;/td&gt;
 * &lt;td&gt; RFC 1123 / RFC 822 &lt;/td&gt;
 * &lt;td&gt;'Tue, 3 Jun 2008 11:05:30 GMT'&lt;/td&gt;
 * &lt;/tr&gt;
 * &lt;/tbody&gt;
 * &lt;/table&gt;
 *
 * &lt;h3 id=&quot;patterns&quot;&gt;Patterns for Formatting and Parsing&lt;/h3&gt;
 * Patterns are based on a simple sequence of letters and symbols.
 * A pattern is used to create a Formatter using the
 * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
 * For example,
 * {@code &quot;d MMM uuuu&quot;} will format 2011-12-03 as '3&amp;nbsp;Dec&amp;nbsp;2011'.
 * A formatter created from a pattern can be used as many times as necessary,
 * it is immutable and is thread-safe.
 * &lt;p&gt;
 * For example:
 * &lt;blockquote&gt;&lt;pre&gt;
 *  DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd&quot;);
 *  String text = date.toString(formatter);
 *  LocalDate date = LocalDate.parse(text, formatter);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;
 * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The
 * following pattern letters are defined:
 * &lt;pre&gt;
 *  Symbol  Meaning                     Presentation      Examples
 *  ------  -------                     ------------      -------
 *   G       era                         text              AD; Anno Domini; A
 *   u       year                        year              2004; 04
 *   y       year-of-era                 year              2004; 04
 *   D       day-of-year                 number            189
 *   M/L     month-of-year               number/text       7; 07; Jul; July; J
 *   d       day-of-month                number            10
 *
 *   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
 *   Y       week-based-year             year              1996; 96
 *   w       week-of-week-based-year     number            27
 *   W       week-of-month               number            4
 *   E       day-of-week                 text              Tue; Tuesday; T
 *   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
 *   F       week-of-month               number            3
 *
 *   a       am-pm-of-day                text              PM
 *   h       clock-hour-of-am-pm (1-12)  number            12
 *   K       hour-of-am-pm (0-11)        number            0
 *   k       clock-hour-of-am-pm (1-24)  number            0
 *
 *   H       hour-of-day (0-23)          number            0
 *   m       minute-of-hour              number            30
 *   s       second-of-minute            number            55
 *   S       fraction-of-second          fraction          978
 *   A       milli-of-day                number            1234
 *   n       nano-of-second              number            987654321
 *   N       nano-of-day                 number            1234000000
 *
 *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
 *   z       time-zone name              zone-name         Pacific Standard Time; PST
 *   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
 *   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
 *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
 *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;
 *
 *   p       pad next                    pad modifier      1
 *
 *   '       escape for text             delimiter
 *   ''      single quote                literal           '
 *   [       optional section start
 *   ]       optional section end
 *   #       reserved for future use
 *   {       reserved for future use
 *   }       reserved for future use
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The count of pattern letters determines the format.
 * &lt;p&gt;
 * &lt;b&gt;Text&lt;/b&gt;: The text style is determined based on the number of pattern
 * letters used. Less than 4 pattern letters will use the
 * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the
 * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the
 * {@link TextStyle#NARROW narrow form}.
 * Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles.
 * &lt;p&gt;
 * &lt;b&gt;Number&lt;/b&gt;: If the count of letters is one, then the value is output using
 * the minimum number of digits and without padding. Otherwise, the count of digits
 * is used as the width of the output field, with the value zero-padded as necessary.
 * The following pattern letters have constraints on the count of letters.
 * Only one letter of 'c' and 'F' can be specified.
 * Up to two letters of 'd', 'H', 'h', 'K', 'k', 'm', and 's' can be specified.
 * Up to three letters of 'D' can be specified.
 * &lt;p&gt;
 * &lt;b&gt;Number/Text&lt;/b&gt;: If the count of pattern letters is 3 or greater, use the
 * Text rules above. Otherwise use the Number rules above.
 * &lt;p&gt;
 * &lt;b&gt;Fraction&lt;/b&gt;: Outputs the nano-of-second field as a fraction-of-second.
 * The nano-of-second value has nine digits, thus the count of pattern letters
 * is from 1 to 9. If it is less than 9, then the nano-of-second value is
 * truncated, with only the most significant digits being output. When parsing
 * in strict mode, the number of parsed digits must match the count of pattern
 * letters. When parsing in lenient mode, the number of parsed digits must be at
 * least the count of pattern letters, up to 9 digits.
 * &lt;p&gt;
 * &lt;b&gt;Year&lt;/b&gt;: The count of letters determines the minimum field width below
 * which padding is used. If the count of letters is two, then a
 * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is
 * used. For printing, this outputs the rightmost two digits. For parsing, this
 * will parse using the base value of 2000, resulting in a year within the range
 * 2000 to 2099 inclusive. If the count of letters is less than four (but not
 * two), then the sign is only output for negative years as per
 * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is
 * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.
 * &lt;p&gt;
 * &lt;b&gt;ZoneId&lt;/b&gt;: This outputs the time-zone ID, such as 'Europe/Paris'. If the
 * count of letters is two, then the time-zone ID is output. Any other count of
 * letters throws {@code IllegalArgumentException}.
 * &lt;p&gt;
 * &lt;b&gt;Zone names&lt;/b&gt;: This outputs the display name of the time-zone ID. If the
 * count of letters is one, two or three, then the short name is output. If the
 * count of letters is four, then the full name is output. Five or more letters
 * throws {@code IllegalArgumentException}.
 * &lt;p&gt;
 * &lt;b&gt;Offset X and x&lt;/b&gt;: This formats the offset based on the number of pattern
 * letters. One letter outputs just the hour, such as '+01', unless the minute
 * is non-zero in which case the minute is also output, such as '+0130'. Two
 * letters outputs the hour and minute, without a colon, such as '+0130'. Three
 * letters outputs the hour and minute, with a colon, such as '+01:30'. Four
 * letters outputs the hour and minute and optional second, without a colon,
 * such as '+013015'. Five letters outputs the hour and minute and optional
 * second, with a colon, such as '+01:30:15'. Six or more letters throws
 * {@code IllegalArgumentException}. Pattern letter 'X' (upper case) will output
 * 'Z' when the offset to be output would be zero, whereas pattern letter 'x'
 * (lower case) will output '+00', '+0000', or '+00:00'.
 * &lt;p&gt;
 * &lt;b&gt;Offset O&lt;/b&gt;: This formats the localized offset based on the number of
 * pattern letters. One letter outputs the {@linkplain TextStyle#SHORT short}
 * form of the localized offset, which is localized offset text, such as 'GMT',
 * with hour without leading zero, optional 2-digit minute and second if
 * non-zero, and colon, for example 'GMT+8'. Four letters outputs the
 * {@linkplain TextStyle#FULL full} form, which is localized offset text,
 * such as 'GMT, with 2-digit hour and minute field, optional second field
 * if non-zero, and colon, for example 'GMT+08:00'. Any other count of letters
 * throws {@code IllegalArgumentException}.
 * &lt;p&gt;
 * &lt;b&gt;Offset Z&lt;/b&gt;: This formats the offset based on the number of pattern
 * letters. One, two or three letters outputs the hour and minute, without a
 * colon, such as '+0130'. The output will be '+0000' when the offset is zero.
 * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
 * offset, equivalent to four letters of Offset-O. The output will be the
 * corresponding localized offset text if the offset is zero. Five
 * letters outputs the hour, minute, with optional second if non-zero, with
 * colon. It outputs 'Z' if the offset is zero.
 * Six or more letters throws {@code IllegalArgumentException}.
 * &lt;p&gt;
 * &lt;b&gt;Optional section&lt;/b&gt;: The optional section markers work exactly like
 * calling {@link DateTimeFormatterBuilder#optionalStart()} and
 * {@link DateTimeFormatterBuilder#optionalEnd()}.
 * &lt;p&gt;
 * &lt;b&gt;Pad modifier&lt;/b&gt;: Modifies the pattern that immediately follows to be
 * padded with spaces. The pad width is determined by the number of pattern
 * letters. This is the same as calling
 * {@link DateTimeFormatterBuilder#padNext(int)}.
 * &lt;p&gt;
 * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to
 * a width of 2.
 * &lt;p&gt;
 * Any unrecognized letter is an error. Any non-letter character, other than
 * '[', ']', '{', '}', '#' and the single quote will be output directly.
 * Despite this, it is recommended to use single quotes around all characters
 * that you want to output directly to ensure that future changes do not break
 * your application.
 *
 * &lt;h3 id=&quot;resolving&quot;&gt;Resolving&lt;/h3&gt;
 * Parsing is implemented as a two-phase operation.
 * First, the text is parsed using the layout defined by the formatter, producing
 * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
 * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
 * simplifying the various fields into more useful ones.
 * &lt;p&gt;
 * Five parsing methods are supplied by this class.
 * Four of these perform both the parse and resolve phases.
 * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},
 * only performs the first phase, leaving the result unresolved.
 * As such, it is essentially a low-level operation.
 * &lt;p&gt;
 * The resolve phase is controlled by two parameters, set on this class.
 * &lt;p&gt;
 * The {@link ResolverStyle} is an enum that offers three different approaches,
 * strict, smart and lenient. The smart option is the default.
 * It can be set using {@link #withResolverStyle(ResolverStyle)}.
 * &lt;p&gt;
 * The {@link #withResolverFields(TemporalField...)} parameter allows the
 * set of fields that will be resolved to be filtered before resolving starts.
 * For example, if the formatter has parsed a year, month, day-of-month
 * and day-of-year, then there are two approaches to resolve a date:
 * (year + month + day-of-month) and (year + day-of-year).
 * The resolver fields allows one of the two approaches to be selected.
 * If no resolver fields are set then both approaches must result in the same date.
 * &lt;p&gt;
 * Resolving separate fields to form a complete date and time is a complex
 * process with behaviour distributed across a number of classes.
 * It follows these steps:
 * &lt;ol&gt;
 * &lt;li&gt;The chronology is determined.
 * The chronology of the result is either the chronology that was parsed,
 * or if no chronology was parsed, it is the chronology set on this class,
 * or if that is null, it is {@code IsoChronology}.
 * &lt;li&gt;The {@code ChronoField} date fields are resolved.
 * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.
 * Documentation about field resolution is located in the implementation
 * of {@code Chronology}.
 * &lt;li&gt;The {@code ChronoField} time fields are resolved.
 * This is documented on {@link ChronoField} and is the same for all chronologies.
 * &lt;li&gt;Any fields that are not {@code ChronoField} are processed.
 * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.
 * Documentation about field resolution is located in the implementation
 * of {@code TemporalField}.
 * &lt;li&gt;The {@code ChronoField} date and time fields are re-resolved.
 * This allows fields in step four to produce {@code ChronoField} values
 * and have them be processed into dates and times.
 * &lt;li&gt;A {@code LocalTime} is formed if there is at least an hour-of-day available.
 * This involves providing default values for minute, second and fraction of second.
 * &lt;li&gt;Any remaining unresolved fields are cross-checked against any
 * date and/or time that was resolved. Thus, an earlier stage would resolve
 * (year + month + day-of-month) to a date, and this stage would check that
 * day-of-week was valid for the date.
 * &lt;li&gt;If an {@linkplain #parsedExcessDays() excess number of days}
 * was parsed then it is added to the date if a date is available.
 * &lt;/ol&gt;
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class DateTimeFormatter {

    /**
     * The printer and/or parser to use, not null.
     */
    private final CompositePrinterParser printerParser;
    /**
     * The locale to use for formatting, not null.
     */
    private final Locale locale;
    /**
     * The symbols to use for formatting, not null.
     */
    private final DecimalStyle decimalStyle;
    /**
     * The resolver style to use, not null.
     */
    private final ResolverStyle resolverStyle;
    /**
     * The fields to use in resolving, null for all fields.
     */
    private final Set&lt;TemporalField&gt; resolverFields;
    /**
     * The chronology to use for formatting, null for no override.
     */
    private final Chronology chrono;
    /**
     * The zone to use for formatting, null for no override.
     */
    private final ZoneId zone;

    //-----------------------------------------------------------------------
    /**
     * Creates a formatter using the specified pattern.
     * &lt;p&gt;
     * This method will create a formatter based on a simple
     * &lt;a href=&quot;#patterns&quot;&gt;pattern of letters and symbols&lt;/a&gt;
     * as described in the class documentation.
     * For example, {@code d MMM uuuu} will format 2011-12-03 as '3 Dec 2011'.
     * &lt;p&gt;
     * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter
     * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param pattern  the pattern to use, not null
     * @return the formatter based on the pattern, not null
     * @throws IllegalArgumentException if the pattern is invalid
     * @see DateTimeFormatterBuilder#appendPattern(String)
     */
    public static DateTimeFormatter ofPattern(String pattern) {
<span class="nc" id="L537">        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();</span>
    }

    /**
     * Creates a formatter using the specified pattern and locale.
     * &lt;p&gt;
     * This method will create a formatter based on a simple
     * &lt;a href=&quot;#patterns&quot;&gt;pattern of letters and symbols&lt;/a&gt;
     * as described in the class documentation.
     * For example, {@code d MMM uuuu} will format 2011-12-03 as '3 Dec 2011'.
     * &lt;p&gt;
     * The formatter will use the specified locale.
     * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param pattern  the pattern to use, not null
     * @param locale  the locale to use, not null
     * @return the formatter based on the pattern, not null
     * @throws IllegalArgumentException if the pattern is invalid
     * @see DateTimeFormatterBuilder#appendPattern(String)
     */
    public static DateTimeFormatter ofPattern(String pattern, Locale locale) {
<span class="nc" id="L561">        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a locale specific date format for the ISO chronology.
     * &lt;p&gt;
     * This returns a formatter that will format or parse a date.
     * The exact format pattern used varies by locale.
     * &lt;p&gt;
     * The locale is determined from the formatter. The formatter returned directly by
     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
     * on the result of this method.
     * &lt;p&gt;
     * Note that the localized pattern is looked up lazily.
     * This {@code DateTimeFormatter} holds the style required and the locale,
     * looking up the pattern required on demand.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param dateStyle  the formatter style to obtain, not null
     * @return the date formatter, not null
     */
    public static DateTimeFormatter ofLocalizedDate(FormatStyle dateStyle) {
<span class="nc" id="L588">        Objects.requireNonNull(dateStyle, &quot;dateStyle&quot;);</span>
<span class="nc" id="L589">        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, null)</span>
<span class="nc" id="L590">                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);</span>
    }

    /**
     * Returns a locale specific time format for the ISO chronology.
     * &lt;p&gt;
     * This returns a formatter that will format or parse a time.
     * The exact format pattern used varies by locale.
     * &lt;p&gt;
     * The locale is determined from the formatter. The formatter returned directly by
     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
     * on the result of this method.
     * &lt;p&gt;
     * Note that the localized pattern is looked up lazily.
     * This {@code DateTimeFormatter} holds the style required and the locale,
     * looking up the pattern required on demand.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param timeStyle  the formatter style to obtain, not null
     * @return the time formatter, not null
     */
    public static DateTimeFormatter ofLocalizedTime(FormatStyle timeStyle) {
<span class="nc" id="L616">        Objects.requireNonNull(timeStyle, &quot;timeStyle&quot;);</span>
<span class="nc" id="L617">        return new DateTimeFormatterBuilder().appendLocalized(null, timeStyle)</span>
<span class="nc" id="L618">                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);</span>
    }

    /**
     * Returns a locale specific date-time formatter for the ISO chronology.
     * &lt;p&gt;
     * This returns a formatter that will format or parse a date-time.
     * The exact format pattern used varies by locale.
     * &lt;p&gt;
     * The locale is determined from the formatter. The formatter returned directly by
     * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
     * on the result of this method.
     * &lt;p&gt;
     * Note that the localized pattern is looked up lazily.
     * This {@code DateTimeFormatter} holds the style required and the locale,
     * looking up the pattern required on demand.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param dateTimeStyle  the formatter style to obtain, not null
     * @return the date-time formatter, not null
     */
    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateTimeStyle) {
<span class="nc" id="L644">        Objects.requireNonNull(dateTimeStyle, &quot;dateTimeStyle&quot;);</span>
<span class="nc" id="L645">        return new DateTimeFormatterBuilder().appendLocalized(dateTimeStyle, dateTimeStyle)</span>
<span class="nc" id="L646">                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);</span>
    }

    /**
     * Returns a locale specific date and time format for the ISO chronology.
     * &lt;p&gt;
     * This returns a formatter that will format or parse a date-time.
     * The exact format pattern used varies by locale.
     * &lt;p&gt;
     * The locale is determined from the formatter. The formatter returned directly by
     * this method will use the {@link Locale#getDefault() default FORMAT locale}.
     * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
     * on the result of this method.
     * &lt;p&gt;
     * Note that the localized pattern is looked up lazily.
     * This {@code DateTimeFormatter} holds the style required and the locale,
     * looking up the pattern required on demand.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
     *
     * @param dateStyle  the date formatter style to obtain, not null
     * @param timeStyle  the time formatter style to obtain, not null
     * @return the date, time or date-time formatter, not null
     */
    public static DateTimeFormatter ofLocalizedDateTime(FormatStyle dateStyle, FormatStyle timeStyle) {
<span class="nc" id="L673">        Objects.requireNonNull(dateStyle, &quot;dateStyle&quot;);</span>
<span class="nc" id="L674">        Objects.requireNonNull(timeStyle, &quot;timeStyle&quot;);</span>
<span class="nc" id="L675">        return new DateTimeFormatterBuilder().appendLocalized(dateStyle, timeStyle)</span>
<span class="nc" id="L676">                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses a date without an
     * offset, such as '2011-12-03'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended local date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;Four digits or more for the {@link ChronoField#YEAR year}.
     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
     * Years outside that range will have a prefixed positive or negative symbol.
     * &lt;li&gt;A dash
     * &lt;li&gt;Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;A dash
     * &lt;li&gt;Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_LOCAL_DATE;
    static {
<span class="nc" id="L705">        ISO_LOCAL_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L706">                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)</span>
<span class="nc" id="L707">                .appendLiteral('-')</span>
<span class="nc" id="L708">                .appendValue(MONTH_OF_YEAR, 2)</span>
<span class="nc" id="L709">                .appendLiteral('-')</span>
<span class="nc" id="L710">                .appendValue(DAY_OF_MONTH, 2)</span>
<span class="nc" id="L711">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses a date with an
     * offset, such as '2011-12-03+01:00'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended offset date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_OFFSET_DATE;
    static {
<span class="nc" id="L735">        ISO_OFFSET_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L736">                .parseCaseInsensitive()</span>
<span class="nc" id="L737">                .append(ISO_LOCAL_DATE)</span>
<span class="nc" id="L738">                .appendOffsetId()</span>
<span class="nc" id="L739">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses a date with the
     * offset if available, such as '2011-12-03' or '2011-12-03+01:00'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
     * &lt;li&gt;If the offset is not available then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_DATE;
    static {
<span class="nc" id="L767">        ISO_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L768">                .parseCaseInsensitive()</span>
<span class="nc" id="L769">                .append(ISO_LOCAL_DATE)</span>
<span class="nc" id="L770">                .optionalStart()</span>
<span class="nc" id="L771">                .appendOffsetId()</span>
<span class="nc" id="L772">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO time formatter that formats or parses a time without an
     * offset, such as '10:15' or '10:15:30'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended local time format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;A colon
     * &lt;li&gt;Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;If the second-of-minute is not available then the format is complete.
     * &lt;li&gt;A colon
     * &lt;li&gt;Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;If the nano-of-second is zero or not available then the format is complete.
     * &lt;li&gt;A decimal point
     * &lt;li&gt;One to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.
     *  As many digits will be output as required.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_LOCAL_TIME;
    static {
<span class="nc" id="L804">        ISO_LOCAL_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L805">                .appendValue(HOUR_OF_DAY, 2)</span>
<span class="nc" id="L806">                .appendLiteral(':')</span>
<span class="nc" id="L807">                .appendValue(MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L808">                .optionalStart()</span>
<span class="nc" id="L809">                .appendLiteral(':')</span>
<span class="nc" id="L810">                .appendValue(SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L811">                .optionalStart()</span>
<span class="nc" id="L812">                .appendFraction(NANO_OF_SECOND, 0, 9, true)</span>
<span class="nc" id="L813">                .toFormatter(ResolverStyle.STRICT, null);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO time formatter that formats or parses a time with an
     * offset, such as '10:15+01:00' or '10:15:30+01:00'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended offset time format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_OFFSET_TIME;
    static {
<span class="nc" id="L836">        ISO_OFFSET_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L837">                .parseCaseInsensitive()</span>
<span class="nc" id="L838">                .append(ISO_LOCAL_TIME)</span>
<span class="nc" id="L839">                .appendOffsetId()</span>
<span class="nc" id="L840">                .toFormatter(ResolverStyle.STRICT, null);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO time formatter that formats or parses a time, with the
     * offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended offset time format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
     * &lt;li&gt;If the offset is not available then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_TIME;
    static {
<span class="nc" id="L867">        ISO_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L868">                .parseCaseInsensitive()</span>
<span class="nc" id="L869">                .append(ISO_LOCAL_TIME)</span>
<span class="nc" id="L870">                .optionalStart()</span>
<span class="nc" id="L871">                .appendOffsetId()</span>
<span class="nc" id="L872">                .toFormatter(ResolverStyle.STRICT, null);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date-time formatter that formats or parses a date-time without
     * an offset, such as '2011-12-03T10:15:30'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended offset date-time format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_DATE}
     * &lt;li&gt;The letter 'T'. Parsing is case insensitive.
     * &lt;li&gt;The {@link #ISO_LOCAL_TIME}
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;
    static {
<span class="nc" id="L895">        ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L896">                .parseCaseInsensitive()</span>
<span class="nc" id="L897">                .append(ISO_LOCAL_DATE)</span>
<span class="nc" id="L898">                .appendLiteral('T')</span>
<span class="nc" id="L899">                .append(ISO_LOCAL_TIME)</span>
<span class="nc" id="L900">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date-time formatter that formats or parses a date-time with an
     * offset, such as '2011-12-03T10:15:30+01:00'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended offset date-time format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_DATE_TIME}
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_OFFSET_DATE_TIME;
    static {
<span class="nc" id="L924">        ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L925">                .parseCaseInsensitive()</span>
<span class="nc" id="L926">                .append(ISO_LOCAL_DATE_TIME)</span>
<span class="nc" id="L927">                .appendOffsetId()</span>
<span class="nc" id="L928">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO-like date-time formatter that formats or parses a date-time with
     * offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * a format that extends the ISO-8601 extended offset date-time format
     * to add the time-zone.
     * The section in square brackets is not part of the ISO-8601 standard.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_OFFSET_DATE_TIME}
     * &lt;li&gt;If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
     * &lt;li&gt;An open square bracket '['.
     * &lt;li&gt;The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
     *  Parsing is case sensitive.
     * &lt;li&gt;A close square bracket ']'.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_ZONED_DATE_TIME;
    static {
<span class="nc" id="L956">        ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L957">                .append(ISO_OFFSET_DATE_TIME)</span>
<span class="nc" id="L958">                .optionalStart()</span>
<span class="nc" id="L959">                .appendLiteral('[')</span>
<span class="nc" id="L960">                .parseCaseSensitive()</span>
<span class="nc" id="L961">                .appendZoneRegionId()</span>
<span class="nc" id="L962">                .appendLiteral(']')</span>
<span class="nc" id="L963">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO-like date-time formatter that formats or parses a date-time with
     * the offset and zone if available, such as '2011-12-03T10:15:30',
     * '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended local or offset date-time format, as well as the
     * extended non-ISO form specifying the time-zone.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_LOCAL_DATE_TIME}
     * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     * &lt;li&gt;If the zone ID is not available or is a {@code ZoneOffset} then the format is complete.
     * &lt;li&gt;An open square bracket '['.
     * &lt;li&gt;The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
     *  Parsing is case sensitive.
     * &lt;li&gt;A close square bracket ']'.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_DATE_TIME;
    static {
<span class="nc" id="L997">        ISO_DATE_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L998">                .append(ISO_LOCAL_DATE_TIME)</span>
<span class="nc" id="L999">                .optionalStart()</span>
<span class="nc" id="L1000">                .appendOffsetId()</span>
<span class="nc" id="L1001">                .optionalStart()</span>
<span class="nc" id="L1002">                .appendLiteral('[')</span>
<span class="nc" id="L1003">                .parseCaseSensitive()</span>
<span class="nc" id="L1004">                .appendZoneRegionId()</span>
<span class="nc" id="L1005">                .appendLiteral(']')</span>
<span class="nc" id="L1006">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses the ordinal date
     * without an offset, such as '2012-337'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended ordinal date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;Four digits or more for the {@link ChronoField#YEAR year}.
     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
     * Years outside that range will have a prefixed positive or negative symbol.
     * &lt;li&gt;A dash
     * &lt;li&gt;Three digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.
     *  This is pre-padded by zero to ensure three digits.
     * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_ORDINAL_DATE;
    static {
<span class="nc" id="L1039">        ISO_ORDINAL_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L1040">                .parseCaseInsensitive()</span>
<span class="nc" id="L1041">                .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)</span>
<span class="nc" id="L1042">                .appendLiteral('-')</span>
<span class="nc" id="L1043">                .appendValue(DAY_OF_YEAR, 3)</span>
<span class="nc" id="L1044">                .optionalStart()</span>
<span class="nc" id="L1045">                .appendOffsetId()</span>
<span class="nc" id="L1046">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses the week-based date
     * without an offset, such as '2012-W48-6'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 extended week-based date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;Four digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.
     * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
     * Years outside that range will have a prefixed positive or negative symbol.
     * &lt;li&gt;A dash
     * &lt;li&gt;The letter 'W'. Parsing is case insensitive.
     * &lt;li&gt;Two digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.
     *  This is pre-padded by zero to ensure three digits.
     * &lt;li&gt;A dash
     * &lt;li&gt;One digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.
     *  The value run from Monday (1) to Sunday (7).
     * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
     *  they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_WEEK_DATE;
    static {
<span class="nc" id="L1083">        ISO_WEEK_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L1084">                .parseCaseInsensitive()</span>
<span class="nc" id="L1085">                .appendValue(IsoFields.WEEK_BASED_YEAR, 4, 10, SignStyle.EXCEEDS_PAD)</span>
<span class="nc" id="L1086">                .appendLiteral(&quot;-W&quot;)</span>
<span class="nc" id="L1087">                .appendValue(IsoFields.WEEK_OF_WEEK_BASED_YEAR, 2)</span>
<span class="nc" id="L1088">                .appendLiteral('-')</span>
<span class="nc" id="L1089">                .appendValue(DAY_OF_WEEK, 1)</span>
<span class="nc" id="L1090">                .optionalStart()</span>
<span class="nc" id="L1091">                .appendOffsetId()</span>
<span class="nc" id="L1092">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO instant formatter that formats or parses an instant in UTC,
     * such as '2011-12-03T10:15:30Z'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 instant format.
     * When formatting, the second-of-minute is always output.
     * The nano-of-second outputs zero, three, six or nine digits digits as necessary.
     * When parsing, time to at least the seconds field is required.
     * Fractional seconds from zero to nine are parsed.
     * The localized decimal style is not used.
     * &lt;p&gt;
     * This is a special case formatter intended to allow a human readable form
     * of an {@link java.time.Instant}. The {@code Instant} class is designed to
     * only represent a point in time and internally stores a value in nanoseconds
     * from a fixed epoch of 1970-01-01Z. As such, an {@code Instant} cannot be
     * formatted as a date or time without providing some form of time-zone.
     * This formatter allows the {@code Instant} to be formatted, by providing
     * a suitable conversion using {@code ZoneOffset.UTC}.
     * &lt;p&gt;
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;The {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from
     *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}
     *  using the {@code UTC} offset. Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The returned formatter has no override chronology or zone.
     * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter ISO_INSTANT;
    static {
<span class="nc" id="L1128">        ISO_INSTANT = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L1129">                .parseCaseInsensitive()</span>
<span class="nc" id="L1130">                .appendInstant()</span>
<span class="nc" id="L1131">                .toFormatter(ResolverStyle.STRICT, null);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The ISO date formatter that formats or parses a date without an
     * offset, such as '20111203'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * the ISO-8601 basic local date format.
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;Four digits for the {@link ChronoField#YEAR year}.
     *  Only years in the range 0000 to 9999 are supported.
     * &lt;li&gt;Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;If the offset is not available to format or parse then the format is complete.
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID} without colons. If the offset has
     *  seconds then they will be handled even though this is not part of the ISO-8601 standard.
     *  Parsing is case insensitive.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * As this formatter has an optional element, it may be necessary to parse using
     * {@link DateTimeFormatter#parseBest}.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
     */
    public static final DateTimeFormatter BASIC_ISO_DATE;
    static {
<span class="nc" id="L1164">        BASIC_ISO_DATE = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L1165">                .parseCaseInsensitive()</span>
<span class="nc" id="L1166">                .appendValue(YEAR, 4)</span>
<span class="nc" id="L1167">                .appendValue(MONTH_OF_YEAR, 2)</span>
<span class="nc" id="L1168">                .appendValue(DAY_OF_MONTH, 2)</span>
<span class="nc" id="L1169">                .optionalStart()</span>
<span class="nc" id="L1170">                .appendOffset(&quot;+HHMMss&quot;, &quot;Z&quot;)</span>
<span class="nc" id="L1171">                .toFormatter(ResolverStyle.STRICT, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30 GMT'.
     * &lt;p&gt;
     * This returns an immutable formatter capable of formatting and parsing
     * most of the RFC-1123 format.
     * RFC-1123 updates RFC-822 changing the year from two digits to four.
     * This implementation requires a four digit year.
     * This implementation also does not handle North American or military zone
     * names, only 'GMT' and offset amounts.
     * &lt;p&gt;
     * The format consists of:
     * &lt;ul&gt;
     * &lt;li&gt;If the day-of-week is not available to format or parse then jump to day-of-month.
     * &lt;li&gt;Three letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.
     * &lt;li&gt;A comma
     * &lt;li&gt;A space
     * &lt;li&gt;One or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
     * &lt;li&gt;A space
     * &lt;li&gt;Three letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.
     * &lt;li&gt;A space
     * &lt;li&gt;Four digits for the {@link ChronoField#YEAR year}.
     *  Only years in the range 0000 to 9999 are supported.
     * &lt;li&gt;A space
     * &lt;li&gt;Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;A colon
     * &lt;li&gt;Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;If the second-of-minute is not available then jump to the next space.
     * &lt;li&gt;A colon
     * &lt;li&gt;Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
     *  This is pre-padded by zero to ensure two digits.
     * &lt;li&gt;A space
     * &lt;li&gt;The {@link ZoneOffset#getId() offset ID} without colons or seconds.
     *  An offset of zero uses &quot;GMT&quot;. North American zone names and military zone names are not handled.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Parsing is case insensitive.
     * &lt;p&gt;
     * The returned formatter has a chronology of ISO set to ensure dates in
     * other calendar systems are correctly converted.
     * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
     */
    public static final DateTimeFormatter RFC_1123_DATE_TIME;
    static {
        // manually code maps to ensure correct data always used
        // (locale data can be changed by application code)
<span class="nc" id="L1222">        Map&lt;Long, String&gt; dow = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1223">        dow.put(1L, &quot;Mon&quot;);</span>
<span class="nc" id="L1224">        dow.put(2L, &quot;Tue&quot;);</span>
<span class="nc" id="L1225">        dow.put(3L, &quot;Wed&quot;);</span>
<span class="nc" id="L1226">        dow.put(4L, &quot;Thu&quot;);</span>
<span class="nc" id="L1227">        dow.put(5L, &quot;Fri&quot;);</span>
<span class="nc" id="L1228">        dow.put(6L, &quot;Sat&quot;);</span>
<span class="nc" id="L1229">        dow.put(7L, &quot;Sun&quot;);</span>
<span class="nc" id="L1230">        Map&lt;Long, String&gt; moy = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1231">        moy.put(1L, &quot;Jan&quot;);</span>
<span class="nc" id="L1232">        moy.put(2L, &quot;Feb&quot;);</span>
<span class="nc" id="L1233">        moy.put(3L, &quot;Mar&quot;);</span>
<span class="nc" id="L1234">        moy.put(4L, &quot;Apr&quot;);</span>
<span class="nc" id="L1235">        moy.put(5L, &quot;May&quot;);</span>
<span class="nc" id="L1236">        moy.put(6L, &quot;Jun&quot;);</span>
<span class="nc" id="L1237">        moy.put(7L, &quot;Jul&quot;);</span>
<span class="nc" id="L1238">        moy.put(8L, &quot;Aug&quot;);</span>
<span class="nc" id="L1239">        moy.put(9L, &quot;Sep&quot;);</span>
<span class="nc" id="L1240">        moy.put(10L, &quot;Oct&quot;);</span>
<span class="nc" id="L1241">        moy.put(11L, &quot;Nov&quot;);</span>
<span class="nc" id="L1242">        moy.put(12L, &quot;Dec&quot;);</span>
<span class="nc" id="L1243">        RFC_1123_DATE_TIME = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L1244">                .parseCaseInsensitive()</span>
<span class="nc" id="L1245">                .parseLenient()</span>
<span class="nc" id="L1246">                .optionalStart()</span>
<span class="nc" id="L1247">                .appendText(DAY_OF_WEEK, dow)</span>
<span class="nc" id="L1248">                .appendLiteral(&quot;, &quot;)</span>
<span class="nc" id="L1249">                .optionalEnd()</span>
<span class="nc" id="L1250">                .appendValue(DAY_OF_MONTH, 1, 2, SignStyle.NOT_NEGATIVE)</span>
<span class="nc" id="L1251">                .appendLiteral(' ')</span>
<span class="nc" id="L1252">                .appendText(MONTH_OF_YEAR, moy)</span>
<span class="nc" id="L1253">                .appendLiteral(' ')</span>
<span class="nc" id="L1254">                .appendValue(YEAR, 4)  // 2 digit year not handled</span>
<span class="nc" id="L1255">                .appendLiteral(' ')</span>
<span class="nc" id="L1256">                .appendValue(HOUR_OF_DAY, 2)</span>
<span class="nc" id="L1257">                .appendLiteral(':')</span>
<span class="nc" id="L1258">                .appendValue(MINUTE_OF_HOUR, 2)</span>
<span class="nc" id="L1259">                .optionalStart()</span>
<span class="nc" id="L1260">                .appendLiteral(':')</span>
<span class="nc" id="L1261">                .appendValue(SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L1262">                .optionalEnd()</span>
<span class="nc" id="L1263">                .appendLiteral(' ')</span>
<span class="nc" id="L1264">                .appendOffset(&quot;+HHMM&quot;, &quot;GMT&quot;)  // should handle UT/Z/EST/EDT/CST/CDT/MST/MDT/PST/MDT</span>
<span class="nc" id="L1265">                .toFormatter(ResolverStyle.SMART, IsoChronology.INSTANCE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * A query that provides access to the excess days that were parsed.
     * &lt;p&gt;
     * This returns a singleton {@linkplain TemporalQuery query} that provides
     * access to additional information from the parse. The query always returns
     * a non-null period, with a zero period returned instead of null.
     * &lt;p&gt;
     * There are two situations where this query may return a non-zero period.
     * &lt;ul&gt;
     * &lt;li&gt;If the {@code ResolverStyle} is {@code LENIENT} and a time is parsed
     *  without a date, then the complete result of the parse consists of a
     *  {@code LocalTime} and an excess {@code Period} in days.
     *
     * &lt;li&gt;If the {@code ResolverStyle} is {@code SMART} and a time is parsed
     *  without a date where the time is 24:00:00, then the complete result of
     *  the parse consists of a {@code LocalTime} of 00:00:00 and an excess
     *  {@code Period} of one day.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * In both cases, if a complete {@code ChronoLocalDateTime} or {@code Instant}
     * is parsed, then the excess days are added to the date part.
     * As a result, this query will return a zero period.
     * &lt;p&gt;
     * The {@code SMART} behaviour handles the common &quot;end of day&quot; 24:00 value.
     * Processing in {@code LENIENT} mode also produces the same result:
     * &lt;pre&gt;
     *  Text to parse        Parsed object                         Excess days
     *  &quot;2012-12-03T00:00&quot;   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
     *  &quot;2012-12-03T24:00&quot;   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
     *  &quot;00:00&quot;              LocalTime.of(0, 0)                    ZERO
     *  &quot;24:00&quot;              LocalTime.of(0, 0)                    Period.ofDays(1)
     * &lt;/pre&gt;
     * The query can be used as follows:
     * &lt;pre&gt;
     *  TemporalAccessor parsed = formatter.parse(str);
     *  LocalTime time = parsed.query(LocalTime::from);
     *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());
     * &lt;/pre&gt;
     * @return a query that provides access to the excess days that were parsed
     */
    public static final TemporalQuery&lt;Period&gt; parsedExcessDays() {
<span class="nc" id="L1310">        return PARSED_EXCESS_DAYS;</span>
    }
<span class="nc" id="L1312">    private static final TemporalQuery&lt;Period&gt; PARSED_EXCESS_DAYS = t -&gt; {</span>
        if (t instanceof Parsed) {
            return ((Parsed) t).excessDays;
        } else {
            return Period.ZERO;
        }
    };

    /**
     * A query that provides access to whether a leap-second was parsed.
     * &lt;p&gt;
     * This returns a singleton {@linkplain TemporalQuery query} that provides
     * access to additional information from the parse. The query always returns
     * a non-null boolean, true if parsing saw a leap-second, false if not.
     * &lt;p&gt;
     * Instant parsing handles the special &quot;leap second&quot; time of '23:59:60'.
     * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other
     * local times in different time-zones. To avoid this potential ambiguity,
     * the handling of leap-seconds is limited to
     * {@link DateTimeFormatterBuilder#appendInstant()}, as that method
     * always parses the instant with the UTC zone offset.
     * &lt;p&gt;
     * If the time '23:59:60' is received, then a simple conversion is applied,
     * replacing the second-of-minute of 60 with 59. This query can be used
     * on the parse result to determine if the leap-second adjustment was made.
     * The query will return one second of excess if it did adjust to remove
     * the leap-second, and zero if not. Note that applying a leap-second
     * smoothing mechanism, such as UTC-SLS, is the responsibility of the
     * application, as follows:
     * &lt;pre&gt;
     *  TemporalAccessor parsed = formatter.parse(str);
     *  Instant instant = parsed.query(Instant::from);
     *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
     *    // validate leap-second is correct and apply correct smoothing
     *  }
     * &lt;/pre&gt;
     * @return a query that provides access to whether a leap-second was parsed
     */
    public static final TemporalQuery&lt;Boolean&gt; parsedLeapSecond() {
<span class="nc" id="L1351">        return PARSED_LEAP_SECOND;</span>
    }
<span class="nc" id="L1353">    private static final TemporalQuery&lt;Boolean&gt; PARSED_LEAP_SECOND = t -&gt; {</span>
        if (t instanceof Parsed) {
            return ((Parsed) t).leapSecond;
        } else {
            return Boolean.FALSE;
        }
    };

    //-----------------------------------------------------------------------
    /**
     * Constructor.
     *
     * @param printerParser  the printer/parser to use, not null
     * @param locale  the locale to use, not null
     * @param decimalStyle  the DecimalStyle to use, not null
     * @param resolverStyle  the resolver style to use, not null
     * @param resolverFields  the fields to use during resolving, null for all fields
     * @param chrono  the chronology to use, null for no override
     * @param zone  the zone to use, null for no override
     */
    DateTimeFormatter(CompositePrinterParser printerParser,
            Locale locale, DecimalStyle decimalStyle,
            ResolverStyle resolverStyle, Set&lt;TemporalField&gt; resolverFields,
<span class="nc" id="L1376">            Chronology chrono, ZoneId zone) {</span>
<span class="nc" id="L1377">        this.printerParser = Objects.requireNonNull(printerParser, &quot;printerParser&quot;);</span>
<span class="nc" id="L1378">        this.resolverFields = resolverFields;</span>
<span class="nc" id="L1379">        this.locale = Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc" id="L1380">        this.decimalStyle = Objects.requireNonNull(decimalStyle, &quot;decimalStyle&quot;);</span>
<span class="nc" id="L1381">        this.resolverStyle = Objects.requireNonNull(resolverStyle, &quot;resolverStyle&quot;);</span>
<span class="nc" id="L1382">        this.chrono = chrono;</span>
<span class="nc" id="L1383">        this.zone = zone;</span>
<span class="nc" id="L1384">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the locale to be used during formatting.
     * &lt;p&gt;
     * This is used to lookup any part of the formatter needing specific
     * localization, such as the text or localized pattern.
     *
     * @return the locale of this formatter, not null
     */
    public Locale getLocale() {
<span class="nc" id="L1396">        return locale;</span>
    }

    /**
     * Returns a copy of this formatter with a new locale.
     * &lt;p&gt;
     * This is used to lookup any part of the formatter needing specific
     * localization, such as the text or localized pattern.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param locale  the new locale, not null
     * @return a formatter based on this formatter with the requested locale, not null
     */
    public DateTimeFormatter withLocale(Locale locale) {
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (this.locale.equals(locale)) {</span>
<span class="nc" id="L1412">            return this;</span>
        }
<span class="nc" id="L1414">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the DecimalStyle to be used during formatting.
     *
     * @return the locale of this formatter, not null
     */
    public DecimalStyle getDecimalStyle() {
<span class="nc" id="L1424">        return decimalStyle;</span>
    }

    /**
     * Returns a copy of this formatter with a new DecimalStyle.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param decimalStyle  the new DecimalStyle, not null
     * @return a formatter based on this formatter with the requested DecimalStyle, not null
     */
    public DateTimeFormatter withDecimalStyle(DecimalStyle decimalStyle) {
<span class="nc bnc" id="L1436" title="All 2 branches missed.">        if (this.decimalStyle.equals(decimalStyle)) {</span>
<span class="nc" id="L1437">            return this;</span>
        }
<span class="nc" id="L1439">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the overriding chronology to be used during formatting.
     * &lt;p&gt;
     * This returns the override chronology, used to convert dates.
     * By default, a formatter has no override chronology, returning null.
     * See {@link #withChronology(Chronology)} for more details on overriding.
     *
     * @return the override chronology of this formatter, null if no override
     */
    public Chronology getChronology() {
<span class="nc" id="L1453">        return chrono;</span>
    }

    /**
     * Returns a copy of this formatter with a new override chronology.
     * &lt;p&gt;
     * This returns a formatter with similar state to this formatter but
     * with the override chronology set.
     * By default, a formatter has no override chronology, returning null.
     * &lt;p&gt;
     * If an override is added, then any date that is formatted or parsed will be affected.
     * &lt;p&gt;
     * When formatting, if the temporal object contains a date, then it will
     * be converted to a date in the override chronology.
     * Whether the temporal contains a date is determined by querying the
     * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.
     * Any time or zone will be retained unaltered unless overridden.
     * &lt;p&gt;
     * If the temporal object does not contain a date, but does contain one
     * or more {@code ChronoField} date fields, then a {@code DateTimeException}
     * is thrown. In all other cases, the override chronology is added to the temporal,
     * replacing any previous chronology, but without changing the date/time.
     * &lt;p&gt;
     * When parsing, there are two distinct cases to consider.
     * If a chronology has been parsed directly from the text, perhaps because
     * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then
     * this override chronology has no effect.
     * If no zone has been parsed, then this override chronology will be used
     * to interpret the {@code ChronoField} values into a date according to the
     * date resolving rules of the chronology.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param chrono  the new chronology, null if no override
     * @return a formatter based on this formatter with the requested override chronology, not null
     */
    public DateTimeFormatter withChronology(Chronology chrono) {
<span class="nc bnc" id="L1490" title="All 2 branches missed.">        if (Objects.equals(this.chrono, chrono)) {</span>
<span class="nc" id="L1491">            return this;</span>
        }
<span class="nc" id="L1493">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the overriding zone to be used during formatting.
     * &lt;p&gt;
     * This returns the override zone, used to convert instants.
     * By default, a formatter has no override zone, returning null.
     * See {@link #withZone(ZoneId)} for more details on overriding.
     *
     * @return the override zone of this formatter, null if no override
     */
    public ZoneId getZone() {
<span class="nc" id="L1507">        return zone;</span>
    }

    /**
     * Returns a copy of this formatter with a new override zone.
     * &lt;p&gt;
     * This returns a formatter with similar state to this formatter but
     * with the override zone set.
     * By default, a formatter has no override zone, returning null.
     * &lt;p&gt;
     * If an override is added, then any instant that is formatted or parsed will be affected.
     * &lt;p&gt;
     * When formatting, if the temporal object contains an instant, then it will
     * be converted to a zoned date-time using the override zone.
     * Whether the temporal is an instant is determined by querying the
     * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.
     * If the input has a chronology then it will be retained unless overridden.
     * If the input does not have a chronology, such as {@code Instant}, then
     * the ISO chronology will be used.
     * &lt;p&gt;
     * If the temporal object does not contain an instant, but does contain
     * an offset then an additional check is made. If the normalized override
     * zone is an offset that differs from the offset of the temporal, then
     * a {@code DateTimeException} is thrown. In all other cases, the override
     * zone is added to the temporal, replacing any previous zone, but without
     * changing the date/time.
     * &lt;p&gt;
     * When parsing, there are two distinct cases to consider.
     * If a zone has been parsed directly from the text, perhaps because
     * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then
     * this override zone has no effect.
     * If no zone has been parsed, then this override zone will be included in
     * the result of the parse where it can be used to build instants and date-times.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param zone  the new override zone, null if no override
     * @return a formatter based on this formatter with the requested override zone, not null
     */
    public DateTimeFormatter withZone(ZoneId zone) {
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        if (Objects.equals(this.zone, zone)) {</span>
<span class="nc" id="L1548">            return this;</span>
        }
<span class="nc" id="L1550">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the resolver style to use during parsing.
     * &lt;p&gt;
     * This returns the resolver style, used during the second phase of parsing
     * when fields are resolved into dates and times.
     * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.
     * See {@link #withResolverStyle(ResolverStyle)} for more details.
     *
     * @return the resolver style of this formatter, not null
     */
    public ResolverStyle getResolverStyle() {
<span class="nc" id="L1565">        return resolverStyle;</span>
    }

    /**
     * Returns a copy of this formatter with a new resolver style.
     * &lt;p&gt;
     * This returns a formatter with similar state to this formatter but
     * with the resolver style set. By default, a formatter has the
     * {@link ResolverStyle#SMART SMART} resolver style.
     * &lt;p&gt;
     * Changing the resolver style only has an effect during parsing.
     * Parsing a text string occurs in two phases.
     * Phase 1 is a basic text parse according to the fields added to the builder.
     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
     * The resolver style is used to control how phase 2, resolving, happens.
     * See {@code ResolverStyle} for more information on the options available.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param resolverStyle  the new resolver style, not null
     * @return a formatter based on this formatter with the requested resolver style, not null
     */
    public DateTimeFormatter withResolverStyle(ResolverStyle resolverStyle) {
<span class="nc" id="L1588">        Objects.requireNonNull(resolverStyle, &quot;resolverStyle&quot;);</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        if (Objects.equals(this.resolverStyle, resolverStyle)) {</span>
<span class="nc" id="L1590">            return this;</span>
        }
<span class="nc" id="L1592">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the resolver fields to use during parsing.
     * &lt;p&gt;
     * This returns the resolver fields, used during the second phase of parsing
     * when fields are resolved into dates and times.
     * By default, a formatter has no resolver fields, and thus returns null.
     * See {@link #withResolverFields(Set)} for more details.
     *
     * @return the immutable set of resolver fields of this formatter, null if no fields
     */
    public Set&lt;TemporalField&gt; getResolverFields() {
<span class="nc" id="L1607">        return resolverFields;</span>
    }

    /**
     * Returns a copy of this formatter with a new set of resolver fields.
     * &lt;p&gt;
     * This returns a formatter with similar state to this formatter but with
     * the resolver fields set. By default, a formatter has no resolver fields.
     * &lt;p&gt;
     * Changing the resolver fields only has an effect during parsing.
     * Parsing a text string occurs in two phases.
     * Phase 1 is a basic text parse according to the fields added to the builder.
     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
     * &lt;p&gt;
     * This can be used to select between two or more ways that a date or time might
     * be resolved. For example, if the formatter consists of year, month, day-of-month
     * and day-of-year, then there are two ways to resolve a date.
     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
     * resolved using the year and day-of-year, effectively meaning that the month
     * and day-of-month are ignored during the resolving phase.
     * &lt;p&gt;
     * In a similar manner, this method can be used to ignore secondary fields that
     * would otherwise be cross-checked. For example, if the formatter consists of year,
     * month, day-of-month and day-of-week, then there is only one way to resolve a
     * date, but the parsed value for day-of-week will be cross-checked against the
     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
     * resolved correctly, but without any cross-check for the day-of-week.
     * &lt;p&gt;
     * In implementation terms, this method behaves as follows. The result of the
     * parsing phase can be considered to be a map of field to value. The behavior
     * of this method is to cause that map to be filtered between phase 1 and 2,
     * removing all fields other than those specified as arguments to this method.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param resolverFields  the new set of resolver fields, null if no fields
     * @return a formatter based on this formatter with the requested resolver style, not null
     */
    public DateTimeFormatter withResolverFields(TemporalField... resolverFields) {
<span class="nc" id="L1650">        Objects.requireNonNull(resolverFields, &quot;resolverFields&quot;);</span>
<span class="nc" id="L1651">        Set&lt;TemporalField&gt; fields = new HashSet&lt;&gt;(Arrays.asList(resolverFields));</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        if (Objects.equals(this.resolverFields, fields)) {</span>
<span class="nc" id="L1653">            return this;</span>
        }
<span class="nc" id="L1655">        fields = Collections.unmodifiableSet(fields);</span>
<span class="nc" id="L1656">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, fields, chrono, zone);</span>
    }

    /**
     * Returns a copy of this formatter with a new set of resolver fields.
     * &lt;p&gt;
     * This returns a formatter with similar state to this formatter but with
     * the resolver fields set. By default, a formatter has no resolver fields.
     * &lt;p&gt;
     * Changing the resolver fields only has an effect during parsing.
     * Parsing a text string occurs in two phases.
     * Phase 1 is a basic text parse according to the fields added to the builder.
     * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
     * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
     * &lt;p&gt;
     * This can be used to select between two or more ways that a date or time might
     * be resolved. For example, if the formatter consists of year, month, day-of-month
     * and day-of-year, then there are two ways to resolve a date.
     * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
     * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
     * resolved using the year and day-of-year, effectively meaning that the month
     * and day-of-month are ignored during the resolving phase.
     * &lt;p&gt;
     * In a similar manner, this method can be used to ignore secondary fields that
     * would otherwise be cross-checked. For example, if the formatter consists of year,
     * month, day-of-month and day-of-week, then there is only one way to resolve a
     * date, but the parsed value for day-of-week will be cross-checked against the
     * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
     * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
     * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
     * resolved correctly, but without any cross-check for the day-of-week.
     * &lt;p&gt;
     * In implementation terms, this method behaves as follows. The result of the
     * parsing phase can be considered to be a map of field to value. The behavior
     * of this method is to cause that map to be filtered between phase 1 and 2,
     * removing all fields other than those specified as arguments to this method.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param resolverFields  the new set of resolver fields, null if no fields
     * @return a formatter based on this formatter with the requested resolver style, not null
     */
    public DateTimeFormatter withResolverFields(Set&lt;TemporalField&gt; resolverFields) {
<span class="nc" id="L1699">        Objects.requireNonNull(resolverFields, &quot;resolverFields&quot;);</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">        if (Objects.equals(this.resolverFields, resolverFields)) {</span>
<span class="nc" id="L1701">            return this;</span>
        }
<span class="nc" id="L1703">        resolverFields = Collections.unmodifiableSet(new HashSet&lt;&gt;(resolverFields));</span>
<span class="nc" id="L1704">        return new DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Formats a date-time object using this formatter.
     * &lt;p&gt;
     * This formats the date-time to a String using the rules of the formatter.
     *
     * @param temporal  the temporal object to format, not null
     * @return the formatted string, not null
     * @throws DateTimeException if an error occurs during formatting
     */
    public String format(TemporalAccessor temporal) {
<span class="nc" id="L1718">        StringBuilder buf = new StringBuilder(32);</span>
<span class="nc" id="L1719">        formatTo(temporal, buf);</span>
<span class="nc" id="L1720">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Formats a date-time object to an {@code Appendable} using this formatter.
     * &lt;p&gt;
     * This outputs the formatted date-time to the specified destination.
     * {@link Appendable} is a general purpose interface that is implemented by all
     * key character output classes including {@code StringBuffer}, {@code StringBuilder},
     * {@code PrintStream} and {@code Writer}.
     * &lt;p&gt;
     * Although {@code Appendable} methods throw an {@code IOException}, this method does not.
     * Instead, any {@code IOException} is wrapped in a runtime exception.
     *
     * @param temporal  the temporal object to format, not null
     * @param appendable  the appendable to format to, not null
     * @throws DateTimeException if an error occurs during formatting
     */
    public void formatTo(TemporalAccessor temporal, Appendable appendable) {
<span class="nc" id="L1740">        Objects.requireNonNull(temporal, &quot;temporal&quot;);</span>
<span class="nc" id="L1741">        Objects.requireNonNull(appendable, &quot;appendable&quot;);</span>
        try {
<span class="nc" id="L1743">            DateTimePrintContext context = new DateTimePrintContext(temporal, this);</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">            if (appendable instanceof StringBuilder) {</span>
<span class="nc" id="L1745">                printerParser.format(context, (StringBuilder) appendable);</span>
            } else {
                // buffer output to avoid writing to appendable in case of error
<span class="nc" id="L1748">                StringBuilder buf = new StringBuilder(32);</span>
<span class="nc" id="L1749">                printerParser.format(context, buf);</span>
<span class="nc" id="L1750">                appendable.append(buf);</span>
            }
<span class="nc" id="L1752">        } catch (IOException ex) {</span>
<span class="nc" id="L1753">            throw new DateTimeException(ex.getMessage(), ex);</span>
<span class="nc" id="L1754">        }</span>
<span class="nc" id="L1755">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Fully parses the text producing a temporal object.
     * &lt;p&gt;
     * This parses the entire text producing a temporal object.
     * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.
     * The result of this method is {@code TemporalAccessor} which has been resolved,
     * applying basic validation checks to help ensure a valid date-time.
     * &lt;p&gt;
     * If the parse completes without reading the entire length of the text,
     * or a problem occurs during parsing or merging, then an exception is thrown.
     *
     * @param text  the text to parse, not null
     * @return the parsed temporal object, not null
     * @throws DateTimeParseException if unable to parse the requested result
     */
    public TemporalAccessor parse(CharSequence text) {
<span class="nc" id="L1774">        Objects.requireNonNull(text, &quot;text&quot;);</span>
        try {
<span class="nc" id="L1776">            return parseResolved0(text, null);</span>
<span class="nc" id="L1777">        } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L1778">            throw ex;</span>
<span class="nc" id="L1779">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L1780">            throw createError(text, ex);</span>
        }
    }

    /**
     * Parses the text using this formatter, providing control over the text position.
     * &lt;p&gt;
     * This parses the text without requiring the parse to start from the beginning
     * of the string or finish at the end.
     * The result of this method is {@code TemporalAccessor} which has been resolved,
     * applying basic validation checks to help ensure a valid date-time.
     * &lt;p&gt;
     * The text will be parsed from the specified start {@code ParsePosition}.
     * The entire length of the text does not have to be parsed, the {@code ParsePosition}
     * will be updated with the index at the end of parsing.
     * &lt;p&gt;
     * The operation of this method is slightly different to similar methods using
     * {@code ParsePosition} on {@code java.text.Format}. That class will return
     * errors using the error index on the {@code ParsePosition}. By contrast, this
     * method will throw a {@link DateTimeParseException} if an error occurs, with
     * the exception containing the error index.
     * This change in behavior is necessary due to the increased complexity of
     * parsing and resolving dates/times in this API.
     * &lt;p&gt;
     * If the formatter parses the same field more than once with different values,
     * the result will be an error.
     *
     * @param text  the text to parse, not null
     * @param position  the position to parse from, updated with length parsed
     *  and the index of any error, not null
     * @return the parsed temporal object, not null
     * @throws DateTimeParseException if unable to parse the requested result
     * @throws IndexOutOfBoundsException if the position is invalid
     */
    public TemporalAccessor parse(CharSequence text, ParsePosition position) {
<span class="nc" id="L1815">        Objects.requireNonNull(text, &quot;text&quot;);</span>
<span class="nc" id="L1816">        Objects.requireNonNull(position, &quot;position&quot;);</span>
        try {
<span class="nc" id="L1818">            return parseResolved0(text, position);</span>
<span class="nc" id="L1819">        } catch (DateTimeParseException | IndexOutOfBoundsException ex) {</span>
<span class="nc" id="L1820">            throw ex;</span>
<span class="nc" id="L1821">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L1822">            throw createError(text, ex);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Fully parses the text producing an object of the specified type.
     * &lt;p&gt;
     * Most applications should use this method for parsing.
     * It parses the entire text to produce the required date-time.
     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.
     * For example:
     * &lt;pre&gt;
     *  LocalDateTime dt = parser.parse(str, LocalDateTime::from);
     * &lt;/pre&gt;
     * If the parse completes without reading the entire length of the text,
     * or a problem occurs during parsing or merging, then an exception is thrown.
     *
     * @param &lt;T&gt; the type of the parsed date-time
     * @param text  the text to parse, not null
     * @param query  the query defining the type to parse to, not null
     * @return the parsed date-time, not null
     * @throws DateTimeParseException if unable to parse the requested result
     */
    public &lt;T&gt; T parse(CharSequence text, TemporalQuery&lt;T&gt; query) {
<span class="nc" id="L1847">        Objects.requireNonNull(text, &quot;text&quot;);</span>
<span class="nc" id="L1848">        Objects.requireNonNull(query, &quot;query&quot;);</span>
        try {
<span class="nc" id="L1850">            return parseResolved0(text, null).query(query);</span>
<span class="nc" id="L1851">        } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L1852">            throw ex;</span>
<span class="nc" id="L1853">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L1854">            throw createError(text, ex);</span>
        }
    }

    /**
     * Fully parses the text producing an object of one of the specified types.
     * &lt;p&gt;
     * This parse method is convenient for use when the parser can handle optional elements.
     * For example, a pattern of 'uuuu-MM-dd HH.mm[ VV]' can be fully parsed to a {@code ZonedDateTime},
     * or partially parsed to a {@code LocalDateTime}.
     * The queries must be specified in order, starting from the best matching full-parse option
     * and ending with the worst matching minimal parse option.
     * The query is typically a method reference to a {@code from(TemporalAccessor)} method.
     * &lt;p&gt;
     * The result is associated with the first type that successfully parses.
     * Normally, applications will use {@code instanceof} to check the result.
     * For example:
     * &lt;pre&gt;
     *  TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
     *  if (dt instanceof ZonedDateTime) {
     *   ...
     *  } else {
     *   ...
     *  }
     * &lt;/pre&gt;
     * If the parse completes without reading the entire length of the text,
     * or a problem occurs during parsing or merging, then an exception is thrown.
     *
     * @param text  the text to parse, not null
     * @param queries  the queries defining the types to attempt to parse to,
     *  must implement {@code TemporalAccessor}, not null
     * @return the parsed date-time, not null
     * @throws IllegalArgumentException if less than 2 types are specified
     * @throws DateTimeParseException if unable to parse the requested result
     */
    public TemporalAccessor parseBest(CharSequence text, TemporalQuery&lt;?&gt;... queries) {
<span class="nc" id="L1890">        Objects.requireNonNull(text, &quot;text&quot;);</span>
<span class="nc" id="L1891">        Objects.requireNonNull(queries, &quot;queries&quot;);</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (queries.length &lt; 2) {</span>
<span class="nc" id="L1893">            throw new IllegalArgumentException(&quot;At least two queries must be specified&quot;);</span>
        }
        try {
<span class="nc" id="L1896">            TemporalAccessor resolved = parseResolved0(text, null);</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">            for (TemporalQuery&lt;?&gt; query : queries) {</span>
                try {
<span class="nc" id="L1899">                    return (TemporalAccessor) resolved.query(query);</span>
<span class="nc" id="L1900">                } catch (RuntimeException ex) {</span>
                    // continue
                }
            }
<span class="nc" id="L1904">            throw new DateTimeException(&quot;Unable to convert parsed text using any of the specified queries&quot;);</span>
<span class="nc" id="L1905">        } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L1906">            throw ex;</span>
<span class="nc" id="L1907">        } catch (RuntimeException ex) {</span>
<span class="nc" id="L1908">            throw createError(text, ex);</span>
        }
    }

    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {
        String abbr;
<span class="nc bnc" id="L1914" title="All 2 branches missed.">        if (text.length() &gt; 64) {</span>
<span class="nc" id="L1915">            abbr = text.subSequence(0, 64).toString() + &quot;...&quot;;</span>
        } else {
<span class="nc" id="L1917">            abbr = text.toString();</span>
        }
<span class="nc" id="L1919">        return new DateTimeParseException(&quot;Text '&quot; + abbr + &quot;' could not be parsed: &quot; + ex.getMessage(), text, 0, ex);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Parses and resolves the specified text.
     * &lt;p&gt;
     * This parses to a {@code TemporalAccessor} ensuring that the text is fully parsed.
     *
     * @param text  the text to parse, not null
     * @param position  the position to parse from, updated with length parsed
     *  and the index of any error, null if parsing whole string
     * @return the resolved result of the parse, not null
     * @throws DateTimeParseException if the parse fails
     * @throws DateTimeException if an error occurs while resolving the date or time
     * @throws IndexOutOfBoundsException if the position is invalid
     */
    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {
<span class="nc bnc" id="L1937" title="All 2 branches missed.">        ParsePosition pos = (position != null ? position : new ParsePosition(0));</span>
<span class="nc" id="L1938">        Parsed unresolved = parseUnresolved0(text, pos);</span>
<span class="nc bnc" id="L1939" title="All 8 branches missed.">        if (unresolved == null || pos.getErrorIndex() &gt;= 0 || (position == null &amp;&amp; pos.getIndex() &lt; text.length())) {</span>
            String abbr;
<span class="nc bnc" id="L1941" title="All 2 branches missed.">            if (text.length() &gt; 64) {</span>
<span class="nc" id="L1942">                abbr = text.subSequence(0, 64).toString() + &quot;...&quot;;</span>
            } else {
<span class="nc" id="L1944">                abbr = text.toString();</span>
            }
<span class="nc bnc" id="L1946" title="All 2 branches missed.">            if (pos.getErrorIndex() &gt;= 0) {</span>
<span class="nc" id="L1947">                throw new DateTimeParseException(&quot;Text '&quot; + abbr + &quot;' could not be parsed at index &quot; +</span>
<span class="nc" id="L1948">                        pos.getErrorIndex(), text, pos.getErrorIndex());</span>
            } else {
<span class="nc" id="L1950">                throw new DateTimeParseException(&quot;Text '&quot; + abbr + &quot;' could not be parsed, unparsed text found at index &quot; +</span>
<span class="nc" id="L1951">                        pos.getIndex(), text, pos.getIndex());</span>
            }
        }
<span class="nc" id="L1954">        return unresolved.resolve(resolverStyle, resolverFields);</span>
    }

    /**
     * Parses the text using this formatter, without resolving the result, intended
     * for advanced use cases.
     * &lt;p&gt;
     * Parsing is implemented as a two-phase operation.
     * First, the text is parsed using the layout defined by the formatter, producing
     * a {@code Map} of field to value, a {@code ZoneId} and a {@code Chronology}.
     * Second, the parsed data is &lt;em&gt;resolved&lt;/em&gt;, by validating, combining and
     * simplifying the various fields into more useful ones.
     * This method performs the parsing stage but not the resolving stage.
     * &lt;p&gt;
     * The result of this method is {@code TemporalAccessor} which represents the
     * data as seen in the input. Values are not validated, thus parsing a date string
     * of '2012-00-65' would result in a temporal with three fields - year of '2012',
     * month of '0' and day-of-month of '65'.
     * &lt;p&gt;
     * The text will be parsed from the specified start {@code ParsePosition}.
     * The entire length of the text does not have to be parsed, the {@code ParsePosition}
     * will be updated with the index at the end of parsing.
     * &lt;p&gt;
     * Errors are returned using the error index field of the {@code ParsePosition}
     * instead of {@code DateTimeParseException}.
     * The returned error index will be set to an index indicative of the error.
     * Callers must check for errors before using the context.
     * &lt;p&gt;
     * If the formatter parses the same field more than once with different values,
     * the result will be an error.
     * &lt;p&gt;
     * This method is intended for advanced use cases that need access to the
     * internal state during parsing. Typical application code should use
     * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.
     *
     * @param text  the text to parse, not null
     * @param position  the position to parse from, updated with length parsed
     *  and the index of any error, not null
     * @return the parsed text, null if the parse results in an error
     * @throws DateTimeException if some problem occurs during parsing
     * @throws IndexOutOfBoundsException if the position is invalid
     */
    public TemporalAccessor parseUnresolved(CharSequence text, ParsePosition position) {
<span class="nc" id="L1997">        return parseUnresolved0(text, position);</span>
    }

    private Parsed parseUnresolved0(CharSequence text, ParsePosition position) {
<span class="nc" id="L2001">        Objects.requireNonNull(text, &quot;text&quot;);</span>
<span class="nc" id="L2002">        Objects.requireNonNull(position, &quot;position&quot;);</span>
<span class="nc" id="L2003">        DateTimeParseContext context = new DateTimeParseContext(this);</span>
<span class="nc" id="L2004">        int pos = position.getIndex();</span>
<span class="nc" id="L2005">        pos = printerParser.parse(context, text, pos);</span>
<span class="nc bnc" id="L2006" title="All 2 branches missed.">        if (pos &lt; 0) {</span>
<span class="nc" id="L2007">            position.setErrorIndex(~pos);  // index not updated from input</span>
<span class="nc" id="L2008">            return null;</span>
        }
<span class="nc" id="L2010">        position.setIndex(pos);  // errorIndex not updated from input</span>
<span class="nc" id="L2011">        return context.toParsed();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns the formatter as a composite printer parser.
     *
     * @param optional  whether the printer/parser should be optional
     * @return the printer/parser, not null
     */
    CompositePrinterParser toPrinterParser(boolean optional) {
<span class="nc" id="L2022">        return printerParser.withOptional(optional);</span>
    }

    /**
     * Returns this formatter as a {@code java.text.Format} instance.
     * &lt;p&gt;
     * The returned {@link Format} instance will format any {@link TemporalAccessor}
     * and parses to a resolved {@link TemporalAccessor}.
     * &lt;p&gt;
     * Exceptions will follow the definitions of {@code Format}, see those methods
     * for details about {@code IllegalArgumentException} during formatting and
     * {@code ParseException} or null during parsing.
     * The format does not support attributing of the returned format string.
     *
     * @return this formatter as a classic format instance, not null
     */
    public Format toFormat() {
<span class="nc" id="L2039">        return new ClassicFormat(this, null);</span>
    }

    /**
     * Returns this formatter as a {@code java.text.Format} instance that will
     * parse using the specified query.
     * &lt;p&gt;
     * The returned {@link Format} instance will format any {@link TemporalAccessor}
     * and parses to the type specified.
     * The type must be one that is supported by {@link #parse}.
     * &lt;p&gt;
     * Exceptions will follow the definitions of {@code Format}, see those methods
     * for details about {@code IllegalArgumentException} during formatting and
     * {@code ParseException} or null during parsing.
     * The format does not support attributing of the returned format string.
     *
     * @param parseQuery  the query defining the type to parse to, not null
     * @return this formatter as a classic format instance, not null
     */
    public Format toFormat(TemporalQuery&lt;?&gt; parseQuery) {
<span class="nc" id="L2059">        Objects.requireNonNull(parseQuery, &quot;parseQuery&quot;);</span>
<span class="nc" id="L2060">        return new ClassicFormat(this, parseQuery);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a description of the underlying formatters.
     *
     * @return a description of this formatter, not null
     */
    @Override
    public String toString() {
<span class="nc" id="L2071">        String pattern = printerParser.toString();</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">        pattern = pattern.startsWith(&quot;[&quot;) ? pattern : pattern.substring(1, pattern.length() - 1);</span>
<span class="nc" id="L2073">        return pattern;</span>
        // TODO: Fix tests to not depend on toString()
//        return &quot;DateTimeFormatter[&quot; + locale +
//                (chrono != null ? &quot;,&quot; + chrono : &quot;&quot;) +
//                (zone != null ? &quot;,&quot; + zone : &quot;&quot;) +
//                pattern + &quot;]&quot;;
    }

    //-----------------------------------------------------------------------
    /**
     * Implements the classic Java Format API.
     * @serial exclude
     */
    @SuppressWarnings(&quot;serial&quot;)  // not actually serializable
    static class ClassicFormat extends Format {
        /** The formatter. */
        private final DateTimeFormatter formatter;
        /** The type to be parsed. */
        private final TemporalQuery&lt;?&gt; parseType;
        /** Constructor. */
<span class="nc" id="L2093">        public ClassicFormat(DateTimeFormatter formatter, TemporalQuery&lt;?&gt; parseType) {</span>
<span class="nc" id="L2094">            this.formatter = formatter;</span>
<span class="nc" id="L2095">            this.parseType = parseType;</span>
<span class="nc" id="L2096">        }</span>

        @Override
        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
<span class="nc" id="L2100">            Objects.requireNonNull(obj, &quot;obj&quot;);</span>
<span class="nc" id="L2101">            Objects.requireNonNull(toAppendTo, &quot;toAppendTo&quot;);</span>
<span class="nc" id="L2102">            Objects.requireNonNull(pos, &quot;pos&quot;);</span>
<span class="nc bnc" id="L2103" title="All 2 branches missed.">            if (obj instanceof TemporalAccessor == false) {</span>
<span class="nc" id="L2104">                throw new IllegalArgumentException(&quot;Format target must implement TemporalAccessor&quot;);</span>
            }
<span class="nc" id="L2106">            pos.setBeginIndex(0);</span>
<span class="nc" id="L2107">            pos.setEndIndex(0);</span>
            try {
<span class="nc" id="L2109">                formatter.formatTo((TemporalAccessor) obj, toAppendTo);</span>
<span class="nc" id="L2110">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L2111">                throw new IllegalArgumentException(ex.getMessage(), ex);</span>
<span class="nc" id="L2112">            }</span>
<span class="nc" id="L2113">            return toAppendTo;</span>
        }
        @Override
        public Object parseObject(String text) throws ParseException {
<span class="nc" id="L2117">            Objects.requireNonNull(text, &quot;text&quot;);</span>
            try {
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                if (parseType == null) {</span>
<span class="nc" id="L2120">                    return formatter.parseResolved0(text, null);</span>
                }
<span class="nc" id="L2122">                return formatter.parse(text, parseType);</span>
<span class="nc" id="L2123">            } catch (DateTimeParseException ex) {</span>
<span class="nc" id="L2124">                throw new ParseException(ex.getMessage(), ex.getErrorIndex());</span>
<span class="nc" id="L2125">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L2126">                throw (ParseException) new ParseException(ex.getMessage(), 0).initCause(ex);</span>
            }
        }
        @Override
        public Object parseObject(String text, ParsePosition pos) {
<span class="nc" id="L2131">            Objects.requireNonNull(text, &quot;text&quot;);</span>
            Parsed unresolved;
            try {
<span class="nc" id="L2134">                unresolved = formatter.parseUnresolved0(text, pos);</span>
<span class="nc" id="L2135">            } catch (IndexOutOfBoundsException ex) {</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">                if (pos.getErrorIndex() &lt; 0) {</span>
<span class="nc" id="L2137">                    pos.setErrorIndex(0);</span>
                }
<span class="nc" id="L2139">                return null;</span>
<span class="nc" id="L2140">            }</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">            if (unresolved == null) {</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                if (pos.getErrorIndex() &lt; 0) {</span>
<span class="nc" id="L2143">                    pos.setErrorIndex(0);</span>
                }
<span class="nc" id="L2145">                return null;</span>
            }
            try {
<span class="nc" id="L2148">                TemporalAccessor resolved = unresolved.resolve(formatter.resolverStyle, formatter.resolverFields);</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                if (parseType == null) {</span>
<span class="nc" id="L2150">                    return resolved;</span>
                }
<span class="nc" id="L2152">                return resolved.query(parseType);</span>
<span class="nc" id="L2153">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L2154">                pos.setErrorIndex(0);</span>
<span class="nc" id="L2155">                return null;</span>
            }
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>