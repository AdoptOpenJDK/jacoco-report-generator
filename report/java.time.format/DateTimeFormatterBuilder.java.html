<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DateTimeFormatterBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.format</a> &gt; <span class="el_source">DateTimeFormatterBuilder.java</span></div><h1>DateTimeFormatterBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.format;

import static java.time.temporal.ChronoField.DAY_OF_MONTH;
import static java.time.temporal.ChronoField.HOUR_OF_DAY;
import static java.time.temporal.ChronoField.INSTANT_SECONDS;
import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
import static java.time.temporal.ChronoField.NANO_OF_SECOND;
import static java.time.temporal.ChronoField.OFFSET_SECONDS;
import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
import static java.time.temporal.ChronoField.YEAR;

import java.lang.ref.SoftReference;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.text.ParsePosition;
import java.time.DateTimeException;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.chrono.ChronoLocalDate;
import java.time.chrono.Chronology;
import java.time.chrono.IsoChronology;
import java.time.format.DateTimeTextProvider.LocaleStore;
import java.time.temporal.ChronoField;
import java.time.temporal.IsoFields;
import java.time.temporal.TemporalAccessor;
import java.time.temporal.TemporalField;
import java.time.temporal.TemporalQueries;
import java.time.temporal.TemporalQuery;
import java.time.temporal.ValueRange;
import java.time.temporal.WeekFields;
import java.time.zone.ZoneRulesProvider;
import java.util.AbstractMap.SimpleImmutableEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleResources;
import sun.util.locale.provider.TimeZoneNameUtility;

/**
 * Builder to create date-time formatters.
 * &lt;p&gt;
 * This allows a {@code DateTimeFormatter} to be created.
 * All date-time formatters are created ultimately using this builder.
 * &lt;p&gt;
 * The basic elements of date-time can all be added:
 * &lt;ul&gt;
 * &lt;li&gt;Value - a numeric value&lt;/li&gt;
 * &lt;li&gt;Fraction - a fractional value including the decimal place. Always use this when
 * outputting fractions to ensure that the fraction is parsed correctly&lt;/li&gt;
 * &lt;li&gt;Text - the textual equivalent for the value&lt;/li&gt;
 * &lt;li&gt;OffsetId/Offset - the {@linkplain ZoneOffset zone offset}&lt;/li&gt;
 * &lt;li&gt;ZoneId - the {@linkplain ZoneId time-zone} id&lt;/li&gt;
 * &lt;li&gt;ZoneText - the name of the time-zone&lt;/li&gt;
 * &lt;li&gt;ChronologyId - the {@linkplain Chronology chronology} id&lt;/li&gt;
 * &lt;li&gt;ChronologyText - the name of the chronology&lt;/li&gt;
 * &lt;li&gt;Literal - a text literal&lt;/li&gt;
 * &lt;li&gt;Nested and Optional - formats can be nested or made optional&lt;/li&gt;
 * &lt;li&gt;Other - the printer and parser interfaces can be used to add user supplied formatting&lt;/li&gt;
 * &lt;/ul&gt;
 * In addition, any of the elements may be decorated by padding, either with spaces or any other character.
 * &lt;p&gt;
 * Finally, a shorthand pattern, mostly compatible with {@code java.text.SimpleDateFormat SimpleDateFormat}
 * can be used, see {@link #appendPattern(String)}.
 * In practice, this simply parses the pattern and calls other methods on the builder.
 *
 * @implSpec
 * This class is a mutable builder intended for use from a single thread.
 *
 * @since 1.8
 */
public final class DateTimeFormatterBuilder {

    /**
     * Query for a time-zone that is region-only.
     */
<span class="nc" id="L158">    private static final TemporalQuery&lt;ZoneId&gt; QUERY_REGION_ONLY = (temporal) -&gt; {</span>
        ZoneId zone = temporal.query(TemporalQueries.zoneId());
        return (zone != null &amp;&amp; zone instanceof ZoneOffset == false ? zone : null);
    };

    /**
     * The currently active builder, used by the outermost builder.
     */
<span class="nc" id="L166">    private DateTimeFormatterBuilder active = this;</span>
    /**
     * The parent builder, null for the outermost builder.
     */
    private final DateTimeFormatterBuilder parent;
    /**
     * The list of printers that will be used.
     */
<span class="nc" id="L174">    private final List&lt;DateTimePrinterParser&gt; printerParsers = new ArrayList&lt;&gt;();</span>
    /**
     * Whether this builder produces an optional formatter.
     */
    private final boolean optional;
    /**
     * The width to pad the next field to.
     */
    private int padNextWidth;
    /**
     * The character to pad the next field with.
     */
    private char padNextChar;
    /**
     * The index of the last variable width value parser.
     */
<span class="nc" id="L190">    private int valueParserIndex = -1;</span>

    /**
     * Gets the formatting pattern for date and time styles for a locale and chronology.
     * The locale and chronology are used to lookup the locale specific format
     * for the requested dateStyle and/or timeStyle.
     *
     * @param dateStyle  the FormatStyle for the date
     * @param timeStyle  the FormatStyle for the time
     * @param chrono  the Chronology, non-null
     * @param locale  the locale, non-null
     * @return the locale and Chronology specific formatting pattern
     * @throws IllegalArgumentException if both dateStyle and timeStyle are null
     */
    public static String getLocalizedDateTimePattern(FormatStyle dateStyle, FormatStyle timeStyle,
            Chronology chrono, Locale locale) {
<span class="nc" id="L206">        Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc" id="L207">        Objects.requireNonNull(chrono, &quot;chrono&quot;);</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">        if (dateStyle == null &amp;&amp; timeStyle == null) {</span>
<span class="nc" id="L209">            throw new IllegalArgumentException(&quot;Either dateStyle or timeStyle must be non-null&quot;);</span>
        }
<span class="nc" id="L211">        LocaleResources lr = LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale);</span>
<span class="nc" id="L212">        String pattern = lr.getJavaTimeDateTimePattern(</span>
<span class="nc" id="L213">                convertStyle(timeStyle), convertStyle(dateStyle), chrono.getCalendarType());</span>
<span class="nc" id="L214">        return pattern;</span>
    }

    /**
     * Converts the given FormatStyle to the java.text.DateFormat style.
     *
     * @param style  the FormatStyle style
     * @return the int style, or -1 if style is null, indicating un-required
     */
    private static int convertStyle(FormatStyle style) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (style == null) {</span>
<span class="nc" id="L225">            return -1;</span>
        }
<span class="nc" id="L227">        return style.ordinal();  // indices happen to align</span>
    }

    /**
     * Constructs a new instance of the builder.
     */
    public DateTimeFormatterBuilder() {
<span class="nc" id="L234">        super();</span>
<span class="nc" id="L235">        parent = null;</span>
<span class="nc" id="L236">        optional = false;</span>
<span class="nc" id="L237">    }</span>

    /**
     * Constructs a new instance of the builder.
     *
     * @param parent  the parent builder, not null
     * @param optional  whether the formatter is optional, not null
     */
    private DateTimeFormatterBuilder(DateTimeFormatterBuilder parent, boolean optional) {
<span class="nc" id="L246">        super();</span>
<span class="nc" id="L247">        this.parent = parent;</span>
<span class="nc" id="L248">        this.optional = optional;</span>
<span class="nc" id="L249">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Changes the parse style to be case sensitive for the remainder of the formatter.
     * &lt;p&gt;
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     * &lt;p&gt;
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case sensitive mode.
     * See {@link #parseCaseInsensitive} for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     * &lt;p&gt;
     * Since the default is case sensitive, this method should only be used after
     * a previous call to {@code #parseCaseInsensitive}.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder parseCaseSensitive() {
<span class="nc" id="L271">        appendInternal(SettingsParser.SENSITIVE);</span>
<span class="nc" id="L272">        return this;</span>
    }

    /**
     * Changes the parse style to be case insensitive for the remainder of the formatter.
     * &lt;p&gt;
     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
     * This method allows the case sensitivity setting of parsing to be changed.
     * &lt;p&gt;
     * Calling this method changes the state of the builder such that all
     * subsequent builder method calls will parse text in case insensitive mode.
     * See {@link #parseCaseSensitive()} for the opposite setting.
     * The parse case sensitive/insensitive methods may be called at any point
     * in the builder, thus the parser can swap between case parsing modes
     * multiple times during the parse.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder parseCaseInsensitive() {
<span class="nc" id="L291">        appendInternal(SettingsParser.INSENSITIVE);</span>
<span class="nc" id="L292">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Changes the parse style to be strict for the remainder of the formatter.
     * &lt;p&gt;
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     * &lt;p&gt;
     * When used, this method changes the parsing to be strict from this point onwards.
     * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until {@code parseLenient} is called.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder parseStrict() {
<span class="nc" id="L310">        appendInternal(SettingsParser.STRICT);</span>
<span class="nc" id="L311">        return this;</span>
    }

    /**
     * Changes the parse style to be lenient for the remainder of the formatter.
     * Note that case sensitivity is set separately to this method.
     * &lt;p&gt;
     * Parsing can be strict or lenient - by default its strict.
     * This controls the degree of flexibility in matching the text and sign styles.
     * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
     * &lt;p&gt;
     * When used, this method changes the parsing to be lenient from this point onwards.
     * The change will remain in force until the end of the formatter that is eventually
     * constructed or until {@code parseStrict} is called.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder parseLenient() {
<span class="nc" id="L329">        appendInternal(SettingsParser.LENIENT);</span>
<span class="nc" id="L330">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a default value for a field to the formatter for use in parsing.
     * &lt;p&gt;
     * This appends an instruction to the builder to inject a default value
     * into the parsed result. This is especially useful in conjunction with
     * optional parts of the formatter.
     * &lt;p&gt;
     * For example, consider a formatter that parses the year, followed by
     * an optional month, with a further optional day-of-month. Using such a
     * formatter would require the calling code to check whether a full date,
     * year-month or just a year had been parsed. This method can be used to
     * default the month and day-of-month to a sensible value, such as the
     * first of the month, allowing the calling code to always get a date.
     * &lt;p&gt;
     * During formatting, this method has no effect.
     * &lt;p&gt;
     * During parsing, the current state of the parse is inspected.
     * If the specified field has no associated value, because it has not been
     * parsed successfully at that point, then the specified value is injected
     * into the parse result. Injection is immediate, thus the field-value pair
     * will be visible to any subsequent elements in the formatter.
     * As such, this method is normally called at the end of the builder.
     *
     * @param field  the field to default the value of, not null
     * @param value  the value to default the field to
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder parseDefaulting(TemporalField field, long value) {
<span class="nc" id="L362">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L363">        appendInternal(new DefaultValueParser(field, value));</span>
<span class="nc" id="L364">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the value of a date-time field to the formatter using a normal
     * output style.
     * &lt;p&gt;
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     * &lt;p&gt;
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     * &lt;p&gt;
     * The parser for a variable width value such as this normally behaves greedily,
     * requiring one digit, but accepting as many digits as possible.
     * This behavior can be affected by 'adjacent value parsing'.
     * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
     *
     * @param field  the field to append, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendValue(TemporalField field) {
<span class="nc" id="L387">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L388">        appendValue(new NumberPrinterParser(field, 1, 19, SignStyle.NORMAL));</span>
<span class="nc" id="L389">        return this;</span>
    }

    /**
     * Appends the value of a date-time field to the formatter using a fixed
     * width, zero-padded approach.
     * &lt;p&gt;
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     * &lt;p&gt;
     * The value will be zero-padded on the left. If the size of the value
     * means that it cannot be printed within the width then an exception is thrown.
     * If the value of the field is negative then an exception is thrown during formatting.
     * &lt;p&gt;
     * This method supports a special technique of parsing known as 'adjacent value parsing'.
     * This technique solves the problem where a value, variable or fixed width, is followed by one or more
     * fixed length values. The standard parser is greedy, and thus it would normally
     * steal the digits that are needed by the fixed width value parsers that follow the
     * variable width one.
     * &lt;p&gt;
     * No action is required to initiate 'adjacent value parsing'.
     * When a call to {@code appendValue} is made, the builder
     * enters adjacent value parsing setup mode. If the immediately subsequent method
     * call or calls on the same builder are for a fixed width value, then the parser will reserve
     * space so that the fixed width values can be parsed.
     * &lt;p&gt;
     * For example, consider {@code builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);}
     * The year is a variable width parse of between 1 and 19 digits.
     * The month is a fixed width parse of 2 digits.
     * Because these were appended to the same builder immediately after one another,
     * the year parser will reserve two digits for the month to parse.
     * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.
     * Without adjacent value parsing, the year would greedily parse all six digits and leave
     * nothing for the month.
     * &lt;p&gt;
     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser
     * that immediately follow any kind of value, variable or fixed width.
     * Calling any other append method will end the setup of adjacent value parsing.
     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
     * simply add the {@code appendValue} to another {@code DateTimeFormatterBuilder}
     * and add that to this builder.
     * &lt;p&gt;
     * If adjacent parsing is active, then parsing must match exactly the specified
     * number of digits in both strict and lenient modes.
     * In addition, no positive or negative sign is permitted.
     *
     * @param field  the field to append, not null
     * @param width  the width of the printed field, from 1 to 19
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width is invalid
     */
    public DateTimeFormatterBuilder appendValue(TemporalField field, int width) {
<span class="nc" id="L441">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc bnc" id="L442" title="All 4 branches missed.">        if (width &lt; 1 || width &gt; 19) {</span>
<span class="nc" id="L443">            throw new IllegalArgumentException(&quot;The width must be from 1 to 19 inclusive but was &quot; + width);</span>
        }
<span class="nc" id="L445">        NumberPrinterParser pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);</span>
<span class="nc" id="L446">        appendValue(pp);</span>
<span class="nc" id="L447">        return this;</span>
    }

    /**
     * Appends the value of a date-time field to the formatter providing full
     * control over formatting.
     * &lt;p&gt;
     * The value of the field will be output during a format.
     * If the value cannot be obtained then an exception will be thrown.
     * &lt;p&gt;
     * This method provides full control of the numeric formatting, including
     * zero-padding and the positive/negative sign.
     * &lt;p&gt;
     * The parser for a variable width value such as this normally behaves greedily,
     * accepting as many digits as possible.
     * This behavior can be affected by 'adjacent value parsing'.
     * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
     * &lt;p&gt;
     * In strict parsing mode, the minimum number of parsed digits is {@code minWidth}
     * and the maximum is {@code maxWidth}.
     * In lenient parsing mode, the minimum number of parsed digits is one
     * and the maximum is 19 (except as limited by adjacent value parsing).
     * &lt;p&gt;
     * If this method is invoked with equal minimum and maximum widths and a sign style of
     * {@code NOT_NEGATIVE} then it delegates to {@code appendValue(TemporalField,int)}.
     * In this scenario, the formatting and parsing behavior described there occur.
     *
     * @param field  the field to append, not null
     * @param minWidth  the minimum field width of the printed field, from 1 to 19
     * @param maxWidth  the maximum field width of the printed field, from 1 to 19
     * @param signStyle  the positive/negative output style, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the widths are invalid
     */
    public DateTimeFormatterBuilder appendValue(
            TemporalField field, int minWidth, int maxWidth, SignStyle signStyle) {
<span class="nc bnc" id="L483" title="All 4 branches missed.">        if (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) {</span>
<span class="nc" id="L484">            return appendValue(field, maxWidth);</span>
        }
<span class="nc" id="L486">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L487">        Objects.requireNonNull(signStyle, &quot;signStyle&quot;);</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">        if (minWidth &lt; 1 || minWidth &gt; 19) {</span>
<span class="nc" id="L489">            throw new IllegalArgumentException(&quot;The minimum width must be from 1 to 19 inclusive but was &quot; + minWidth);</span>
        }
<span class="nc bnc" id="L491" title="All 4 branches missed.">        if (maxWidth &lt; 1 || maxWidth &gt; 19) {</span>
<span class="nc" id="L492">            throw new IllegalArgumentException(&quot;The maximum width must be from 1 to 19 inclusive but was &quot; + maxWidth);</span>
        }
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (maxWidth &lt; minWidth) {</span>
<span class="nc" id="L495">            throw new IllegalArgumentException(&quot;The maximum width must exceed or equal the minimum width but &quot; +</span>
                    maxWidth + &quot; &lt; &quot; + minWidth);
        }
<span class="nc" id="L498">        NumberPrinterParser pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);</span>
<span class="nc" id="L499">        appendValue(pp);</span>
<span class="nc" id="L500">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the reduced value of a date-time field to the formatter.
     * &lt;p&gt;
     * Since fields such as year vary by chronology, it is recommended to use the
     * {@link #appendValueReduced(TemporalField, int, int, ChronoLocalDate)} date}
     * variant of this method in most cases. This variant is suitable for
     * simple fields or working with only the ISO chronology.
     * &lt;p&gt;
     * For formatting, the {@code width} and {@code maxWidth} are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the {@code baseValue} using
     * {@code width} characters then the reduced value is formatted otherwise the value is
     * truncated to fit {@code maxWidth}.
     * The rightmost characters are output to match the width, left padding with zero.
     * &lt;p&gt;
     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to {@code width} and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the {@code baseValue} with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     * &lt;p&gt;
     * For example, a base value of {@code 1980} and a width of {@code 2} will have
     * valid values from {@code 1980} to {@code 2079}.
     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that
     * is the value within the range where the last two characters are &quot;12&quot;.
     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.
     *
     * @param field  the field to append, not null
     * @param width  the field width of the printed and parsed field, from 1 to 10
     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param baseValue  the base value of the range of valid values
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    public DateTimeFormatterBuilder appendValueReduced(TemporalField field,
            int width, int maxWidth, int baseValue) {
<span class="nc" id="L544">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L545">        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);</span>
<span class="nc" id="L546">        appendValue(pp);</span>
<span class="nc" id="L547">        return this;</span>
    }

    /**
     * Appends the reduced value of a date-time field to the formatter.
     * &lt;p&gt;
     * This is typically used for formatting and parsing a two digit year.
     * &lt;p&gt;
     * The base date is used to calculate the full value during parsing.
     * For example, if the base date is 1950-01-01 then parsed values for
     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
     * Only the year would be extracted from the date, thus a base date of
     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
     * This behavior is necessary to support fields such as week-based-year
     * or other calendar systems where the parsed value does not align with
     * standard ISO years.
     * &lt;p&gt;
     * The exact behavior is as follows. Parse the full set of fields and
     * determine the effective chronology using the last chronology if
     * it appears more than once. Then convert the base date to the
     * effective chronology. Then extract the specified field from the
     * chronology-specific base date and use it to determine the
     * {@code baseValue} used below.
     * &lt;p&gt;
     * For formatting, the {@code width} and {@code maxWidth} are used to
     * determine the number of characters to format.
     * If they are equal then the format is fixed width.
     * If the value of the field is within the range of the {@code baseValue} using
     * {@code width} characters then the reduced value is formatted otherwise the value is
     * truncated to fit {@code maxWidth}.
     * The rightmost characters are output to match the width, left padding with zero.
     * &lt;p&gt;
     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
     * For lenient parsing, the number of characters must be at least 1 and less than 10.
     * If the number of digits parsed is equal to {@code width} and the value is positive,
     * the value of the field is computed to be the first number greater than
     * or equal to the {@code baseValue} with the same least significant characters,
     * otherwise the value parsed is the field value.
     * This allows a reduced value to be entered for values in range of the baseValue
     * and width and absolute values can be entered for values outside the range.
     * &lt;p&gt;
     * For example, a base value of {@code 1980} and a width of {@code 2} will have
     * valid values from {@code 1980} to {@code 2079}.
     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that
     * is the value within the range where the last two characters are &quot;12&quot;.
     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.
     *
     * @param field  the field to append, not null
     * @param width  the field width of the printed and parsed field, from 1 to 10
     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
     * @param baseDate  the base date used to calculate the base value for the range
     *  of valid values in the parsed chronology, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the width or base value is invalid
     */
    public DateTimeFormatterBuilder appendValueReduced(
            TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {
<span class="nc" id="L604">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L605">        Objects.requireNonNull(baseDate, &quot;baseDate&quot;);</span>
<span class="nc" id="L606">        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);</span>
<span class="nc" id="L607">        appendValue(pp);</span>
<span class="nc" id="L608">        return this;</span>
    }

    /**
     * Appends a fixed or variable width printer-parser handling adjacent value mode.
     * If a PrinterParser is not active then the new PrinterParser becomes
     * the active PrinterParser.
     * Otherwise, the active PrinterParser is modified depending on the new PrinterParser.
     * If the new PrinterParser is fixed width and has sign style {@code NOT_NEGATIVE}
     * then its width is added to the active PP and
     * the new PrinterParser is forced to be fixed width.
     * If the new PrinterParser is variable width, the active PrinterParser is changed
     * to be fixed width and the new PrinterParser becomes the active PP.
     *
     * @param pp  the printer-parser, not null
     * @return this, for chaining, not null
     */
    private DateTimeFormatterBuilder appendValue(NumberPrinterParser pp) {
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (active.valueParserIndex &gt;= 0) {</span>
<span class="nc" id="L627">            final int activeValueParser = active.valueParserIndex;</span>

            // adjacent parsing mode, update setting in previous parsers
<span class="nc" id="L630">            NumberPrinterParser basePP = (NumberPrinterParser) active.printerParsers.get(activeValueParser);</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">            if (pp.minWidth == pp.maxWidth &amp;&amp; pp.signStyle == SignStyle.NOT_NEGATIVE) {</span>
                // Append the width to the subsequentWidth of the active parser
<span class="nc" id="L633">                basePP = basePP.withSubsequentWidth(pp.maxWidth);</span>
                // Append the new parser as a fixed width
<span class="nc" id="L635">                appendInternal(pp.withFixedWidth());</span>
                // Retain the previous active parser
<span class="nc" id="L637">                active.valueParserIndex = activeValueParser;</span>
            } else {
                // Modify the active parser to be fixed width
<span class="nc" id="L640">                basePP = basePP.withFixedWidth();</span>
                // The new parser becomes the mew active parser
<span class="nc" id="L642">                active.valueParserIndex = appendInternal(pp);</span>
            }
            // Replace the modified parser with the updated one
<span class="nc" id="L645">            active.printerParsers.set(activeValueParser, basePP);</span>
<span class="nc" id="L646">        } else {</span>
            // The new Parser becomes the active parser
<span class="nc" id="L648">            active.valueParserIndex = appendInternal(pp);</span>
        }
<span class="nc" id="L650">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the fractional value of a date-time field to the formatter.
     * &lt;p&gt;
     * The fractional value of the field will be output including the
     * preceding decimal point. The preceding value is not output.
     * For example, the second-of-minute value of 15 would be output as {@code .25}.
     * &lt;p&gt;
     * The width of the printed fraction can be controlled. Setting the
     * minimum width to zero will cause no output to be generated.
     * The printed fraction will have the minimum width necessary between
     * the minimum and maximum widths - trailing zeroes are omitted.
     * No rounding occurs due to the maximum width - digits are simply dropped.
     * &lt;p&gt;
     * When parsing in strict mode, the number of parsed digits must be between
     * the minimum and maximum width. When parsing in lenient mode, the minimum
     * width is considered to be zero and the maximum is nine.
     * &lt;p&gt;
     * If the value cannot be obtained then an exception will be thrown.
     * If the value is negative an exception will be thrown.
     * If the field does not have a fixed set of valid values then an
     * exception will be thrown.
     * If the field value in the date-time to be printed is invalid it
     * cannot be printed and an exception will be thrown.
     *
     * @param field  the field to append, not null
     * @param minWidth  the minimum width of the field excluding the decimal point, from 0 to 9
     * @param maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9
     * @param decimalPoint  whether to output the localized decimal point symbol
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the field has a variable set of valid values or
     *  either width is invalid
     */
    public DateTimeFormatterBuilder appendFraction(
            TemporalField field, int minWidth, int maxWidth, boolean decimalPoint) {
<span class="nc" id="L688">        appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));</span>
<span class="nc" id="L689">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the text of a date-time field to the formatter using the full
     * text style.
     * &lt;p&gt;
     * The text of the field will be output during a format.
     * The value must be within the valid range of the field.
     * If the value cannot be obtained then an exception will be thrown.
     * If the field has no textual representation, then the numeric value will be used.
     * &lt;p&gt;
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     *
     * @param field  the field to append, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendText(TemporalField field) {
<span class="nc" id="L709">        return appendText(field, TextStyle.FULL);</span>
    }

    /**
     * Appends the text of a date-time field to the formatter.
     * &lt;p&gt;
     * The text of the field will be output during a format.
     * The value must be within the valid range of the field.
     * If the value cannot be obtained then an exception will be thrown.
     * If the field has no textual representation, then the numeric value will be used.
     * &lt;p&gt;
     * The value will be printed as per the normal format of an integer value.
     * Only negative numbers will be signed. No padding will be added.
     *
     * @param field  the field to append, not null
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendText(TemporalField field, TextStyle textStyle) {
<span class="nc" id="L728">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L729">        Objects.requireNonNull(textStyle, &quot;textStyle&quot;);</span>
<span class="nc" id="L730">        appendInternal(new TextPrinterParser(field, textStyle, DateTimeTextProvider.getInstance()));</span>
<span class="nc" id="L731">        return this;</span>
    }

    /**
     * Appends the text of a date-time field to the formatter using the specified
     * map to supply the text.
     * &lt;p&gt;
     * The standard text outputting methods use the localized text in the JDK.
     * This method allows that text to be specified directly.
     * The supplied map is not validated by the builder to ensure that formatting or
     * parsing is possible, thus an invalid map may throw an error during later use.
     * &lt;p&gt;
     * Supplying the map of text provides considerable flexibility in formatting and parsing.
     * For example, a legacy application might require or supply the months of the
     * year as &quot;JNY&quot;, &quot;FBY&quot;, &quot;MCH&quot; etc. These do not match the standard set of text
     * for localized month names. Using this method, a map can be created which
     * defines the connection between each value and the text:
     * &lt;pre&gt;
     * Map&amp;lt;Long, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
     * map.put(1, &quot;JNY&quot;);
     * map.put(2, &quot;FBY&quot;);
     * map.put(3, &quot;MCH&quot;);
     * ...
     * builder.appendText(MONTH_OF_YEAR, map);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Other uses might be to output the value with a suffix, such as &quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;,
     * or as Roman numerals &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;.
     * &lt;p&gt;
     * During formatting, the value is obtained and checked that it is in the valid range.
     * If text is not available for the value then it is output as a number.
     * During parsing, the parser will match against the map of text and numeric values.
     *
     * @param field  the field to append, not null
     * @param textLookup  the map from the value to the text
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendText(TemporalField field, Map&lt;Long, String&gt; textLookup) {
<span class="nc" id="L769">        Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc" id="L770">        Objects.requireNonNull(textLookup, &quot;textLookup&quot;);</span>
<span class="nc" id="L771">        Map&lt;Long, String&gt; copy = new LinkedHashMap&lt;&gt;(textLookup);</span>
<span class="nc" id="L772">        Map&lt;TextStyle, Map&lt;Long, String&gt;&gt; map = Collections.singletonMap(TextStyle.FULL, copy);</span>
<span class="nc" id="L773">        final LocaleStore store = new LocaleStore(map);</span>
<span class="nc" id="L774">        DateTimeTextProvider provider = new DateTimeTextProvider() {</span>
            @Override
            public String getText(TemporalField field, long value, TextStyle style, Locale locale) {
<span class="nc" id="L777">                return store.getText(value, style);</span>
            }
            @Override
            public Iterator&lt;Entry&lt;String, Long&gt;&gt; getTextIterator(TemporalField field, TextStyle style, Locale locale) {
<span class="nc" id="L781">                return store.getTextIterator(style);</span>
            }
        };
<span class="nc" id="L784">        appendInternal(new TextPrinterParser(field, TextStyle.FULL, provider));</span>
<span class="nc" id="L785">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends an instant using ISO-8601 to the formatter, formatting fractional
     * digits in groups of three.
     * &lt;p&gt;
     * Instants have a fixed output format.
     * They are converted to a date-time with a zone-offset of UTC and formatted
     * using the standard ISO-8601 format.
     * With this method, formatting nano-of-second outputs zero, three, six
     * or nine digits digits as necessary.
     * The localized decimal style is not used.
     * &lt;p&gt;
     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
     * and optionally (@code NANO_OF_SECOND). The value of {@code INSTANT_SECONDS}
     * may be outside the maximum range of {@code LocalDateTime}.
     * &lt;p&gt;
     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
     * The leap-second time of '23:59:59' is handled to some degree, see
     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
     * &lt;p&gt;
     * An alternative to this method is to format/parse the instant as a single
     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendInstant() {
<span class="nc" id="L815">        appendInternal(new InstantPrinterParser(-2));</span>
<span class="nc" id="L816">        return this;</span>
    }

    /**
     * Appends an instant using ISO-8601 to the formatter with control over
     * the number of fractional digits.
     * &lt;p&gt;
     * Instants have a fixed output format, although this method provides some
     * control over the fractional digits. They are converted to a date-time
     * with a zone-offset of UTC and printed using the standard ISO-8601 format.
     * The localized decimal style is not used.
     * &lt;p&gt;
     * The {@code fractionalDigits} parameter allows the output of the fractional
     * second to be controlled. Specifying zero will cause no fractional digits
     * to be output. From 1 to 9 will output an increasing number of digits, using
     * zero right-padding if necessary. The special value -1 is used to output as
     * many digits as necessary to avoid any trailing zeroes.
     * &lt;p&gt;
     * When parsing in strict mode, the number of parsed digits must match the
     * fractional digits. When parsing in lenient mode, any number of fractional
     * digits from zero to nine are accepted.
     * &lt;p&gt;
     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
     * and optionally (@code NANO_OF_SECOND). The value of {@code INSTANT_SECONDS}
     * may be outside the maximum range of {@code LocalDateTime}.
     * &lt;p&gt;
     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
     * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
     * The leap-second time of '23:59:59' is handled to some degree, see
     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
     * &lt;p&gt;
     * An alternative to this method is to format/parse the instant as a single
     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.
     *
     * @param fractionalDigits  the number of fractional second digits to format with,
     *  from 0 to 9, or -1 to use as many digits as necessary
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendInstant(int fractionalDigits) {
<span class="nc bnc" id="L855" title="All 4 branches missed.">        if (fractionalDigits &lt; -1 || fractionalDigits &gt; 9) {</span>
<span class="nc" id="L856">            throw new IllegalArgumentException(&quot;The fractional digits must be from -1 to 9 inclusive but was &quot; + fractionalDigits);</span>
        }
<span class="nc" id="L858">        appendInternal(new InstantPrinterParser(fractionalDigits));</span>
<span class="nc" id="L859">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the zone offset, such as '+01:00', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the offset ID to the builder.
     * This is equivalent to calling {@code appendOffset(&quot;HH:MM:ss&quot;, &quot;Z&quot;)}.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendOffsetId() {
<span class="nc" id="L872">        appendInternal(OffsetIdPrinterParser.INSTANCE_ID_Z);</span>
<span class="nc" id="L873">        return this;</span>
    }

    /**
     * Appends the zone offset, such as '+01:00', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the offset ID to the builder.
     * &lt;p&gt;
     * During formatting, the offset is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#offset()}.
     * It will be printed using the format defined below.
     * If the offset cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the offset is parsed using the format defined below.
     * If the offset cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * The format of the offset is controlled by a pattern which must be one
     * of the following:
     * &lt;ul&gt;
     * &lt;li&gt;{@code +HH} - hour only, ignoring minute and second
     * &lt;li&gt;{@code +HHmm} - hour, with minute if non-zero, ignoring second, no colon
     * &lt;li&gt;{@code +HH:mm} - hour, with minute if non-zero, ignoring second, with colon
     * &lt;li&gt;{@code +HHMM} - hour and minute, ignoring second, no colon
     * &lt;li&gt;{@code +HH:MM} - hour and minute, ignoring second, with colon
     * &lt;li&gt;{@code +HHMMss} - hour and minute, with second if non-zero, no colon
     * &lt;li&gt;{@code +HH:MM:ss} - hour and minute, with second if non-zero, with colon
     * &lt;li&gt;{@code +HHMMSS} - hour, minute and second, no colon
     * &lt;li&gt;{@code +HH:MM:SS} - hour, minute and second, with colon
     * &lt;/ul&gt;
     * The &quot;no offset&quot; text controls what text is printed when the total amount of
     * the offset fields to be output is zero.
     * Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.
     * Three formats are accepted for parsing UTC - the &quot;no offset&quot; text, and the
     * plus and minus versions of zero defined by the pattern.
     *
     * @param pattern  the pattern to use, not null
     * @param noOffsetText  the text to use when the offset is zero, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendOffset(String pattern, String noOffsetText) {
<span class="nc" id="L915">        appendInternal(new OffsetIdPrinterParser(pattern, noOffsetText));</span>
<span class="nc" id="L916">        return this;</span>
    }

    /**
     * Appends the localized zone offset, such as 'GMT+01:00', to the formatter.
     * &lt;p&gt;
     * This appends a localized zone offset to the builder, the format of the
     * localized offset is controlled by the specified {@link FormatStyle style}
     * to this method:
     * &lt;ul&gt;
     * &lt;li&gt;{@link TextStyle#FULL full} - formats with localized offset text, such
     * as 'GMT, 2-digit hour and minute field, optional second field if non-zero,
     * and colon.
     * &lt;li&gt;{@link TextStyle#SHORT short} - formats with localized offset text,
     * such as 'GMT, hour without leading zero, optional 2-digit minute and
     * second if non-zero, and colon.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * During formatting, the offset is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#offset()}.
     * If the offset cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the offset is parsed using the format defined above.
     * If the offset cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * @param style  the format style to use, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if style is neither {@link TextStyle#FULL
     * full} nor {@link TextStyle#SHORT short}
     */
    public DateTimeFormatterBuilder appendLocalizedOffset(TextStyle style) {
<span class="nc" id="L949">        Objects.requireNonNull(style, &quot;style&quot;);</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">        if (style != TextStyle.FULL &amp;&amp; style != TextStyle.SHORT) {</span>
<span class="nc" id="L951">            throw new IllegalArgumentException(&quot;Style must be either full or short&quot;);</span>
        }
<span class="nc" id="L953">        appendInternal(new LocalizedOffsetIdPrinterParser(style));</span>
<span class="nc" id="L954">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the zone ID to the builder.
     * The zone ID is obtained in a strict manner suitable for {@code ZonedDateTime}.
     * By contrast, {@code OffsetDateTime} does not have a zone ID suitable
     * for use with this method, see {@link #appendZoneOrOffsetId()}.
     * &lt;p&gt;
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#zoneId()}.
     * It will be printed using the result of {@link ZoneId#getId()}.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the text must match a known zone or offset.
     * There are two types of zone ID, offset-based, such as '+01:30' and
     * region-based, such as 'Europe/London'. These are parsed differently.
     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
     * expects an offset-based zone and will not match region-based zones.
     * The offset ID, such as '+02:30', may be at the start of the parse,
     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
     * equivalent to using {@link #appendOffset(String, String)} using the
     * arguments 'HH:MM:ss' and the no offset string '0'.
     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
     * In all other cases, the list of known region-based zones is used to
     * find the longest available match. If no match is found, and the parse
     * starts with 'Z', then {@code ZoneOffset.UTC} is selected.
     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
     * &lt;p&gt;
     * For example, the following will parse:
     * &lt;pre&gt;
     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
     *   &quot;Z&quot;                       -- ZoneOffset.UTC
     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
     * &lt;/pre&gt;
     *
     * @return this, for chaining, not null
     * @see #appendZoneRegionId()
     */
    public DateTimeFormatterBuilder appendZoneId() {
<span class="nc" id="L1005">        appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), &quot;ZoneId()&quot;));</span>
<span class="nc" id="L1006">        return this;</span>
    }

    /**
     * Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,
     * rejecting the zone ID if it is a {@code ZoneOffset}.
     * &lt;p&gt;
     * This appends an instruction to format/parse the zone ID to the builder
     * only if it is a region-based ID.
     * &lt;p&gt;
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#zoneId()}.
     * If the zone is a {@code ZoneOffset} or it cannot be obtained then
     * an exception is thrown unless the section of the formatter is optional.
     * If the zone is not an offset, then the zone will be printed using
     * the zone ID from {@link ZoneId#getId()}.
     * &lt;p&gt;
     * During parsing, the text must match a known zone or offset.
     * There are two types of zone ID, offset-based, such as '+01:30' and
     * region-based, such as 'Europe/London'. These are parsed differently.
     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
     * expects an offset-based zone and will not match region-based zones.
     * The offset ID, such as '+02:30', may be at the start of the parse,
     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
     * equivalent to using {@link #appendOffset(String, String)} using the
     * arguments 'HH:MM:ss' and the no offset string '0'.
     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
     * In all other cases, the list of known region-based zones is used to
     * find the longest available match. If no match is found, and the parse
     * starts with 'Z', then {@code ZoneOffset.UTC} is selected.
     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
     * &lt;p&gt;
     * For example, the following will parse:
     * &lt;pre&gt;
     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
     *   &quot;Z&quot;                       -- ZoneOffset.UTC
     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Note that this method is is identical to {@code appendZoneId()} except
     * in the mechanism used to obtain the zone.
     * Note also that parsing accepts offsets, whereas formatting will never
     * produce one.
     *
     * @return this, for chaining, not null
     * @see #appendZoneId()
     */
    public DateTimeFormatterBuilder appendZoneRegionId() {
<span class="nc" id="L1061">        appendInternal(new ZoneIdPrinterParser(QUERY_REGION_ONLY, &quot;ZoneRegionId()&quot;));</span>
<span class="nc" id="L1062">        return this;</span>
    }

    /**
     * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to
     * the formatter, using the best available zone ID.
     * &lt;p&gt;
     * This appends an instruction to format/parse the best available
     * zone or offset ID to the builder.
     * The zone ID is obtained in a lenient manner that first attempts to
     * find a true zone ID, such as that on {@code ZonedDateTime}, and
     * then attempts to find an offset, such as that on {@code OffsetDateTime}.
     * &lt;p&gt;
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#zone()}.
     * It will be printed using the result of {@link ZoneId#getId()}.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the text must match a known zone or offset.
     * There are two types of zone ID, offset-based, such as '+01:30' and
     * region-based, such as 'Europe/London'. These are parsed differently.
     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
     * expects an offset-based zone and will not match region-based zones.
     * The offset ID, such as '+02:30', may be at the start of the parse,
     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
     * equivalent to using {@link #appendOffset(String, String)} using the
     * arguments 'HH:MM:ss' and the no offset string '0'.
     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
     * In all other cases, the list of known region-based zones is used to
     * find the longest available match. If no match is found, and the parse
     * starts with 'Z', then {@code ZoneOffset.UTC} is selected.
     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
     * &lt;p&gt;
     * For example, the following will parse:
     * &lt;pre&gt;
     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
     *   &quot;Z&quot;                       -- ZoneOffset.UTC
     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;UT+01:30&quot;)
     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;UTC+01:30&quot;)
     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;GMT+01:30&quot;)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Note that this method is is identical to {@code appendZoneId()} except
     * in the mechanism used to obtain the zone.
     *
     * @return this, for chaining, not null
     * @see #appendZoneId()
     */
    public DateTimeFormatterBuilder appendZoneOrOffsetId() {
<span class="nc" id="L1117">        appendInternal(new ZoneIdPrinterParser(TemporalQueries.zone(), &quot;ZoneOrOffsetId()&quot;));</span>
<span class="nc" id="L1118">        return this;</span>
    }

    /**
     * Appends the time-zone name, such as 'British Summer Time', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the textual name of the zone to
     * the builder.
     * &lt;p&gt;
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#zoneId()}.
     * If the zone is a {@code ZoneOffset} it will be printed using the
     * result of {@link ZoneOffset#getId()}.
     * If the zone is not an offset, the textual name will be looked up
     * for the locale set in the {@link DateTimeFormatter}.
     * If the temporal object being printed represents an instant, then the text
     * will be the summer or winter time text as appropriate.
     * If the lookup for text does not find any suitable reuslt, then the
     * {@link ZoneId#getId() ID} will be printed instead.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, either the textual zone name, the zone ID or the offset
     * is accepted. Many textual zone names are not unique, such as CST can be
     * for both &quot;Central Standard Time&quot; and &quot;China Standard Time&quot;. In this
     * situation, the zone id will be determined by the region information from
     * formatter's  {@link DateTimeFormatter#getLocale() locale} and the standard
     * zone id for that area, for example, America/New_York for the America Eastern
     * zone. The {@link #appendZoneText(TextStyle, Set)} may be used
     * to specify a set of preferred {@link ZoneId} in this situation.
     *
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle) {
<span class="nc" id="L1153">        appendInternal(new ZoneTextPrinterParser(textStyle, null));</span>
<span class="nc" id="L1154">        return this;</span>
    }

    /**
     * Appends the time-zone name, such as 'British Summer Time', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the textual name of the zone to
     * the builder.
     * &lt;p&gt;
     * During formatting, the zone is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#zoneId()}.
     * If the zone is a {@code ZoneOffset} it will be printed using the
     * result of {@link ZoneOffset#getId()}.
     * If the zone is not an offset, the textual name will be looked up
     * for the locale set in the {@link DateTimeFormatter}.
     * If the temporal object being printed represents an instant, then the text
     * will be the summer or winter time text as appropriate.
     * If the lookup for text does not find any suitable reuslt, then the
     * {@link ZoneId#getId() ID} will be printed instead.
     * If the zone cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, either the textual zone name, the zone ID or the offset
     * is accepted. Many textual zone names are not unique, such as CST can be
     * for both &quot;Central Standard Time&quot; and &quot;China Standard Time&quot;. In this
     * situation, the zone id will be determined by the region information from
     * formatter's  {@link DateTimeFormatter#getLocale() locale} and the standard
     * zone id for that area, for example, America/New_York for the America Eastern
     * zone. This method also allows a set of preferred {@link ZoneId} to be
     * specified for parsing. The matched preferred zone id will be used if the
     * textural zone name being parsed is not unique.
     *
     * If the zone cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     *
     * @param textStyle  the text style to use, not null
     * @param preferredZones  the set of preferred zone ids, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle,
                                                   Set&lt;ZoneId&gt; preferredZones) {
<span class="nc" id="L1195">        Objects.requireNonNull(preferredZones, &quot;preferredZones&quot;);</span>
<span class="nc" id="L1196">        appendInternal(new ZoneTextPrinterParser(textStyle, preferredZones));</span>
<span class="nc" id="L1197">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.
     * &lt;p&gt;
     * This appends an instruction to format/parse the chronology ID to the builder.
     * &lt;p&gt;
     * During formatting, the chronology is obtained using a mechanism equivalent
     * to querying the temporal with {@link TemporalQueries#chronology()}.
     * It will be printed using the result of {@link Chronology#getId()}.
     * If the chronology cannot be obtained then an exception is thrown unless the
     * section of the formatter is optional.
     * &lt;p&gt;
     * During parsing, the chronology is parsed and must match one of the chronologies
     * in {@link Chronology#getAvailableChronologies()}.
     * If the chronology cannot be parsed then an exception is thrown unless the
     * section of the formatter is optional.
     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendChronologyId() {
<span class="nc" id="L1221">        appendInternal(new ChronoPrinterParser(null));</span>
<span class="nc" id="L1222">        return this;</span>
    }

    /**
     * Appends the chronology name to the formatter.
     * &lt;p&gt;
     * The calendar system name will be output during a format.
     * If the chronology cannot be obtained then an exception will be thrown.
     * The calendar system name is obtained from the Chronology.
     *
     * @param textStyle  the text style to use, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendChronologyText(TextStyle textStyle) {
<span class="nc" id="L1236">        Objects.requireNonNull(textStyle, &quot;textStyle&quot;);</span>
<span class="nc" id="L1237">        appendInternal(new ChronoPrinterParser(textStyle));</span>
<span class="nc" id="L1238">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a localized date-time pattern to the formatter.
     * &lt;p&gt;
     * This appends a localized section to the builder, suitable for outputting
     * a date, time or date-time combination. The format of the localized
     * section is lazily looked up based on four items:
     * &lt;ul&gt;
     * &lt;li&gt;the {@code dateStyle} specified to this method
     * &lt;li&gt;the {@code timeStyle} specified to this method
     * &lt;li&gt;the {@code Locale} of the {@code DateTimeFormatter}
     * &lt;li&gt;the {@code Chronology}, selecting the best available
     * &lt;/ul&gt;
     * During formatting, the chronology is obtained from the temporal object
     * being formatted, which may have been overridden by
     * {@link DateTimeFormatter#withChronology(Chronology)}.
     * &lt;p&gt;
     * During parsing, if a chronology has already been parsed, then it is used.
     * Otherwise the default from {@code DateTimeFormatter.withChronology(Chronology)}
     * is used, with {@code IsoChronology} as the fallback.
     * &lt;p&gt;
     * Note that this method provides similar functionality to methods on
     * {@code DateFormat} such as {@link java.text.DateFormat#getDateTimeInstance(int, int)}.
     *
     * @param dateStyle  the date style to use, null means no date required
     * @param timeStyle  the time style to use, null means no time required
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if both the date and time styles are null
     */
    public DateTimeFormatterBuilder appendLocalized(FormatStyle dateStyle, FormatStyle timeStyle) {
<span class="nc bnc" id="L1271" title="All 4 branches missed.">        if (dateStyle == null &amp;&amp; timeStyle == null) {</span>
<span class="nc" id="L1272">            throw new IllegalArgumentException(&quot;Either the date or time style must be non-null&quot;);</span>
        }
<span class="nc" id="L1274">        appendInternal(new LocalizedPrinterParser(dateStyle, timeStyle));</span>
<span class="nc" id="L1275">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a character literal to the formatter.
     * &lt;p&gt;
     * This character will be output during a format.
     *
     * @param literal  the literal to append, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendLiteral(char literal) {
<span class="nc" id="L1288">        appendInternal(new CharLiteralPrinterParser(literal));</span>
<span class="nc" id="L1289">        return this;</span>
    }

    /**
     * Appends a string literal to the formatter.
     * &lt;p&gt;
     * This string will be output during a format.
     * &lt;p&gt;
     * If the literal is empty, nothing is added to the formatter.
     *
     * @param literal  the literal to append, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendLiteral(String literal) {
<span class="nc" id="L1303">        Objects.requireNonNull(literal, &quot;literal&quot;);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (literal.length() &gt; 0) {</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (literal.length() == 1) {</span>
<span class="nc" id="L1306">                appendInternal(new CharLiteralPrinterParser(literal.charAt(0)));</span>
            } else {
<span class="nc" id="L1308">                appendInternal(new StringLiteralPrinterParser(literal));</span>
            }
        }
<span class="nc" id="L1311">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends all the elements of a formatter to the builder.
     * &lt;p&gt;
     * This method has the same effect as appending each of the constituent
     * parts of the formatter directly to this builder.
     *
     * @param formatter  the formatter to add, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
<span class="nc" id="L1325">        Objects.requireNonNull(formatter, &quot;formatter&quot;);</span>
<span class="nc" id="L1326">        appendInternal(formatter.toPrinterParser(false));</span>
<span class="nc" id="L1327">        return this;</span>
    }

    /**
     * Appends a formatter to the builder which will optionally format/parse.
     * &lt;p&gt;
     * This method has the same effect as appending each of the constituent
     * parts directly to this builder surrounded by an {@link #optionalStart()} and
     * {@link #optionalEnd()}.
     * &lt;p&gt;
     * The formatter will format if data is available for all the fields contained within it.
     * The formatter will parse if the string matches, otherwise no error is returned.
     *
     * @param formatter  the formatter to add, not null
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder appendOptional(DateTimeFormatter formatter) {
<span class="nc" id="L1344">        Objects.requireNonNull(formatter, &quot;formatter&quot;);</span>
<span class="nc" id="L1345">        appendInternal(formatter.toPrinterParser(true));</span>
<span class="nc" id="L1346">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends the elements defined by the specified pattern to the builder.
     * &lt;p&gt;
     * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.
     * The characters '#', '{' and '}' are reserved for future use.
     * The characters '[' and ']' indicate optional patterns.
     * The following pattern letters are defined:
     * &lt;pre&gt;
     *  Symbol  Meaning                     Presentation      Examples
     *  ------  -------                     ------------      -------
     *   G       era                         text              AD; Anno Domini; A
     *   u       year                        year              2004; 04
     *   y       year-of-era                 year              2004; 04
     *   D       day-of-year                 number            189
     *   M/L     month-of-year               number/text       7; 07; Jul; July; J
     *   d       day-of-month                number            10
     *
     *   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
     *   Y       week-based-year             year              1996; 96
     *   w       week-of-week-based-year     number            27
     *   W       week-of-month               number            4
     *   E       day-of-week                 text              Tue; Tuesday; T
     *   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
     *   F       week-of-month               number            3
     *
     *   a       am-pm-of-day                text              PM
     *   h       clock-hour-of-am-pm (1-12)  number            12
     *   K       hour-of-am-pm (0-11)        number            0
     *   k       clock-hour-of-am-pm (1-24)  number            0
     *
     *   H       hour-of-day (0-23)          number            0
     *   m       minute-of-hour              number            30
     *   s       second-of-minute            number            55
     *   S       fraction-of-second          fraction          978
     *   A       milli-of-day                number            1234
     *   n       nano-of-second              number            987654321
     *   N       nano-of-day                 number            1234000000
     *
     *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
     *   z       time-zone name              zone-name         Pacific Standard Time; PST
     *   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
     *   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15;
     *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15;
     *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00;
     *
     *   p       pad next                    pad modifier      1
     *
     *   '       escape for text             delimiter
     *   ''      single quote                literal           '
     *   [       optional section start
     *   ]       optional section end
     *   #       reserved for future use
     *   {       reserved for future use
     *   }       reserved for future use
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The count of pattern letters determine the format.
     * See &lt;a href=&quot;DateTimeFormatter.html#patterns&quot;&gt;DateTimeFormatter&lt;/a&gt; for a user-focused description of the patterns.
     * The following tables define how the pattern letters map to the builder.
     * &lt;p&gt;
     * &lt;b&gt;Date fields&lt;/b&gt;: Pattern letters to output a date.
     * &lt;pre&gt;
     *  Pattern  Count  Equivalent builder methods
     *  -------  -----  --------------------------
     *    G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
     *    GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
     *    GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
     *    GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
     *    GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)
     *
     *    u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL);
     *    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000);
     *    uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL);
     *    u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD);
     *    y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL);
     *    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000);
     *    yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL);
     *    y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD);
     *    Y       1      append special localized WeekFields element for numeric week-based-year
     *    YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits;
     *    YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL);
     *    Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD);
     *
     *    Q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
     *    QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
     *    QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
     *    QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
     *    QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
     *    q       1      appendValue(IsoFields.QUARTER_OF_YEAR);
     *    qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2);
     *    qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)
     *    qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)
     *    qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)
     *
     *    M       1      appendValue(ChronoField.MONTH_OF_YEAR);
     *    MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
     *    MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)
     *    MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)
     *    MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)
     *    L       1      appendValue(ChronoField.MONTH_OF_YEAR);
     *    LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2);
     *    LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
     *    LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)
     *    LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)
     *
     *    w       1      append special localized WeekFields element for numeric week-of-year
     *    ww      1      append special localized WeekFields element for numeric week-of-year, zero-padded
     *    W       1      append special localized WeekFields element for numeric week-of-month
     *    d       1      appendValue(ChronoField.DAY_OF_MONTH)
     *    dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)
     *    D       1      appendValue(ChronoField.DAY_OF_YEAR)
     *    DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2)
     *    DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
     *    F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)
     *    E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     *    EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     *    EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     *    EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     *    EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     *    e       1      append special localized WeekFields element for numeric day-of-week
     *    ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded
     *    eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
     *    eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
     *    eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
     *    c       1      append special localized WeekFields element for numeric day-of-week
     *    ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)
     *    cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)
     *    ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Time fields&lt;/b&gt;: Pattern letters to output a time.
     * &lt;pre&gt;
     *  Pattern  Count  Equivalent builder methods
     *  -------  -----  --------------------------
     *    a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)
     *    h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)
     *    hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)
     *    H       1      appendValue(ChronoField.HOUR_OF_DAY)
     *    HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)
     *    k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)
     *    kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)
     *    K       1      appendValue(ChronoField.HOUR_OF_AMPM)
     *    KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
     *    m       1      appendValue(ChronoField.MINUTE_OF_HOUR)
     *    mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
     *    s       1      appendValue(ChronoField.SECOND_OF_MINUTE)
     *    ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)
     *
     *    S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)
     *    A       1      appendValue(ChronoField.MILLI_OF_DAY)
     *    A..A    2..n   appendValue(ChronoField.MILLI_OF_DAY, n)
     *    n       1      appendValue(ChronoField.NANO_OF_SECOND)
     *    n..n    2..n   appendValue(ChronoField.NANO_OF_SECOND, n)
     *    N       1      appendValue(ChronoField.NANO_OF_DAY)
     *    N..N    2..n   appendValue(ChronoField.NANO_OF_DAY, n)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Zone ID&lt;/b&gt;: Pattern letters to output {@code ZoneId}.
     * &lt;pre&gt;
     *  Pattern  Count  Equivalent builder methods
     *  -------  -----  --------------------------
     *    VV      2      appendZoneId()
     *    z       1      appendZoneText(TextStyle.SHORT)
     *    zz      2      appendZoneText(TextStyle.SHORT)
     *    zzz     3      appendZoneText(TextStyle.SHORT)
     *    zzzz    4      appendZoneText(TextStyle.FULL)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Zone offset&lt;/b&gt;: Pattern letters to output {@code ZoneOffset}.
     * &lt;pre&gt;
     *  Pattern  Count  Equivalent builder methods
     *  -------  -----  --------------------------
     *    O       1      appendLocalizedOffsetPrefixed(TextStyle.SHORT);
     *    OOOO    4      appendLocalizedOffsetPrefixed(TextStyle.FULL);
     *    X       1      appendOffset(&quot;+HHmm&quot;,&quot;Z&quot;)
     *    XX      2      appendOffset(&quot;+HHMM&quot;,&quot;Z&quot;)
     *    XXX     3      appendOffset(&quot;+HH:MM&quot;,&quot;Z&quot;)
     *    XXXX    4      appendOffset(&quot;+HHMMss&quot;,&quot;Z&quot;)
     *    XXXXX   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;)
     *    x       1      appendOffset(&quot;+HHmm&quot;,&quot;+00&quot;)
     *    xx      2      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *    xxx     3      appendOffset(&quot;+HH:MM&quot;,&quot;+00:00&quot;)
     *    xxxx    4      appendOffset(&quot;+HHMMss&quot;,&quot;+0000&quot;)
     *    xxxxx   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;+00:00&quot;)
     *    Z       1      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *    ZZ      2      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *    ZZZ     3      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
     *    ZZZZ    4      appendLocalizedOffset(TextStyle.FULL);
     *    ZZZZZ   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;b&gt;Modifiers&lt;/b&gt;: Pattern letters that modify the rest of the pattern:
     * &lt;pre&gt;
     *  Pattern  Count  Equivalent builder methods
     *  -------  -----  --------------------------
     *    [       1      optionalStart()
     *    ]       1      optionalEnd()
     *    p..p    1..n   padNext(n)
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Any sequence of letters not specified above, unrecognized letter or
     * reserved character will throw an exception.
     * Future versions may add to the set of patterns.
     * It is recommended to use single quotes around all characters that you want
     * to output directly to ensure that future changes do not break your application.
     * &lt;p&gt;
     * Note that the pattern string is similar, but not identical, to
     * {@link java.text.SimpleDateFormat SimpleDateFormat}.
     * The pattern string is also similar, but not identical, to that defined by the
     * Unicode Common Locale Data Repository (CLDR/LDML).
     * Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.
     * By contrast, {@code SimpleDateFormat} uses 'u' for the numeric day of week.
     * Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.
     * Pattern letters 'n', 'A', 'N', and 'p' are added.
     * Number types will reject large numbers.
     *
     * @param pattern  the pattern to add, not null
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if the pattern is invalid
     */
    public DateTimeFormatterBuilder appendPattern(String pattern) {
<span class="nc" id="L1571">        Objects.requireNonNull(pattern, &quot;pattern&quot;);</span>
<span class="nc" id="L1572">        parsePattern(pattern);</span>
<span class="nc" id="L1573">        return this;</span>
    }

    private void parsePattern(String pattern) {
<span class="nc bnc" id="L1577" title="All 2 branches missed.">        for (int pos = 0; pos &lt; pattern.length(); pos++) {</span>
<span class="nc" id="L1578">            char cur = pattern.charAt(pos);</span>
<span class="nc bnc" id="L1579" title="All 8 branches missed.">            if ((cur &gt;= 'A' &amp;&amp; cur &lt;= 'Z') || (cur &gt;= 'a' &amp;&amp; cur &lt;= 'z')) {</span>
<span class="nc" id="L1580">                int start = pos++;</span>
<span class="nc bnc" id="L1581" title="All 4 branches missed.">                for ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  // short loop</span>
<span class="nc" id="L1582">                int count = pos - start;</span>
                // padding
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                if (cur == 'p') {</span>
<span class="nc" id="L1585">                    int pad = 0;</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">                    if (pos &lt; pattern.length()) {</span>
<span class="nc" id="L1587">                        cur = pattern.charAt(pos);</span>
<span class="nc bnc" id="L1588" title="All 8 branches missed.">                        if ((cur &gt;= 'A' &amp;&amp; cur &lt;= 'Z') || (cur &gt;= 'a' &amp;&amp; cur &lt;= 'z')) {</span>
<span class="nc" id="L1589">                            pad = count;</span>
<span class="nc" id="L1590">                            start = pos++;</span>
<span class="nc bnc" id="L1591" title="All 4 branches missed.">                            for ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  // short loop</span>
<span class="nc" id="L1592">                            count = pos - start;</span>
                        }
                    }
<span class="nc bnc" id="L1595" title="All 2 branches missed.">                    if (pad == 0) {</span>
<span class="nc" id="L1596">                        throw new IllegalArgumentException(</span>
                                &quot;Pad letter 'p' must be followed by valid pad pattern: &quot; + pattern);
                    }
<span class="nc" id="L1599">                    padNext(pad); // pad and continue parsing</span>
                }
                // main rules
<span class="nc" id="L1602">                TemporalField field = FIELD_MAP.get(cur);</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">                if (field != null) {</span>
<span class="nc" id="L1604">                    parseField(cur, count, field);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                } else if (cur == 'z') {</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (count &gt; 4) {</span>
<span class="nc" id="L1607">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                    } else if (count == 4) {</span>
<span class="nc" id="L1609">                        appendZoneText(TextStyle.FULL);</span>
                    } else {
<span class="nc" id="L1611">                        appendZoneText(TextStyle.SHORT);</span>
                    }
<span class="nc bnc" id="L1613" title="All 2 branches missed.">                } else if (cur == 'V') {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                    if (count != 2) {</span>
<span class="nc" id="L1615">                        throw new IllegalArgumentException(&quot;Pattern letter count must be 2: &quot; + cur);</span>
                    }
<span class="nc" id="L1617">                    appendZoneId();</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                } else if (cur == 'Z') {</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                    if (count &lt; 4) {</span>
<span class="nc" id="L1620">                        appendOffset(&quot;+HHMM&quot;, &quot;+0000&quot;);</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">                    } else if (count == 4) {</span>
<span class="nc" id="L1622">                        appendLocalizedOffset(TextStyle.FULL);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                    } else if (count == 5) {</span>
<span class="nc" id="L1624">                        appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;);</span>
                    } else {
<span class="nc" id="L1626">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                    }
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                } else if (cur == 'O') {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                    if (count == 1) {</span>
<span class="nc" id="L1630">                        appendLocalizedOffset(TextStyle.SHORT);</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                    } else if (count == 4) {</span>
<span class="nc" id="L1632">                        appendLocalizedOffset(TextStyle.FULL);</span>
                    } else {
<span class="nc" id="L1634">                        throw new IllegalArgumentException(&quot;Pattern letter count must be 1 or 4: &quot; + cur);</span>
                    }
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                } else if (cur == 'X') {</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">                    if (count &gt; 5) {</span>
<span class="nc" id="L1638">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                    }
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == 1 ? 0 : 1)], &quot;Z&quot;);</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                } else if (cur == 'x') {</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">                    if (count &gt; 5) {</span>
<span class="nc" id="L1643">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                    }
<span class="nc bnc" id="L1645" title="All 4 branches missed.">                    String zero = (count == 1 ? &quot;+00&quot; : (count % 2 == 0 ? &quot;+0000&quot; : &quot;+00:00&quot;));</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == 1 ? 0 : 1)], zero);</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                } else if (cur == 'W') {</span>
                    // Fields defined by Locale
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                    if (count &gt; 1) {</span>
<span class="nc" id="L1650">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                    }
<span class="nc" id="L1652">                    appendInternal(new WeekBasedFieldPrinterParser(cur, count));</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">                } else if (cur == 'w') {</span>
                    // Fields defined by Locale
<span class="nc bnc" id="L1655" title="All 2 branches missed.">                    if (count &gt; 2) {</span>
<span class="nc" id="L1656">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                    }
<span class="nc" id="L1658">                    appendInternal(new WeekBasedFieldPrinterParser(cur, count));</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">                } else if (cur == 'Y') {</span>
                    // Fields defined by Locale
<span class="nc" id="L1661">                    appendInternal(new WeekBasedFieldPrinterParser(cur, count));</span>
                } else {
<span class="nc" id="L1663">                    throw new IllegalArgumentException(&quot;Unknown pattern letter: &quot; + cur);</span>
                }
<span class="nc" id="L1665">                pos--;</span>

<span class="nc bnc" id="L1667" title="All 2 branches missed.">            } else if (cur == '\'') {</span>
                // parse literals
<span class="nc" id="L1669">                int start = pos++;</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                for ( ; pos &lt; pattern.length(); pos++) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                    if (pattern.charAt(pos) == '\'') {</span>
<span class="nc bnc" id="L1672" title="All 4 branches missed.">                        if (pos + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(pos + 1) == '\'') {</span>
<span class="nc" id="L1673">                            pos++;</span>
                        } else {
                            break;  // end of literal
                        }
                    }
                }
<span class="nc bnc" id="L1679" title="All 2 branches missed.">                if (pos &gt;= pattern.length()) {</span>
<span class="nc" id="L1680">                    throw new IllegalArgumentException(&quot;Pattern ends with an incomplete string literal: &quot; + pattern);</span>
                }
<span class="nc" id="L1682">                String str = pattern.substring(start + 1, pos);</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">                if (str.length() == 0) {</span>
<span class="nc" id="L1684">                    appendLiteral('\'');</span>
                } else {
<span class="nc" id="L1686">                    appendLiteral(str.replace(&quot;''&quot;, &quot;'&quot;));</span>
                }

<span class="nc bnc" id="L1689" title="All 2 branches missed.">            } else if (cur == '[') {</span>
<span class="nc" id="L1690">                optionalStart();</span>

<span class="nc bnc" id="L1692" title="All 2 branches missed.">            } else if (cur == ']') {</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                if (active.parent == null) {</span>
<span class="nc" id="L1694">                    throw new IllegalArgumentException(&quot;Pattern invalid as it contains ] without previous [&quot;);</span>
                }
<span class="nc" id="L1696">                optionalEnd();</span>

<span class="nc bnc" id="L1698" title="All 6 branches missed.">            } else if (cur == '{' || cur == '}' || cur == '#') {</span>
<span class="nc" id="L1699">                throw new IllegalArgumentException(&quot;Pattern includes reserved character: '&quot; + cur + &quot;'&quot;);</span>
            } else {
<span class="nc" id="L1701">                appendLiteral(cur);</span>
            }
        }
<span class="nc" id="L1704">    }</span>

    @SuppressWarnings(&quot;fallthrough&quot;)
    private void parseField(char cur, int count, TemporalField field) {
<span class="nc" id="L1708">        boolean standalone = false;</span>
<span class="nc bnc" id="L1709" title="All 11 branches missed.">        switch (cur) {</span>
            case 'u':
            case 'y':
<span class="nc bnc" id="L1712" title="All 2 branches missed.">                if (count == 2) {</span>
<span class="nc" id="L1713">                    appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">                } else if (count &lt; 4) {</span>
<span class="nc" id="L1715">                    appendValue(field, count, 19, SignStyle.NORMAL);</span>
                } else {
<span class="nc" id="L1717">                    appendValue(field, count, 19, SignStyle.EXCEEDS_PAD);</span>
                }
<span class="nc" id="L1719">                break;</span>
            case 'c':
<span class="nc bnc" id="L1721" title="All 2 branches missed.">                if (count == 2) {</span>
<span class="nc" id="L1722">                    throw new IllegalArgumentException(&quot;Invalid pattern \&quot;cc\&quot;&quot;);</span>
                }
                /*fallthrough*/
            case 'L':
            case 'q':
<span class="nc" id="L1727">                standalone = true;</span>
                /*fallthrough*/
            case 'M':
            case 'Q':
            case 'E':
            case 'e':
<span class="nc bnc" id="L1733" title="All 5 branches missed.">                switch (count) {</span>
                    case 1:
                    case 2:
<span class="nc bnc" id="L1736" title="All 4 branches missed.">                        if (cur == 'c' || cur == 'e') {</span>
<span class="nc" id="L1737">                            appendInternal(new WeekBasedFieldPrinterParser(cur, count));</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                        } else if (cur == 'E') {</span>
<span class="nc" id="L1739">                            appendText(field, TextStyle.SHORT);</span>
                        } else {
<span class="nc bnc" id="L1741" title="All 2 branches missed.">                            if (count == 1) {</span>
<span class="nc" id="L1742">                                appendValue(field);</span>
                            } else {
<span class="nc" id="L1744">                                appendValue(field, 2);</span>
                            }
                        }
<span class="nc" id="L1747">                        break;</span>
                    case 3:
<span class="nc bnc" id="L1749" title="All 2 branches missed.">                        appendText(field, standalone ? TextStyle.SHORT_STANDALONE : TextStyle.SHORT);</span>
<span class="nc" id="L1750">                        break;</span>
                    case 4:
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                        appendText(field, standalone ? TextStyle.FULL_STANDALONE : TextStyle.FULL);</span>
<span class="nc" id="L1753">                        break;</span>
                    case 5:
<span class="nc bnc" id="L1755" title="All 2 branches missed.">                        appendText(field, standalone ? TextStyle.NARROW_STANDALONE : TextStyle.NARROW);</span>
<span class="nc" id="L1756">                        break;</span>
                    default:
<span class="nc" id="L1758">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            case 'a':
<span class="nc bnc" id="L1762" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L1763">                    appendText(field, TextStyle.SHORT);</span>
                } else {
<span class="nc" id="L1765">                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            case 'G':
<span class="nc bnc" id="L1769" title="All 4 branches missed.">                switch (count) {</span>
                    case 1:
                    case 2:
                    case 3:
<span class="nc" id="L1773">                        appendText(field, TextStyle.SHORT);</span>
<span class="nc" id="L1774">                        break;</span>
                    case 4:
<span class="nc" id="L1776">                        appendText(field, TextStyle.FULL);</span>
<span class="nc" id="L1777">                        break;</span>
                    case 5:
<span class="nc" id="L1779">                        appendText(field, TextStyle.NARROW);</span>
<span class="nc" id="L1780">                        break;</span>
                    default:
<span class="nc" id="L1782">                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            case 'S':
<span class="nc" id="L1786">                appendFraction(NANO_OF_SECOND, count, count, false);</span>
<span class="nc" id="L1787">                break;</span>
            case 'F':
<span class="nc bnc" id="L1789" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L1790">                    appendValue(field);</span>
                } else {
<span class="nc" id="L1792">                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            case 'd':
            case 'h':
            case 'H':
            case 'k':
            case 'K':
            case 'm':
            case 's':
<span class="nc bnc" id="L1802" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L1803">                    appendValue(field);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">                } else if (count == 2) {</span>
<span class="nc" id="L1805">                    appendValue(field, count);</span>
                } else {
<span class="nc" id="L1807">                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            case 'D':
<span class="nc bnc" id="L1811" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L1812">                    appendValue(field);</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                } else if (count &lt;= 3) {</span>
<span class="nc" id="L1814">                    appendValue(field, count);</span>
                } else {
<span class="nc" id="L1816">                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</span>
                }
                break;
            default:
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L1821">                    appendValue(field);</span>
                } else {
<span class="nc" id="L1823">                    appendValue(field, count);</span>
                }
                break;
        }
<span class="nc" id="L1827">    }</span>

    /** Map of letters to fields. */
<span class="nc" id="L1830">    private static final Map&lt;Character, TemporalField&gt; FIELD_MAP = new HashMap&lt;&gt;();</span>
    static {
        // SDF = SimpleDateFormat
<span class="nc" id="L1833">        FIELD_MAP.put('G', ChronoField.ERA);                       // SDF, LDML (different to both for 1/2 chars)</span>
<span class="nc" id="L1834">        FIELD_MAP.put('y', ChronoField.YEAR_OF_ERA);               // SDF, LDML</span>
<span class="nc" id="L1835">        FIELD_MAP.put('u', ChronoField.YEAR);                      // LDML (different in SDF)</span>
<span class="nc" id="L1836">        FIELD_MAP.put('Q', IsoFields.QUARTER_OF_YEAR);             // LDML (removed quarter from 310)</span>
<span class="nc" id="L1837">        FIELD_MAP.put('q', IsoFields.QUARTER_OF_YEAR);             // LDML (stand-alone)</span>
<span class="nc" id="L1838">        FIELD_MAP.put('M', ChronoField.MONTH_OF_YEAR);             // SDF, LDML</span>
<span class="nc" id="L1839">        FIELD_MAP.put('L', ChronoField.MONTH_OF_YEAR);             // SDF, LDML (stand-alone)</span>
<span class="nc" id="L1840">        FIELD_MAP.put('D', ChronoField.DAY_OF_YEAR);               // SDF, LDML</span>
<span class="nc" id="L1841">        FIELD_MAP.put('d', ChronoField.DAY_OF_MONTH);              // SDF, LDML</span>
<span class="nc" id="L1842">        FIELD_MAP.put('F', ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);  // SDF, LDML</span>
<span class="nc" id="L1843">        FIELD_MAP.put('E', ChronoField.DAY_OF_WEEK);               // SDF, LDML (different to both for 1/2 chars)</span>
<span class="nc" id="L1844">        FIELD_MAP.put('c', ChronoField.DAY_OF_WEEK);               // LDML (stand-alone)</span>
<span class="nc" id="L1845">        FIELD_MAP.put('e', ChronoField.DAY_OF_WEEK);               // LDML (needs localized week number)</span>
<span class="nc" id="L1846">        FIELD_MAP.put('a', ChronoField.AMPM_OF_DAY);               // SDF, LDML</span>
<span class="nc" id="L1847">        FIELD_MAP.put('H', ChronoField.HOUR_OF_DAY);               // SDF, LDML</span>
<span class="nc" id="L1848">        FIELD_MAP.put('k', ChronoField.CLOCK_HOUR_OF_DAY);         // SDF, LDML</span>
<span class="nc" id="L1849">        FIELD_MAP.put('K', ChronoField.HOUR_OF_AMPM);              // SDF, LDML</span>
<span class="nc" id="L1850">        FIELD_MAP.put('h', ChronoField.CLOCK_HOUR_OF_AMPM);        // SDF, LDML</span>
<span class="nc" id="L1851">        FIELD_MAP.put('m', ChronoField.MINUTE_OF_HOUR);            // SDF, LDML</span>
<span class="nc" id="L1852">        FIELD_MAP.put('s', ChronoField.SECOND_OF_MINUTE);          // SDF, LDML</span>
<span class="nc" id="L1853">        FIELD_MAP.put('S', ChronoField.NANO_OF_SECOND);            // LDML (SDF uses milli-of-second number)</span>
<span class="nc" id="L1854">        FIELD_MAP.put('A', ChronoField.MILLI_OF_DAY);              // LDML</span>
<span class="nc" id="L1855">        FIELD_MAP.put('n', ChronoField.NANO_OF_SECOND);            // 310 (proposed for LDML)</span>
<span class="nc" id="L1856">        FIELD_MAP.put('N', ChronoField.NANO_OF_DAY);               // 310 (proposed for LDML)</span>
        // 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4
        // 310 - Z - matches SimpleDateFormat and LDML
        // 310 - V - time-zone id, matches LDML
        // 310 - p - prefix for padding
        // 310 - X - matches LDML, almost matches SDF for 1, exact match 2&amp;3, extended 4&amp;5
        // 310 - x - matches LDML
        // 310 - w, W, and Y are localized forms matching LDML
        // LDML - U - cycle year name, not supported by 310 yet
        // LDML - l - deprecated
        // LDML - j - not relevant
        // LDML - g - modified-julian-day
        // LDML - v,V - extended time-zone names
    }

    //-----------------------------------------------------------------------
    /**
     * Causes the next added printer/parser to pad to a fixed width using a space.
     * &lt;p&gt;
     * This padding will pad to a fixed width using spaces.
     * &lt;p&gt;
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during formatting if
     * the pad width is exceeded.
     * &lt;p&gt;
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * If parsing is case insensitive, then the pad character is matched ignoring case.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param padWidth  the pad width, 1 or greater
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    public DateTimeFormatterBuilder padNext(int padWidth) {
<span class="nc" id="L1892">        return padNext(padWidth, ' ');</span>
    }

    /**
     * Causes the next added printer/parser to pad to a fixed width.
     * &lt;p&gt;
     * This padding is intended for padding other than zero-padding.
     * Zero-padding should be achieved using the appendValue methods.
     * &lt;p&gt;
     * During formatting, the decorated element will be output and then padded
     * to the specified width. An exception will be thrown during formatting if
     * the pad width is exceeded.
     * &lt;p&gt;
     * During parsing, the padding and decorated element are parsed.
     * If parsing is lenient, then the pad width is treated as a maximum.
     * If parsing is case insensitive, then the pad character is matched ignoring case.
     * The padding is parsed greedily. Thus, if the decorated element starts with
     * the pad character, it will not be parsed.
     *
     * @param padWidth  the pad width, 1 or greater
     * @param padChar  the pad character
     * @return this, for chaining, not null
     * @throws IllegalArgumentException if pad width is too small
     */
    public DateTimeFormatterBuilder padNext(int padWidth, char padChar) {
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        if (padWidth &lt; 1) {</span>
<span class="nc" id="L1918">            throw new IllegalArgumentException(&quot;The pad width must be at least one but was &quot; + padWidth);</span>
        }
<span class="nc" id="L1920">        active.padNextWidth = padWidth;</span>
<span class="nc" id="L1921">        active.padNextChar = padChar;</span>
<span class="nc" id="L1922">        active.valueParserIndex = -1;</span>
<span class="nc" id="L1923">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Mark the start of an optional section.
     * &lt;p&gt;
     * The output of formatting can include optional sections, which may be nested.
     * An optional section is started by calling this method and ended by calling
     * {@link #optionalEnd()} or by ending the build process.
     * &lt;p&gt;
     * All elements in the optional section are treated as optional.
     * During formatting, the section is only output if data is available in the
     * {@code TemporalAccessor} for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     * &lt;p&gt;
     * For example, consider a builder setup as
     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)}.
     * The optional section ends automatically at the end of the builder.
     * During formatting, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return this, for chaining, not null
     */
    public DateTimeFormatterBuilder optionalStart() {
<span class="nc" id="L1948">        active.valueParserIndex = -1;</span>
<span class="nc" id="L1949">        active = new DateTimeFormatterBuilder(active, true);</span>
<span class="nc" id="L1950">        return this;</span>
    }

    /**
     * Ends an optional section.
     * &lt;p&gt;
     * The output of formatting can include optional sections, which may be nested.
     * An optional section is started by calling {@link #optionalStart()} and ended
     * using this method (or at the end of the builder).
     * &lt;p&gt;
     * Calling this method without having previously called {@code optionalStart}
     * will throw an exception.
     * Calling this method immediately after calling {@code optionalStart} has no effect
     * on the formatter other than ending the (empty) optional section.
     * &lt;p&gt;
     * All elements in the optional section are treated as optional.
     * During formatting, the section is only output if data is available in the
     * {@code TemporalAccessor} for all the elements in the section.
     * During parsing, the whole section may be missing from the parsed string.
     * &lt;p&gt;
     * For example, consider a builder setup as
     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.
     * During formatting, the minute will only be output if its value can be obtained from the date-time.
     * During parsing, the input will be successfully parsed whether the minute is present or not.
     *
     * @return this, for chaining, not null
     * @throws IllegalStateException if there was no previous call to {@code optionalStart}
     */
    public DateTimeFormatterBuilder optionalEnd() {
<span class="nc bnc" id="L1979" title="All 2 branches missed.">        if (active.parent == null) {</span>
<span class="nc" id="L1980">            throw new IllegalStateException(&quot;Cannot call optionalEnd() as there was no previous call to optionalStart()&quot;);</span>
        }
<span class="nc bnc" id="L1982" title="All 2 branches missed.">        if (active.printerParsers.size() &gt; 0) {</span>
<span class="nc" id="L1983">            CompositePrinterParser cpp = new CompositePrinterParser(active.printerParsers, active.optional);</span>
<span class="nc" id="L1984">            active = active.parent;</span>
<span class="nc" id="L1985">            appendInternal(cpp);</span>
<span class="nc" id="L1986">        } else {</span>
<span class="nc" id="L1987">            active = active.parent;</span>
        }
<span class="nc" id="L1989">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Appends a printer and/or parser to the internal list handling padding.
     *
     * @param pp  the printer-parser to add, not null
     * @return the index into the active parsers list
     */
    private int appendInternal(DateTimePrinterParser pp) {
<span class="nc" id="L2000">        Objects.requireNonNull(pp, &quot;pp&quot;);</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">        if (active.padNextWidth &gt; 0) {</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if (pp != null) {</span>
<span class="nc" id="L2003">                pp = new PadPrinterParserDecorator(pp, active.padNextWidth, active.padNextChar);</span>
            }
<span class="nc" id="L2005">            active.padNextWidth = 0;</span>
<span class="nc" id="L2006">            active.padNextChar = 0;</span>
        }
<span class="nc" id="L2008">        active.printerParsers.add(pp);</span>
<span class="nc" id="L2009">        active.valueParserIndex = -1;</span>
<span class="nc" id="L2010">        return active.printerParsers.size() - 1;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Completes this builder by creating the {@code DateTimeFormatter}
     * using the default locale.
     * &lt;p&gt;
     * This will create a formatter with the {@linkplain Locale#getDefault(Locale.Category) default FORMAT locale}.
     * Numbers will be printed and parsed using the standard DecimalStyle.
     * The resolver style will be {@link ResolverStyle#SMART SMART}.
     * &lt;p&gt;
     * Calling this method will end any open optional sections by repeatedly
     * calling {@link #optionalEnd()} before creating the formatter.
     * &lt;p&gt;
     * This builder can still be used after creating the formatter if desired,
     * although the state may have been changed by calls to {@code optionalEnd}.
     *
     * @return the created formatter, not null
     */
    public DateTimeFormatter toFormatter() {
<span class="nc" id="L2031">        return toFormatter(Locale.getDefault(Locale.Category.FORMAT));</span>
    }

    /**
     * Completes this builder by creating the {@code DateTimeFormatter}
     * using the specified locale.
     * &lt;p&gt;
     * This will create a formatter with the specified locale.
     * Numbers will be printed and parsed using the standard DecimalStyle.
     * The resolver style will be {@link ResolverStyle#SMART SMART}.
     * &lt;p&gt;
     * Calling this method will end any open optional sections by repeatedly
     * calling {@link #optionalEnd()} before creating the formatter.
     * &lt;p&gt;
     * This builder can still be used after creating the formatter if desired,
     * although the state may have been changed by calls to {@code optionalEnd}.
     *
     * @param locale  the locale to use for formatting, not null
     * @return the created formatter, not null
     */
    public DateTimeFormatter toFormatter(Locale locale) {
<span class="nc" id="L2052">        return toFormatter(locale, ResolverStyle.SMART, null);</span>
    }

    /**
     * Completes this builder by creating the formatter.
     * This uses the default locale.
     *
     * @param resolverStyle  the resolver style to use, not null
     * @return the created formatter, not null
     */
    DateTimeFormatter toFormatter(ResolverStyle resolverStyle, Chronology chrono) {
<span class="nc" id="L2063">        return toFormatter(Locale.getDefault(Locale.Category.FORMAT), resolverStyle, chrono);</span>
    }

    /**
     * Completes this builder by creating the formatter.
     *
     * @param locale  the locale to use for formatting, not null
     * @param chrono  the chronology to use, may be null
     * @return the created formatter, not null
     */
    private DateTimeFormatter toFormatter(Locale locale, ResolverStyle resolverStyle, Chronology chrono) {
<span class="nc" id="L2074">        Objects.requireNonNull(locale, &quot;locale&quot;);</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">        while (active.parent != null) {</span>
<span class="nc" id="L2076">            optionalEnd();</span>
        }
<span class="nc" id="L2078">        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);</span>
<span class="nc" id="L2079">        return new DateTimeFormatter(pp, locale, DecimalStyle.STANDARD,</span>
                resolverStyle, null, chrono, null);
    }

    //-----------------------------------------------------------------------
    /**
     * Strategy for formatting/parsing date-time information.
     * &lt;p&gt;
     * The printer may format any part, or the whole, of the input date-time object.
     * Typically, a complete format is constructed from a number of smaller
     * units, each outputting a single field.
     * &lt;p&gt;
     * The parser may parse any piece of text from the input, storing the result
     * in the context. Typically, each individual parser will just parse one
     * field, such as the day-of-month, storing the value in the context.
     * Once the parse is complete, the caller will then resolve the parsed values
     * to create the desired object, such as a {@code LocalDate}.
     * &lt;p&gt;
     * The parse position will be updated during the parse. Parsing will start at
     * the specified index and the return value specifies the new parse position
     * for the next parser. If an error occurs, the returned index will be negative
     * and will have the error position encoded using the complement operator.
     *
     * @implSpec
     * This interface must be implemented with care to ensure other classes operate correctly.
     * All implementations that can be instantiated must be final, immutable and thread-safe.
     * &lt;p&gt;
     * The context is not a thread-safe object and a new instance will be created
     * for each format that occurs. The context must not be stored in an instance
     * variable or shared with any other threads.
     */
    interface DateTimePrinterParser {

        /**
         * Prints the date-time object to the buffer.
         * &lt;p&gt;
         * The context holds information to use during the format.
         * It also contains the date-time information to be printed.
         * &lt;p&gt;
         * The buffer must not be mutated beyond the content controlled by the implementation.
         *
         * @param context  the context to format using, not null
         * @param buf  the buffer to append to, not null
         * @return false if unable to query the value from the date-time, true otherwise
         * @throws DateTimeException if the date-time cannot be printed successfully
         */
        boolean format(DateTimePrintContext context, StringBuilder buf);

        /**
         * Parses text into date-time information.
         * &lt;p&gt;
         * The context holds information to use during the parse.
         * It is also used to store the parsed date-time information.
         *
         * @param context  the context to use and parse into, not null
         * @param text  the input text to parse, not null
         * @param position  the position to start parsing at, from 0 to the text length
         * @return the new parse position, where negative means an error with the
         *  error position encoded using the complement ~ operator
         * @throws NullPointerException if the context or text is null
         * @throws IndexOutOfBoundsException if the position is invalid
         */
        int parse(DateTimeParseContext context, CharSequence text, int position);
    }

    //-----------------------------------------------------------------------
    /**
     * Composite printer and parser.
     */
    static final class CompositePrinterParser implements DateTimePrinterParser {
        private final DateTimePrinterParser[] printerParsers;
        private final boolean optional;

        CompositePrinterParser(List&lt;DateTimePrinterParser&gt; printerParsers, boolean optional) {
<span class="nc" id="L2153">            this(printerParsers.toArray(new DateTimePrinterParser[printerParsers.size()]), optional);</span>
<span class="nc" id="L2154">        }</span>

<span class="nc" id="L2156">        CompositePrinterParser(DateTimePrinterParser[] printerParsers, boolean optional) {</span>
<span class="nc" id="L2157">            this.printerParsers = printerParsers;</span>
<span class="nc" id="L2158">            this.optional = optional;</span>
<span class="nc" id="L2159">        }</span>

        /**
         * Returns a copy of this printer-parser with the optional flag changed.
         *
         * @param optional  the optional flag to set in the copy
         * @return the new printer-parser, not null
         */
        public CompositePrinterParser withOptional(boolean optional) {
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            if (optional == this.optional) {</span>
<span class="nc" id="L2169">                return this;</span>
            }
<span class="nc" id="L2171">            return new CompositePrinterParser(printerParsers, optional);</span>
        }

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2176">            int length = buf.length();</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">            if (optional) {</span>
<span class="nc" id="L2178">                context.startOptional();</span>
            }
            try {
<span class="nc bnc" id="L2181" title="All 2 branches missed.">                for (DateTimePrinterParser pp : printerParsers) {</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">                    if (pp.format(context, buf) == false) {</span>
<span class="nc" id="L2183">                        buf.setLength(length);  // reset buffer</span>
<span class="nc" id="L2184">                        return true;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L2188" title="All 6 branches missed.">                if (optional) {</span>
<span class="nc" id="L2189">                    context.endOptional();</span>
                }
            }
<span class="nc" id="L2192">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc bnc" id="L2197" title="All 2 branches missed.">            if (optional) {</span>
<span class="nc" id="L2198">                context.startOptional();</span>
<span class="nc" id="L2199">                int pos = position;</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">                for (DateTimePrinterParser pp : printerParsers) {</span>
<span class="nc" id="L2201">                    pos = pp.parse(context, text, pos);</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">                    if (pos &lt; 0) {</span>
<span class="nc" id="L2203">                        context.endOptional(false);</span>
<span class="nc" id="L2204">                        return position;  // return original position</span>
                    }
                }
<span class="nc" id="L2207">                context.endOptional(true);</span>
<span class="nc" id="L2208">                return pos;</span>
            } else {
<span class="nc bnc" id="L2210" title="All 2 branches missed.">                for (DateTimePrinterParser pp : printerParsers) {</span>
<span class="nc" id="L2211">                    position = pp.parse(context, text, position);</span>
<span class="nc bnc" id="L2212" title="All 2 branches missed.">                    if (position &lt; 0) {</span>
<span class="nc" id="L2213">                        break;</span>
                    }
                }
<span class="nc" id="L2216">                return position;</span>
            }
        }

        @Override
        public String toString() {
<span class="nc" id="L2222">            StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">            if (printerParsers != null) {</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                buf.append(optional ? &quot;[&quot; : &quot;(&quot;);</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">                for (DateTimePrinterParser pp : printerParsers) {</span>
<span class="nc" id="L2226">                    buf.append(pp);</span>
                }
<span class="nc bnc" id="L2228" title="All 2 branches missed.">                buf.append(optional ? &quot;]&quot; : &quot;)&quot;);</span>
            }
<span class="nc" id="L2230">            return buf.toString();</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Pads the output to a fixed width.
     */
    static final class PadPrinterParserDecorator implements DateTimePrinterParser {
        private final DateTimePrinterParser printerParser;
        private final int padWidth;
        private final char padChar;

        /**
         * Constructor.
         *
         * @param printerParser  the printer, not null
         * @param padWidth  the width to pad to, 1 or greater
         * @param padChar  the pad character
         */
<span class="nc" id="L2250">        PadPrinterParserDecorator(DateTimePrinterParser printerParser, int padWidth, char padChar) {</span>
            // input checked by DateTimeFormatterBuilder
<span class="nc" id="L2252">            this.printerParser = printerParser;</span>
<span class="nc" id="L2253">            this.padWidth = padWidth;</span>
<span class="nc" id="L2254">            this.padChar = padChar;</span>
<span class="nc" id="L2255">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2259">            int preLen = buf.length();</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">            if (printerParser.format(context, buf) == false) {</span>
<span class="nc" id="L2261">                return false;</span>
            }
<span class="nc" id="L2263">            int len = buf.length() - preLen;</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">            if (len &gt; padWidth) {</span>
<span class="nc" id="L2265">                throw new DateTimeException(</span>
                    &quot;Cannot print as output of &quot; + len + &quot; characters exceeds pad width of &quot; + padWidth);
            }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">            for (int i = 0; i &lt; padWidth - len; i++) {</span>
<span class="nc" id="L2269">                buf.insert(preLen, padChar);</span>
            }
<span class="nc" id="L2271">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
            // cache context before changed by decorated parser
<span class="nc" id="L2277">            final boolean strict = context.isStrict();</span>
            // parse
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (position &gt; text.length()) {</span>
<span class="nc" id="L2280">                throw new IndexOutOfBoundsException();</span>
            }
<span class="nc bnc" id="L2282" title="All 2 branches missed.">            if (position == text.length()) {</span>
<span class="nc" id="L2283">                return ~position;  // no more characters in the string</span>
            }
<span class="nc" id="L2285">            int endPos = position + padWidth;</span>
<span class="nc bnc" id="L2286" title="All 2 branches missed.">            if (endPos &gt; text.length()) {</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">                if (strict) {</span>
<span class="nc" id="L2288">                    return ~position;  // not enough characters in the string to meet the parse width</span>
                }
<span class="nc" id="L2290">                endPos = text.length();</span>
            }
<span class="nc" id="L2292">            int pos = position;</span>
<span class="nc bnc" id="L2293" title="All 4 branches missed.">            while (pos &lt; endPos &amp;&amp; context.charEquals(text.charAt(pos), padChar)) {</span>
<span class="nc" id="L2294">                pos++;</span>
            }
<span class="nc" id="L2296">            text = text.subSequence(0, endPos);</span>
<span class="nc" id="L2297">            int resultPos = printerParser.parse(context, text, pos);</span>
<span class="nc bnc" id="L2298" title="All 4 branches missed.">            if (resultPos != endPos &amp;&amp; strict) {</span>
<span class="nc" id="L2299">                return ~(position + pos);  // parse of decorated field didn't parse to the end</span>
            }
<span class="nc" id="L2301">            return resultPos;</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            return &quot;Pad(&quot; + printerParser + &quot;,&quot; + padWidth + (padChar == ' ' ? &quot;)&quot; : &quot;,'&quot; + padChar + &quot;')&quot;);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Enumeration to apply simple parse settings.
     */
<span class="nc" id="L2314">    static enum SettingsParser implements DateTimePrinterParser {</span>
<span class="nc" id="L2315">        SENSITIVE,</span>
<span class="nc" id="L2316">        INSENSITIVE,</span>
<span class="nc" id="L2317">        STRICT,</span>
<span class="nc" id="L2318">        LENIENT;</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2322">            return true;  // nothing to do here</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
            // using ordinals to avoid javac synthetic inner class
<span class="nc bnc" id="L2328" title="All 5 branches missed.">            switch (ordinal()) {</span>
<span class="nc" id="L2329">                case 0: context.setCaseSensitive(true); break;</span>
<span class="nc" id="L2330">                case 1: context.setCaseSensitive(false); break;</span>
<span class="nc" id="L2331">                case 2: context.setStrict(true); break;</span>
<span class="nc" id="L2332">                case 3: context.setStrict(false); break;</span>
            }
<span class="nc" id="L2334">            return position;</span>
        }

        @Override
        public String toString() {
            // using ordinals to avoid javac synthetic inner class
<span class="nc bnc" id="L2340" title="All 5 branches missed.">            switch (ordinal()) {</span>
<span class="nc" id="L2341">                case 0: return &quot;ParseCaseSensitive(true)&quot;;</span>
<span class="nc" id="L2342">                case 1: return &quot;ParseCaseSensitive(false)&quot;;</span>
<span class="nc" id="L2343">                case 2: return &quot;ParseStrict(true)&quot;;</span>
<span class="nc" id="L2344">                case 3: return &quot;ParseStrict(false)&quot;;</span>
            }
<span class="nc" id="L2346">            throw new IllegalStateException(&quot;Unreachable&quot;);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Defaults a value into the parse if not currently present.
     */
    static class DefaultValueParser implements DateTimePrinterParser {
        private final TemporalField field;
        private final long value;

<span class="nc" id="L2358">        DefaultValueParser(TemporalField field, long value) {</span>
<span class="nc" id="L2359">            this.field = field;</span>
<span class="nc" id="L2360">            this.value = value;</span>
<span class="nc" id="L2361">        }</span>

        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2364">            return true;</span>
        }

        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc bnc" id="L2368" title="All 2 branches missed.">            if (context.getParsed(field) == null) {</span>
<span class="nc" id="L2369">                context.setParsedField(field, value, position, position);</span>
            }
<span class="nc" id="L2371">            return position;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a character literal.
     */
    static final class CharLiteralPrinterParser implements DateTimePrinterParser {
        private final char literal;

<span class="nc" id="L2382">        CharLiteralPrinterParser(char literal) {</span>
<span class="nc" id="L2383">            this.literal = literal;</span>
<span class="nc" id="L2384">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2388">            buf.append(literal);</span>
<span class="nc" id="L2389">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L2394">            int length = text.length();</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">            if (position == length) {</span>
<span class="nc" id="L2396">                return ~position;</span>
            }
<span class="nc" id="L2398">            char ch = text.charAt(position);</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">            if (ch != literal) {</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">                if (context.isCaseSensitive() ||</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                        (Character.toUpperCase(ch) != Character.toUpperCase(literal) &amp;&amp;</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">                         Character.toLowerCase(ch) != Character.toLowerCase(literal))) {</span>
<span class="nc" id="L2403">                    return ~position;</span>
                }
            }
<span class="nc" id="L2406">            return position + 1;</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L2411" title="All 2 branches missed.">            if (literal == '\'') {</span>
<span class="nc" id="L2412">                return &quot;''&quot;;</span>
            }
<span class="nc" id="L2414">            return &quot;'&quot; + literal + &quot;'&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a string literal.
     */
    static final class StringLiteralPrinterParser implements DateTimePrinterParser {
        private final String literal;

<span class="nc" id="L2425">        StringLiteralPrinterParser(String literal) {</span>
<span class="nc" id="L2426">            this.literal = literal;  // validated by caller</span>
<span class="nc" id="L2427">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2431">            buf.append(literal);</span>
<span class="nc" id="L2432">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L2437">            int length = text.length();</span>
<span class="nc bnc" id="L2438" title="All 4 branches missed.">            if (position &gt; length || position &lt; 0) {</span>
<span class="nc" id="L2439">                throw new IndexOutOfBoundsException();</span>
            }
<span class="nc bnc" id="L2441" title="All 2 branches missed.">            if (context.subSequenceEquals(text, position, literal, 0, literal.length()) == false) {</span>
<span class="nc" id="L2442">                return ~position;</span>
            }
<span class="nc" id="L2444">            return position + literal.length();</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L2449">            String converted = literal.replace(&quot;'&quot;, &quot;''&quot;);</span>
<span class="nc" id="L2450">            return &quot;'&quot; + converted + &quot;'&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints and parses a numeric date-time field with optional padding.
     */
    static class NumberPrinterParser implements DateTimePrinterParser {

        /**
         * Array of 10 to the power of n.
         */
<span class="nc" id="L2463">        static final long[] EXCEED_POINTS = new long[] {</span>
            0L,
            10L,
            100L,
            1000L,
            10000L,
            100000L,
            1000000L,
            10000000L,
            100000000L,
            1000000000L,
            10000000000L,
        };

        final TemporalField field;
        final int minWidth;
        final int maxWidth;
        private final SignStyle signStyle;
        final int subsequentWidth;

        /**
         * Constructor.
         *
         * @param field  the field to format, not null
         * @param minWidth  the minimum field width, from 1 to 19
         * @param maxWidth  the maximum field width, from minWidth to 19
         * @param signStyle  the positive/negative sign style, not null
         */
<span class="nc" id="L2491">        NumberPrinterParser(TemporalField field, int minWidth, int maxWidth, SignStyle signStyle) {</span>
            // validated by caller
<span class="nc" id="L2493">            this.field = field;</span>
<span class="nc" id="L2494">            this.minWidth = minWidth;</span>
<span class="nc" id="L2495">            this.maxWidth = maxWidth;</span>
<span class="nc" id="L2496">            this.signStyle = signStyle;</span>
<span class="nc" id="L2497">            this.subsequentWidth = 0;</span>
<span class="nc" id="L2498">        }</span>

        /**
         * Constructor.
         *
         * @param field  the field to format, not null
         * @param minWidth  the minimum field width, from 1 to 19
         * @param maxWidth  the maximum field width, from minWidth to 19
         * @param signStyle  the positive/negative sign style, not null
         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,
         *  -1 if fixed width due to active adjacent parsing
         */
<span class="nc" id="L2510">        protected NumberPrinterParser(TemporalField field, int minWidth, int maxWidth, SignStyle signStyle, int subsequentWidth) {</span>
            // validated by caller
<span class="nc" id="L2512">            this.field = field;</span>
<span class="nc" id="L2513">            this.minWidth = minWidth;</span>
<span class="nc" id="L2514">            this.maxWidth = maxWidth;</span>
<span class="nc" id="L2515">            this.signStyle = signStyle;</span>
<span class="nc" id="L2516">            this.subsequentWidth = subsequentWidth;</span>
<span class="nc" id="L2517">        }</span>

        /**
         * Returns a new instance with fixed width flag set.
         *
         * @return a new updated printer-parser, not null
         */
        NumberPrinterParser withFixedWidth() {
<span class="nc bnc" id="L2525" title="All 2 branches missed.">            if (subsequentWidth == -1) {</span>
<span class="nc" id="L2526">                return this;</span>
            }
<span class="nc" id="L2528">            return new NumberPrinterParser(field, minWidth, maxWidth, signStyle, -1);</span>
        }

        /**
         * Returns a new instance with an updated subsequent width.
         *
         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
         * @return a new updated printer-parser, not null
         */
        NumberPrinterParser withSubsequentWidth(int subsequentWidth) {
<span class="nc" id="L2538">            return new NumberPrinterParser(field, minWidth, maxWidth, signStyle, this.subsequentWidth + subsequentWidth);</span>
        }

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2543">            Long valueLong = context.getValue(field);</span>
<span class="nc bnc" id="L2544" title="All 2 branches missed.">            if (valueLong == null) {</span>
<span class="nc" id="L2545">                return false;</span>
            }
<span class="nc" id="L2547">            long value = getValue(context, valueLong);</span>
<span class="nc" id="L2548">            DecimalStyle decimalStyle = context.getDecimalStyle();</span>
<span class="nc bnc" id="L2549" title="All 2 branches missed.">            String str = (value == Long.MIN_VALUE ? &quot;9223372036854775808&quot; : Long.toString(Math.abs(value)));</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">            if (str.length() &gt; maxWidth) {</span>
<span class="nc" id="L2551">                throw new DateTimeException(&quot;Field &quot; + field +</span>
                    &quot; cannot be printed as the value &quot; + value +
                    &quot; exceeds the maximum print width of &quot; + maxWidth);
            }
<span class="nc" id="L2555">            str = decimalStyle.convertNumberToI18N(str);</span>

<span class="nc bnc" id="L2557" title="All 2 branches missed.">            if (value &gt;= 0) {</span>
<span class="nc bnc" id="L2558" title="All 3 branches missed.">                switch (signStyle) {</span>
                    case EXCEEDS_PAD:
<span class="nc bnc" id="L2560" title="All 4 branches missed.">                        if (minWidth &lt; 19 &amp;&amp; value &gt;= EXCEED_POINTS[minWidth]) {</span>
<span class="nc" id="L2561">                            buf.append(decimalStyle.getPositiveSign());</span>
                        }
                        break;
                    case ALWAYS:
<span class="nc" id="L2565">                        buf.append(decimalStyle.getPositiveSign());</span>
<span class="nc" id="L2566">                        break;</span>
                }
            } else {
<span class="nc bnc" id="L2569" title="All 3 branches missed.">                switch (signStyle) {</span>
                    case NORMAL:
                    case EXCEEDS_PAD:
                    case ALWAYS:
<span class="nc" id="L2573">                        buf.append(decimalStyle.getNegativeSign());</span>
<span class="nc" id="L2574">                        break;</span>
                    case NOT_NEGATIVE:
<span class="nc" id="L2576">                        throw new DateTimeException(&quot;Field &quot; + field +</span>
                            &quot; cannot be printed as the value &quot; + value +
                            &quot; cannot be negative according to the SignStyle&quot;);
                }
            }
<span class="nc bnc" id="L2581" title="All 2 branches missed.">            for (int i = 0; i &lt; minWidth - str.length(); i++) {</span>
<span class="nc" id="L2582">                buf.append(decimalStyle.getZeroDigit());</span>
            }
<span class="nc" id="L2584">            buf.append(str);</span>
<span class="nc" id="L2585">            return true;</span>
        }

        /**
         * Gets the value to output.
         *
         * @param context  the context
         * @param value  the value of the field, not null
         * @return the value
         */
        long getValue(DateTimePrintContext context, long value) {
<span class="nc" id="L2596">            return value;</span>
        }

        boolean isFixedWidth() {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">            return subsequentWidth == -1;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L2605">            int length = text.length();</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">            if (position == length) {</span>
<span class="nc" id="L2607">                return ~position;</span>
            }
<span class="nc" id="L2609">            char sign = text.charAt(position);  // IOOBE if invalid position</span>
<span class="nc" id="L2610">            boolean negative = false;</span>
<span class="nc" id="L2611">            boolean positive = false;</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">            if (sign == context.getDecimalStyle().getPositiveSign()) {</span>
<span class="nc bnc" id="L2613" title="All 4 branches missed.">                if (signStyle.parse(true, context.isStrict(), minWidth == maxWidth) == false) {</span>
<span class="nc" id="L2614">                    return ~position;</span>
                }
<span class="nc" id="L2616">                positive = true;</span>
<span class="nc" id="L2617">                position++;</span>
<span class="nc bnc" id="L2618" title="All 2 branches missed.">            } else if (sign == context.getDecimalStyle().getNegativeSign()) {</span>
<span class="nc bnc" id="L2619" title="All 4 branches missed.">                if (signStyle.parse(false, context.isStrict(), minWidth == maxWidth) == false) {</span>
<span class="nc" id="L2620">                    return ~position;</span>
                }
<span class="nc" id="L2622">                negative = true;</span>
<span class="nc" id="L2623">                position++;</span>
            } else {
<span class="nc bnc" id="L2625" title="All 4 branches missed.">                if (signStyle == SignStyle.ALWAYS &amp;&amp; context.isStrict()) {</span>
<span class="nc" id="L2626">                    return ~position;</span>
                }
            }
<span class="nc bnc" id="L2629" title="All 4 branches missed.">            int effMinWidth = (context.isStrict() || isFixedWidth() ? minWidth : 1);</span>
<span class="nc" id="L2630">            int minEndPos = position + effMinWidth;</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">            if (minEndPos &gt; length) {</span>
<span class="nc" id="L2632">                return ~position;</span>
            }
<span class="nc bnc" id="L2634" title="All 4 branches missed.">            int effMaxWidth = (context.isStrict() || isFixedWidth() ? maxWidth : 9) + Math.max(subsequentWidth, 0);</span>
<span class="nc" id="L2635">            long total = 0;</span>
<span class="nc" id="L2636">            BigInteger totalBig = null;</span>
<span class="nc" id="L2637">            int pos = position;</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">            for (int pass = 0; pass &lt; 2; pass++) {</span>
<span class="nc" id="L2639">                int maxEndPos = Math.min(pos + effMaxWidth, length);</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">                while (pos &lt; maxEndPos) {</span>
<span class="nc" id="L2641">                    char ch = text.charAt(pos++);</span>
<span class="nc" id="L2642">                    int digit = context.getDecimalStyle().convertToDigit(ch);</span>
<span class="nc bnc" id="L2643" title="All 2 branches missed.">                    if (digit &lt; 0) {</span>
<span class="nc" id="L2644">                        pos--;</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">                        if (pos &lt; minEndPos) {</span>
<span class="nc" id="L2646">                            return ~position;  // need at least min width digits</span>
                        }
                        break;
                    }
<span class="nc bnc" id="L2650" title="All 2 branches missed.">                    if ((pos - position) &gt; 18) {</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">                        if (totalBig == null) {</span>
<span class="nc" id="L2652">                            totalBig = BigInteger.valueOf(total);</span>
                        }
<span class="nc" id="L2654">                        totalBig = totalBig.multiply(BigInteger.TEN).add(BigInteger.valueOf(digit));</span>
                    } else {
<span class="nc" id="L2656">                        total = total * 10 + digit;</span>
                    }
<span class="nc" id="L2658">                }</span>
<span class="nc bnc" id="L2659" title="All 4 branches missed.">                if (subsequentWidth &gt; 0 &amp;&amp; pass == 0) {</span>
                    // re-parse now we know the correct width
<span class="nc" id="L2661">                    int parseLen = pos - position;</span>
<span class="nc" id="L2662">                    effMaxWidth = Math.max(effMinWidth, parseLen - subsequentWidth);</span>
<span class="nc" id="L2663">                    pos = position;</span>
<span class="nc" id="L2664">                    total = 0;</span>
<span class="nc" id="L2665">                    totalBig = null;</span>
                } else {
                    break;
                }
            }
<span class="nc bnc" id="L2670" title="All 2 branches missed.">            if (negative) {</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">                if (totalBig != null) {</span>
<span class="nc bnc" id="L2672" title="All 4 branches missed.">                    if (totalBig.equals(BigInteger.ZERO) &amp;&amp; context.isStrict()) {</span>
<span class="nc" id="L2673">                        return ~(position - 1);  // minus zero not allowed</span>
                    }
<span class="nc" id="L2675">                    totalBig = totalBig.negate();</span>
                } else {
<span class="nc bnc" id="L2677" title="All 4 branches missed.">                    if (total == 0 &amp;&amp; context.isStrict()) {</span>
<span class="nc" id="L2678">                        return ~(position - 1);  // minus zero not allowed</span>
                    }
<span class="nc" id="L2680">                    total = -total;</span>
                }
<span class="nc bnc" id="L2682" title="All 4 branches missed.">            } else if (signStyle == SignStyle.EXCEEDS_PAD &amp;&amp; context.isStrict()) {</span>
<span class="nc" id="L2683">                int parseLen = pos - position;</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                if (positive) {</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">                    if (parseLen &lt;= minWidth) {</span>
<span class="nc" id="L2686">                        return ~(position - 1);  // '+' only parsed if minWidth exceeded</span>
                    }
                } else {
<span class="nc bnc" id="L2689" title="All 2 branches missed.">                    if (parseLen &gt; minWidth) {</span>
<span class="nc" id="L2690">                        return ~position;  // '+' must be parsed if minWidth exceeded</span>
                    }
                }
            }
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            if (totalBig != null) {</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">                if (totalBig.bitLength() &gt; 63) {</span>
                    // overflow, parse 1 less digit
<span class="nc" id="L2697">                    totalBig = totalBig.divide(BigInteger.TEN);</span>
<span class="nc" id="L2698">                    pos--;</span>
                }
<span class="nc" id="L2700">                return setValue(context, totalBig.longValue(), position, pos);</span>
            }
<span class="nc" id="L2702">            return setValue(context, total, position, pos);</span>
        }

        /**
         * Stores the value.
         *
         * @param context  the context to store into, not null
         * @param value  the value
         * @param errorPos  the position of the field being parsed
         * @param successPos  the position after the field being parsed
         * @return the new position
         */
        int setValue(DateTimeParseContext context, long value, int errorPos, int successPos) {
<span class="nc" id="L2715">            return context.setParsedField(field, value, errorPos, successPos);</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L2720" title="All 6 branches missed.">            if (minWidth == 1 &amp;&amp; maxWidth == 19 &amp;&amp; signStyle == SignStyle.NORMAL) {</span>
<span class="nc" id="L2721">                return &quot;Value(&quot; + field + &quot;)&quot;;</span>
            }
<span class="nc bnc" id="L2723" title="All 4 branches missed.">            if (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) {</span>
<span class="nc" id="L2724">                return &quot;Value(&quot; + field + &quot;,&quot; + minWidth + &quot;)&quot;;</span>
            }
<span class="nc" id="L2726">            return &quot;Value(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth + &quot;,&quot; + signStyle + &quot;)&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints and parses a reduced numeric date-time field.
     */
    static final class ReducedPrinterParser extends NumberPrinterParser {
        /**
         * The base date for reduced value parsing.
         */
<span class="nc" id="L2738">        static final LocalDate BASE_DATE = LocalDate.of(2000, 1, 1);</span>

        private final int baseValue;
        private final ChronoLocalDate baseDate;

        /**
         * Constructor.
         *
         * @param field  the field to format, validated not null
         * @param minWidth  the minimum field width, from 1 to 10
         * @param maxWidth  the maximum field width, from 1 to 10
         * @param baseValue  the base value
         * @param baseDate  the base date
         */
        ReducedPrinterParser(TemporalField field, int minWidth, int maxWidth,
                int baseValue, ChronoLocalDate baseDate) {
<span class="nc" id="L2754">            this(field, minWidth, maxWidth, baseValue, baseDate, 0);</span>
<span class="nc bnc" id="L2755" title="All 4 branches missed.">            if (minWidth &lt; 1 || minWidth &gt; 10) {</span>
<span class="nc" id="L2756">                throw new IllegalArgumentException(&quot;The minWidth must be from 1 to 10 inclusive but was &quot; + minWidth);</span>
            }
<span class="nc bnc" id="L2758" title="All 4 branches missed.">            if (maxWidth &lt; 1 || maxWidth &gt; 10) {</span>
<span class="nc" id="L2759">                throw new IllegalArgumentException(&quot;The maxWidth must be from 1 to 10 inclusive but was &quot; + minWidth);</span>
            }
<span class="nc bnc" id="L2761" title="All 2 branches missed.">            if (maxWidth &lt; minWidth) {</span>
<span class="nc" id="L2762">                throw new IllegalArgumentException(&quot;Maximum width must exceed or equal the minimum width but &quot; +</span>
                        maxWidth + &quot; &lt; &quot; + minWidth);
            }
<span class="nc bnc" id="L2765" title="All 2 branches missed.">            if (baseDate == null) {</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">                if (field.range().isValidValue(baseValue) == false) {</span>
<span class="nc" id="L2767">                    throw new IllegalArgumentException(&quot;The base value must be within the range of the field&quot;);</span>
                }
<span class="nc bnc" id="L2769" title="All 2 branches missed.">                if ((((long) baseValue) + EXCEED_POINTS[maxWidth]) &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L2770">                    throw new DateTimeException(&quot;Unable to add printer-parser as the range exceeds the capacity of an int&quot;);</span>
                }
            }
<span class="nc" id="L2773">        }</span>

        /**
         * Constructor.
         * The arguments have already been checked.
         *
         * @param field  the field to format, validated not null
         * @param minWidth  the minimum field width, from 1 to 10
         * @param maxWidth  the maximum field width, from 1 to 10
         * @param baseValue  the base value
         * @param baseDate  the base date
         * @param subsequentWidth the subsequentWidth for this instance
         */
        private ReducedPrinterParser(TemporalField field, int minWidth, int maxWidth,
                int baseValue, ChronoLocalDate baseDate, int subsequentWidth) {
<span class="nc" id="L2788">            super(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth);</span>
<span class="nc" id="L2789">            this.baseValue = baseValue;</span>
<span class="nc" id="L2790">            this.baseDate = baseDate;</span>
<span class="nc" id="L2791">        }</span>

        @Override
        long getValue(DateTimePrintContext context, long value) {
<span class="nc" id="L2795">            long absValue = Math.abs(value);</span>
<span class="nc" id="L2796">            int baseValue = this.baseValue;</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">            if (baseDate != null) {</span>
<span class="nc" id="L2798">                Chronology chrono = Chronology.from(context.getTemporal());</span>
<span class="nc" id="L2799">                baseValue = chrono.date(baseDate).get(field);</span>
            }
<span class="nc bnc" id="L2801" title="All 4 branches missed.">            if (value &gt;= baseValue &amp;&amp; value &lt; baseValue + EXCEED_POINTS[minWidth]) {</span>
                // Use the reduced value if it fits in minWidth
<span class="nc" id="L2803">                return absValue % EXCEED_POINTS[minWidth];</span>
            }
            // Otherwise truncate to fit in maxWidth
<span class="nc" id="L2806">            return absValue % EXCEED_POINTS[maxWidth];</span>
        }

        @Override
        int setValue(DateTimeParseContext context, long value, int errorPos, int successPos) {
<span class="nc" id="L2811">            int baseValue = this.baseValue;</span>
<span class="nc bnc" id="L2812" title="All 2 branches missed.">            if (baseDate != null) {</span>
<span class="nc" id="L2813">                Chronology chrono = context.getEffectiveChronology();</span>
<span class="nc" id="L2814">                baseValue = chrono.date(baseDate).get(field);</span>

                // In case the Chronology is changed later, add a callback when/if it changes
<span class="nc" id="L2817">                final long initialValue = value;</span>
<span class="nc" id="L2818">                context.addChronoChangedListener(</span>
                        (_unused) -&gt;  {
                            /* Repeat the set of the field using the current Chronology
                             * The success/error position is ignored because the value is
                             * intentionally being overwritten.
                             */
                            setValue(context, initialValue, errorPos, successPos);
                        });
            }
<span class="nc" id="L2827">            int parseLen = successPos - errorPos;</span>
<span class="nc bnc" id="L2828" title="All 4 branches missed.">            if (parseLen == minWidth &amp;&amp; value &gt;= 0) {</span>
<span class="nc" id="L2829">                long range = EXCEED_POINTS[minWidth];</span>
<span class="nc" id="L2830">                long lastPart = baseValue % range;</span>
<span class="nc" id="L2831">                long basePart = baseValue - lastPart;</span>
<span class="nc bnc" id="L2832" title="All 2 branches missed.">                if (baseValue &gt; 0) {</span>
<span class="nc" id="L2833">                    value = basePart + value;</span>
                } else {
<span class="nc" id="L2835">                    value = basePart - value;</span>
                }
<span class="nc bnc" id="L2837" title="All 2 branches missed.">                if (value &lt; baseValue) {</span>
<span class="nc" id="L2838">                    value += range;</span>
                }
            }
<span class="nc" id="L2841">            return context.setParsedField(field, value, errorPos, successPos);</span>
        }

        /**
         * Returns a new instance with fixed width flag set.
         *
         * @return a new updated printer-parser, not null
         */
        @Override
        ReducedPrinterParser withFixedWidth() {
<span class="nc bnc" id="L2851" title="All 2 branches missed.">            if (subsequentWidth == -1) {</span>
<span class="nc" id="L2852">                return this;</span>
            }
<span class="nc" id="L2854">            return new ReducedPrinterParser(field, minWidth, maxWidth, baseValue, baseDate, -1);</span>
        }

        /**
         * Returns a new instance with an updated subsequent width.
         *
         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
         * @return a new updated printer-parser, not null
         */
        @Override
        ReducedPrinterParser withSubsequentWidth(int subsequentWidth) {
<span class="nc" id="L2865">            return new ReducedPrinterParser(field, minWidth, maxWidth, baseValue, baseDate,</span>
                    this.subsequentWidth + subsequentWidth);
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L2871" title="All 2 branches missed.">            return &quot;ReducedValue(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth + &quot;,&quot; + (baseDate != null ? baseDate : baseValue) + &quot;)&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints and parses a numeric date-time field with optional padding.
     */
    static final class FractionPrinterParser implements DateTimePrinterParser {
        private final TemporalField field;
        private final int minWidth;
        private final int maxWidth;
        private final boolean decimalPoint;

        /**
         * Constructor.
         *
         * @param field  the field to output, not null
         * @param minWidth  the minimum width to output, from 0 to 9
         * @param maxWidth  the maximum width to output, from 0 to 9
         * @param decimalPoint  whether to output the localized decimal point symbol
         */
<span class="nc" id="L2893">        FractionPrinterParser(TemporalField field, int minWidth, int maxWidth, boolean decimalPoint) {</span>
<span class="nc" id="L2894">            Objects.requireNonNull(field, &quot;field&quot;);</span>
<span class="nc bnc" id="L2895" title="All 2 branches missed.">            if (field.range().isFixed() == false) {</span>
<span class="nc" id="L2896">                throw new IllegalArgumentException(&quot;Field must have a fixed set of values: &quot; + field);</span>
            }
<span class="nc bnc" id="L2898" title="All 4 branches missed.">            if (minWidth &lt; 0 || minWidth &gt; 9) {</span>
<span class="nc" id="L2899">                throw new IllegalArgumentException(&quot;Minimum width must be from 0 to 9 inclusive but was &quot; + minWidth);</span>
            }
<span class="nc bnc" id="L2901" title="All 4 branches missed.">            if (maxWidth &lt; 1 || maxWidth &gt; 9) {</span>
<span class="nc" id="L2902">                throw new IllegalArgumentException(&quot;Maximum width must be from 1 to 9 inclusive but was &quot; + maxWidth);</span>
            }
<span class="nc bnc" id="L2904" title="All 2 branches missed.">            if (maxWidth &lt; minWidth) {</span>
<span class="nc" id="L2905">                throw new IllegalArgumentException(&quot;Maximum width must exceed or equal the minimum width but &quot; +</span>
                        maxWidth + &quot; &lt; &quot; + minWidth);
            }
<span class="nc" id="L2908">            this.field = field;</span>
<span class="nc" id="L2909">            this.minWidth = minWidth;</span>
<span class="nc" id="L2910">            this.maxWidth = maxWidth;</span>
<span class="nc" id="L2911">            this.decimalPoint = decimalPoint;</span>
<span class="nc" id="L2912">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L2916">            Long value = context.getValue(field);</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L2918">                return false;</span>
            }
<span class="nc" id="L2920">            DecimalStyle decimalStyle = context.getDecimalStyle();</span>
<span class="nc" id="L2921">            BigDecimal fraction = convertToFraction(value);</span>
<span class="nc bnc" id="L2922" title="All 2 branches missed.">            if (fraction.scale() == 0) {  // scale is zero if value is zero</span>
<span class="nc bnc" id="L2923" title="All 2 branches missed.">                if (minWidth &gt; 0) {</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">                    if (decimalPoint) {</span>
<span class="nc" id="L2925">                        buf.append(decimalStyle.getDecimalSeparator());</span>
                    }
<span class="nc bnc" id="L2927" title="All 2 branches missed.">                    for (int i = 0; i &lt; minWidth; i++) {</span>
<span class="nc" id="L2928">                        buf.append(decimalStyle.getZeroDigit());</span>
                    }
                }
            } else {
<span class="nc" id="L2932">                int outputScale = Math.min(Math.max(fraction.scale(), minWidth), maxWidth);</span>
<span class="nc" id="L2933">                fraction = fraction.setScale(outputScale, RoundingMode.FLOOR);</span>
<span class="nc" id="L2934">                String str = fraction.toPlainString().substring(2);</span>
<span class="nc" id="L2935">                str = decimalStyle.convertNumberToI18N(str);</span>
<span class="nc bnc" id="L2936" title="All 2 branches missed.">                if (decimalPoint) {</span>
<span class="nc" id="L2937">                    buf.append(decimalStyle.getDecimalSeparator());</span>
                }
<span class="nc" id="L2939">                buf.append(str);</span>
            }
<span class="nc" id="L2941">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc bnc" id="L2946" title="All 2 branches missed.">            int effectiveMin = (context.isStrict() ? minWidth : 0);</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">            int effectiveMax = (context.isStrict() ? maxWidth : 9);</span>
<span class="nc" id="L2948">            int length = text.length();</span>
<span class="nc bnc" id="L2949" title="All 2 branches missed.">            if (position == length) {</span>
                // valid if whole field is optional, invalid if minimum width
<span class="nc bnc" id="L2951" title="All 2 branches missed.">                return (effectiveMin &gt; 0 ? ~position : position);</span>
            }
<span class="nc bnc" id="L2953" title="All 2 branches missed.">            if (decimalPoint) {</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                if (text.charAt(position) != context.getDecimalStyle().getDecimalSeparator()) {</span>
                    // valid if whole field is optional, invalid if minimum width
<span class="nc bnc" id="L2956" title="All 2 branches missed.">                    return (effectiveMin &gt; 0 ? ~position : position);</span>
                }
<span class="nc" id="L2958">                position++;</span>
            }
<span class="nc" id="L2960">            int minEndPos = position + effectiveMin;</span>
<span class="nc bnc" id="L2961" title="All 2 branches missed.">            if (minEndPos &gt; length) {</span>
<span class="nc" id="L2962">                return ~position;  // need at least min width digits</span>
            }
<span class="nc" id="L2964">            int maxEndPos = Math.min(position + effectiveMax, length);</span>
<span class="nc" id="L2965">            int total = 0;  // can use int because we are only parsing up to 9 digits</span>
<span class="nc" id="L2966">            int pos = position;</span>
<span class="nc bnc" id="L2967" title="All 2 branches missed.">            while (pos &lt; maxEndPos) {</span>
<span class="nc" id="L2968">                char ch = text.charAt(pos++);</span>
<span class="nc" id="L2969">                int digit = context.getDecimalStyle().convertToDigit(ch);</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                if (digit &lt; 0) {</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">                    if (pos &lt; minEndPos) {</span>
<span class="nc" id="L2972">                        return ~position;  // need at least min width digits</span>
                    }
<span class="nc" id="L2974">                    pos--;</span>
<span class="nc" id="L2975">                    break;</span>
                }
<span class="nc" id="L2977">                total = total * 10 + digit;</span>
<span class="nc" id="L2978">            }</span>
<span class="nc" id="L2979">            BigDecimal fraction = new BigDecimal(total).movePointLeft(pos - position);</span>
<span class="nc" id="L2980">            long value = convertFromFraction(fraction);</span>
<span class="nc" id="L2981">            return context.setParsedField(field, value, position, pos);</span>
        }

        /**
         * Converts a value for this field to a fraction between 0 and 1.
         * &lt;p&gt;
         * The fractional value is between 0 (inclusive) and 1 (exclusive).
         * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
         * The fraction is obtained by calculation from the field range using 9 decimal
         * places and a rounding mode of {@link RoundingMode#FLOOR FLOOR}.
         * The calculation is inaccurate if the values do not run continuously from smallest to largest.
         * &lt;p&gt;
         * For example, the second-of-minute value of 15 would be returned as 0.25,
         * assuming the standard definition of 60 seconds in a minute.
         *
         * @param value  the value to convert, must be valid for this rule
         * @return the value as a fraction within the range, from 0 to 1, not null
         * @throws DateTimeException if the value cannot be converted to a fraction
         */
        private BigDecimal convertToFraction(long value) {
<span class="nc" id="L3001">            ValueRange range = field.range();</span>
<span class="nc" id="L3002">            range.checkValidValue(value, field);</span>
<span class="nc" id="L3003">            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());</span>
<span class="nc" id="L3004">            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);</span>
<span class="nc" id="L3005">            BigDecimal valueBD = BigDecimal.valueOf(value).subtract(minBD);</span>
<span class="nc" id="L3006">            BigDecimal fraction = valueBD.divide(rangeBD, 9, RoundingMode.FLOOR);</span>
            // stripTrailingZeros bug
<span class="nc bnc" id="L3008" title="All 2 branches missed.">            return fraction.compareTo(BigDecimal.ZERO) == 0 ? BigDecimal.ZERO : fraction.stripTrailingZeros();</span>
        }

        /**
         * Converts a fraction from 0 to 1 for this field to a value.
         * &lt;p&gt;
         * The fractional value must be between 0 (inclusive) and 1 (exclusive).
         * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
         * The value is obtained by calculation from the field range and a rounding
         * mode of {@link RoundingMode#FLOOR FLOOR}.
         * The calculation is inaccurate if the values do not run continuously from smallest to largest.
         * &lt;p&gt;
         * For example, the fractional second-of-minute of 0.25 would be converted to 15,
         * assuming the standard definition of 60 seconds in a minute.
         *
         * @param fraction  the fraction to convert, not null
         * @return the value of the field, valid for this rule
         * @throws DateTimeException if the value cannot be converted
         */
        private long convertFromFraction(BigDecimal fraction) {
<span class="nc" id="L3028">            ValueRange range = field.range();</span>
<span class="nc" id="L3029">            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());</span>
<span class="nc" id="L3030">            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);</span>
<span class="nc" id="L3031">            BigDecimal valueBD = fraction.multiply(rangeBD).setScale(0, RoundingMode.FLOOR).add(minBD);</span>
<span class="nc" id="L3032">            return valueBD.longValueExact();</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L3037" title="All 2 branches missed.">            String decimal = (decimalPoint ? &quot;,DecimalPoint&quot; : &quot;&quot;);</span>
<span class="nc" id="L3038">            return &quot;Fraction(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth + decimal + &quot;)&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses field text.
     */
    static final class TextPrinterParser implements DateTimePrinterParser {
        private final TemporalField field;
        private final TextStyle textStyle;
        private final DateTimeTextProvider provider;
        /**
         * The cached number printer parser.
         * Immutable and volatile, so no synchronization needed.
         */
        private volatile NumberPrinterParser numberPrinterParser;

        /**
         * Constructor.
         *
         * @param field  the field to output, not null
         * @param textStyle  the text style, not null
         * @param provider  the text provider, not null
         */
<span class="nc" id="L3063">        TextPrinterParser(TemporalField field, TextStyle textStyle, DateTimeTextProvider provider) {</span>
            // validated by caller
<span class="nc" id="L3065">            this.field = field;</span>
<span class="nc" id="L3066">            this.textStyle = textStyle;</span>
<span class="nc" id="L3067">            this.provider = provider;</span>
<span class="nc" id="L3068">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L3072">            Long value = context.getValue(field);</span>
<span class="nc bnc" id="L3073" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L3074">                return false;</span>
            }
            String text;
<span class="nc" id="L3077">            Chronology chrono = context.getTemporal().query(TemporalQueries.chronology());</span>
<span class="nc bnc" id="L3078" title="All 4 branches missed.">            if (chrono == null || chrono == IsoChronology.INSTANCE) {</span>
<span class="nc" id="L3079">                text = provider.getText(field, value, textStyle, context.getLocale());</span>
            } else {
<span class="nc" id="L3081">                text = provider.getText(chrono, field, value, textStyle, context.getLocale());</span>
            }
<span class="nc bnc" id="L3083" title="All 2 branches missed.">            if (text == null) {</span>
<span class="nc" id="L3084">                return numberPrinterParser().format(context, buf);</span>
            }
<span class="nc" id="L3086">            buf.append(text);</span>
<span class="nc" id="L3087">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence parseText, int position) {
<span class="nc" id="L3092">            int length = parseText.length();</span>
<span class="nc bnc" id="L3093" title="All 4 branches missed.">            if (position &lt; 0 || position &gt; length) {</span>
<span class="nc" id="L3094">                throw new IndexOutOfBoundsException();</span>
            }
<span class="nc bnc" id="L3096" title="All 2 branches missed.">            TextStyle style = (context.isStrict() ? textStyle : null);</span>
<span class="nc" id="L3097">            Chronology chrono = context.getEffectiveChronology();</span>
            Iterator&lt;Entry&lt;String, Long&gt;&gt; it;
<span class="nc bnc" id="L3099" title="All 4 branches missed.">            if (chrono == null || chrono == IsoChronology.INSTANCE) {</span>
<span class="nc" id="L3100">                it = provider.getTextIterator(field, style, context.getLocale());</span>
            } else {
<span class="nc" id="L3102">                it = provider.getTextIterator(chrono, field, style, context.getLocale());</span>
            }
<span class="nc bnc" id="L3104" title="All 2 branches missed.">            if (it != null) {</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">                while (it.hasNext()) {</span>
<span class="nc" id="L3106">                    Entry&lt;String, Long&gt; entry = it.next();</span>
<span class="nc" id="L3107">                    String itText = entry.getKey();</span>
<span class="nc bnc" id="L3108" title="All 2 branches missed.">                    if (context.subSequenceEquals(itText, 0, parseText, position, itText.length())) {</span>
<span class="nc" id="L3109">                        return context.setParsedField(field, entry.getValue(), position, position + itText.length());</span>
                    }
<span class="nc" id="L3111">                }</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                if (context.isStrict()) {</span>
<span class="nc" id="L3113">                    return ~position;</span>
                }
            }
<span class="nc" id="L3116">            return numberPrinterParser().parse(context, parseText, position);</span>
        }

        /**
         * Create and cache a number printer parser.
         * @return the number printer parser for this field, not null
         */
        private NumberPrinterParser numberPrinterParser() {
<span class="nc bnc" id="L3124" title="All 2 branches missed.">            if (numberPrinterParser == null) {</span>
<span class="nc" id="L3125">                numberPrinterParser = new NumberPrinterParser(field, 1, 19, SignStyle.NORMAL);</span>
            }
<span class="nc" id="L3127">            return numberPrinterParser;</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L3132" title="All 2 branches missed.">            if (textStyle == TextStyle.FULL) {</span>
<span class="nc" id="L3133">                return &quot;Text(&quot; + field + &quot;)&quot;;</span>
            }
<span class="nc" id="L3135">            return &quot;Text(&quot; + field + &quot;,&quot; + textStyle + &quot;)&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses an ISO-8601 instant.
     */
    static final class InstantPrinterParser implements DateTimePrinterParser {
        // days in a 400 year cycle = 146097
        // days in a 10,000 year cycle = 146097 * 25
        // seconds per day = 86400
        private static final long SECONDS_PER_10000_YEARS = 146097L * 25L * 86400L;
        private static final long SECONDS_0000_TO_1970 = ((146097L * 5L) - (30L * 365L + 7L)) * 86400L;
        private final int fractionalDigits;

<span class="nc" id="L3151">        InstantPrinterParser(int fractionalDigits) {</span>
<span class="nc" id="L3152">            this.fractionalDigits = fractionalDigits;</span>
<span class="nc" id="L3153">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
            // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX
<span class="nc" id="L3158">            Long inSecs = context.getValue(INSTANT_SECONDS);</span>
<span class="nc" id="L3159">            Long inNanos = null;</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {</span>
<span class="nc" id="L3161">                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);</span>
            }
<span class="nc bnc" id="L3163" title="All 2 branches missed.">            if (inSecs == null) {</span>
<span class="nc" id="L3164">                return false;</span>
            }
<span class="nc" id="L3166">            long inSec = inSecs;</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);</span>
            // format mostly using LocalDateTime.toString
<span class="nc bnc" id="L3169" title="All 2 branches missed.">            if (inSec &gt;= -SECONDS_0000_TO_1970) {</span>
                // current era
<span class="nc" id="L3171">                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;</span>
<span class="nc" id="L3172">                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;</span>
<span class="nc" id="L3173">                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);</span>
<span class="nc" id="L3174">                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);</span>
<span class="nc bnc" id="L3175" title="All 2 branches missed.">                if (hi &gt; 0) {</span>
<span class="nc" id="L3176">                    buf.append('+').append(hi);</span>
                }
<span class="nc" id="L3178">                buf.append(ldt);</span>
<span class="nc bnc" id="L3179" title="All 2 branches missed.">                if (ldt.getSecond() == 0) {</span>
<span class="nc" id="L3180">                    buf.append(&quot;:00&quot;);</span>
                }
<span class="nc" id="L3182">            } else {</span>
                // before current era
<span class="nc" id="L3184">                long zeroSecs = inSec + SECONDS_0000_TO_1970;</span>
<span class="nc" id="L3185">                long hi = zeroSecs / SECONDS_PER_10000_YEARS;</span>
<span class="nc" id="L3186">                long lo = zeroSecs % SECONDS_PER_10000_YEARS;</span>
<span class="nc" id="L3187">                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);</span>
<span class="nc" id="L3188">                int pos = buf.length();</span>
<span class="nc" id="L3189">                buf.append(ldt);</span>
<span class="nc bnc" id="L3190" title="All 2 branches missed.">                if (ldt.getSecond() == 0) {</span>
<span class="nc" id="L3191">                    buf.append(&quot;:00&quot;);</span>
                }
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                if (hi &lt; 0) {</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">                    if (ldt.getYear() == -10_000) {</span>
<span class="nc" id="L3195">                        buf.replace(pos, pos + 2, Long.toString(hi - 1));</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                    } else if (lo == 0) {</span>
<span class="nc" id="L3197">                        buf.insert(pos, hi);</span>
                    } else {
<span class="nc" id="L3199">                        buf.insert(pos + 1, Math.abs(hi));</span>
                    }
                }
            }
            // add fraction
<span class="nc bnc" id="L3204" title="All 6 branches missed.">            if ((fractionalDigits &lt; 0 &amp;&amp; inNano &gt; 0) || fractionalDigits &gt; 0) {</span>
<span class="nc" id="L3205">                buf.append('.');</span>
<span class="nc" id="L3206">                int div = 100_000_000;</span>
<span class="nc bnc" id="L3207" title="All 12 branches missed.">                for (int i = 0; ((fractionalDigits == -1 &amp;&amp; inNano &gt; 0) ||</span>
                                    (fractionalDigits == -2 &amp;&amp; (inNano &gt; 0 || (i % 3) != 0)) ||
<span class="nc" id="L3209">                                    i &lt; fractionalDigits); i++) {</span>
<span class="nc" id="L3210">                    int digit = inNano / div;</span>
<span class="nc" id="L3211">                    buf.append((char) (digit + '0'));</span>
<span class="nc" id="L3212">                    inNano = inNano - (digit * div);</span>
<span class="nc" id="L3213">                    div = div / 10;</span>
                }
            }
<span class="nc" id="L3216">            buf.append('Z');</span>
<span class="nc" id="L3217">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
            // new context to avoid overwriting fields like year/month/day
<span class="nc bnc" id="L3223" title="All 2 branches missed.">            int minDigits = (fractionalDigits &lt; 0 ? 0 : fractionalDigits);</span>
<span class="nc bnc" id="L3224" title="All 2 branches missed.">            int maxDigits = (fractionalDigits &lt; 0 ? 9 : fractionalDigits);</span>
<span class="nc" id="L3225">            CompositePrinterParser parser = new DateTimeFormatterBuilder()</span>
<span class="nc" id="L3226">                    .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')</span>
<span class="nc" id="L3227">                    .appendValue(HOUR_OF_DAY, 2).appendLiteral(':')</span>
<span class="nc" id="L3228">                    .appendValue(MINUTE_OF_HOUR, 2).appendLiteral(':')</span>
<span class="nc" id="L3229">                    .appendValue(SECOND_OF_MINUTE, 2)</span>
<span class="nc" id="L3230">                    .appendFraction(NANO_OF_SECOND, minDigits, maxDigits, true)</span>
<span class="nc" id="L3231">                    .appendLiteral('Z')</span>
<span class="nc" id="L3232">                    .toFormatter().toPrinterParser(false);</span>
<span class="nc" id="L3233">            DateTimeParseContext newContext = context.copy();</span>
<span class="nc" id="L3234">            int pos = parser.parse(newContext, text, position);</span>
<span class="nc bnc" id="L3235" title="All 2 branches missed.">            if (pos &lt; 0) {</span>
<span class="nc" id="L3236">                return pos;</span>
            }
            // parser restricts most fields to 2 digits, so definitely int
            // correctly parsed nano is also guaranteed to be valid
<span class="nc" id="L3240">            long yearParsed = newContext.getParsed(YEAR);</span>
<span class="nc" id="L3241">            int month = newContext.getParsed(MONTH_OF_YEAR).intValue();</span>
<span class="nc" id="L3242">            int day = newContext.getParsed(DAY_OF_MONTH).intValue();</span>
<span class="nc" id="L3243">            int hour = newContext.getParsed(HOUR_OF_DAY).intValue();</span>
<span class="nc" id="L3244">            int min = newContext.getParsed(MINUTE_OF_HOUR).intValue();</span>
<span class="nc" id="L3245">            Long secVal = newContext.getParsed(SECOND_OF_MINUTE);</span>
<span class="nc" id="L3246">            Long nanoVal = newContext.getParsed(NANO_OF_SECOND);</span>
<span class="nc bnc" id="L3247" title="All 2 branches missed.">            int sec = (secVal != null ? secVal.intValue() : 0);</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">            int nano = (nanoVal != null ? nanoVal.intValue() : 0);</span>
<span class="nc" id="L3249">            int days = 0;</span>
<span class="nc bnc" id="L3250" title="All 8 branches missed.">            if (hour == 24 &amp;&amp; min == 0 &amp;&amp; sec == 0 &amp;&amp; nano == 0) {</span>
<span class="nc" id="L3251">                hour = 0;</span>
<span class="nc" id="L3252">                days = 1;</span>
<span class="nc bnc" id="L3253" title="All 6 branches missed.">            } else if (hour == 23 &amp;&amp; min == 59 &amp;&amp; sec == 60) {</span>
<span class="nc" id="L3254">                context.setParsedLeapSecond();</span>
<span class="nc" id="L3255">                sec = 59;</span>
            }
<span class="nc" id="L3257">            int year = (int) yearParsed % 10_000;</span>
            long instantSecs;
            try {
<span class="nc" id="L3260">                LocalDateTime ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);</span>
<span class="nc" id="L3261">                instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);</span>
<span class="nc" id="L3262">                instantSecs += Math.multiplyExact(yearParsed / 10_000L, SECONDS_PER_10000_YEARS);</span>
<span class="nc" id="L3263">            } catch (RuntimeException ex) {</span>
<span class="nc" id="L3264">                return ~position;</span>
<span class="nc" id="L3265">            }</span>
<span class="nc" id="L3266">            int successPos = text.length();</span>
<span class="nc" id="L3267">            successPos = context.setParsedField(INSTANT_SECONDS, instantSecs, position, successPos);</span>
<span class="nc" id="L3268">            return context.setParsedField(NANO_OF_SECOND, nano, position, successPos);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L3273">            return &quot;Instant()&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses an offset ID.
     */
    static final class OffsetIdPrinterParser implements DateTimePrinterParser {
<span class="nc" id="L3282">        static final String[] PATTERNS = new String[] {</span>
            &quot;+HH&quot;, &quot;+HHmm&quot;, &quot;+HH:mm&quot;, &quot;+HHMM&quot;, &quot;+HH:MM&quot;, &quot;+HHMMss&quot;, &quot;+HH:MM:ss&quot;, &quot;+HHMMSS&quot;, &quot;+HH:MM:SS&quot;,
        };  // order used in pattern builder
<span class="nc" id="L3285">        static final OffsetIdPrinterParser INSTANCE_ID_Z = new OffsetIdPrinterParser(&quot;+HH:MM:ss&quot;, &quot;Z&quot;);</span>
<span class="nc" id="L3286">        static final OffsetIdPrinterParser INSTANCE_ID_ZERO = new OffsetIdPrinterParser(&quot;+HH:MM:ss&quot;, &quot;0&quot;);</span>

        private final String noOffsetText;
        private final int type;

        /**
         * Constructor.
         *
         * @param pattern  the pattern
         * @param noOffsetText  the text to use for UTC, not null
         */
<span class="nc" id="L3297">        OffsetIdPrinterParser(String pattern, String noOffsetText) {</span>
<span class="nc" id="L3298">            Objects.requireNonNull(pattern, &quot;pattern&quot;);</span>
<span class="nc" id="L3299">            Objects.requireNonNull(noOffsetText, &quot;noOffsetText&quot;);</span>
<span class="nc" id="L3300">            this.type = checkPattern(pattern);</span>
<span class="nc" id="L3301">            this.noOffsetText = noOffsetText;</span>
<span class="nc" id="L3302">        }</span>

        private int checkPattern(String pattern) {
<span class="nc bnc" id="L3305" title="All 2 branches missed.">            for (int i = 0; i &lt; PATTERNS.length; i++) {</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">                if (PATTERNS[i].equals(pattern)) {</span>
<span class="nc" id="L3307">                    return i;</span>
                }
            }
<span class="nc" id="L3310">            throw new IllegalArgumentException(&quot;Invalid zone offset pattern: &quot; + pattern);</span>
        }

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L3315">            Long offsetSecs = context.getValue(OFFSET_SECONDS);</span>
<span class="nc bnc" id="L3316" title="All 2 branches missed.">            if (offsetSecs == null) {</span>
<span class="nc" id="L3317">                return false;</span>
            }
<span class="nc" id="L3319">            int totalSecs = Math.toIntExact(offsetSecs);</span>
<span class="nc bnc" id="L3320" title="All 2 branches missed.">            if (totalSecs == 0) {</span>
<span class="nc" id="L3321">                buf.append(noOffsetText);</span>
            } else {
<span class="nc" id="L3323">                int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped</span>
<span class="nc" id="L3324">                int absMinutes = Math.abs((totalSecs / 60) % 60);</span>
<span class="nc" id="L3325">                int absSeconds = Math.abs(totalSecs % 60);</span>
<span class="nc" id="L3326">                int bufPos = buf.length();</span>
<span class="nc" id="L3327">                int output = absHours;</span>
<span class="nc bnc" id="L3328" title="All 2 branches missed.">                buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;)</span>
<span class="nc" id="L3329">                    .append((char) (absHours / 10 + '0')).append((char) (absHours % 10 + '0'));</span>
<span class="nc bnc" id="L3330" title="All 6 branches missed.">                if (type &gt;= 3 || (type &gt;= 1 &amp;&amp; absMinutes &gt; 0)) {</span>
<span class="nc bnc" id="L3331" title="All 2 branches missed.">                    buf.append((type % 2) == 0 ? &quot;:&quot; : &quot;&quot;)</span>
<span class="nc" id="L3332">                        .append((char) (absMinutes / 10 + '0')).append((char) (absMinutes % 10 + '0'));</span>
<span class="nc" id="L3333">                    output += absMinutes;</span>
<span class="nc bnc" id="L3334" title="All 6 branches missed.">                    if (type &gt;= 7 || (type &gt;= 5 &amp;&amp; absSeconds &gt; 0)) {</span>
<span class="nc bnc" id="L3335" title="All 2 branches missed.">                        buf.append((type % 2) == 0 ? &quot;:&quot; : &quot;&quot;)</span>
<span class="nc" id="L3336">                            .append((char) (absSeconds / 10 + '0')).append((char) (absSeconds % 10 + '0'));</span>
<span class="nc" id="L3337">                        output += absSeconds;</span>
                    }
                }
<span class="nc bnc" id="L3340" title="All 2 branches missed.">                if (output == 0) {</span>
<span class="nc" id="L3341">                    buf.setLength(bufPos);</span>
<span class="nc" id="L3342">                    buf.append(noOffsetText);</span>
                }
            }
<span class="nc" id="L3345">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L3350">            int length = text.length();</span>
<span class="nc" id="L3351">            int noOffsetLen = noOffsetText.length();</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">            if (noOffsetLen == 0) {</span>
<span class="nc bnc" id="L3353" title="All 2 branches missed.">                if (position == length) {</span>
<span class="nc" id="L3354">                    return context.setParsedField(OFFSET_SECONDS, 0, position, position);</span>
                }
            } else {
<span class="nc bnc" id="L3357" title="All 2 branches missed.">                if (position == length) {</span>
<span class="nc" id="L3358">                    return ~position;</span>
                }
<span class="nc bnc" id="L3360" title="All 2 branches missed.">                if (context.subSequenceEquals(text, position, noOffsetText, 0, noOffsetLen)) {</span>
<span class="nc" id="L3361">                    return context.setParsedField(OFFSET_SECONDS, 0, position, position + noOffsetLen);</span>
                }
            }

            // parse normal plus/minus offset
<span class="nc" id="L3366">            char sign = text.charAt(position);  // IOOBE if invalid position</span>
<span class="nc bnc" id="L3367" title="All 4 branches missed.">            if (sign == '+' || sign == '-') {</span>
                // starts
<span class="nc bnc" id="L3369" title="All 2 branches missed.">                int negative = (sign == '-' ? -1 : 1);</span>
<span class="nc" id="L3370">                int[] array = new int[4];</span>
<span class="nc" id="L3371">                array[0] = position + 1;</span>
<span class="nc bnc" id="L3372" title="All 4 branches missed.">                if ((parseNumber(array, 1, text, true) ||</span>
<span class="nc bnc" id="L3373" title="All 2 branches missed.">                        parseNumber(array, 2, text, type &gt;=3) ||</span>
<span class="nc bnc" id="L3374" title="All 4 branches missed.">                        parseNumber(array, 3, text, false)) == false) {</span>
                    // success
<span class="nc" id="L3376">                    long offsetSecs = negative * (array[1] * 3600L + array[2] * 60L + array[3]);</span>
<span class="nc" id="L3377">                    return context.setParsedField(OFFSET_SECONDS, offsetSecs, position, array[0]);</span>
                }
            }
            // handle special case of empty no offset text
<span class="nc bnc" id="L3381" title="All 2 branches missed.">            if (noOffsetLen == 0) {</span>
<span class="nc" id="L3382">                return context.setParsedField(OFFSET_SECONDS, 0, position, position + noOffsetLen);</span>
            }
<span class="nc" id="L3384">            return ~position;</span>
        }

        /**
         * Parse a two digit zero-prefixed number.
         *
         * @param array  the array of parsed data, 0=pos,1=hours,2=mins,3=secs, not null
         * @param arrayIndex  the index to parse the value into
         * @param parseText  the offset ID, not null
         * @param required  whether this number is required
         * @return true if an error occurred
         */
        private boolean parseNumber(int[] array, int arrayIndex, CharSequence parseText, boolean required) {
<span class="nc bnc" id="L3397" title="All 2 branches missed.">            if ((type + 3) / 2 &lt; arrayIndex) {</span>
<span class="nc" id="L3398">                return false;  // ignore seconds/minutes</span>
            }
<span class="nc" id="L3400">            int pos = array[0];</span>
<span class="nc bnc" id="L3401" title="All 4 branches missed.">            if ((type % 2) == 0 &amp;&amp; arrayIndex &gt; 1) {</span>
<span class="nc bnc" id="L3402" title="All 4 branches missed.">                if (pos + 1 &gt; parseText.length() || parseText.charAt(pos) != ':') {</span>
<span class="nc" id="L3403">                    return required;</span>
                }
<span class="nc" id="L3405">                pos++;</span>
            }
<span class="nc bnc" id="L3407" title="All 2 branches missed.">            if (pos + 2 &gt; parseText.length()) {</span>
<span class="nc" id="L3408">                return required;</span>
            }
<span class="nc" id="L3410">            char ch1 = parseText.charAt(pos++);</span>
<span class="nc" id="L3411">            char ch2 = parseText.charAt(pos++);</span>
<span class="nc bnc" id="L3412" title="All 8 branches missed.">            if (ch1 &lt; '0' || ch1 &gt; '9' || ch2 &lt; '0' || ch2 &gt; '9') {</span>
<span class="nc" id="L3413">                return required;</span>
            }
<span class="nc" id="L3415">            int value = (ch1 - 48) * 10 + (ch2 - 48);</span>
<span class="nc bnc" id="L3416" title="All 4 branches missed.">            if (value &lt; 0 || value &gt; 59) {</span>
<span class="nc" id="L3417">                return required;</span>
            }
<span class="nc" id="L3419">            array[arrayIndex] = value;</span>
<span class="nc" id="L3420">            array[0] = pos;</span>
<span class="nc" id="L3421">            return false;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L3426">            String converted = noOffsetText.replace(&quot;'&quot;, &quot;''&quot;);</span>
<span class="nc" id="L3427">            return &quot;Offset(&quot; + PATTERNS[type] + &quot;,'&quot; + converted + &quot;')&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses an offset ID.
     */
    static final class LocalizedOffsetIdPrinterParser implements DateTimePrinterParser {
        private final TextStyle style;

        /**
         * Constructor.
         *
         * @param style  the style, not null
         */
<span class="nc" id="L3443">        LocalizedOffsetIdPrinterParser(TextStyle style) {</span>
<span class="nc" id="L3444">            this.style = style;</span>
<span class="nc" id="L3445">        }</span>

        private static StringBuilder appendHMS(StringBuilder buf, int t) {
<span class="nc" id="L3448">            return buf.append((char)(t / 10 + '0'))</span>
<span class="nc" id="L3449">                      .append((char)(t % 10 + '0'));</span>
        }

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L3454">            Long offsetSecs = context.getValue(OFFSET_SECONDS);</span>
<span class="nc bnc" id="L3455" title="All 2 branches missed.">            if (offsetSecs == null) {</span>
<span class="nc" id="L3456">                return false;</span>
            }
<span class="nc" id="L3458">            String gmtText = &quot;GMT&quot;;  // TODO: get localized version of 'GMT'</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">            if (gmtText != null) {</span>
<span class="nc" id="L3460">                buf.append(gmtText);</span>
            }
<span class="nc" id="L3462">            int totalSecs = Math.toIntExact(offsetSecs);</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">            if (totalSecs != 0) {</span>
<span class="nc" id="L3464">                int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped</span>
<span class="nc" id="L3465">                int absMinutes = Math.abs((totalSecs / 60) % 60);</span>
<span class="nc" id="L3466">                int absSeconds = Math.abs(totalSecs % 60);</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">                buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;);</span>
<span class="nc bnc" id="L3468" title="All 2 branches missed.">                if (style == TextStyle.FULL) {</span>
<span class="nc" id="L3469">                    appendHMS(buf, absHours);</span>
<span class="nc" id="L3470">                    buf.append(':');</span>
<span class="nc" id="L3471">                    appendHMS(buf, absMinutes);</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">                    if (absSeconds != 0) {</span>
<span class="nc" id="L3473">                       buf.append(':');</span>
<span class="nc" id="L3474">                       appendHMS(buf, absSeconds);</span>
                    }
                } else {
<span class="nc bnc" id="L3477" title="All 2 branches missed.">                    if (absHours &gt;= 10) {</span>
<span class="nc" id="L3478">                        buf.append((char)(absHours / 10 + '0'));</span>
                    }
<span class="nc" id="L3480">                    buf.append((char)(absHours % 10 + '0'));</span>
<span class="nc bnc" id="L3481" title="All 4 branches missed.">                    if (absMinutes != 0 || absSeconds != 0) {</span>
<span class="nc" id="L3482">                        buf.append(':');</span>
<span class="nc" id="L3483">                        appendHMS(buf, absMinutes);</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">                        if (absSeconds != 0) {</span>
<span class="nc" id="L3485">                            buf.append(':');</span>
<span class="nc" id="L3486">                            appendHMS(buf, absSeconds);</span>
                        }
                    }
                }
            }
<span class="nc" id="L3491">            return true;</span>
        }

        int getDigit(CharSequence text, int position) {
<span class="nc" id="L3495">            char c = text.charAt(position);</span>
<span class="nc bnc" id="L3496" title="All 4 branches missed.">            if (c &lt; '0' || c &gt; '9') {</span>
<span class="nc" id="L3497">                return -1;</span>
            }
<span class="nc" id="L3499">            return c - '0';</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L3504">            int pos = position;</span>
<span class="nc" id="L3505">            int end = pos + text.length();</span>
<span class="nc" id="L3506">            String gmtText = &quot;GMT&quot;;  // TODO: get localized version of 'GMT'</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">            if (gmtText != null) {</span>
<span class="nc bnc" id="L3508" title="All 2 branches missed.">                if (!context.subSequenceEquals(text, pos, gmtText, 0, gmtText.length())) {</span>
<span class="nc" id="L3509">                    return ~position;</span>
                }
<span class="nc" id="L3511">                pos += gmtText.length();</span>
            }
            // parse normal plus/minus offset
<span class="nc" id="L3514">            int negative = 0;</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">            if (pos == end) {</span>
<span class="nc" id="L3516">                return context.setParsedField(OFFSET_SECONDS, 0, position, pos);</span>
            }
<span class="nc" id="L3518">            char sign = text.charAt(pos);  // IOOBE if invalid position</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">            if (sign == '+') {</span>
<span class="nc" id="L3520">                negative = 1;</span>
<span class="nc bnc" id="L3521" title="All 2 branches missed.">            } else if (sign == '-') {</span>
<span class="nc" id="L3522">                negative = -1;</span>
            } else {
<span class="nc" id="L3524">                return context.setParsedField(OFFSET_SECONDS, 0, position, pos);</span>
            }
<span class="nc" id="L3526">            pos++;</span>
<span class="nc" id="L3527">            int h = 0;</span>
<span class="nc" id="L3528">            int m = 0;</span>
<span class="nc" id="L3529">            int s = 0;</span>
<span class="nc bnc" id="L3530" title="All 2 branches missed.">            if (style == TextStyle.FULL) {</span>
<span class="nc" id="L3531">                int h1 = getDigit(text, pos++);</span>
<span class="nc" id="L3532">                int h2 = getDigit(text, pos++);</span>
<span class="nc bnc" id="L3533" title="All 6 branches missed.">                if (h1 &lt; 0 || h2 &lt; 0 || text.charAt(pos++) != ':') {</span>
<span class="nc" id="L3534">                    return ~position;</span>
                }
<span class="nc" id="L3536">                h = h1 * 10 + h2;</span>
<span class="nc" id="L3537">                int m1 = getDigit(text, pos++);</span>
<span class="nc" id="L3538">                int m2 = getDigit(text, pos++);</span>
<span class="nc bnc" id="L3539" title="All 4 branches missed.">                if (m1 &lt; 0 || m2 &lt; 0) {</span>
<span class="nc" id="L3540">                    return ~position;</span>
                }
<span class="nc" id="L3542">                m = m1 * 10 + m2;</span>
<span class="nc bnc" id="L3543" title="All 4 branches missed.">                if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == ':') {</span>
<span class="nc" id="L3544">                    int s1 = getDigit(text, pos + 1);</span>
<span class="nc" id="L3545">                    int s2 = getDigit(text, pos + 2);</span>
<span class="nc bnc" id="L3546" title="All 4 branches missed.">                    if (s1 &gt;= 0 &amp;&amp; s2 &gt;= 0) {</span>
<span class="nc" id="L3547">                        s = s1 * 10 + s2;</span>
<span class="nc" id="L3548">                        pos += 3;</span>
                    }
                }
<span class="nc" id="L3551">            } else {</span>
<span class="nc" id="L3552">                h = getDigit(text, pos++);</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">                if (h &lt; 0) {</span>
<span class="nc" id="L3554">                    return ~position;</span>
                }
<span class="nc bnc" id="L3556" title="All 2 branches missed.">                if (pos &lt; end) {</span>
<span class="nc" id="L3557">                    int h2 = getDigit(text, pos);</span>
<span class="nc bnc" id="L3558" title="All 2 branches missed.">                    if (h2 &gt;=0) {</span>
<span class="nc" id="L3559">                        h = h * 10 + h2;</span>
<span class="nc" id="L3560">                        pos++;</span>
                    }
<span class="nc bnc" id="L3562" title="All 4 branches missed.">                    if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == ':') {</span>
<span class="nc bnc" id="L3563" title="All 4 branches missed.">                        if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == ':') {</span>
<span class="nc" id="L3564">                            int m1 = getDigit(text, pos + 1);</span>
<span class="nc" id="L3565">                            int m2 = getDigit(text, pos + 2);</span>
<span class="nc bnc" id="L3566" title="All 4 branches missed.">                            if (m1 &gt;= 0 &amp;&amp; m2 &gt;= 0) {</span>
<span class="nc" id="L3567">                                m = m1 * 10 + m2;</span>
<span class="nc" id="L3568">                                pos += 3;</span>
<span class="nc bnc" id="L3569" title="All 4 branches missed.">                                if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == ':') {</span>
<span class="nc" id="L3570">                                    int s1 = getDigit(text, pos + 1);</span>
<span class="nc" id="L3571">                                    int s2 = getDigit(text, pos + 2);</span>
<span class="nc bnc" id="L3572" title="All 4 branches missed.">                                    if (s1 &gt;= 0 &amp;&amp; s2 &gt;= 0) {</span>
<span class="nc" id="L3573">                                        s = s1 * 10 + s2;</span>
<span class="nc" id="L3574">                                        pos += 3;</span>
                                   }
                                }
                            }
                        }
                    }
                }
            }
<span class="nc" id="L3582">            long offsetSecs = negative * (h * 3600L + m * 60L + s);</span>
<span class="nc" id="L3583">            return context.setParsedField(OFFSET_SECONDS, offsetSecs, position, pos);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L3588">            return &quot;LocalizedOffset(&quot; + style + &quot;)&quot;;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a zone ID.
     */
    static final class ZoneTextPrinterParser extends ZoneIdPrinterParser {

        /** The text style to output. */
        private final TextStyle textStyle;

        /** The preferred zoneid map */
        private Set&lt;String&gt; preferredZones;

        ZoneTextPrinterParser(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones) {
<span class="nc" id="L3605">            super(TemporalQueries.zone(), &quot;ZoneText(&quot; + textStyle + &quot;)&quot;);</span>
<span class="nc" id="L3606">            this.textStyle = Objects.requireNonNull(textStyle, &quot;textStyle&quot;);</span>
<span class="nc bnc" id="L3607" title="All 4 branches missed.">            if (preferredZones != null &amp;&amp; preferredZones.size() != 0) {</span>
<span class="nc" id="L3608">                this.preferredZones = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3609" title="All 2 branches missed.">                for (ZoneId id : preferredZones) {</span>
<span class="nc" id="L3610">                    this.preferredZones.add(id.getId());</span>
<span class="nc" id="L3611">                }</span>
            }
<span class="nc" id="L3613">        }</span>

        private static final int STD = 0;
        private static final int DST = 1;
        private static final int GENERIC = 2;
<span class="nc" id="L3618">        private static final Map&lt;String, SoftReference&lt;Map&lt;Locale, String[]&gt;&gt;&gt; cache =</span>
            new ConcurrentHashMap&lt;&gt;();

        private String getDisplayName(String id, int type, Locale locale) {
<span class="nc bnc" id="L3622" title="All 2 branches missed.">            if (textStyle == TextStyle.NARROW) {</span>
<span class="nc" id="L3623">                return null;</span>
            }
            String[] names;
<span class="nc" id="L3626">            SoftReference&lt;Map&lt;Locale, String[]&gt;&gt; ref = cache.get(id);</span>
<span class="nc" id="L3627">            Map&lt;Locale, String[]&gt; perLocale = null;</span>
<span class="nc bnc" id="L3628" title="All 4 branches missed.">            if (ref == null || (perLocale = ref.get()) == null ||</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">                (names = perLocale.get(locale)) == null) {</span>
<span class="nc" id="L3630">                names = TimeZoneNameUtility.retrieveDisplayNames(id, locale);</span>
<span class="nc bnc" id="L3631" title="All 2 branches missed.">                if (names == null) {</span>
<span class="nc" id="L3632">                    return null;</span>
                }
<span class="nc" id="L3634">                names = Arrays.copyOfRange(names, 0, 7);</span>
<span class="nc" id="L3635">                names[5] =</span>
<span class="nc" id="L3636">                    TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.LONG, locale);</span>
<span class="nc bnc" id="L3637" title="All 2 branches missed.">                if (names[5] == null) {</span>
<span class="nc" id="L3638">                    names[5] = names[0]; // use the id</span>
                }
<span class="nc" id="L3640">                names[6] =</span>
<span class="nc" id="L3641">                    TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.SHORT, locale);</span>
<span class="nc bnc" id="L3642" title="All 2 branches missed.">                if (names[6] == null) {</span>
<span class="nc" id="L3643">                    names[6] = names[0];</span>
                }
<span class="nc bnc" id="L3645" title="All 2 branches missed.">                if (perLocale == null) {</span>
<span class="nc" id="L3646">                    perLocale = new ConcurrentHashMap&lt;&gt;();</span>
                }
<span class="nc" id="L3648">                perLocale.put(locale, names);</span>
<span class="nc" id="L3649">                cache.put(id, new SoftReference&lt;&gt;(perLocale));</span>
            }
<span class="nc bnc" id="L3651" title="All 3 branches missed.">            switch (type) {</span>
            case STD:
<span class="nc" id="L3653">                return names[textStyle.zoneNameStyleIndex() + 1];</span>
            case DST:
<span class="nc" id="L3655">                return names[textStyle.zoneNameStyleIndex() + 3];</span>
            }
<span class="nc" id="L3657">            return names[textStyle.zoneNameStyleIndex() + 5];</span>
        }

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L3662">            ZoneId zone = context.getValue(TemporalQueries.zoneId());</span>
<span class="nc bnc" id="L3663" title="All 2 branches missed.">            if (zone == null) {</span>
<span class="nc" id="L3664">                return false;</span>
            }
<span class="nc" id="L3666">            String zname = zone.getId();</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">            if (!(zone instanceof ZoneOffset)) {</span>
<span class="nc" id="L3668">                TemporalAccessor dt = context.getTemporal();</span>
<span class="nc" id="L3669">                String name = getDisplayName(zname,</span>
<span class="nc bnc" id="L3670" title="All 2 branches missed.">                                             dt.isSupported(ChronoField.INSTANT_SECONDS)</span>
<span class="nc bnc" id="L3671" title="All 2 branches missed.">                                             ? (zone.getRules().isDaylightSavings(Instant.from(dt)) ? DST : STD)</span>
                                             : GENERIC,
<span class="nc" id="L3673">                                             context.getLocale());</span>
<span class="nc bnc" id="L3674" title="All 2 branches missed.">                if (name != null) {</span>
<span class="nc" id="L3675">                    zname = name;</span>
                }
            }
<span class="nc" id="L3678">            buf.append(zname);</span>
<span class="nc" id="L3679">            return true;</span>
        }

        // cache per instance for now
<span class="nc" id="L3683">        private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;</span>
            cachedTree = new HashMap&lt;&gt;();
<span class="nc" id="L3685">        private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;</span>
            cachedTreeCI = new HashMap&lt;&gt;();

        @Override
        protected PrefixTree getTree(DateTimeParseContext context) {
<span class="nc bnc" id="L3690" title="All 2 branches missed.">            if (textStyle == TextStyle.NARROW) {</span>
<span class="nc" id="L3691">                return super.getTree(context);</span>
            }
<span class="nc" id="L3693">            Locale locale = context.getLocale();</span>
<span class="nc" id="L3694">            boolean isCaseSensitive = context.isCaseSensitive();</span>
<span class="nc" id="L3695">            Set&lt;String&gt; regionIds = ZoneRulesProvider.getAvailableZoneIds();</span>
<span class="nc" id="L3696">            int regionIdsSize = regionIds.size();</span>

<span class="nc bnc" id="L3698" title="All 2 branches missed.">            Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt; cached =</span>
                isCaseSensitive ? cachedTree : cachedTreeCI;

<span class="nc" id="L3701">            Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt; entry = null;</span>
<span class="nc" id="L3702">            PrefixTree tree = null;</span>
<span class="nc" id="L3703">            String[][] zoneStrings = null;</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">            if ((entry = cached.get(locale)) == null ||</span>
<span class="nc bnc" id="L3705" title="All 2 branches missed.">                (entry.getKey() != regionIdsSize ||</span>
<span class="nc bnc" id="L3706" title="All 2 branches missed.">                (tree = entry.getValue().get()) == null)) {</span>
<span class="nc" id="L3707">                tree = PrefixTree.newTree(context);</span>
<span class="nc" id="L3708">                zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);</span>
<span class="nc bnc" id="L3709" title="All 2 branches missed.">                for (String[] names : zoneStrings) {</span>
<span class="nc" id="L3710">                    String zid = names[0];</span>
<span class="nc bnc" id="L3711" title="All 2 branches missed.">                    if (!regionIds.contains(zid)) {</span>
<span class="nc" id="L3712">                        continue;</span>
                    }
<span class="nc" id="L3714">                    tree.add(zid, zid);    // don't convert zid -&gt; metazone</span>
<span class="nc" id="L3715">                    zid = ZoneName.toZid(zid, locale);</span>
<span class="nc bnc" id="L3716" title="All 2 branches missed.">                    int i = textStyle == TextStyle.FULL ? 1 : 2;</span>
<span class="nc bnc" id="L3717" title="All 2 branches missed.">                    for (; i &lt; names.length; i += 2) {</span>
<span class="nc" id="L3718">                        tree.add(names[i], zid);</span>
                    }
                }
                // if we have a set of preferred zones, need a copy and
                // add the preferred zones again to overwrite
<span class="nc bnc" id="L3723" title="All 2 branches missed.">                if (preferredZones != null) {</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">                    for (String[] names : zoneStrings) {</span>
<span class="nc" id="L3725">                        String zid = names[0];</span>
<span class="nc bnc" id="L3726" title="All 4 branches missed.">                        if (!preferredZones.contains(zid) || !regionIds.contains(zid)) {</span>
<span class="nc" id="L3727">                            continue;</span>
                        }
<span class="nc bnc" id="L3729" title="All 2 branches missed.">                        int i = textStyle == TextStyle.FULL ? 1 : 2;</span>
<span class="nc bnc" id="L3730" title="All 2 branches missed.">                        for (; i &lt; names.length; i += 2) {</span>
<span class="nc" id="L3731">                            tree.add(names[i], zid);</span>
                       }
                    }
                }
<span class="nc" id="L3735">                cached.put(locale, new SimpleImmutableEntry&lt;&gt;(regionIdsSize, new SoftReference&lt;&gt;(tree)));</span>
            }
<span class="nc" id="L3737">            return tree;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a zone ID.
     */
    static class ZoneIdPrinterParser implements DateTimePrinterParser {
        private final TemporalQuery&lt;ZoneId&gt; query;
        private final String description;

<span class="nc" id="L3749">        ZoneIdPrinterParser(TemporalQuery&lt;ZoneId&gt; query, String description) {</span>
<span class="nc" id="L3750">            this.query = query;</span>
<span class="nc" id="L3751">            this.description = description;</span>
<span class="nc" id="L3752">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L3756">            ZoneId zone = context.getValue(query);</span>
<span class="nc bnc" id="L3757" title="All 2 branches missed.">            if (zone == null) {</span>
<span class="nc" id="L3758">                return false;</span>
            }
<span class="nc" id="L3760">            buf.append(zone.getId());</span>
<span class="nc" id="L3761">            return true;</span>
        }

        /**
         * The cached tree to speed up parsing.
         */
        private static volatile Entry&lt;Integer, PrefixTree&gt; cachedPrefixTree;
        private static volatile Entry&lt;Integer, PrefixTree&gt; cachedPrefixTreeCI;

        protected PrefixTree getTree(DateTimeParseContext context) {
            // prepare parse tree
<span class="nc" id="L3772">            Set&lt;String&gt; regionIds = ZoneRulesProvider.getAvailableZoneIds();</span>
<span class="nc" id="L3773">            final int regionIdsSize = regionIds.size();</span>
<span class="nc bnc" id="L3774" title="All 2 branches missed.">            Entry&lt;Integer, PrefixTree&gt; cached = context.isCaseSensitive()</span>
                                                ? cachedPrefixTree : cachedPrefixTreeCI;
<span class="nc bnc" id="L3776" title="All 4 branches missed.">            if (cached == null || cached.getKey() != regionIdsSize) {</span>
<span class="nc" id="L3777">                synchronized (this) {</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">                    cached = context.isCaseSensitive() ? cachedPrefixTree : cachedPrefixTreeCI;</span>
<span class="nc bnc" id="L3779" title="All 4 branches missed.">                    if (cached == null || cached.getKey() != regionIdsSize) {</span>
<span class="nc" id="L3780">                        cached = new SimpleImmutableEntry&lt;&gt;(regionIdsSize, PrefixTree.newTree(regionIds, context));</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">                        if (context.isCaseSensitive()) {</span>
<span class="nc" id="L3782">                            cachedPrefixTree = cached;</span>
                        } else {
<span class="nc" id="L3784">                            cachedPrefixTreeCI = cached;</span>
                        }
                    }
<span class="nc" id="L3787">                }</span>
            }
<span class="nc" id="L3789">            return cached.getValue();</span>
        }

        /**
         * This implementation looks for the longest matching string.
         * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just
         * Etc/GMC although both are valid.
         */
        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L3799">            int length = text.length();</span>
<span class="nc bnc" id="L3800" title="All 2 branches missed.">            if (position &gt; length) {</span>
<span class="nc" id="L3801">                throw new IndexOutOfBoundsException();</span>
            }
<span class="nc bnc" id="L3803" title="All 2 branches missed.">            if (position == length) {</span>
<span class="nc" id="L3804">                return ~position;</span>
            }

            // handle fixed time-zone IDs
<span class="nc" id="L3808">            char nextChar = text.charAt(position);</span>
<span class="nc bnc" id="L3809" title="All 4 branches missed.">            if (nextChar == '+' || nextChar == '-') {</span>
<span class="nc" id="L3810">                return parseOffsetBased(context, text, position, position, OffsetIdPrinterParser.INSTANCE_ID_Z);</span>
<span class="nc bnc" id="L3811" title="All 2 branches missed.">            } else if (length &gt;= position + 2) {</span>
<span class="nc" id="L3812">                char nextNextChar = text.charAt(position + 1);</span>
<span class="nc bnc" id="L3813" title="All 4 branches missed.">                if (context.charEquals(nextChar, 'U') &amp;&amp; context.charEquals(nextNextChar, 'T')) {</span>
<span class="nc bnc" id="L3814" title="All 4 branches missed.">                    if (length &gt;= position + 3 &amp;&amp; context.charEquals(text.charAt(position + 2), 'C')) {</span>
<span class="nc" id="L3815">                        return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
                    }
<span class="nc" id="L3817">                    return parseOffsetBased(context, text, position, position + 2, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
<span class="nc bnc" id="L3818" title="All 4 branches missed.">                } else if (context.charEquals(nextChar, 'G') &amp;&amp; length &gt;= position + 3 &amp;&amp;</span>
<span class="nc bnc" id="L3819" title="All 4 branches missed.">                        context.charEquals(nextNextChar, 'M') &amp;&amp; context.charEquals(text.charAt(position + 2), 'T')) {</span>
<span class="nc" id="L3820">                    return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</span>
                }
            }

            // parse
<span class="nc" id="L3825">            PrefixTree tree = getTree(context);</span>
<span class="nc" id="L3826">            ParsePosition ppos = new ParsePosition(position);</span>
<span class="nc" id="L3827">            String parsedZoneId = tree.match(text, ppos);</span>
<span class="nc bnc" id="L3828" title="All 2 branches missed.">            if (parsedZoneId == null) {</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">                if (context.charEquals(nextChar, 'Z')) {</span>
<span class="nc" id="L3830">                    context.setParsed(ZoneOffset.UTC);</span>
<span class="nc" id="L3831">                    return position + 1;</span>
                }
<span class="nc" id="L3833">                return ~position;</span>
            }
<span class="nc" id="L3835">            context.setParsed(ZoneId.of(parsedZoneId));</span>
<span class="nc" id="L3836">            return ppos.getIndex();</span>
        }

        /**
         * Parse an offset following a prefix and set the ZoneId if it is valid.
         * To matching the parsing of ZoneId.of the values are not normalized
         * to ZoneOffsets.
         *
         * @param context the parse context
         * @param text the input text
         * @param prefixPos start of the prefix
         * @param position start of text after the prefix
         * @param parser parser for the value after the prefix
         * @return the position after the parse
         */
        private int parseOffsetBased(DateTimeParseContext context, CharSequence text, int prefixPos, int position, OffsetIdPrinterParser parser) {
<span class="nc" id="L3852">            String prefix = text.toString().substring(prefixPos, position).toUpperCase();</span>
<span class="nc bnc" id="L3853" title="All 2 branches missed.">            if (position &gt;= text.length()) {</span>
<span class="nc" id="L3854">                context.setParsed(ZoneId.of(prefix));</span>
<span class="nc" id="L3855">                return position;</span>
            }

            // '0' or 'Z' after prefix is not part of a valid ZoneId; use bare prefix
<span class="nc bnc" id="L3859" title="All 2 branches missed.">            if (text.charAt(position) == '0' ||</span>
<span class="nc bnc" id="L3860" title="All 2 branches missed.">                context.charEquals(text.charAt(position), 'Z')) {</span>
<span class="nc" id="L3861">                context.setParsed(ZoneId.of(prefix));</span>
<span class="nc" id="L3862">                return position;</span>
            }

<span class="nc" id="L3865">            DateTimeParseContext newContext = context.copy();</span>
<span class="nc" id="L3866">            int endPos = parser.parse(newContext, text, position);</span>
            try {
<span class="nc bnc" id="L3868" title="All 2 branches missed.">                if (endPos &lt; 0) {</span>
<span class="nc bnc" id="L3869" title="All 2 branches missed.">                    if (parser == OffsetIdPrinterParser.INSTANCE_ID_Z) {</span>
<span class="nc" id="L3870">                        return ~prefixPos;</span>
                    }
<span class="nc" id="L3872">                    context.setParsed(ZoneId.of(prefix));</span>
<span class="nc" id="L3873">                    return position;</span>
                }
<span class="nc" id="L3875">                int offset = (int) newContext.getParsed(OFFSET_SECONDS).longValue();</span>
<span class="nc" id="L3876">                ZoneOffset zoneOffset = ZoneOffset.ofTotalSeconds(offset);</span>
<span class="nc" id="L3877">                context.setParsed(ZoneId.ofOffset(prefix, zoneOffset));</span>
<span class="nc" id="L3878">                return endPos;</span>
<span class="nc" id="L3879">            } catch (DateTimeException dte) {</span>
<span class="nc" id="L3880">                return ~prefixPos;</span>
            }
        }

        @Override
        public String toString() {
<span class="nc" id="L3886">            return description;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * A String based prefix tree for parsing time-zone names.
     */
    static class PrefixTree {
        protected String key;
        protected String value;
        protected char c0;    // performance optimization to avoid the
                              // boundary check cost of key.charat(0)
        protected PrefixTree child;
        protected PrefixTree sibling;

<span class="nc" id="L3902">        private PrefixTree(String k, String v, PrefixTree child) {</span>
<span class="nc" id="L3903">            this.key = k;</span>
<span class="nc" id="L3904">            this.value = v;</span>
<span class="nc" id="L3905">            this.child = child;</span>
<span class="nc bnc" id="L3906" title="All 2 branches missed.">            if (k.length() == 0){</span>
<span class="nc" id="L3907">                c0 = 0xffff;</span>
            } else {
<span class="nc" id="L3909">                c0 = key.charAt(0);</span>
            }
<span class="nc" id="L3911">        }</span>

        /**
         * Creates a new prefix parsing tree based on parse context.
         *
         * @param context  the parse context
         * @return the tree, not null
         */
        public static PrefixTree newTree(DateTimeParseContext context) {
            //if (!context.isStrict()) {
            //    return new LENIENT(&quot;&quot;, null, null);
            //}
<span class="nc bnc" id="L3923" title="All 2 branches missed.">            if (context.isCaseSensitive()) {</span>
<span class="nc" id="L3924">                return new PrefixTree(&quot;&quot;, null, null);</span>
            }
<span class="nc" id="L3926">            return new CI(&quot;&quot;, null, null);</span>
        }

        /**
         * Creates a new prefix parsing tree.
         *
         * @param keys  a set of strings to build the prefix parsing tree, not null
         * @param context  the parse context
         * @return the tree, not null
         */
        public static  PrefixTree newTree(Set&lt;String&gt; keys, DateTimeParseContext context) {
<span class="nc" id="L3937">            PrefixTree tree = newTree(context);</span>
<span class="nc bnc" id="L3938" title="All 2 branches missed.">            for (String k : keys) {</span>
<span class="nc" id="L3939">                tree.add0(k, k);</span>
<span class="nc" id="L3940">            }</span>
<span class="nc" id="L3941">            return tree;</span>
        }

        /**
         * Clone a copy of this tree
         */
        public PrefixTree copyTree() {
<span class="nc" id="L3948">            PrefixTree copy = new PrefixTree(key, value, null);</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">            if (child != null) {</span>
<span class="nc" id="L3950">                copy.child = child.copyTree();</span>
            }
<span class="nc bnc" id="L3952" title="All 2 branches missed.">            if (sibling != null) {</span>
<span class="nc" id="L3953">                copy.sibling = sibling.copyTree();</span>
            }
<span class="nc" id="L3955">            return copy;</span>
        }


        /**
         * Adds a pair of {key, value} into the prefix tree.
         *
         * @param k  the key, not null
         * @param v  the value, not null
         * @return  true if the pair is added successfully
         */
        public boolean add(String k, String v) {
<span class="nc" id="L3967">            return add0(k, v);</span>
        }

        private boolean add0(String k, String v) {
<span class="nc" id="L3971">            k = toKey(k);</span>
<span class="nc" id="L3972">            int prefixLen = prefixLength(k);</span>
<span class="nc bnc" id="L3973" title="All 2 branches missed.">            if (prefixLen == key.length()) {</span>
<span class="nc bnc" id="L3974" title="All 2 branches missed.">                if (prefixLen &lt; k.length()) {  // down the tree</span>
<span class="nc" id="L3975">                    String subKey = k.substring(prefixLen);</span>
<span class="nc" id="L3976">                    PrefixTree c = child;</span>
<span class="nc bnc" id="L3977" title="All 2 branches missed.">                    while (c != null) {</span>
<span class="nc bnc" id="L3978" title="All 2 branches missed.">                        if (isEqual(c.c0, subKey.charAt(0))) {</span>
<span class="nc" id="L3979">                            return c.add0(subKey, v);</span>
                        }
<span class="nc" id="L3981">                        c = c.sibling;</span>
                    }
                    // add the node as the child of the current node
<span class="nc" id="L3984">                    c = newNode(subKey, v, null);</span>
<span class="nc" id="L3985">                    c.sibling = child;</span>
<span class="nc" id="L3986">                    child = c;</span>
<span class="nc" id="L3987">                    return true;</span>
                }
                // have an existing &lt;key, value&gt; already, overwrite it
                // if (value != null) {
                //    return false;
                //}
<span class="nc" id="L3993">                value = v;</span>
<span class="nc" id="L3994">                return true;</span>
            }
            // split the existing node
<span class="nc" id="L3997">            PrefixTree n1 = newNode(key.substring(prefixLen), value, child);</span>
<span class="nc" id="L3998">            key = k.substring(0, prefixLen);</span>
<span class="nc" id="L3999">            child = n1;</span>
<span class="nc bnc" id="L4000" title="All 2 branches missed.">            if (prefixLen &lt; k.length()) {</span>
<span class="nc" id="L4001">                PrefixTree n2 = newNode(k.substring(prefixLen), v, null);</span>
<span class="nc" id="L4002">                child.sibling = n2;</span>
<span class="nc" id="L4003">                value = null;</span>
<span class="nc" id="L4004">            } else {</span>
<span class="nc" id="L4005">                value = v;</span>
            }
<span class="nc" id="L4007">            return true;</span>
        }

        /**
         * Match text with the prefix tree.
         *
         * @param text  the input text to parse, not null
         * @param off  the offset position to start parsing at
         * @param end  the end position to stop parsing
         * @return the resulting string, or null if no match found.
         */
        public String match(CharSequence text, int off, int end) {
<span class="nc bnc" id="L4019" title="All 2 branches missed.">            if (!prefixOf(text, off, end)){</span>
<span class="nc" id="L4020">                return null;</span>
            }
<span class="nc bnc" id="L4022" title="All 4 branches missed.">            if (child != null &amp;&amp; (off += key.length()) != end) {</span>
<span class="nc" id="L4023">                PrefixTree c = child;</span>
                do {
<span class="nc bnc" id="L4025" title="All 2 branches missed.">                    if (isEqual(c.c0, text.charAt(off))) {</span>
<span class="nc" id="L4026">                        String found = c.match(text, off, end);</span>
<span class="nc bnc" id="L4027" title="All 2 branches missed.">                        if (found != null) {</span>
<span class="nc" id="L4028">                            return found;</span>
                        }
<span class="nc" id="L4030">                        return value;</span>
                    }
<span class="nc" id="L4032">                    c = c.sibling;</span>
<span class="nc bnc" id="L4033" title="All 2 branches missed.">                } while (c != null);</span>
            }
<span class="nc" id="L4035">            return value;</span>
        }

        /**
         * Match text with the prefix tree.
         *
         * @param text  the input text to parse, not null
         * @param pos  the position to start parsing at, from 0 to the text
         *  length. Upon return, position will be updated to the new parse
         *  position, or unchanged, if no match found.
         * @return the resulting string, or null if no match found.
         */
        public String match(CharSequence text, ParsePosition pos) {
<span class="nc" id="L4048">            int off = pos.getIndex();</span>
<span class="nc" id="L4049">            int end = text.length();</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">            if (!prefixOf(text, off, end)){</span>
<span class="nc" id="L4051">                return null;</span>
            }
<span class="nc" id="L4053">            off += key.length();</span>
<span class="nc bnc" id="L4054" title="All 4 branches missed.">            if (child != null &amp;&amp; off != end) {</span>
<span class="nc" id="L4055">                PrefixTree c = child;</span>
                do {
<span class="nc bnc" id="L4057" title="All 2 branches missed.">                    if (isEqual(c.c0, text.charAt(off))) {</span>
<span class="nc" id="L4058">                        pos.setIndex(off);</span>
<span class="nc" id="L4059">                        String found = c.match(text, pos);</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">                        if (found != null) {</span>
<span class="nc" id="L4061">                            return found;</span>
                        }
                        break;
                    }
<span class="nc" id="L4065">                    c = c.sibling;</span>
<span class="nc bnc" id="L4066" title="All 2 branches missed.">                } while (c != null);</span>
            }
<span class="nc" id="L4068">            pos.setIndex(off);</span>
<span class="nc" id="L4069">            return value;</span>
        }

        protected String toKey(String k) {
<span class="nc" id="L4073">            return k;</span>
        }

        protected PrefixTree newNode(String k, String v, PrefixTree child) {
<span class="nc" id="L4077">            return new PrefixTree(k, v, child);</span>
        }

        protected boolean isEqual(char c1, char c2) {
<span class="nc bnc" id="L4081" title="All 2 branches missed.">            return c1 == c2;</span>
        }

        protected boolean prefixOf(CharSequence text, int off, int end) {
<span class="nc bnc" id="L4085" title="All 2 branches missed.">            if (text instanceof String) {</span>
<span class="nc" id="L4086">                return ((String)text).startsWith(key, off);</span>
            }
<span class="nc" id="L4088">            int len = key.length();</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">            if (len &gt; end - off) {</span>
<span class="nc" id="L4090">                return false;</span>
            }
<span class="nc" id="L4092">            int off0 = 0;</span>
<span class="nc bnc" id="L4093" title="All 2 branches missed.">            while (len-- &gt; 0) {</span>
<span class="nc bnc" id="L4094" title="All 2 branches missed.">                if (!isEqual(key.charAt(off0++), text.charAt(off++))) {</span>
<span class="nc" id="L4095">                    return false;</span>
                }
            }
<span class="nc" id="L4098">            return true;</span>
        }

        private int prefixLength(String k) {
<span class="nc" id="L4102">            int off = 0;</span>
<span class="nc bnc" id="L4103" title="All 4 branches missed.">            while (off &lt; k.length() &amp;&amp; off &lt; key.length()) {</span>
<span class="nc bnc" id="L4104" title="All 2 branches missed.">                if (!isEqual(k.charAt(off), key.charAt(off))) {</span>
<span class="nc" id="L4105">                    return off;</span>
                }
<span class="nc" id="L4107">                off++;</span>
            }
<span class="nc" id="L4109">            return off;</span>
        }

        /**
         * Case Insensitive prefix tree.
         */
        private static class CI extends PrefixTree {

            private CI(String k, String v, PrefixTree child) {
<span class="nc" id="L4118">                super(k, v, child);</span>
<span class="nc" id="L4119">            }</span>

            @Override
            protected CI newNode(String k, String v, PrefixTree child) {
<span class="nc" id="L4123">                return new CI(k, v, child);</span>
            }

            @Override
            protected boolean isEqual(char c1, char c2) {
<span class="nc" id="L4128">                return DateTimeParseContext.charEqualsIgnoreCase(c1, c2);</span>
            }

            @Override
            protected boolean prefixOf(CharSequence text, int off, int end) {
<span class="nc" id="L4133">                int len = key.length();</span>
<span class="nc bnc" id="L4134" title="All 2 branches missed.">                if (len &gt; end - off) {</span>
<span class="nc" id="L4135">                    return false;</span>
                }
<span class="nc" id="L4137">                int off0 = 0;</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">                while (len-- &gt; 0) {</span>
<span class="nc bnc" id="L4139" title="All 2 branches missed.">                    if (!isEqual(key.charAt(off0++), text.charAt(off++))) {</span>
<span class="nc" id="L4140">                        return false;</span>
                    }
                }
<span class="nc" id="L4143">                return true;</span>
            }
        }

        /**
         * Lenient prefix tree. Case insensitive and ignores characters
         * like space, underscore and slash.
         */
        private static class LENIENT extends CI {

            private LENIENT(String k, String v, PrefixTree child) {
<span class="nc" id="L4154">                super(k, v, child);</span>
<span class="nc" id="L4155">            }</span>

            @Override
            protected CI newNode(String k, String v, PrefixTree child) {
<span class="nc" id="L4159">                return new LENIENT(k, v, child);</span>
            }

            private boolean isLenientChar(char c) {
<span class="nc bnc" id="L4163" title="All 6 branches missed.">                return c == ' ' || c == '_' || c == '/';</span>
            }

            protected String toKey(String k) {
<span class="nc bnc" id="L4167" title="All 2 branches missed.">                for (int i = 0; i &lt; k.length(); i++) {</span>
<span class="nc bnc" id="L4168" title="All 2 branches missed.">                    if (isLenientChar(k.charAt(i))) {</span>
<span class="nc" id="L4169">                        StringBuilder sb = new StringBuilder(k.length());</span>
<span class="nc" id="L4170">                        sb.append(k, 0, i);</span>
<span class="nc" id="L4171">                        i++;</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">                        while (i &lt; k.length()) {</span>
<span class="nc bnc" id="L4173" title="All 2 branches missed.">                            if (!isLenientChar(k.charAt(i))) {</span>
<span class="nc" id="L4174">                                sb.append(k.charAt(i));</span>
                            }
<span class="nc" id="L4176">                            i++;</span>
                        }
<span class="nc" id="L4178">                        return sb.toString();</span>
                    }
                }
<span class="nc" id="L4181">                return k;</span>
            }

            @Override
            public String match(CharSequence text, ParsePosition pos) {
<span class="nc" id="L4186">                int off = pos.getIndex();</span>
<span class="nc" id="L4187">                int end = text.length();</span>
<span class="nc" id="L4188">                int len = key.length();</span>
<span class="nc" id="L4189">                int koff = 0;</span>
<span class="nc bnc" id="L4190" title="All 4 branches missed.">                while (koff &lt; len &amp;&amp; off &lt; end) {</span>
<span class="nc bnc" id="L4191" title="All 2 branches missed.">                    if (isLenientChar(text.charAt(off))) {</span>
<span class="nc" id="L4192">                        off++;</span>
<span class="nc" id="L4193">                        continue;</span>
                    }
<span class="nc bnc" id="L4195" title="All 2 branches missed.">                    if (!isEqual(key.charAt(koff++), text.charAt(off++))) {</span>
<span class="nc" id="L4196">                        return null;</span>
                    }
                }
<span class="nc bnc" id="L4199" title="All 2 branches missed.">                if (koff != len) {</span>
<span class="nc" id="L4200">                    return null;</span>
                }
<span class="nc bnc" id="L4202" title="All 4 branches missed.">                if (child != null &amp;&amp; off != end) {</span>
<span class="nc" id="L4203">                    int off0 = off;</span>
<span class="nc bnc" id="L4204" title="All 4 branches missed.">                    while (off0 &lt; end &amp;&amp; isLenientChar(text.charAt(off0))) {</span>
<span class="nc" id="L4205">                        off0++;</span>
                    }
<span class="nc bnc" id="L4207" title="All 2 branches missed.">                    if (off0 &lt; end) {</span>
<span class="nc" id="L4208">                        PrefixTree c = child;</span>
                        do {
<span class="nc bnc" id="L4210" title="All 2 branches missed.">                            if (isEqual(c.c0, text.charAt(off0))) {</span>
<span class="nc" id="L4211">                                pos.setIndex(off0);</span>
<span class="nc" id="L4212">                                String found = c.match(text, pos);</span>
<span class="nc bnc" id="L4213" title="All 2 branches missed.">                                if (found != null) {</span>
<span class="nc" id="L4214">                                    return found;</span>
                                }
                                break;
                            }
<span class="nc" id="L4218">                            c = c.sibling;</span>
<span class="nc bnc" id="L4219" title="All 2 branches missed.">                        } while (c != null);</span>
                    }
                }
<span class="nc" id="L4222">                pos.setIndex(off);</span>
<span class="nc" id="L4223">                return value;</span>
            }
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a chronology.
     */
    static final class ChronoPrinterParser implements DateTimePrinterParser {
        /** The text style to output, null means the ID. */
        private final TextStyle textStyle;

<span class="nc" id="L4236">        ChronoPrinterParser(TextStyle textStyle) {</span>
            // validated by caller
<span class="nc" id="L4238">            this.textStyle = textStyle;</span>
<span class="nc" id="L4239">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L4243">            Chronology chrono = context.getValue(TemporalQueries.chronology());</span>
<span class="nc bnc" id="L4244" title="All 2 branches missed.">            if (chrono == null) {</span>
<span class="nc" id="L4245">                return false;</span>
            }
<span class="nc bnc" id="L4247" title="All 2 branches missed.">            if (textStyle == null) {</span>
<span class="nc" id="L4248">                buf.append(chrono.getId());</span>
            } else {
<span class="nc" id="L4250">                buf.append(getChronologyName(chrono, context.getLocale()));</span>
            }
<span class="nc" id="L4252">            return true;</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
            // simple looping parser to find the chronology
<span class="nc bnc" id="L4258" title="All 4 branches missed.">            if (position &lt; 0 || position &gt; text.length()) {</span>
<span class="nc" id="L4259">                throw new IndexOutOfBoundsException();</span>
            }
<span class="nc" id="L4261">            Set&lt;Chronology&gt; chronos = Chronology.getAvailableChronologies();</span>
<span class="nc" id="L4262">            Chronology bestMatch = null;</span>
<span class="nc" id="L4263">            int matchLen = -1;</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">            for (Chronology chrono : chronos) {</span>
                String name;
<span class="nc bnc" id="L4266" title="All 2 branches missed.">                if (textStyle == null) {</span>
<span class="nc" id="L4267">                    name = chrono.getId();</span>
                } else {
<span class="nc" id="L4269">                    name = getChronologyName(chrono, context.getLocale());</span>
                }
<span class="nc" id="L4271">                int nameLen = name.length();</span>
<span class="nc bnc" id="L4272" title="All 4 branches missed.">                if (nameLen &gt; matchLen &amp;&amp; context.subSequenceEquals(text, position, name, 0, nameLen)) {</span>
<span class="nc" id="L4273">                    bestMatch = chrono;</span>
<span class="nc" id="L4274">                    matchLen = nameLen;</span>
                }
<span class="nc" id="L4276">            }</span>
<span class="nc bnc" id="L4277" title="All 2 branches missed.">            if (bestMatch == null) {</span>
<span class="nc" id="L4278">                return ~position;</span>
            }
<span class="nc" id="L4280">            context.setParsed(bestMatch);</span>
<span class="nc" id="L4281">            return position + matchLen;</span>
        }

        /**
         * Returns the chronology name of the given chrono in the given locale
         * if available, or the chronology Id otherwise. The regular ResourceBundle
         * search path is used for looking up the chronology name.
         *
         * @param chrono  the chronology, not null
         * @param locale  the locale, not null
         * @return the chronology name of chrono in locale, or the id if no name is available
         * @throws NullPointerException if chrono or locale is null
         */
        private String getChronologyName(Chronology chrono, Locale locale) {
<span class="nc" id="L4295">            String key = &quot;calendarname.&quot; + chrono.getCalendarType();</span>
<span class="nc" id="L4296">            String name = DateTimeTextProvider.getLocalizedResource(key, locale);</span>
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            return name != null ? name : chrono.getId();</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a localized pattern.
     */
    static final class LocalizedPrinterParser implements DateTimePrinterParser {
        /** Cache of formatters. */
<span class="nc" id="L4307">        private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(16, 0.75f, 2);</span>

        private final FormatStyle dateStyle;
        private final FormatStyle timeStyle;

        /**
         * Constructor.
         *
         * @param dateStyle  the date style to use, may be null
         * @param timeStyle  the time style to use, may be null
         */
<span class="nc" id="L4318">        LocalizedPrinterParser(FormatStyle dateStyle, FormatStyle timeStyle) {</span>
            // validated by caller
<span class="nc" id="L4320">            this.dateStyle = dateStyle;</span>
<span class="nc" id="L4321">            this.timeStyle = timeStyle;</span>
<span class="nc" id="L4322">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L4326">            Chronology chrono = Chronology.from(context.getTemporal());</span>
<span class="nc" id="L4327">            return formatter(context.getLocale(), chrono).toPrinterParser(false).format(context, buf);</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L4332">            Chronology chrono = context.getEffectiveChronology();</span>
<span class="nc" id="L4333">            return formatter(context.getLocale(), chrono).toPrinterParser(false).parse(context, text, position);</span>
        }

        /**
         * Gets the formatter to use.
         * &lt;p&gt;
         * The formatter will be the most appropriate to use for the date and time style in the locale.
         * For example, some locales will use the month name while others will use the number.
         *
         * @param locale  the locale to use, not null
         * @param chrono  the chronology to use, not null
         * @return the formatter, not null
         * @throws IllegalArgumentException if the formatter cannot be found
         */
        private DateTimeFormatter formatter(Locale locale, Chronology chrono) {
<span class="nc" id="L4348">            String key = chrono.getId() + '|' + locale.toString() + '|' + dateStyle + timeStyle;</span>
<span class="nc" id="L4349">            DateTimeFormatter formatter = FORMATTER_CACHE.get(key);</span>
<span class="nc bnc" id="L4350" title="All 2 branches missed.">            if (formatter == null) {</span>
<span class="nc" id="L4351">                String pattern = getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale);</span>
<span class="nc" id="L4352">                formatter = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);</span>
<span class="nc" id="L4353">                DateTimeFormatter old = FORMATTER_CACHE.putIfAbsent(key, formatter);</span>
<span class="nc bnc" id="L4354" title="All 2 branches missed.">                if (old != null) {</span>
<span class="nc" id="L4355">                    formatter = old;</span>
                }
            }
<span class="nc" id="L4358">            return formatter;</span>
        }

        @Override
        public String toString() {
<span class="nc bnc" id="L4363" title="All 4 branches missed.">            return &quot;Localized(&quot; + (dateStyle != null ? dateStyle : &quot;&quot;) + &quot;,&quot; +</span>
                (timeStyle != null ? timeStyle : &quot;&quot;) + &quot;)&quot;;
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Prints or parses a localized pattern from a localized field.
     * The specific formatter and parameters is not selected until the
     * the field is to be printed or parsed.
     * The locale is needed to select the proper WeekFields from which
     * the field for day-of-week, week-of-month, or week-of-year is selected.
     */
    static final class WeekBasedFieldPrinterParser implements DateTimePrinterParser {
        private char chr;
        private int count;

        /**
         * Constructor.
         *
         * @param chr the pattern format letter that added this PrinterParser.
         * @param count the repeat count of the format letter
         */
<span class="nc" id="L4386">        WeekBasedFieldPrinterParser(char chr, int count) {</span>
<span class="nc" id="L4387">            this.chr = chr;</span>
<span class="nc" id="L4388">            this.count = count;</span>
<span class="nc" id="L4389">        }</span>

        @Override
        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<span class="nc" id="L4393">            return printerParser(context.getLocale()).format(context, buf);</span>
        }

        @Override
        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<span class="nc" id="L4398">            return printerParser(context.getLocale()).parse(context, text, position);</span>
        }

        /**
         * Gets the printerParser to use based on the field and the locale.
         *
         * @param locale  the locale to use, not null
         * @return the formatter, not null
         * @throws IllegalArgumentException if the formatter cannot be found
         */
        private DateTimePrinterParser printerParser(Locale locale) {
<span class="nc" id="L4409">            WeekFields weekDef = WeekFields.of(locale);</span>
<span class="nc" id="L4410">            TemporalField field = null;</span>
<span class="nc bnc" id="L4411" title="All 5 branches missed.">            switch (chr) {</span>
                case 'Y':
<span class="nc" id="L4413">                    field = weekDef.weekBasedYear();</span>
<span class="nc bnc" id="L4414" title="All 2 branches missed.">                    if (count == 2) {</span>
<span class="nc" id="L4415">                        return new ReducedPrinterParser(field, 2, 2, 0, ReducedPrinterParser.BASE_DATE, 0);</span>
                    } else {
<span class="nc bnc" id="L4417" title="All 2 branches missed.">                        return new NumberPrinterParser(field, count, 19,</span>
                                (count &lt; 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD, -1);
                    }
                case 'e':
                case 'c':
<span class="nc" id="L4422">                    field = weekDef.dayOfWeek();</span>
<span class="nc" id="L4423">                    break;</span>
                case 'w':
<span class="nc" id="L4425">                    field = weekDef.weekOfWeekBasedYear();</span>
<span class="nc" id="L4426">                    break;</span>
                case 'W':
<span class="nc" id="L4428">                    field = weekDef.weekOfMonth();</span>
<span class="nc" id="L4429">                    break;</span>
                default:
<span class="nc" id="L4431">                    throw new IllegalStateException(&quot;unreachable&quot;);</span>
            }
<span class="nc bnc" id="L4433" title="All 2 branches missed.">            return new NumberPrinterParser(field, (count == 2 ? 2 : 1), 2, SignStyle.NOT_NEGATIVE);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L4438">            StringBuilder sb = new StringBuilder(30);</span>
<span class="nc" id="L4439">            sb.append(&quot;Localized(&quot;);</span>
<span class="nc bnc" id="L4440" title="All 2 branches missed.">            if (chr == 'Y') {</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">                if (count == 1) {</span>
<span class="nc" id="L4442">                    sb.append(&quot;WeekBasedYear&quot;);</span>
<span class="nc bnc" id="L4443" title="All 2 branches missed.">                } else if (count == 2) {</span>
<span class="nc" id="L4444">                    sb.append(&quot;ReducedValue(WeekBasedYear,2,2,2000-01-01)&quot;);</span>
                } else {
<span class="nc" id="L4446">                    sb.append(&quot;WeekBasedYear,&quot;).append(count).append(&quot;,&quot;)</span>
<span class="nc bnc" id="L4447" title="All 2 branches missed.">                            .append(19).append(&quot;,&quot;)</span>
<span class="nc" id="L4448">                            .append((count &lt; 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD);</span>
                }
            } else {
<span class="nc bnc" id="L4451" title="All 4 branches missed.">                switch (chr) {</span>
                    case 'c':
                    case 'e':
<span class="nc" id="L4454">                        sb.append(&quot;DayOfWeek&quot;);</span>
<span class="nc" id="L4455">                        break;</span>
                    case 'w':
<span class="nc" id="L4457">                        sb.append(&quot;WeekOfWeekBasedYear&quot;);</span>
<span class="nc" id="L4458">                        break;</span>
                    case 'W':
<span class="nc" id="L4460">                        sb.append(&quot;WeekOfMonth&quot;);</span>
<span class="nc" id="L4461">                        break;</span>
                    default:
                        break;
                }
<span class="nc" id="L4465">                sb.append(&quot;,&quot;);</span>
<span class="nc" id="L4466">                sb.append(count);</span>
            }
<span class="nc" id="L4468">            sb.append(&quot;)&quot;);</span>
<span class="nc" id="L4469">            return sb.toString();</span>
        }
    }

    //-------------------------------------------------------------------------
    /**
     * Length comparator.
     */
<span class="nc" id="L4477">    static final Comparator&lt;String&gt; LENGTH_SORT = new Comparator&lt;String&gt;() {</span>
        @Override
        public int compare(String str1, String str2) {
<span class="nc bnc" id="L4480" title="All 2 branches missed.">            return str1.length() == str2.length() ? str1.compareTo(str2) : str1.length() - str2.length();</span>
        }
    };
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>