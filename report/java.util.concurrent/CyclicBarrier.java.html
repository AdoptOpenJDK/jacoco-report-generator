<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CyclicBarrier.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">CyclicBarrier.java</span></div><h1>CyclicBarrier.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * A synchronization aid that allows a set of threads to all wait for
 * each other to reach a common barrier point.  CyclicBarriers are
 * useful in programs involving a fixed sized party of threads that
 * must occasionally wait for each other. The barrier is called
 * &lt;em&gt;cyclic&lt;/em&gt; because it can be re-used after the waiting threads
 * are released.
 *
 * &lt;p&gt;A {@code CyclicBarrier} supports an optional {@link Runnable} command
 * that is run once per barrier point, after the last thread in the party
 * arrives, but before any threads are released.
 * This &lt;em&gt;barrier action&lt;/em&gt; is useful
 * for updating shared-state before any of the parties continue.
 *
 * &lt;p&gt;&lt;b&gt;Sample usage:&lt;/b&gt; Here is an example of using a barrier in a
 * parallel decomposition design:
 *
 *  &lt;pre&gt; {@code
 * class Solver {
 *   final int N;
 *   final float[][] data;
 *   final CyclicBarrier barrier;
 *
 *   class Worker implements Runnable {
 *     int myRow;
 *     Worker(int row) { myRow = row; }
 *     public void run() {
 *       while (!done()) {
 *         processRow(myRow);
 *
 *         try {
 *           barrier.await();
 *         } catch (InterruptedException ex) {
 *           return;
 *         } catch (BrokenBarrierException ex) {
 *           return;
 *         }
 *       }
 *     }
 *   }
 *
 *   public Solver(float[][] matrix) {
 *     data = matrix;
 *     N = matrix.length;
 *     Runnable barrierAction =
 *       new Runnable() { public void run() { mergeRows(...); }};
 *     barrier = new CyclicBarrier(N, barrierAction);
 *
 *     List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(N);
 *     for (int i = 0; i &lt; N; i++) {
 *       Thread thread = new Thread(new Worker(i));
 *       threads.add(thread);
 *       thread.start();
 *     }
 *
 *     // wait until done
 *     for (Thread thread : threads)
 *       thread.join();
 *   }
 * }}&lt;/pre&gt;
 *
 * Here, each worker thread processes a row of the matrix then waits at the
 * barrier until all rows have been processed. When all rows are processed
 * the supplied {@link Runnable} barrier action is executed and merges the
 * rows. If the merger
 * determines that a solution has been found then {@code done()} will return
 * {@code true} and each worker will terminate.
 *
 * &lt;p&gt;If the barrier action does not rely on the parties being suspended when
 * it is executed, then any of the threads in the party could execute that
 * action when it is released. To facilitate this, each invocation of
 * {@link #await} returns the arrival index of that thread at the barrier.
 * You can then choose which thread should execute the barrier action, for
 * example:
 *  &lt;pre&gt; {@code
 * if (barrier.await() == 0) {
 *   // log the completion of this iteration
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;The {@code CyclicBarrier} uses an all-or-none breakage model
 * for failed synchronization attempts: If a thread leaves a barrier
 * point prematurely because of interruption, failure, or timeout, all
 * other threads waiting at that barrier point will also leave
 * abnormally via {@link BrokenBarrierException} (or
 * {@link InterruptedException} if they too were interrupted at about
 * the same time).
 *
 * &lt;p&gt;Memory consistency effects: Actions in a thread prior to calling
 * {@code await()}
 * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
 * actions that are part of the barrier action, which in turn
 * &lt;i&gt;happen-before&lt;/i&gt; actions following a successful return from the
 * corresponding {@code await()} in other threads.
 *
 * @since 1.5
 * @see CountDownLatch
 *
 * @author Doug Lea
 */
public class CyclicBarrier {
    /**
     * Each use of the barrier is represented as a generation instance.
     * The generation changes whenever the barrier is tripped, or
     * is reset. There can be many generations associated with threads
     * using the barrier - due to the non-deterministic way the lock
     * may be allocated to waiting threads - but only one of these
     * can be active at a time (the one to which {@code count} applies)
     * and all the rest are either broken or tripped.
     * There need not be an active generation if there has been a break
     * but no subsequent reset.
     */
<span class="fc" id="L151">    private static class Generation {</span>
<span class="fc" id="L152">        boolean broken = false;</span>
    }

    /** The lock for guarding barrier entry */
<span class="fc" id="L156">    private final ReentrantLock lock = new ReentrantLock();</span>
    /** Condition to wait on until tripped */
<span class="fc" id="L158">    private final Condition trip = lock.newCondition();</span>
    /** The number of parties */
    private final int parties;
    /* The command to run when tripped */
    private final Runnable barrierCommand;
    /** The current generation */
<span class="fc" id="L164">    private Generation generation = new Generation();</span>

    /**
     * Number of parties still waiting. Counts down from parties to 0
     * on each generation.  It is reset to parties on each new
     * generation or when broken.
     */
    private int count;

    /**
     * Updates state on barrier trip and wakes up everyone.
     * Called only while holding lock.
     */
    private void nextGeneration() {
        // signal completion of last generation
<span class="fc" id="L179">        trip.signalAll();</span>
        // set up next generation
<span class="fc" id="L181">        count = parties;</span>
<span class="fc" id="L182">        generation = new Generation();</span>
<span class="fc" id="L183">    }</span>

    /**
     * Sets current barrier generation as broken and wakes up everyone.
     * Called only while holding lock.
     */
    private void breakBarrier() {
<span class="nc" id="L190">        generation.broken = true;</span>
<span class="nc" id="L191">        count = parties;</span>
<span class="nc" id="L192">        trip.signalAll();</span>
<span class="nc" id="L193">    }</span>

    /**
     * Main barrier code, covering the various policies.
     */
    private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
<span class="fc" id="L201">        final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L202">        lock.lock();</span>
        try {
<span class="fc" id="L204">            final Generation g = generation;</span>

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (g.broken)</span>
<span class="nc" id="L207">                throw new BrokenBarrierException();</span>

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (Thread.interrupted()) {</span>
<span class="nc" id="L210">                breakBarrier();</span>
<span class="nc" id="L211">                throw new InterruptedException();</span>
            }

<span class="fc" id="L214">            int index = --count;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (index == 0) {  // tripped</span>
<span class="fc" id="L216">                boolean ranAction = false;</span>
                try {
<span class="fc" id="L218">                    final Runnable command = barrierCommand;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                    if (command != null)</span>
<span class="fc" id="L220">                        command.run();</span>
<span class="fc" id="L221">                    ranAction = true;</span>
<span class="fc" id="L222">                    nextGeneration();</span>
<span class="fc" id="L223">                    return 0;</span>
                } finally {
<span class="pc bpc" id="L225" title="3 of 4 branches missed.">                    if (!ranAction)</span>
<span class="nc" id="L226">                        breakBarrier();</span>
                }
            }

            // loop until tripped, broken, interrupted, or timed out
            for (;;) {
                try {
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">                    if (!timed)</span>
<span class="fc" id="L234">                        trip.await();</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                    else if (nanos &gt; 0L)</span>
<span class="nc" id="L236">                        nanos = trip.awaitNanos(nanos);</span>
<span class="nc" id="L237">                } catch (InterruptedException ie) {</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">                    if (g == generation &amp;&amp; ! g.broken) {</span>
<span class="nc" id="L239">                        breakBarrier();</span>
<span class="nc" id="L240">                        throw ie;</span>
                    } else {
                        // We're about to finish waiting even if we had not
                        // been interrupted, so this interrupt is deemed to
                        // &quot;belong&quot; to subsequent execution.
<span class="nc" id="L245">                        Thread.currentThread().interrupt();</span>
                    }
<span class="fc" id="L247">                }</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">                if (g.broken)</span>
<span class="nc" id="L250">                    throw new BrokenBarrierException();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                if (g != generation)</span>
<span class="fc" id="L253">                    return index;</span>

<span class="nc bnc" id="L255" title="All 4 branches missed.">                if (timed &amp;&amp; nanos &lt;= 0L) {</span>
<span class="nc" id="L256">                    breakBarrier();</span>
<span class="nc" id="L257">                    throw new TimeoutException();</span>
                }
            }
        } finally {
<span class="pc" id="L261">            lock.unlock();</span>
        }
    }

    /**
     * Creates a new {@code CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and which
     * will execute the given barrier action when the barrier is tripped,
     * performed by the last thread entering the barrier.
     *
     * @param parties the number of threads that must invoke {@link #await}
     *        before the barrier is tripped
     * @param barrierAction the command to execute when the barrier is
     *        tripped, or {@code null} if there is no action
     * @throws IllegalArgumentException if {@code parties} is less than 1
     */
<span class="fc" id="L277">    public CyclicBarrier(int parties, Runnable barrierAction) {</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (parties &lt;= 0) throw new IllegalArgumentException();</span>
<span class="fc" id="L279">        this.parties = parties;</span>
<span class="fc" id="L280">        this.count = parties;</span>
<span class="fc" id="L281">        this.barrierCommand = barrierAction;</span>
<span class="fc" id="L282">    }</span>

    /**
     * Creates a new {@code CyclicBarrier} that will trip when the
     * given number of parties (threads) are waiting upon it, and
     * does not perform a predefined action when the barrier is tripped.
     *
     * @param parties the number of threads that must invoke {@link #await}
     *        before the barrier is tripped
     * @throws IllegalArgumentException if {@code parties} is less than 1
     */
    public CyclicBarrier(int parties) {
<span class="fc" id="L294">        this(parties, null);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Returns the number of parties required to trip this barrier.
     *
     * @return the number of parties required to trip this barrier
     */
    public int getParties() {
<span class="nc" id="L303">        return parties;</span>
    }

    /**
     * Waits until all {@linkplain #getParties parties} have invoked
     * {@code await} on this barrier.
     *
     * &lt;p&gt;If the current thread is not the last to arrive then it is
     * disabled for thread scheduling purposes and lies dormant until
     * one of the following things happens:
     * &lt;ul&gt;
     * &lt;li&gt;The last thread arrives; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * one of the other waiting threads; or
     * &lt;li&gt;Some other thread times out while waiting for barrier; or
     * &lt;li&gt;Some other thread invokes {@link #reset} on this barrier.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If the current thread:
     * &lt;ul&gt;
     * &lt;li&gt;has its interrupted status set on entry to this method; or
     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
     * &lt;/ul&gt;
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * &lt;p&gt;If the barrier is {@link #reset} while any thread is waiting,
     * or if the barrier {@linkplain #isBroken is broken} when
     * {@code await} is invoked, or while any thread is waiting, then
     * {@link BrokenBarrierException} is thrown.
     *
     * &lt;p&gt;If any thread is {@linkplain Thread#interrupt interrupted} while waiting,
     * then all other waiting threads will throw
     * {@link BrokenBarrierException} and the barrier is placed in the broken
     * state.
     *
     * &lt;p&gt;If the current thread is the last thread to arrive, and a
     * non-null barrier action was supplied in the constructor, then the
     * current thread runs the action before allowing the other threads to
     * continue.
     * If an exception occurs during the barrier action then that exception
     * will be propagated in the current thread and the barrier is placed in
     * the broken state.
     *
     * @return the arrival index of the current thread, where index
     *         {@code getParties() - 1} indicates the first
     *         to arrive and zero indicates the last to arrive
     * @throws InterruptedException if the current thread was interrupted
     *         while waiting
     * @throws BrokenBarrierException if &lt;em&gt;another&lt;/em&gt; thread was
     *         interrupted or timed out while the current thread was
     *         waiting, or the barrier was reset, or the barrier was
     *         broken when {@code await} was called, or the barrier
     *         action (if present) failed due to an exception
     */
    public int await() throws InterruptedException, BrokenBarrierException {
        try {
<span class="fc" id="L362">            return dowait(false, 0L);</span>
<span class="nc" id="L363">        } catch (TimeoutException toe) {</span>
<span class="nc" id="L364">            throw new Error(toe); // cannot happen</span>
        }
    }

    /**
     * Waits until all {@linkplain #getParties parties} have invoked
     * {@code await} on this barrier, or the specified waiting time elapses.
     *
     * &lt;p&gt;If the current thread is not the last to arrive then it is
     * disabled for thread scheduling purposes and lies dormant until
     * one of the following things happens:
     * &lt;ul&gt;
     * &lt;li&gt;The last thread arrives; or
     * &lt;li&gt;The specified timeout elapses; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * the current thread; or
     * &lt;li&gt;Some other thread {@linkplain Thread#interrupt interrupts}
     * one of the other waiting threads; or
     * &lt;li&gt;Some other thread times out while waiting for barrier; or
     * &lt;li&gt;Some other thread invokes {@link #reset} on this barrier.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;If the current thread:
     * &lt;ul&gt;
     * &lt;li&gt;has its interrupted status set on entry to this method; or
     * &lt;li&gt;is {@linkplain Thread#interrupt interrupted} while waiting
     * &lt;/ul&gt;
     * then {@link InterruptedException} is thrown and the current thread's
     * interrupted status is cleared.
     *
     * &lt;p&gt;If the specified waiting time elapses then {@link TimeoutException}
     * is thrown. If the time is less than or equal to zero, the
     * method will not wait at all.
     *
     * &lt;p&gt;If the barrier is {@link #reset} while any thread is waiting,
     * or if the barrier {@linkplain #isBroken is broken} when
     * {@code await} is invoked, or while any thread is waiting, then
     * {@link BrokenBarrierException} is thrown.
     *
     * &lt;p&gt;If any thread is {@linkplain Thread#interrupt interrupted} while
     * waiting, then all other waiting threads will throw {@link
     * BrokenBarrierException} and the barrier is placed in the broken
     * state.
     *
     * &lt;p&gt;If the current thread is the last thread to arrive, and a
     * non-null barrier action was supplied in the constructor, then the
     * current thread runs the action before allowing the other threads to
     * continue.
     * If an exception occurs during the barrier action then that exception
     * will be propagated in the current thread and the barrier is placed in
     * the broken state.
     *
     * @param timeout the time to wait for the barrier
     * @param unit the time unit of the timeout parameter
     * @return the arrival index of the current thread, where index
     *         {@code getParties() - 1} indicates the first
     *         to arrive and zero indicates the last to arrive
     * @throws InterruptedException if the current thread was interrupted
     *         while waiting
     * @throws TimeoutException if the specified timeout elapses.
     *         In this case the barrier will be broken.
     * @throws BrokenBarrierException if &lt;em&gt;another&lt;/em&gt; thread was
     *         interrupted or timed out while the current thread was
     *         waiting, or the barrier was reset, or the barrier was broken
     *         when {@code await} was called, or the barrier action (if
     *         present) failed due to an exception
     */
    public int await(long timeout, TimeUnit unit)
        throws InterruptedException,
               BrokenBarrierException,
               TimeoutException {
<span class="nc" id="L435">        return dowait(true, unit.toNanos(timeout));</span>
    }

    /**
     * Queries if this barrier is in a broken state.
     *
     * @return {@code true} if one or more parties broke out of this
     *         barrier due to interruption or timeout since
     *         construction or the last reset, or a barrier action
     *         failed due to an exception; {@code false} otherwise.
     */
    public boolean isBroken() {
<span class="nc" id="L447">        final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L448">        lock.lock();</span>
        try {
<span class="nc" id="L450">            return generation.broken;</span>
        } finally {
<span class="nc" id="L452">            lock.unlock();</span>
        }
    }

    /**
     * Resets the barrier to its initial state.  If any parties are
     * currently waiting at the barrier, they will return with a
     * {@link BrokenBarrierException}. Note that resets &lt;em&gt;after&lt;/em&gt;
     * a breakage has occurred for other reasons can be complicated to
     * carry out; threads need to re-synchronize in some other way,
     * and choose one to perform the reset.  It may be preferable to
     * instead create a new barrier for subsequent use.
     */
    public void reset() {
<span class="nc" id="L466">        final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L467">        lock.lock();</span>
        try {
<span class="nc" id="L469">            breakBarrier();   // break the current generation</span>
<span class="nc" id="L470">            nextGeneration(); // start a new generation</span>
        } finally {
<span class="nc" id="L472">            lock.unlock();</span>
<span class="nc" id="L473">        }</span>
<span class="nc" id="L474">    }</span>

    /**
     * Returns the number of parties currently waiting at the barrier.
     * This method is primarily useful for debugging and assertions.
     *
     * @return the number of parties currently blocked in {@link #await}
     */
    public int getNumberWaiting() {
<span class="nc" id="L483">        final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L484">        lock.lock();</span>
        try {
<span class="nc" id="L486">            return parties - count;</span>
        } finally {
<span class="nc" id="L488">            lock.unlock();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>