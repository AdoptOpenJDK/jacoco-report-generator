<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CopyOnWriteArraySet.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">CopyOnWriteArraySet.java</span></div><h1>CopyOnWriteArraySet.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.util.Collection;
import java.util.Set;
import java.util.AbstractSet;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.Predicate;
import java.util.function.Consumer;

/**
 * A {@link java.util.Set} that uses an internal {@link CopyOnWriteArrayList}
 * for all of its operations.  Thus, it shares the same basic properties:
 * &lt;ul&gt;
 *  &lt;li&gt;It is best suited for applications in which set sizes generally
 *       stay small, read-only operations
 *       vastly outnumber mutative operations, and you need
 *       to prevent interference among threads during traversal.
 *  &lt;li&gt;It is thread-safe.
 *  &lt;li&gt;Mutative operations ({@code add}, {@code set}, {@code remove}, etc.)
 *      are expensive since they usually entail copying the entire underlying
 *      array.
 *  &lt;li&gt;Iterators do not support the mutative {@code remove} operation.
 *  &lt;li&gt;Traversal via iterators is fast and cannot encounter
 *      interference from other threads. Iterators rely on
 *      unchanging snapshots of the array at the time the iterators were
 *      constructed.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Sample Usage.&lt;/b&gt; The following code sketch uses a
 * copy-on-write set to maintain a set of Handler objects that
 * perform some action upon state updates.
 *
 *  &lt;pre&gt; {@code
 * class Handler { void handle(); ... }
 *
 * class X {
 *   private final CopyOnWriteArraySet&lt;Handler&gt; handlers
 *     = new CopyOnWriteArraySet&lt;Handler&gt;();
 *   public void addHandler(Handler h) { handlers.add(h); }
 *
 *   private long internalState;
 *   private synchronized void changeState() { internalState = ...; }
 *
 *   public void update() {
 *     changeState();
 *     for (Handler handler : handlers)
 *       handler.handle();
 *   }
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @see CopyOnWriteArrayList
 * @since 1.5
 * @author Doug Lea
 * @param &lt;E&gt; the type of elements held in this collection
 */
public class CopyOnWriteArraySet&lt;E&gt; extends AbstractSet&lt;E&gt;
        implements java.io.Serializable {
    private static final long serialVersionUID = 5457747651344034263L;

    private final CopyOnWriteArrayList&lt;E&gt; al;

    /**
     * Creates an empty set.
     */
<span class="fc" id="L105">    public CopyOnWriteArraySet() {</span>
<span class="fc" id="L106">        al = new CopyOnWriteArrayList&lt;E&gt;();</span>
<span class="fc" id="L107">    }</span>

    /**
     * Creates a set containing all of the elements of the specified
     * collection.
     *
     * @param c the collection of elements to initially contain
     * @throws NullPointerException if the specified collection is null
     */
<span class="nc" id="L116">    public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (c.getClass() == CopyOnWriteArraySet.class) {</span>
<span class="nc" id="L118">            @SuppressWarnings(&quot;unchecked&quot;) CopyOnWriteArraySet&lt;E&gt; cc =</span>
                (CopyOnWriteArraySet&lt;E&gt;)c;
<span class="nc" id="L120">            al = new CopyOnWriteArrayList&lt;E&gt;(cc.al);</span>
<span class="nc" id="L121">        }</span>
        else {
<span class="nc" id="L123">            al = new CopyOnWriteArrayList&lt;E&gt;();</span>
<span class="nc" id="L124">            al.addAllAbsent(c);</span>
        }
<span class="nc" id="L126">    }</span>

    /**
     * Returns the number of elements in this set.
     *
     * @return the number of elements in this set
     */
    public int size() {
<span class="fc" id="L134">        return al.size();</span>
    }

    /**
     * Returns {@code true} if this set contains no elements.
     *
     * @return {@code true} if this set contains no elements
     */
    public boolean isEmpty() {
<span class="fc" id="L143">        return al.isEmpty();</span>
    }

    /**
     * Returns {@code true} if this set contains the specified element.
     * More formally, returns {@code true} if and only if this set
     * contains an element {@code e} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.
     *
     * @param o element whose presence in this set is to be tested
     * @return {@code true} if this set contains the specified element
     */
    public boolean contains(Object o) {
<span class="fc" id="L156">        return al.contains(o);</span>
    }

    /**
     * Returns an array containing all of the elements in this set.
     * If this set makes any guarantees as to what order its elements
     * are returned by its iterator, this method must return the
     * elements in the same order.
     *
     * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it
     * are maintained by this set.  (In other words, this method must
     * allocate a new array even if this set is backed by an array).
     * The caller is thus free to modify the returned array.
     *
     * &lt;p&gt;This method acts as bridge between array-based and collection-based
     * APIs.
     *
     * @return an array containing all the elements in this set
     */
    public Object[] toArray() {
<span class="fc" id="L176">        return al.toArray();</span>
    }

    /**
     * Returns an array containing all of the elements in this set; the
     * runtime type of the returned array is that of the specified array.
     * If the set fits in the specified array, it is returned therein.
     * Otherwise, a new array is allocated with the runtime type of the
     * specified array and the size of this set.
     *
     * &lt;p&gt;If this set fits in the specified array with room to spare
     * (i.e., the array has more elements than this set), the element in
     * the array immediately following the end of the set is set to
     * {@code null}.  (This is useful in determining the length of this
     * set &lt;i&gt;only&lt;/i&gt; if the caller knows that this set does not contain
     * any null elements.)
     *
     * &lt;p&gt;If this set makes any guarantees as to what order its elements
     * are returned by its iterator, this method must return the elements
     * in the same order.
     *
     * &lt;p&gt;Like the {@link #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * &lt;p&gt;Suppose {@code x} is a set known to contain only strings.
     * The following code can be used to dump the set into a newly allocated
     * array of {@code String}:
     *
     *  &lt;pre&gt; {@code String[] y = x.toArray(new String[0]);}&lt;/pre&gt;
     *
     * Note that {@code toArray(new Object[0])} is identical in function to
     * {@code toArray()}.
     *
     * @param a the array into which the elements of this set are to be
     *        stored, if it is big enough; otherwise, a new array of the same
     *        runtime type is allocated for this purpose.
     * @return an array containing all the elements in this set
     * @throws ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in this
     *         set
     * @throws NullPointerException if the specified array is null
     */
    public &lt;T&gt; T[] toArray(T[] a) {
<span class="fc" id="L221">        return al.toArray(a);</span>
    }

    /**
     * Removes all of the elements from this set.
     * The set will be empty after this call returns.
     */
    public void clear() {
<span class="fc" id="L229">        al.clear();</span>
<span class="fc" id="L230">    }</span>

    /**
     * Removes the specified element from this set if it is present.
     * More formally, removes an element {@code e} such that
     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,
     * if this set contains such an element.  Returns {@code true} if
     * this set contained the element (or equivalently, if this set
     * changed as a result of the call).  (This set will not contain the
     * element once the call returns.)
     *
     * @param o object to be removed from this set, if present
     * @return {@code true} if this set contained the specified element
     */
    public boolean remove(Object o) {
<span class="fc" id="L245">        return al.remove(o);</span>
    }

    /**
     * Adds the specified element to this set if it is not already present.
     * More formally, adds the specified element {@code e} to this set if
     * the set contains no element {@code e2} such that
     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.
     * If this set already contains the element, the call leaves the set
     * unchanged and returns {@code false}.
     *
     * @param e element to be added to this set
     * @return {@code true} if this set did not already contain the specified
     *         element
     */
    public boolean add(E e) {
<span class="fc" id="L261">        return al.addIfAbsent(e);</span>
    }

    /**
     * Returns {@code true} if this set contains all of the elements of the
     * specified collection.  If the specified collection is also a set, this
     * method returns {@code true} if it is a &lt;i&gt;subset&lt;/i&gt; of this set.
     *
     * @param  c collection to be checked for containment in this set
     * @return {@code true} if this set contains all of the elements of the
     *         specified collection
     * @throws NullPointerException if the specified collection is null
     * @see #contains(Object)
     */
    public boolean containsAll(Collection&lt;?&gt; c) {
<span class="fc" id="L276">        return al.containsAll(c);</span>
    }

    /**
     * Adds all of the elements in the specified collection to this set if
     * they're not already present.  If the specified collection is also a
     * set, the {@code addAll} operation effectively modifies this set so
     * that its value is the &lt;i&gt;union&lt;/i&gt; of the two sets.  The behavior of
     * this operation is undefined if the specified collection is modified
     * while the operation is in progress.
     *
     * @param  c collection containing elements to be added to this set
     * @return {@code true} if this set changed as a result of the call
     * @throws NullPointerException if the specified collection is null
     * @see #add(Object)
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        return al.addAllAbsent(c) &gt; 0;</span>
    }

    /**
     * Removes from this set all of its elements that are contained in the
     * specified collection.  If the specified collection is also a set,
     * this operation effectively modifies this set so that its value is the
     * &lt;i&gt;asymmetric set difference&lt;/i&gt; of the two sets.
     *
     * @param  c collection containing elements to be removed from this set
     * @return {@code true} if this set changed as a result of the call
     * @throws ClassCastException if the class of an element of this set
     *         is incompatible with the specified collection (optional)
     * @throws NullPointerException if this set contains a null element and the
     *         specified collection does not permit null elements (optional),
     *         or if the specified collection is null
     * @see #remove(Object)
     */
    public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc" id="L312">        return al.removeAll(c);</span>
    }

    /**
     * Retains only the elements in this set that are contained in the
     * specified collection.  In other words, removes from this set all of
     * its elements that are not contained in the specified collection.  If
     * the specified collection is also a set, this operation effectively
     * modifies this set so that its value is the &lt;i&gt;intersection&lt;/i&gt; of the
     * two sets.
     *
     * @param  c collection containing elements to be retained in this set
     * @return {@code true} if this set changed as a result of the call
     * @throws ClassCastException if the class of an element of this set
     *         is incompatible with the specified collection (optional)
     * @throws NullPointerException if this set contains a null element and the
     *         specified collection does not permit null elements (optional),
     *         or if the specified collection is null
     * @see #remove(Object)
     */
    public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc" id="L333">        return al.retainAll(c);</span>
    }

    /**
     * Returns an iterator over the elements contained in this set
     * in the order in which these elements were added.
     *
     * &lt;p&gt;The returned iterator provides a snapshot of the state of the set
     * when the iterator was constructed. No synchronization is needed while
     * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the
     * {@code remove} method.
     *
     * @return an iterator over the elements in this set
     */
    public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L348">        return al.iterator();</span>
    }

    /**
     * Compares the specified object with this set for equality.
     * Returns {@code true} if the specified object is the same object
     * as this object, or if it is also a {@link Set} and the elements
     * returned by an {@linkplain Set#iterator() iterator} over the
     * specified set are the same as the elements returned by an
     * iterator over this set.  More formally, the two iterators are
     * considered to return the same elements if they return the same
     * number of elements and for every element {@code e1} returned by
     * the iterator over the specified set, there is an element
     * {@code e2} returned by the iterator over this set such that
     * {@code (e1==null ? e2==null : e1.equals(e2))}.
     *
     * @param o object to be compared for equality with this set
     * @return {@code true} if the specified object is equal to this set
     */
    public boolean equals(Object o) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (o == this)</span>
<span class="fc" id="L369">            return true;</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if (!(o instanceof Set))</span>
<span class="nc" id="L371">            return false;</span>
<span class="fc" id="L372">        Set&lt;?&gt; set = (Set&lt;?&gt;)(o);</span>
<span class="fc" id="L373">        Iterator&lt;?&gt; it = set.iterator();</span>

        // Uses O(n^2) algorithm that is only appropriate
        // for small sets, which CopyOnWriteArraySets should be.

        //  Use a single snapshot of underlying array
<span class="fc" id="L379">        Object[] elements = al.getArray();</span>
<span class="fc" id="L380">        int len = elements.length;</span>
        // Mark matched elements to avoid re-checking
<span class="fc" id="L382">        boolean[] matched = new boolean[len];</span>
<span class="fc" id="L383">        int k = 0;</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        outer: while (it.hasNext()) {</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (++k &gt; len)</span>
<span class="nc" id="L386">                return false;</span>
<span class="fc" id="L387">            Object x = it.next();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">            for (int i = 0; i &lt; len; ++i) {</span>
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">                if (!matched[i] &amp;&amp; eq(x, elements[i])) {</span>
<span class="fc" id="L390">                    matched[i] = true;</span>
<span class="fc" id="L391">                    continue outer;</span>
                }
            }
<span class="nc" id="L394">            return false;</span>
        }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        return k == len;</span>
    }

    public boolean removeIf(Predicate&lt;? super E&gt; filter) {
<span class="nc" id="L400">        return al.removeIf(filter);</span>
    }

    public void forEach(Consumer&lt;? super E&gt; action) {
<span class="nc" id="L404">        al.forEach(action);</span>
<span class="nc" id="L405">    }</span>

    /**
     * Returns a {@link Spliterator} over the elements in this set in the order
     * in which these elements were added.
     *
     * &lt;p&gt;The {@code Spliterator} reports {@link Spliterator#IMMUTABLE},
     * {@link Spliterator#DISTINCT}, {@link Spliterator#SIZED}, and
     * {@link Spliterator#SUBSIZED}.
     *
     * &lt;p&gt;The spliterator provides a snapshot of the state of the set
     * when the spliterator was constructed. No synchronization is needed while
     * operating on the spliterator.
     *
     * @return a {@code Spliterator} over the elements in this set
     * @since 1.8
     */
    public Spliterator&lt;E&gt; spliterator() {
<span class="nc" id="L423">        return Spliterators.spliterator</span>
<span class="nc" id="L424">            (al.getArray(), Spliterator.IMMUTABLE | Spliterator.DISTINCT);</span>
    }

    /**
     * Tests for equality, coping with nulls.
     */
    private static boolean eq(Object o1, Object o2) {
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        return (o1 == null) ? o2 == null : o1.equals(o2);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>