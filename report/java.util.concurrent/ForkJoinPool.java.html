<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ForkJoinPool.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">ForkJoinPool.java</span></div><h1>ForkJoinPool.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;

import java.lang.Thread.UncaughtExceptionHandler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

/**
 * An {@link ExecutorService} for running {@link ForkJoinTask}s.
 * A {@code ForkJoinPool} provides the entry point for submissions
 * from non-{@code ForkJoinTask} clients, as well as management and
 * monitoring operations.
 *
 * &lt;p&gt;A {@code ForkJoinPool} differs from other kinds of {@link
 * ExecutorService} mainly by virtue of employing
 * &lt;em&gt;work-stealing&lt;/em&gt;: all threads in the pool attempt to find and
 * execute tasks submitted to the pool and/or created by other active
 * tasks (eventually blocking waiting for work if none exist). This
 * enables efficient processing when most tasks spawn other subtasks
 * (as do most {@code ForkJoinTask}s), as well as when many small
 * tasks are submitted to the pool from external clients.  Especially
 * when setting &lt;em&gt;asyncMode&lt;/em&gt; to true in constructors, {@code
 * ForkJoinPool}s may also be appropriate for use with event-style
 * tasks that are never joined.
 *
 * &lt;p&gt;A static {@link #commonPool()} is available and appropriate for
 * most applications. The common pool is used by any ForkJoinTask that
 * is not explicitly submitted to a specified pool. Using the common
 * pool normally reduces resource usage (its threads are slowly
 * reclaimed during periods of non-use, and reinstated upon subsequent
 * use).
 *
 * &lt;p&gt;For applications that require separate or custom pools, a {@code
 * ForkJoinPool} may be constructed with a given target parallelism
 * level; by default, equal to the number of available processors. The
 * pool attempts to maintain enough active (or available) threads by
 * dynamically adding, suspending, or resuming internal worker
 * threads, even if some tasks are stalled waiting to join others.
 * However, no such adjustments are guaranteed in the face of blocked
 * I/O or other unmanaged synchronization. The nested {@link
 * ManagedBlocker} interface enables extension of the kinds of
 * synchronization accommodated.
 *
 * &lt;p&gt;In addition to execution and lifecycle control methods, this
 * class provides status check methods (for example
 * {@link #getStealCount}) that are intended to aid in developing,
 * tuning, and monitoring fork/join applications. Also, method
 * {@link #toString} returns indications of pool state in a
 * convenient form for informal monitoring.
 *
 * &lt;p&gt;As is the case with other ExecutorServices, there are three
 * main task execution methods summarized in the following table.
 * These are designed to be used primarily by clients not already
 * engaged in fork/join computations in the current pool.  The main
 * forms of these methods accept instances of {@code ForkJoinTask},
 * but overloaded forms also allow mixed execution of plain {@code
 * Runnable}- or {@code Callable}- based activities as well.  However,
 * tasks that are already executing in a pool should normally instead
 * use the within-computation forms listed in the table unless using
 * async event-style tasks that are not usually joined, in which case
 * there is little difference among choice of methods.
 *
 * &lt;table BORDER CELLPADDING=3 CELLSPACING=1&gt;
 * &lt;caption&gt;Summary of task execution methods&lt;/caption&gt;
 *  &lt;tr&gt;
 *    &lt;td&gt;&lt;/td&gt;
 *    &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from non-fork/join clients&lt;/b&gt;&lt;/td&gt;
 *    &lt;td ALIGN=CENTER&gt; &lt;b&gt;Call from within fork/join computations&lt;/b&gt;&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *    &lt;td&gt; &lt;b&gt;Arrange async execution&lt;/b&gt;&lt;/td&gt;
 *    &lt;td&gt; {@link #execute(ForkJoinTask)}&lt;/td&gt;
 *    &lt;td&gt; {@link ForkJoinTask#fork}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *    &lt;td&gt; &lt;b&gt;Await and obtain result&lt;/b&gt;&lt;/td&gt;
 *    &lt;td&gt; {@link #invoke(ForkJoinTask)}&lt;/td&gt;
 *    &lt;td&gt; {@link ForkJoinTask#invoke}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *    &lt;td&gt; &lt;b&gt;Arrange exec and obtain Future&lt;/b&gt;&lt;/td&gt;
 *    &lt;td&gt; {@link #submit(ForkJoinTask)}&lt;/td&gt;
 *    &lt;td&gt; {@link ForkJoinTask#fork} (ForkJoinTasks &lt;em&gt;are&lt;/em&gt; Futures)&lt;/td&gt;
 *  &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;The common pool is by default constructed with default
 * parameters, but these may be controlled by setting three
 * {@linkplain System#getProperty system properties}:
 * &lt;ul&gt;
 * &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.parallelism}
 * - the parallelism level, a non-negative integer
 * &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.threadFactory}
 * - the class name of a {@link ForkJoinWorkerThreadFactory}
 * &lt;li&gt;{@code java.util.concurrent.ForkJoinPool.common.exceptionHandler}
 * - the class name of a {@link UncaughtExceptionHandler}
 * &lt;/ul&gt;
 * The system class loader is used to load these classes.
 * Upon any error in establishing these settings, default parameters
 * are used. It is possible to disable or limit the use of threads in
 * the common pool by setting the parallelism property to zero, and/or
 * using a factory that may return {@code null}. However doing so may
 * cause unjoined tasks to never be executed.
 *
 * &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
 * maximum number of running threads to 32767. Attempts to create
 * pools with greater than the maximum number result in
 * {@code IllegalArgumentException}.
 *
 * &lt;p&gt;This implementation rejects submitted tasks (that is, by throwing
 * {@link RejectedExecutionException}) only when the pool is shut down
 * or internal resources have been exhausted.
 *
 * @since 1.7
 * @author Doug Lea
 */
@sun.misc.Contended
public class ForkJoinPool extends AbstractExecutorService {

    /*
     * Implementation Overview
     *
     * This class and its nested classes provide the main
     * functionality and control for a set of worker threads:
     * Submissions from non-FJ threads enter into submission queues.
     * Workers take these tasks and typically split them into subtasks
     * that may be stolen by other workers.  Preference rules give
     * first priority to processing tasks from their own queues (LIFO
     * or FIFO, depending on mode), then to randomized FIFO steals of
     * tasks in other queues.
     *
     * WorkQueues
     * ==========
     *
     * Most operations occur within work-stealing queues (in nested
     * class WorkQueue).  These are special forms of Deques that
     * support only three of the four possible end-operations -- push,
     * pop, and poll (aka steal), under the further constraints that
     * push and pop are called only from the owning thread (or, as
     * extended here, under a lock), while poll may be called from
     * other threads.  (If you are unfamiliar with them, you probably
     * want to read Herlihy and Shavit's book &quot;The Art of
     * Multiprocessor programming&quot;, chapter 16 describing these in
     * more detail before proceeding.)  The main work-stealing queue
     * design is roughly similar to those in the papers &quot;Dynamic
     * Circular Work-Stealing Deque&quot; by Chase and Lev, SPAA 2005
     * (http://research.sun.com/scalable/pubs/index.html) and
     * &quot;Idempotent work stealing&quot; by Michael, Saraswat, and Vechev,
     * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).
     * See also &quot;Correct and Efficient Work-Stealing for Weak Memory
     * Models&quot; by Le, Pop, Cohen, and Nardelli, PPoPP 2013
     * (http://www.di.ens.fr/~zappa/readings/ppopp13.pdf) for an
     * analysis of memory ordering (atomic, volatile etc) issues.  The
     * main differences ultimately stem from GC requirements that we
     * null out taken slots as soon as we can, to maintain as small a
     * footprint as possible even in programs generating huge numbers
     * of tasks. To accomplish this, we shift the CAS arbitrating pop
     * vs poll (steal) from being on the indices (&quot;base&quot; and &quot;top&quot;) to
     * the slots themselves.  So, both a successful pop and poll
     * mainly entail a CAS of a slot from non-null to null.  Because
     * we rely on CASes of references, we do not need tag bits on base
     * or top.  They are simple ints as used in any circular
     * array-based queue (see for example ArrayDeque).  Updates to the
     * indices must still be ordered in a way that guarantees that top
     * == base means the queue is empty, but otherwise may err on the
     * side of possibly making the queue appear nonempty when a push,
     * pop, or poll have not fully committed. Note that this means
     * that the poll operation, considered individually, is not
     * wait-free. One thief cannot successfully continue until another
     * in-progress one (or, if previously empty, a push) completes.
     * However, in the aggregate, we ensure at least probabilistic
     * non-blockingness.  If an attempted steal fails, a thief always
     * chooses a different random victim target to try next. So, in
     * order for one thief to progress, it suffices for any
     * in-progress poll or new push on any empty queue to
     * complete. (This is why we normally use method pollAt and its
     * variants that try once at the apparent base index, else
     * consider alternative actions, rather than method poll.)
     *
     * This approach also enables support of a user mode in which local
     * task processing is in FIFO, not LIFO order, simply by using
     * poll rather than pop.  This can be useful in message-passing
     * frameworks in which tasks are never joined.  However neither
     * mode considers affinities, loads, cache localities, etc, so
     * rarely provide the best possible performance on a given
     * machine, but portably provide good throughput by averaging over
     * these factors.  (Further, even if we did try to use such
     * information, we do not usually have a basis for exploiting it.
     * For example, some sets of tasks profit from cache affinities,
     * but others are harmed by cache pollution effects.)
     *
     * WorkQueues are also used in a similar way for tasks submitted
     * to the pool. We cannot mix these tasks in the same queues used
     * for work-stealing (this would contaminate lifo/fifo
     * processing). Instead, we randomly associate submission queues
     * with submitting threads, using a form of hashing.  The
     * ThreadLocalRandom probe value serves as a hash code for
     * choosing existing queues, and may be randomly repositioned upon
     * contention with other submitters.  In essence, submitters act
     * like workers except that they are restricted to executing local
     * tasks that they submitted (or in the case of CountedCompleters,
     * others with the same root task).  However, because most
     * shared/external queue operations are more expensive than
     * internal, and because, at steady state, external submitters
     * will compete for CPU with workers, ForkJoinTask.join and
     * related methods disable them from repeatedly helping to process
     * tasks if all workers are active.  Insertion of tasks in shared
     * mode requires a lock (mainly to protect in the case of
     * resizing) but we use only a simple spinlock (using bits in
     * field qlock), because submitters encountering a busy queue move
     * on to try or create other queues -- they block only when
     * creating and registering new queues.
     *
     * Management
     * ==========
     *
     * The main throughput advantages of work-stealing stem from
     * decentralized control -- workers mostly take tasks from
     * themselves or each other. We cannot negate this in the
     * implementation of other management responsibilities. The main
     * tactic for avoiding bottlenecks is packing nearly all
     * essentially atomic control state into two volatile variables
     * that are by far most often read (not written) as status and
     * consistency checks.
     *
     * Field &quot;ctl&quot; contains 64 bits holding all the information needed
     * to atomically decide to add, inactivate, enqueue (on an event
     * queue), dequeue, and/or re-activate workers.  To enable this
     * packing, we restrict maximum parallelism to (1&lt;&lt;15)-1 (which is
     * far in excess of normal operating range) to allow ids, counts,
     * and their negations (used for thresholding) to fit into 16bit
     * fields.
     *
     * Field &quot;plock&quot; is a form of sequence lock with a saturating
     * shutdown bit (similarly for per-queue &quot;qlocks&quot;), mainly
     * protecting updates to the workQueues array, as well as to
     * enable shutdown.  When used as a lock, it is normally only very
     * briefly held, so is nearly always available after at most a
     * brief spin, but we use a monitor-based backup strategy to
     * block when needed.
     *
     * Recording WorkQueues.  WorkQueues are recorded in the
     * &quot;workQueues&quot; array that is created upon first use and expanded
     * if necessary.  Updates to the array while recording new workers
     * and unrecording terminated ones are protected from each other
     * by a lock but the array is otherwise concurrently readable, and
     * accessed directly.  To simplify index-based operations, the
     * array size is always a power of two, and all readers must
     * tolerate null slots. Worker queues are at odd indices. Shared
     * (submission) queues are at even indices, up to a maximum of 64
     * slots, to limit growth even if array needs to expand to add
     * more workers. Grouping them together in this way simplifies and
     * speeds up task scanning.
     *
     * All worker thread creation is on-demand, triggered by task
     * submissions, replacement of terminated workers, and/or
     * compensation for blocked workers. However, all other support
     * code is set up to work with other policies.  To ensure that we
     * do not hold on to worker references that would prevent GC, ALL
     * accesses to workQueues are via indices into the workQueues
     * array (which is one source of some of the messy code
     * constructions here). In essence, the workQueues array serves as
     * a weak reference mechanism. Thus for example the wait queue
     * field of ctl stores indices, not references.  Access to the
     * workQueues in associated methods (for example signalWork) must
     * both index-check and null-check the IDs. All such accesses
     * ignore bad IDs by returning out early from what they are doing,
     * since this can only be associated with termination, in which
     * case it is OK to give up.  All uses of the workQueues array
     * also check that it is non-null (even if previously
     * non-null). This allows nulling during termination, which is
     * currently not necessary, but remains an option for
     * resource-revocation-based shutdown schemes. It also helps
     * reduce JIT issuance of uncommon-trap code, which tends to
     * unnecessarily complicate control flow in some methods.
     *
     * Event Queuing. Unlike HPC work-stealing frameworks, we cannot
     * let workers spin indefinitely scanning for tasks when none can
     * be found immediately, and we cannot start/resume workers unless
     * there appear to be tasks available.  On the other hand, we must
     * quickly prod them into action when new tasks are submitted or
     * generated. In many usages, ramp-up time to activate workers is
     * the main limiting factor in overall performance (this is
     * compounded at program start-up by JIT compilation and
     * allocation). So we try to streamline this as much as possible.
     * We park/unpark workers after placing in an event wait queue
     * when they cannot find work. This &quot;queue&quot; is actually a simple
     * Treiber stack, headed by the &quot;id&quot; field of ctl, plus a 15bit
     * counter value (that reflects the number of times a worker has
     * been inactivated) to avoid ABA effects (we need only as many
     * version numbers as worker threads). Successors are held in
     * field WorkQueue.nextWait.  Queuing deals with several intrinsic
     * races, mainly that a task-producing thread can miss seeing (and
     * signalling) another thread that gave up looking for work but
     * has not yet entered the wait queue. We solve this by requiring
     * a full sweep of all workers (via repeated calls to method
     * scan()) both before and after a newly waiting worker is added
     * to the wait queue.  Because enqueued workers may actually be
     * rescanning rather than waiting, we set and clear the &quot;parker&quot;
     * field of WorkQueues to reduce unnecessary calls to unpark.
     * (This requires a secondary recheck to avoid missed signals.)
     * Note the unusual conventions about Thread.interrupts
     * surrounding parking and other blocking: Because interrupts are
     * used solely to alert threads to check termination, which is
     * checked anyway upon blocking, we clear status (using
     * Thread.interrupted) before any call to park, so that park does
     * not immediately return due to status being set via some other
     * unrelated call to interrupt in user code.
     *
     * Signalling.  We create or wake up workers only when there
     * appears to be at least one task they might be able to find and
     * execute.  When a submission is added or another worker adds a
     * task to a queue that has fewer than two tasks, they signal
     * waiting workers (or trigger creation of new ones if fewer than
     * the given parallelism level -- signalWork).  These primary
     * signals are buttressed by others whenever other threads remove
     * a task from a queue and notice that there are other tasks there
     * as well.  So in general, pools will be over-signalled. On most
     * platforms, signalling (unpark) overhead time is noticeably
     * long, and the time between signalling a thread and it actually
     * making progress can be very noticeably long, so it is worth
     * offloading these delays from critical paths as much as
     * possible. Additionally, workers spin-down gradually, by staying
     * alive so long as they see the ctl state changing.  Similar
     * stability-sensing techniques are also used before blocking in
     * awaitJoin and helpComplete.
     *
     * Trimming workers. To release resources after periods of lack of
     * use, a worker starting to wait when the pool is quiescent will
     * time out and terminate if the pool has remained quiescent for a
     * given period -- a short period if there are more threads than
     * parallelism, longer as the number of threads decreases. This
     * will slowly propagate, eventually terminating all workers after
     * periods of non-use.
     *
     * Shutdown and Termination. A call to shutdownNow atomically sets
     * a plock bit and then (non-atomically) sets each worker's
     * qlock status, cancels all unprocessed tasks, and wakes up
     * all waiting workers.  Detecting whether termination should
     * commence after a non-abrupt shutdown() call requires more work
     * and bookkeeping. We need consensus about quiescence (i.e., that
     * there is no more work). The active count provides a primary
     * indication but non-abrupt shutdown still requires a rechecking
     * scan for any workers that are inactive but not queued.
     *
     * Joining Tasks
     * =============
     *
     * Any of several actions may be taken when one worker is waiting
     * to join a task stolen (or always held) by another.  Because we
     * are multiplexing many tasks on to a pool of workers, we can't
     * just let them block (as in Thread.join).  We also cannot just
     * reassign the joiner's run-time stack with another and replace
     * it later, which would be a form of &quot;continuation&quot;, that even if
     * possible is not necessarily a good idea since we sometimes need
     * both an unblocked task and its continuation to progress.
     * Instead we combine two tactics:
     *
     *   Helping: Arranging for the joiner to execute some task that it
     *      would be running if the steal had not occurred.
     *
     *   Compensating: Unless there are already enough live threads,
     *      method tryCompensate() may create or re-activate a spare
     *      thread to compensate for blocked joiners until they unblock.
     *
     * A third form (implemented in tryRemoveAndExec) amounts to
     * helping a hypothetical compensator: If we can readily tell that
     * a possible action of a compensator is to steal and execute the
     * task being joined, the joining thread can do so directly,
     * without the need for a compensation thread (although at the
     * expense of larger run-time stacks, but the tradeoff is
     * typically worthwhile).
     *
     * The ManagedBlocker extension API can't use helping so relies
     * only on compensation in method awaitBlocker.
     *
     * The algorithm in tryHelpStealer entails a form of &quot;linear&quot;
     * helping: Each worker records (in field currentSteal) the most
     * recent task it stole from some other worker. Plus, it records
     * (in field currentJoin) the task it is currently actively
     * joining. Method tryHelpStealer uses these markers to try to
     * find a worker to help (i.e., steal back a task from and execute
     * it) that could hasten completion of the actively joined task.
     * In essence, the joiner executes a task that would be on its own
     * local deque had the to-be-joined task not been stolen. This may
     * be seen as a conservative variant of the approach in Wagner &amp;
     * Calder &quot;Leapfrogging: a portable technique for implementing
     * efficient futures&quot; SIGPLAN Notices, 1993
     * (http://portal.acm.org/citation.cfm?id=155354). It differs in
     * that: (1) We only maintain dependency links across workers upon
     * steals, rather than use per-task bookkeeping.  This sometimes
     * requires a linear scan of workQueues array to locate stealers,
     * but often doesn't because stealers leave hints (that may become
     * stale/wrong) of where to locate them.  It is only a hint
     * because a worker might have had multiple steals and the hint
     * records only one of them (usually the most current).  Hinting
     * isolates cost to when it is needed, rather than adding to
     * per-task overhead.  (2) It is &quot;shallow&quot;, ignoring nesting and
     * potentially cyclic mutual steals.  (3) It is intentionally
     * racy: field currentJoin is updated only while actively joining,
     * which means that we miss links in the chain during long-lived
     * tasks, GC stalls etc (which is OK since blocking in such cases
     * is usually a good idea).  (4) We bound the number of attempts
     * to find work (see MAX_HELP) and fall back to suspending the
     * worker and if necessary replacing it with another.
     *
     * Helping actions for CountedCompleters are much simpler: Method
     * helpComplete can take and execute any task with the same root
     * as the task being waited on. However, this still entails some
     * traversal of completer chains, so is less efficient than using
     * CountedCompleters without explicit joins.
     *
     * It is impossible to keep exactly the target parallelism number
     * of threads running at any given time.  Determining the
     * existence of conservatively safe helping targets, the
     * availability of already-created spares, and the apparent need
     * to create new spares are all racy, so we rely on multiple
     * retries of each.  Compensation in the apparent absence of
     * helping opportunities is challenging to control on JVMs, where
     * GC and other activities can stall progress of tasks that in
     * turn stall out many other dependent tasks, without us being
     * able to determine whether they will ever require compensation.
     * Even though work-stealing otherwise encounters little
     * degradation in the presence of more threads than cores,
     * aggressively adding new threads in such cases entails risk of
     * unwanted positive feedback control loops in which more threads
     * cause more dependent stalls (as well as delayed progress of
     * unblocked threads to the point that we know they are available)
     * leading to more situations requiring more threads, and so
     * on. This aspect of control can be seen as an (analytically
     * intractable) game with an opponent that may choose the worst
     * (for us) active thread to stall at any time.  We take several
     * precautions to bound losses (and thus bound gains), mainly in
     * methods tryCompensate and awaitJoin.
     *
     * Common Pool
     * ===========
     *
     * The static common pool always exists after static
     * initialization.  Since it (or any other created pool) need
     * never be used, we minimize initial construction overhead and
     * footprint to the setup of about a dozen fields, with no nested
     * allocation. Most bootstrapping occurs within method
     * fullExternalPush during the first submission to the pool.
     *
     * When external threads submit to the common pool, they can
     * perform subtask processing (see externalHelpJoin and related
     * methods).  This caller-helps policy makes it sensible to set
     * common pool parallelism level to one (or more) less than the
     * total number of available cores, or even zero for pure
     * caller-runs.  We do not need to record whether external
     * submissions are to the common pool -- if not, externalHelpJoin
     * returns quickly (at the most helping to signal some common pool
     * workers). These submitters would otherwise be blocked waiting
     * for completion, so the extra effort (with liberally sprinkled
     * task status checks) in inapplicable cases amounts to an odd
     * form of limited spin-wait before blocking in ForkJoinTask.join.
     *
     * Style notes
     * ===========
     *
     * There is a lot of representation-level coupling among classes
     * ForkJoinPool, ForkJoinWorkerThread, and ForkJoinTask.  The
     * fields of WorkQueue maintain data structures managed by
     * ForkJoinPool, so are directly accessed.  There is little point
     * trying to reduce this, since any associated future changes in
     * representations will need to be accompanied by algorithmic
     * changes anyway. Several methods intrinsically sprawl because
     * they must accumulate sets of consistent reads of volatiles held
     * in local variables.  Methods signalWork() and scan() are the
     * main bottlenecks, so are especially heavily
     * micro-optimized/mangled.  There are lots of inline assignments
     * (of form &quot;while ((local = field) != 0)&quot;) which are usually the
     * simplest way to ensure the required read orderings (which are
     * sometimes critical). This leads to a &quot;C&quot;-like style of listing
     * declarations of these locals at the heads of methods or blocks.
     * There are several occurrences of the unusual &quot;do {} while
     * (!cas...)&quot;  which is the simplest way to force an update of a
     * CAS'ed variable. There are also other coding oddities (including
     * several unnecessary-looking hoisted null checks) that help
     * some methods perform reasonably even when interpreted (not
     * compiled).
     *
     * The order of declarations in this file is:
     * (1) Static utility functions
     * (2) Nested (static) classes
     * (3) Static fields
     * (4) Fields, along with constants used when unpacking some of them
     * (5) Internal control methods
     * (6) Callbacks and other support for ForkJoinTask methods
     * (7) Exported methods
     * (8) Static block initializing statics in minimally dependent order
     */

    // Static utilities

    /**
     * If there is a security manager, makes sure caller has
     * permission to modify threads.
     */
    private static void checkPermission() {
<span class="fc" id="L547">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">        if (security != null)</span>
<span class="fc" id="L549">            security.checkPermission(modifyThreadPermission);</span>
<span class="fc" id="L550">    }</span>

    // Nested classes

    /**
     * Factory for creating new {@link ForkJoinWorkerThread}s.
     * A {@code ForkJoinWorkerThreadFactory} must be defined and used
     * for {@code ForkJoinWorkerThread} subclasses that extend base
     * functionality or initialize threads with different contexts.
     */
    public static interface ForkJoinWorkerThreadFactory {
        /**
         * Returns a new worker thread operating in the given pool.
         *
         * @param pool the pool this thread works in
         * @return the new worker thread
         * @throws NullPointerException if the pool is null
         */
        public ForkJoinWorkerThread newThread(ForkJoinPool pool);
    }

    /**
     * Default ForkJoinWorkerThreadFactory implementation; creates a
     * new ForkJoinWorkerThread.
     */
<span class="fc" id="L575">    static final class DefaultForkJoinWorkerThreadFactory</span>
        implements ForkJoinWorkerThreadFactory {
        public final ForkJoinWorkerThread newThread(ForkJoinPool pool) {
<span class="fc" id="L578">            return new ForkJoinWorkerThread(pool);</span>
        }
    }

    /**
     * Class for artificial tasks that are used to replace the target
     * of local joins if they are removed from an interior queue slot
     * in WorkQueue.tryRemoveAndExec. We don't need the proxy to
     * actually do anything beyond having a unique identity.
     */
    static final class EmptyTask extends ForkJoinTask&lt;Void&gt; {
        private static final long serialVersionUID = -7721805057305804111L;
<span class="nc" id="L590">        EmptyTask() { status = ForkJoinTask.NORMAL; } // force done</span>
<span class="nc" id="L591">        public final Void getRawResult() { return null; }</span>
<span class="nc" id="L592">        public final void setRawResult(Void x) {}</span>
<span class="nc" id="L593">        public final boolean exec() { return true; }</span>
    }

    /**
     * Queues supporting work-stealing as well as external task
     * submission. See above for main rationale and algorithms.
     * Implementation relies heavily on &quot;Unsafe&quot; intrinsics
     * and selective use of &quot;volatile&quot;:
     *
     * Field &quot;base&quot; is the index (mod array.length) of the least valid
     * queue slot, which is always the next position to steal (poll)
     * from if nonempty. Reads and writes require volatile orderings
     * but not CAS, because updates are only performed after slot
     * CASes.
     *
     * Field &quot;top&quot; is the index (mod array.length) of the next queue
     * slot to push to or pop from. It is written only by owner thread
     * for push, or under lock for external/shared push, and accessed
     * by other threads only after reading (volatile) base.  Both top
     * and base are allowed to wrap around on overflow, but (top -
     * base) (or more commonly -(base - top) to force volatile read of
     * base before top) still estimates size. The lock (&quot;qlock&quot;) is
     * forced to -1 on termination, causing all further lock attempts
     * to fail. (Note: we don't need CAS for termination state because
     * upon pool shutdown, all shared-queues will stop being used
     * anyway.)  Nearly all lock bodies are set up so that exceptions
     * within lock bodies are &quot;impossible&quot; (modulo JVM errors that
     * would cause failure anyway.)
     *
     * The array slots are read and written using the emulation of
     * volatiles/atomics provided by Unsafe. Insertions must in
     * general use putOrderedObject as a form of releasing store to
     * ensure that all writes to the task object are ordered before
     * its publication in the queue.  All removals entail a CAS to
     * null.  The array is always a power of two. To ensure safety of
     * Unsafe array operations, all accesses perform explicit null
     * checks and implicit bounds checks via power-of-two masking.
     *
     * In addition to basic queuing support, this class contains
     * fields described elsewhere to control execution. It turns out
     * to work better memory-layout-wise to include them in this class
     * rather than a separate class.
     *
     * Performance on most platforms is very sensitive to placement of
     * instances of both WorkQueues and their arrays -- we absolutely
     * do not want multiple WorkQueue instances or multiple queue
     * arrays sharing cache lines. (It would be best for queue objects
     * and their arrays to share, but there is nothing available to
     * help arrange that). The @Contended annotation alerts JVMs to
     * try to keep instances apart.
     */
    @sun.misc.Contended
    static final class WorkQueue {
        /**
         * Capacity of work-stealing queue array upon initialization.
         * Must be a power of two; at least 4, but should be larger to
         * reduce or eliminate cacheline sharing among queues.
         * Currently, it is much larger, as a partial workaround for
         * the fact that JVMs often place arrays in locations that
         * share GC bookkeeping (especially cardmarks) such that
         * per-write accesses encounter serious memory contention.
         */
        static final int INITIAL_QUEUE_CAPACITY = 1 &lt;&lt; 13;

        /**
         * Maximum size for queue arrays. Must be a power of two less
         * than or equal to 1 &lt;&lt; (31 - width of array entry) to ensure
         * lack of wraparound of index calculations, but defined to a
         * value a bit less than this to help users trap runaway
         * programs before saturating systems.
         */
        static final int MAXIMUM_QUEUE_CAPACITY = 1 &lt;&lt; 26; // 64M

        volatile int eventCount;   // encoded inactivation count; &lt; 0 if inactive
        int nextWait;              // encoded record of next event waiter
        int nsteals;               // number of steals
        int hint;                  // steal index hint
        short poolIndex;           // index of this queue in pool
        final short mode;          // 0: lifo, &gt; 0: fifo, &lt; 0: shared
        volatile int qlock;        // 1: locked, -1: terminate; else 0
        volatile int base;         // index of next slot for poll
        int top;                   // index of next slot for push
        ForkJoinTask&lt;?&gt;[] array;   // the elements (initially unallocated)
        final ForkJoinPool pool;   // the containing pool (may be null)
        final ForkJoinWorkerThread owner; // owning thread or null if shared
        volatile Thread parker;    // == owner during call to park; else null
        volatile ForkJoinTask&lt;?&gt; currentJoin;  // task being joined in awaitJoin
        ForkJoinTask&lt;?&gt; currentSteal; // current non-local task being executed

        WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner, int mode,
<span class="fc" id="L683">                  int seed) {</span>
<span class="fc" id="L684">            this.pool = pool;</span>
<span class="fc" id="L685">            this.owner = owner;</span>
<span class="fc" id="L686">            this.mode = (short)mode;</span>
<span class="fc" id="L687">            this.hint = seed; // store initial seed for runWorker</span>
            // Place indices in the center of array (that is not yet allocated)
<span class="fc" id="L689">            base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; 1;</span>
<span class="fc" id="L690">        }</span>

        /**
         * Returns the approximate number of tasks in the queue.
         */
        final int queueSize() {
<span class="fc" id="L696">            int n = base - top;       // non-owner callers must read base first</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            return (n &gt;= 0) ? 0 : -n; // ignore transient negative</span>
        }

        /**
         * Provides a more accurate estimate of whether this queue has
         * any tasks than does queueSize, by checking whether a
         * near-empty queue has at least one unclaimed task.
         */
        final boolean isEmpty() {
            ForkJoinTask&lt;?&gt;[] a; int m, s;
<span class="fc" id="L707">            int n = base - (s = top);</span>
<span class="pc bpc" id="L708" title="7 of 8 branches missed.">            return (n &gt;= 0 ||</span>
                    (n == -1 &amp;&amp;
                     ((a = array) == null ||
                      (m = a.length - 1) &lt; 0 ||
                      U.getObject
<span class="pc bnc" id="L713" title="All 2 branches missed.">                      (a, (long)((m &amp; (s - 1)) &lt;&lt; ASHIFT) + ABASE) == null)));</span>
        }

        /**
         * Pushes a task. Call only by owner in unshared queues.  (The
         * shared-queue version is embedded in method externalPush.)
         *
         * @param task the task. Caller must ensure non-null.
         * @throws RejectedExecutionException if array cannot be resized
         */
        final void push(ForkJoinTask&lt;?&gt; task) {
            ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;
<span class="fc" id="L725">            int s = top, n;</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">            if ((a = array) != null) {    // ignore if queue removed</span>
<span class="fc" id="L727">                int m = a.length - 1;</span>
<span class="fc" id="L728">                U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                if ((n = (top = s + 1) - base) &lt;= 2)</span>
<span class="fc" id="L730">                    (p = pool).signalWork(p.workQueues, this);</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">                else if (n &gt;= m)</span>
<span class="nc" id="L732">                    growArray();</span>
            }
<span class="fc" id="L734">        }</span>

        /**
         * Initializes or doubles the capacity of array. Call either
         * by owner or with lock held -- it is OK for base, but not
         * top, to move while resizings are in progress.
         */
        final ForkJoinTask&lt;?&gt;[] growArray() {
<span class="fc" id="L742">            ForkJoinTask&lt;?&gt;[] oldA = array;</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            int size = oldA != null ? oldA.length &lt;&lt; 1 : INITIAL_QUEUE_CAPACITY;</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">            if (size &gt; MAXIMUM_QUEUE_CAPACITY)</span>
<span class="nc" id="L745">                throw new RejectedExecutionException(&quot;Queue capacity exceeded&quot;);</span>
            int oldMask, t, b;
<span class="fc" id="L747">            ForkJoinTask&lt;?&gt;[] a = array = new ForkJoinTask&lt;?&gt;[size];</span>
<span class="pc bpc" id="L748" title="5 of 6 branches missed.">            if (oldA != null &amp;&amp; (oldMask = oldA.length - 1) &gt;= 0 &amp;&amp;</span>
                (t = top) - (b = base) &gt; 0) {
<span class="nc" id="L750">                int mask = size - 1;</span>
                do {
                    ForkJoinTask&lt;?&gt; x;
<span class="nc" id="L753">                    int oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc" id="L754">                    int j    = ((b &amp;    mask) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc" id="L755">                    x = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(oldA, oldj);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">                    if (x != null &amp;&amp;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">                        U.compareAndSwapObject(oldA, oldj, x, null))</span>
<span class="nc" id="L758">                        U.putObjectVolatile(a, j, x);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                } while (++b != t);</span>
            }
<span class="fc" id="L761">            return a;</span>
        }

        /**
         * Takes next task, if one exists, in LIFO order.  Call only
         * by owner in unshared queues.
         */
        final ForkJoinTask&lt;?&gt; pop() {
            ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; int m;
<span class="pc bpc" id="L770" title="2 of 4 branches missed.">            if ((a = array) != null &amp;&amp; (m = a.length - 1) &gt;= 0) {</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">                for (int s; (s = top - 1) - base &gt;= 0;) {</span>
<span class="nc" id="L772">                    long j = ((m &amp; s) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                    if ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == null)</span>
<span class="nc" id="L774">                        break;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                    if (U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="nc" id="L776">                        top = s;</span>
<span class="nc" id="L777">                        return t;</span>
                    }
<span class="nc" id="L779">                }</span>
            }
<span class="fc" id="L781">            return null;</span>
        }

        /**
         * Takes a task in FIFO order if b is base of queue and a task
         * can be claimed without contention. Specialized versions
         * appear in ForkJoinPool methods scan and tryHelpStealer.
         */
        final ForkJoinTask&lt;?&gt; pollAt(int b) {
            ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] a;
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if ((a = array) != null) {</span>
<span class="nc" id="L792">                int j = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc bnc" id="L793" title="All 4 branches missed.">                if ((t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j)) != null &amp;&amp;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                    base == b &amp;&amp; U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="nc" id="L795">                    U.putOrderedInt(this, QBASE, b + 1);</span>
<span class="nc" id="L796">                    return t;</span>
                }
            }
<span class="nc" id="L799">            return null;</span>
        }

        /**
         * Takes next task, if one exists, in FIFO order.
         */
        final ForkJoinTask&lt;?&gt; poll() {
            ForkJoinTask&lt;?&gt;[] a; int b; ForkJoinTask&lt;?&gt; t;
<span class="pc bpc" id="L807" title="3 of 4 branches missed.">            while ((b = base) - top &lt; 0 &amp;&amp; (a = array) != null) {</span>
<span class="nc" id="L808">                int j = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc" id="L809">                t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                if (t != null) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                    if (U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="nc" id="L812">                        U.putOrderedInt(this, QBASE, b + 1);</span>
<span class="nc" id="L813">                        return t;</span>
                    }
                }
<span class="nc bnc" id="L816" title="All 2 branches missed.">                else if (base == b) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                    if (b + 1 == top)</span>
<span class="nc" id="L818">                        break;</span>
<span class="nc" id="L819">                    Thread.yield(); // wait for lagging update (very rare)</span>
                }
<span class="nc" id="L821">            }</span>
<span class="fc" id="L822">            return null;</span>
        }

        /**
         * Takes next task, if one exists, in order specified by mode.
         */
        final ForkJoinTask&lt;?&gt; nextLocalTask() {
<span class="nc bnc" id="L829" title="All 2 branches missed.">            return mode == 0 ? pop() : poll();</span>
        }

        /**
         * Returns next task, if one exists, in order specified by mode.
         */
        final ForkJoinTask&lt;?&gt; peek() {
<span class="nc" id="L836">            ForkJoinTask&lt;?&gt;[] a = array; int m;</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">            if (a == null || (m = a.length - 1) &lt; 0)</span>
<span class="nc" id="L838">                return null;</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">            int i = mode == 0 ? top - 1 : base;</span>
<span class="nc" id="L840">            int j = ((i &amp; m) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc" id="L841">            return (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);</span>
        }

        /**
         * Pops the given task only if it is at the current top.
         * (A shared version is available only via FJP.tryExternalUnpush)
         */
        final boolean tryUnpush(ForkJoinTask&lt;?&gt; t) {
            ForkJoinTask&lt;?&gt;[] a; int s;
<span class="pc bpc" id="L850" title="1 of 4 branches missed.">            if ((a = array) != null &amp;&amp; (s = top) != base &amp;&amp;</span>
                U.compareAndSwapObject
<span class="fc bfc" id="L852" title="All 2 branches covered.">                (a, (((a.length - 1) &amp; --s) &lt;&lt; ASHIFT) + ABASE, t, null)) {</span>
<span class="fc" id="L853">                top = s;</span>
<span class="fc" id="L854">                return true;</span>
            }
<span class="fc" id="L856">            return false;</span>
        }

        /**
         * Removes and cancels all known tasks, ignoring any exceptions.
         */
        final void cancelAll() {
<span class="fc" id="L863">            ForkJoinTask.cancelIgnoringExceptions(currentJoin);</span>
<span class="fc" id="L864">            ForkJoinTask.cancelIgnoringExceptions(currentSteal);</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">            for (ForkJoinTask&lt;?&gt; t; (t = poll()) != null; )</span>
<span class="nc" id="L866">                ForkJoinTask.cancelIgnoringExceptions(t);</span>
<span class="fc" id="L867">        }</span>

        // Specialized execution methods

        /**
         * Polls and runs tasks until empty.
         */
        final void pollAndExecAll() {
<span class="nc bnc" id="L875" title="All 2 branches missed.">            for (ForkJoinTask&lt;?&gt; t; (t = poll()) != null;)</span>
<span class="nc" id="L876">                t.doExec();</span>
<span class="nc" id="L877">        }</span>

        /**
         * Executes a top-level task and any local tasks remaining
         * after execution.
         */
        final void runTask(ForkJoinTask&lt;?&gt; task) {
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if ((currentSteal = task) != null) {</span>
<span class="fc" id="L885">                task.doExec();</span>
<span class="fc" id="L886">                ForkJoinTask&lt;?&gt;[] a = array;</span>
<span class="fc" id="L887">                int md = mode;</span>
<span class="fc" id="L888">                ++nsteals;</span>
<span class="fc" id="L889">                currentSteal = null;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">                if (md != 0)</span>
<span class="nc" id="L891">                    pollAndExecAll();</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">                else if (a != null) {</span>
<span class="fc" id="L893">                    int s, m = a.length - 1;</span>
                    ForkJoinTask&lt;?&gt; t;
<span class="fc bfc" id="L895" title="All 2 branches covered.">                    while ((s = top - 1) - base &gt;= 0 &amp;&amp;</span>
                           (t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject
<span class="fc bfc" id="L897" title="All 2 branches covered.">                            (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, null)) != null) {</span>
<span class="fc" id="L898">                        top = s;</span>
<span class="fc" id="L899">                        t.doExec();</span>
                    }
                }
            }
<span class="fc" id="L903">        }</span>

        /**
         * If present, removes from queue and executes the given task,
         * or any other cancelled task. Returns (true) on any CAS
         * or consistency check failure so caller can retry.
         *
         * @return false if no progress can be made, else true
         */
        final boolean tryRemoveAndExec(ForkJoinTask&lt;?&gt; task) {
            boolean stat;
            ForkJoinTask&lt;?&gt;[] a; int m, s, b, n;
<span class="pc bpc" id="L915" title="3 of 8 branches missed.">            if (task != null &amp;&amp; (a = array) != null &amp;&amp; (m = a.length - 1) &gt;= 0 &amp;&amp;</span>
                (n = (s = top) - (b = base)) &gt; 0) {
<span class="fc" id="L917">                boolean removed = false, empty = true;</span>
<span class="fc" id="L918">                stat = true;</span>
                for (ForkJoinTask&lt;?&gt; t;;) {           // traverse from s to b
<span class="fc" id="L920">                    long j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc" id="L921">                    t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j);</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">                    if (t == null)                    // inconsistent length</span>
<span class="fc" id="L923">                        break;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                    else if (t == task) {</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                        if (s + 1 == top) {           // pop</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                            if (!U.compareAndSwapObject(a, j, task, null))</span>
<span class="nc" id="L927">                                break;</span>
<span class="nc" id="L928">                            top = s;</span>
<span class="nc" id="L929">                            removed = true;</span>
                        }
<span class="nc bnc" id="L931" title="All 2 branches missed.">                        else if (base == b)           // replace with proxy</span>
<span class="nc" id="L932">                            removed = U.compareAndSwapObject(a, j, task,</span>
                                                             new EmptyTask());
                        break;
                    }
<span class="nc bnc" id="L936" title="All 2 branches missed.">                    else if (t.status &gt;= 0)</span>
<span class="nc" id="L937">                        empty = false;</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                    else if (s + 1 == top) {          // pop and throw away</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">                        if (U.compareAndSwapObject(a, j, t, null))</span>
<span class="nc" id="L940">                            top = s;</span>
                        break;
                    }
<span class="nc bnc" id="L943" title="All 2 branches missed.">                    if (--n == 0) {</span>
<span class="nc bnc" id="L944" title="All 4 branches missed.">                        if (!empty &amp;&amp; base == b)</span>
<span class="nc" id="L945">                            stat = false;</span>
                        break;
                    }
<span class="nc" id="L948">                }</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">                if (removed)</span>
<span class="nc" id="L950">                    task.doExec();</span>
<span class="fc" id="L951">            }</span>
            else
<span class="fc" id="L953">                stat = false;</span>
<span class="fc" id="L954">            return stat;</span>
        }

        /**
         * Tries to poll for and execute the given task or any other
         * task in its CountedCompleter computation.
         */
        final boolean pollAndExecCC(CountedCompleter&lt;?&gt; root) {
            ForkJoinTask&lt;?&gt;[] a; int b; Object o; CountedCompleter&lt;?&gt; t, r;
<span class="pc bpc" id="L963" title="1 of 4 branches missed.">            if ((b = base) - top &lt; 0 &amp;&amp; (a = array) != null) {</span>
<span class="fc" id="L964">                long j = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc bfc" id="L965" title="All 2 branches covered.">                if ((o = U.getObjectVolatile(a, j)) == null)</span>
<span class="fc" id="L966">                    return true; // retry</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">                if (o instanceof CountedCompleter) {</span>
<span class="fc" id="L968">                    for (t = (CountedCompleter&lt;?&gt;)o, r = t;;) {</span>
<span class="fc bfc" id="L969" title="All 2 branches covered.">                        if (r == root) {</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">                            if (base == b &amp;&amp;</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">                                U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="fc" id="L972">                                U.putOrderedInt(this, QBASE, b + 1);</span>
<span class="fc" id="L973">                                t.doExec();</span>
                            }
<span class="fc" id="L975">                            return true;</span>
                        }
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">                        else if ((r = r.completer) == null)</span>
<span class="nc" id="L978">                            break; // not part of root computation</span>
                    }
                }
            }
<span class="fc" id="L982">            return false;</span>
        }

        /**
         * Tries to pop and execute the given task or any other task
         * in its CountedCompleter computation.
         */
        final boolean externalPopAndExecCC(CountedCompleter&lt;?&gt; root) {
            ForkJoinTask&lt;?&gt;[] a; int s; Object o; CountedCompleter&lt;?&gt; t, r;
<span class="pc bpc" id="L991" title="1 of 4 branches missed.">            if (base - (s = top) &lt; 0 &amp;&amp; (a = array) != null) {</span>
<span class="fc" id="L992">                long j = (((a.length - 1) &amp; (s - 1)) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">                if ((o = U.getObject(a, j)) instanceof CountedCompleter) {</span>
<span class="fc" id="L994">                    for (t = (CountedCompleter&lt;?&gt;)o, r = t;;) {</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">                        if (r == root) {</span>
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">                            if (U.compareAndSwapInt(this, QLOCK, 0, 1)) {</span>
<span class="pc bpc" id="L997" title="2 of 4 branches missed.">                                if (top == s &amp;&amp; array == a &amp;&amp;</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">                                    U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="fc" id="L999">                                    top = s - 1;</span>
<span class="fc" id="L1000">                                    qlock = 0;</span>
<span class="fc" id="L1001">                                    t.doExec();</span>
                                }
                                else
<span class="fc" id="L1004">                                    qlock = 0;</span>
                            }
<span class="fc" id="L1006">                            return true;</span>
                        }
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">                        else if ((r = r.completer) == null)</span>
<span class="nc" id="L1009">                            break;</span>
                    }
                }
            }
<span class="fc" id="L1013">            return false;</span>
        }

        /**
         * Internal version
         */
        final boolean internalPopAndExecCC(CountedCompleter&lt;?&gt; root) {
            ForkJoinTask&lt;?&gt;[] a; int s; Object o; CountedCompleter&lt;?&gt; t, r;
<span class="nc bnc" id="L1021" title="All 4 branches missed.">            if (base - (s = top) &lt; 0 &amp;&amp; (a = array) != null) {</span>
<span class="nc" id="L1022">                long j = (((a.length - 1) &amp; (s - 1)) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if ((o = U.getObject(a, j)) instanceof CountedCompleter) {</span>
<span class="nc" id="L1024">                    for (t = (CountedCompleter&lt;?&gt;)o, r = t;;) {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                        if (r == root) {</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                            if (U.compareAndSwapObject(a, j, t, null)) {</span>
<span class="nc" id="L1027">                                top = s - 1;</span>
<span class="nc" id="L1028">                                t.doExec();</span>
                            }
<span class="nc" id="L1030">                            return true;</span>
                        }
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                        else if ((r = r.completer) == null)</span>
<span class="nc" id="L1033">                            break;</span>
                    }
                }
            }
<span class="nc" id="L1037">            return false;</span>
        }

        /**
         * Returns true if owned and not known to be blocked.
         */
        final boolean isApparentlyUnblocked() {
            Thread wt; Thread.State s;
<span class="pc bpc" id="L1045" title="1 of 4 branches missed.">            return (eventCount &gt;= 0 &amp;&amp;</span>
                    (wt = owner) != null &amp;&amp;
<span class="pc bpc" id="L1047" title="4 of 6 branches missed.">                    (s = wt.getState()) != Thread.State.BLOCKED &amp;&amp;</span>
                    s != Thread.State.WAITING &amp;&amp;
                    s != Thread.State.TIMED_WAITING);
        }

        // Unsafe mechanics
        private static final sun.misc.Unsafe U;
        private static final long QBASE;
        private static final long QLOCK;
        private static final int ABASE;
        private static final int ASHIFT;
        static {
            try {
<span class="fc" id="L1060">                U = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L1061">                Class&lt;?&gt; k = WorkQueue.class;</span>
<span class="fc" id="L1062">                Class&lt;?&gt; ak = ForkJoinTask[].class;</span>
<span class="fc" id="L1063">                QBASE = U.objectFieldOffset</span>
<span class="fc" id="L1064">                    (k.getDeclaredField(&quot;base&quot;));</span>
<span class="fc" id="L1065">                QLOCK = U.objectFieldOffset</span>
<span class="fc" id="L1066">                    (k.getDeclaredField(&quot;qlock&quot;));</span>
<span class="fc" id="L1067">                ABASE = U.arrayBaseOffset(ak);</span>
<span class="fc" id="L1068">                int scale = U.arrayIndexScale(ak);</span>
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">                if ((scale &amp; (scale - 1)) != 0)</span>
<span class="nc" id="L1070">                    throw new Error(&quot;data type scale not a power of two&quot;);</span>
<span class="fc" id="L1071">                ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span>
<span class="nc" id="L1072">            } catch (Exception e) {</span>
<span class="nc" id="L1073">                throw new Error(e);</span>
<span class="fc" id="L1074">            }</span>
<span class="fc" id="L1075">        }</span>
    }

    // static fields (initialized in static initializer below)

    /**
     * Creates a new ForkJoinWorkerThread. This factory is used unless
     * overridden in ForkJoinPool constructors.
     */
    public static final ForkJoinWorkerThreadFactory
        defaultForkJoinWorkerThreadFactory;

    /**
     * Permission required for callers of methods that may start or
     * kill threads.
     */
    private static final RuntimePermission modifyThreadPermission;

    /**
     * Common (static) pool. Non-null for public use unless a static
     * construction exception, but internal usages null-check on use
     * to paranoically avoid potential initialization circularities
     * as well as to simplify generated code.
     */
    static final ForkJoinPool common;

    /**
     * Common pool parallelism. To allow simpler use and management
     * when common pool threads are disabled, we allow the underlying
     * common.parallelism field to be zero, but in that case still report
     * parallelism as 1 to reflect resulting caller-runs mechanics.
     */
    static final int commonParallelism;

    /**
     * Sequence number for creating workerNamePrefix.
     */
    private static int poolNumberSequence;

    /**
     * Returns the next sequence number. We don't expect this to
     * ever contend, so use simple builtin sync.
     */
    private static final synchronized int nextPoolId() {
<span class="fc" id="L1119">        return ++poolNumberSequence;</span>
    }

    // static constants

    /**
     * Initial timeout value (in nanoseconds) for the thread
     * triggering quiescence to park waiting for new work. On timeout,
     * the thread will instead try to shrink the number of
     * workers. The value should be large enough to avoid overly
     * aggressive shrinkage during most transient stalls (long GCs
     * etc).
     */
    private static final long IDLE_TIMEOUT      = 2000L * 1000L * 1000L; // 2sec

    /**
     * Timeout value when there are more threads than parallelism level
     */
    private static final long FAST_IDLE_TIMEOUT =  200L * 1000L * 1000L;

    /**
     * Tolerance for idle timeouts, to cope with timer undershoots
     */
    private static final long TIMEOUT_SLOP = 2000000L;

    /**
     * The maximum stolen-&gt;joining link depth allowed in method
     * tryHelpStealer.  Must be a power of two.  Depths for legitimate
     * chains are unbounded, but we use a fixed constant to avoid
     * (otherwise unchecked) cycles and to bound staleness of
     * traversal parameters at the expense of sometimes blocking when
     * we could be helping.
     */
    private static final int MAX_HELP = 64;

    /**
     * Increment for seed generators. See class ThreadLocal for
     * explanation.
     */
    private static final int SEED_INCREMENT = 0x61c88647;

    /*
     * Bits and masks for control variables
     *
     * Field ctl is a long packed with:
     * AC: Number of active running workers minus target parallelism (16 bits)
     * TC: Number of total workers minus target parallelism (16 bits)
     * ST: true if pool is terminating (1 bit)
     * EC: the wait count of top waiting thread (15 bits)
     * ID: poolIndex of top of Treiber stack of waiters (16 bits)
     *
     * When convenient, we can extract the upper 32 bits of counts and
     * the lower 32 bits of queue state, u = (int)(ctl &gt;&gt;&gt; 32) and e =
     * (int)ctl.  The ec field is never accessed alone, but always
     * together with id and st. The offsets of counts by the target
     * parallelism and the positionings of fields makes it possible to
     * perform the most common checks via sign tests of fields: When
     * ac is negative, there are not enough active workers, when tc is
     * negative, there are not enough total workers, and when e is
     * negative, the pool is terminating.  To deal with these possibly
     * negative fields, we use casts in and out of &quot;short&quot; and/or
     * signed shifts to maintain signedness.
     *
     * When a thread is queued (inactivated), its eventCount field is
     * set negative, which is the only way to tell if a worker is
     * prevented from executing tasks, even though it must continue to
     * scan for them to avoid queuing races. Note however that
     * eventCount updates lag releases so usage requires care.
     *
     * Field plock is an int packed with:
     * SHUTDOWN: true if shutdown is enabled (1 bit)
     * SEQ:  a sequence lock, with PL_LOCK bit set if locked (30 bits)
     * SIGNAL: set when threads may be waiting on the lock (1 bit)
     *
     * The sequence number enables simple consistency checks:
     * Staleness of read-only operations on the workQueues array can
     * be checked by comparing plock before vs after the reads.
     */

    // bit positions/shifts for fields
    private static final int  AC_SHIFT   = 48;
    private static final int  TC_SHIFT   = 32;
    private static final int  ST_SHIFT   = 31;
    private static final int  EC_SHIFT   = 16;

    // bounds
    private static final int  SMASK      = 0xffff;  // short bits
    private static final int  MAX_CAP    = 0x7fff;  // max #workers - 1
    private static final int  EVENMASK   = 0xfffe;  // even short bits
    private static final int  SQMASK     = 0x007e;  // max 64 (even) slots
    private static final int  SHORT_SIGN = 1 &lt;&lt; 15;
    private static final int  INT_SIGN   = 1 &lt;&lt; 31;

    // masks
    private static final long STOP_BIT   = 0x0001L &lt;&lt; ST_SHIFT;
    private static final long AC_MASK    = ((long)SMASK) &lt;&lt; AC_SHIFT;
    private static final long TC_MASK    = ((long)SMASK) &lt;&lt; TC_SHIFT;

    // units for incrementing and decrementing
    private static final long TC_UNIT    = 1L &lt;&lt; TC_SHIFT;
    private static final long AC_UNIT    = 1L &lt;&lt; AC_SHIFT;

    // masks and units for dealing with u = (int)(ctl &gt;&gt;&gt; 32)
    private static final int  UAC_SHIFT  = AC_SHIFT - 32;
    private static final int  UTC_SHIFT  = TC_SHIFT - 32;
    private static final int  UAC_MASK   = SMASK &lt;&lt; UAC_SHIFT;
    private static final int  UTC_MASK   = SMASK &lt;&lt; UTC_SHIFT;
    private static final int  UAC_UNIT   = 1 &lt;&lt; UAC_SHIFT;
    private static final int  UTC_UNIT   = 1 &lt;&lt; UTC_SHIFT;

    // masks and units for dealing with e = (int)ctl
    private static final int E_MASK      = 0x7fffffff; // no STOP_BIT
    private static final int E_SEQ       = 1 &lt;&lt; EC_SHIFT;

    // plock bits
    private static final int SHUTDOWN    = 1 &lt;&lt; 31;
    private static final int PL_LOCK     = 2;
    private static final int PL_SIGNAL   = 1;
    private static final int PL_SPINS    = 1 &lt;&lt; 8;

    // access mode for WorkQueue
    static final int LIFO_QUEUE          =  0;
    static final int FIFO_QUEUE          =  1;
    static final int SHARED_QUEUE        = -1;

    // Instance fields
    volatile long stealCount;                  // collects worker counts
    volatile long ctl;                         // main pool control
    volatile int plock;                        // shutdown status and seqLock
    volatile int indexSeed;                    // worker/submitter index seed
    final short parallelism;                   // parallelism level
    final short mode;                          // LIFO/FIFO
    WorkQueue[] workQueues;                    // main registry
    final ForkJoinWorkerThreadFactory factory;
    final UncaughtExceptionHandler ueh;        // per-worker UEH
    final String workerNamePrefix;             // to create worker name string

    /**
     * Acquires the plock lock to protect worker array and related
     * updates. This method is called only if an initial CAS on plock
     * fails. This acts as a spinlock for normal cases, but falls back
     * to builtin monitor to block when (rarely) needed. This would be
     * a terrible idea for a highly contended lock, but works fine as
     * a more conservative alternative to a pure spinlock.
     */
    private int acquirePlock() {
<span class="fc" id="L1265">        int spins = PL_SPINS, ps, nps;</span>
        for (;;) {
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">            if (((ps = plock) &amp; PL_LOCK) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">                U.compareAndSwapInt(this, PLOCK, ps, nps = ps + PL_LOCK))</span>
<span class="fc" id="L1269">                return nps;</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">            else if (spins &gt;= 0) {</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">                if (ThreadLocalRandom.nextSecondarySeed() &gt;= 0)</span>
<span class="nc" id="L1272">                    --spins;</span>
            }
<span class="nc bnc" id="L1274" title="All 2 branches missed.">            else if (U.compareAndSwapInt(this, PLOCK, ps, ps | PL_SIGNAL)) {</span>
<span class="nc" id="L1275">                synchronized (this) {</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                    if ((plock &amp; PL_SIGNAL) != 0) {</span>
                        try {
<span class="nc" id="L1278">                            wait();</span>
<span class="nc" id="L1279">                        } catch (InterruptedException ie) {</span>
                            try {
<span class="nc" id="L1281">                                Thread.currentThread().interrupt();</span>
<span class="nc" id="L1282">                            } catch (SecurityException ignore) {</span>
<span class="nc" id="L1283">                            }</span>
<span class="nc" id="L1284">                        }</span>
                    }
                    else
<span class="nc" id="L1287">                        notifyAll();</span>
<span class="nc" id="L1288">                }</span>
            }
        }
    }

    /**
     * Unlocks and signals any thread waiting for plock. Called only
     * when CAS of seq value for unlock fails.
     */
    private void releasePlock(int ps) {
<span class="nc" id="L1298">        plock = ps;</span>
<span class="nc" id="L1299">        synchronized (this) { notifyAll(); }</span>
<span class="nc" id="L1300">    }</span>

    /**
     * Tries to create and start one worker if fewer than target
     * parallelism level exist. Adjusts counts etc on failure.
     */
    private void tryAddWorker() {
        long c; int u, e;
<span class="pc bpc" id="L1308" title="3 of 6 branches missed.">        while ((u = (int)((c = ctl) &gt;&gt;&gt; 32)) &lt; 0 &amp;&amp;</span>
               (u &amp; SHORT_SIGN) != 0 &amp;&amp; (e = (int)c) &gt;= 0) {
<span class="fc" id="L1310">            long nc = ((long)(((u + UTC_UNIT) &amp; UTC_MASK) |</span>
                              ((u + UAC_UNIT) &amp; UAC_MASK)) &lt;&lt; 32) | (long)e;
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">            if (U.compareAndSwapLong(this, CTL, c, nc)) {</span>
                ForkJoinWorkerThreadFactory fac;
<span class="fc" id="L1314">                Throwable ex = null;</span>
<span class="fc" id="L1315">                ForkJoinWorkerThread wt = null;</span>
                try {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">                    if ((fac = factory) != null &amp;&amp;</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">                        (wt = fac.newThread(this)) != null) {</span>
<span class="fc" id="L1319">                        wt.start();</span>
<span class="fc" id="L1320">                        break;</span>
                    }
<span class="nc" id="L1322">                } catch (Throwable rex) {</span>
<span class="nc" id="L1323">                    ex = rex;</span>
<span class="fc" id="L1324">                }</span>
<span class="fc" id="L1325">                deregisterWorker(wt, ex);</span>
<span class="fc" id="L1326">                break;</span>
            }
<span class="nc" id="L1328">        }</span>
<span class="fc" id="L1329">    }</span>

    //  Registering and deregistering workers

    /**
     * Callback from ForkJoinWorkerThread to establish and record its
     * WorkQueue. To avoid scanning bias due to packing entries in
     * front of the workQueues array, we treat the array as a simple
     * power-of-two hash table using per-thread seed as hash,
     * expanding as needed.
     *
     * @param wt the worker thread
     * @return the worker's queue
     */
    final WorkQueue registerWorker(ForkJoinWorkerThread wt) {
        UncaughtExceptionHandler handler; WorkQueue[] ws; int s, ps;
<span class="fc" id="L1345">        wt.setDaemon(true);</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        if ((handler = ueh) != null)</span>
<span class="fc" id="L1347">            wt.setUncaughtExceptionHandler(handler);</span>
<span class="pc bpc" id="L1348" title="1 of 4 branches missed.">        do {} while (!U.compareAndSwapInt(this, INDEXSEED, s = indexSeed,</span>
                                          s += SEED_INCREMENT) ||
                     s == 0); // skip 0
<span class="fc" id="L1351">        WorkQueue w = new WorkQueue(this, wt, mode, s);</span>
<span class="pc bpc" id="L1352" title="1 of 2 branches missed.">        if (((ps = plock) &amp; PL_LOCK) != 0 ||</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">            !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))</span>
<span class="fc" id="L1354">            ps = acquirePlock();</span>
<span class="fc" id="L1355">        int nps = (ps &amp; SHUTDOWN) | ((ps + PL_LOCK) &amp; ~SHUTDOWN);</span>
        try {
<span class="pc bpc" id="L1357" title="1 of 2 branches missed.">            if ((ws = workQueues) != null) {    // skip if shutting down</span>
<span class="fc" id="L1358">                int n = ws.length, m = n - 1;</span>
<span class="fc" id="L1359">                int r = (s &lt;&lt; 1) | 1;           // use odd-numbered indices</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">                if (ws[r &amp;= m] != null) {       // collision</span>
<span class="fc" id="L1361">                    int probes = 0;             // step by approx half size</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">                    int step = (n &lt;= 4) ? 2 : ((n &gt;&gt;&gt; 1) &amp; EVENMASK) + 2;</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">                    while (ws[r = (r + step) &amp; m] != null) {</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                        if (++probes &gt;= n) {</span>
<span class="fc" id="L1365">                            workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= 1);</span>
<span class="fc" id="L1366">                            m = n - 1;</span>
<span class="fc" id="L1367">                            probes = 0;</span>
                        }
                    }
                }
<span class="fc" id="L1371">                w.poolIndex = (short)r;</span>
<span class="fc" id="L1372">                w.eventCount = r; // volatile write orders</span>
<span class="fc" id="L1373">                ws[r] = w;</span>
            }
        } finally {
<span class="pc bpc" id="L1376" title="3 of 4 branches missed.">            if (!U.compareAndSwapInt(this, PLOCK, ps, nps))</span>
<span class="nc" id="L1377">                releasePlock(nps);</span>
        }
<span class="fc" id="L1379">        wt.setName(workerNamePrefix.concat(Integer.toString(w.poolIndex &gt;&gt;&gt; 1)));</span>
<span class="fc" id="L1380">        return w;</span>
    }

    /**
     * Final callback from terminating worker, as well as upon failure
     * to construct or start a worker.  Removes record of worker from
     * array, and adjusts counts. If pool is shutting down, tries to
     * complete termination.
     *
     * @param wt the worker thread, or null if construction failed
     * @param ex the exception causing failure, or null if none
     */
    final void deregisterWorker(ForkJoinWorkerThread wt, Throwable ex) {
<span class="fc" id="L1393">        WorkQueue w = null;</span>
<span class="pc bpc" id="L1394" title="1 of 4 branches missed.">        if (wt != null &amp;&amp; (w = wt.workQueue) != null) {</span>
            int ps;
<span class="fc" id="L1396">            w.qlock = -1;                // ensure set</span>
<span class="fc" id="L1397">            U.getAndAddLong(this, STEALCOUNT, w.nsteals); // collect steals</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">            if (((ps = plock) &amp; PL_LOCK) != 0 ||</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">                !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))</span>
<span class="fc" id="L1400">                ps = acquirePlock();</span>
<span class="fc" id="L1401">            int nps = (ps &amp; SHUTDOWN) | ((ps + PL_LOCK) &amp; ~SHUTDOWN);</span>
            try {
<span class="fc" id="L1403">                int idx = w.poolIndex;</span>
<span class="fc" id="L1404">                WorkQueue[] ws = workQueues;</span>
<span class="pc bpc" id="L1405" title="4 of 8 branches missed.">                if (ws != null &amp;&amp; idx &gt;= 0 &amp;&amp; idx &lt; ws.length &amp;&amp; ws[idx] == w)</span>
<span class="fc" id="L1406">                    ws[idx] = null;</span>
            } finally {
<span class="pc bpc" id="L1408" title="3 of 4 branches missed.">                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))</span>
<span class="nc" id="L1409">                    releasePlock(nps);</span>
            }
        }

        long c;                          // adjust ctl counts
<span class="fc" id="L1414">        do {} while (!U.compareAndSwapLong</span>
<span class="pc bpc" id="L1415" title="1 of 2 branches missed.">                     (this, CTL, c = ctl, (((c - AC_UNIT) &amp; AC_MASK) |</span>
                                           ((c - TC_UNIT) &amp; TC_MASK) |
                                           (c &amp; ~(AC_MASK|TC_MASK)))));

<span class="pc bpc" id="L1419" title="1 of 6 branches missed.">        if (!tryTerminate(false, false) &amp;&amp; w != null &amp;&amp; w.array != null) {</span>
<span class="fc" id="L1420">            w.cancelAll();               // cancel remaining tasks</span>
            WorkQueue[] ws; WorkQueue v; Thread p; int u, i, e;
<span class="pc bpc" id="L1422" title="2 of 4 branches missed.">            while ((u = (int)((c = ctl) &gt;&gt;&gt; 32)) &lt; 0 &amp;&amp; (e = (int)c) &gt;= 0) {</span>
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">                if (e &gt; 0) {             // activate or create replacement</span>
<span class="nc bnc" id="L1424" title="All 6 branches missed.">                    if ((ws = workQueues) == null ||</span>
                        (i = e &amp; SMASK) &gt;= ws.length ||
                        (v = ws[i]) == null)
<span class="nc" id="L1427">                        break;</span>
<span class="nc" id="L1428">                    long nc = (((long)(v.nextWait &amp; E_MASK)) |</span>
                               ((long)(u + UAC_UNIT) &lt;&lt; 32));
<span class="nc bnc" id="L1430" title="All 2 branches missed.">                    if (v.eventCount != (e | INT_SIGN))</span>
<span class="nc" id="L1431">                        break;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                    if (U.compareAndSwapLong(this, CTL, c, nc)) {</span>
<span class="nc" id="L1433">                        v.eventCount = (e + E_SEQ) &amp; E_MASK;</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                        if ((p = v.parker) != null)</span>
<span class="nc" id="L1435">                            U.unpark(p);</span>
                        break;
                    }
<span class="nc" id="L1438">                }</span>
                else {
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">                    if ((short)u &lt; 0)</span>
<span class="fc" id="L1441">                        tryAddWorker();</span>
                    break;
                }
            }
        }
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">        if (ex == null)                     // help clean refs on way out</span>
<span class="fc" id="L1447">            ForkJoinTask.helpExpungeStaleExceptions();</span>
        else                                // rethrow
<span class="nc" id="L1449">            ForkJoinTask.rethrow(ex);</span>
<span class="fc" id="L1450">    }</span>

    // Submissions

    /**
     * Unless shutting down, adds the given task to a submission queue
     * at submitter's current queue index (modulo submission
     * range). Only the most common path is directly handled in this
     * method. All others are relayed to fullExternalPush.
     *
     * @param task the task. Caller must ensure non-null.
     */
    final void externalPush(ForkJoinTask&lt;?&gt; task) {
        WorkQueue q; int m, s, n, am; ForkJoinTask&lt;?&gt;[] a;
<span class="fc" id="L1464">        int r = ThreadLocalRandom.getProbe();</span>
<span class="fc" id="L1465">        int ps = plock;</span>
<span class="fc" id="L1466">        WorkQueue[] ws = workQueues;</span>
<span class="pc bpc" id="L1467" title="4 of 10 branches missed.">        if (ps &gt; 0 &amp;&amp; ws != null &amp;&amp; (m = (ws.length - 1)) &gt;= 0 &amp;&amp;</span>
            (q = ws[m &amp; r &amp; SQMASK]) != null &amp;&amp; r != 0 &amp;&amp;
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">            U.compareAndSwapInt(q, QLOCK, 0, 1)) { // lock</span>
<span class="pc bpc" id="L1470" title="2 of 4 branches missed.">            if ((a = q.array) != null &amp;&amp;</span>
                (am = a.length - 1) &gt; (n = (s = q.top) - q.base)) {
<span class="fc" id="L1472">                int j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc" id="L1473">                U.putOrderedObject(a, j, task);</span>
<span class="fc" id="L1474">                q.top = s + 1;                     // push on to deque</span>
<span class="fc" id="L1475">                q.qlock = 0;</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">                if (n &lt;= 1)</span>
<span class="fc" id="L1477">                    signalWork(ws, q);</span>
<span class="fc" id="L1478">                return;</span>
            }
<span class="nc" id="L1480">            q.qlock = 0;</span>
        }
<span class="fc" id="L1482">        fullExternalPush(task);</span>
<span class="fc" id="L1483">    }</span>

    /**
     * Full version of externalPush. This method is called, among
     * other times, upon the first submission of the first task to the
     * pool, so must perform secondary initialization.  It also
     * detects first submission by an external thread by looking up
     * its ThreadLocal, and creates a new shared queue if the one at
     * index if empty or contended. The plock lock body must be
     * exception-free (so no try/finally) so we optimistically
     * allocate new queues outside the lock and throw them away if
     * (very rarely) not needed.
     *
     * Secondary initialization occurs when plock is zero, to create
     * workQueue array and set plock to a valid value.  This lock body
     * must also be exception-free. Because the plock seq value can
     * eventually wrap around zero, this method harmlessly fails to
     * reinitialize if workQueues exists, while still advancing plock.
     */
    private void fullExternalPush(ForkJoinTask&lt;?&gt; task) {
        int r;
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if ((r = ThreadLocalRandom.getProbe()) == 0) {</span>
<span class="fc" id="L1505">            ThreadLocalRandom.localInit();</span>
<span class="fc" id="L1506">            r = ThreadLocalRandom.getProbe();</span>
        }
        for (;;) {
            WorkQueue[] ws; WorkQueue q; int ps, m, k;
<span class="fc" id="L1510">            boolean move = false;</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">            if ((ps = plock) &lt; 0)</span>
<span class="nc" id="L1512">                throw new RejectedExecutionException();</span>
<span class="pc bpc" id="L1513" title="2 of 6 branches missed.">            else if (ps == 0 || (ws = workQueues) == null ||</span>
                     (m = ws.length - 1) &lt; 0) { // initialize workQueues
<span class="fc" id="L1515">                int p = parallelism;            // find power of two table size</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">                int n = (p &gt; 1) ? p - 1 : 1;    // ensure at least 2 slots</span>
<span class="fc" id="L1517">                n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2;  n |= n &gt;&gt;&gt; 4;</span>
<span class="fc" id="L1518">                n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; n = (n + 1) &lt;&lt; 1;</span>
<span class="pc bpc" id="L1519" title="3 of 4 branches missed.">                WorkQueue[] nws = ((ws = workQueues) == null || ws.length == 0 ?</span>
                                   new WorkQueue[n] : null);
<span class="pc bpc" id="L1521" title="1 of 2 branches missed.">                if (((ps = plock) &amp; PL_LOCK) != 0 ||</span>
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">                    !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))</span>
<span class="nc" id="L1523">                    ps = acquirePlock();</span>
<span class="pc bpc" id="L1524" title="4 of 6 branches missed.">                if (((ws = workQueues) == null || ws.length == 0) &amp;&amp; nws != null)</span>
<span class="fc" id="L1525">                    workQueues = nws;</span>
<span class="fc" id="L1526">                int nps = (ps &amp; SHUTDOWN) | ((ps + PL_LOCK) &amp; ~SHUTDOWN);</span>
<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))</span>
<span class="nc" id="L1528">                    releasePlock(nps);</span>
<span class="fc" id="L1529">            }</span>
<span class="fc bfc" id="L1530" title="All 2 branches covered.">            else if ((q = ws[k = r &amp; m &amp; SQMASK]) != null) {</span>
<span class="pc bpc" id="L1531" title="2 of 4 branches missed.">                if (q.qlock == 0 &amp;&amp; U.compareAndSwapInt(q, QLOCK, 0, 1)) {</span>
<span class="fc" id="L1532">                    ForkJoinTask&lt;?&gt;[] a = q.array;</span>
<span class="fc" id="L1533">                    int s = q.top;</span>
<span class="fc" id="L1534">                    boolean submitted = false;</span>
                    try {                      // locked version of push
<span class="pc bpc" id="L1536" title="3 of 4 branches missed.">                        if ((a != null &amp;&amp; a.length &gt; s + 1 - q.base) ||</span>
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">                            (a = q.growArray()) != null) {   // must presize</span>
<span class="fc" id="L1538">                            int j = (((a.length - 1) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc" id="L1539">                            U.putOrderedObject(a, j, task);</span>
<span class="fc" id="L1540">                            q.top = s + 1;</span>
<span class="fc" id="L1541">                            submitted = true;</span>
                        }
                    } finally {
<span class="pc" id="L1544">                        q.qlock = 0;  // unlock</span>
<span class="fc" id="L1545">                    }</span>
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">                    if (submitted) {</span>
<span class="fc" id="L1547">                        signalWork(ws, q);</span>
<span class="fc" id="L1548">                        return;</span>
                    }
                }
<span class="nc" id="L1551">                move = true; // move on failure</span>
            }
<span class="pc bpc" id="L1553" title="1 of 2 branches missed.">            else if (((ps = plock) &amp; PL_LOCK) == 0) { // create new queue</span>
<span class="fc" id="L1554">                q = new WorkQueue(this, null, SHARED_QUEUE, r);</span>
<span class="fc" id="L1555">                q.poolIndex = (short)k;</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">                if (((ps = plock) &amp; PL_LOCK) != 0 ||</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">                    !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))</span>
<span class="nc" id="L1558">                    ps = acquirePlock();</span>
<span class="pc bpc" id="L1559" title="3 of 6 branches missed.">                if ((ws = workQueues) != null &amp;&amp; k &lt; ws.length &amp;&amp; ws[k] == null)</span>
<span class="fc" id="L1560">                    ws[k] = q;</span>
<span class="fc" id="L1561">                int nps = (ps &amp; SHUTDOWN) | ((ps + PL_LOCK) &amp; ~SHUTDOWN);</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">                if (!U.compareAndSwapInt(this, PLOCK, ps, nps))</span>
<span class="nc" id="L1563">                    releasePlock(nps);</span>
<span class="fc" id="L1564">            }</span>
            else
<span class="nc" id="L1566">                move = true; // move if busy</span>
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">            if (move)</span>
<span class="nc" id="L1568">                r = ThreadLocalRandom.advanceProbe(r);</span>
<span class="fc" id="L1569">        }</span>
    }

    // Maintaining ctl counts

    /**
     * Increments active count; mainly called upon return from blocking.
     */
    final void incrementActiveCount() {
        long c;
<span class="nc" id="L1579">        do {} while (!U.compareAndSwapLong</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                     (this, CTL, c = ctl, ((c &amp; ~AC_MASK) |</span>
                                           ((c &amp; AC_MASK) + AC_UNIT))));
<span class="nc" id="L1582">    }</span>

    /**
     * Tries to create or activate a worker if too few are active.
     *
     * @param ws the worker array to use to find signallees
     * @param q if non-null, the queue holding tasks to be processed
     */
    final void signalWork(WorkQueue[] ws, WorkQueue q) {
        for (;;) {
            long c; int e, u, i; WorkQueue w; Thread p;
<span class="fc bfc" id="L1593" title="All 2 branches covered.">            if ((u = (int)((c = ctl) &gt;&gt;&gt; 32)) &gt;= 0)</span>
<span class="fc" id="L1594">                break;</span>
<span class="fc bfc" id="L1595" title="All 2 branches covered.">            if ((e = (int)c) &lt;= 0) {</span>
<span class="fc bfc" id="L1596" title="All 2 branches covered.">                if ((short)u &lt; 0)</span>
<span class="fc" id="L1597">                    tryAddWorker();</span>
                break;
            }
<span class="pc bpc" id="L1600" title="3 of 6 branches missed.">            if (ws == null || ws.length &lt;= (i = e &amp; SMASK) ||</span>
                (w = ws[i]) == null)
<span class="nc" id="L1602">                break;</span>
<span class="fc" id="L1603">            long nc = (((long)(w.nextWait &amp; E_MASK)) |</span>
                       ((long)(u + UAC_UNIT)) &lt;&lt; 32);
<span class="fc" id="L1605">            int ne = (e + E_SEQ) &amp; E_MASK;</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">            if (w.eventCount == (e | INT_SIGN) &amp;&amp;</span>
<span class="fc bfc" id="L1607" title="All 2 branches covered.">                U.compareAndSwapLong(this, CTL, c, nc)) {</span>
<span class="fc" id="L1608">                w.eventCount = ne;</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                if ((p = w.parker) != null)</span>
<span class="fc" id="L1610">                    U.unpark(p);</span>
                break;
            }
<span class="pc bpc" id="L1613" title="1 of 4 branches missed.">            if (q != null &amp;&amp; q.base &gt;= q.top)</span>
<span class="fc" id="L1614">                break;</span>
<span class="fc" id="L1615">        }</span>
<span class="fc" id="L1616">    }</span>

    // Scanning for tasks

    /**
     * Top-level runloop for workers, called by ForkJoinWorkerThread.run.
     */
    final void runWorker(WorkQueue w) {
<span class="fc" id="L1624">        w.growArray(); // allocate queue</span>
<span class="fc bfc" id="L1625" title="All 2 branches covered.">        for (int r = w.hint; scan(w, r) == 0; ) {</span>
<span class="fc" id="L1626">            r ^= r &lt;&lt; 13; r ^= r &gt;&gt;&gt; 17; r ^= r &lt;&lt; 5; // xorshift</span>
        }
<span class="fc" id="L1628">    }</span>

    /**
     * Scans for and, if found, runs one task, else possibly
     * inactivates the worker. This method operates on single reads of
     * volatile state and is designed to be re-invoked continuously,
     * in part because it returns upon detecting inconsistencies,
     * contention, or state changes that indicate possible success on
     * re-invocation.
     *
     * The scan searches for tasks across queues starting at a random
     * index, checking each at least twice.  The scan terminates upon
     * either finding a non-empty queue, or completing the sweep. If
     * the worker is not inactivated, it takes and runs a task from
     * this queue. Otherwise, if not activated, it tries to activate
     * itself or some other worker by signalling. On failure to find a
     * task, returns (for retry) if pool state may have changed during
     * an empty scan, or tries to inactivate if active, else possibly
     * blocks or terminates via method awaitWork.
     *
     * @param w the worker (via its WorkQueue)
     * @param r a random seed
     * @return worker qlock status if would have waited, else 0
     */
    private final int scan(WorkQueue w, int r) {
        WorkQueue[] ws; int m;
<span class="fc" id="L1654">        long c = ctl;                            // for consistency check</span>
<span class="pc bpc" id="L1655" title="3 of 6 branches missed.">        if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp; w != null) {</span>
<span class="fc" id="L1656">            for (int j = m + m + 1, ec = w.eventCount;;) {</span>
                WorkQueue q; int b, e; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;
<span class="pc bpc" id="L1658" title="1 of 6 branches missed.">                if ((q = ws[(r - j) &amp; m]) != null &amp;&amp;</span>
                    (b = q.base) - q.top &lt; 0 &amp;&amp; (a = q.array) != null) {
<span class="fc" id="L1660">                    long i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc" id="L1661">                    if ((t = ((ForkJoinTask&lt;?&gt;)</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">                              U.getObjectVolatile(a, i))) != null) {</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">                        if (ec &lt; 0)</span>
<span class="fc" id="L1664">                            helpRelease(c, ws, w, q, b);</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">                        else if (q.base == b &amp;&amp;</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">                                 U.compareAndSwapObject(a, i, t, null)) {</span>
<span class="fc" id="L1667">                            U.putOrderedInt(q, QBASE, b + 1);</span>
<span class="fc bfc" id="L1668" title="All 2 branches covered.">                            if ((b + 1) - q.top &lt; 0)</span>
<span class="fc" id="L1669">                                signalWork(ws, q);</span>
<span class="fc" id="L1670">                            w.runTask(t);</span>
                        }
                    }
                    break;
                }
<span class="fc bfc" id="L1675" title="All 2 branches covered.">                else if (--j &lt; 0) {</span>
<span class="fc bfc" id="L1676" title="All 2 branches covered.">                    if ((ec | (e = (int)c)) &lt; 0) // inactive or terminating</span>
<span class="fc" id="L1677">                        return awaitWork(w, c, ec);</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">                    else if (ctl == c) {         // try to inactivate and enqueue</span>
<span class="fc" id="L1679">                        long nc = (long)ec | ((c - AC_UNIT) &amp; (AC_MASK|TC_MASK));</span>
<span class="fc" id="L1680">                        w.nextWait = e;</span>
<span class="fc" id="L1681">                        w.eventCount = ec | INT_SIGN;</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">                        if (!U.compareAndSwapLong(this, CTL, c, nc))</span>
<span class="fc" id="L1683">                            w.eventCount = ec;   // back out</span>
<span class="fc" id="L1684">                    }</span>
                    break;
                }
<span class="fc" id="L1687">            }</span>
        }
<span class="fc" id="L1689">        return 0;</span>
    }

    /**
     * A continuation of scan(), possibly blocking or terminating
     * worker w. Returns without blocking if pool state has apparently
     * changed since last invocation.  Also, if inactivating w has
     * caused the pool to become quiescent, checks for pool
     * termination, and, so long as this is not the only worker, waits
     * for event for up to a given duration.  On timeout, if ctl has
     * not changed, terminates the worker, which will in turn wake up
     * another worker to possibly repeat this process.
     *
     * @param w the calling worker
     * @param c the ctl value on entry to scan
     * @param ec the worker's eventCount on entry to scan
     */
    private final int awaitWork(WorkQueue w, long c, int ec) {
        int stat, ns; long parkTime, deadline;
<span class="fc bfc" id="L1708" title="All 6 branches covered.">        if ((stat = w.qlock) &gt;= 0 &amp;&amp; w.eventCount == ec &amp;&amp; ctl == c &amp;&amp;</span>
<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">            !Thread.interrupted()) {</span>
<span class="fc" id="L1710">            int e = (int)c;</span>
<span class="fc" id="L1711">            int u = (int)(c &gt;&gt;&gt; 32);</span>
<span class="fc" id="L1712">            int d = (u &gt;&gt; UAC_SHIFT) + parallelism; // active count</span>

<span class="pc bpc" id="L1714" title="1 of 6 branches missed.">            if (e &lt; 0 || (d &lt;= 0 &amp;&amp; tryTerminate(false, false)))</span>
<span class="fc" id="L1715">                stat = w.qlock = -1;          // pool is terminating</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">            else if ((ns = w.nsteals) != 0) { // collect steals and retry</span>
<span class="fc" id="L1717">                w.nsteals = 0;</span>
<span class="fc" id="L1718">                U.getAndAddLong(this, STEALCOUNT, (long)ns);</span>
            }
            else {
<span class="fc bfc" id="L1721" title="All 4 branches covered.">                long pc = ((d &gt; 0 || ec != (e | INT_SIGN)) ? 0L :</span>
                           ((long)(w.nextWait &amp; E_MASK)) | // ctl to restore
                           ((long)(u + UAC_UNIT)) &lt;&lt; 32);
<span class="fc bfc" id="L1724" title="All 2 branches covered.">                if (pc != 0L) {               // timed wait if last waiter</span>
<span class="fc" id="L1725">                    int dc = -(short)(c &gt;&gt;&gt; TC_SHIFT);</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">                    parkTime = (dc &lt; 0 ? FAST_IDLE_TIMEOUT:</span>
                                (dc + 1) * IDLE_TIMEOUT);
<span class="fc" id="L1728">                    deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span>
<span class="fc" id="L1729">                }</span>
                else
<span class="fc" id="L1731">                    parkTime = deadline = 0L;</span>
<span class="fc bfc" id="L1732" title="All 4 branches covered.">                if (w.eventCount == ec &amp;&amp; ctl == c) {</span>
<span class="fc" id="L1733">                    Thread wt = Thread.currentThread();</span>
<span class="fc" id="L1734">                    U.putObject(wt, PARKBLOCKER, this);</span>
<span class="fc" id="L1735">                    w.parker = wt;            // emulate LockSupport.park</span>
<span class="fc bfc" id="L1736" title="All 4 branches covered.">                    if (w.eventCount == ec &amp;&amp; ctl == c)</span>
<span class="fc" id="L1737">                        U.park(false, parkTime);  // must recheck before park</span>
<span class="fc" id="L1738">                    w.parker = null;</span>
<span class="fc" id="L1739">                    U.putObject(wt, PARKBLOCKER, null);</span>
<span class="fc bfc" id="L1740" title="All 4 branches covered.">                    if (parkTime != 0L &amp;&amp; ctl == c &amp;&amp;</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">                        deadline - System.nanoTime() &lt;= 0L &amp;&amp;</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">                        U.compareAndSwapLong(this, CTL, c, pc))</span>
<span class="nc" id="L1743">                        stat = w.qlock = -1;  // shrink pool</span>
                }
            }
        }
<span class="fc" id="L1747">        return stat;</span>
    }

    /**
     * Possibly releases (signals) a worker. Called only from scan()
     * when a worker with apparently inactive status finds a non-empty
     * queue. This requires revalidating all of the associated state
     * from caller.
     */
    private final void helpRelease(long c, WorkQueue[] ws, WorkQueue w,
                                   WorkQueue q, int b) {
        WorkQueue v; int e, i; Thread p;
<span class="pc bpc" id="L1759" title="5 of 14 branches missed.">        if (w != null &amp;&amp; w.eventCount &lt; 0 &amp;&amp; (e = (int)c) &gt; 0 &amp;&amp;</span>
            ws != null &amp;&amp; ws.length &gt; (i = e &amp; SMASK) &amp;&amp;
            (v = ws[i]) != null &amp;&amp; ctl == c) {
<span class="fc" id="L1762">            long nc = (((long)(v.nextWait &amp; E_MASK)) |</span>
                       ((long)((int)(c &gt;&gt;&gt; 32) + UAC_UNIT)) &lt;&lt; 32);
<span class="fc" id="L1764">            int ne = (e + E_SEQ) &amp; E_MASK;</span>
<span class="pc bpc" id="L1765" title="1 of 8 branches missed.">            if (q != null &amp;&amp; q.base == b &amp;&amp; w.eventCount &lt; 0 &amp;&amp;</span>
                v.eventCount == (e | INT_SIGN) &amp;&amp;
<span class="fc bfc" id="L1767" title="All 2 branches covered.">                U.compareAndSwapLong(this, CTL, c, nc)) {</span>
<span class="fc" id="L1768">                v.eventCount = ne;</span>
<span class="pc bpc" id="L1769" title="1 of 2 branches missed.">                if ((p = v.parker) != null)</span>
<span class="nc" id="L1770">                    U.unpark(p);</span>
            }
        }
<span class="fc" id="L1773">    }</span>

    /**
     * Tries to locate and execute tasks for a stealer of the given
     * task, or in turn one of its stealers, Traces currentSteal -&gt;
     * currentJoin links looking for a thread working on a descendant
     * of the given task and with a non-empty queue to steal back and
     * execute tasks from. The first call to this method upon a
     * waiting join will often entail scanning/search, (which is OK
     * because the joiner has nothing better to do), but this method
     * leaves hints in workers to speed up subsequent calls. The
     * implementation is very branchy to cope with potential
     * inconsistencies or loops encountering chains that are stale,
     * unknown, or so long that they are likely cyclic.
     *
     * @param joiner the joining worker
     * @param task the task to join
     * @return 0 if no progress can be made, negative if task
     * known complete, else positive
     */
    private int tryHelpStealer(WorkQueue joiner, ForkJoinTask&lt;?&gt; task) {
<span class="fc" id="L1794">        int stat = 0, steps = 0;                    // bound to avoid cycles</span>
<span class="pc bpc" id="L1795" title="3 of 6 branches missed.">        if (task != null &amp;&amp; joiner != null &amp;&amp;</span>
            joiner.base - joiner.top &gt;= 0) {        // hoist checks
            restart: for (;;) {
<span class="fc" id="L1798">                ForkJoinTask&lt;?&gt; subtask = task;     // current target</span>
<span class="fc" id="L1799">                for (WorkQueue j = joiner, v;;) {   // v is stealer of subtask</span>
                    WorkQueue[] ws; int m, s, h;
<span class="fc bfc" id="L1801" title="All 2 branches covered.">                    if ((s = task.status) &lt; 0) {</span>
<span class="fc" id="L1802">                        stat = s;</span>
<span class="fc" id="L1803">                        break restart;</span>
                    }
<span class="pc bpc" id="L1805" title="2 of 4 branches missed.">                    if ((ws = workQueues) == null || (m = ws.length - 1) &lt;= 0)</span>
<span class="nc" id="L1806">                        break restart;              // shutting down</span>
<span class="pc bpc" id="L1807" title="1 of 4 branches missed.">                    if ((v = ws[h = (j.hint | 1) &amp; m]) == null ||</span>
                        v.currentSteal != subtask) {
<span class="fc" id="L1809">                        for (int origin = h;;) {    // find stealer</span>
<span class="fc bfc" id="L1810" title="All 6 branches covered.">                            if (((h = (h + 2) &amp; m) &amp; 15) == 1 &amp;&amp;</span>
                                (subtask.status &lt; 0 || j.currentJoin != subtask))
<span class="fc" id="L1812">                                continue restart;   // occasional staleness check</span>
<span class="fc bfc" id="L1813" title="All 4 branches covered.">                            if ((v = ws[h]) != null &amp;&amp;</span>
                                v.currentSteal == subtask) {
<span class="fc" id="L1815">                                j.hint = h;        // save hint</span>
<span class="fc" id="L1816">                                break;</span>
                            }
<span class="fc bfc" id="L1818" title="All 2 branches covered.">                            if (h == origin)</span>
<span class="fc" id="L1819">                                break restart;      // cannot find stealer</span>
                        }
                    }
                    for (;;) { // help stealer or descend to its stealer
                        ForkJoinTask&lt;?&gt;[] a; int b;
<span class="fc bfc" id="L1824" title="All 2 branches covered.">                        if (subtask.status &lt; 0)     // surround probes with</span>
<span class="fc" id="L1825">                            continue restart;       //   consistency checks</span>
<span class="pc bpc" id="L1826" title="1 of 4 branches missed.">                        if ((b = v.base) - v.top &lt; 0 &amp;&amp; (a = v.array) != null) {</span>
<span class="fc" id="L1827">                            int i = (((a.length - 1) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="fc" id="L1828">                            ForkJoinTask&lt;?&gt; t =</span>
<span class="fc" id="L1829">                                (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, i);</span>
<span class="pc bpc" id="L1830" title="3 of 6 branches missed.">                            if (subtask.status &lt; 0 || j.currentJoin != subtask ||</span>
                                v.currentSteal != subtask)
<span class="nc" id="L1832">                                continue restart;   // stale</span>
<span class="fc" id="L1833">                            stat = 1;               // apparent progress</span>
<span class="fc bfc" id="L1834" title="All 2 branches covered.">                            if (v.base == b) {</span>
<span class="fc bfc" id="L1835" title="All 2 branches covered.">                                if (t == null)</span>
<span class="fc" id="L1836">                                    break restart;</span>
<span class="fc bfc" id="L1837" title="All 2 branches covered.">                                if (U.compareAndSwapObject(a, i, t, null)) {</span>
<span class="fc" id="L1838">                                    U.putOrderedInt(v, QBASE, b + 1);</span>
<span class="fc" id="L1839">                                    ForkJoinTask&lt;?&gt; ps = joiner.currentSteal;</span>
<span class="fc" id="L1840">                                    int jt = joiner.top;</span>
                                    do {
<span class="fc" id="L1842">                                        joiner.currentSteal = t;</span>
<span class="fc" id="L1843">                                        t.doExec(); // clear local tasks too</span>
<span class="pc bpc" id="L1844" title="1 of 4 branches missed.">                                    } while (task.status &gt;= 0 &amp;&amp;</span>
                                             joiner.top != jt &amp;&amp;
<span class="pc bpc" id="L1846" title="1 of 2 branches missed.">                                             (t = joiner.pop()) != null);</span>
<span class="fc" id="L1847">                                    joiner.currentSteal = ps;</span>
<span class="fc" id="L1848">                                    break restart;</span>
                                }
                            }
<span class="fc" id="L1851">                        }</span>
                        else {                      // empty -- try to descend
<span class="fc" id="L1853">                            ForkJoinTask&lt;?&gt; next = v.currentJoin;</span>
<span class="pc bpc" id="L1854" title="1 of 6 branches missed.">                            if (subtask.status &lt; 0 || j.currentJoin != subtask ||</span>
                                v.currentSteal != subtask)
<span class="nc" id="L1856">                                continue restart;   // stale</span>
<span class="fc bfc" id="L1857" title="All 4 branches covered.">                            else if (next == null || ++steps == MAX_HELP)</span>
<span class="fc" id="L1858">                                break restart;      // dead-end or maybe cyclic</span>
                            else {
<span class="fc" id="L1860">                                subtask = next;</span>
<span class="fc" id="L1861">                                j = v;</span>
<span class="fc" id="L1862">                                break;</span>
                            }
                        }
<span class="fc" id="L1865">                    }</span>
<span class="fc" id="L1866">                }</span>
            }
        }
<span class="fc" id="L1869">        return stat;</span>
    }

    /**
     * Analog of tryHelpStealer for CountedCompleters. Tries to steal
     * and run tasks within the target's computation.
     *
     * @param task the task to join
     * @param maxTasks the maximum number of other tasks to run
     */
    final int helpComplete(WorkQueue joiner, CountedCompleter&lt;?&gt; task,
                           int maxTasks) {
        WorkQueue[] ws; int m;
<span class="nc" id="L1882">        int s = 0;</span>
<span class="nc bnc" id="L1883" title="All 8 branches missed.">        if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp;</span>
            joiner != null &amp;&amp; task != null) {
<span class="nc" id="L1885">            int j = joiner.poolIndex;</span>
<span class="nc" id="L1886">            int scans = m + m + 1;</span>
<span class="nc" id="L1887">            long c = 0L;              // for stability check</span>
<span class="nc" id="L1888">            for (int k = scans; ; j += 2) {</span>
                WorkQueue q;
<span class="nc bnc" id="L1890" title="All 2 branches missed.">                if ((s = task.status) &lt; 0)</span>
<span class="nc" id="L1891">                    break;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">                else if (joiner.internalPopAndExecCC(task)) {</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                    if (--maxTasks &lt;= 0) {</span>
<span class="nc" id="L1894">                        s = task.status;</span>
<span class="nc" id="L1895">                        break;</span>
                    }
<span class="nc" id="L1897">                    k = scans;</span>
                }
<span class="nc bnc" id="L1899" title="All 2 branches missed.">                else if ((s = task.status) &lt; 0)</span>
<span class="nc" id="L1900">                    break;</span>
<span class="nc bnc" id="L1901" title="All 4 branches missed.">                else if ((q = ws[j &amp; m]) != null &amp;&amp; q.pollAndExecCC(task)) {</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">                    if (--maxTasks &lt;= 0) {</span>
<span class="nc" id="L1903">                        s = task.status;</span>
<span class="nc" id="L1904">                        break;</span>
                    }
<span class="nc" id="L1906">                    k = scans;</span>
                }
<span class="nc bnc" id="L1908" title="All 2 branches missed.">                else if (--k &lt; 0) {</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">                    if (c == (c = ctl))</span>
<span class="nc" id="L1910">                        break;</span>
<span class="nc" id="L1911">                    k = scans;</span>
                }
            }
        }
<span class="nc" id="L1915">        return s;</span>
    }

    /**
     * Tries to decrement active count (sometimes implicitly) and
     * possibly release or create a compensating worker in preparation
     * for blocking. Fails on contention or termination. Otherwise,
     * adds a new thread if no idle workers are available and pool
     * may become starved.
     *
     * @param c the assumed ctl value
     */
    final boolean tryCompensate(long c) {
<span class="fc" id="L1928">        WorkQueue[] ws = workQueues;</span>
<span class="fc" id="L1929">        int pc = parallelism, e = (int)c, m, tc;</span>
<span class="pc bpc" id="L1930" title="3 of 8 branches missed.">        if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp; e &gt;= 0 &amp;&amp; ctl == c) {</span>
<span class="fc" id="L1931">            WorkQueue w = ws[e &amp; m];</span>
<span class="pc bpc" id="L1932" title="1 of 4 branches missed.">            if (e != 0 &amp;&amp; w != null) {</span>
                Thread p;
<span class="fc" id="L1934">                long nc = ((long)(w.nextWait &amp; E_MASK) |</span>
                           (c &amp; (AC_MASK|TC_MASK)));
<span class="fc" id="L1936">                int ne = (e + E_SEQ) &amp; E_MASK;</span>
<span class="pc bpc" id="L1937" title="1 of 2 branches missed.">                if (w.eventCount == (e | INT_SIGN) &amp;&amp;</span>
<span class="pc bpc" id="L1938" title="1 of 2 branches missed.">                    U.compareAndSwapLong(this, CTL, c, nc)) {</span>
<span class="fc" id="L1939">                    w.eventCount = ne;</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">                    if ((p = w.parker) != null)</span>
<span class="fc" id="L1941">                        U.unpark(p);</span>
<span class="fc" id="L1942">                    return true;   // replace with idle worker</span>
                }
<span class="nc" id="L1944">            }</span>
<span class="pc bpc" id="L1945" title="1 of 4 branches missed.">            else if ((tc = (short)(c &gt;&gt;&gt; TC_SHIFT)) &gt;= 0 &amp;&amp;</span>
                     (int)(c &gt;&gt; AC_SHIFT) + pc &gt; 1) {
<span class="fc" id="L1947">                long nc = ((c - AC_UNIT) &amp; AC_MASK) | (c &amp; ~AC_MASK);</span>
<span class="fc bfc" id="L1948" title="All 2 branches covered.">                if (U.compareAndSwapLong(this, CTL, c, nc))</span>
<span class="fc" id="L1949">                    return true;   // no compensation</span>
<span class="fc" id="L1950">            }</span>
<span class="pc bpc" id="L1951" title="1 of 2 branches missed.">            else if (tc + pc &lt; MAX_CAP) {</span>
<span class="fc" id="L1952">                long nc = ((c + TC_UNIT) &amp; TC_MASK) | (c &amp; ~TC_MASK);</span>
<span class="pc bpc" id="L1953" title="1 of 2 branches missed.">                if (U.compareAndSwapLong(this, CTL, c, nc)) {</span>
                    ForkJoinWorkerThreadFactory fac;
<span class="fc" id="L1955">                    Throwable ex = null;</span>
<span class="fc" id="L1956">                    ForkJoinWorkerThread wt = null;</span>
                    try {
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">                        if ((fac = factory) != null &amp;&amp;</span>
<span class="pc bpc" id="L1959" title="1 of 2 branches missed.">                            (wt = fac.newThread(this)) != null) {</span>
<span class="fc" id="L1960">                            wt.start();</span>
<span class="fc" id="L1961">                            return true;</span>
                        }
<span class="nc" id="L1963">                    } catch (Throwable rex) {</span>
<span class="nc" id="L1964">                        ex = rex;</span>
<span class="nc" id="L1965">                    }</span>
<span class="nc" id="L1966">                    deregisterWorker(wt, ex); // clean up and return false</span>
                }
            }
        }
<span class="fc" id="L1970">        return false;</span>
    }

    /**
     * Helps and/or blocks until the given task is done.
     *
     * @param joiner the joining worker
     * @param task the task
     * @return task status on exit
     */
    final int awaitJoin(WorkQueue joiner, ForkJoinTask&lt;?&gt; task) {
<span class="fc" id="L1981">        int s = 0;</span>
<span class="pc bpc" id="L1982" title="2 of 6 branches missed.">        if (task != null &amp;&amp; (s = task.status) &gt;= 0 &amp;&amp; joiner != null) {</span>
<span class="fc" id="L1983">            ForkJoinTask&lt;?&gt; prevJoin = joiner.currentJoin;</span>
<span class="fc" id="L1984">            joiner.currentJoin = task;</span>
<span class="pc bpc" id="L1985" title="1 of 4 branches missed.">            do {} while (joiner.tryRemoveAndExec(task) &amp;&amp; // process local tasks</span>
                         (s = task.status) &gt;= 0);
<span class="pc bpc" id="L1987" title="2 of 4 branches missed.">            if (s &gt;= 0 &amp;&amp; (task instanceof CountedCompleter))</span>
<span class="nc" id="L1988">                s = helpComplete(joiner, (CountedCompleter&lt;?&gt;)task, Integer.MAX_VALUE);</span>
<span class="fc" id="L1989">            long cc = 0;        // for stability checks</span>
<span class="fc bfc" id="L1990" title="All 4 branches covered.">            while (s &gt;= 0 &amp;&amp; (s = task.status) &gt;= 0) {</span>
<span class="fc bfc" id="L1991" title="All 4 branches covered.">                if ((s = tryHelpStealer(joiner, task)) == 0 &amp;&amp;</span>
                    (s = task.status) &gt;= 0) {
<span class="fc bfc" id="L1993" title="All 2 branches covered.">                    if (!tryCompensate(cc))</span>
<span class="fc" id="L1994">                        cc = ctl;</span>
                    else {
<span class="pc bpc" id="L1996" title="1 of 4 branches missed.">                        if (task.trySetSignal() &amp;&amp; (s = task.status) &gt;= 0) {</span>
<span class="fc" id="L1997">                            synchronized (task) {</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">                                if (task.status &gt;= 0) {</span>
                                    try {                // see ForkJoinTask
<span class="fc" id="L2000">                                        task.wait();     //  for explanation</span>
<span class="nc" id="L2001">                                    } catch (InterruptedException ie) {</span>
<span class="pc" id="L2002">                                    }</span>
                                }
                                else
<span class="fc" id="L2005">                                    task.notifyAll();</span>
<span class="pc" id="L2006">                            }</span>
                        }
                        long c; // reactivate
<span class="fc" id="L2009">                        do {} while (!U.compareAndSwapLong</span>
<span class="fc bfc" id="L2010" title="All 2 branches covered.">                                     (this, CTL, c = ctl,</span>
                                      ((c &amp; ~AC_MASK) |
                                       ((c &amp; AC_MASK) + AC_UNIT))));
<span class="fc" id="L2013">                    }</span>
                }
            }
<span class="fc" id="L2016">            joiner.currentJoin = prevJoin;</span>
        }
<span class="fc" id="L2018">        return s;</span>
    }

    /**
     * Stripped-down variant of awaitJoin used by timed joins. Tries
     * to help join only while there is continuous progress. (Caller
     * will then enter a timed wait.)
     *
     * @param joiner the joining worker
     * @param task the task
     */
    final void helpJoinOnce(WorkQueue joiner, ForkJoinTask&lt;?&gt; task) {
        int s;
<span class="nc bnc" id="L2031" title="All 6 branches missed.">        if (joiner != null &amp;&amp; task != null &amp;&amp; (s = task.status) &gt;= 0) {</span>
<span class="nc" id="L2032">            ForkJoinTask&lt;?&gt; prevJoin = joiner.currentJoin;</span>
<span class="nc" id="L2033">            joiner.currentJoin = task;</span>
<span class="nc bnc" id="L2034" title="All 4 branches missed.">            do {} while (joiner.tryRemoveAndExec(task) &amp;&amp; // process local tasks</span>
                         (s = task.status) &gt;= 0);
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            if (s &gt;= 0) {</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">                if (task instanceof CountedCompleter)</span>
<span class="nc" id="L2038">                    helpComplete(joiner, (CountedCompleter&lt;?&gt;)task, Integer.MAX_VALUE);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">                do {} while (task.status &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">                             tryHelpStealer(joiner, task) &gt; 0);</span>
            }
<span class="nc" id="L2042">            joiner.currentJoin = prevJoin;</span>
        }
<span class="nc" id="L2044">    }</span>

    /**
     * Returns a (probably) non-empty steal queue, if one is found
     * during a scan, else null.  This method must be retried by
     * caller if, by the time it tries to use the queue, it is empty.
     */
    private WorkQueue findNonEmptyStealQueue() {
<span class="nc" id="L2052">        int r = ThreadLocalRandom.nextSecondarySeed();</span>
        for (;;) {
<span class="nc" id="L2054">            int ps = plock, m; WorkQueue[] ws; WorkQueue q;</span>
<span class="nc bnc" id="L2055" title="All 4 branches missed.">            if ((ws = workQueues) != null &amp;&amp; (m = ws.length - 1) &gt;= 0) {</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                for (int j = (m + 1) &lt;&lt; 2; j &gt;= 0; --j) {</span>
<span class="nc bnc" id="L2057" title="All 4 branches missed.">                    if ((q = ws[(((r - j) &lt;&lt; 1) | 1) &amp; m]) != null &amp;&amp;</span>
                        q.base - q.top &lt; 0)
<span class="nc" id="L2059">                        return q;</span>
                }
            }
<span class="nc bnc" id="L2062" title="All 2 branches missed.">            if (plock == ps)</span>
<span class="nc" id="L2063">                return null;</span>
<span class="nc" id="L2064">        }</span>
    }

    /**
     * Runs tasks until {@code isQuiescent()}. We piggyback on
     * active count ctl maintenance, but rather than blocking
     * when tasks cannot be found, we rescan until all others cannot
     * find tasks either.
     */
    final void helpQuiescePool(WorkQueue w) {
<span class="nc" id="L2074">        ForkJoinTask&lt;?&gt; ps = w.currentSteal;</span>
<span class="nc" id="L2075">        for (boolean active = true;;) {</span>
            long c; WorkQueue q; ForkJoinTask&lt;?&gt; t; int b;
<span class="nc bnc" id="L2077" title="All 2 branches missed.">            while ((t = w.nextLocalTask()) != null)</span>
<span class="nc" id="L2078">                t.doExec();</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">            if ((q = findNonEmptyStealQueue()) != null) {</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">                if (!active) {      // re-establish active count</span>
<span class="nc" id="L2081">                    active = true;</span>
<span class="nc" id="L2082">                    do {} while (!U.compareAndSwapLong</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">                                 (this, CTL, c = ctl,</span>
                                  ((c &amp; ~AC_MASK) |
                                   ((c &amp; AC_MASK) + AC_UNIT))));
                }
<span class="nc bnc" id="L2087" title="All 4 branches missed.">                if ((b = q.base) - q.top &lt; 0 &amp;&amp; (t = q.pollAt(b)) != null) {</span>
<span class="nc" id="L2088">                    (w.currentSteal = t).doExec();</span>
<span class="nc" id="L2089">                    w.currentSteal = ps;</span>
                }
            }
<span class="nc bnc" id="L2092" title="All 2 branches missed.">            else if (active) {       // decrement active count without queuing</span>
<span class="nc" id="L2093">                long nc = ((c = ctl) &amp; ~AC_MASK) | ((c &amp; AC_MASK) - AC_UNIT);</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">                if ((int)(nc &gt;&gt; AC_SHIFT) + parallelism == 0)</span>
<span class="nc" id="L2095">                    break;          // bypass decrement-then-increment</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                if (U.compareAndSwapLong(this, CTL, c, nc))</span>
<span class="nc" id="L2097">                    active = false;</span>
<span class="nc" id="L2098">            }</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">            else if ((int)((c = ctl) &gt;&gt; AC_SHIFT) + parallelism &lt;= 0 &amp;&amp;</span>
                     U.compareAndSwapLong
<span class="nc bnc" id="L2101" title="All 2 branches missed.">                     (this, CTL, c, ((c &amp; ~AC_MASK) |</span>
                                     ((c &amp; AC_MASK) + AC_UNIT))))
<span class="nc" id="L2103">                break;</span>
<span class="nc" id="L2104">        }</span>
<span class="nc" id="L2105">    }</span>

    /**
     * Gets and removes a local or stolen task for the given worker.
     *
     * @return a task, if available
     */
    final ForkJoinTask&lt;?&gt; nextTaskFor(WorkQueue w) {
        for (ForkJoinTask&lt;?&gt; t;;) {
            WorkQueue q; int b;
<span class="nc bnc" id="L2115" title="All 2 branches missed.">            if ((t = w.nextLocalTask()) != null)</span>
<span class="nc" id="L2116">                return t;</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">            if ((q = findNonEmptyStealQueue()) == null)</span>
<span class="nc" id="L2118">                return null;</span>
<span class="nc bnc" id="L2119" title="All 4 branches missed.">            if ((b = q.base) - q.top &lt; 0 &amp;&amp; (t = q.pollAt(b)) != null)</span>
<span class="nc" id="L2120">                return t;</span>
<span class="nc" id="L2121">        }</span>
    }

    /**
     * Returns a cheap heuristic guide for task partitioning when
     * programmers, frameworks, tools, or languages have little or no
     * idea about task granularity.  In essence by offering this
     * method, we ask users only about tradeoffs in overhead vs
     * expected throughput and its variance, rather than how finely to
     * partition tasks.
     *
     * In a steady state strict (tree-structured) computation, each
     * thread makes available for stealing enough tasks for other
     * threads to remain active. Inductively, if all threads play by
     * the same rules, each thread should make available only a
     * constant number of tasks.
     *
     * The minimum useful constant is just 1. But using a value of 1
     * would require immediate replenishment upon each steal to
     * maintain enough tasks, which is infeasible.  Further,
     * partitionings/granularities of offered tasks should minimize
     * steal rates, which in general means that threads nearer the top
     * of computation tree should generate more than those nearer the
     * bottom. In perfect steady state, each thread is at
     * approximately the same level of computation tree. However,
     * producing extra tasks amortizes the uncertainty of progress and
     * diffusion assumptions.
     *
     * So, users will want to use values larger (but not much larger)
     * than 1 to both smooth over transient shortages and hedge
     * against uneven progress; as traded off against the cost of
     * extra task overhead. We leave the user to pick a threshold
     * value to compare with the results of this call to guide
     * decisions, but recommend values such as 3.
     *
     * When all threads are active, it is on average OK to estimate
     * surplus strictly locally. In steady-state, if one thread is
     * maintaining say 2 surplus tasks, then so are others. So we can
     * just use estimated queue length.  However, this strategy alone
     * leads to serious mis-estimates in some non-steady-state
     * conditions (ramp-up, ramp-down, other stalls). We can detect
     * many of these by further considering the number of &quot;idle&quot;
     * threads, that are known to have zero queued tasks, so
     * compensate by a factor of (#idle/#active) threads.
     *
     * Note: The approximation of #busy workers as #active workers is
     * not very good under current signalling scheme, and should be
     * improved.
     */
    static int getSurplusQueuedTaskCount() {
        Thread t; ForkJoinWorkerThread wt; ForkJoinPool pool; WorkQueue q;
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">        if (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)) {</span>
<span class="fc" id="L2173">            int p = (pool = (wt = (ForkJoinWorkerThread)t).pool).parallelism;</span>
<span class="fc" id="L2174">            int n = (q = wt.workQueue).top - q.base;</span>
<span class="fc" id="L2175">            int a = (int)(pool.ctl &gt;&gt; AC_SHIFT) + p;</span>
<span class="pc bpc" id="L2176" title="1 of 8 branches missed.">            return n - (a &gt; (p &gt;&gt;&gt;= 1) ? 0 :</span>
                        a &gt; (p &gt;&gt;&gt;= 1) ? 1 :
                        a &gt; (p &gt;&gt;&gt;= 1) ? 2 :
                        a &gt; (p &gt;&gt;&gt;= 1) ? 4 :
                        8);
        }
<span class="nc" id="L2182">        return 0;</span>
    }

    //  Termination

    /**
     * Possibly initiates and/or completes termination.  The caller
     * triggering termination runs three passes through workQueues:
     * (0) Setting termination status, followed by wakeups of queued
     * workers; (1) cancelling all tasks; (2) interrupting lagging
     * threads (likely in external tasks, but possibly also blocked in
     * joins).  Each pass repeats previous steps because of potential
     * lagging thread creation.
     *
     * @param now if true, unconditionally terminate, else only
     * if no work and no active workers
     * @param enable if true, enable shutdown when next possible
     * @return true if now terminating or terminated
     */
    private boolean tryTerminate(boolean now, boolean enable) {
        int ps;
<span class="fc bfc" id="L2203" title="All 2 branches covered.">        if (this == common)                        // cannot shut down</span>
<span class="fc" id="L2204">            return false;</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">        if ((ps = plock) &gt;= 0) {                   // enable by setting plock</span>
<span class="fc bfc" id="L2206" title="All 2 branches covered.">            if (!enable)</span>
<span class="fc" id="L2207">                return false;</span>
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">            if ((ps &amp; PL_LOCK) != 0 ||</span>
<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">                !U.compareAndSwapInt(this, PLOCK, ps, ps += PL_LOCK))</span>
<span class="nc" id="L2210">                ps = acquirePlock();</span>
<span class="fc" id="L2211">            int nps = ((ps + PL_LOCK) &amp; ~SHUTDOWN) | SHUTDOWN;</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">            if (!U.compareAndSwapInt(this, PLOCK, ps, nps))</span>
<span class="nc" id="L2213">                releasePlock(nps);</span>
        }
        for (long c;;) {
<span class="fc bfc" id="L2216" title="All 2 branches covered.">            if (((c = ctl) &amp; STOP_BIT) != 0) {     // already terminating</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">                if ((short)(c &gt;&gt;&gt; TC_SHIFT) + parallelism &lt;= 0) {</span>
<span class="fc" id="L2218">                    synchronized (this) {</span>
<span class="fc" id="L2219">                        notifyAll();               // signal when 0 workers</span>
<span class="pc" id="L2220">                    }</span>
                }
<span class="fc" id="L2222">                return true;</span>
            }
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">            if (!now) {                            // check if idle &amp; no tasks</span>
                WorkQueue[] ws; WorkQueue w;
<span class="fc bfc" id="L2226" title="All 2 branches covered.">                if ((int)(c &gt;&gt; AC_SHIFT) + parallelism &gt; 0)</span>
<span class="fc" id="L2227">                    return false;</span>
<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">                if ((ws = workQueues) != null) {</span>
<span class="fc bfc" id="L2229" title="All 2 branches covered.">                    for (int i = 0; i &lt; ws.length; ++i) {</span>
<span class="fc bfc" id="L2230" title="All 2 branches covered.">                        if ((w = ws[i]) != null &amp;&amp;</span>
<span class="pc bpc" id="L2231" title="2 of 6 branches missed.">                            (!w.isEmpty() ||</span>
                             ((i &amp; 1) != 0 &amp;&amp; w.eventCount &gt;= 0))) {
<span class="nc" id="L2233">                            signalWork(ws, w);</span>
<span class="nc" id="L2234">                            return false;</span>
                        }
                    }
                }
            }
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">            if (U.compareAndSwapLong(this, CTL, c, c | STOP_BIT)) {</span>
<span class="fc bfc" id="L2240" title="All 2 branches covered.">                for (int pass = 0; pass &lt; 3; ++pass) {</span>
                    WorkQueue[] ws; WorkQueue w; Thread wt;
<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">                    if ((ws = workQueues) != null) {</span>
<span class="fc" id="L2243">                        int n = ws.length;</span>
<span class="fc bfc" id="L2244" title="All 2 branches covered.">                        for (int i = 0; i &lt; n; ++i) {</span>
<span class="fc bfc" id="L2245" title="All 2 branches covered.">                            if ((w = ws[i]) != null) {</span>
<span class="fc" id="L2246">                                w.qlock = -1;</span>
<span class="fc bfc" id="L2247" title="All 2 branches covered.">                                if (pass &gt; 0) {</span>
<span class="fc" id="L2248">                                    w.cancelAll();</span>
<span class="fc bfc" id="L2249" title="All 4 branches covered.">                                    if (pass &gt; 1 &amp;&amp; (wt = w.owner) != null) {</span>
<span class="pc bpc" id="L2250" title="1 of 2 branches missed.">                                        if (!wt.isInterrupted()) {</span>
                                            try {
<span class="fc" id="L2252">                                                wt.interrupt();</span>
<span class="nc" id="L2253">                                            } catch (Throwable ignore) {</span>
<span class="fc" id="L2254">                                            }</span>
                                        }
<span class="fc" id="L2256">                                        U.unpark(wt);</span>
                                    }
                                }
                            }
                        }
                        // Wake up workers parked on event queue
                        int i, e; long cc; Thread p;
<span class="pc bpc" id="L2263" title="3 of 8 branches missed.">                        while ((e = (int)(cc = ctl) &amp; E_MASK) != 0 &amp;&amp;</span>
                               (i = e &amp; SMASK) &lt; n &amp;&amp; i &gt;= 0 &amp;&amp;
                               (w = ws[i]) != null) {
<span class="fc" id="L2266">                            long nc = ((long)(w.nextWait &amp; E_MASK) |</span>
                                       ((cc + AC_UNIT) &amp; AC_MASK) |
                                       (cc &amp; (TC_MASK|STOP_BIT)));
<span class="pc bpc" id="L2269" title="1 of 2 branches missed.">                            if (w.eventCount == (e | INT_SIGN) &amp;&amp;</span>
<span class="pc bpc" id="L2270" title="1 of 2 branches missed.">                                U.compareAndSwapLong(this, CTL, cc, nc)) {</span>
<span class="fc" id="L2271">                                w.eventCount = (e + E_SEQ) &amp; E_MASK;</span>
<span class="fc" id="L2272">                                w.qlock = -1;</span>
<span class="fc bfc" id="L2273" title="All 2 branches covered.">                                if ((p = w.parker) != null)</span>
<span class="fc" id="L2274">                                    U.unpark(p);</span>
                            }
<span class="fc" id="L2276">                        }</span>
                    }
                }
            }
        }
    }

    // external operations on common pool

    /**
     * Returns common pool queue for a thread that has submitted at
     * least one task.
     */
    static WorkQueue commonSubmitterQueue() {
        ForkJoinPool p; WorkQueue[] ws; int m, z;
<span class="nc bnc" id="L2291" title="All 8 branches missed.">        return ((z = ThreadLocalRandom.getProbe()) != 0 &amp;&amp;</span>
                (p = common) != null &amp;&amp;
                (ws = p.workQueues) != null &amp;&amp;
                (m = ws.length - 1) &gt;= 0) ?
            ws[m &amp; z &amp; SQMASK] : null;
    }

    /**
     * Tries to pop the given task from submitter's queue in common pool.
     */
    final boolean tryExternalUnpush(ForkJoinTask&lt;?&gt; task) {
        WorkQueue joiner; ForkJoinTask&lt;?&gt;[] a; int m, s;
<span class="fc" id="L2303">        WorkQueue[] ws = workQueues;</span>
<span class="fc" id="L2304">        int z = ThreadLocalRandom.getProbe();</span>
<span class="fc" id="L2305">        boolean popped = false;</span>
<span class="pc bpc" id="L2306" title="4 of 10 branches missed.">        if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp;</span>
            (joiner = ws[z &amp; m &amp; SQMASK]) != null &amp;&amp;
            joiner.base != (s = joiner.top) &amp;&amp;
            (a = joiner.array) != null) {
<span class="fc" id="L2310">            long j = (((a.length - 1) &amp; (s - 1)) &lt;&lt; ASHIFT) + ABASE;</span>
<span class="pc bpc" id="L2311" title="1 of 2 branches missed.">            if (U.getObject(a, j) == task &amp;&amp;</span>
<span class="pc bpc" id="L2312" title="1 of 2 branches missed.">                U.compareAndSwapInt(joiner, QLOCK, 0, 1)) {</span>
<span class="pc bpc" id="L2313" title="2 of 4 branches missed.">                if (joiner.top == s &amp;&amp; joiner.array == a &amp;&amp;</span>
<span class="pc bpc" id="L2314" title="1 of 2 branches missed.">                    U.compareAndSwapObject(a, j, task, null)) {</span>
<span class="fc" id="L2315">                    joiner.top = s - 1;</span>
<span class="fc" id="L2316">                    popped = true;</span>
                }
<span class="fc" id="L2318">                joiner.qlock = 0;</span>
            }
        }
<span class="fc" id="L2321">        return popped;</span>
    }

    final int externalHelpComplete(CountedCompleter&lt;?&gt; task, int maxTasks) {
        WorkQueue joiner; int m;
<span class="fc" id="L2326">        WorkQueue[] ws = workQueues;</span>
<span class="fc" id="L2327">        int j = ThreadLocalRandom.getProbe();</span>
<span class="fc" id="L2328">        int s = 0;</span>
<span class="pc bpc" id="L2329" title="4 of 8 branches missed.">        if (ws != null &amp;&amp; (m = ws.length - 1) &gt;= 0 &amp;&amp;</span>
            (joiner = ws[j &amp; m &amp; SQMASK]) != null &amp;&amp; task != null) {
<span class="fc" id="L2331">            int scans = m + m + 1;</span>
<span class="fc" id="L2332">            long c = 0L;             // for stability check</span>
<span class="fc" id="L2333">            j |= 1;                  // poll odd queues</span>
<span class="fc" id="L2334">            for (int k = scans; ; j += 2) {</span>
                WorkQueue q;
<span class="fc bfc" id="L2336" title="All 2 branches covered.">                if ((s = task.status) &lt; 0)</span>
<span class="fc" id="L2337">                    break;</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">                else if (joiner.externalPopAndExecCC(task)) {</span>
<span class="pc bpc" id="L2339" title="1 of 2 branches missed.">                    if (--maxTasks &lt;= 0) {</span>
<span class="nc" id="L2340">                        s = task.status;</span>
<span class="nc" id="L2341">                        break;</span>
                    }
<span class="fc" id="L2343">                    k = scans;</span>
                }
<span class="fc bfc" id="L2345" title="All 2 branches covered.">                else if ((s = task.status) &lt; 0)</span>
<span class="fc" id="L2346">                    break;</span>
<span class="fc bfc" id="L2347" title="All 4 branches covered.">                else if ((q = ws[j &amp; m]) != null &amp;&amp; q.pollAndExecCC(task)) {</span>
<span class="pc bpc" id="L2348" title="1 of 2 branches missed.">                    if (--maxTasks &lt;= 0) {</span>
<span class="nc" id="L2349">                        s = task.status;</span>
<span class="nc" id="L2350">                        break;</span>
                    }
<span class="fc" id="L2352">                    k = scans;</span>
                }
<span class="fc bfc" id="L2354" title="All 2 branches covered.">                else if (--k &lt; 0) {</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">                    if (c == (c = ctl))</span>
<span class="fc" id="L2356">                        break;</span>
<span class="fc" id="L2357">                    k = scans;</span>
                }
            }
        }
<span class="fc" id="L2361">        return s;</span>
    }

    // Exported methods

    // Constructors

    /**
     * Creates a {@code ForkJoinPool} with parallelism equal to {@link
     * java.lang.Runtime#availableProcessors}, using the {@linkplain
     * #defaultForkJoinWorkerThreadFactory default thread factory},
     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
     *
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}
     */
    public ForkJoinPool() {
<span class="nc" id="L2380">        this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span>
             defaultForkJoinWorkerThreadFactory, null, false);
<span class="nc" id="L2382">    }</span>

    /**
     * Creates a {@code ForkJoinPool} with the indicated parallelism
     * level, the {@linkplain
     * #defaultForkJoinWorkerThreadFactory default thread factory},
     * no UncaughtExceptionHandler, and non-async LIFO processing mode.
     *
     * @param parallelism the parallelism level
     * @throws IllegalArgumentException if parallelism less than or
     *         equal to zero, or greater than implementation limit
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}
     */
    public ForkJoinPool(int parallelism) {
<span class="fc" id="L2399">        this(parallelism, defaultForkJoinWorkerThreadFactory, null, false);</span>
<span class="fc" id="L2400">    }</span>

    /**
     * Creates a {@code ForkJoinPool} with the given parameters.
     *
     * @param parallelism the parallelism level. For default value,
     * use {@link java.lang.Runtime#availableProcessors}.
     * @param factory the factory for creating new threads. For default value,
     * use {@link #defaultForkJoinWorkerThreadFactory}.
     * @param handler the handler for internal worker threads that
     * terminate due to unrecoverable errors encountered while executing
     * tasks. For default value, use {@code null}.
     * @param asyncMode if true,
     * establishes local first-in-first-out scheduling mode for forked
     * tasks that are never joined. This mode may be more appropriate
     * than default locally stack-based mode in applications in which
     * worker threads only process event-style asynchronous tasks.
     * For default value, use {@code false}.
     * @throws IllegalArgumentException if parallelism less than or
     *         equal to zero, or greater than implementation limit
     * @throws NullPointerException if the factory is null
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}
     */
    public ForkJoinPool(int parallelism,
                        ForkJoinWorkerThreadFactory factory,
                        UncaughtExceptionHandler handler,
                        boolean asyncMode) {
<span class="fc" id="L2430">        this(checkParallelism(parallelism),</span>
<span class="pc bpc" id="L2431" title="1 of 2 branches missed.">             checkFactory(factory),</span>
             handler,
             (asyncMode ? FIFO_QUEUE : LIFO_QUEUE),
<span class="fc" id="L2434">             &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);</span>
<span class="fc" id="L2435">        checkPermission();</span>
<span class="fc" id="L2436">    }</span>

    private static int checkParallelism(int parallelism) {
<span class="pc bpc" id="L2439" title="2 of 4 branches missed.">        if (parallelism &lt;= 0 || parallelism &gt; MAX_CAP)</span>
<span class="nc" id="L2440">            throw new IllegalArgumentException();</span>
<span class="fc" id="L2441">        return parallelism;</span>
    }

    private static ForkJoinWorkerThreadFactory checkFactory
        (ForkJoinWorkerThreadFactory factory) {
<span class="pc bpc" id="L2446" title="1 of 2 branches missed.">        if (factory == null)</span>
<span class="nc" id="L2447">            throw new NullPointerException();</span>
<span class="fc" id="L2448">        return factory;</span>
    }

    /**
     * Creates a {@code ForkJoinPool} with the given parameters, without
     * any security checks or parameter validation.  Invoked directly by
     * makeCommonPool.
     */
    private ForkJoinPool(int parallelism,
                         ForkJoinWorkerThreadFactory factory,
                         UncaughtExceptionHandler handler,
                         int mode,
<span class="fc" id="L2460">                         String workerNamePrefix) {</span>
<span class="fc" id="L2461">        this.workerNamePrefix = workerNamePrefix;</span>
<span class="fc" id="L2462">        this.factory = factory;</span>
<span class="fc" id="L2463">        this.ueh = handler;</span>
<span class="fc" id="L2464">        this.mode = (short)mode;</span>
<span class="fc" id="L2465">        this.parallelism = (short)parallelism;</span>
<span class="fc" id="L2466">        long np = (long)(-parallelism); // offset ctl counts</span>
<span class="fc" id="L2467">        this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span>
<span class="fc" id="L2468">    }</span>

    /**
     * Returns the common pool instance. This pool is statically
     * constructed; its run state is unaffected by attempts to {@link
     * #shutdown} or {@link #shutdownNow}. However this pool and any
     * ongoing processing are automatically terminated upon program
     * {@link System#exit}.  Any program that relies on asynchronous
     * task processing to complete before program termination should
     * invoke {@code commonPool().}{@link #awaitQuiescence awaitQuiescence},
     * before exit.
     *
     * @return the common pool instance
     * @since 1.8
     */
    public static ForkJoinPool commonPool() {
        // assert common != null : &quot;static init error&quot;;
<span class="fc" id="L2485">        return common;</span>
    }

    // Execution methods

    /**
     * Performs the given task, returning its result upon completion.
     * If the computation encounters an unchecked Exception or Error,
     * it is rethrown as the outcome of this invocation.  Rethrown
     * exceptions behave in the same way as regular exceptions, but,
     * when possible, contain stack traces (as displayed for example
     * using {@code ex.printStackTrace()}) of both the current thread
     * as well as the thread actually encountering the exception;
     * minimally only the latter.
     *
     * @param task the task
     * @param &lt;T&gt; the type of the task's result
     * @return the task's result
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task) {
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L2509">            throw new NullPointerException();</span>
<span class="fc" id="L2510">        externalPush(task);</span>
<span class="fc" id="L2511">        return task.join();</span>
    }

    /**
     * Arranges for (asynchronous) execution of the given task.
     *
     * @param task the task
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public void execute(ForkJoinTask&lt;?&gt; task) {
<span class="pc bpc" id="L2523" title="1 of 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L2524">            throw new NullPointerException();</span>
<span class="fc" id="L2525">        externalPush(task);</span>
<span class="fc" id="L2526">    }</span>

    // AbstractExecutorService methods

    /**
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public void execute(Runnable task) {
<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L2537">            throw new NullPointerException();</span>
        ForkJoinTask&lt;?&gt; job;
<span class="fc bfc" id="L2539" title="All 2 branches covered.">        if (task instanceof ForkJoinTask&lt;?&gt;) // avoid re-wrap</span>
<span class="fc" id="L2540">            job = (ForkJoinTask&lt;?&gt;) task;</span>
        else
<span class="fc" id="L2542">            job = new ForkJoinTask.RunnableExecuteAction(task);</span>
<span class="fc" id="L2543">        externalPush(job);</span>
<span class="fc" id="L2544">    }</span>

    /**
     * Submits a ForkJoinTask for execution.
     *
     * @param task the task to submit
     * @param &lt;T&gt; the type of the task's result
     * @return the task
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task) {
<span class="nc bnc" id="L2557" title="All 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L2558">            throw new NullPointerException();</span>
<span class="nc" id="L2559">        externalPush(task);</span>
<span class="nc" id="L2560">        return task;</span>
    }

    /**
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task) {
<span class="nc" id="L2569">        ForkJoinTask&lt;T&gt; job = new ForkJoinTask.AdaptedCallable&lt;T&gt;(task);</span>
<span class="nc" id="L2570">        externalPush(job);</span>
<span class="nc" id="L2571">        return job;</span>
    }

    /**
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result) {
<span class="nc" id="L2580">        ForkJoinTask&lt;T&gt; job = new ForkJoinTask.AdaptedRunnable&lt;T&gt;(task, result);</span>
<span class="nc" id="L2581">        externalPush(job);</span>
<span class="nc" id="L2582">        return job;</span>
    }

    /**
     * @throws NullPointerException if the task is null
     * @throws RejectedExecutionException if the task cannot be
     *         scheduled for execution
     */
    public ForkJoinTask&lt;?&gt; submit(Runnable task) {
<span class="nc bnc" id="L2591" title="All 2 branches missed.">        if (task == null)</span>
<span class="nc" id="L2592">            throw new NullPointerException();</span>
        ForkJoinTask&lt;?&gt; job;
<span class="nc bnc" id="L2594" title="All 2 branches missed.">        if (task instanceof ForkJoinTask&lt;?&gt;) // avoid re-wrap</span>
<span class="nc" id="L2595">            job = (ForkJoinTask&lt;?&gt;) task;</span>
        else
<span class="nc" id="L2597">            job = new ForkJoinTask.AdaptedRunnableAction(task);</span>
<span class="nc" id="L2598">        externalPush(job);</span>
<span class="nc" id="L2599">        return job;</span>
    }

    /**
     * @throws NullPointerException       {@inheritDoc}
     * @throws RejectedExecutionException {@inheritDoc}
     */
    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) {
        // In previous versions of this class, this method constructed
        // a task to run ForkJoinTask.invokeAll, but now external
        // invocation of multiple tasks is at least as efficient.
<span class="nc" id="L2610">        ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span>

<span class="nc" id="L2612">        boolean done = false;</span>
        try {
<span class="nc bnc" id="L2614" title="All 2 branches missed.">            for (Callable&lt;T&gt; t : tasks) {</span>
<span class="nc" id="L2615">                ForkJoinTask&lt;T&gt; f = new ForkJoinTask.AdaptedCallable&lt;T&gt;(t);</span>
<span class="nc" id="L2616">                futures.add(f);</span>
<span class="nc" id="L2617">                externalPush(f);</span>
<span class="nc" id="L2618">            }</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">            for (int i = 0, size = futures.size(); i &lt; size; i++)</span>
<span class="nc" id="L2620">                ((ForkJoinTask&lt;?&gt;)futures.get(i)).quietlyJoin();</span>
<span class="nc" id="L2621">            done = true;</span>
<span class="nc" id="L2622">            return futures;</span>
        } finally {
<span class="nc bnc" id="L2624" title="All 4 branches missed.">            if (!done)</span>
<span class="nc bnc" id="L2625" title="All 4 branches missed.">                for (int i = 0, size = futures.size(); i &lt; size; i++)</span>
<span class="nc" id="L2626">                    futures.get(i).cancel(false);</span>
        }
    }

    /**
     * Returns the factory used for constructing new workers.
     *
     * @return the factory used for constructing new workers
     */
    public ForkJoinWorkerThreadFactory getFactory() {
<span class="nc" id="L2636">        return factory;</span>
    }

    /**
     * Returns the handler for internal worker threads that terminate
     * due to unrecoverable errors encountered while executing tasks.
     *
     * @return the handler, or {@code null} if none
     */
    public UncaughtExceptionHandler getUncaughtExceptionHandler() {
<span class="nc" id="L2646">        return ueh;</span>
    }

    /**
     * Returns the targeted parallelism level of this pool.
     *
     * @return the targeted parallelism level of this pool
     */
    public int getParallelism() {
        int par;
<span class="nc bnc" id="L2656" title="All 2 branches missed.">        return ((par = parallelism) &gt; 0) ? par : 1;</span>
    }

    /**
     * Returns the targeted parallelism level of the common pool.
     *
     * @return the targeted parallelism level of the common pool
     * @since 1.8
     */
    public static int getCommonPoolParallelism() {
<span class="fc" id="L2666">        return commonParallelism;</span>
    }

    /**
     * Returns the number of worker threads that have started but not
     * yet terminated.  The result returned by this method may differ
     * from {@link #getParallelism} when threads are created to
     * maintain parallelism when others are cooperatively blocked.
     *
     * @return the number of worker threads
     */
    public int getPoolSize() {
<span class="nc" id="L2678">        return parallelism + (short)(ctl &gt;&gt;&gt; TC_SHIFT);</span>
    }

    /**
     * Returns {@code true} if this pool uses local first-in-first-out
     * scheduling mode for forked tasks that are never joined.
     *
     * @return {@code true} if this pool uses async mode
     */
    public boolean getAsyncMode() {
<span class="nc bnc" id="L2688" title="All 2 branches missed.">        return mode == FIFO_QUEUE;</span>
    }

    /**
     * Returns an estimate of the number of worker threads that are
     * not blocked waiting to join tasks or for other managed
     * synchronization. This method may overestimate the
     * number of running threads.
     *
     * @return the number of worker threads
     */
    public int getRunningThreadCount() {
<span class="nc" id="L2700">        int rc = 0;</span>
        WorkQueue[] ws; WorkQueue w;
<span class="nc bnc" id="L2702" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">            for (int i = 1; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2704" title="All 4 branches missed.">                if ((w = ws[i]) != null &amp;&amp; w.isApparentlyUnblocked())</span>
<span class="nc" id="L2705">                    ++rc;</span>
            }
        }
<span class="nc" id="L2708">        return rc;</span>
    }

    /**
     * Returns an estimate of the number of threads that are currently
     * stealing or executing tasks. This method may overestimate the
     * number of active threads.
     *
     * @return the number of active threads
     */
    public int getActiveThreadCount() {
<span class="nc" id="L2719">        int r = parallelism + (int)(ctl &gt;&gt; AC_SHIFT);</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">        return (r &lt;= 0) ? 0 : r; // suppress momentarily negative values</span>
    }

    /**
     * Returns {@code true} if all worker threads are currently idle.
     * An idle worker is one that cannot obtain a task to execute
     * because none are available to steal from other threads, and
     * there are no pending submissions to the pool. This method is
     * conservative; it might not return {@code true} immediately upon
     * idleness of all threads, but will eventually become true if
     * threads remain inactive.
     *
     * @return {@code true} if all threads are currently idle
     */
    public boolean isQuiescent() {
<span class="nc bnc" id="L2735" title="All 2 branches missed.">        return parallelism + (int)(ctl &gt;&gt; AC_SHIFT) &lt;= 0;</span>
    }

    /**
     * Returns an estimate of the total number of tasks stolen from
     * one thread's work queue by another. The reported value
     * underestimates the actual total number of steals when the pool
     * is not quiescent. This value may be useful for monitoring and
     * tuning fork/join programs: in general, steal counts should be
     * high enough to keep threads busy, but low enough to avoid
     * overhead and contention across threads.
     *
     * @return the number of steals
     */
    public long getStealCount() {
<span class="nc" id="L2750">        long count = stealCount;</span>
        WorkQueue[] ws; WorkQueue w;
<span class="nc bnc" id="L2752" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2753" title="All 2 branches missed.">            for (int i = 1; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">                if ((w = ws[i]) != null)</span>
<span class="nc" id="L2755">                    count += w.nsteals;</span>
            }
        }
<span class="nc" id="L2758">        return count;</span>
    }

    /**
     * Returns an estimate of the total number of tasks currently held
     * in queues by worker threads (but not including tasks submitted
     * to the pool that have not begun executing). This value is only
     * an approximation, obtained by iterating across all threads in
     * the pool. This method may be useful for tuning task
     * granularities.
     *
     * @return the number of queued tasks
     */
    public long getQueuedTaskCount() {
<span class="nc" id="L2772">        long count = 0;</span>
        WorkQueue[] ws; WorkQueue w;
<span class="nc bnc" id="L2774" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">            for (int i = 1; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">                if ((w = ws[i]) != null)</span>
<span class="nc" id="L2777">                    count += w.queueSize();</span>
            }
        }
<span class="nc" id="L2780">        return count;</span>
    }

    /**
     * Returns an estimate of the number of tasks submitted to this
     * pool that have not yet begun executing.  This method may take
     * time proportional to the number of submissions.
     *
     * @return the number of queued submissions
     */
    public int getQueuedSubmissionCount() {
<span class="nc" id="L2791">        int count = 0;</span>
        WorkQueue[] ws; WorkQueue w;
<span class="nc bnc" id="L2793" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2794" title="All 2 branches missed.">            for (int i = 0; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2795" title="All 2 branches missed.">                if ((w = ws[i]) != null)</span>
<span class="nc" id="L2796">                    count += w.queueSize();</span>
            }
        }
<span class="nc" id="L2799">        return count;</span>
    }

    /**
     * Returns {@code true} if there are any tasks submitted to this
     * pool that have not yet begun executing.
     *
     * @return {@code true} if there are any queued submissions
     */
    public boolean hasQueuedSubmissions() {
        WorkQueue[] ws; WorkQueue w;
<span class="nc bnc" id="L2810" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            for (int i = 0; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2812" title="All 4 branches missed.">                if ((w = ws[i]) != null &amp;&amp; !w.isEmpty())</span>
<span class="nc" id="L2813">                    return true;</span>
            }
        }
<span class="nc" id="L2816">        return false;</span>
    }

    /**
     * Removes and returns the next unexecuted submission if one is
     * available.  This method may be useful in extensions to this
     * class that re-assign work in systems with multiple pools.
     *
     * @return the next submission, or {@code null} if none
     */
    protected ForkJoinTask&lt;?&gt; pollSubmission() {
        WorkQueue[] ws; WorkQueue w; ForkJoinTask&lt;?&gt; t;
<span class="nc bnc" id="L2828" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2829" title="All 2 branches missed.">            for (int i = 0; i &lt; ws.length; i += 2) {</span>
<span class="nc bnc" id="L2830" title="All 4 branches missed.">                if ((w = ws[i]) != null &amp;&amp; (t = w.poll()) != null)</span>
<span class="nc" id="L2831">                    return t;</span>
            }
        }
<span class="nc" id="L2834">        return null;</span>
    }

    /**
     * Removes all available unexecuted submitted and forked tasks
     * from scheduling queues and adds them to the given collection,
     * without altering their execution status. These may include
     * artificially generated or wrapped tasks. This method is
     * designed to be invoked only when the pool is known to be
     * quiescent. Invocations at other times may not remove all
     * tasks. A failure encountered while attempting to add elements
     * to collection {@code c} may result in elements being in
     * neither, either or both collections when the associated
     * exception is thrown.  The behavior of this operation is
     * undefined if the specified collection is modified while the
     * operation is in progress.
     *
     * @param c the collection to transfer elements into
     * @return the number of elements transferred
     */
    protected int drainTasksTo(Collection&lt;? super ForkJoinTask&lt;?&gt;&gt; c) {
<span class="nc" id="L2855">        int count = 0;</span>
        WorkQueue[] ws; WorkQueue w; ForkJoinTask&lt;?&gt; t;
<span class="nc bnc" id="L2857" title="All 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="nc bnc" id="L2858" title="All 2 branches missed.">            for (int i = 0; i &lt; ws.length; ++i) {</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">                if ((w = ws[i]) != null) {</span>
<span class="nc bnc" id="L2860" title="All 2 branches missed.">                    while ((t = w.poll()) != null) {</span>
<span class="nc" id="L2861">                        c.add(t);</span>
<span class="nc" id="L2862">                        ++count;</span>
                    }
                }
            }
        }
<span class="nc" id="L2867">        return count;</span>
    }

    /**
     * Returns a string identifying this pool, as well as its state,
     * including indications of run state, parallelism level, and
     * worker and task counts.
     *
     * @return a string identifying this pool, as well as its state
     */
    public String toString() {
        // Use a single pass through workQueues to collect counts
<span class="fc" id="L2879">        long qt = 0L, qs = 0L; int rc = 0;</span>
<span class="fc" id="L2880">        long st = stealCount;</span>
<span class="fc" id="L2881">        long c = ctl;</span>
        WorkQueue[] ws; WorkQueue w;
<span class="pc bpc" id="L2883" title="1 of 2 branches missed.">        if ((ws = workQueues) != null) {</span>
<span class="fc bfc" id="L2884" title="All 2 branches covered.">            for (int i = 0; i &lt; ws.length; ++i) {</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">                if ((w = ws[i]) != null) {</span>
<span class="fc" id="L2886">                    int size = w.queueSize();</span>
<span class="fc bfc" id="L2887" title="All 2 branches covered.">                    if ((i &amp; 1) == 0)</span>
<span class="fc" id="L2888">                        qs += size;</span>
                    else {
<span class="fc" id="L2890">                        qt += size;</span>
<span class="fc" id="L2891">                        st += w.nsteals;</span>
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">                        if (w.isApparentlyUnblocked())</span>
<span class="nc" id="L2893">                            ++rc;</span>
                    }
                }
            }
        }
<span class="fc" id="L2898">        int pc = parallelism;</span>
<span class="fc" id="L2899">        int tc = pc + (short)(c &gt;&gt;&gt; TC_SHIFT);</span>
<span class="fc" id="L2900">        int ac = pc + (int)(c &gt;&gt; AC_SHIFT);</span>
<span class="pc bpc" id="L2901" title="1 of 2 branches missed.">        if (ac &lt; 0) // ignore transient negative</span>
<span class="nc" id="L2902">            ac = 0;</span>
        String level;
<span class="pc bpc" id="L2904" title="1 of 2 branches missed.">        if ((c &amp; STOP_BIT) != 0)</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">            level = (tc == 0) ? &quot;Terminated&quot; : &quot;Terminating&quot;;</span>
        else
<span class="pc bpc" id="L2907" title="1 of 2 branches missed.">            level = plock &lt; 0 ? &quot;Shutting down&quot; : &quot;Running&quot;;</span>
<span class="fc" id="L2908">        return super.toString() +</span>
            &quot;[&quot; + level +
            &quot;, parallelism = &quot; + pc +
            &quot;, size = &quot; + tc +
            &quot;, active = &quot; + ac +
            &quot;, running = &quot; + rc +
            &quot;, steals = &quot; + st +
            &quot;, tasks = &quot; + qt +
            &quot;, submissions = &quot; + qs +
            &quot;]&quot;;
    }

    /**
     * Possibly initiates an orderly shutdown in which previously
     * submitted tasks are executed, but no new tasks will be
     * accepted. Invocation has no effect on execution state if this
     * is the {@link #commonPool()}, and no additional effect if
     * already shut down.  Tasks that are in the process of being
     * submitted concurrently during the course of this method may or
     * may not be rejected.
     *
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}
     */
    public void shutdown() {
<span class="fc" id="L2935">        checkPermission();</span>
<span class="fc" id="L2936">        tryTerminate(false, true);</span>
<span class="fc" id="L2937">    }</span>

    /**
     * Possibly attempts to cancel and/or stop all tasks, and reject
     * all subsequently submitted tasks.  Invocation has no effect on
     * execution state if this is the {@link #commonPool()}, and no
     * additional effect if already shut down. Otherwise, tasks that
     * are in the process of being submitted or executed concurrently
     * during the course of this method may or may not be
     * rejected. This method cancels both existing and unexecuted
     * tasks, in order to permit termination in the presence of task
     * dependencies. So the method always returns an empty list
     * (unlike the case for some other Executors).
     *
     * @return an empty list
     * @throws SecurityException if a security manager exists and
     *         the caller is not permitted to modify threads
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code (&quot;modifyThread&quot;)}
     */
    public List&lt;Runnable&gt; shutdownNow() {
<span class="nc" id="L2958">        checkPermission();</span>
<span class="nc" id="L2959">        tryTerminate(true, true);</span>
<span class="nc" id="L2960">        return Collections.emptyList();</span>
    }

    /**
     * Returns {@code true} if all tasks have completed following shut down.
     *
     * @return {@code true} if all tasks have completed following shut down
     */
    public boolean isTerminated() {
<span class="nc" id="L2969">        long c = ctl;</span>
<span class="nc bnc" id="L2970" title="All 4 branches missed.">        return ((c &amp; STOP_BIT) != 0L &amp;&amp;</span>
                (short)(c &gt;&gt;&gt; TC_SHIFT) + parallelism &lt;= 0);
    }

    /**
     * Returns {@code true} if the process of termination has
     * commenced but not yet completed.  This method may be useful for
     * debugging. A return of {@code true} reported a sufficient
     * period after shutdown may indicate that submitted tasks have
     * ignored or suppressed interruption, or are waiting for I/O,
     * causing this executor not to properly terminate. (See the
     * advisory notes for class {@link ForkJoinTask} stating that
     * tasks should not normally entail blocking operations.  But if
     * they do, they must abort them on interrupt.)
     *
     * @return {@code true} if terminating but not yet terminated
     */
    public boolean isTerminating() {
<span class="nc" id="L2988">        long c = ctl;</span>
<span class="nc bnc" id="L2989" title="All 4 branches missed.">        return ((c &amp; STOP_BIT) != 0L &amp;&amp;</span>
                (short)(c &gt;&gt;&gt; TC_SHIFT) + parallelism &gt; 0);
    }

    /**
     * Returns {@code true} if this pool has been shut down.
     *
     * @return {@code true} if this pool has been shut down
     */
    public boolean isShutdown() {
<span class="nc bnc" id="L2999" title="All 2 branches missed.">        return plock &lt; 0;</span>
    }

    /**
     * Blocks until all tasks have completed execution after a
     * shutdown request, or the timeout occurs, or the current thread
     * is interrupted, whichever happens first. Because the {@link
     * #commonPool()} never terminates until program shutdown, when
     * applied to the common pool, this method is equivalent to {@link
     * #awaitQuiescence(long, TimeUnit)} but always returns {@code false}.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return {@code true} if this executor terminated and
     *         {@code false} if the timeout elapsed before termination
     * @throws InterruptedException if interrupted while waiting
     */
    public boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException {
<span class="nc bnc" id="L3018" title="All 2 branches missed.">        if (Thread.interrupted())</span>
<span class="nc" id="L3019">            throw new InterruptedException();</span>
<span class="nc bnc" id="L3020" title="All 2 branches missed.">        if (this == common) {</span>
<span class="nc" id="L3021">            awaitQuiescence(timeout, unit);</span>
<span class="nc" id="L3022">            return false;</span>
        }
<span class="nc" id="L3024">        long nanos = unit.toNanos(timeout);</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">        if (isTerminated())</span>
<span class="nc" id="L3026">            return true;</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">        if (nanos &lt;= 0L)</span>
<span class="nc" id="L3028">            return false;</span>
<span class="nc" id="L3029">        long deadline = System.nanoTime() + nanos;</span>
<span class="nc" id="L3030">        synchronized (this) {</span>
            for (;;) {
<span class="nc bnc" id="L3032" title="All 2 branches missed.">                if (isTerminated())</span>
<span class="nc" id="L3033">                    return true;</span>
<span class="nc bnc" id="L3034" title="All 2 branches missed.">                if (nanos &lt;= 0L)</span>
<span class="nc" id="L3035">                    return false;</span>
<span class="nc" id="L3036">                long millis = TimeUnit.NANOSECONDS.toMillis(nanos);</span>
<span class="nc bnc" id="L3037" title="All 2 branches missed.">                wait(millis &gt; 0L ? millis : 1L);</span>
<span class="nc" id="L3038">                nanos = deadline - System.nanoTime();</span>
<span class="nc" id="L3039">            }</span>
<span class="nc" id="L3040">        }</span>
    }

    /**
     * If called by a ForkJoinTask operating in this pool, equivalent
     * in effect to {@link ForkJoinTask#helpQuiesce}. Otherwise,
     * waits and/or attempts to assist performing tasks until this
     * pool {@link #isQuiescent} or the indicated timeout elapses.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return {@code true} if quiescent; {@code false} if the
     * timeout elapsed.
     */
    public boolean awaitQuiescence(long timeout, TimeUnit unit) {
<span class="nc" id="L3055">        long nanos = unit.toNanos(timeout);</span>
        ForkJoinWorkerThread wt;
<span class="nc" id="L3057">        Thread thread = Thread.currentThread();</span>
<span class="nc bnc" id="L3058" title="All 4 branches missed.">        if ((thread instanceof ForkJoinWorkerThread) &amp;&amp;</span>
            (wt = (ForkJoinWorkerThread)thread).pool == this) {
<span class="nc" id="L3060">            helpQuiescePool(wt.workQueue);</span>
<span class="nc" id="L3061">            return true;</span>
        }
<span class="nc" id="L3063">        long startTime = System.nanoTime();</span>
        WorkQueue[] ws;
<span class="nc" id="L3065">        int r = 0, m;</span>
<span class="nc" id="L3066">        boolean found = true;</span>
<span class="nc bnc" id="L3067" title="All 6 branches missed.">        while (!isQuiescent() &amp;&amp; (ws = workQueues) != null &amp;&amp;</span>
               (m = ws.length - 1) &gt;= 0) {
<span class="nc bnc" id="L3069" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc bnc" id="L3070" title="All 2 branches missed.">                if ((System.nanoTime() - startTime) &gt; nanos)</span>
<span class="nc" id="L3071">                    return false;</span>
<span class="nc" id="L3072">                Thread.yield(); // cannot block</span>
            }
<span class="nc" id="L3074">            found = false;</span>
<span class="nc bnc" id="L3075" title="All 2 branches missed.">            for (int j = (m + 1) &lt;&lt; 2; j &gt;= 0; --j) {</span>
                ForkJoinTask&lt;?&gt; t; WorkQueue q; int b;
<span class="nc bnc" id="L3077" title="All 4 branches missed.">                if ((q = ws[r++ &amp; m]) != null &amp;&amp; (b = q.base) - q.top &lt; 0) {</span>
<span class="nc" id="L3078">                    found = true;</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">                    if ((t = q.pollAt(b)) != null)</span>
<span class="nc" id="L3080">                        t.doExec();</span>
                    break;
                }
            }
        }
<span class="nc" id="L3085">        return true;</span>
    }

    /**
     * Waits and/or attempts to assist performing tasks indefinitely
     * until the {@link #commonPool()} {@link #isQuiescent}.
     */
    static void quiesceCommonPool() {
<span class="nc" id="L3093">        common.awaitQuiescence(Long.MAX_VALUE, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L3094">    }</span>

    /**
     * Interface for extending managed parallelism for tasks running
     * in {@link ForkJoinPool}s.
     *
     * &lt;p&gt;A {@code ManagedBlocker} provides two methods.  Method
     * {@code isReleasable} must return {@code true} if blocking is
     * not necessary. Method {@code block} blocks the current thread
     * if necessary (perhaps internally invoking {@code isReleasable}
     * before actually blocking). These actions are performed by any
     * thread invoking {@link ForkJoinPool#managedBlock(ManagedBlocker)}.
     * The unusual methods in this API accommodate synchronizers that
     * may, but don't usually, block for long periods. Similarly, they
     * allow more efficient internal handling of cases in which
     * additional workers may be, but usually are not, needed to
     * ensure sufficient parallelism.  Toward this end,
     * implementations of method {@code isReleasable} must be amenable
     * to repeated invocation.
     *
     * &lt;p&gt;For example, here is a ManagedBlocker based on a
     * ReentrantLock:
     *  &lt;pre&gt; {@code
     * class ManagedLocker implements ManagedBlocker {
     *   final ReentrantLock lock;
     *   boolean hasLock = false;
     *   ManagedLocker(ReentrantLock lock) { this.lock = lock; }
     *   public boolean block() {
     *     if (!hasLock)
     *       lock.lock();
     *     return true;
     *   }
     *   public boolean isReleasable() {
     *     return hasLock || (hasLock = lock.tryLock());
     *   }
     * }}&lt;/pre&gt;
     *
     * &lt;p&gt;Here is a class that possibly blocks waiting for an
     * item on a given queue:
     *  &lt;pre&gt; {@code
     * class QueueTaker&lt;E&gt; implements ManagedBlocker {
     *   final BlockingQueue&lt;E&gt; queue;
     *   volatile E item = null;
     *   QueueTaker(BlockingQueue&lt;E&gt; q) { this.queue = q; }
     *   public boolean block() throws InterruptedException {
     *     if (item == null)
     *       item = queue.take();
     *     return true;
     *   }
     *   public boolean isReleasable() {
     *     return item != null || (item = queue.poll()) != null;
     *   }
     *   public E getItem() { // call after pool.managedBlock completes
     *     return item;
     *   }
     * }}&lt;/pre&gt;
     */
    public static interface ManagedBlocker {
        /**
         * Possibly blocks the current thread, for example waiting for
         * a lock or condition.
         *
         * @return {@code true} if no additional blocking is necessary
         * (i.e., if isReleasable would return true)
         * @throws InterruptedException if interrupted while waiting
         * (the method is not required to do so, but is allowed to)
         */
        boolean block() throws InterruptedException;

        /**
         * Returns {@code true} if blocking is unnecessary.
         * @return {@code true} if blocking is unnecessary
         */
        boolean isReleasable();
    }

    /**
     * Blocks in accord with the given blocker.  If the current thread
     * is a {@link ForkJoinWorkerThread}, this method possibly
     * arranges for a spare thread to be activated if necessary to
     * ensure sufficient parallelism while the current thread is blocked.
     *
     * &lt;p&gt;If the caller is not a {@link ForkJoinTask}, this method is
     * behaviorally equivalent to
     *  &lt;pre&gt; {@code
     * while (!blocker.isReleasable())
     *   if (blocker.block())
     *     return;
     * }&lt;/pre&gt;
     *
     * If the caller is a {@code ForkJoinTask}, then the pool may
     * first be expanded to ensure parallelism, and later adjusted.
     *
     * @param blocker the blocker
     * @throws InterruptedException if blocker.block did so
     */
    public static void managedBlock(ManagedBlocker blocker)
        throws InterruptedException {
<span class="fc" id="L3192">        Thread t = Thread.currentThread();</span>
<span class="pc bpc" id="L3193" title="1 of 2 branches missed.">        if (t instanceof ForkJoinWorkerThread) {</span>
<span class="nc" id="L3194">            ForkJoinPool p = ((ForkJoinWorkerThread)t).pool;</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">            while (!blocker.isReleasable()) {</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                if (p.tryCompensate(p.ctl)) {</span>
                    try {
<span class="nc bnc" id="L3198" title="All 2 branches missed.">                        do {} while (!blocker.isReleasable() &amp;&amp;</span>
<span class="nc bnc" id="L3199" title="All 2 branches missed.">                                     !blocker.block());</span>
                    } finally {
<span class="nc" id="L3201">                        p.incrementActiveCount();</span>
<span class="nc" id="L3202">                    }</span>
<span class="nc" id="L3203">                    break;</span>
                }
            }
<span class="nc" id="L3206">        }</span>
        else {
<span class="fc bfc" id="L3208" title="All 2 branches covered.">            do {} while (!blocker.isReleasable() &amp;&amp;</span>
<span class="fc bfc" id="L3209" title="All 2 branches covered.">                         !blocker.block());</span>
        }
<span class="fc" id="L3211">    }</span>

    // AbstractExecutorService overrides.  These rely on undocumented
    // fact that ForkJoinTask.adapt returns ForkJoinTasks that also
    // implement RunnableFuture.

    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
<span class="nc" id="L3218">        return new ForkJoinTask.AdaptedRunnable&lt;T&gt;(runnable, value);</span>
    }

    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
<span class="nc" id="L3222">        return new ForkJoinTask.AdaptedCallable&lt;T&gt;(callable);</span>
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe U;
    private static final long CTL;
    private static final long PARKBLOCKER;
    private static final int ABASE;
    private static final int ASHIFT;
    private static final long STEALCOUNT;
    private static final long PLOCK;
    private static final long INDEXSEED;
    private static final long QBASE;
    private static final long QLOCK;

    static {
        // initialize field offsets for CAS etc
        try {
<span class="fc" id="L3240">            U = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L3241">            Class&lt;?&gt; k = ForkJoinPool.class;</span>
<span class="fc" id="L3242">            CTL = U.objectFieldOffset</span>
<span class="fc" id="L3243">                (k.getDeclaredField(&quot;ctl&quot;));</span>
<span class="fc" id="L3244">            STEALCOUNT = U.objectFieldOffset</span>
<span class="fc" id="L3245">                (k.getDeclaredField(&quot;stealCount&quot;));</span>
<span class="fc" id="L3246">            PLOCK = U.objectFieldOffset</span>
<span class="fc" id="L3247">                (k.getDeclaredField(&quot;plock&quot;));</span>
<span class="fc" id="L3248">            INDEXSEED = U.objectFieldOffset</span>
<span class="fc" id="L3249">                (k.getDeclaredField(&quot;indexSeed&quot;));</span>
<span class="fc" id="L3250">            Class&lt;?&gt; tk = Thread.class;</span>
<span class="fc" id="L3251">            PARKBLOCKER = U.objectFieldOffset</span>
<span class="fc" id="L3252">                (tk.getDeclaredField(&quot;parkBlocker&quot;));</span>
<span class="fc" id="L3253">            Class&lt;?&gt; wk = WorkQueue.class;</span>
<span class="fc" id="L3254">            QBASE = U.objectFieldOffset</span>
<span class="fc" id="L3255">                (wk.getDeclaredField(&quot;base&quot;));</span>
<span class="fc" id="L3256">            QLOCK = U.objectFieldOffset</span>
<span class="fc" id="L3257">                (wk.getDeclaredField(&quot;qlock&quot;));</span>
<span class="fc" id="L3258">            Class&lt;?&gt; ak = ForkJoinTask[].class;</span>
<span class="fc" id="L3259">            ABASE = U.arrayBaseOffset(ak);</span>
<span class="fc" id="L3260">            int scale = U.arrayIndexScale(ak);</span>
<span class="pc bpc" id="L3261" title="1 of 2 branches missed.">            if ((scale &amp; (scale - 1)) != 0)</span>
<span class="nc" id="L3262">                throw new Error(&quot;data type scale not a power of two&quot;);</span>
<span class="fc" id="L3263">            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span>
<span class="nc" id="L3264">        } catch (Exception e) {</span>
<span class="nc" id="L3265">            throw new Error(e);</span>
<span class="fc" id="L3266">        }</span>

<span class="fc" id="L3268">        defaultForkJoinWorkerThreadFactory =</span>
            new DefaultForkJoinWorkerThreadFactory();
<span class="fc" id="L3270">        modifyThreadPermission = new RuntimePermission(&quot;modifyThread&quot;);</span>

<span class="fc" id="L3272">        common = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L3273">            (new java.security.PrivilegedAction&lt;ForkJoinPool&gt;() {</span>
<span class="fc" id="L3274">                public ForkJoinPool run() { return makeCommonPool(); }});</span>
<span class="fc" id="L3275">        int par = common.parallelism; // report 1 even if threads disabled</span>
<span class="fc bfc" id="L3276" title="All 2 branches covered.">        commonParallelism = par &gt; 0 ? par : 1;</span>
<span class="fc" id="L3277">    }</span>

    /**
     * Creates and returns the common pool, respecting user settings
     * specified via system properties.
     */
    private static ForkJoinPool makeCommonPool() {
<span class="fc" id="L3284">        int parallelism = -1;</span>
<span class="fc" id="L3285">        ForkJoinWorkerThreadFactory factory</span>
            = defaultForkJoinWorkerThreadFactory;
<span class="fc" id="L3287">        UncaughtExceptionHandler handler = null;</span>
        try {  // ignore exceptions in accessing/parsing properties
<span class="fc" id="L3289">            String pp = System.getProperty</span>
<span class="fc" id="L3290">                (&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;);</span>
<span class="fc" id="L3291">            String fp = System.getProperty</span>
<span class="fc" id="L3292">                (&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;);</span>
<span class="fc" id="L3293">            String hp = System.getProperty</span>
<span class="fc" id="L3294">                (&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;);</span>
<span class="fc bfc" id="L3295" title="All 2 branches covered.">            if (pp != null)</span>
<span class="fc" id="L3296">                parallelism = Integer.parseInt(pp);</span>
<span class="fc bfc" id="L3297" title="All 2 branches covered.">            if (fp != null)</span>
                factory = ((ForkJoinWorkerThreadFactory)ClassLoader.
<span class="fc" id="L3299">                           getSystemClassLoader().loadClass(fp).newInstance());</span>
<span class="fc bfc" id="L3300" title="All 2 branches covered.">            if (hp != null)</span>
                handler = ((UncaughtExceptionHandler)ClassLoader.
<span class="fc" id="L3302">                           getSystemClassLoader().loadClass(hp).newInstance());</span>
<span class="nc" id="L3303">        } catch (Exception ignore) {</span>
<span class="fc" id="L3304">        }</span>

<span class="fc bfc" id="L3306" title="All 2 branches covered.">        if (parallelism &lt; 0 &amp;&amp; // default 1 less than #cores</span>
<span class="pc bpc" id="L3307" title="1 of 2 branches missed.">            (parallelism = Runtime.getRuntime().availableProcessors() - 1) &lt;= 0)</span>
<span class="nc" id="L3308">            parallelism = 1;</span>
<span class="pc bpc" id="L3309" title="1 of 2 branches missed.">        if (parallelism &gt; MAX_CAP)</span>
<span class="nc" id="L3310">            parallelism = MAX_CAP;</span>
<span class="fc" id="L3311">        return new ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span>
                                &quot;ForkJoinPool.commonPool-worker-&quot;);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>