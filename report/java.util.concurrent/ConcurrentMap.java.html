<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcurrentMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">ConcurrentMap.java</span></div><h1>ConcurrentMap.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * A {@link java.util.Map} providing thread safety and atomicity
 * guarantees.
 *
 * &lt;p&gt;Memory consistency effects: As with other concurrent
 * collections, actions in a thread prior to placing an object into a
 * {@code ConcurrentMap} as a key or value
 * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
 * actions subsequent to the access or removal of that object from
 * the {@code ConcurrentMap} in another thread.
 *
 * &lt;p&gt;This interface is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @since 1.5
 * @author Doug Lea
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 */
public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; {

    /**
     * {@inheritDoc}
     *
     * @implNote This implementation assumes that the ConcurrentMap cannot
     * contain null values and {@code get()} returning null unambiguously means
     * the key is absent. Implementations which support null values
     * &lt;strong&gt;must&lt;/strong&gt; override this default implementation.
     *
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default V getOrDefault(Object key, V defaultValue) {
        V v;
<span class="nc bnc" id="L80" title="All 2 branches missed.">        return ((v = get(key)) != null) ? v : defaultValue;</span>
    }

   /**
     * {@inheritDoc}
     *
     * @implSpec The default implementation is equivalent to, for this
     * {@code map}:
     * &lt;pre&gt; {@code
     * for ((Map.Entry&lt;K, V&gt; entry : map.entrySet())
     *     action.accept(entry.getKey(), entry.getValue());
     * }&lt;/pre&gt;
     *
     * @implNote The default implementation assumes that
     * {@code IllegalStateException} thrown by {@code getKey()} or
     * {@code getValue()} indicates that the entry has been removed and cannot
     * be processed. Operation continues for subsequent entries.
     *
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc" id="L103">        Objects.requireNonNull(action);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {</span>
            K k;
            V v;
            try {
<span class="nc" id="L108">                k = entry.getKey();</span>
<span class="nc" id="L109">                v = entry.getValue();</span>
<span class="nc" id="L110">            } catch(IllegalStateException ise) {</span>
                // this usually means the entry is no longer in the map.
<span class="nc" id="L112">                continue;</span>
<span class="nc" id="L113">            }</span>
<span class="nc" id="L114">            action.accept(k, v);</span>
<span class="nc" id="L115">        }</span>
<span class="nc" id="L116">    }</span>

    /**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * This is equivalent to
     *  &lt;pre&gt; {@code
     * if (!map.containsKey(key))
     *   return map.put(key, value);
     * else
     *   return map.get(key);
     * }&lt;/pre&gt;
     *
     * except that the action is performed atomically.
     *
     * @implNote This implementation intentionally re-abstracts the
     * inappropriate default provided in {@code Map}.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or
     *         {@code null} if there was no mapping for the key.
     *         (A {@code null} return can also indicate that the map
     *         previously associated {@code null} with the key,
     *         if the implementation supports null values.)
     * @throws UnsupportedOperationException if the {@code put} operation
     *         is not supported by this map
     * @throws ClassCastException if the class of the specified key or value
     *         prevents it from being stored in this map
     * @throws NullPointerException if the specified key or value is null,
     *         and this map does not permit null keys or values
     * @throws IllegalArgumentException if some property of the specified key
     *         or value prevents it from being stored in this map
     */
     V putIfAbsent(K key, V value);

    /**
     * Removes the entry for a key only if currently mapped to a given value.
     * This is equivalent to
     *  &lt;pre&gt; {@code
     * if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), value)) {
     *   map.remove(key);
     *   return true;
     * } else
     *   return false;
     * }&lt;/pre&gt;
     *
     * except that the action is performed atomically.
     *
     * @implNote This implementation intentionally re-abstracts the
     * inappropriate default provided in {@code Map}.
     *
     * @param key key with which the specified value is associated
     * @param value value expected to be associated with the specified key
     * @return {@code true} if the value was removed
     * @throws UnsupportedOperationException if the {@code remove} operation
     *         is not supported by this map
     * @throws ClassCastException if the key or value is of an inappropriate
     *         type for this map
     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
     * @throws NullPointerException if the specified key or value is null,
     *         and this map does not permit null keys or values
     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)
     */
    boolean remove(Object key, Object value);

    /**
     * Replaces the entry for a key only if currently mapped to a given value.
     * This is equivalent to
     *  &lt;pre&gt; {@code
     * if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), oldValue)) {
     *   map.put(key, newValue);
     *   return true;
     * } else
     *   return false;
     * }&lt;/pre&gt;
     *
     * except that the action is performed atomically.
     *
     * @implNote This implementation intentionally re-abstracts the
     * inappropriate default provided in {@code Map}.
     *
     * @param key key with which the specified value is associated
     * @param oldValue value expected to be associated with the specified key
     * @param newValue value to be associated with the specified key
     * @return {@code true} if the value was replaced
     * @throws UnsupportedOperationException if the {@code put} operation
     *         is not supported by this map
     * @throws ClassCastException if the class of a specified key or value
     *         prevents it from being stored in this map
     * @throws NullPointerException if a specified key or value is null,
     *         and this map does not permit null keys or values
     * @throws IllegalArgumentException if some property of a specified key
     *         or value prevents it from being stored in this map
     */
    boolean replace(K key, V oldValue, V newValue);

    /**
     * Replaces the entry for a key only if currently mapped to some value.
     * This is equivalent to
     *  &lt;pre&gt; {@code
     * if (map.containsKey(key)) {
     *   return map.put(key, value);
     * } else
     *   return null;
     * }&lt;/pre&gt;
     *
     * except that the action is performed atomically.
     *
     * @implNote This implementation intentionally re-abstracts the
     * inappropriate default provided in {@code Map}.
     *
     * @param key key with which the specified value is associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or
     *         {@code null} if there was no mapping for the key.
     *         (A {@code null} return can also indicate that the map
     *         previously associated {@code null} with the key,
     *         if the implementation supports null values.)
     * @throws UnsupportedOperationException if the {@code put} operation
     *         is not supported by this map
     * @throws ClassCastException if the class of the specified key or value
     *         prevents it from being stored in this map
     * @throws NullPointerException if the specified key or value is null,
     *         and this map does not permit null keys or values
     * @throws IllegalArgumentException if some property of the specified key
     *         or value prevents it from being stored in this map
     */
    V replace(K key, V value);

    /**
     * {@inheritDoc}
     *
     * @implSpec
     * &lt;p&gt;The default implementation is equivalent to, for this {@code map}:
     * &lt;pre&gt; {@code
     * for ((Map.Entry&lt;K, V&gt; entry : map.entrySet())
     *     do {
     *        K k = entry.getKey();
     *        V v = entry.getValue();
     *     } while(!replace(k, v, function.apply(k, v)));
     * }&lt;/pre&gt;
     *
     * The default implementation may retry these steps when multiple
     * threads attempt updates including potentially calling the function
     * repeatedly for a given key.
     *
     * &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
     * values and {@code get()} returning null unambiguously means the key is
     * absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
     * override this default implementation.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @throws ClassCastException {@inheritDoc}
     * @throws IllegalArgumentException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc" id="L276">        Objects.requireNonNull(function);</span>
<span class="nc" id="L277">        forEach((k,v) -&gt; {</span>
            while(!replace(k, v, function.apply(k, v))) {
                // v changed or k is gone
                if ( (v = get(k)) == null) {
                    // k is no longer in the map.
                    break;
                }
            }
        });
<span class="nc" id="L286">    }</span>

    /**
     * {@inheritDoc}
     *
     * @implSpec
     * The default implementation is equivalent to the following steps for this
     * {@code map}, then returning the current value or {@code null} if now
     * absent:
     *
     * &lt;pre&gt; {@code
     * if (map.get(key) == null) {
     *     V newValue = mappingFunction.apply(key);
     *     if (newValue != null)
     *         return map.putIfAbsent(key, newValue);
     * }
     * }&lt;/pre&gt;
     *
     * The default implementation may retry these steps when multiple
     * threads attempt updates including potentially calling the mapping
     * function multiple times.
     *
     * &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
     * values and {@code get()} returning null unambiguously means the key is
     * absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
     * override this default implementation.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default V computeIfAbsent(K key,
            Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc" id="L321">        Objects.requireNonNull(mappingFunction);</span>
        V v, newValue;
<span class="nc bnc" id="L323" title="All 2 branches missed.">        return ((v = get(key)) == null &amp;&amp;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                (newValue = mappingFunction.apply(key)) != null &amp;&amp;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">                (v = putIfAbsent(key, newValue)) == null) ? newValue : v;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @implSpec
     * The default implementation is equivalent to performing the following
     * steps for this {@code map}, then returning the current value or
     * {@code null} if now absent. :
     *
     * &lt;pre&gt; {@code
     * if (map.get(key) != null) {
     *     V oldValue = map.get(key);
     *     V newValue = remappingFunction.apply(key, oldValue);
     *     if (newValue != null)
     *         map.replace(key, oldValue, newValue);
     *     else
     *         map.remove(key, oldValue);
     * }
     * }&lt;/pre&gt;
     *
     * The default implementation may retry these steps when multiple threads
     * attempt updates including potentially calling the remapping function
     * multiple times.
     *
     * &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
     * values and {@code get()} returning null unambiguously means the key is
     * absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
     * override this default implementation.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default V computeIfPresent(K key,
            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L364">        Objects.requireNonNull(remappingFunction);</span>
        V oldValue;
<span class="nc bnc" id="L366" title="All 2 branches missed.">        while((oldValue = get(key)) != null) {</span>
<span class="nc" id="L367">            V newValue = remappingFunction.apply(key, oldValue);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (newValue != null) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (replace(key, oldValue, newValue))</span>
<span class="nc" id="L370">                    return newValue;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            } else if (remove(key, oldValue))</span>
<span class="nc" id="L372">               return null;</span>
<span class="nc" id="L373">        }</span>
<span class="nc" id="L374">        return oldValue;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @implSpec
     * The default implementation is equivalent to performing the following
     * steps for this {@code map}, then returning the current value or
     * {@code null} if absent:
     *
     * &lt;pre&gt; {@code
     * V oldValue = map.get(key);
     * V newValue = remappingFunction.apply(key, oldValue);
     * if (oldValue != null ) {
     *    if (newValue != null)
     *       map.replace(key, oldValue, newValue);
     *    else
     *       map.remove(key, oldValue);
     * } else {
     *    if (newValue != null)
     *       map.putIfAbsent(key, newValue);
     *    else
     *       return null;
     * }
     * }&lt;/pre&gt;
     *
     * The default implementation may retry these steps when multiple
     * threads attempt updates including potentially calling the remapping
     * function multiple times.
     *
     * &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
     * values and {@code get()} returning null unambiguously means the key is
     * absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
     * override this default implementation.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default V compute(K key,
            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L418">        Objects.requireNonNull(remappingFunction);</span>
<span class="nc" id="L419">        V oldValue = get(key);</span>
        for(;;) {
<span class="nc" id="L421">            V newValue = remappingFunction.apply(key, oldValue);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (newValue == null) {</span>
                // delete mapping
<span class="nc bnc" id="L424" title="All 4 branches missed.">                if (oldValue != null || containsKey(key)) {</span>
                    // something to remove
<span class="nc bnc" id="L426" title="All 2 branches missed.">                    if (remove(key, oldValue)) {</span>
                        // removed the old value as expected
<span class="nc" id="L428">                        return null;</span>
                    }

                    // some other value replaced old value. try again.
<span class="nc" id="L432">                    oldValue = get(key);</span>
                } else {
                    // nothing to do. Leave things as they were.
<span class="nc" id="L435">                    return null;</span>
                }
            } else {
                // add or replace old mapping
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (oldValue != null) {</span>
                    // replace
<span class="nc bnc" id="L441" title="All 2 branches missed.">                    if (replace(key, oldValue, newValue)) {</span>
                        // replaced as expected.
<span class="nc" id="L443">                        return newValue;</span>
                    }

                    // some other value replaced old value. try again.
<span class="nc" id="L447">                    oldValue = get(key);</span>
                } else {
                    // add (replace if oldValue was null)
<span class="nc bnc" id="L450" title="All 2 branches missed.">                    if ((oldValue = putIfAbsent(key, newValue)) == null) {</span>
                        // replaced
<span class="nc" id="L452">                        return newValue;</span>
                    }

                    // some other value replaced old value. try again.
                }
            }
<span class="nc" id="L458">        }</span>
    }


    /**
     * {@inheritDoc}
     *
     * @implSpec
     * The default implementation is equivalent to performing the
     * following steps for this {@code map}, then returning the
     * current value or {@code null} if absent:
     *
     * &lt;pre&gt; {@code
     * V oldValue = map.get(key);
     * V newValue = (oldValue == null) ? value :
     *              remappingFunction.apply(oldValue, value);
     * if (newValue == null)
     *     map.remove(key);
     * else if (oldValue == null)
     *     map.remove(key);
     * else
     *     map.put(key, newValue);
     * }&lt;/pre&gt;
     *
     * &lt;p&gt;The default implementation may retry these steps when multiple
     * threads attempt updates including potentially calling the remapping
     * function multiple times.
     *
     * &lt;p&gt;This implementation assumes that the ConcurrentMap cannot contain null
     * values and {@code get()} returning null unambiguously means the key is
     * absent. Implementations which support null values &lt;strong&gt;must&lt;/strong&gt;
     * override this default implementation.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    default V merge(K key, V value,
            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L499">        Objects.requireNonNull(remappingFunction);</span>
<span class="nc" id="L500">        Objects.requireNonNull(value);</span>
<span class="nc" id="L501">        V oldValue = get(key);</span>
        for (;;) {
<span class="nc bnc" id="L503" title="All 2 branches missed.">            if (oldValue != null) {</span>
<span class="nc" id="L504">                V newValue = remappingFunction.apply(oldValue, value);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (newValue != null) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                    if (replace(key, oldValue, newValue))</span>
<span class="nc" id="L507">                        return newValue;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                } else if (remove(key, oldValue)) {</span>
<span class="nc" id="L509">                    return null;</span>
                }
<span class="nc" id="L511">                oldValue = get(key);</span>
<span class="nc" id="L512">            } else {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if ((oldValue = putIfAbsent(key, value)) == null) {</span>
<span class="nc" id="L514">                    return value;</span>
                }
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>