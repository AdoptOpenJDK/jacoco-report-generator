<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ConcurrentSkipListMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">ConcurrentSkipListMap.java</span></div><h1>ConcurrentSkipListMap.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.io.Serializable;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentNavigableMap;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.BiConsumer;
import java.util.function.Function;

/**
 * A scalable concurrent {@link ConcurrentNavigableMap} implementation.
 * The map is sorted according to the {@linkplain Comparable natural
 * ordering} of its keys, or by a {@link Comparator} provided at map
 * creation time, depending on which constructor is used.
 *
 * &lt;p&gt;This class implements a concurrent variant of &lt;a
 * href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt;
 * providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the
 * {@code containsKey}, {@code get}, {@code put} and
 * {@code remove} operations and their variants.  Insertion, removal,
 * update, and access operations safely execute concurrently by
 * multiple threads.
 *
 * &lt;p&gt;Iterators and spliterators are
 * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
 *
 * &lt;p&gt;Ascending key ordered views and their iterators are faster than
 * descending ones.
 *
 * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
 * and its views represent snapshots of mappings at the time they were
 * produced. They do &lt;em&gt;not&lt;/em&gt; support the {@code Entry.setValue}
 * method. (Note however that it is possible to change mappings in the
 * associated map using {@code put}, {@code putIfAbsent}, or
 * {@code replace}, depending on exactly which effect you need.)
 *
 * &lt;p&gt;Beware that, unlike in most collections, the {@code size}
 * method is &lt;em&gt;not&lt;/em&gt; a constant-time operation. Because of the
 * asynchronous nature of these maps, determining the current number
 * of elements requires a traversal of the elements, and so may report
 * inaccurate results if this collection is modified during traversal.
 * Additionally, the bulk operations {@code putAll}, {@code equals},
 * {@code toArray}, {@code containsValue}, and {@code clear} are
 * &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an
 * iterator operating concurrently with a {@code putAll} operation
 * might view only some of the added elements.
 *
 * &lt;p&gt;This class and its views and iterators implement all of the
 * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}
 * interfaces. Like most other concurrent collections, this class does
 * &lt;em&gt;not&lt;/em&gt; permit the use of {@code null} keys or values because some
 * null return values cannot be reliably distinguished from the absence of
 * elements.
 *
 * &lt;p&gt;This class is a member of the
 * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt;
 * Java Collections Framework&lt;/a&gt;.
 *
 * @author Doug Lea
 * @param &lt;K&gt; the type of keys maintained by this map
 * @param &lt;V&gt; the type of mapped values
 * @since 1.6
 */
public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {
    /*
     * This class implements a tree-like two-dimensionally linked skip
     * list in which the index levels are represented in separate
     * nodes from the base nodes holding data.  There are two reasons
     * for taking this approach instead of the usual array-based
     * structure: 1) Array based implementations seem to encounter
     * more complexity and overhead 2) We can use cheaper algorithms
     * for the heavily-traversed index lists than can be used for the
     * base lists.  Here's a picture of some of the basics for a
     * possible list with 2 levels of index:
     *
     * Head nodes          Index nodes
     * +-+    right        +-+                      +-+
     * |2|----------------&gt;| |---------------------&gt;| |-&gt;null
     * +-+                 +-+                      +-+
     *  | down              |                        |
     *  v                   v                        v
     * +-+            +-+  +-+       +-+            +-+       +-+
     * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null
     * +-+            +-+  +-+       +-+            +-+       +-+
     *  v              |    |         |              |         |
     * Nodes  next     v    v         v              v         v
     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
     * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null
     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
     *
     * The base lists use a variant of the HM linked ordered set
     * algorithm. See Tim Harris, &quot;A pragmatic implementation of
     * non-blocking linked lists&quot;
     * http://www.cl.cam.ac.uk/~tlh20/publications.html and Maged
     * Michael &quot;High Performance Dynamic Lock-Free Hash Tables and
     * List-Based Sets&quot;
     * http://www.research.ibm.com/people/m/michael/pubs.htm.  The
     * basic idea in these lists is to mark the &quot;next&quot; pointers of
     * deleted nodes when deleting to avoid conflicts with concurrent
     * insertions, and when traversing to keep track of triples
     * (predecessor, node, successor) in order to detect when and how
     * to unlink these deleted nodes.
     *
     * Rather than using mark-bits to mark list deletions (which can
     * be slow and space-intensive using AtomicMarkedReference), nodes
     * use direct CAS'able next pointers.  On deletion, instead of
     * marking a pointer, they splice in another node that can be
     * thought of as standing for a marked pointer (indicating this by
     * using otherwise impossible field values).  Using plain nodes
     * acts roughly like &quot;boxed&quot; implementations of marked pointers,
     * but uses new nodes only when nodes are deleted, not for every
     * link.  This requires less space and supports faster
     * traversal. Even if marked references were better supported by
     * JVMs, traversal using this technique might still be faster
     * because any search need only read ahead one more node than
     * otherwise required (to check for trailing marker) rather than
     * unmasking mark bits or whatever on each read.
     *
     * This approach maintains the essential property needed in the HM
     * algorithm of changing the next-pointer of a deleted node so
     * that any other CAS of it will fail, but implements the idea by
     * changing the pointer to point to a different node, not by
     * marking it.  While it would be possible to further squeeze
     * space by defining marker nodes not to have key/value fields, it
     * isn't worth the extra type-testing overhead.  The deletion
     * markers are rarely encountered during traversal and are
     * normally quickly garbage collected. (Note that this technique
     * would not work well in systems without garbage collection.)
     *
     * In addition to using deletion markers, the lists also use
     * nullness of value fields to indicate deletion, in a style
     * similar to typical lazy-deletion schemes.  If a node's value is
     * null, then it is considered logically deleted and ignored even
     * though it is still reachable. This maintains proper control of
     * concurrent replace vs delete operations -- an attempted replace
     * must fail if a delete beat it by nulling field, and a delete
     * must return the last non-null value held in the field. (Note:
     * Null, rather than some special marker, is used for value fields
     * here because it just so happens to mesh with the Map API
     * requirement that method get returns null if there is no
     * mapping, which allows nodes to remain concurrently readable
     * even when deleted. Using any other marker value here would be
     * messy at best.)
     *
     * Here's the sequence of events for a deletion of node n with
     * predecessor b and successor f, initially:
     *
     *        +------+       +------+      +------+
     *   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...
     *        +------+       +------+      +------+
     *
     * 1. CAS n's value field from non-null to null.
     *    From this point on, no public operations encountering
     *    the node consider this mapping to exist. However, other
     *    ongoing insertions and deletions might still modify
     *    n's next pointer.
     *
     * 2. CAS n's next pointer to point to a new marker node.
     *    From this point on, no other nodes can be appended to n.
     *    which avoids deletion errors in CAS-based linked lists.
     *
     *        +------+       +------+      +------+       +------+
     *   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...
     *        +------+       +------+      +------+       +------+
     *
     * 3. CAS b's next pointer over both n and its marker.
     *    From this point on, no new traversals will encounter n,
     *    and it can eventually be GCed.
     *        +------+                                    +------+
     *   ...  |   b  |-----------------------------------&gt;|   f  | ...
     *        +------+                                    +------+
     *
     * A failure at step 1 leads to simple retry due to a lost race
     * with another operation. Steps 2-3 can fail because some other
     * thread noticed during a traversal a node with null value and
     * helped out by marking and/or unlinking.  This helping-out
     * ensures that no thread can become stuck waiting for progress of
     * the deleting thread.  The use of marker nodes slightly
     * complicates helping-out code because traversals must track
     * consistent reads of up to four nodes (b, n, marker, f), not
     * just (b, n, f), although the next field of a marker is
     * immutable, and once a next field is CAS'ed to point to a
     * marker, it never again changes, so this requires less care.
     *
     * Skip lists add indexing to this scheme, so that the base-level
     * traversals start close to the locations being found, inserted
     * or deleted -- usually base level traversals only traverse a few
     * nodes. This doesn't change the basic algorithm except for the
     * need to make sure base traversals start at predecessors (here,
     * b) that are not (structurally) deleted, otherwise retrying
     * after processing the deletion.
     *
     * Index levels are maintained as lists with volatile next fields,
     * using CAS to link and unlink.  Races are allowed in index-list
     * operations that can (rarely) fail to link in a new index node
     * or delete one. (We can't do this of course for data nodes.)
     * However, even when this happens, the index lists remain sorted,
     * so correctly serve as indices.  This can impact performance,
     * but since skip lists are probabilistic anyway, the net result
     * is that under contention, the effective &quot;p&quot; value may be lower
     * than its nominal value. And race windows are kept small enough
     * that in practice these failures are rare, even under a lot of
     * contention.
     *
     * The fact that retries (for both base and index lists) are
     * relatively cheap due to indexing allows some minor
     * simplifications of retry logic. Traversal restarts are
     * performed after most &quot;helping-out&quot; CASes. This isn't always
     * strictly necessary, but the implicit backoffs tend to help
     * reduce other downstream failed CAS's enough to outweigh restart
     * cost.  This worsens the worst case, but seems to improve even
     * highly contended cases.
     *
     * Unlike most skip-list implementations, index insertion and
     * deletion here require a separate traversal pass occurring after
     * the base-level action, to add or remove index nodes.  This adds
     * to single-threaded overhead, but improves contended
     * multithreaded performance by narrowing interference windows,
     * and allows deletion to ensure that all index nodes will be made
     * unreachable upon return from a public remove operation, thus
     * avoiding unwanted garbage retention. This is more important
     * here than in some other data structures because we cannot null
     * out node fields referencing user keys since they might still be
     * read by other ongoing traversals.
     *
     * Indexing uses skip list parameters that maintain good search
     * performance while using sparser-than-usual indices: The
     * hardwired parameters k=1, p=0.5 (see method doPut) mean
     * that about one-quarter of the nodes have indices. Of those that
     * do, half have one level, a quarter have two, and so on (see
     * Pugh's Skip List Cookbook, sec 3.4).  The expected total space
     * requirement for a map is slightly less than for the current
     * implementation of java.util.TreeMap.
     *
     * Changing the level of the index (i.e, the height of the
     * tree-like structure) also uses CAS. The head index has initial
     * level/height of one. Creation of an index with height greater
     * than the current level adds a level to the head index by
     * CAS'ing on a new top-most head. To maintain good performance
     * after a lot of removals, deletion methods heuristically try to
     * reduce the height if the topmost levels appear to be empty.
     * This may encounter races in which it possible (but rare) to
     * reduce and &quot;lose&quot; a level just as it is about to contain an
     * index (that will then never be encountered). This does no
     * structural harm, and in practice appears to be a better option
     * than allowing unrestrained growth of levels.
     *
     * The code for all this is more verbose than you'd like. Most
     * operations entail locating an element (or position to insert an
     * element). The code to do this can't be nicely factored out
     * because subsequent uses require a snapshot of predecessor
     * and/or successor and/or value fields which can't be returned
     * all at once, at least not without creating yet another object
     * to hold them -- creating such little objects is an especially
     * bad idea for basic internal search operations because it adds
     * to GC overhead.  (This is one of the few times I've wished Java
     * had macros.) Instead, some traversal code is interleaved within
     * insertion and removal operations.  The control logic to handle
     * all the retry conditions is sometimes twisty. Most search is
     * broken into 2 parts. findPredecessor() searches index nodes
     * only, returning a base-level predecessor of the key. findNode()
     * finishes out the base-level search. Even with this factoring,
     * there is a fair amount of near-duplication of code to handle
     * variants.
     *
     * To produce random values without interference across threads,
     * we use within-JDK thread local random support (via the
     * &quot;secondary seed&quot;, to avoid interference with user-level
     * ThreadLocalRandom.)
     *
     * A previous version of this class wrapped non-comparable keys
     * with their comparators to emulate Comparables when using
     * comparators vs Comparables.  However, JVMs now appear to better
     * handle infusing comparator-vs-comparable choice into search
     * loops. Static method cpr(comparator, x, y) is used for all
     * comparisons, which works well as long as the comparator
     * argument is set up outside of loops (thus sometimes passed as
     * an argument to internal methods) to avoid field re-reads.
     *
     * For explanation of algorithms sharing at least a couple of
     * features with this one, see Mikhail Fomitchev's thesis
     * (http://www.cs.yorku.ca/~mikhail/), Keir Fraser's thesis
     * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell's
     * thesis (http://www.cs.chalmers.se/~phs/).
     *
     * Given the use of tree-like index nodes, you might wonder why
     * this doesn't use some kind of search tree instead, which would
     * support somewhat faster search operations. The reason is that
     * there are no known efficient lock-free insertion and deletion
     * algorithms for search trees. The immutability of the &quot;down&quot;
     * links of index nodes (as opposed to mutable &quot;left&quot; fields in
     * true trees) makes this tractable using only CAS operations.
     *
     * Notation guide for local variables
     * Node:         b, n, f    for  predecessor, node, successor
     * Index:        q, r, d    for index node, right, down.
     *               t          for another index node
     * Head:         h
     * Levels:       j
     * Keys:         k, key
     * Values:       v, value
     * Comparisons:  c
     */

    private static final long serialVersionUID = -8627078645895051609L;

    /**
     * Special value used to identify base-level header
     */
<span class="fc" id="L363">    private static final Object BASE_HEADER = new Object();</span>

    /**
     * The topmost head index of the skiplist.
     */
    private transient volatile HeadIndex&lt;K,V&gt; head;

    /**
     * The comparator used to maintain order in this map, or null if
     * using natural ordering.  (Non-private to simplify access in
     * nested classes.)
     * @serial
     */
    final Comparator&lt;? super K&gt; comparator;

    /** Lazily initialized key set */
    private transient KeySet&lt;K&gt; keySet;
    /** Lazily initialized entry set */
    private transient EntrySet&lt;K,V&gt; entrySet;
    /** Lazily initialized values collection */
    private transient Values&lt;V&gt; values;
    /** Lazily initialized descending key set */
    private transient ConcurrentNavigableMap&lt;K,V&gt; descendingMap;

    /**
     * Initializes or resets state. Needed by constructors, clone,
     * clear, readObject. and ConcurrentSkipListSet.clone.
     * (Note that comparator must be separately initialized.)
     */
    private void initialize() {
<span class="fc" id="L393">        keySet = null;</span>
<span class="fc" id="L394">        entrySet = null;</span>
<span class="fc" id="L395">        values = null;</span>
<span class="fc" id="L396">        descendingMap = null;</span>
<span class="fc" id="L397">        head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null),</span>
                                  null, null, 1);
<span class="fc" id="L399">    }</span>

    /**
     * compareAndSet head node
     */
    private boolean casHead(HeadIndex&lt;K,V&gt; cmp, HeadIndex&lt;K,V&gt; val) {
<span class="fc" id="L405">        return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);</span>
    }

    /* ---------------- Nodes -------------- */

    /**
     * Nodes hold keys and values, and are singly linked in sorted
     * order, possibly with some intervening marker nodes. The list is
     * headed by a dummy node accessible as head.node. The value field
     * is declared only as Object because it takes special non-V
     * values for marker and header nodes.
     */
    static final class Node&lt;K,V&gt; {
        final K key;
        volatile Object value;
        volatile Node&lt;K,V&gt; next;

        /**
         * Creates a new regular node.
         */
<span class="fc" id="L425">        Node(K key, Object value, Node&lt;K,V&gt; next) {</span>
<span class="fc" id="L426">            this.key = key;</span>
<span class="fc" id="L427">            this.value = value;</span>
<span class="fc" id="L428">            this.next = next;</span>
<span class="fc" id="L429">        }</span>

        /**
         * Creates a new marker node. A marker is distinguished by
         * having its value field point to itself.  Marker nodes also
         * have null keys, a fact that is exploited in a few places,
         * but this doesn't distinguish markers from the base-level
         * header node (head.node), which also has a null key.
         */
<span class="fc" id="L438">        Node(Node&lt;K,V&gt; next) {</span>
<span class="fc" id="L439">            this.key = null;</span>
<span class="fc" id="L440">            this.value = this;</span>
<span class="fc" id="L441">            this.next = next;</span>
<span class="fc" id="L442">        }</span>

        /**
         * compareAndSet value field
         */
        boolean casValue(Object cmp, Object val) {
<span class="fc" id="L448">            return UNSAFE.compareAndSwapObject(this, valueOffset, cmp, val);</span>
        }

        /**
         * compareAndSet next field
         */
        boolean casNext(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val) {
<span class="fc" id="L455">            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</span>
        }

        /**
         * Returns true if this node is a marker. This method isn't
         * actually called in any current code checking for markers
         * because callers will have already read value field and need
         * to use that read (not another done here) and so directly
         * test if value points to node.
         *
         * @return true if this node is a marker node
         */
        boolean isMarker() {
<span class="nc bnc" id="L468" title="All 2 branches missed.">            return value == this;</span>
        }

        /**
         * Returns true if this node is the header of base-level list.
         * @return true if this node is header node
         */
        boolean isBaseHeader() {
<span class="fc bfc" id="L476" title="All 2 branches covered.">            return value == BASE_HEADER;</span>
        }

        /**
         * Tries to append a deletion marker to this node.
         * @param f the assumed current successor of this node
         * @return true if successful
         */
        boolean appendMarker(Node&lt;K,V&gt; f) {
<span class="fc" id="L485">            return casNext(f, new Node&lt;K,V&gt;(f));</span>
        }

        /**
         * Helps out a deletion by appending marker or unlinking from
         * predecessor. This is called during traversals when value
         * field seen to be null.
         * @param b predecessor
         * @param f successor
         */
        void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) {
            /*
             * Rechecking links and then doing only one of the
             * help-out stages per call tends to minimize CAS
             * interference among helping threads.
             */
<span class="nc bnc" id="L501" title="All 4 branches missed.">            if (f == next &amp;&amp; this == b.next) {</span>
<span class="nc bnc" id="L502" title="All 4 branches missed.">                if (f == null || f.value != f) // not already marked</span>
<span class="nc" id="L503">                    casNext(f, new Node&lt;K,V&gt;(f));</span>
                else
<span class="nc" id="L505">                    b.casNext(this, f.next);</span>
            }
<span class="nc" id="L507">        }</span>

        /**
         * Returns value if this node contains a valid key-value pair,
         * else null.
         * @return this node's value if it isn't a marker or header or
         * is deleted, else null
         */
        V getValidValue() {
<span class="fc" id="L516">            Object v = value;</span>
<span class="pc bpc" id="L517" title="1 of 4 branches missed.">            if (v == this || v == BASE_HEADER)</span>
<span class="fc" id="L518">                return null;</span>
<span class="fc" id="L519">            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L520">            return vv;</span>
        }

        /**
         * Creates and returns a new SimpleImmutableEntry holding current
         * mapping if this node holds a valid value, else null.
         * @return new entry or null
         */
        AbstractMap.SimpleImmutableEntry&lt;K,V&gt; createSnapshot() {
<span class="fc" id="L529">            Object v = value;</span>
<span class="pc bpc" id="L530" title="3 of 6 branches missed.">            if (v == null || v == this || v == BASE_HEADER)</span>
<span class="nc" id="L531">                return null;</span>
<span class="fc" id="L532">            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L533">            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, vv);</span>
        }

        // UNSAFE mechanics

        private static final sun.misc.Unsafe UNSAFE;
        private static final long valueOffset;
        private static final long nextOffset;

        static {
            try {
<span class="fc" id="L544">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L545">                Class&lt;?&gt; k = Node.class;</span>
<span class="fc" id="L546">                valueOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L547">                    (k.getDeclaredField(&quot;value&quot;));</span>
<span class="fc" id="L548">                nextOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L549">                    (k.getDeclaredField(&quot;next&quot;));</span>
<span class="nc" id="L550">            } catch (Exception e) {</span>
<span class="nc" id="L551">                throw new Error(e);</span>
<span class="fc" id="L552">            }</span>
<span class="fc" id="L553">        }</span>
    }

    /* ---------------- Indexing -------------- */

    /**
     * Index nodes represent the levels of the skip list.  Note that
     * even though both Nodes and Indexes have forward-pointing
     * fields, they have different types and are handled in different
     * ways, that can't nicely be captured by placing field in a
     * shared abstract class.
     */
    static class Index&lt;K,V&gt; {
        final Node&lt;K,V&gt; node;
        final Index&lt;K,V&gt; down;
        volatile Index&lt;K,V&gt; right;

        /**
         * Creates index node with given values.
         */
<span class="fc" id="L573">        Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) {</span>
<span class="fc" id="L574">            this.node = node;</span>
<span class="fc" id="L575">            this.down = down;</span>
<span class="fc" id="L576">            this.right = right;</span>
<span class="fc" id="L577">        }</span>

        /**
         * compareAndSet right field
         */
        final boolean casRight(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val) {
<span class="fc" id="L583">            return UNSAFE.compareAndSwapObject(this, rightOffset, cmp, val);</span>
        }

        /**
         * Returns true if the node this indexes has been deleted.
         * @return true if indexed node is known to be deleted
         */
        final boolean indexesDeletedNode() {
<span class="fc bfc" id="L591" title="All 2 branches covered.">            return node.value == null;</span>
        }

        /**
         * Tries to CAS newSucc as successor.  To minimize races with
         * unlink that may lose this index node, if the node being
         * indexed is known to be deleted, it doesn't try to link in.
         * @param succ the expected current successor
         * @param newSucc the new successor
         * @return true if successful
         */
        final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) {
<span class="fc" id="L603">            Node&lt;K,V&gt; n = node;</span>
<span class="fc" id="L604">            newSucc.right = succ;</span>
<span class="pc bpc" id="L605" title="2 of 4 branches missed.">            return n.value != null &amp;&amp; casRight(succ, newSucc);</span>
        }

        /**
         * Tries to CAS right field to skip over apparent successor
         * succ.  Fails (forcing a retraversal by caller) if this node
         * is known to be deleted.
         * @param succ the expected current successor
         * @return true if successful
         */
        final boolean unlink(Index&lt;K,V&gt; succ) {
<span class="pc bpc" id="L616" title="2 of 4 branches missed.">            return node.value != null &amp;&amp; casRight(succ, succ.right);</span>
        }

        // Unsafe mechanics
        private static final sun.misc.Unsafe UNSAFE;
        private static final long rightOffset;
        static {
            try {
<span class="fc" id="L624">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L625">                Class&lt;?&gt; k = Index.class;</span>
<span class="fc" id="L626">                rightOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L627">                    (k.getDeclaredField(&quot;right&quot;));</span>
<span class="nc" id="L628">            } catch (Exception e) {</span>
<span class="nc" id="L629">                throw new Error(e);</span>
<span class="fc" id="L630">            }</span>
<span class="fc" id="L631">        }</span>
    }

    /* ---------------- Head nodes -------------- */

    /**
     * Nodes heading each level keep track of their level.
     */
    static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; {
        final int level;
        HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) {
<span class="fc" id="L642">            super(node, down, right);</span>
<span class="fc" id="L643">            this.level = level;</span>
<span class="fc" id="L644">        }</span>
    }

    /* ---------------- Comparison utilities -------------- */

    /**
     * Compares using comparator or natural ordering if null.
     * Called only by methods that have performed required type checks.
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    static final int cpr(Comparator c, Object x, Object y) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">        return (c != null) ? c.compare(x, y) : ((Comparable)x).compareTo(y);</span>
    }

    /* ---------------- Traversal -------------- */

    /**
     * Returns a base-level node with key strictly less than given key,
     * or the base-level header if there is no such node.  Also
     * unlinks indexes to deleted nodes found along the way.  Callers
     * rely on this side-effect of clearing indices to deleted nodes.
     * @param key the key
     * @return a predecessor of key
     */
    private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L670">            throw new NullPointerException(); // don't postpone errors</span>
        for (;;) {
<span class="fc" id="L672">            for (Index&lt;K,V&gt; q = head, r = q.right, d;;) {</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">                if (r != null) {</span>
<span class="fc" id="L674">                    Node&lt;K,V&gt; n = r.node;</span>
<span class="fc" id="L675">                    K k = n.key;</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                    if (n.value == null) {</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                        if (!q.unlink(r))</span>
<span class="nc" id="L678">                            break;           // restart</span>
<span class="fc" id="L679">                        r = q.right;         // reread r</span>
<span class="fc" id="L680">                        continue;</span>
                    }
<span class="fc bfc" id="L682" title="All 2 branches covered.">                    if (cpr(cmp, key, k) &gt; 0) {</span>
<span class="fc" id="L683">                        q = r;</span>
<span class="fc" id="L684">                        r = r.right;</span>
<span class="fc" id="L685">                        continue;</span>
                    }
                }
<span class="fc bfc" id="L688" title="All 2 branches covered.">                if ((d = q.down) == null)</span>
<span class="fc" id="L689">                    return q.node;</span>
<span class="fc" id="L690">                q = d;</span>
<span class="pc" id="L691">                r = d.right;</span>
            }
        }
    }

    /**
     * Returns node holding key or null if no such, clearing out any
     * deleted nodes seen along the way.  Repeatedly traverses at
     * base-level looking for key starting at predecessor returned
     * from findPredecessor, processing base-level deletions as
     * encountered. Some callers rely on this side-effect of clearing
     * deleted nodes.
     *
     * Restarts occur, at traversal step centered on node n, if:
     *
     *   (1) After reading n's next field, n is no longer assumed
     *       predecessor b's current successor, which means that
     *       we don't have a consistent 3-node snapshot and so cannot
     *       unlink any subsequent deleted nodes encountered.
     *
     *   (2) n's value field is null, indicating n is deleted, in
     *       which case we help out an ongoing structural deletion
     *       before retrying.  Even though there are cases where such
     *       unlinking doesn't require restart, they aren't sorted out
     *       here because doing so would not usually outweigh cost of
     *       restarting.
     *
     *   (3) n is a marker or n's predecessor's value field is null,
     *       indicating (among other possibilities) that
     *       findPredecessor returned a deleted node. We can't unlink
     *       the node because we don't know its predecessor, so rely
     *       on another call to findPredecessor to notice and return
     *       some earlier predecessor, which it will do. This check is
     *       only strictly needed at beginning of loop, (and the
     *       b.value check isn't strictly needed at all) but is done
     *       each iteration to help avoid contention with other
     *       threads by callers that will fail to be able to change
     *       links, and so will retry anyway.
     *
     * The traversal loops in doPut, doRemove, and findNear all
     * include the same three kinds of checks. And specialized
     * versions appear in findFirst, and findLast and their
     * variants. They can't easily share code because each uses the
     * reads of fields held in locals occurring in the orders they
     * were performed.
     *
     * @param key the key
     * @return node holding key, or null if no such
     */
    private Node&lt;K,V&gt; findNode(Object key) {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L742">            throw new NullPointerException(); // don't postpone errors</span>
<span class="fc" id="L743">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        outer: for (;;) {
<span class="fc" id="L745">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</span>
                Object v; int c;
<span class="fc bfc" id="L747" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc" id="L748">                    break outer;</span>
<span class="fc" id="L749">                Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">                if (n != b.next)                // inconsistent read</span>
<span class="nc" id="L751">                    break;</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">                if ((v = n.value) == null) {    // n is deleted</span>
<span class="nc" id="L753">                    n.helpDelete(b, f);</span>
<span class="nc" id="L754">                    break;</span>
                }
<span class="pc bpc" id="L756" title="2 of 4 branches missed.">                if (b.value == null || v == n)  // b is deleted</span>
<span class="nc" id="L757">                    break;</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">                if ((c = cpr(cmp, key, n.key)) == 0)</span>
<span class="fc" id="L759">                    return n;</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">                if (c &lt; 0)</span>
<span class="nc" id="L761">                    break outer;</span>
<span class="fc" id="L762">                b = n;</span>
<span class="fc" id="L763">                n = f;</span>
<span class="pc" id="L764">            }</span>
        }
<span class="fc" id="L766">        return null;</span>
    }

    /**
     * Gets value for key. Almost the same as findNode, but returns
     * the found value (to avoid retries during re-reads)
     *
     * @param key the key
     * @return the value, or null if absent
     */
    private V doGet(Object key) {
<span class="fc bfc" id="L777" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L778">            throw new NullPointerException();</span>
<span class="fc" id="L779">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        outer: for (;;) {
<span class="fc" id="L781">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</span>
                Object v; int c;
<span class="fc bfc" id="L783" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc" id="L784">                    break outer;</span>
<span class="fc" id="L785">                Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">                if (n != b.next)                // inconsistent read</span>
<span class="nc" id="L787">                    break;</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">                if ((v = n.value) == null) {    // n is deleted</span>
<span class="nc" id="L789">                    n.helpDelete(b, f);</span>
<span class="nc" id="L790">                    break;</span>
                }
<span class="pc bpc" id="L792" title="2 of 4 branches missed.">                if (b.value == null || v == n)  // b is deleted</span>
<span class="nc" id="L793">                    break;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">                if ((c = cpr(cmp, key, n.key)) == 0) {</span>
<span class="fc" id="L795">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L796">                    return vv;</span>
                }
<span class="fc bfc" id="L798" title="All 2 branches covered.">                if (c &lt; 0)</span>
<span class="fc" id="L799">                    break outer;</span>
<span class="fc" id="L800">                b = n;</span>
<span class="fc" id="L801">                n = f;</span>
<span class="pc" id="L802">            }</span>
        }
<span class="fc" id="L804">        return null;</span>
    }

    /* ---------------- Insertion -------------- */

    /**
     * Main insertion method.  Adds element if not present, or
     * replaces value if present and onlyIfAbsent is false.
     * @param key the key
     * @param value the value that must be associated with key
     * @param onlyIfAbsent if should not insert if already present
     * @return the old value, or null if newly inserted
     */
    private V doPut(K key, V value, boolean onlyIfAbsent) {
        Node&lt;K,V&gt; z;             // added node
<span class="fc bfc" id="L819" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L820">            throw new NullPointerException();</span>
<span class="fc" id="L821">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        outer: for (;;) {
<span class="fc" id="L823">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">                if (n != null) {</span>
                    Object v; int c;
<span class="fc" id="L826">                    Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                    if (n != b.next)               // inconsistent read</span>
<span class="nc" id="L828">                        break;</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">                    if ((v = n.value) == null) {   // n is deleted</span>
<span class="nc" id="L830">                        n.helpDelete(b, f);</span>
<span class="nc" id="L831">                        break;</span>
                    }
<span class="pc bpc" id="L833" title="2 of 4 branches missed.">                    if (b.value == null || v == n) // b is deleted</span>
<span class="nc" id="L834">                        break;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">                    if ((c = cpr(cmp, key, n.key)) &gt; 0) {</span>
<span class="fc" id="L836">                        b = n;</span>
<span class="fc" id="L837">                        n = f;</span>
<span class="fc" id="L838">                        continue;</span>
                    }
<span class="fc bfc" id="L840" title="All 2 branches covered.">                    if (c == 0) {</span>
<span class="pc bpc" id="L841" title="1 of 4 branches missed.">                        if (onlyIfAbsent || n.casValue(v, value)) {</span>
<span class="fc" id="L842">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L843">                            return vv;</span>
                        }
                        break; // restart if lost race to replace value
                    }
                    // else c &lt; 0; fall through
                }

<span class="fc" id="L850">                z = new Node&lt;K,V&gt;(key, value, n);</span>
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">                if (!b.casNext(n, z))</span>
<span class="nc" id="L852">                    break;         // restart if lost race to append to b</span>
                break outer;
            }
        }

<span class="fc" id="L857">        int rnd = ThreadLocalRandom.nextSecondarySeed();</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if ((rnd &amp; 0x80000001) == 0) { // test highest and lowest bits</span>
<span class="fc" id="L859">            int level = 1, max;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</span>
<span class="fc" id="L861">                ++level;</span>
<span class="fc" id="L862">            Index&lt;K,V&gt; idx = null;</span>
<span class="fc" id="L863">            HeadIndex&lt;K,V&gt; h = head;</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">            if (level &lt;= (max = h.level)) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">                for (int i = 1; i &lt;= level; ++i)</span>
<span class="fc" id="L866">                    idx = new Index&lt;K,V&gt;(z, idx, null);</span>
            }
            else { // try to grow by one level
<span class="fc" id="L869">                level = max + 1; // hold in array and later pick the one to use</span>
<span class="fc" id="L870">                @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</span>
                    (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];
<span class="fc bfc" id="L872" title="All 2 branches covered.">                for (int i = 1; i &lt;= level; ++i)</span>
<span class="fc" id="L873">                    idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</span>
                for (;;) {
<span class="fc" id="L875">                    h = head;</span>
<span class="fc" id="L876">                    int oldLevel = h.level;</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">                    if (level &lt;= oldLevel) // lost race to add level</span>
<span class="nc" id="L878">                        break;</span>
<span class="fc" id="L879">                    HeadIndex&lt;K,V&gt; newh = h;</span>
<span class="fc" id="L880">                    Node&lt;K,V&gt; oldbase = h.node;</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                    for (int j = oldLevel+1; j &lt;= level; ++j)</span>
<span class="fc" id="L882">                        newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">                    if (casHead(h, newh)) {</span>
<span class="fc" id="L884">                        h = newh;</span>
<span class="fc" id="L885">                        idx = idxs[level = oldLevel];</span>
<span class="fc" id="L886">                        break;</span>
                    }
<span class="nc" id="L888">                }</span>
            }
            // find insertion points and splice in
<span class="fc" id="L891">            splice: for (int insertionLevel = level;;) {</span>
<span class="fc" id="L892">                int j = h.level;</span>
<span class="fc" id="L893">                for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) {</span>
<span class="pc bpc" id="L894" title="2 of 4 branches missed.">                    if (q == null || t == null)</span>
<span class="nc" id="L895">                        break splice;</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                    if (r != null) {</span>
<span class="fc" id="L897">                        Node&lt;K,V&gt; n = r.node;</span>
                        // compare before deletion check avoids needing recheck
<span class="fc" id="L899">                        int c = cpr(cmp, key, n.key);</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">                        if (n.value == null) {</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                            if (!q.unlink(r))</span>
<span class="nc" id="L902">                                break;</span>
<span class="nc" id="L903">                            r = q.right;</span>
<span class="nc" id="L904">                            continue;</span>
                        }
<span class="fc bfc" id="L906" title="All 2 branches covered.">                        if (c &gt; 0) {</span>
<span class="fc" id="L907">                            q = r;</span>
<span class="fc" id="L908">                            r = r.right;</span>
<span class="fc" id="L909">                            continue;</span>
                        }
                    }

<span class="fc bfc" id="L913" title="All 2 branches covered.">                    if (j == insertionLevel) {</span>
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">                        if (!q.link(r, t))</span>
<span class="nc" id="L915">                            break; // restart</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">                        if (t.node.value == null) {</span>
<span class="nc" id="L917">                            findNode(key);</span>
<span class="nc" id="L918">                            break splice;</span>
                        }
<span class="fc bfc" id="L920" title="All 2 branches covered.">                        if (--insertionLevel == 0)</span>
<span class="fc" id="L921">                            break splice;</span>
                    }

<span class="pc bpc" id="L924" title="1 of 4 branches missed.">                    if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span>
<span class="fc" id="L925">                        t = t.down;</span>
<span class="fc" id="L926">                    q = q.down;</span>
<span class="fc" id="L927">                    r = q.right;</span>
                }
<span class="nc" id="L929">            }</span>
        }
<span class="fc" id="L931">        return null;</span>
    }

    /* ---------------- Deletion -------------- */

    /**
     * Main deletion method. Locates node, nulls value, appends a
     * deletion marker, unlinks predecessor, removes associated index
     * nodes, and possibly reduces head index level.
     *
     * Index nodes are cleared out simply by calling findPredecessor.
     * which unlinks indexes to deleted nodes found along path to key,
     * which will include the indexes to this node.  This is done
     * unconditionally. We can't check beforehand whether there are
     * index nodes because it might be the case that some or all
     * indexes hadn't been inserted yet for this node during initial
     * search for it, and we'd like to ensure lack of garbage
     * retention, so must call to be sure.
     *
     * @param key the key
     * @param value if non-null, the value that must be
     * associated with key
     * @return the node, or null if not found
     */
    final V doRemove(Object key, Object value) {
<span class="fc bfc" id="L956" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L957">            throw new NullPointerException();</span>
<span class="fc" id="L958">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        outer: for (;;) {
<span class="fc" id="L960">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</span>
                Object v; int c;
<span class="fc bfc" id="L962" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc" id="L963">                    break outer;</span>
<span class="fc" id="L964">                Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">                if (n != b.next)                    // inconsistent read</span>
<span class="nc" id="L966">                    break;</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">                if ((v = n.value) == null) {        // n is deleted</span>
<span class="nc" id="L968">                    n.helpDelete(b, f);</span>
<span class="nc" id="L969">                    break;</span>
                }
<span class="pc bpc" id="L971" title="2 of 4 branches missed.">                if (b.value == null || v == n)      // b is deleted</span>
<span class="nc" id="L972">                    break;</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">                if ((c = cpr(cmp, key, n.key)) &lt; 0)</span>
<span class="fc" id="L974">                    break outer;</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                if (c &gt; 0) {</span>
<span class="fc" id="L976">                    b = n;</span>
<span class="fc" id="L977">                    n = f;</span>
<span class="fc" id="L978">                    continue;</span>
                }
<span class="fc bfc" id="L980" title="All 4 branches covered.">                if (value != null &amp;&amp; !value.equals(v))</span>
<span class="fc" id="L981">                    break outer;</span>
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">                if (!n.casValue(v, null))</span>
<span class="nc" id="L983">                    break;</span>
<span class="pc bpc" id="L984" title="2 of 4 branches missed.">                if (!n.appendMarker(f) || !b.casNext(n, f))</span>
<span class="nc" id="L985">                    findNode(key);                  // retry via findNode</span>
                else {
<span class="fc" id="L987">                    findPredecessor(key, cmp);      // clean index</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">                    if (head.right == null)</span>
<span class="fc" id="L989">                        tryReduceLevel();</span>
                }
<span class="fc" id="L991">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="pc" id="L992">                return vv;</span>
            }
        }
<span class="fc" id="L995">        return null;</span>
    }

    /**
     * Possibly reduce head level if it has no nodes.  This method can
     * (rarely) make mistakes, in which case levels can disappear even
     * though they are about to contain index nodes. This impacts
     * performance, not correctness.  To minimize mistakes as well as
     * to reduce hysteresis, the level is reduced by one only if the
     * topmost three levels look empty. Also, if the removed level
     * looks non-empty after CAS, we try to change it back quick
     * before anyone notices our mistake! (This trick works pretty
     * well because this method will practically never make mistakes
     * unless current thread stalls immediately before first CAS, in
     * which case it is very unlikely to stall again immediately
     * afterwards, so will recover.)
     *
     * We put up with all this rather than just let levels grow
     * because otherwise, even a small map that has undergone a large
     * number of insertions and removals will have a lot of levels,
     * slowing down access more than would an occasional unwanted
     * reduction.
     */
    private void tryReduceLevel() {
<span class="fc" id="L1019">        HeadIndex&lt;K,V&gt; h = head;</span>
        HeadIndex&lt;K,V&gt; d;
        HeadIndex&lt;K,V&gt; e;
<span class="pc bpc" id="L1022" title="5 of 12 branches missed.">        if (h.level &gt; 3 &amp;&amp;</span>
            (d = (HeadIndex&lt;K,V&gt;)h.down) != null &amp;&amp;
            (e = (HeadIndex&lt;K,V&gt;)d.down) != null &amp;&amp;
            e.right == null &amp;&amp;
            d.right == null &amp;&amp;
            h.right == null &amp;&amp;
<span class="pc bpc" id="L1028" title="2 of 4 branches missed.">            casHead(h, d) &amp;&amp; // try to set</span>
            h.right != null) // recheck
<span class="nc" id="L1030">            casHead(d, h);   // try to backout</span>
<span class="fc" id="L1031">    }</span>

    /* ---------------- Finding and removing first element -------------- */

    /**
     * Specialized variant of findNode to get first valid node.
     * @return first node or null if empty
     */
    final Node&lt;K,V&gt; findFirst() {
        for (Node&lt;K,V&gt; b, n;;) {
<span class="fc bfc" id="L1041" title="All 2 branches covered.">            if ((n = (b = head.node).next) == null)</span>
<span class="fc" id="L1042">                return null;</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">            if (n.value != null)</span>
<span class="fc" id="L1044">                return n;</span>
<span class="nc" id="L1045">            n.helpDelete(b, n.next);</span>
        }
    }

    /**
     * Removes first entry; returns its snapshot.
     * @return null if empty, else snapshot of first entry
     */
    private Map.Entry&lt;K,V&gt; doRemoveFirstEntry() {
        for (Node&lt;K,V&gt; b, n;;) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if ((n = (b = head.node).next) == null)</span>
<span class="fc" id="L1056">                return null;</span>
<span class="fc" id="L1057">            Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">            if (n != b.next)</span>
<span class="nc" id="L1059">                continue;</span>
<span class="fc" id="L1060">            Object v = n.value;</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">            if (v == null) {</span>
<span class="nc" id="L1062">                n.helpDelete(b, f);</span>
<span class="nc" id="L1063">                continue;</span>
            }
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">            if (!n.casValue(v, null))</span>
<span class="nc" id="L1066">                continue;</span>
<span class="pc bpc" id="L1067" title="2 of 4 branches missed.">            if (!n.appendMarker(f) || !b.casNext(n, f))</span>
<span class="nc" id="L1068">                findFirst(); // retry</span>
<span class="fc" id="L1069">            clearIndexToFirst();</span>
<span class="fc" id="L1070">            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L1071">            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, vv);</span>
        }
    }

    /**
     * Clears out index nodes associated with deleted first entry.
     */
    private void clearIndexToFirst() {
        for (;;) {
<span class="fc" id="L1080">            for (Index&lt;K,V&gt; q = head;;) {</span>
<span class="fc" id="L1081">                Index&lt;K,V&gt; r = q.right;</span>
<span class="pc bpc" id="L1082" title="1 of 6 branches missed.">                if (r != null &amp;&amp; r.indexesDeletedNode() &amp;&amp; !q.unlink(r))</span>
<span class="nc" id="L1083">                    break;</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">                if ((q = q.down) == null) {</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">                    if (head.right == null)</span>
<span class="fc" id="L1086">                        tryReduceLevel();</span>
<span class="fc" id="L1087">                    return;</span>
                }
<span class="pc" id="L1089">            }</span>
        }
    }

    /**
     * Removes last entry; returns its snapshot.
     * Specialized variant of doRemove.
     * @return null if empty, else snapshot of last entry
     */
    private Map.Entry&lt;K,V&gt; doRemoveLastEntry() {
        for (;;) {
<span class="fc" id="L1100">            Node&lt;K,V&gt; b = findPredecessorOfLast();</span>
<span class="fc" id="L1101">            Node&lt;K,V&gt; n = b.next;</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">            if (n == null) {</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">                if (b.isBaseHeader())               // empty</span>
<span class="fc" id="L1104">                    return null;</span>
                else
                    continue; // all b's successors are deleted; retry
            }
            for (;;) {
<span class="fc" id="L1109">                Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">                if (n != b.next)                    // inconsistent read</span>
<span class="nc" id="L1111">                    break;</span>
<span class="fc" id="L1112">                Object v = n.value;</span>
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">                if (v == null) {                    // n is deleted</span>
<span class="nc" id="L1114">                    n.helpDelete(b, f);</span>
<span class="nc" id="L1115">                    break;</span>
                }
<span class="pc bpc" id="L1117" title="2 of 4 branches missed.">                if (b.value == null || v == n)      // b is deleted</span>
<span class="nc" id="L1118">                    break;</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">                if (f != null) {</span>
<span class="fc" id="L1120">                    b = n;</span>
<span class="fc" id="L1121">                    n = f;</span>
<span class="fc" id="L1122">                    continue;</span>
                }
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">                if (!n.casValue(v, null))</span>
<span class="nc" id="L1125">                    break;</span>
<span class="fc" id="L1126">                K key = n.key;</span>
<span class="pc bpc" id="L1127" title="2 of 4 branches missed.">                if (!n.appendMarker(f) || !b.casNext(n, f))</span>
<span class="nc" id="L1128">                    findNode(key);                  // retry via findNode</span>
                else {                              // clean index
<span class="fc" id="L1130">                    findPredecessor(key, comparator);</span>
<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">                    if (head.right == null)</span>
<span class="nc" id="L1132">                        tryReduceLevel();</span>
                }
<span class="fc" id="L1134">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L1135">                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(key, vv);</span>
            }
<span class="nc" id="L1137">        }</span>
    }

    /* ---------------- Finding and removing last element -------------- */

    /**
     * Specialized version of find to get last valid node.
     * @return last node or null if empty
     */
    final Node&lt;K,V&gt; findLast() {
        /*
         * findPredecessor can't be used to traverse index level
         * because this doesn't use comparisons.  So traversals of
         * both levels are folded together.
         */
<span class="fc" id="L1152">        Index&lt;K,V&gt; q = head;</span>
        for (;;) {
            Index&lt;K,V&gt; d, r;
<span class="fc bfc" id="L1155" title="All 2 branches covered.">            if ((r = q.right) != null) {</span>
<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">                if (r.indexesDeletedNode()) {</span>
<span class="nc" id="L1157">                    q.unlink(r);</span>
<span class="nc" id="L1158">                    q = head; // restart</span>
                }
                else
<span class="fc" id="L1161">                    q = r;</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">            } else if ((d = q.down) != null) {</span>
<span class="fc" id="L1163">                q = d;</span>
            } else {
<span class="fc" id="L1165">                for (Node&lt;K,V&gt; b = q.node, n = b.next;;) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">                    if (n == null)</span>
<span class="fc bfc" id="L1167" title="All 2 branches covered.">                        return b.isBaseHeader() ? null : b;</span>
<span class="fc" id="L1168">                    Node&lt;K,V&gt; f = n.next;            // inconsistent read</span>
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">                    if (n != b.next)</span>
<span class="nc" id="L1170">                        break;</span>
<span class="fc" id="L1171">                    Object v = n.value;</span>
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">                    if (v == null) {                 // n is deleted</span>
<span class="nc" id="L1173">                        n.helpDelete(b, f);</span>
<span class="nc" id="L1174">                        break;</span>
                    }
<span class="pc bpc" id="L1176" title="2 of 4 branches missed.">                    if (b.value == null || v == n)      // b is deleted</span>
<span class="nc" id="L1177">                        break;</span>
<span class="fc" id="L1178">                    b = n;</span>
<span class="fc" id="L1179">                    n = f;</span>
<span class="fc" id="L1180">                }</span>
<span class="nc" id="L1181">                q = head; // restart</span>
            }
<span class="fc" id="L1183">        }</span>
    }

    /**
     * Specialized variant of findPredecessor to get predecessor of last
     * valid node.  Needed when removing the last entry.  It is possible
     * that all successors of returned node will have been deleted upon
     * return, in which case this method can be retried.
     * @return likely predecessor of last node
     */
    private Node&lt;K,V&gt; findPredecessorOfLast() {
        for (;;) {
<span class="fc" id="L1195">            for (Index&lt;K,V&gt; q = head;;) {</span>
                Index&lt;K,V&gt; d, r;
<span class="fc bfc" id="L1197" title="All 2 branches covered.">                if ((r = q.right) != null) {</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">                    if (r.indexesDeletedNode()) {</span>
<span class="nc" id="L1199">                        q.unlink(r);</span>
<span class="nc" id="L1200">                        break;    // must restart</span>
                    }
                    // proceed as far across as possible without overshooting
<span class="fc bfc" id="L1203" title="All 2 branches covered.">                    if (r.node.next != null) {</span>
<span class="fc" id="L1204">                        q = r;</span>
<span class="fc" id="L1205">                        continue;</span>
                    }
                }
<span class="fc bfc" id="L1208" title="All 2 branches covered.">                if ((d = q.down) != null)</span>
<span class="fc" id="L1209">                    q = d;</span>
                else
<span class="fc" id="L1211">                    return q.node;</span>
<span class="pc" id="L1212">            }</span>
        }
    }

    /* ---------------- Relational operations -------------- */

    // Control values OR'ed as arguments to findNear

    private static final int EQ = 1;
    private static final int LT = 2;
    private static final int GT = 0; // Actually checked as !LT

    /**
     * Utility for ceiling, floor, lower, higher methods.
     * @param key the key
     * @param rel the relation -- OR'ed combination of EQ, LT, GT
     * @return nearest node fitting relation, or null if no such
     */
    final Node&lt;K,V&gt; findNear(K key, int rel, Comparator&lt;? super K&gt; cmp) {
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L1232">            throw new NullPointerException();</span>
        for (;;) {
<span class="fc" id="L1234">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) {</span>
                Object v;
<span class="fc bfc" id="L1236" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc bfc" id="L1237" title="All 4 branches covered.">                    return ((rel &amp; LT) == 0 || b.isBaseHeader()) ? null : b;</span>
<span class="fc" id="L1238">                Node&lt;K,V&gt; f = n.next;</span>
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">                if (n != b.next)                  // inconsistent read</span>
<span class="nc" id="L1240">                    break;</span>
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">                if ((v = n.value) == null) {      // n is deleted</span>
<span class="nc" id="L1242">                    n.helpDelete(b, f);</span>
<span class="nc" id="L1243">                    break;</span>
                }
<span class="pc bpc" id="L1245" title="2 of 4 branches missed.">                if (b.value == null || v == n)      // b is deleted</span>
<span class="nc" id="L1246">                    break;</span>
<span class="fc" id="L1247">                int c = cpr(cmp, key, n.key);</span>
<span class="fc bfc" id="L1248" title="All 8 branches covered.">                if ((c == 0 &amp;&amp; (rel &amp; EQ) != 0) ||</span>
                    (c &lt;  0 &amp;&amp; (rel &amp; LT) == 0))
<span class="fc" id="L1250">                    return n;</span>
<span class="fc bfc" id="L1251" title="All 4 branches covered.">                if ( c &lt;= 0 &amp;&amp; (rel &amp; LT) != 0)</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">                    return b.isBaseHeader() ? null : b;</span>
<span class="fc" id="L1253">                b = n;</span>
<span class="fc" id="L1254">                n = f;</span>
<span class="pc" id="L1255">            }</span>
        }
    }

    /**
     * Returns SimpleImmutableEntry for results of findNear.
     * @param key the key
     * @param rel the relation -- OR'ed combination of EQ, LT, GT
     * @return Entry fitting relation, or null if no such
     */
    final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; getNear(K key, int rel) {
<span class="fc" id="L1266">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        for (;;) {
<span class="fc" id="L1268">            Node&lt;K,V&gt; n = findNear(key, rel, cmp);</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">            if (n == null)</span>
<span class="fc" id="L1270">                return null;</span>
<span class="fc" id="L1271">            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">            if (e != null)</span>
<span class="fc" id="L1273">                return e;</span>
<span class="nc" id="L1274">        }</span>
    }

    /* ---------------- Constructors -------------- */

    /**
     * Constructs a new, empty map, sorted according to the
     * {@linkplain Comparable natural ordering} of the keys.
     */
<span class="fc" id="L1283">    public ConcurrentSkipListMap() {</span>
<span class="fc" id="L1284">        this.comparator = null;</span>
<span class="fc" id="L1285">        initialize();</span>
<span class="fc" id="L1286">    }</span>

    /**
     * Constructs a new, empty map, sorted according to the specified
     * comparator.
     *
     * @param comparator the comparator that will be used to order this map.
     *        If {@code null}, the {@linkplain Comparable natural
     *        ordering} of the keys will be used.
     */
<span class="fc" id="L1296">    public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) {</span>
<span class="fc" id="L1297">        this.comparator = comparator;</span>
<span class="fc" id="L1298">        initialize();</span>
<span class="fc" id="L1299">    }</span>

    /**
     * Constructs a new map containing the same mappings as the given map,
     * sorted according to the {@linkplain Comparable natural ordering} of
     * the keys.
     *
     * @param  m the map whose mappings are to be placed in this map
     * @throws ClassCastException if the keys in {@code m} are not
     *         {@link Comparable}, or are not mutually comparable
     * @throws NullPointerException if the specified map or any of its keys
     *         or values are null
     */
<span class="fc" id="L1312">    public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) {</span>
<span class="fc" id="L1313">        this.comparator = null;</span>
<span class="fc" id="L1314">        initialize();</span>
<span class="fc" id="L1315">        putAll(m);</span>
<span class="fc" id="L1316">    }</span>

    /**
     * Constructs a new map containing the same mappings and using the
     * same ordering as the specified sorted map.
     *
     * @param m the sorted map whose mappings are to be placed in this
     *        map, and whose comparator is to be used to sort this map
     * @throws NullPointerException if the specified sorted map or any of
     *         its keys or values are null
     */
<span class="nc" id="L1327">    public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {</span>
<span class="nc" id="L1328">        this.comparator = m.comparator();</span>
<span class="nc" id="L1329">        initialize();</span>
<span class="nc" id="L1330">        buildFromSorted(m);</span>
<span class="nc" id="L1331">    }</span>

    /**
     * Returns a shallow copy of this {@code ConcurrentSkipListMap}
     * instance. (The keys and values themselves are not cloned.)
     *
     * @return a shallow copy of this map
     */
    public ConcurrentSkipListMap&lt;K,V&gt; clone() {
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1342">            ConcurrentSkipListMap&lt;K,V&gt; clone =</span>
<span class="nc" id="L1343">                (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();</span>
<span class="nc" id="L1344">            clone.initialize();</span>
<span class="nc" id="L1345">            clone.buildFromSorted(this);</span>
<span class="nc" id="L1346">            return clone;</span>
<span class="nc" id="L1347">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L1348">            throw new InternalError();</span>
        }
    }

    /**
     * Streamlined bulk insertion to initialize from elements of
     * given sorted map.  Call only from constructor or clone
     * method.
     */
    private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {
<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (map == null)</span>
<span class="nc" id="L1359">            throw new NullPointerException();</span>

<span class="nc" id="L1361">        HeadIndex&lt;K,V&gt; h = head;</span>
<span class="nc" id="L1362">        Node&lt;K,V&gt; basepred = h.node;</span>

        // Track the current rightmost node at each level. Uses an
        // ArrayList to avoid committing to initial or maximum level.
<span class="nc" id="L1366">        ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;();</span>

        // initialize
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        for (int i = 0; i &lt;= h.level; ++i)</span>
<span class="nc" id="L1370">            preds.add(null);</span>
<span class="nc" id="L1371">        Index&lt;K,V&gt; q = h;</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">        for (int i = h.level; i &gt; 0; --i) {</span>
<span class="nc" id="L1373">            preds.set(i, q);</span>
<span class="nc" id="L1374">            q = q.down;</span>
        }

<span class="nc" id="L1377">        Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =</span>
<span class="nc" id="L1378">            map.entrySet().iterator();</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1380">            Map.Entry&lt;? extends K, ? extends V&gt; e = it.next();</span>
<span class="nc" id="L1381">            int rnd = ThreadLocalRandom.current().nextInt();</span>
<span class="nc" id="L1382">            int j = 0;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">            if ((rnd &amp; 0x80000001) == 0) {</span>
                do {
<span class="nc" id="L1385">                    ++j;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                } while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0);</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                if (j &gt; h.level) j = h.level + 1;</span>
            }
<span class="nc" id="L1389">            K k = e.getKey();</span>
<span class="nc" id="L1390">            V v = e.getValue();</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">            if (k == null || v == null)</span>
<span class="nc" id="L1392">                throw new NullPointerException();</span>
<span class="nc" id="L1393">            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);</span>
<span class="nc" id="L1394">            basepred.next = z;</span>
<span class="nc" id="L1395">            basepred = z;</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">            if (j &gt; 0) {</span>
<span class="nc" id="L1397">                Index&lt;K,V&gt; idx = null;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                for (int i = 1; i &lt;= j; ++i) {</span>
<span class="nc" id="L1399">                    idx = new Index&lt;K,V&gt;(z, idx, null);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                    if (i &gt; h.level)</span>
<span class="nc" id="L1401">                        h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i);</span>

<span class="nc bnc" id="L1403" title="All 2 branches missed.">                    if (i &lt; preds.size()) {</span>
<span class="nc" id="L1404">                        preds.get(i).right = idx;</span>
<span class="nc" id="L1405">                        preds.set(i, idx);</span>
                    } else
<span class="nc" id="L1407">                        preds.add(idx);</span>
                }
            }
<span class="nc" id="L1410">        }</span>
<span class="nc" id="L1411">        head = h;</span>
<span class="nc" id="L1412">    }</span>

    /* ---------------- Serialization -------------- */

    /**
     * Saves this map to a stream (that is, serializes it).
     *
     * @param s the stream
     * @throws java.io.IOException if an I/O error occurs
     * @serialData The key (Object) and value (Object) for each
     * key-value mapping represented by the map, followed by
     * {@code null}. The key-value mappings are emitted in key-order
     * (as determined by the Comparator, or by the keys' natural
     * ordering if no Comparator).
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out the Comparator and any hidden stuff
<span class="fc" id="L1430">        s.defaultWriteObject();</span>

        // Write out keys and values (alternating)
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</span>
<span class="fc" id="L1434">            V v = n.getValidValue();</span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">            if (v != null) {</span>
<span class="fc" id="L1436">                s.writeObject(n.key);</span>
<span class="fc" id="L1437">                s.writeObject(v);</span>
            }
        }
<span class="fc" id="L1440">        s.writeObject(null);</span>
<span class="fc" id="L1441">    }</span>

    /**
     * Reconstitutes this map from a stream (that is, deserializes it).
     * @param s the stream
     * @throws ClassNotFoundException if the class of a serialized object
     *         could not be found
     * @throws java.io.IOException if an I/O error occurs
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(final java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in the Comparator and any hidden stuff
<span class="fc" id="L1454">        s.defaultReadObject();</span>
        // Reset transients
<span class="fc" id="L1456">        initialize();</span>

        /*
         * This is nearly identical to buildFromSorted, but is
         * distinct because readObject calls can't be nicely adapted
         * as the kind of iterator needed by buildFromSorted. (They
         * can be, but doing so requires type cheats and/or creation
         * of adaptor classes.) It is simpler to just adapt the code.
         */

<span class="fc" id="L1466">        HeadIndex&lt;K,V&gt; h = head;</span>
<span class="fc" id="L1467">        Node&lt;K,V&gt; basepred = h.node;</span>
<span class="fc" id="L1468">        ArrayList&lt;Index&lt;K,V&gt;&gt; preds = new ArrayList&lt;Index&lt;K,V&gt;&gt;();</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">        for (int i = 0; i &lt;= h.level; ++i)</span>
<span class="fc" id="L1470">            preds.add(null);</span>
<span class="fc" id="L1471">        Index&lt;K,V&gt; q = h;</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">        for (int i = h.level; i &gt; 0; --i) {</span>
<span class="fc" id="L1473">            preds.set(i, q);</span>
<span class="fc" id="L1474">            q = q.down;</span>
        }

        for (;;) {
<span class="fc" id="L1478">            Object k = s.readObject();</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">            if (k == null)</span>
<span class="fc" id="L1480">                break;</span>
<span class="fc" id="L1481">            Object v = s.readObject();</span>
<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">            if (v == null)</span>
<span class="nc" id="L1483">                throw new NullPointerException();</span>
<span class="fc" id="L1484">            K key = (K) k;</span>
<span class="fc" id="L1485">            V val = (V) v;</span>
<span class="fc" id="L1486">            int rnd = ThreadLocalRandom.current().nextInt();</span>
<span class="fc" id="L1487">            int j = 0;</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">            if ((rnd &amp; 0x80000001) == 0) {</span>
                do {
<span class="fc" id="L1490">                    ++j;</span>
<span class="fc bfc" id="L1491" title="All 2 branches covered.">                } while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0);</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">                if (j &gt; h.level) j = h.level + 1;</span>
            }
<span class="fc" id="L1494">            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(key, val, null);</span>
<span class="fc" id="L1495">            basepred.next = z;</span>
<span class="fc" id="L1496">            basepred = z;</span>
<span class="fc bfc" id="L1497" title="All 2 branches covered.">            if (j &gt; 0) {</span>
<span class="fc" id="L1498">                Index&lt;K,V&gt; idx = null;</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">                for (int i = 1; i &lt;= j; ++i) {</span>
<span class="fc" id="L1500">                    idx = new Index&lt;K,V&gt;(z, idx, null);</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                    if (i &gt; h.level)</span>
<span class="fc" id="L1502">                        h = new HeadIndex&lt;K,V&gt;(h.node, h, idx, i);</span>

<span class="fc bfc" id="L1504" title="All 2 branches covered.">                    if (i &lt; preds.size()) {</span>
<span class="fc" id="L1505">                        preds.get(i).right = idx;</span>
<span class="fc" id="L1506">                        preds.set(i, idx);</span>
                    } else
<span class="fc" id="L1508">                        preds.add(idx);</span>
                }
            }
<span class="fc" id="L1511">        }</span>
<span class="fc" id="L1512">        head = h;</span>
<span class="fc" id="L1513">    }</span>

    /* ------ Map API methods ------ */

    /**
     * Returns {@code true} if this map contains a mapping for the specified
     * key.
     *
     * @param key key whose presence in this map is to be tested
     * @return {@code true} if this map contains a mapping for the specified key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     */
    public boolean containsKey(Object key) {
<span class="fc bfc" id="L1528" title="All 2 branches covered.">        return doGet(key) != null;</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key} compares
     * equal to {@code k} according to the map's ordering, then this
     * method returns {@code v}; otherwise it returns {@code null}.
     * (There can be at most one such mapping.)
     *
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     */
    public V get(Object key) {
<span class="fc" id="L1546">        return doGet(key);</span>
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or the given defaultValue if this map contains no mapping for the key.
     *
     * @param key the key
     * @param defaultValue the value to return if this map contains
     * no mapping for the given key
     * @return the mapping for the key, if present; else the defaultValue
     * @throws NullPointerException if the specified key is null
     * @since 1.8
     */
    public V getOrDefault(Object key, V defaultValue) {
        V v;
<span class="nc bnc" id="L1562" title="All 2 branches missed.">        return (v = doGet(key)) == null ? defaultValue : v;</span>
    }

    /**
     * Associates the specified value with the specified key in this map.
     * If the map previously contained a mapping for the key, the old
     * value is replaced.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with the specified key, or
     *         {@code null} if there was no mapping for the key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key or value is null
     */
    public V put(K key, V value) {
<span class="pc bpc" id="L1579" title="1 of 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L1580">            throw new NullPointerException();</span>
<span class="fc" id="L1581">        return doPut(key, value, false);</span>
    }

    /**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param  key key for which mapping should be removed
     * @return the previous value associated with the specified key, or
     *         {@code null} if there was no mapping for the key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     */
    public V remove(Object key) {
<span class="fc" id="L1595">        return doRemove(key, null);</span>
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value.  This operation requires time linear in the
     * map size. Additionally, it is possible for the map to change
     * during execution of this method, in which case the returned
     * result may be inaccurate.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if a mapping to {@code value} exists;
     *         {@code false} otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean containsValue(Object value) {
<span class="fc bfc" id="L1611" title="All 2 branches covered.">        if (value == null)</span>
<span class="fc" id="L1612">            throw new NullPointerException();</span>
<span class="fc bfc" id="L1613" title="All 2 branches covered.">        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</span>
<span class="fc" id="L1614">            V v = n.getValidValue();</span>
<span class="pc bpc" id="L1615" title="1 of 4 branches missed.">            if (v != null &amp;&amp; value.equals(v))</span>
<span class="fc" id="L1616">                return true;</span>
        }
<span class="fc" id="L1618">        return false;</span>
    }

    /**
     * Returns the number of key-value mappings in this map.  If this map
     * contains more than {@code Integer.MAX_VALUE} elements, it
     * returns {@code Integer.MAX_VALUE}.
     *
     * &lt;p&gt;Beware that, unlike in most collections, this method is
     * &lt;em&gt;NOT&lt;/em&gt; a constant-time operation. Because of the
     * asynchronous nature of these maps, determining the current
     * number of elements requires traversing them all to count them.
     * Additionally, it is possible for the size to change during
     * execution of this method, in which case the returned result
     * will be inaccurate. Thus, this method is typically not very
     * useful in concurrent applications.
     *
     * @return the number of elements in this map
     */
    public int size() {
<span class="fc" id="L1638">        long count = 0;</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</span>
<span class="pc bpc" id="L1640" title="1 of 2 branches missed.">            if (n.getValidValue() != null)</span>
<span class="fc" id="L1641">                ++count;</span>
        }
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">        return (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;</span>
    }

    /**
     * Returns {@code true} if this map contains no key-value mappings.
     * @return {@code true} if this map contains no key-value mappings
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1651" title="All 2 branches covered.">        return findFirst() == null;</span>
    }

    /**
     * Removes all of the mappings from this map.
     */
    public void clear() {
<span class="fc" id="L1658">        initialize();</span>
<span class="fc" id="L1659">    }</span>

    /**
     * If the specified key is not already associated with a value,
     * attempts to compute its value using the given mapping function
     * and enters it into this map unless {@code null}.  The function
     * is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only
     * if the value is not present.
     *
     * @param key key with which the specified value is to be associated
     * @param mappingFunction the function to compute a value
     * @return the current (existing or computed) value associated with
     *         the specified key, or null if the computed value is null
     * @throws NullPointerException if the specified key is null
     *         or the mappingFunction is null
     * @since 1.8
     */
    public V computeIfAbsent(K key,
                             Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="nc bnc" id="L1678" title="All 4 branches missed.">        if (key == null || mappingFunction == null)</span>
<span class="nc" id="L1679">            throw new NullPointerException();</span>
        V v, p, r;
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        if ((v = doGet(key)) == null &amp;&amp;</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">            (r = mappingFunction.apply(key)) != null)</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            v = (p = doPut(key, r, true)) == null ? r : p;</span>
<span class="nc" id="L1684">        return v;</span>
    }

    /**
     * If the value for the specified key is present, attempts to
     * compute a new mapping given the key and its current mapped
     * value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied
     * once atomically.
     *
     * @param key key with which a value may be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key is null
     *         or the remappingFunction is null
     * @since 1.8
     */
    public V computeIfPresent(K key,
                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1702" title="All 4 branches missed.">        if (key == null || remappingFunction == null)</span>
<span class="nc" id="L1703">            throw new NullPointerException();</span>
        Node&lt;K,V&gt; n; Object v;
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        while ((n = findNode(key)) != null) {</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">            if ((v = n.value) != null) {</span>
<span class="nc" id="L1707">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</span>
<span class="nc" id="L1708">                V r = remappingFunction.apply(key, vv);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">                if (r != null) {</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">                    if (n.casValue(vv, r))</span>
<span class="nc" id="L1711">                        return r;</span>
                }
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                else if (doRemove(key, vv) != null)</span>
<span class="nc" id="L1714">                    break;</span>
<span class="nc" id="L1715">            }</span>
        }
<span class="nc" id="L1717">        return null;</span>
    }

    /**
     * Attempts to compute a mapping for the specified key and its
     * current mapped value (or {@code null} if there is no current
     * mapping). The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied
     * once atomically.
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key is null
     *         or the remappingFunction is null
     * @since 1.8
     */
    public V compute(K key,
                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1735" title="All 4 branches missed.">        if (key == null || remappingFunction == null)</span>
<span class="nc" id="L1736">            throw new NullPointerException();</span>
        for (;;) {
            Node&lt;K,V&gt; n; Object v; V r;
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            if ((n = findNode(key)) == null) {</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                if ((r = remappingFunction.apply(key, null)) == null)</span>
<span class="nc" id="L1741">                    break;</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">                if (doPut(key, r, true) == null)</span>
<span class="nc" id="L1743">                    return r;</span>
            }
<span class="nc bnc" id="L1745" title="All 2 branches missed.">            else if ((v = n.value) != null) {</span>
<span class="nc" id="L1746">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">                if ((r = remappingFunction.apply(key, vv)) != null) {</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">                    if (n.casValue(vv, r))</span>
<span class="nc" id="L1749">                        return r;</span>
                }
<span class="nc bnc" id="L1751" title="All 2 branches missed.">                else if (doRemove(key, vv) != null)</span>
<span class="nc" id="L1752">                    break;</span>
            }
<span class="nc" id="L1754">        }</span>
<span class="nc" id="L1755">        return null;</span>
    }

    /**
     * If the specified key is not already associated with a value,
     * associates it with the given value.  Otherwise, replaces the
     * value with the results of the given remapping function, or
     * removes if {@code null}. The function is &lt;em&gt;NOT&lt;/em&gt;
     * guaranteed to be applied once atomically.
     *
     * @param key key with which the specified value is to be associated
     * @param value the value to use if absent
     * @param remappingFunction the function to recompute a value if present
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or value is null
     *         or the remappingFunction is null
     * @since 1.8
     */
    public V merge(K key, V value,
                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc bnc" id="L1775" title="All 6 branches missed.">        if (key == null || value == null || remappingFunction == null)</span>
<span class="nc" id="L1776">            throw new NullPointerException();</span>
        for (;;) {
            Node&lt;K,V&gt; n; Object v; V r;
<span class="nc bnc" id="L1779" title="All 2 branches missed.">            if ((n = findNode(key)) == null) {</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">                if (doPut(key, value, true) == null)</span>
<span class="nc" id="L1781">                    return value;</span>
            }
<span class="nc bnc" id="L1783" title="All 2 branches missed.">            else if ((v = n.value) != null) {</span>
<span class="nc" id="L1784">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V) v;</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">                if ((r = remappingFunction.apply(vv, value)) != null) {</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">                    if (n.casValue(vv, r))</span>
<span class="nc" id="L1787">                        return r;</span>
                }
<span class="nc bnc" id="L1789" title="All 2 branches missed.">                else if (doRemove(key, vv) != null)</span>
<span class="nc" id="L1790">                    return null;</span>
            }
<span class="nc" id="L1792">        }</span>
    }

    /* ---------------- View methods -------------- */

    /*
     * Note: Lazy initialization works for views because view classes
     * are stateless/immutable so it doesn't matter wrt correctness if
     * more than one is created (which will only rarely happen).  Even
     * so, the following idiom conservatively ensures that the method
     * returns the one it created if it does so, not one created by
     * another racing thread.
     */

    /**
     * Returns a {@link NavigableSet} view of the keys contained in this map.
     *
     * &lt;p&gt;The set's iterator returns the keys in ascending order.
     * The set's spliterator additionally reports {@link Spliterator#CONCURRENT},
     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
     * key order.  The spliterator's comparator (see
     * {@link java.util.Spliterator#getComparator()}) is {@code null} if
     * the map's comparator (see {@link #comparator()}) is {@code null}.
     * Otherwise, the spliterator's comparator is the same as or imposes the
     * same total ordering as the map's comparator.
     *
     * &lt;p&gt;The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or {@code addAll}
     * operations.
     *
     * &lt;p&gt;The view's iterators and spliterators are
     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
     *
     * &lt;p&gt;This method is equivalent to method {@code navigableKeySet}.
     *
     * @return a navigable set view of the keys in this map
     */
    public NavigableSet&lt;K&gt; keySet() {
<span class="fc" id="L1835">        KeySet&lt;K&gt; ks = keySet;</span>
<span class="fc bfc" id="L1836" title="All 2 branches covered.">        return (ks != null) ? ks : (keySet = new KeySet&lt;K&gt;(this));</span>
    }

    public NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L1840">        KeySet&lt;K&gt; ks = keySet;</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">        return (ks != null) ? ks : (keySet = new KeySet&lt;K&gt;(this));</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * &lt;p&gt;The collection's iterator returns the values in ascending order
     * of the corresponding keys. The collections's spliterator additionally
     * reports {@link Spliterator#CONCURRENT}, {@link Spliterator#NONNULL} and
     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
     * order of the corresponding keys.
     *
     * &lt;p&gt;The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  The collection
     * supports element removal, which removes the corresponding
     * mapping from the map, via the {@code Iterator.remove},
     * {@code Collection.remove}, {@code removeAll},
     * {@code retainAll} and {@code clear} operations.  It does not
     * support the {@code add} or {@code addAll} operations.
     *
     * &lt;p&gt;The view's iterators and spliterators are
     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
     */
    public Collection&lt;V&gt; values() {
<span class="fc" id="L1864">        Values&lt;V&gt; vs = values;</span>
<span class="fc bfc" id="L1865" title="All 2 branches covered.">        return (vs != null) ? vs : (values = new Values&lt;V&gt;(this));</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     *
     * &lt;p&gt;The set's iterator returns the entries in ascending key order.  The
     * set's spliterator additionally reports {@link Spliterator#CONCURRENT},
     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
     * key order.
     *
     * &lt;p&gt;The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll} and {@code clear}
     * operations.  It does not support the {@code add} or
     * {@code addAll} operations.
     *
     * &lt;p&gt;The view's iterators and spliterators are
     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
     *
     * &lt;p&gt;The {@code Map.Entry} elements traversed by the {@code iterator}
     * or {@code spliterator} do &lt;em&gt;not&lt;/em&gt; support the {@code setValue}
     * operation.
     *
     * @return a set view of the mappings contained in this map,
     *         sorted in ascending key order
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L1896">        EntrySet&lt;K,V&gt; es = entrySet;</span>
<span class="fc bfc" id="L1897" title="All 2 branches covered.">        return (es != null) ? es : (entrySet = new EntrySet&lt;K,V&gt;(this));</span>
    }

    public ConcurrentNavigableMap&lt;K,V&gt; descendingMap() {
<span class="fc" id="L1901">        ConcurrentNavigableMap&lt;K,V&gt; dm = descendingMap;</span>
<span class="fc bfc" id="L1902" title="All 2 branches covered.">        return (dm != null) ? dm : (descendingMap = new SubMap&lt;K,V&gt;</span>
                                    (this, null, false, null, false, true));
    }

    public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L1907">        return descendingMap().navigableKeySet();</span>
    }

    /* ---------------- AbstractMap Overrides -------------- */

    /**
     * Compares the specified object with this map for equality.
     * Returns {@code true} if the given object is also a map and the
     * two maps represent the same mappings.  More formally, two maps
     * {@code m1} and {@code m2} represent the same mappings if
     * {@code m1.entrySet().equals(m2.entrySet())}.  This
     * operation may return misleading results if either map is
     * concurrently modified during execution of this method.
     *
     * @param o object to be compared for equality with this map
     * @return {@code true} if the specified object is equal to this map
     */
    public boolean equals(Object o) {
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">        if (o == this)</span>
<span class="nc" id="L1926">            return true;</span>
<span class="pc bpc" id="L1927" title="1 of 2 branches missed.">        if (!(o instanceof Map))</span>
<span class="nc" id="L1928">            return false;</span>
<span class="fc" id="L1929">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span>
        try {
<span class="fc bfc" id="L1931" title="All 2 branches covered.">            for (Map.Entry&lt;K,V&gt; e : this.entrySet())</span>
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">                if (! e.getValue().equals(m.get(e.getKey())))</span>
<span class="nc" id="L1933">                    return false;</span>
<span class="fc bfc" id="L1934" title="All 2 branches covered.">            for (Map.Entry&lt;?,?&gt; e : m.entrySet()) {</span>
<span class="fc" id="L1935">                Object k = e.getKey();</span>
<span class="fc" id="L1936">                Object v = e.getValue();</span>
<span class="pc bpc" id="L1937" title="3 of 6 branches missed.">                if (k == null || v == null || !v.equals(get(k)))</span>
<span class="nc" id="L1938">                    return false;</span>
<span class="fc" id="L1939">            }</span>
<span class="fc" id="L1940">            return true;</span>
<span class="nc" id="L1941">        } catch (ClassCastException unused) {</span>
<span class="nc" id="L1942">            return false;</span>
<span class="nc" id="L1943">        } catch (NullPointerException unused) {</span>
<span class="nc" id="L1944">            return false;</span>
        }
    }

    /* ------ ConcurrentMap API methods ------ */

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key or value is null
     */
    public V putIfAbsent(K key, V value) {
<span class="fc bfc" id="L1960" title="All 2 branches covered.">        if (value == null)</span>
<span class="fc" id="L1961">            throw new NullPointerException();</span>
<span class="fc" id="L1962">        return doPut(key, value, true);</span>
    }

    /**
     * {@inheritDoc}
     *
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key is null
     */
    public boolean remove(Object key, Object value) {
<span class="fc bfc" id="L1973" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L1974">            throw new NullPointerException();</span>
<span class="fc bfc" id="L1975" title="All 4 branches covered.">        return value != null &amp;&amp; doRemove(key, value) != null;</span>
    }

    /**
     * {@inheritDoc}
     *
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if any of the arguments are null
     */
    public boolean replace(K key, V oldValue, V newValue) {
<span class="pc bpc" id="L1986" title="1 of 6 branches missed.">        if (key == null || oldValue == null || newValue == null)</span>
<span class="fc" id="L1987">            throw new NullPointerException();</span>
        for (;;) {
            Node&lt;K,V&gt; n; Object v;
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">            if ((n = findNode(key)) == null)</span>
<span class="nc" id="L1991">                return false;</span>
<span class="pc bpc" id="L1992" title="1 of 2 branches missed.">            if ((v = n.value) != null) {</span>
<span class="fc bfc" id="L1993" title="All 2 branches covered.">                if (!oldValue.equals(v))</span>
<span class="fc" id="L1994">                    return false;</span>
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">                if (n.casValue(v, newValue))</span>
<span class="fc" id="L1996">                    return true;</span>
            }
<span class="nc" id="L1998">        }</span>
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws ClassCastException if the specified key cannot be compared
     *         with the keys currently in the map
     * @throws NullPointerException if the specified key or value is null
     */
    public V replace(K key, V value) {
<span class="fc bfc" id="L2011" title="All 4 branches covered.">        if (key == null || value == null)</span>
<span class="fc" id="L2012">            throw new NullPointerException();</span>
        for (;;) {
            Node&lt;K,V&gt; n; Object v;
<span class="fc bfc" id="L2015" title="All 2 branches covered.">            if ((n = findNode(key)) == null)</span>
<span class="fc" id="L2016">                return null;</span>
<span class="pc bpc" id="L2017" title="2 of 4 branches missed.">            if ((v = n.value) != null &amp;&amp; n.casValue(v, value)) {</span>
<span class="fc" id="L2018">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="fc" id="L2019">                return vv;</span>
            }
<span class="nc" id="L2021">        }</span>
    }

    /* ------ SortedMap API methods ------ */

    public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L2027">        return comparator;</span>
    }

    /**
     * @throws NoSuchElementException {@inheritDoc}
     */
    public K firstKey() {
<span class="fc" id="L2034">        Node&lt;K,V&gt; n = findFirst();</span>
<span class="fc bfc" id="L2035" title="All 2 branches covered.">        if (n == null)</span>
<span class="fc" id="L2036">            throw new NoSuchElementException();</span>
<span class="fc" id="L2037">        return n.key;</span>
    }

    /**
     * @throws NoSuchElementException {@inheritDoc}
     */
    public K lastKey() {
<span class="fc" id="L2044">        Node&lt;K,V&gt; n = findLast();</span>
<span class="fc bfc" id="L2045" title="All 2 branches covered.">        if (n == null)</span>
<span class="fc" id="L2046">            throw new NoSuchElementException();</span>
<span class="fc" id="L2047">        return n.key;</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey,
                                              boolean fromInclusive,
                                              K toKey,
                                              boolean toInclusive) {
<span class="pc bpc" id="L2059" title="2 of 4 branches missed.">        if (fromKey == null || toKey == null)</span>
<span class="nc" id="L2060">            throw new NullPointerException();</span>
<span class="fc" id="L2061">        return new SubMap&lt;K,V&gt;</span>
            (this, fromKey, fromInclusive, toKey, toInclusive, false);
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code toKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey,
                                               boolean inclusive) {
<span class="pc bpc" id="L2072" title="1 of 2 branches missed.">        if (toKey == null)</span>
<span class="nc" id="L2073">            throw new NullPointerException();</span>
<span class="fc" id="L2074">        return new SubMap&lt;K,V&gt;</span>
            (this, null, false, toKey, inclusive, false);
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey,
                                               boolean inclusive) {
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">        if (fromKey == null)</span>
<span class="nc" id="L2086">            throw new NullPointerException();</span>
<span class="fc" id="L2087">        return new SubMap&lt;K,V&gt;</span>
            (this, fromKey, inclusive, null, false, false);
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L2097">        return subMap(fromKey, true, toKey, false);</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code toKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L2106">        return headMap(toKey, false);</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if {@code fromKey} is null
     * @throws IllegalArgumentException {@inheritDoc}
     */
    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L2115">        return tailMap(fromKey, true);</span>
    }

    /* ---------------- Relational operations -------------- */

    /**
     * Returns a key-value mapping associated with the greatest key
     * strictly less than the given key, or {@code null} if there is
     * no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the
     * {@code Entry.setValue} method.
     *
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<span class="fc" id="L2130">        return getNear(key, LT);</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public K lowerKey(K key) {
<span class="fc" id="L2138">        Node&lt;K,V&gt; n = findNear(key, LT, comparator);</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">        return (n == null) ? null : n.key;</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest key
     * less than or equal to the given key, or {@code null} if there
     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     *
     * @param key the key
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public Map.Entry&lt;K,V&gt; floorEntry(K key) {
<span class="fc" id="L2153">        return getNear(key, LT|EQ);</span>
    }

    /**
     * @param key the key
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public K floorKey(K key) {
<span class="fc" id="L2162">        Node&lt;K,V&gt; n = findNear(key, LT|EQ, comparator);</span>
<span class="fc bfc" id="L2163" title="All 2 branches covered.">        return (n == null) ? null : n.key;</span>
    }

    /**
     * Returns a key-value mapping associated with the least key
     * greater than or equal to the given key, or {@code null} if
     * there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt;
     * support the {@code Entry.setValue} method.
     *
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<span class="fc" id="L2176">        return getNear(key, GT|EQ);</span>
    }

    /**
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public K ceilingKey(K key) {
<span class="fc" id="L2184">        Node&lt;K,V&gt; n = findNear(key, GT|EQ, comparator);</span>
<span class="fc bfc" id="L2185" title="All 2 branches covered.">        return (n == null) ? null : n.key;</span>
    }

    /**
     * Returns a key-value mapping associated with the least key
     * strictly greater than the given key, or {@code null} if there
     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     *
     * @param key the key
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public Map.Entry&lt;K,V&gt; higherEntry(K key) {
<span class="fc" id="L2199">        return getNear(key, GT);</span>
    }

    /**
     * @param key the key
     * @throws ClassCastException {@inheritDoc}
     * @throws NullPointerException if the specified key is null
     */
    public K higherKey(K key) {
<span class="fc" id="L2208">        Node&lt;K,V&gt; n = findNear(key, GT, comparator);</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">        return (n == null) ? null : n.key;</span>
    }

    /**
     * Returns a key-value mapping associated with the least
     * key in this map, or {@code null} if the map is empty.
     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     */
    public Map.Entry&lt;K,V&gt; firstEntry() {
        for (;;) {
<span class="fc" id="L2220">            Node&lt;K,V&gt; n = findFirst();</span>
<span class="fc bfc" id="L2221" title="All 2 branches covered.">            if (n == null)</span>
<span class="fc" id="L2222">                return null;</span>
<span class="fc" id="L2223">            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</span>
<span class="pc bpc" id="L2224" title="1 of 2 branches missed.">            if (e != null)</span>
<span class="fc" id="L2225">                return e;</span>
<span class="nc" id="L2226">        }</span>
    }

    /**
     * Returns a key-value mapping associated with the greatest
     * key in this map, or {@code null} if the map is empty.
     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     */
    public Map.Entry&lt;K,V&gt; lastEntry() {
        for (;;) {
<span class="fc" id="L2237">            Node&lt;K,V&gt; n = findLast();</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">            if (n == null)</span>
<span class="fc" id="L2239">                return null;</span>
<span class="fc" id="L2240">            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e = n.createSnapshot();</span>
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">            if (e != null)</span>
<span class="fc" id="L2242">                return e;</span>
<span class="nc" id="L2243">        }</span>
    }

    /**
     * Removes and returns a key-value mapping associated with
     * the least key in this map, or {@code null} if the map is empty.
     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     */
    public Map.Entry&lt;K,V&gt; pollFirstEntry() {
<span class="fc" id="L2253">        return doRemoveFirstEntry();</span>
    }

    /**
     * Removes and returns a key-value mapping associated with
     * the greatest key in this map, or {@code null} if the map is empty.
     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
     * the {@code Entry.setValue} method.
     */
    public Map.Entry&lt;K,V&gt; pollLastEntry() {
<span class="fc" id="L2263">        return doRemoveLastEntry();</span>
    }


    /* ---------------- Iterators -------------- */

    /**
     * Base of iterator classes:
     */
    abstract class Iter&lt;T&gt; implements Iterator&lt;T&gt; {
        /** the last node returned by next() */
        Node&lt;K,V&gt; lastReturned;
        /** the next node to return from next(); */
        Node&lt;K,V&gt; next;
        /** Cache of next value field to maintain weak consistency */
        V nextValue;

        /** Initializes ascending iterator for entire range. */
<span class="fc" id="L2281">        Iter() {</span>
<span class="fc bfc" id="L2282" title="All 2 branches covered.">            while ((next = findFirst()) != null) {</span>
<span class="fc" id="L2283">                Object x = next.value;</span>
<span class="pc bpc" id="L2284" title="2 of 4 branches missed.">                if (x != null &amp;&amp; x != next) {</span>
<span class="fc" id="L2285">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</span>
<span class="fc" id="L2286">                    nextValue = vv;</span>
<span class="fc" id="L2287">                    break;</span>
                }
<span class="nc" id="L2289">            }</span>
<span class="fc" id="L2290">        }</span>

        public final boolean hasNext() {
<span class="fc bfc" id="L2293" title="All 2 branches covered.">            return next != null;</span>
        }

        /** Advances next to higher entry. */
        final void advance() {
<span class="fc bfc" id="L2298" title="All 2 branches covered.">            if (next == null)</span>
<span class="fc" id="L2299">                throw new NoSuchElementException();</span>
<span class="fc" id="L2300">            lastReturned = next;</span>
<span class="fc bfc" id="L2301" title="All 2 branches covered.">            while ((next = next.next) != null) {</span>
<span class="fc" id="L2302">                Object x = next.value;</span>
<span class="pc bpc" id="L2303" title="1 of 4 branches missed.">                if (x != null &amp;&amp; x != next) {</span>
<span class="fc" id="L2304">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</span>
<span class="fc" id="L2305">                    nextValue = vv;</span>
<span class="fc" id="L2306">                    break;</span>
                }
<span class="fc" id="L2308">            }</span>
<span class="fc" id="L2309">        }</span>

        public void remove() {
<span class="fc" id="L2312">            Node&lt;K,V&gt; l = lastReturned;</span>
<span class="fc bfc" id="L2313" title="All 2 branches covered.">            if (l == null)</span>
<span class="fc" id="L2314">                throw new IllegalStateException();</span>
            // It would not be worth all of the overhead to directly
            // unlink from here. Using remove is fast enough.
<span class="fc" id="L2317">            ConcurrentSkipListMap.this.remove(l.key);</span>
<span class="fc" id="L2318">            lastReturned = null;</span>
<span class="fc" id="L2319">        }</span>

    }

<span class="fc" id="L2323">    final class ValueIterator extends Iter&lt;V&gt; {</span>
        public V next() {
<span class="fc" id="L2325">            V v = nextValue;</span>
<span class="fc" id="L2326">            advance();</span>
<span class="fc" id="L2327">            return v;</span>
        }
    }

<span class="fc" id="L2331">    final class KeyIterator extends Iter&lt;K&gt; {</span>
        public K next() {
<span class="fc" id="L2333">            Node&lt;K,V&gt; n = next;</span>
<span class="fc" id="L2334">            advance();</span>
<span class="fc" id="L2335">            return n.key;</span>
        }
    }

<span class="fc" id="L2339">    final class EntryIterator extends Iter&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
        public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L2341">            Node&lt;K,V&gt; n = next;</span>
<span class="fc" id="L2342">            V v = nextValue;</span>
<span class="fc" id="L2343">            advance();</span>
<span class="fc" id="L2344">            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</span>
        }
    }

    // Factory methods for iterators needed by ConcurrentSkipListSet etc

    Iterator&lt;K&gt; keyIterator() {
<span class="fc" id="L2351">        return new KeyIterator();</span>
    }

    Iterator&lt;V&gt; valueIterator() {
<span class="fc" id="L2355">        return new ValueIterator();</span>
    }

    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() {
<span class="fc" id="L2359">        return new EntryIterator();</span>
    }

    /* ---------------- View Classes -------------- */

    /*
     * View classes are static, delegating to a ConcurrentNavigableMap
     * to allow use by SubMaps, which outweighs the ugliness of
     * needing type-tests for Iterator methods.
     */

    static final &lt;E&gt; List&lt;E&gt; toList(Collection&lt;E&gt; c) {
        // Using size() here would be a pessimization.
<span class="fc" id="L2372">        ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();</span>
<span class="fc bfc" id="L2373" title="All 2 branches covered.">        for (E e : c)</span>
<span class="fc" id="L2374">            list.add(e);</span>
<span class="fc" id="L2375">        return list;</span>
    }

    static final class KeySet&lt;E&gt;
            extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {
        final ConcurrentNavigableMap&lt;E,?&gt; m;
<span class="fc" id="L2381">        KeySet(ConcurrentNavigableMap&lt;E,?&gt; map) { m = map; }</span>
<span class="fc" id="L2382">        public int size() { return m.size(); }</span>
<span class="fc" id="L2383">        public boolean isEmpty() { return m.isEmpty(); }</span>
<span class="fc" id="L2384">        public boolean contains(Object o) { return m.containsKey(o); }</span>
<span class="pc bpc" id="L2385" title="1 of 2 branches missed.">        public boolean remove(Object o) { return m.remove(o) != null; }</span>
<span class="nc" id="L2386">        public void clear() { m.clear(); }</span>
<span class="fc" id="L2387">        public E lower(E e) { return m.lowerKey(e); }</span>
<span class="fc" id="L2388">        public E floor(E e) { return m.floorKey(e); }</span>
<span class="fc" id="L2389">        public E ceiling(E e) { return m.ceilingKey(e); }</span>
<span class="fc" id="L2390">        public E higher(E e) { return m.higherKey(e); }</span>
<span class="fc" id="L2391">        public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }</span>
<span class="fc" id="L2392">        public E first() { return m.firstKey(); }</span>
<span class="fc" id="L2393">        public E last() { return m.lastKey(); }</span>
        public E pollFirst() {
<span class="nc" id="L2395">            Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">            return (e == null) ? null : e.getKey();</span>
        }
        public E pollLast() {
<span class="nc" id="L2399">            Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">            return (e == null) ? null : e.getKey();</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        public Iterator&lt;E&gt; iterator() {
<span class="fc bfc" id="L2404" title="All 2 branches covered.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2405">                return ((ConcurrentSkipListMap&lt;E,Object&gt;)m).keyIterator();</span>
            else
<span class="fc" id="L2407">                return ((ConcurrentSkipListMap.SubMap&lt;E,Object&gt;)m).keyIterator();</span>
        }
        public boolean equals(Object o) {
<span class="fc bfc" id="L2410" title="All 2 branches covered.">            if (o == this)</span>
<span class="fc" id="L2411">                return true;</span>
<span class="pc bpc" id="L2412" title="1 of 2 branches missed.">            if (!(o instanceof Set))</span>
<span class="nc" id="L2413">                return false;</span>
<span class="fc" id="L2414">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span>
            try {
<span class="pc bpc" id="L2416" title="2 of 4 branches missed.">                return containsAll(c) &amp;&amp; c.containsAll(this);</span>
<span class="nc" id="L2417">            } catch (ClassCastException unused) {</span>
<span class="nc" id="L2418">                return false;</span>
<span class="nc" id="L2419">            } catch (NullPointerException unused) {</span>
<span class="nc" id="L2420">                return false;</span>
            }
        }
<span class="fc" id="L2423">        public Object[] toArray()     { return toList(this).toArray();  }</span>
<span class="fc" id="L2424">        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</span>
        public Iterator&lt;E&gt; descendingIterator() {
<span class="fc" id="L2426">            return descendingSet().iterator();</span>
        }
        public NavigableSet&lt;E&gt; subSet(E fromElement,
                                      boolean fromInclusive,
                                      E toElement,
                                      boolean toInclusive) {
<span class="fc" id="L2432">            return new KeySet&lt;E&gt;(m.subMap(fromElement, fromInclusive,</span>
                                          toElement,   toInclusive));
        }
        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
<span class="fc" id="L2436">            return new KeySet&lt;E&gt;(m.headMap(toElement, inclusive));</span>
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
<span class="fc" id="L2439">            return new KeySet&lt;E&gt;(m.tailMap(fromElement, inclusive));</span>
        }
        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) {
<span class="fc" id="L2442">            return subSet(fromElement, true, toElement, false);</span>
        }
        public NavigableSet&lt;E&gt; headSet(E toElement) {
<span class="fc" id="L2445">            return headSet(toElement, false);</span>
        }
        public NavigableSet&lt;E&gt; tailSet(E fromElement) {
<span class="fc" id="L2448">            return tailSet(fromElement, true);</span>
        }
        public NavigableSet&lt;E&gt; descendingSet() {
<span class="fc" id="L2451">            return new KeySet&lt;E&gt;(m.descendingMap());</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        public Spliterator&lt;E&gt; spliterator() {
<span class="pc bpc" id="L2455" title="1 of 2 branches missed.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2456">                return ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator();</span>
            else
<span class="nc" id="L2458">                return (Spliterator&lt;E&gt;)((SubMap&lt;E,?&gt;)m).keyIterator();</span>
        }
    }

    static final class Values&lt;E&gt; extends AbstractCollection&lt;E&gt; {
        final ConcurrentNavigableMap&lt;?, E&gt; m;
<span class="fc" id="L2464">        Values(ConcurrentNavigableMap&lt;?, E&gt; map) {</span>
<span class="fc" id="L2465">            m = map;</span>
<span class="fc" id="L2466">        }</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public Iterator&lt;E&gt; iterator() {
<span class="fc bfc" id="L2469" title="All 2 branches covered.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2470">                return ((ConcurrentSkipListMap&lt;?,E&gt;)m).valueIterator();</span>
            else
<span class="fc" id="L2472">                return ((SubMap&lt;?,E&gt;)m).valueIterator();</span>
        }
        public boolean isEmpty() {
<span class="fc" id="L2475">            return m.isEmpty();</span>
        }
        public int size() {
<span class="fc" id="L2478">            return m.size();</span>
        }
        public boolean contains(Object o) {
<span class="fc" id="L2481">            return m.containsValue(o);</span>
        }
        public void clear() {
<span class="nc" id="L2484">            m.clear();</span>
<span class="nc" id="L2485">        }</span>
<span class="fc" id="L2486">        public Object[] toArray()     { return toList(this).toArray();  }</span>
<span class="fc" id="L2487">        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public Spliterator&lt;E&gt; spliterator() {
<span class="pc bpc" id="L2490" title="1 of 2 branches missed.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2491">                return ((ConcurrentSkipListMap&lt;?,E&gt;)m).valueSpliterator();</span>
            else
<span class="nc" id="L2493">                return (Spliterator&lt;E&gt;)((SubMap&lt;?,E&gt;)m).valueIterator();</span>
        }
    }

    static final class EntrySet&lt;K1,V1&gt; extends AbstractSet&lt;Map.Entry&lt;K1,V1&gt;&gt; {
        final ConcurrentNavigableMap&lt;K1, V1&gt; m;
<span class="fc" id="L2499">        EntrySet(ConcurrentNavigableMap&lt;K1, V1&gt; map) {</span>
<span class="fc" id="L2500">            m = map;</span>
<span class="fc" id="L2501">        }</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public Iterator&lt;Map.Entry&lt;K1,V1&gt;&gt; iterator() {
<span class="fc bfc" id="L2504" title="All 2 branches covered.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2505">                return ((ConcurrentSkipListMap&lt;K1,V1&gt;)m).entryIterator();</span>
            else
<span class="fc" id="L2507">                return ((SubMap&lt;K1,V1&gt;)m).entryIterator();</span>
        }

        public boolean contains(Object o) {
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L2512">                return false;</span>
<span class="fc" id="L2513">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="fc" id="L2514">            V1 v = m.get(e.getKey());</span>
<span class="pc bpc" id="L2515" title="1 of 4 branches missed.">            return v != null &amp;&amp; v.equals(e.getValue());</span>
        }
        public boolean remove(Object o) {
<span class="pc bpc" id="L2518" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L2519">                return false;</span>
<span class="fc" id="L2520">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span>
<span class="fc" id="L2521">            return m.remove(e.getKey(),</span>
<span class="fc" id="L2522">                            e.getValue());</span>
        }
        public boolean isEmpty() {
<span class="fc" id="L2525">            return m.isEmpty();</span>
        }
        public int size() {
<span class="fc" id="L2528">            return m.size();</span>
        }
        public void clear() {
<span class="nc" id="L2531">            m.clear();</span>
<span class="nc" id="L2532">        }</span>
        public boolean equals(Object o) {
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">            if (o == this)</span>
<span class="nc" id="L2535">                return true;</span>
<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">            if (!(o instanceof Set))</span>
<span class="nc" id="L2537">                return false;</span>
<span class="fc" id="L2538">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span>
            try {
<span class="pc bpc" id="L2540" title="2 of 4 branches missed.">                return containsAll(c) &amp;&amp; c.containsAll(this);</span>
<span class="nc" id="L2541">            } catch (ClassCastException unused) {</span>
<span class="nc" id="L2542">                return false;</span>
<span class="nc" id="L2543">            } catch (NullPointerException unused) {</span>
<span class="nc" id="L2544">                return false;</span>
            }
        }
<span class="fc" id="L2547">        public Object[] toArray()     { return toList(this).toArray();  }</span>
<span class="fc" id="L2548">        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        public Spliterator&lt;Map.Entry&lt;K1,V1&gt;&gt; spliterator() {
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">            if (m instanceof ConcurrentSkipListMap)</span>
<span class="fc" id="L2552">                return ((ConcurrentSkipListMap&lt;K1,V1&gt;)m).entrySpliterator();</span>
            else
<span class="nc" id="L2554">                return (Spliterator&lt;Map.Entry&lt;K1,V1&gt;&gt;)</span>
<span class="nc" id="L2555">                    ((SubMap&lt;K1,V1&gt;)m).entryIterator();</span>
        }
    }

    /**
     * Submaps returned by {@link ConcurrentSkipListMap} submap operations
     * represent a subrange of mappings of their underlying
     * maps. Instances of this class support all methods of their
     * underlying maps, differing in that mappings outside their range are
     * ignored, and attempts to add mappings outside their ranges result
     * in {@link IllegalArgumentException}.  Instances of this class are
     * constructed only using the {@code subMap}, {@code headMap}, and
     * {@code tailMap} methods of their underlying maps.
     *
     * @serial include
     */
    static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
        implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {
        private static final long serialVersionUID = -7647078645895051609L;

        /** Underlying map */
        private final ConcurrentSkipListMap&lt;K,V&gt; m;
        /** lower bound key, or null if from start */
        private final K lo;
        /** upper bound key, or null if to end */
        private final K hi;
        /** inclusion flag for lo */
        private final boolean loInclusive;
        /** inclusion flag for hi */
        private final boolean hiInclusive;
        /** direction */
        private final boolean isDescending;

        // Lazily initialized view holders
        private transient KeySet&lt;K&gt; keySetView;
        private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySetView;
        private transient Collection&lt;V&gt; valuesView;

        /**
         * Creates a new submap, initializing all fields.
         */
        SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,
               K fromKey, boolean fromInclusive,
               K toKey, boolean toInclusive,
<span class="fc" id="L2599">               boolean isDescending) {</span>
<span class="fc" id="L2600">            Comparator&lt;? super K&gt; cmp = map.comparator;</span>
<span class="fc bfc" id="L2601" title="All 4 branches covered.">            if (fromKey != null &amp;&amp; toKey != null &amp;&amp;</span>
<span class="pc bpc" id="L2602" title="1 of 2 branches missed.">                cpr(cmp, fromKey, toKey) &gt; 0)</span>
<span class="nc" id="L2603">                throw new IllegalArgumentException(&quot;inconsistent range&quot;);</span>
<span class="fc" id="L2604">            this.m = map;</span>
<span class="fc" id="L2605">            this.lo = fromKey;</span>
<span class="fc" id="L2606">            this.hi = toKey;</span>
<span class="fc" id="L2607">            this.loInclusive = fromInclusive;</span>
<span class="fc" id="L2608">            this.hiInclusive = toInclusive;</span>
<span class="fc" id="L2609">            this.isDescending = isDescending;</span>
<span class="fc" id="L2610">        }</span>

        /* ----------------  Utilities -------------- */

        boolean tooLow(Object key, Comparator&lt;? super K&gt; cmp) {
            int c;
<span class="fc bfc" id="L2616" title="All 8 branches covered.">            return (lo != null &amp;&amp; ((c = cpr(cmp, key, lo)) &lt; 0 ||</span>
                                   (c == 0 &amp;&amp; !loInclusive)));
        }

        boolean tooHigh(Object key, Comparator&lt;? super K&gt; cmp) {
            int c;
<span class="fc bfc" id="L2622" title="All 8 branches covered.">            return (hi != null &amp;&amp; ((c = cpr(cmp, key, hi)) &gt; 0 ||</span>
                                   (c == 0 &amp;&amp; !hiInclusive)));
        }

        boolean inBounds(Object key, Comparator&lt;? super K&gt; cmp) {
<span class="fc bfc" id="L2627" title="All 4 branches covered.">            return !tooLow(key, cmp) &amp;&amp; !tooHigh(key, cmp);</span>
        }

        void checkKeyBounds(K key, Comparator&lt;? super K&gt; cmp) {
<span class="pc bpc" id="L2631" title="1 of 2 branches missed.">            if (key == null)</span>
<span class="nc" id="L2632">                throw new NullPointerException();</span>
<span class="pc bpc" id="L2633" title="1 of 2 branches missed.">            if (!inBounds(key, cmp))</span>
<span class="nc" id="L2634">                throw new IllegalArgumentException(&quot;key out of range&quot;);</span>
<span class="fc" id="L2635">        }</span>

        /**
         * Returns true if node key is less than upper bound of range.
         */
        boolean isBeforeEnd(ConcurrentSkipListMap.Node&lt;K,V&gt; n,
                            Comparator&lt;? super K&gt; cmp) {
<span class="fc bfc" id="L2642" title="All 2 branches covered.">            if (n == null)</span>
<span class="fc" id="L2643">                return false;</span>
<span class="fc bfc" id="L2644" title="All 2 branches covered.">            if (hi == null)</span>
<span class="fc" id="L2645">                return true;</span>
<span class="fc" id="L2646">            K k = n.key;</span>
<span class="fc bfc" id="L2647" title="All 2 branches covered.">            if (k == null) // pass by markers and headers</span>
<span class="fc" id="L2648">                return true;</span>
<span class="fc" id="L2649">            int c = cpr(cmp, k, hi);</span>
<span class="fc bfc" id="L2650" title="All 6 branches covered.">            if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))</span>
<span class="fc" id="L2651">                return false;</span>
<span class="fc" id="L2652">            return true;</span>
        }

        /**
         * Returns lowest node. This node might not be in range, so
         * most usages need to check bounds.
         */
        ConcurrentSkipListMap.Node&lt;K,V&gt; loNode(Comparator&lt;? super K&gt; cmp) {
<span class="fc bfc" id="L2660" title="All 2 branches covered.">            if (lo == null)</span>
<span class="fc" id="L2661">                return m.findFirst();</span>
<span class="fc bfc" id="L2662" title="All 2 branches covered.">            else if (loInclusive)</span>
<span class="fc" id="L2663">                return m.findNear(lo, GT|EQ, cmp);</span>
            else
<span class="fc" id="L2665">                return m.findNear(lo, GT, cmp);</span>
        }

        /**
         * Returns highest node. This node might not be in range, so
         * most usages need to check bounds.
         */
        ConcurrentSkipListMap.Node&lt;K,V&gt; hiNode(Comparator&lt;? super K&gt; cmp) {
<span class="fc bfc" id="L2673" title="All 2 branches covered.">            if (hi == null)</span>
<span class="fc" id="L2674">                return m.findLast();</span>
<span class="fc bfc" id="L2675" title="All 2 branches covered.">            else if (hiInclusive)</span>
<span class="fc" id="L2676">                return m.findNear(hi, LT|EQ, cmp);</span>
            else
<span class="fc" id="L2678">                return m.findNear(hi, LT, cmp);</span>
        }

        /**
         * Returns lowest absolute key (ignoring directonality).
         */
        K lowestKey() {
<span class="fc" id="L2685">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc" id="L2686">            ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2687" title="All 2 branches covered.">            if (isBeforeEnd(n, cmp))</span>
<span class="fc" id="L2688">                return n.key;</span>
            else
<span class="fc" id="L2690">                throw new NoSuchElementException();</span>
        }

        /**
         * Returns highest absolute key (ignoring directonality).
         */
        K highestKey() {
<span class="fc" id="L2697">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc" id="L2698">            ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</span>
<span class="fc bfc" id="L2699" title="All 2 branches covered.">            if (n != null) {</span>
<span class="fc" id="L2700">                K last = n.key;</span>
<span class="fc bfc" id="L2701" title="All 2 branches covered.">                if (inBounds(last, cmp))</span>
<span class="fc" id="L2702">                    return last;</span>
            }
<span class="fc" id="L2704">            throw new NoSuchElementException();</span>
        }

        Map.Entry&lt;K,V&gt; lowestEntry() {
<span class="fc" id="L2708">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
            for (;;) {
<span class="fc" id="L2710">                ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2711" title="All 2 branches covered.">                if (!isBeforeEnd(n, cmp))</span>
<span class="fc" id="L2712">                    return null;</span>
<span class="fc" id="L2713">                Map.Entry&lt;K,V&gt; e = n.createSnapshot();</span>
<span class="pc bpc" id="L2714" title="1 of 2 branches missed.">                if (e != null)</span>
<span class="fc" id="L2715">                    return e;</span>
<span class="nc" id="L2716">            }</span>
        }

        Map.Entry&lt;K,V&gt; highestEntry() {
<span class="fc" id="L2720">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
            for (;;) {
<span class="fc" id="L2722">                ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</span>
<span class="pc bpc" id="L2723" title="1 of 4 branches missed.">                if (n == null || !inBounds(n.key, cmp))</span>
<span class="fc" id="L2724">                    return null;</span>
<span class="fc" id="L2725">                Map.Entry&lt;K,V&gt; e = n.createSnapshot();</span>
<span class="pc bpc" id="L2726" title="1 of 2 branches missed.">                if (e != null)</span>
<span class="fc" id="L2727">                    return e;</span>
<span class="nc" id="L2728">            }</span>
        }

        Map.Entry&lt;K,V&gt; removeLowest() {
<span class="fc" id="L2732">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
            for (;;) {
<span class="fc" id="L2734">                Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2735" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc" id="L2736">                    return null;</span>
<span class="fc" id="L2737">                K k = n.key;</span>
<span class="pc bpc" id="L2738" title="1 of 2 branches missed.">                if (!inBounds(k, cmp))</span>
<span class="nc" id="L2739">                    return null;</span>
<span class="fc" id="L2740">                V v = m.doRemove(k, null);</span>
<span class="pc bpc" id="L2741" title="1 of 2 branches missed.">                if (v != null)</span>
<span class="fc" id="L2742">                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</span>
<span class="nc" id="L2743">            }</span>
        }

        Map.Entry&lt;K,V&gt; removeHighest() {
<span class="fc" id="L2747">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
            for (;;) {
<span class="fc" id="L2749">                Node&lt;K,V&gt; n = hiNode(cmp);</span>
<span class="fc bfc" id="L2750" title="All 2 branches covered.">                if (n == null)</span>
<span class="fc" id="L2751">                    return null;</span>
<span class="fc" id="L2752">                K k = n.key;</span>
<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">                if (!inBounds(k, cmp))</span>
<span class="nc" id="L2754">                    return null;</span>
<span class="fc" id="L2755">                V v = m.doRemove(k, null);</span>
<span class="pc bpc" id="L2756" title="1 of 2 branches missed.">                if (v != null)</span>
<span class="fc" id="L2757">                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</span>
<span class="nc" id="L2758">            }</span>
        }

        /**
         * Submap version of ConcurrentSkipListMap.getNearEntry
         */
        Map.Entry&lt;K,V&gt; getNearEntry(K key, int rel) {
<span class="fc" id="L2765">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc bfc" id="L2766" title="All 2 branches covered.">            if (isDescending) { // adjust relation for direction</span>
<span class="fc bfc" id="L2767" title="All 2 branches covered.">                if ((rel &amp; LT) == 0)</span>
<span class="fc" id="L2768">                    rel |= LT;</span>
                else
<span class="fc" id="L2770">                    rel &amp;= ~LT;</span>
            }
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">            if (tooLow(key, cmp))</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">                return ((rel &amp; LT) != 0) ? null : lowestEntry();</span>
<span class="pc bpc" id="L2774" title="1 of 2 branches missed.">            if (tooHigh(key, cmp))</span>
<span class="nc bnc" id="L2775" title="All 2 branches missed.">                return ((rel &amp; LT) != 0) ? highestEntry() : null;</span>
            for (;;) {
<span class="fc" id="L2777">                Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);</span>
<span class="pc bpc" id="L2778" title="1 of 4 branches missed.">                if (n == null || !inBounds(n.key, cmp))</span>
<span class="fc" id="L2779">                    return null;</span>
<span class="fc" id="L2780">                K k = n.key;</span>
<span class="fc" id="L2781">                V v = n.getValidValue();</span>
<span class="pc bpc" id="L2782" title="1 of 2 branches missed.">                if (v != null)</span>
<span class="fc" id="L2783">                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</span>
<span class="nc" id="L2784">            }</span>
        }

        // Almost the same as getNearEntry, except for keys
        K getNearKey(K key, int rel) {
<span class="fc" id="L2789">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc bfc" id="L2790" title="All 2 branches covered.">            if (isDescending) { // adjust relation for direction</span>
<span class="fc bfc" id="L2791" title="All 2 branches covered.">                if ((rel &amp; LT) == 0)</span>
<span class="fc" id="L2792">                    rel |= LT;</span>
                else
<span class="fc" id="L2794">                    rel &amp;= ~LT;</span>
            }
<span class="fc bfc" id="L2796" title="All 2 branches covered.">            if (tooLow(key, cmp)) {</span>
<span class="fc bfc" id="L2797" title="All 2 branches covered.">                if ((rel &amp; LT) == 0) {</span>
<span class="fc" id="L2798">                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2799" title="All 2 branches covered.">                    if (isBeforeEnd(n, cmp))</span>
<span class="fc" id="L2800">                        return n.key;</span>
                }
<span class="fc" id="L2802">                return null;</span>
            }
<span class="fc bfc" id="L2804" title="All 2 branches covered.">            if (tooHigh(key, cmp)) {</span>
<span class="fc bfc" id="L2805" title="All 2 branches covered.">                if ((rel &amp; LT) != 0) {</span>
<span class="fc" id="L2806">                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);</span>
<span class="fc bfc" id="L2807" title="All 2 branches covered.">                    if (n != null) {</span>
<span class="fc" id="L2808">                        K last = n.key;</span>
<span class="fc bfc" id="L2809" title="All 2 branches covered.">                        if (inBounds(last, cmp))</span>
<span class="fc" id="L2810">                            return last;</span>
                    }
                }
<span class="fc" id="L2813">                return null;</span>
            }
            for (;;) {
<span class="fc" id="L2816">                Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);</span>
<span class="fc bfc" id="L2817" title="All 4 branches covered.">                if (n == null || !inBounds(n.key, cmp))</span>
<span class="fc" id="L2818">                    return null;</span>
<span class="fc" id="L2819">                K k = n.key;</span>
<span class="fc" id="L2820">                V v = n.getValidValue();</span>
<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">                if (v != null)</span>
<span class="fc" id="L2822">                    return k;</span>
<span class="nc" id="L2823">            }</span>
        }

        /* ----------------  Map API methods -------------- */

        public boolean containsKey(Object key) {
<span class="fc bfc" id="L2829" title="All 2 branches covered.">            if (key == null) throw new NullPointerException();</span>
<span class="pc bpc" id="L2830" title="1 of 4 branches missed.">            return inBounds(key, m.comparator) &amp;&amp; m.containsKey(key);</span>
        }

        public V get(Object key) {
<span class="pc bpc" id="L2834" title="1 of 2 branches missed.">            if (key == null) throw new NullPointerException();</span>
<span class="pc bpc" id="L2835" title="1 of 2 branches missed.">            return (!inBounds(key, m.comparator)) ? null : m.get(key);</span>
        }

        public V put(K key, V value) {
<span class="fc" id="L2839">            checkKeyBounds(key, m.comparator);</span>
<span class="fc" id="L2840">            return m.put(key, value);</span>
        }

        public V remove(Object key) {
<span class="pc bpc" id="L2844" title="1 of 2 branches missed.">            return (!inBounds(key, m.comparator)) ? null : m.remove(key);</span>
        }

        public int size() {
<span class="fc" id="L2848">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc" id="L2849">            long count = 0;</span>
<span class="fc" id="L2850">            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2851" title="All 2 branches covered.">                 isBeforeEnd(n, cmp);</span>
<span class="fc" id="L2852">                 n = n.next) {</span>
<span class="pc bpc" id="L2853" title="1 of 2 branches missed.">                if (n.getValidValue() != null)</span>
<span class="fc" id="L2854">                    ++count;</span>
            }
<span class="pc bpc" id="L2856" title="1 of 2 branches missed.">            return count &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)count;</span>
        }

        public boolean isEmpty() {
<span class="fc" id="L2860">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc bfc" id="L2861" title="All 2 branches covered.">            return !isBeforeEnd(loNode(cmp), cmp);</span>
        }

        public boolean containsValue(Object value) {
<span class="fc bfc" id="L2865" title="All 2 branches covered.">            if (value == null)</span>
<span class="fc" id="L2866">                throw new NullPointerException();</span>
<span class="fc" id="L2867">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc" id="L2868">            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2869" title="All 2 branches covered.">                 isBeforeEnd(n, cmp);</span>
<span class="fc" id="L2870">                 n = n.next) {</span>
<span class="fc" id="L2871">                V v = n.getValidValue();</span>
<span class="pc bpc" id="L2872" title="1 of 4 branches missed.">                if (v != null &amp;&amp; value.equals(v))</span>
<span class="fc" id="L2873">                    return true;</span>
            }
<span class="fc" id="L2875">            return false;</span>
        }

        public void clear() {
<span class="fc" id="L2879">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc" id="L2880">            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</span>
<span class="fc bfc" id="L2881" title="All 2 branches covered.">                 isBeforeEnd(n, cmp);</span>
<span class="fc" id="L2882">                 n = n.next) {</span>
<span class="fc bfc" id="L2883" title="All 2 branches covered.">                if (n.getValidValue() != null)</span>
<span class="fc" id="L2884">                    m.remove(n.key);</span>
            }
<span class="fc" id="L2886">        }</span>

        /* ----------------  ConcurrentMap API methods -------------- */

        public V putIfAbsent(K key, V value) {
<span class="fc" id="L2891">            checkKeyBounds(key, m.comparator);</span>
<span class="fc" id="L2892">            return m.putIfAbsent(key, value);</span>
        }

        public boolean remove(Object key, Object value) {
<span class="pc bpc" id="L2896" title="1 of 4 branches missed.">            return inBounds(key, m.comparator) &amp;&amp; m.remove(key, value);</span>
        }

        public boolean replace(K key, V oldValue, V newValue) {
<span class="nc" id="L2900">            checkKeyBounds(key, m.comparator);</span>
<span class="nc" id="L2901">            return m.replace(key, oldValue, newValue);</span>
        }

        public V replace(K key, V value) {
<span class="nc" id="L2905">            checkKeyBounds(key, m.comparator);</span>
<span class="nc" id="L2906">            return m.replace(key, value);</span>
        }

        /* ----------------  SortedMap API methods -------------- */

        public Comparator&lt;? super K&gt; comparator() {
<span class="fc" id="L2912">            Comparator&lt;? super K&gt; cmp = m.comparator();</span>
<span class="fc bfc" id="L2913" title="All 2 branches covered.">            if (isDescending)</span>
<span class="fc" id="L2914">                return Collections.reverseOrder(cmp);</span>
            else
<span class="fc" id="L2916">                return cmp;</span>
        }

        /**
         * Utility to create submaps, where given bounds override
         * unbounded(null) ones and/or are checked against bounded ones.
         */
        SubMap&lt;K,V&gt; newSubMap(K fromKey, boolean fromInclusive,
                              K toKey, boolean toInclusive) {
<span class="fc" id="L2925">            Comparator&lt;? super K&gt; cmp = m.comparator;</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">            if (isDescending) { // flip senses</span>
<span class="fc" id="L2927">                K tk = fromKey;</span>
<span class="fc" id="L2928">                fromKey = toKey;</span>
<span class="fc" id="L2929">                toKey = tk;</span>
<span class="fc" id="L2930">                boolean ti = fromInclusive;</span>
<span class="fc" id="L2931">                fromInclusive = toInclusive;</span>
<span class="fc" id="L2932">                toInclusive = ti;</span>
            }
<span class="fc bfc" id="L2934" title="All 2 branches covered.">            if (lo != null) {</span>
<span class="fc bfc" id="L2935" title="All 2 branches covered.">                if (fromKey == null) {</span>
<span class="fc" id="L2936">                    fromKey = lo;</span>
<span class="fc" id="L2937">                    fromInclusive = loInclusive;</span>
                }
                else {
<span class="fc" id="L2940">                    int c = cpr(cmp, fromKey, lo);</span>
<span class="pc bpc" id="L2941" title="2 of 8 branches missed.">                    if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive &amp;&amp; fromInclusive))</span>
<span class="fc" id="L2942">                        throw new IllegalArgumentException(&quot;key out of range&quot;);</span>
                }
            }
<span class="fc bfc" id="L2945" title="All 2 branches covered.">            if (hi != null) {</span>
<span class="fc bfc" id="L2946" title="All 2 branches covered.">                if (toKey == null) {</span>
<span class="fc" id="L2947">                    toKey = hi;</span>
<span class="fc" id="L2948">                    toInclusive = hiInclusive;</span>
                }
                else {
<span class="fc" id="L2951">                    int c = cpr(cmp, toKey, hi);</span>
<span class="pc bpc" id="L2952" title="2 of 8 branches missed.">                    if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive &amp;&amp; toInclusive))</span>
<span class="fc" id="L2953">                        throw new IllegalArgumentException(&quot;key out of range&quot;);</span>
                }
            }
<span class="fc" id="L2956">            return new SubMap&lt;K,V&gt;(m, fromKey, fromInclusive,</span>
                                   toKey, toInclusive, isDescending);
        }

        public SubMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                                  K toKey, boolean toInclusive) {
<span class="pc bpc" id="L2962" title="2 of 4 branches missed.">            if (fromKey == null || toKey == null)</span>
<span class="nc" id="L2963">                throw new NullPointerException();</span>
<span class="fc" id="L2964">            return newSubMap(fromKey, fromInclusive, toKey, toInclusive);</span>
        }

        public SubMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
<span class="pc bpc" id="L2968" title="1 of 2 branches missed.">            if (toKey == null)</span>
<span class="nc" id="L2969">                throw new NullPointerException();</span>
<span class="fc" id="L2970">            return newSubMap(null, false, toKey, inclusive);</span>
        }

        public SubMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
<span class="pc bpc" id="L2974" title="1 of 2 branches missed.">            if (fromKey == null)</span>
<span class="nc" id="L2975">                throw new NullPointerException();</span>
<span class="fc" id="L2976">            return newSubMap(fromKey, inclusive, null, false);</span>
        }

        public SubMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<span class="fc" id="L2980">            return subMap(fromKey, true, toKey, false);</span>
        }

        public SubMap&lt;K,V&gt; headMap(K toKey) {
<span class="fc" id="L2984">            return headMap(toKey, false);</span>
        }

        public SubMap&lt;K,V&gt; tailMap(K fromKey) {
<span class="fc" id="L2988">            return tailMap(fromKey, true);</span>
        }

        public SubMap&lt;K,V&gt; descendingMap() {
<span class="fc bfc" id="L2992" title="All 2 branches covered.">            return new SubMap&lt;K,V&gt;(m, lo, loInclusive,</span>
                                   hi, hiInclusive, !isDescending);
        }

        /* ----------------  Relational methods -------------- */

        public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<span class="fc" id="L2999">            return getNearEntry(key, GT|EQ);</span>
        }

        public K ceilingKey(K key) {
<span class="fc" id="L3003">            return getNearKey(key, GT|EQ);</span>
        }

        public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<span class="fc" id="L3007">            return getNearEntry(key, LT);</span>
        }

        public K lowerKey(K key) {
<span class="fc" id="L3011">            return getNearKey(key, LT);</span>
        }

        public Map.Entry&lt;K,V&gt; floorEntry(K key) {
<span class="fc" id="L3015">            return getNearEntry(key, LT|EQ);</span>
        }

        public K floorKey(K key) {
<span class="fc" id="L3019">            return getNearKey(key, LT|EQ);</span>
        }

        public Map.Entry&lt;K,V&gt; higherEntry(K key) {
<span class="fc" id="L3023">            return getNearEntry(key, GT);</span>
        }

        public K higherKey(K key) {
<span class="fc" id="L3027">            return getNearKey(key, GT);</span>
        }

        public K firstKey() {
<span class="fc bfc" id="L3031" title="All 2 branches covered.">            return isDescending ? highestKey() : lowestKey();</span>
        }

        public K lastKey() {
<span class="fc bfc" id="L3035" title="All 2 branches covered.">            return isDescending ? lowestKey() : highestKey();</span>
        }

        public Map.Entry&lt;K,V&gt; firstEntry() {
<span class="fc bfc" id="L3039" title="All 2 branches covered.">            return isDescending ? highestEntry() : lowestEntry();</span>
        }

        public Map.Entry&lt;K,V&gt; lastEntry() {
<span class="fc bfc" id="L3043" title="All 2 branches covered.">            return isDescending ? lowestEntry() : highestEntry();</span>
        }

        public Map.Entry&lt;K,V&gt; pollFirstEntry() {
<span class="fc bfc" id="L3047" title="All 2 branches covered.">            return isDescending ? removeHighest() : removeLowest();</span>
        }

        public Map.Entry&lt;K,V&gt; pollLastEntry() {
<span class="fc bfc" id="L3051" title="All 2 branches covered.">            return isDescending ? removeLowest() : removeHighest();</span>
        }

        /* ---------------- Submap Views -------------- */

        public NavigableSet&lt;K&gt; keySet() {
<span class="fc" id="L3057">            KeySet&lt;K&gt; ks = keySetView;</span>
<span class="fc bfc" id="L3058" title="All 2 branches covered.">            return (ks != null) ? ks : (keySetView = new KeySet&lt;K&gt;(this));</span>
        }

        public NavigableSet&lt;K&gt; navigableKeySet() {
<span class="fc" id="L3062">            KeySet&lt;K&gt; ks = keySetView;</span>
<span class="fc bfc" id="L3063" title="All 2 branches covered.">            return (ks != null) ? ks : (keySetView = new KeySet&lt;K&gt;(this));</span>
        }

        public Collection&lt;V&gt; values() {
<span class="fc" id="L3067">            Collection&lt;V&gt; vs = valuesView;</span>
<span class="fc bfc" id="L3068" title="All 2 branches covered.">            return (vs != null) ? vs : (valuesView = new Values&lt;V&gt;(this));</span>
        }

        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L3072">            Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySetView;</span>
<span class="fc bfc" id="L3073" title="All 2 branches covered.">            return (es != null) ? es : (entrySetView = new EntrySet&lt;K,V&gt;(this));</span>
        }

        public NavigableSet&lt;K&gt; descendingKeySet() {
<span class="fc" id="L3077">            return descendingMap().navigableKeySet();</span>
        }

        Iterator&lt;K&gt; keyIterator() {
<span class="fc" id="L3081">            return new SubMapKeyIterator();</span>
        }

        Iterator&lt;V&gt; valueIterator() {
<span class="fc" id="L3085">            return new SubMapValueIterator();</span>
        }

        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; entryIterator() {
<span class="fc" id="L3089">            return new SubMapEntryIterator();</span>
        }

        /**
         * Variant of main Iter class to traverse through submaps.
         * Also serves as back-up Spliterator for views
         */
        abstract class SubMapIter&lt;T&gt; implements Iterator&lt;T&gt;, Spliterator&lt;T&gt; {
            /** the last node returned by next() */
            Node&lt;K,V&gt; lastReturned;
            /** the next node to return from next(); */
            Node&lt;K,V&gt; next;
            /** Cache of next value field to maintain weak consistency */
            V nextValue;

<span class="fc" id="L3104">            SubMapIter() {</span>
<span class="fc" id="L3105">                Comparator&lt;? super K&gt; cmp = m.comparator;</span>
                for (;;) {
<span class="fc bfc" id="L3107" title="All 2 branches covered.">                    next = isDescending ? hiNode(cmp) : loNode(cmp);</span>
<span class="fc bfc" id="L3108" title="All 2 branches covered.">                    if (next == null)</span>
<span class="fc" id="L3109">                        break;</span>
<span class="fc" id="L3110">                    Object x = next.value;</span>
<span class="pc bpc" id="L3111" title="2 of 4 branches missed.">                    if (x != null &amp;&amp; x != next) {</span>
<span class="fc bfc" id="L3112" title="All 2 branches covered.">                        if (! inBounds(next.key, cmp))</span>
<span class="fc" id="L3113">                            next = null;</span>
                        else {
<span class="fc" id="L3115">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</span>
<span class="fc" id="L3116">                            nextValue = vv;</span>
                        }
<span class="fc" id="L3118">                        break;</span>
                    }
<span class="nc" id="L3120">                }</span>
<span class="fc" id="L3121">            }</span>

            public final boolean hasNext() {
<span class="fc bfc" id="L3124" title="All 2 branches covered.">                return next != null;</span>
            }

            final void advance() {
<span class="fc bfc" id="L3128" title="All 2 branches covered.">                if (next == null)</span>
<span class="fc" id="L3129">                    throw new NoSuchElementException();</span>
<span class="fc" id="L3130">                lastReturned = next;</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">                if (isDescending)</span>
<span class="fc" id="L3132">                    descend();</span>
                else
<span class="fc" id="L3134">                    ascend();</span>
<span class="fc" id="L3135">            }</span>

            private void ascend() {
<span class="fc" id="L3138">                Comparator&lt;? super K&gt; cmp = m.comparator;</span>
                for (;;) {
<span class="fc" id="L3140">                    next = next.next;</span>
<span class="fc bfc" id="L3141" title="All 2 branches covered.">                    if (next == null)</span>
<span class="fc" id="L3142">                        break;</span>
<span class="fc" id="L3143">                    Object x = next.value;</span>
<span class="pc bpc" id="L3144" title="2 of 4 branches missed.">                    if (x != null &amp;&amp; x != next) {</span>
<span class="fc bfc" id="L3145" title="All 2 branches covered.">                        if (tooHigh(next.key, cmp))</span>
<span class="fc" id="L3146">                            next = null;</span>
                        else {
<span class="fc" id="L3148">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</span>
<span class="fc" id="L3149">                            nextValue = vv;</span>
                        }
<span class="fc" id="L3151">                        break;</span>
                    }
<span class="nc" id="L3153">                }</span>
<span class="fc" id="L3154">            }</span>

            private void descend() {
<span class="fc" id="L3157">                Comparator&lt;? super K&gt; cmp = m.comparator;</span>
                for (;;) {
<span class="fc" id="L3159">                    next = m.findNear(lastReturned.key, LT, cmp);</span>
<span class="fc bfc" id="L3160" title="All 2 branches covered.">                    if (next == null)</span>
<span class="fc" id="L3161">                        break;</span>
<span class="fc" id="L3162">                    Object x = next.value;</span>
<span class="pc bpc" id="L3163" title="2 of 4 branches missed.">                    if (x != null &amp;&amp; x != next) {</span>
<span class="fc bfc" id="L3164" title="All 2 branches covered.">                        if (tooLow(next.key, cmp))</span>
<span class="fc" id="L3165">                            next = null;</span>
                        else {
<span class="fc" id="L3167">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)x;</span>
<span class="fc" id="L3168">                            nextValue = vv;</span>
                        }
<span class="fc" id="L3170">                        break;</span>
                    }
<span class="nc" id="L3172">                }</span>
<span class="fc" id="L3173">            }</span>

            public void remove() {
<span class="fc" id="L3176">                Node&lt;K,V&gt; l = lastReturned;</span>
<span class="fc bfc" id="L3177" title="All 2 branches covered.">                if (l == null)</span>
<span class="fc" id="L3178">                    throw new IllegalStateException();</span>
<span class="fc" id="L3179">                m.remove(l.key);</span>
<span class="fc" id="L3180">                lastReturned = null;</span>
<span class="fc" id="L3181">            }</span>

            public Spliterator&lt;T&gt; trySplit() {
<span class="nc" id="L3184">                return null;</span>
            }

            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                if (hasNext()) {</span>
<span class="nc" id="L3189">                    action.accept(next());</span>
<span class="nc" id="L3190">                    return true;</span>
                }
<span class="nc" id="L3192">                return false;</span>
            }

            public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                while (hasNext())</span>
<span class="nc" id="L3197">                    action.accept(next());</span>
<span class="nc" id="L3198">            }</span>

            public long estimateSize() {
<span class="nc" id="L3201">                return Long.MAX_VALUE;</span>
            }

        }

<span class="fc" id="L3206">        final class SubMapValueIterator extends SubMapIter&lt;V&gt; {</span>
            public V next() {
<span class="fc" id="L3208">                V v = nextValue;</span>
<span class="fc" id="L3209">                advance();</span>
<span class="fc" id="L3210">                return v;</span>
            }
            public int characteristics() {
<span class="nc" id="L3213">                return 0;</span>
            }
        }

<span class="fc" id="L3217">        final class SubMapKeyIterator extends SubMapIter&lt;K&gt; {</span>
            public K next() {
<span class="fc" id="L3219">                Node&lt;K,V&gt; n = next;</span>
<span class="fc" id="L3220">                advance();</span>
<span class="fc" id="L3221">                return n.key;</span>
            }
            public int characteristics() {
<span class="nc" id="L3224">                return Spliterator.DISTINCT | Spliterator.ORDERED |</span>
                    Spliterator.SORTED;
            }
            public final Comparator&lt;? super K&gt; getComparator() {
<span class="nc" id="L3228">                return SubMap.this.comparator();</span>
            }
        }

<span class="fc" id="L3232">        final class SubMapEntryIterator extends SubMapIter&lt;Map.Entry&lt;K,V&gt;&gt; {</span>
            public Map.Entry&lt;K,V&gt; next() {
<span class="fc" id="L3234">                Node&lt;K,V&gt; n = next;</span>
<span class="fc" id="L3235">                V v = nextValue;</span>
<span class="fc" id="L3236">                advance();</span>
<span class="fc" id="L3237">                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</span>
            }
            public int characteristics() {
<span class="nc" id="L3240">                return Spliterator.DISTINCT;</span>
            }
        }
    }

    // default Map method overrides

    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="nc bnc" id="L3248" title="All 2 branches missed.">        if (action == null) throw new NullPointerException();</span>
        V v;
<span class="nc bnc" id="L3250" title="All 2 branches missed.">        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</span>
<span class="nc bnc" id="L3251" title="All 2 branches missed.">            if ((v = n.getValidValue()) != null)</span>
<span class="nc" id="L3252">                action.accept(n.key, v);</span>
        }
<span class="nc" id="L3254">    }</span>

    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<span class="nc bnc" id="L3257" title="All 2 branches missed.">        if (function == null) throw new NullPointerException();</span>
        V v;
<span class="nc bnc" id="L3259" title="All 2 branches missed.">        for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) {</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">            while ((v = n.getValidValue()) != null) {</span>
<span class="nc" id="L3261">                V r = function.apply(n.key, v);</span>
<span class="nc bnc" id="L3262" title="All 2 branches missed.">                if (r == null) throw new NullPointerException();</span>
<span class="nc bnc" id="L3263" title="All 2 branches missed.">                if (n.casValue(v, r))</span>
<span class="nc" id="L3264">                    break;</span>
<span class="nc" id="L3265">            }</span>
        }
<span class="nc" id="L3267">    }</span>

    /**
     * Base class providing common structure for Spliterators.
     * (Although not all that much common functionality; as usual for
     * view classes, details annoyingly vary in key, value, and entry
     * subclasses in ways that are not worth abstracting out for
     * internal classes.)
     *
     * The basic split strategy is to recursively descend from top
     * level, row by row, descending to next row when either split
     * off, or the end of row is encountered. Control of the number of
     * splits relies on some statistical estimation: The expected
     * remaining number of elements of a skip list when advancing
     * either across or down decreases by about 25%. To make this
     * observation useful, we need to know initial size, which we
     * don't. But we can just use Integer.MAX_VALUE so that we
     * don't prematurely zero out while splitting.
     */
    abstract static class CSLMSpliterator&lt;K,V&gt; {
        final Comparator&lt;? super K&gt; comparator;
        final K fence;     // exclusive upper bound for keys, or null if to end
        Index&lt;K,V&gt; row;    // the level to split out
        Node&lt;K,V&gt; current; // current traversal node; initialize at origin
        int est;           // pseudo-size estimate
        CSLMSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
<span class="fc" id="L3293">                        Node&lt;K,V&gt; origin, K fence, int est) {</span>
<span class="fc" id="L3294">            this.comparator = comparator; this.row = row;</span>
<span class="fc" id="L3295">            this.current = origin; this.fence = fence; this.est = est;</span>
<span class="fc" id="L3296">        }</span>

<span class="nc" id="L3298">        public final long estimateSize() { return (long)est; }</span>
    }

    static final class KeySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
        implements Spliterator&lt;K&gt; {
        KeySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
                       Node&lt;K,V&gt; origin, K fence, int est) {
<span class="fc" id="L3305">            super(comparator, row, origin, fence, est);</span>
<span class="fc" id="L3306">        }</span>

        public Spliterator&lt;K&gt; trySplit() {
            Node&lt;K,V&gt; e; K ek;
<span class="nc" id="L3310">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3311">            K f = fence;</span>
<span class="nc bnc" id="L3312" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</span>
<span class="nc bnc" id="L3313" title="All 2 branches missed.">                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</span>
                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
<span class="nc bnc" id="L3315" title="All 10 branches missed.">                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</span>
                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;
<span class="nc bnc" id="L3317" title="All 4 branches missed.">                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L3318" title="All 2 branches missed.">                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</span>
<span class="nc" id="L3319">                        current = n;</span>
<span class="nc" id="L3320">                        Index&lt;K,V&gt; r = q.down;</span>
<span class="nc bnc" id="L3321" title="All 2 branches missed.">                        row = (s.right != null) ? s : s.down;</span>
<span class="nc" id="L3322">                        est -= est &gt;&gt;&gt; 2;</span>
<span class="nc" id="L3323">                        return new KeySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</span>
                    }
                }
            }
<span class="nc" id="L3327">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L3331" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3332">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3333">            K f = fence;</span>
<span class="nc" id="L3334">            Node&lt;K,V&gt; e = current;</span>
<span class="nc" id="L3335">            current = null;</span>
<span class="nc bnc" id="L3336" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3338" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</span>
<span class="nc" id="L3339">                    break;</span>
<span class="nc bnc" id="L3340" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e)</span>
<span class="nc" id="L3341">                    action.accept(k);</span>
            }
<span class="nc" id="L3343">        }</span>

        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
<span class="nc bnc" id="L3346" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3347">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3348">            K f = fence;</span>
<span class="nc" id="L3349">            Node&lt;K,V&gt; e = current;</span>
<span class="nc bnc" id="L3350" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3352" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</span>
<span class="nc" id="L3353">                    e = null;</span>
<span class="nc" id="L3354">                    break;</span>
                }
<span class="nc bnc" id="L3356" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e) {</span>
<span class="nc" id="L3357">                    current = e.next;</span>
<span class="nc" id="L3358">                    action.accept(k);</span>
<span class="nc" id="L3359">                    return true;</span>
                }
            }
<span class="nc" id="L3362">            current = e;</span>
<span class="nc" id="L3363">            return false;</span>
        }

        public int characteristics() {
<span class="fc" id="L3367">            return Spliterator.DISTINCT | Spliterator.SORTED |</span>
                Spliterator.ORDERED | Spliterator.CONCURRENT |
                Spliterator.NONNULL;
        }

        public final Comparator&lt;? super K&gt; getComparator() {
<span class="fc" id="L3373">            return comparator;</span>
        }
    }
    // factory method for KeySpliterator
    final KeySpliterator&lt;K,V&gt; keySpliterator() {
<span class="fc" id="L3378">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        for (;;) { // ensure h corresponds to origin p
            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;
<span class="fc" id="L3381">            Node&lt;K,V&gt; b = (h = head).node;</span>
<span class="pc bpc" id="L3382" title="2 of 4 branches missed.">            if ((p = b.next) == null || p.value != null)</span>
<span class="pc bpc" id="L3383" title="1 of 2 branches missed.">                return new KeySpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</span>
                                               0 : Integer.MAX_VALUE);
<span class="nc" id="L3385">            p.helpDelete(b, p.next);</span>
<span class="nc" id="L3386">        }</span>
    }

    static final class ValueSpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
        implements Spliterator&lt;V&gt; {
        ValueSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
                       Node&lt;K,V&gt; origin, K fence, int est) {
<span class="fc" id="L3393">            super(comparator, row, origin, fence, est);</span>
<span class="fc" id="L3394">        }</span>

        public Spliterator&lt;V&gt; trySplit() {
            Node&lt;K,V&gt; e; K ek;
<span class="nc" id="L3398">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3399">            K f = fence;</span>
<span class="nc bnc" id="L3400" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</span>
<span class="nc bnc" id="L3401" title="All 2 branches missed.">                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</span>
                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
<span class="nc bnc" id="L3403" title="All 10 branches missed.">                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</span>
                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;
<span class="nc bnc" id="L3405" title="All 4 branches missed.">                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L3406" title="All 2 branches missed.">                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</span>
<span class="nc" id="L3407">                        current = n;</span>
<span class="nc" id="L3408">                        Index&lt;K,V&gt; r = q.down;</span>
<span class="nc bnc" id="L3409" title="All 2 branches missed.">                        row = (s.right != null) ? s : s.down;</span>
<span class="nc" id="L3410">                        est -= est &gt;&gt;&gt; 2;</span>
<span class="nc" id="L3411">                        return new ValueSpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</span>
                    }
                }
            }
<span class="nc" id="L3415">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super V&gt; action) {
<span class="nc bnc" id="L3419" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3420">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3421">            K f = fence;</span>
<span class="nc" id="L3422">            Node&lt;K,V&gt; e = current;</span>
<span class="nc" id="L3423">            current = null;</span>
<span class="nc bnc" id="L3424" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3426" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</span>
<span class="nc" id="L3427">                    break;</span>
<span class="nc bnc" id="L3428" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e) {</span>
<span class="nc" id="L3429">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="nc" id="L3430">                    action.accept(vv);</span>
                }
            }
<span class="nc" id="L3433">        }</span>

        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
<span class="nc bnc" id="L3436" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3437">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3438">            K f = fence;</span>
<span class="nc" id="L3439">            Node&lt;K,V&gt; e = current;</span>
<span class="nc bnc" id="L3440" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3442" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</span>
<span class="nc" id="L3443">                    e = null;</span>
<span class="nc" id="L3444">                    break;</span>
                }
<span class="nc bnc" id="L3446" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e) {</span>
<span class="nc" id="L3447">                    current = e.next;</span>
<span class="nc" id="L3448">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="nc" id="L3449">                    action.accept(vv);</span>
<span class="nc" id="L3450">                    return true;</span>
                }
            }
<span class="nc" id="L3453">            current = e;</span>
<span class="nc" id="L3454">            return false;</span>
        }

        public int characteristics() {
<span class="fc" id="L3458">            return Spliterator.CONCURRENT | Spliterator.ORDERED |</span>
                Spliterator.NONNULL;
        }
    }

    // Almost the same as keySpliterator()
    final ValueSpliterator&lt;K,V&gt; valueSpliterator() {
<span class="fc" id="L3465">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        for (;;) {
            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;
<span class="fc" id="L3468">            Node&lt;K,V&gt; b = (h = head).node;</span>
<span class="pc bpc" id="L3469" title="2 of 4 branches missed.">            if ((p = b.next) == null || p.value != null)</span>
<span class="pc bpc" id="L3470" title="1 of 2 branches missed.">                return new ValueSpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</span>
                                                 0 : Integer.MAX_VALUE);
<span class="nc" id="L3472">            p.helpDelete(b, p.next);</span>
<span class="nc" id="L3473">        }</span>
    }

    static final class EntrySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
        EntrySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,
                         Node&lt;K,V&gt; origin, K fence, int est) {
<span class="fc" id="L3480">            super(comparator, row, origin, fence, est);</span>
<span class="fc" id="L3481">        }</span>

        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; trySplit() {
            Node&lt;K,V&gt; e; K ek;
<span class="nc" id="L3485">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3486">            K f = fence;</span>
<span class="nc bnc" id="L3487" title="All 4 branches missed.">            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</span>
<span class="nc bnc" id="L3488" title="All 2 branches missed.">                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</span>
                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;
<span class="nc bnc" id="L3490" title="All 10 branches missed.">                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</span>
                        (n = b.next) != null &amp;&amp; n.value != null &amp;&amp;
<span class="nc bnc" id="L3492" title="All 4 branches missed.">                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">                        (f == null || cpr(cmp, sk, f) &lt; 0)) {</span>
<span class="nc" id="L3494">                        current = n;</span>
<span class="nc" id="L3495">                        Index&lt;K,V&gt; r = q.down;</span>
<span class="nc bnc" id="L3496" title="All 2 branches missed.">                        row = (s.right != null) ? s : s.down;</span>
<span class="nc" id="L3497">                        est -= est &gt;&gt;&gt; 2;</span>
<span class="nc" id="L3498">                        return new EntrySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</span>
                    }
                }
            }
<span class="nc" id="L3502">            return null;</span>
        }

        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
<span class="nc bnc" id="L3506" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3507">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3508">            K f = fence;</span>
<span class="nc" id="L3509">            Node&lt;K,V&gt; e = current;</span>
<span class="nc" id="L3510">            current = null;</span>
<span class="nc bnc" id="L3511" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3513" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</span>
<span class="nc" id="L3514">                    break;</span>
<span class="nc bnc" id="L3515" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e) {</span>
<span class="nc" id="L3516">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="nc" id="L3517">                    action.accept</span>
<span class="nc" id="L3518">                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, vv));</span>
                }
            }
<span class="nc" id="L3521">        }</span>

        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
<span class="nc bnc" id="L3524" title="All 2 branches missed.">            if (action == null) throw new NullPointerException();</span>
<span class="nc" id="L3525">            Comparator&lt;? super K&gt; cmp = comparator;</span>
<span class="nc" id="L3526">            K f = fence;</span>
<span class="nc" id="L3527">            Node&lt;K,V&gt; e = current;</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">            for (; e != null; e = e.next) {</span>
                K k; Object v;
<span class="nc bnc" id="L3530" title="All 6 branches missed.">                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</span>
<span class="nc" id="L3531">                    e = null;</span>
<span class="nc" id="L3532">                    break;</span>
                }
<span class="nc bnc" id="L3534" title="All 4 branches missed.">                if ((v = e.value) != null &amp;&amp; v != e) {</span>
<span class="nc" id="L3535">                    current = e.next;</span>
<span class="nc" id="L3536">                    @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span>
<span class="nc" id="L3537">                    action.accept</span>
<span class="nc" id="L3538">                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, vv));</span>
<span class="nc" id="L3539">                    return true;</span>
                }
            }
<span class="nc" id="L3542">            current = e;</span>
<span class="nc" id="L3543">            return false;</span>
        }

        public int characteristics() {
<span class="fc" id="L3547">            return Spliterator.DISTINCT | Spliterator.SORTED |</span>
                Spliterator.ORDERED | Spliterator.CONCURRENT |
                Spliterator.NONNULL;
        }

        public final Comparator&lt;Map.Entry&lt;K,V&gt;&gt; getComparator() {
            // Adapt or create a key-based comparator
<span class="pc bpc" id="L3554" title="1 of 2 branches missed.">            if (comparator != null) {</span>
<span class="nc" id="L3555">                return Map.Entry.comparingByKey(comparator);</span>
            }
            else {
<span class="fc" id="L3558">                return (Comparator&lt;Map.Entry&lt;K,V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();
                    return k1.compareTo(e2.getKey());
                };
            }
        }
    }

    // Almost the same as keySpliterator()
    final EntrySpliterator&lt;K,V&gt; entrySpliterator() {
<span class="fc" id="L3569">        Comparator&lt;? super K&gt; cmp = comparator;</span>
        for (;;) { // almost same as key version
            HeadIndex&lt;K,V&gt; h; Node&lt;K,V&gt; p;
<span class="fc" id="L3572">            Node&lt;K,V&gt; b = (h = head).node;</span>
<span class="pc bpc" id="L3573" title="2 of 4 branches missed.">            if ((p = b.next) == null || p.value != null)</span>
<span class="pc bpc" id="L3574" title="1 of 2 branches missed.">                return new EntrySpliterator&lt;K,V&gt;(cmp, h, p, null, (p == null) ?</span>
                                                 0 : Integer.MAX_VALUE);
<span class="nc" id="L3576">            p.helpDelete(b, p.next);</span>
<span class="nc" id="L3577">        }</span>
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long headOffset;
    private static final long SECONDARY;
    static {
        try {
<span class="fc" id="L3586">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L3587">            Class&lt;?&gt; k = ConcurrentSkipListMap.class;</span>
<span class="fc" id="L3588">            headOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L3589">                (k.getDeclaredField(&quot;head&quot;));</span>
<span class="fc" id="L3590">            Class&lt;?&gt; tk = Thread.class;</span>
<span class="fc" id="L3591">            SECONDARY = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L3592">                (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</span>

<span class="nc" id="L3594">        } catch (Exception e) {</span>
<span class="nc" id="L3595">            throw new Error(e);</span>
<span class="fc" id="L3596">        }</span>
<span class="fc" id="L3597">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>