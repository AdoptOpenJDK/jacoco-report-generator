<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduledThreadPoolExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">ScheduledThreadPoolExecutor.java</span></div><h1>ScheduledThreadPoolExecutor.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import static java.util.concurrent.TimeUnit.NANOSECONDS;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.*;

/**
 * A {@link ThreadPoolExecutor} that can additionally schedule
 * commands to run after a given delay, or to execute
 * periodically. This class is preferable to {@link java.util.Timer}
 * when multiple worker threads are needed, or when the additional
 * flexibility or capabilities of {@link ThreadPoolExecutor} (which
 * this class extends) are required.
 *
 * &lt;p&gt;Delayed tasks execute no sooner than they are enabled, but
 * without any real-time guarantees about when, after they are
 * enabled, they will commence. Tasks scheduled for exactly the same
 * execution time are enabled in first-in-first-out (FIFO) order of
 * submission.
 *
 * &lt;p&gt;When a submitted task is cancelled before it is run, execution
 * is suppressed. By default, such a cancelled task is not
 * automatically removed from the work queue until its delay
 * elapses. While this enables further inspection and monitoring, it
 * may also cause unbounded retention of cancelled tasks. To avoid
 * this, set {@link #setRemoveOnCancelPolicy} to {@code true}, which
 * causes tasks to be immediately removed from the work queue at
 * time of cancellation.
 *
 * &lt;p&gt;Successive executions of a task scheduled via
 * {@code scheduleAtFixedRate} or
 * {@code scheduleWithFixedDelay} do not overlap. While different
 * executions may be performed by different threads, the effects of
 * prior executions &lt;a
 * href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;
 * those of subsequent ones.
 *
 * &lt;p&gt;While this class inherits from {@link ThreadPoolExecutor}, a few
 * of the inherited tuning methods are not useful for it. In
 * particular, because it acts as a fixed-sized pool using
 * {@code corePoolSize} threads and an unbounded queue, adjustments
 * to {@code maximumPoolSize} have no useful effect. Additionally, it
 * is almost never a good idea to set {@code corePoolSize} to zero or
 * use {@code allowCoreThreadTimeOut} because this may leave the pool
 * without threads to handle tasks once they become eligible to run.
 *
 * &lt;p&gt;&lt;b&gt;Extension notes:&lt;/b&gt; This class overrides the
 * {@link ThreadPoolExecutor#execute(Runnable) execute} and
 * {@link AbstractExecutorService#submit(Runnable) submit}
 * methods to generate internal {@link ScheduledFuture} objects to
 * control per-task delays and scheduling.  To preserve
 * functionality, any further overrides of these methods in
 * subclasses must invoke superclass versions, which effectively
 * disables additional task customization.  However, this class
 * provides alternative protected extension method
 * {@code decorateTask} (one version each for {@code Runnable} and
 * {@code Callable}) that can be used to customize the concrete task
 * types used to execute commands entered via {@code execute},
 * {@code submit}, {@code schedule}, {@code scheduleAtFixedRate},
 * and {@code scheduleWithFixedDelay}.  By default, a
 * {@code ScheduledThreadPoolExecutor} uses a task type extending
 * {@link FutureTask}. However, this may be modified or replaced using
 * subclasses of the form:
 *
 *  &lt;pre&gt; {@code
 * public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor {
 *
 *   static class CustomTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; { ... }
 *
 *   protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
 *                Runnable r, RunnableScheduledFuture&lt;V&gt; task) {
 *       return new CustomTask&lt;V&gt;(r, task);
 *   }
 *
 *   protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
 *                Callable&lt;V&gt; c, RunnableScheduledFuture&lt;V&gt; task) {
 *       return new CustomTask&lt;V&gt;(c, task);
 *   }
 *   // ... add constructors, etc.
 * }}&lt;/pre&gt;
 *
 * @since 1.5
 * @author Doug Lea
 */
public class ScheduledThreadPoolExecutor
        extends ThreadPoolExecutor
        implements ScheduledExecutorService {

    /*
     * This class specializes ThreadPoolExecutor implementation by
     *
     * 1. Using a custom task type, ScheduledFutureTask for
     *    tasks, even those that don't require scheduling (i.e.,
     *    those submitted using ExecutorService execute, not
     *    ScheduledExecutorService methods) which are treated as
     *    delayed tasks with a delay of zero.
     *
     * 2. Using a custom queue (DelayedWorkQueue), a variant of
     *    unbounded DelayQueue. The lack of capacity constraint and
     *    the fact that corePoolSize and maximumPoolSize are
     *    effectively identical simplifies some execution mechanics
     *    (see delayedExecute) compared to ThreadPoolExecutor.
     *
     * 3. Supporting optional run-after-shutdown parameters, which
     *    leads to overrides of shutdown methods to remove and cancel
     *    tasks that should NOT be run after shutdown, as well as
     *    different recheck logic when task (re)submission overlaps
     *    with a shutdown.
     *
     * 4. Task decoration methods to allow interception and
     *    instrumentation, which are needed because subclasses cannot
     *    otherwise override submit methods to get this effect. These
     *    don't have any impact on pool control logic though.
     */

    /**
     * False if should cancel/suppress periodic tasks on shutdown.
     */
    private volatile boolean continueExistingPeriodicTasksAfterShutdown;

    /**
     * False if should cancel non-periodic tasks on shutdown.
     */
<span class="pc" id="L160">    private volatile boolean executeExistingDelayedTasksAfterShutdown = true;</span>

    /**
     * True if ScheduledFutureTask.cancel should remove from queue
     */
<span class="pc" id="L165">    private volatile boolean removeOnCancel = false;</span>

    /**
     * Sequence number to break scheduling ties, and in turn to
     * guarantee FIFO order among tied entries.
     */
<span class="fc" id="L171">    private static final AtomicLong sequencer = new AtomicLong();</span>

    /**
     * Returns current nanosecond time.
     */
    final long now() {
<span class="fc" id="L177">        return System.nanoTime();</span>
    }

    private class ScheduledFutureTask&lt;V&gt;
            extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; {

        /** Sequence number to break ties FIFO */
        private final long sequenceNumber;

        /** The time the task is enabled to execute in nanoTime units */
        private long time;

        /**
         * Period in nanoseconds for repeating tasks.  A positive
         * value indicates fixed-rate execution.  A negative value
         * indicates fixed-delay execution.  A value of 0 indicates a
         * non-repeating task.
         */
        private final long period;

        /** The actual task to be re-enqueued by reExecutePeriodic */
<span class="fc" id="L198">        RunnableScheduledFuture&lt;V&gt; outerTask = this;</span>

        /**
         * Index into delay queue, to support faster cancellation.
         */
        int heapIndex;

        /**
         * Creates a one-shot action with given nanoTime-based trigger time.
         */
<span class="fc" id="L208">        ScheduledFutureTask(Runnable r, V result, long ns) {</span>
<span class="fc" id="L209">            super(r, result);</span>
<span class="fc" id="L210">            this.time = ns;</span>
<span class="fc" id="L211">            this.period = 0;</span>
<span class="fc" id="L212">            this.sequenceNumber = sequencer.getAndIncrement();</span>
<span class="fc" id="L213">        }</span>

        /**
         * Creates a periodic action with given nano time and period.
         */
<span class="fc" id="L218">        ScheduledFutureTask(Runnable r, V result, long ns, long period) {</span>
<span class="fc" id="L219">            super(r, result);</span>
<span class="fc" id="L220">            this.time = ns;</span>
<span class="fc" id="L221">            this.period = period;</span>
<span class="fc" id="L222">            this.sequenceNumber = sequencer.getAndIncrement();</span>
<span class="fc" id="L223">        }</span>

        /**
         * Creates a one-shot action with given nanoTime-based trigger time.
         */
<span class="fc" id="L228">        ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) {</span>
<span class="fc" id="L229">            super(callable);</span>
<span class="fc" id="L230">            this.time = ns;</span>
<span class="fc" id="L231">            this.period = 0;</span>
<span class="fc" id="L232">            this.sequenceNumber = sequencer.getAndIncrement();</span>
<span class="fc" id="L233">        }</span>

        public long getDelay(TimeUnit unit) {
<span class="fc" id="L236">            return unit.convert(time - now(), NANOSECONDS);</span>
        }

        public int compareTo(Delayed other) {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (other == this) // compare zero if same object</span>
<span class="nc" id="L241">                return 0;</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">            if (other instanceof ScheduledFutureTask) {</span>
<span class="fc" id="L243">                ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span>
<span class="fc" id="L244">                long diff = time - x.time;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                if (diff &lt; 0)</span>
<span class="fc" id="L246">                    return -1;</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                else if (diff &gt; 0)</span>
<span class="fc" id="L248">                    return 1;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">                else if (sequenceNumber &lt; x.sequenceNumber)</span>
<span class="nc" id="L250">                    return -1;</span>
                else
<span class="nc" id="L252">                    return 1;</span>
            }
<span class="nc" id="L254">            long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">            return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;</span>
        }

        /**
         * Returns {@code true} if this is a periodic (not a one-shot) action.
         *
         * @return {@code true} if periodic
         */
        public boolean isPeriodic() {
<span class="fc bfc" id="L264" title="All 2 branches covered.">            return period != 0;</span>
        }

        /**
         * Sets the next time to run for a periodic task.
         */
        private void setNextRunTime() {
<span class="fc" id="L271">            long p = period;</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            if (p &gt; 0)</span>
<span class="nc" id="L273">                time += p;</span>
            else
<span class="fc" id="L275">                time = triggerTime(-p);</span>
<span class="fc" id="L276">        }</span>

        public boolean cancel(boolean mayInterruptIfRunning) {
<span class="fc" id="L279">            boolean cancelled = super.cancel(mayInterruptIfRunning);</span>
<span class="pc bpc" id="L280" title="3 of 6 branches missed.">            if (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= 0)</span>
<span class="nc" id="L281">                remove(this);</span>
<span class="fc" id="L282">            return cancelled;</span>
        }

        /**
         * Overrides FutureTask version so as to reset/requeue if periodic.
         */
        public void run() {
<span class="fc" id="L289">            boolean periodic = isPeriodic();</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            if (!canRunInCurrentRunState(periodic))</span>
<span class="nc" id="L291">                cancel(false);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            else if (!periodic)</span>
<span class="fc" id="L293">                ScheduledFutureTask.super.run();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">            else if (ScheduledFutureTask.super.runAndReset()) {</span>
<span class="fc" id="L295">                setNextRunTime();</span>
<span class="fc" id="L296">                reExecutePeriodic(outerTask);</span>
            }
<span class="fc" id="L298">        }</span>
    }

    /**
     * Returns true if can run a task given current run state
     * and run-after-shutdown parameters.
     *
     * @param periodic true if this task periodic, false if delayed
     */
    boolean canRunInCurrentRunState(boolean periodic) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        return isRunningOrShutdown(periodic ?</span>
                                   continueExistingPeriodicTasksAfterShutdown :
                                   executeExistingDelayedTasksAfterShutdown);
    }

    /**
     * Main execution method for delayed or periodic tasks.  If pool
     * is shut down, rejects the task. Otherwise adds task to queue
     * and starts a thread, if necessary, to run it.  (We cannot
     * prestart the thread to run the task because the task (probably)
     * shouldn't be run yet.)  If the pool is shut down while the task
     * is being added, cancel and remove it if required by state and
     * run-after-shutdown parameters.
     *
     * @param task the task
     */
    private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (isShutdown())</span>
<span class="nc" id="L326">            reject(task);</span>
        else {
<span class="fc" id="L328">            super.getQueue().add(task);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (isShutdown() &amp;&amp;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                remove(task))</span>
<span class="nc" id="L332">                task.cancel(false);</span>
            else
<span class="fc" id="L334">                ensurePrestart();</span>
        }
<span class="fc" id="L336">    }</span>

    /**
     * Requeues a periodic task unless current run state precludes it.
     * Same idea as delayedExecute except drops task rather than rejecting.
     *
     * @param task the task
     */
    void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (canRunInCurrentRunState(true)) {</span>
<span class="fc" id="L346">            super.getQueue().add(task);</span>
<span class="pc bpc" id="L347" title="3 of 4 branches missed.">            if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))</span>
<span class="nc" id="L348">                task.cancel(false);</span>
            else
<span class="fc" id="L350">                ensurePrestart();</span>
        }
<span class="fc" id="L352">    }</span>

    /**
     * Cancels and clears the queue of all tasks that should not be run
     * due to shutdown policy.  Invoked within super.shutdown.
     */
    @Override void onShutdown() {
<span class="fc" id="L359">        BlockingQueue&lt;Runnable&gt; q = super.getQueue();</span>
<span class="fc" id="L360">        boolean keepDelayed =</span>
<span class="fc" id="L361">            getExecuteExistingDelayedTasksAfterShutdownPolicy();</span>
<span class="fc" id="L362">        boolean keepPeriodic =</span>
<span class="fc" id="L363">            getContinueExistingPeriodicTasksAfterShutdownPolicy();</span>
<span class="pc bpc" id="L364" title="3 of 4 branches missed.">        if (!keepDelayed &amp;&amp; !keepPeriodic) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            for (Object e : q.toArray())</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                if (e instanceof RunnableScheduledFuture&lt;?&gt;)</span>
<span class="nc" id="L367">                    ((RunnableScheduledFuture&lt;?&gt;) e).cancel(false);</span>
<span class="nc" id="L368">            q.clear();</span>
        }
        else {
            // Traverse snapshot to avoid iterator exceptions
<span class="fc bfc" id="L372" title="All 2 branches covered.">            for (Object e : q.toArray()) {</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">                if (e instanceof RunnableScheduledFuture) {</span>
<span class="fc" id="L374">                    RunnableScheduledFuture&lt;?&gt; t =</span>
                        (RunnableScheduledFuture&lt;?&gt;)e;
<span class="pc bpc" id="L376" title="4 of 6 branches missed.">                    if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                        t.isCancelled()) { // also remove if already cancelled</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                        if (q.remove(t))</span>
<span class="fc" id="L379">                            t.cancel(false);</span>
                    }
                }
            }
        }
<span class="fc" id="L384">        tryTerminate();</span>
<span class="fc" id="L385">    }</span>

    /**
     * Modifies or replaces the task used to execute a runnable.
     * This method can be used to override the concrete
     * class used for managing internal tasks.
     * The default implementation simply returns the given task.
     *
     * @param runnable the submitted Runnable
     * @param task the task created to execute the runnable
     * @param &lt;V&gt; the type of the task's result
     * @return a task that can execute the runnable
     * @since 1.6
     */
    protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
        Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) {
<span class="fc" id="L401">        return task;</span>
    }

    /**
     * Modifies or replaces the task used to execute a callable.
     * This method can be used to override the concrete
     * class used for managing internal tasks.
     * The default implementation simply returns the given task.
     *
     * @param callable the submitted Callable
     * @param task the task created to execute the callable
     * @param &lt;V&gt; the type of the task's result
     * @return a task that can execute the callable
     * @since 1.6
     */
    protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask(
        Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task) {
<span class="fc" id="L418">        return task;</span>
    }

    /**
     * Creates a new {@code ScheduledThreadPoolExecutor} with the
     * given core pool size.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     */
    public ScheduledThreadPoolExecutor(int corePoolSize) {
<span class="fc" id="L430">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span>
              new DelayedWorkQueue());
<span class="fc" id="L432">    }</span>

    /**
     * Creates a new {@code ScheduledThreadPoolExecutor} with the
     * given initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     * @throws NullPointerException if {@code threadFactory} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       ThreadFactory threadFactory) {
<span class="fc" id="L447">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span>
              new DelayedWorkQueue(), threadFactory);
<span class="fc" id="L449">    }</span>

    /**
     * Creates a new ScheduledThreadPoolExecutor with the given
     * initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     * @throws NullPointerException if {@code handler} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       RejectedExecutionHandler handler) {
<span class="nc" id="L464">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span>
              new DelayedWorkQueue(), handler);
<span class="nc" id="L466">    }</span>

    /**
     * Creates a new ScheduledThreadPoolExecutor with the given
     * initial parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     * @throws NullPointerException if {@code threadFactory} or
     *         {@code handler} is null
     */
    public ScheduledThreadPoolExecutor(int corePoolSize,
                                       ThreadFactory threadFactory,
                                       RejectedExecutionHandler handler) {
<span class="fc" id="L485">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span>
              new DelayedWorkQueue(), threadFactory, handler);
<span class="fc" id="L487">    }</span>

    /**
     * Returns the trigger time of a delayed action.
     */
    private long triggerTime(long delay, TimeUnit unit) {
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        return triggerTime(unit.toNanos((delay &lt; 0) ? 0 : delay));</span>
    }

    /**
     * Returns the trigger time of a delayed action.
     */
    long triggerTime(long delay) {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        return now() +</span>
<span class="pc" id="L501">            ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay));</span>
    }

    /**
     * Constrains the values of all delays in the queue to be within
     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.
     * This may occur if a task is eligible to be dequeued, but has
     * not yet been, while some other task is added with a delay of
     * Long.MAX_VALUE.
     */
    private long overflowFree(long delay) {
<span class="nc" id="L512">        Delayed head = (Delayed) super.getQueue().peek();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (head != null) {</span>
<span class="nc" id="L514">            long headDelay = head.getDelay(NANOSECONDS);</span>
<span class="nc bnc" id="L515" title="All 4 branches missed.">            if (headDelay &lt; 0 &amp;&amp; (delay - headDelay &lt; 0))</span>
<span class="nc" id="L516">                delay = Long.MAX_VALUE + headDelay;</span>
        }
<span class="nc" id="L518">        return delay;</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public ScheduledFuture&lt;?&gt; schedule(Runnable command,
                                       long delay,
                                       TimeUnit unit) {
<span class="pc bpc" id="L528" title="2 of 4 branches missed.">        if (command == null || unit == null)</span>
<span class="nc" id="L529">            throw new NullPointerException();</span>
<span class="fc" id="L530">        RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span>
            new ScheduledFutureTask&lt;Void&gt;(command, null,
<span class="fc" id="L532">                                          triggerTime(delay, unit)));</span>
<span class="fc" id="L533">        delayedExecute(t);</span>
<span class="fc" id="L534">        return t;</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,
                                           long delay,
                                           TimeUnit unit) {
<span class="pc bpc" id="L544" title="2 of 4 branches missed.">        if (callable == null || unit == null)</span>
<span class="nc" id="L545">            throw new NullPointerException();</span>
<span class="fc" id="L546">        RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span>
            new ScheduledFutureTask&lt;V&gt;(callable,
<span class="fc" id="L548">                                       triggerTime(delay, unit)));</span>
<span class="fc" id="L549">        delayedExecute(t);</span>
<span class="fc" id="L550">        return t;</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     * @throws IllegalArgumentException   {@inheritDoc}
     */
    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit) {
<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (command == null || unit == null)</span>
<span class="nc" id="L563">            throw new NullPointerException();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (period &lt;= 0)</span>
<span class="nc" id="L565">            throw new IllegalArgumentException();</span>
<span class="nc" id="L566">        ScheduledFutureTask&lt;Void&gt; sft =</span>
            new ScheduledFutureTask&lt;Void&gt;(command,
                                          null,
<span class="nc" id="L569">                                          triggerTime(initialDelay, unit),</span>
<span class="nc" id="L570">                                          unit.toNanos(period));</span>
<span class="nc" id="L571">        RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span>
<span class="nc" id="L572">        sft.outerTask = t;</span>
<span class="nc" id="L573">        delayedExecute(t);</span>
<span class="nc" id="L574">        return t;</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     * @throws IllegalArgumentException   {@inheritDoc}
     */
    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit) {
<span class="pc bpc" id="L586" title="2 of 4 branches missed.">        if (command == null || unit == null)</span>
<span class="nc" id="L587">            throw new NullPointerException();</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (delay &lt;= 0)</span>
<span class="nc" id="L589">            throw new IllegalArgumentException();</span>
<span class="fc" id="L590">        ScheduledFutureTask&lt;Void&gt; sft =</span>
            new ScheduledFutureTask&lt;Void&gt;(command,
                                          null,
<span class="fc" id="L593">                                          triggerTime(initialDelay, unit),</span>
<span class="fc" id="L594">                                          unit.toNanos(-delay));</span>
<span class="fc" id="L595">        RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span>
<span class="fc" id="L596">        sft.outerTask = t;</span>
<span class="fc" id="L597">        delayedExecute(t);</span>
<span class="fc" id="L598">        return t;</span>
    }

    /**
     * Executes {@code command} with zero required delay.
     * This has effect equivalent to
     * {@link #schedule(Runnable,long,TimeUnit) schedule(command, 0, anyUnit)}.
     * Note that inspections of the queue and of the list returned by
     * {@code shutdownNow} will access the zero-delayed
     * {@link ScheduledFuture}, not the {@code command} itself.
     *
     * &lt;p&gt;A consequence of the use of {@code ScheduledFuture} objects is
     * that {@link ThreadPoolExecutor#afterExecute afterExecute} is always
     * called with a null second {@code Throwable} argument, even if the
     * {@code command} terminated abruptly.  Instead, the {@code Throwable}
     * thrown by such a task can be obtained via {@link Future#get}.
     *
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution because the
     *         executor has been shut down
     * @throws NullPointerException {@inheritDoc}
     */
    public void execute(Runnable command) {
<span class="nc" id="L622">        schedule(command, 0, NANOSECONDS);</span>
<span class="nc" id="L623">    }</span>

    // Override AbstractExecutorService methods

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public Future&lt;?&gt; submit(Runnable task) {
<span class="nc" id="L632">        return schedule(task, 0, NANOSECONDS);</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
<span class="nc" id="L640">        return schedule(Executors.callable(task, result), 0, NANOSECONDS);</span>
    }

    /**
     * @throws RejectedExecutionException {@inheritDoc}
     * @throws NullPointerException       {@inheritDoc}
     */
    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
<span class="fc" id="L648">        return schedule(task, 0, NANOSECONDS);</span>
    }

    /**
     * Sets the policy on whether to continue executing existing
     * periodic tasks even when this executor has been {@code shutdown}.
     * In this case, these tasks will only terminate upon
     * {@code shutdownNow} or after setting the policy to
     * {@code false} when already shutdown.
     * This value is by default {@code false}.
     *
     * @param value if {@code true}, continue after shutdown, else don't
     * @see #getContinueExistingPeriodicTasksAfterShutdownPolicy
     */
    public void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) {
<span class="nc" id="L663">        continueExistingPeriodicTasksAfterShutdown = value;</span>
<span class="nc bnc" id="L664" title="All 4 branches missed.">        if (!value &amp;&amp; isShutdown())</span>
<span class="nc" id="L665">            onShutdown();</span>
<span class="nc" id="L666">    }</span>

    /**
     * Gets the policy on whether to continue executing existing
     * periodic tasks even when this executor has been {@code shutdown}.
     * In this case, these tasks will only terminate upon
     * {@code shutdownNow} or after setting the policy to
     * {@code false} when already shutdown.
     * This value is by default {@code false}.
     *
     * @return {@code true} if will continue after shutdown
     * @see #setContinueExistingPeriodicTasksAfterShutdownPolicy
     */
    public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy() {
<span class="fc" id="L680">        return continueExistingPeriodicTasksAfterShutdown;</span>
    }

    /**
     * Sets the policy on whether to execute existing delayed
     * tasks even when this executor has been {@code shutdown}.
     * In this case, these tasks will only terminate upon
     * {@code shutdownNow}, or after setting the policy to
     * {@code false} when already shutdown.
     * This value is by default {@code true}.
     *
     * @param value if {@code true}, execute after shutdown, else don't
     * @see #getExecuteExistingDelayedTasksAfterShutdownPolicy
     */
    public void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) {
<span class="nc" id="L695">        executeExistingDelayedTasksAfterShutdown = value;</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">        if (!value &amp;&amp; isShutdown())</span>
<span class="nc" id="L697">            onShutdown();</span>
<span class="nc" id="L698">    }</span>

    /**
     * Gets the policy on whether to execute existing delayed
     * tasks even when this executor has been {@code shutdown}.
     * In this case, these tasks will only terminate upon
     * {@code shutdownNow}, or after setting the policy to
     * {@code false} when already shutdown.
     * This value is by default {@code true}.
     *
     * @return {@code true} if will execute after shutdown
     * @see #setExecuteExistingDelayedTasksAfterShutdownPolicy
     */
    public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy() {
<span class="fc" id="L712">        return executeExistingDelayedTasksAfterShutdown;</span>
    }

    /**
     * Sets the policy on whether cancelled tasks should be immediately
     * removed from the work queue at time of cancellation.  This value is
     * by default {@code false}.
     *
     * @param value if {@code true}, remove on cancellation, else don't
     * @see #getRemoveOnCancelPolicy
     * @since 1.7
     */
    public void setRemoveOnCancelPolicy(boolean value) {
<span class="fc" id="L725">        removeOnCancel = value;</span>
<span class="fc" id="L726">    }</span>

    /**
     * Gets the policy on whether cancelled tasks should be immediately
     * removed from the work queue at time of cancellation.  This value is
     * by default {@code false}.
     *
     * @return {@code true} if cancelled tasks are immediately removed
     *         from the queue
     * @see #setRemoveOnCancelPolicy
     * @since 1.7
     */
    public boolean getRemoveOnCancelPolicy() {
<span class="nc" id="L739">        return removeOnCancel;</span>
    }

    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * &lt;p&gt;This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * &lt;p&gt;If the {@code ExecuteExistingDelayedTasksAfterShutdownPolicy}
     * has been set {@code false}, existing delayed tasks whose delays
     * have not yet elapsed are cancelled.  And unless the {@code
     * ContinueExistingPeriodicTasksAfterShutdownPolicy} has been set
     * {@code true}, future executions of existing periodic tasks will
     * be cancelled.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public void shutdown() {
<span class="fc" id="L761">        super.shutdown();</span>
<span class="fc" id="L762">    }</span>

    /**
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution.
     *
     * &lt;p&gt;This method does not wait for actively executing tasks to
     * terminate.  Use {@link #awaitTermination awaitTermination} to
     * do that.
     *
     * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  This implementation
     * cancels tasks via {@link Thread#interrupt}, so any task that
     * fails to respond to interrupts may never terminate.
     *
     * @return list of tasks that never commenced execution.
     *         Each element of this list is a {@link ScheduledFuture},
     *         including those tasks submitted using {@code execute},
     *         which are for scheduling purposes used as the basis of a
     *         zero-delay {@code ScheduledFuture}.
     * @throws SecurityException {@inheritDoc}
     */
    public List&lt;Runnable&gt; shutdownNow() {
<span class="fc" id="L786">        return super.shutdownNow();</span>
    }

    /**
     * Returns the task queue used by this executor.  Each element of
     * this queue is a {@link ScheduledFuture}, including those
     * tasks submitted using {@code execute} which are for scheduling
     * purposes used as the basis of a zero-delay
     * {@code ScheduledFuture}.  Iteration over this queue is
     * &lt;em&gt;not&lt;/em&gt; guaranteed to traverse tasks in the order in
     * which they will execute.
     *
     * @return the task queue
     */
    public BlockingQueue&lt;Runnable&gt; getQueue() {
<span class="nc" id="L801">        return super.getQueue();</span>
    }

    /**
     * Specialized delay queue. To mesh with TPE declarations, this
     * class must be declared as a BlockingQueue&lt;Runnable&gt; even though
     * it can only hold RunnableScheduledFutures.
     */
<span class="fc" id="L809">    static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt;</span>
        implements BlockingQueue&lt;Runnable&gt; {

        /*
         * A DelayedWorkQueue is based on a heap-based data structure
         * like those in DelayQueue and PriorityQueue, except that
         * every ScheduledFutureTask also records its index into the
         * heap array. This eliminates the need to find a task upon
         * cancellation, greatly speeding up removal (down from O(n)
         * to O(log n)), and reducing garbage retention that would
         * otherwise occur by waiting for the element to rise to top
         * before clearing. But because the queue may also hold
         * RunnableScheduledFutures that are not ScheduledFutureTasks,
         * we are not guaranteed to have such indices available, in
         * which case we fall back to linear search. (We expect that
         * most tasks will not be decorated, and that the faster cases
         * will be much more common.)
         *
         * All heap operations must record index changes -- mainly
         * within siftUp and siftDown. Upon removal, a task's
         * heapIndex is set to -1. Note that ScheduledFutureTasks can
         * appear at most once in the queue (this need not be true for
         * other kinds of tasks or work queues), so are uniquely
         * identified by heapIndex.
         */

        private static final int INITIAL_CAPACITY = 16;
<span class="fc" id="L836">        private RunnableScheduledFuture&lt;?&gt;[] queue =</span>
            new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];
<span class="fc" id="L838">        private final ReentrantLock lock = new ReentrantLock();</span>
<span class="fc" id="L839">        private int size = 0;</span>

        /**
         * Thread designated to wait for the task at the head of the
         * queue.  This variant of the Leader-Follower pattern
         * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to
         * minimize unnecessary timed waiting.  When a thread becomes
         * the leader, it waits only for the next delay to elapse, but
         * other threads await indefinitely.  The leader thread must
         * signal some other thread before returning from take() or
         * poll(...), unless some other thread becomes leader in the
         * interim.  Whenever the head of the queue is replaced with a
         * task with an earlier expiration time, the leader field is
         * invalidated by being reset to null, and some waiting
         * thread, but not necessarily the current leader, is
         * signalled.  So waiting threads must be prepared to acquire
         * and lose leadership while waiting.
         */
<span class="fc" id="L857">        private Thread leader = null;</span>

        /**
         * Condition signalled when a newer task becomes available at the
         * head of the queue or a new thread may need to become leader.
         */
<span class="fc" id="L863">        private final Condition available = lock.newCondition();</span>

        /**
         * Sets f's heapIndex if it is a ScheduledFutureTask.
         */
        private void setIndex(RunnableScheduledFuture&lt;?&gt; f, int idx) {
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">            if (f instanceof ScheduledFutureTask)</span>
<span class="fc" id="L870">                ((ScheduledFutureTask)f).heapIndex = idx;</span>
<span class="fc" id="L871">        }</span>

        /**
         * Sifts element added at bottom up to its heap-ordered spot.
         * Call only when holding lock.
         */
        private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) {
<span class="fc bfc" id="L878" title="All 2 branches covered.">            while (k &gt; 0) {</span>
<span class="fc" id="L879">                int parent = (k - 1) &gt;&gt;&gt; 1;</span>
<span class="fc" id="L880">                RunnableScheduledFuture&lt;?&gt; e = queue[parent];</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                if (key.compareTo(e) &gt;= 0)</span>
<span class="fc" id="L882">                    break;</span>
<span class="fc" id="L883">                queue[k] = e;</span>
<span class="fc" id="L884">                setIndex(e, k);</span>
<span class="fc" id="L885">                k = parent;</span>
<span class="fc" id="L886">            }</span>
<span class="fc" id="L887">            queue[k] = key;</span>
<span class="fc" id="L888">            setIndex(key, k);</span>
<span class="fc" id="L889">        }</span>

        /**
         * Sifts element added at top down to its heap-ordered spot.
         * Call only when holding lock.
         */
        private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) {
<span class="fc" id="L896">            int half = size &gt;&gt;&gt; 1;</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">            while (k &lt; half) {</span>
<span class="fc" id="L898">                int child = (k &lt;&lt; 1) + 1;</span>
<span class="fc" id="L899">                RunnableScheduledFuture&lt;?&gt; c = queue[child];</span>
<span class="fc" id="L900">                int right = child + 1;</span>
<span class="fc bfc" id="L901" title="All 4 branches covered.">                if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0)</span>
<span class="fc" id="L902">                    c = queue[child = right];</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                if (key.compareTo(c) &lt;= 0)</span>
<span class="fc" id="L904">                    break;</span>
<span class="fc" id="L905">                queue[k] = c;</span>
<span class="fc" id="L906">                setIndex(c, k);</span>
<span class="fc" id="L907">                k = child;</span>
<span class="fc" id="L908">            }</span>
<span class="fc" id="L909">            queue[k] = key;</span>
<span class="fc" id="L910">            setIndex(key, k);</span>
<span class="fc" id="L911">        }</span>

        /**
         * Resizes the heap array.  Call only when holding lock.
         */
        private void grow() {
<span class="fc" id="L917">            int oldCapacity = queue.length;</span>
<span class="fc" id="L918">            int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // grow 50%</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">            if (newCapacity &lt; 0) // overflow</span>
<span class="nc" id="L920">                newCapacity = Integer.MAX_VALUE;</span>
<span class="fc" id="L921">            queue = Arrays.copyOf(queue, newCapacity);</span>
<span class="fc" id="L922">        }</span>

        /**
         * Finds index of given object, or -1 if absent.
         */
        private int indexOf(Object x) {
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">            if (x != null) {</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                if (x instanceof ScheduledFutureTask) {</span>
<span class="fc" id="L930">                    int i = ((ScheduledFutureTask) x).heapIndex;</span>
                    // Sanity check; x could conceivably be a
                    // ScheduledFutureTask from some other pool.
<span class="pc bpc" id="L933" title="3 of 6 branches missed.">                    if (i &gt;= 0 &amp;&amp; i &lt; size &amp;&amp; queue[i] == x)</span>
<span class="fc" id="L934">                        return i;</span>
<span class="nc" id="L935">                } else {</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++)</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                        if (x.equals(queue[i]))</span>
<span class="nc" id="L938">                            return i;</span>
                }
            }
<span class="nc" id="L941">            return -1;</span>
        }

        public boolean contains(Object x) {
<span class="nc" id="L945">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L946">            lock.lock();</span>
            try {
<span class="nc bnc" id="L948" title="All 2 branches missed.">                return indexOf(x) != -1;</span>
            } finally {
<span class="nc" id="L950">                lock.unlock();</span>
            }
        }

        public boolean remove(Object x) {
<span class="fc" id="L955">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L956">            lock.lock();</span>
            try {
<span class="fc" id="L958">                int i = indexOf(x);</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">                if (i &lt; 0)</span>
<span class="nc" id="L960">                    return false;</span>

<span class="fc" id="L962">                setIndex(queue[i], -1);</span>
<span class="fc" id="L963">                int s = --size;</span>
<span class="fc" id="L964">                RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span>
<span class="fc" id="L965">                queue[s] = null;</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">                if (s != i) {</span>
<span class="fc" id="L967">                    siftDown(i, replacement);</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">                    if (queue[i] == replacement)</span>
<span class="fc" id="L969">                        siftUp(i, replacement);</span>
                }
<span class="fc" id="L971">                return true;</span>
            } finally {
<span class="pc" id="L973">                lock.unlock();</span>
            }
        }

        public int size() {
<span class="fc" id="L978">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L979">            lock.lock();</span>
            try {
<span class="fc" id="L981">                return size;</span>
            } finally {
<span class="pc" id="L983">                lock.unlock();</span>
            }
        }

        public boolean isEmpty() {
<span class="fc bfc" id="L988" title="All 2 branches covered.">            return size() == 0;</span>
        }

        public int remainingCapacity() {
<span class="nc" id="L992">            return Integer.MAX_VALUE;</span>
        }

        public RunnableScheduledFuture&lt;?&gt; peek() {
<span class="nc" id="L996">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L997">            lock.lock();</span>
            try {
<span class="nc" id="L999">                return queue[0];</span>
            } finally {
<span class="nc" id="L1001">                lock.unlock();</span>
            }
        }

        public boolean offer(Runnable x) {
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">            if (x == null)</span>
<span class="nc" id="L1007">                throw new NullPointerException();</span>
<span class="fc" id="L1008">            RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span>
<span class="fc" id="L1009">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L1010">            lock.lock();</span>
            try {
<span class="fc" id="L1012">                int i = size;</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">                if (i &gt;= queue.length)</span>
<span class="fc" id="L1014">                    grow();</span>
<span class="fc" id="L1015">                size = i + 1;</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                if (i == 0) {</span>
<span class="fc" id="L1017">                    queue[0] = e;</span>
<span class="fc" id="L1018">                    setIndex(e, 0);</span>
                } else {
<span class="fc" id="L1020">                    siftUp(i, e);</span>
                }
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                if (queue[0] == e) {</span>
<span class="fc" id="L1023">                    leader = null;</span>
<span class="fc" id="L1024">                    available.signal();</span>
                }
            } finally {
<span class="pc" id="L1027">                lock.unlock();</span>
<span class="fc" id="L1028">            }</span>
<span class="fc" id="L1029">            return true;</span>
        }

        public void put(Runnable e) {
<span class="nc" id="L1033">            offer(e);</span>
<span class="nc" id="L1034">        }</span>

        public boolean add(Runnable e) {
<span class="fc" id="L1037">            return offer(e);</span>
        }

        public boolean offer(Runnable e, long timeout, TimeUnit unit) {
<span class="nc" id="L1041">            return offer(e);</span>
        }

        /**
         * Performs common bookkeeping for poll and take: Replaces
         * first element with last and sifts it down.  Call only when
         * holding lock.
         * @param f the task to remove and return
         */
        private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) {
<span class="fc" id="L1051">            int s = --size;</span>
<span class="fc" id="L1052">            RunnableScheduledFuture&lt;?&gt; x = queue[s];</span>
<span class="fc" id="L1053">            queue[s] = null;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">            if (s != 0)</span>
<span class="fc" id="L1055">                siftDown(0, x);</span>
<span class="fc" id="L1056">            setIndex(f, -1);</span>
<span class="fc" id="L1057">            return f;</span>
        }

        public RunnableScheduledFuture&lt;?&gt; poll() {
<span class="nc" id="L1061">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L1062">            lock.lock();</span>
            try {
<span class="nc" id="L1064">                RunnableScheduledFuture&lt;?&gt; first = queue[0];</span>
<span class="nc bnc" id="L1065" title="All 4 branches missed.">                if (first == null || first.getDelay(NANOSECONDS) &gt; 0)</span>
<span class="nc" id="L1066">                    return null;</span>
                else
<span class="nc" id="L1068">                    return finishPoll(first);</span>
            } finally {
<span class="nc" id="L1070">                lock.unlock();</span>
            }
        }

        public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException {
<span class="fc" id="L1075">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L1076">            lock.lockInterruptibly();</span>
            try {
                for (;;) {
<span class="fc" id="L1079">                    RunnableScheduledFuture&lt;?&gt; first = queue[0];</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">                    if (first == null)</span>
<span class="fc" id="L1081">                        available.await();</span>
                    else {
<span class="fc" id="L1083">                        long delay = first.getDelay(NANOSECONDS);</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">                        if (delay &lt;= 0)</span>
<span class="fc" id="L1085">                            return finishPoll(first);</span>
<span class="fc" id="L1086">                        first = null; // don't retain ref while waiting</span>
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">                        if (leader != null)</span>
<span class="nc" id="L1088">                            available.await();</span>
                        else {
<span class="fc" id="L1090">                            Thread thisThread = Thread.currentThread();</span>
<span class="fc" id="L1091">                            leader = thisThread;</span>
                            try {
<span class="fc" id="L1093">                                available.awaitNanos(delay);</span>
                            } finally {
<span class="pc bpc" id="L1095" title="1 of 4 branches missed.">                                if (leader == thisThread)</span>
<span class="fc" id="L1096">                                    leader = null;</span>
                            }
                        }
                    }
<span class="fc" id="L1100">                }</span>
            } finally {
<span class="pc bpc" id="L1102" title="2 of 8 branches missed.">                if (leader == null &amp;&amp; queue[0] != null)</span>
<span class="fc" id="L1103">                    available.signal();</span>
<span class="fc" id="L1104">                lock.unlock();</span>
            }
        }

        public RunnableScheduledFuture&lt;?&gt; poll(long timeout, TimeUnit unit)
            throws InterruptedException {
<span class="nc" id="L1110">            long nanos = unit.toNanos(timeout);</span>
<span class="nc" id="L1111">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L1112">            lock.lockInterruptibly();</span>
            try {
                for (;;) {
<span class="nc" id="L1115">                    RunnableScheduledFuture&lt;?&gt; first = queue[0];</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                    if (first == null) {</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                        if (nanos &lt;= 0)</span>
<span class="nc" id="L1118">                            return null;</span>
                        else
<span class="nc" id="L1120">                            nanos = available.awaitNanos(nanos);</span>
                    } else {
<span class="nc" id="L1122">                        long delay = first.getDelay(NANOSECONDS);</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                        if (delay &lt;= 0)</span>
<span class="nc" id="L1124">                            return finishPoll(first);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                        if (nanos &lt;= 0)</span>
<span class="nc" id="L1126">                            return null;</span>
<span class="nc" id="L1127">                        first = null; // don't retain ref while waiting</span>
<span class="nc bnc" id="L1128" title="All 4 branches missed.">                        if (nanos &lt; delay || leader != null)</span>
<span class="nc" id="L1129">                            nanos = available.awaitNanos(nanos);</span>
                        else {
<span class="nc" id="L1131">                            Thread thisThread = Thread.currentThread();</span>
<span class="nc" id="L1132">                            leader = thisThread;</span>
                            try {
<span class="nc" id="L1134">                                long timeLeft = available.awaitNanos(delay);</span>
<span class="nc" id="L1135">                                nanos -= delay - timeLeft;</span>
                            } finally {
<span class="nc bnc" id="L1137" title="All 4 branches missed.">                                if (leader == thisThread)</span>
<span class="nc" id="L1138">                                    leader = null;</span>
                            }
                        }
                    }
<span class="nc" id="L1142">                }</span>
            } finally {
<span class="nc bnc" id="L1144" title="All 16 branches missed.">                if (leader == null &amp;&amp; queue[0] != null)</span>
<span class="nc" id="L1145">                    available.signal();</span>
<span class="nc" id="L1146">                lock.unlock();</span>
            }
        }

        public void clear() {
<span class="nc" id="L1151">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L1152">            lock.lock();</span>
            try {
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1155">                    RunnableScheduledFuture&lt;?&gt; t = queue[i];</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                    if (t != null) {</span>
<span class="nc" id="L1157">                        queue[i] = null;</span>
<span class="nc" id="L1158">                        setIndex(t, -1);</span>
                    }
                }
<span class="nc" id="L1161">                size = 0;</span>
            } finally {
<span class="nc" id="L1163">                lock.unlock();</span>
<span class="nc" id="L1164">            }</span>
<span class="nc" id="L1165">        }</span>

        /**
         * Returns first element only if it is expired.
         * Used only by drainTo.  Call only when holding lock.
         */
        private RunnableScheduledFuture&lt;?&gt; peekExpired() {
            // assert lock.isHeldByCurrentThread();
<span class="fc" id="L1173">            RunnableScheduledFuture&lt;?&gt; first = queue[0];</span>
<span class="pc bpc" id="L1174" title="3 of 4 branches missed.">            return (first == null || first.getDelay(NANOSECONDS) &gt; 0) ?</span>
                null : first;
        }

        public int drainTo(Collection&lt;? super Runnable&gt; c) {
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">            if (c == null)</span>
<span class="nc" id="L1180">                throw new NullPointerException();</span>
<span class="pc bpc" id="L1181" title="1 of 2 branches missed.">            if (c == this)</span>
<span class="nc" id="L1182">                throw new IllegalArgumentException();</span>
<span class="fc" id="L1183">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L1184">            lock.lock();</span>
            try {
                RunnableScheduledFuture&lt;?&gt; first;
<span class="fc" id="L1187">                int n = 0;</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">                while ((first = peekExpired()) != null) {</span>
<span class="nc" id="L1189">                    c.add(first);   // In this order, in case add() throws.</span>
<span class="nc" id="L1190">                    finishPoll(first);</span>
<span class="nc" id="L1191">                    ++n;</span>
                }
<span class="fc" id="L1193">                return n;</span>
            } finally {
<span class="pc" id="L1195">                lock.unlock();</span>
            }
        }

        public int drainTo(Collection&lt;? super Runnable&gt; c, int maxElements) {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">            if (c == null)</span>
<span class="nc" id="L1201">                throw new NullPointerException();</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (c == this)</span>
<span class="nc" id="L1203">                throw new IllegalArgumentException();</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">            if (maxElements &lt;= 0)</span>
<span class="nc" id="L1205">                return 0;</span>
<span class="nc" id="L1206">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L1207">            lock.lock();</span>
            try {
                RunnableScheduledFuture&lt;?&gt; first;
<span class="nc" id="L1210">                int n = 0;</span>
<span class="nc bnc" id="L1211" title="All 4 branches missed.">                while (n &lt; maxElements &amp;&amp; (first = peekExpired()) != null) {</span>
<span class="nc" id="L1212">                    c.add(first);   // In this order, in case add() throws.</span>
<span class="nc" id="L1213">                    finishPoll(first);</span>
<span class="nc" id="L1214">                    ++n;</span>
                }
<span class="nc" id="L1216">                return n;</span>
            } finally {
<span class="nc" id="L1218">                lock.unlock();</span>
            }
        }

        public Object[] toArray() {
<span class="fc" id="L1223">            final ReentrantLock lock = this.lock;</span>
<span class="fc" id="L1224">            lock.lock();</span>
            try {
<span class="fc" id="L1226">                return Arrays.copyOf(queue, size, Object[].class);</span>
            } finally {
<span class="pc" id="L1228">                lock.unlock();</span>
            }
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        public &lt;T&gt; T[] toArray(T[] a) {
<span class="nc" id="L1234">            final ReentrantLock lock = this.lock;</span>
<span class="nc" id="L1235">            lock.lock();</span>
            try {
<span class="nc bnc" id="L1237" title="All 2 branches missed.">                if (a.length &lt; size)</span>
<span class="nc" id="L1238">                    return (T[]) Arrays.copyOf(queue, size, a.getClass());</span>
<span class="nc" id="L1239">                System.arraycopy(queue, 0, a, 0, size);</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                if (a.length &gt; size)</span>
<span class="nc" id="L1241">                    a[size] = null;</span>
<span class="nc" id="L1242">                return a;</span>
            } finally {
<span class="nc" id="L1244">                lock.unlock();</span>
            }
        }

        public Iterator&lt;Runnable&gt; iterator() {
<span class="nc" id="L1249">            return new Itr(Arrays.copyOf(queue, size));</span>
        }

        /**
         * Snapshot iterator that works off copy of underlying q array.
         */
<span class="fc" id="L1255">        private class Itr implements Iterator&lt;Runnable&gt; {</span>
            final RunnableScheduledFuture&lt;?&gt;[] array;
<span class="nc" id="L1257">            int cursor = 0;     // index of next element to return</span>
<span class="nc" id="L1258">            int lastRet = -1;   // index of last element, or -1 if no such</span>

<span class="nc" id="L1260">            Itr(RunnableScheduledFuture&lt;?&gt;[] array) {</span>
<span class="nc" id="L1261">                this.array = array;</span>
<span class="nc" id="L1262">            }</span>

            public boolean hasNext() {
<span class="nc bnc" id="L1265" title="All 2 branches missed.">                return cursor &lt; array.length;</span>
            }

            public Runnable next() {
<span class="nc bnc" id="L1269" title="All 2 branches missed.">                if (cursor &gt;= array.length)</span>
<span class="nc" id="L1270">                    throw new NoSuchElementException();</span>
<span class="nc" id="L1271">                lastRet = cursor;</span>
<span class="nc" id="L1272">                return array[cursor++];</span>
            }

            public void remove() {
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                if (lastRet &lt; 0)</span>
<span class="nc" id="L1277">                    throw new IllegalStateException();</span>
<span class="nc" id="L1278">                DelayedWorkQueue.this.remove(array[lastRet]);</span>
<span class="nc" id="L1279">                lastRet = -1;</span>
<span class="nc" id="L1280">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>