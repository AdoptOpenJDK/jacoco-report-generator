<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Executors.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">Executors.java</span></div><h1>Executors.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.security.AccessControlException;
import sun.security.util.SecurityConstants;

/**
 * Factory and utility methods for {@link Executor}, {@link
 * ExecutorService}, {@link ScheduledExecutorService}, {@link
 * ThreadFactory}, and {@link Callable} classes defined in this
 * package. This class supports the following kinds of methods:
 *
 * &lt;ul&gt;
 *   &lt;li&gt; Methods that create and return an {@link ExecutorService}
 *        set up with commonly useful configuration settings.
 *   &lt;li&gt; Methods that create and return a {@link ScheduledExecutorService}
 *        set up with commonly useful configuration settings.
 *   &lt;li&gt; Methods that create and return a &quot;wrapped&quot; ExecutorService, that
 *        disables reconfiguration by making implementation-specific methods
 *        inaccessible.
 *   &lt;li&gt; Methods that create and return a {@link ThreadFactory}
 *        that sets newly created threads to a known state.
 *   &lt;li&gt; Methods that create and return a {@link Callable}
 *        out of other closure-like forms, so they can be used
 *        in execution methods requiring {@code Callable}.
 * &lt;/ul&gt;
 *
 * @since 1.5
 * @author Doug Lea
 */
public class Executors {

    /**
     * Creates a thread pool that reuses a fixed number of threads
     * operating off a shared unbounded queue.  At any point, at most
     * {@code nThreads} threads will be active processing tasks.
     * If additional tasks are submitted when all threads are active,
     * they will wait in the queue until a thread is available.
     * If any thread terminates due to a failure during execution
     * prior to shutdown, a new one will take its place if needed to
     * execute subsequent tasks.  The threads in the pool will exist
     * until it is explicitly {@link ExecutorService#shutdown shutdown}.
     *
     * @param nThreads the number of threads in the pool
     * @return the newly created thread pool
     * @throws IllegalArgumentException if {@code nThreads &lt;= 0}
     */
    public static ExecutorService newFixedThreadPool(int nThreads) {
<span class="fc" id="L89">        return new ThreadPoolExecutor(nThreads, nThreads,</span>
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }

    /**
     * Creates a thread pool that maintains enough threads to support
     * the given parallelism level, and may use multiple queues to
     * reduce contention. The parallelism level corresponds to the
     * maximum number of threads actively engaged in, or available to
     * engage in, task processing. The actual number of threads may
     * grow and shrink dynamically. A work-stealing pool makes no
     * guarantees about the order in which submitted tasks are
     * executed.
     *
     * @param parallelism the targeted parallelism level
     * @return the newly created thread pool
     * @throws IllegalArgumentException if {@code parallelism &lt;= 0}
     * @since 1.8
     */
    public static ExecutorService newWorkStealingPool(int parallelism) {
<span class="nc" id="L110">        return new ForkJoinPool</span>
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }

    /**
     * Creates a work-stealing thread pool using all
     * {@link Runtime#availableProcessors available processors}
     * as its target parallelism level.
     * @return the newly created thread pool
     * @see #newWorkStealingPool(int)
     * @since 1.8
     */
    public static ExecutorService newWorkStealingPool() {
<span class="nc" id="L125">        return new ForkJoinPool</span>
<span class="nc" id="L126">            (Runtime.getRuntime().availableProcessors(),</span>
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }

    /**
     * Creates a thread pool that reuses a fixed number of threads
     * operating off a shared unbounded queue, using the provided
     * ThreadFactory to create new threads when needed.  At any point,
     * at most {@code nThreads} threads will be active processing
     * tasks.  If additional tasks are submitted when all threads are
     * active, they will wait in the queue until a thread is
     * available.  If any thread terminates due to a failure during
     * execution prior to shutdown, a new one will take its place if
     * needed to execute subsequent tasks.  The threads in the pool will
     * exist until it is explicitly {@link ExecutorService#shutdown
     * shutdown}.
     *
     * @param nThreads the number of threads in the pool
     * @param threadFactory the factory to use when creating new threads
     * @return the newly created thread pool
     * @throws NullPointerException if threadFactory is null
     * @throws IllegalArgumentException if {@code nThreads &lt;= 0}
     */
    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
<span class="fc" id="L151">        return new ThreadPoolExecutor(nThreads, nThreads,</span>
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }

    /**
     * Creates an Executor that uses a single worker thread operating
     * off an unbounded queue. (Note however that if this single
     * thread terminates due to a failure during execution prior to
     * shutdown, a new one will take its place if needed to execute
     * subsequent tasks.)  Tasks are guaranteed to execute
     * sequentially, and no more than one task will be active at any
     * given time. Unlike the otherwise equivalent
     * {@code newFixedThreadPool(1)} the returned executor is
     * guaranteed not to be reconfigurable to use additional threads.
     *
     * @return the newly created single-threaded Executor
     */
    public static ExecutorService newSingleThreadExecutor() {
<span class="fc" id="L171">        return new FinalizableDelegatedExecutorService</span>
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }

    /**
     * Creates an Executor that uses a single worker thread operating
     * off an unbounded queue, and uses the provided ThreadFactory to
     * create a new thread when needed. Unlike the otherwise
     * equivalent {@code newFixedThreadPool(1, threadFactory)} the
     * returned executor is guaranteed not to be reconfigurable to use
     * additional threads.
     *
     * @param threadFactory the factory to use when creating new
     * threads
     *
     * @return the newly created single-threaded Executor
     * @throws NullPointerException if threadFactory is null
     */
    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
<span class="fc" id="L192">        return new FinalizableDelegatedExecutorService</span>
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    }

    /**
     * Creates a thread pool that creates new threads as needed, but
     * will reuse previously constructed threads when they are
     * available.  These pools will typically improve the performance
     * of programs that execute many short-lived asynchronous tasks.
     * Calls to {@code execute} will reuse previously constructed
     * threads if available. If no existing thread is available, a new
     * thread will be created and added to the pool. Threads that have
     * not been used for sixty seconds are terminated and removed from
     * the cache. Thus, a pool that remains idle for long enough will
     * not consume any resources. Note that pools with similar
     * properties but different details (for example, timeout parameters)
     * may be created using {@link ThreadPoolExecutor} constructors.
     *
     * @return the newly created thread pool
     */
    public static ExecutorService newCachedThreadPool() {
<span class="fc" id="L216">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span>
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }

    /**
     * Creates a thread pool that creates new threads as needed, but
     * will reuse previously constructed threads when they are
     * available, and uses the provided
     * ThreadFactory to create new threads when needed.
     * @param threadFactory the factory to use when creating new threads
     * @return the newly created thread pool
     * @throws NullPointerException if threadFactory is null
     */
    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
<span class="fc" id="L231">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span>
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }

    /**
     * Creates a single-threaded executor that can schedule commands
     * to run after a given delay, or to execute periodically.
     * (Note however that if this single
     * thread terminates due to a failure during execution prior to
     * shutdown, a new one will take its place if needed to execute
     * subsequent tasks.)  Tasks are guaranteed to execute
     * sequentially, and no more than one task will be active at any
     * given time. Unlike the otherwise equivalent
     * {@code newScheduledThreadPool(1)} the returned executor is
     * guaranteed not to be reconfigurable to use additional threads.
     * @return the newly created scheduled executor
     */
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
<span class="fc" id="L251">        return new DelegatedScheduledExecutorService</span>
            (new ScheduledThreadPoolExecutor(1));
    }

    /**
     * Creates a single-threaded executor that can schedule commands
     * to run after a given delay, or to execute periodically.  (Note
     * however that if this single thread terminates due to a failure
     * during execution prior to shutdown, a new one will take its
     * place if needed to execute subsequent tasks.)  Tasks are
     * guaranteed to execute sequentially, and no more than one task
     * will be active at any given time. Unlike the otherwise
     * equivalent {@code newScheduledThreadPool(1, threadFactory)}
     * the returned executor is guaranteed not to be reconfigurable to
     * use additional threads.
     * @param threadFactory the factory to use when creating new
     * threads
     * @return a newly created scheduled executor
     * @throws NullPointerException if threadFactory is null
     */
    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {
<span class="fc" id="L272">        return new DelegatedScheduledExecutorService</span>
            (new ScheduledThreadPoolExecutor(1, threadFactory));
    }

    /**
     * Creates a thread pool that can schedule commands to run after a
     * given delay, or to execute periodically.
     * @param corePoolSize the number of threads to keep in the pool,
     * even if they are idle
     * @return a newly created scheduled thread pool
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     */
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
<span class="fc" id="L285">        return new ScheduledThreadPoolExecutor(corePoolSize);</span>
    }

    /**
     * Creates a thread pool that can schedule commands to run after a
     * given delay, or to execute periodically.
     * @param corePoolSize the number of threads to keep in the pool,
     * even if they are idle
     * @param threadFactory the factory to use when the executor
     * creates a new thread
     * @return a newly created scheduled thread pool
     * @throws IllegalArgumentException if {@code corePoolSize &lt; 0}
     * @throws NullPointerException if threadFactory is null
     */
    public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
<span class="fc" id="L301">        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span>
    }

    /**
     * Returns an object that delegates all defined {@link
     * ExecutorService} methods to the given executor, but not any
     * other methods that might otherwise be accessible using
     * casts. This provides a way to safely &quot;freeze&quot; configuration and
     * disallow tuning of a given concrete implementation.
     * @param executor the underlying implementation
     * @return an {@code ExecutorService} instance
     * @throws NullPointerException if executor null
     */
    public static ExecutorService unconfigurableExecutorService(ExecutorService executor) {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        if (executor == null)</span>
<span class="fc" id="L316">            throw new NullPointerException();</span>
<span class="nc" id="L317">        return new DelegatedExecutorService(executor);</span>
    }

    /**
     * Returns an object that delegates all defined {@link
     * ScheduledExecutorService} methods to the given executor, but
     * not any other methods that might otherwise be accessible using
     * casts. This provides a way to safely &quot;freeze&quot; configuration and
     * disallow tuning of a given concrete implementation.
     * @param executor the underlying implementation
     * @return a {@code ScheduledExecutorService} instance
     * @throws NullPointerException if executor null
     */
    public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (executor == null)</span>
<span class="fc" id="L332">            throw new NullPointerException();</span>
<span class="nc" id="L333">        return new DelegatedScheduledExecutorService(executor);</span>
    }

    /**
     * Returns a default thread factory used to create new threads.
     * This factory creates all new threads used by an Executor in the
     * same {@link ThreadGroup}. If there is a {@link
     * java.lang.SecurityManager}, it uses the group of {@link
     * System#getSecurityManager}, else the group of the thread
     * invoking this {@code defaultThreadFactory} method. Each new
     * thread is created as a non-daemon thread with priority set to
     * the smaller of {@code Thread.NORM_PRIORITY} and the maximum
     * priority permitted in the thread group.  New threads have names
     * accessible via {@link Thread#getName} of
     * &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence
     * number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number
     * of the thread created by this factory.
     * @return a thread factory
     */
    public static ThreadFactory defaultThreadFactory() {
<span class="fc" id="L353">        return new DefaultThreadFactory();</span>
    }

    /**
     * Returns a thread factory used to create new threads that
     * have the same permissions as the current thread.
     * This factory creates threads with the same settings as {@link
     * Executors#defaultThreadFactory}, additionally setting the
     * AccessControlContext and contextClassLoader of new threads to
     * be the same as the thread invoking this
     * {@code privilegedThreadFactory} method.  A new
     * {@code privilegedThreadFactory} can be created within an
     * {@link AccessController#doPrivileged AccessController.doPrivileged}
     * action setting the current thread's access control context to
     * create threads with the selected permission settings holding
     * within that action.
     *
     * &lt;p&gt;Note that while tasks running within such threads will have
     * the same access control and class loader settings as the
     * current thread, they need not have the same {@link
     * java.lang.ThreadLocal} or {@link
     * java.lang.InheritableThreadLocal} values. If necessary,
     * particular values of thread locals can be set or reset before
     * any task runs in {@link ThreadPoolExecutor} subclasses using
     * {@link ThreadPoolExecutor#beforeExecute(Thread, Runnable)}.
     * Also, if it is necessary to initialize worker threads to have
     * the same InheritableThreadLocal settings as some other
     * designated thread, you can create a custom ThreadFactory in
     * which that thread waits for and services requests to create
     * others that will inherit its values.
     *
     * @return a thread factory
     * @throws AccessControlException if the current access control
     * context does not have permission to both get and set context
     * class loader
     */
    public static ThreadFactory privilegedThreadFactory() {
<span class="fc" id="L390">        return new PrivilegedThreadFactory();</span>
    }

    /**
     * Returns a {@link Callable} object that, when
     * called, runs the given task and returns the given result.  This
     * can be useful when applying methods requiring a
     * {@code Callable} to an otherwise resultless action.
     * @param task the task to run
     * @param result the result to return
     * @param &lt;T&gt; the type of the result
     * @return a callable object
     * @throws NullPointerException if task null
     */
    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (task == null)</span>
<span class="fc" id="L406">            throw new NullPointerException();</span>
<span class="fc" id="L407">        return new RunnableAdapter&lt;T&gt;(task, result);</span>
    }

    /**
     * Returns a {@link Callable} object that, when
     * called, runs the given task and returns {@code null}.
     * @param task the task to run
     * @return a callable object
     * @throws NullPointerException if task null
     */
    public static Callable&lt;Object&gt; callable(Runnable task) {
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        if (task == null)</span>
<span class="fc" id="L419">            throw new NullPointerException();</span>
<span class="nc" id="L420">        return new RunnableAdapter&lt;Object&gt;(task, null);</span>
    }

    /**
     * Returns a {@link Callable} object that, when
     * called, runs the given privileged action and returns its result.
     * @param action the privileged action to run
     * @return a callable object
     * @throws NullPointerException if action null
     */
    public static Callable&lt;Object&gt; callable(final PrivilegedAction&lt;?&gt; action) {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (action == null)</span>
<span class="fc" id="L432">            throw new NullPointerException();</span>
<span class="nc" id="L433">        return new Callable&lt;Object&gt;() {</span>
<span class="nc" id="L434">            public Object call() { return action.run(); }};</span>
    }

    /**
     * Returns a {@link Callable} object that, when
     * called, runs the given privileged exception action and returns
     * its result.
     * @param action the privileged exception action to run
     * @return a callable object
     * @throws NullPointerException if action null
     */
    public static Callable&lt;Object&gt; callable(final PrivilegedExceptionAction&lt;?&gt; action) {
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (action == null)</span>
<span class="fc" id="L447">            throw new NullPointerException();</span>
<span class="nc" id="L448">        return new Callable&lt;Object&gt;() {</span>
<span class="nc" id="L449">            public Object call() throws Exception { return action.run(); }};</span>
    }

    /**
     * Returns a {@link Callable} object that will, when called,
     * execute the given {@code callable} under the current access
     * control context. This method should normally be invoked within
     * an {@link AccessController#doPrivileged AccessController.doPrivileged}
     * action to create callables that will, if possible, execute
     * under the selected permission settings holding within that
     * action; or if not possible, throw an associated {@link
     * AccessControlException}.
     * @param callable the underlying task
     * @param &lt;T&gt; the type of the callable's result
     * @return a callable object
     * @throws NullPointerException if callable null
     */
    public static &lt;T&gt; Callable&lt;T&gt; privilegedCallable(Callable&lt;T&gt; callable) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (callable == null)</span>
<span class="fc" id="L468">            throw new NullPointerException();</span>
<span class="fc" id="L469">        return new PrivilegedCallable&lt;T&gt;(callable);</span>
    }

    /**
     * Returns a {@link Callable} object that will, when called,
     * execute the given {@code callable} under the current access
     * control context, with the current context class loader as the
     * context class loader. This method should normally be invoked
     * within an
     * {@link AccessController#doPrivileged AccessController.doPrivileged}
     * action to create callables that will, if possible, execute
     * under the selected permission settings holding within that
     * action; or if not possible, throw an associated {@link
     * AccessControlException}.
     *
     * @param callable the underlying task
     * @param &lt;T&gt; the type of the callable's result
     * @return a callable object
     * @throws NullPointerException if callable null
     * @throws AccessControlException if the current access control
     * context does not have permission to both set and get context
     * class loader
     */
    public static &lt;T&gt; Callable&lt;T&gt; privilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; callable) {
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if (callable == null)</span>
<span class="nc" id="L494">            throw new NullPointerException();</span>
<span class="fc" id="L495">        return new PrivilegedCallableUsingCurrentClassLoader&lt;T&gt;(callable);</span>
    }

    // Non-public classes supporting the public methods

    /**
     * A callable that runs given task and returns given result
     */
    static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {
        final Runnable task;
        final T result;
<span class="fc" id="L506">        RunnableAdapter(Runnable task, T result) {</span>
<span class="fc" id="L507">            this.task = task;</span>
<span class="fc" id="L508">            this.result = result;</span>
<span class="fc" id="L509">        }</span>
        public T call() {
<span class="fc" id="L511">            task.run();</span>
<span class="fc" id="L512">            return result;</span>
        }
    }

    /**
     * A callable that runs under established access control settings
     */
    static final class PrivilegedCallable&lt;T&gt; implements Callable&lt;T&gt; {
        private final Callable&lt;T&gt; task;
        private final AccessControlContext acc;

<span class="fc" id="L523">        PrivilegedCallable(Callable&lt;T&gt; task) {</span>
<span class="fc" id="L524">            this.task = task;</span>
<span class="fc" id="L525">            this.acc = AccessController.getContext();</span>
<span class="fc" id="L526">        }</span>

        public T call() throws Exception {
            try {
<span class="fc" id="L530">                return AccessController.doPrivileged(</span>
<span class="fc" id="L531">                    new PrivilegedExceptionAction&lt;T&gt;() {</span>
                        public T run() throws Exception {
<span class="fc" id="L533">                            return task.call();</span>
                        }
                    }, acc);
<span class="fc" id="L536">            } catch (PrivilegedActionException e) {</span>
<span class="fc" id="L537">                throw e.getException();</span>
            }
        }
    }

    /**
     * A callable that runs under established access control settings and
     * current ClassLoader
     */
    static final class PrivilegedCallableUsingCurrentClassLoader&lt;T&gt; implements Callable&lt;T&gt; {
        private final Callable&lt;T&gt; task;
        private final AccessControlContext acc;
        private final ClassLoader ccl;

<span class="fc" id="L551">        PrivilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; task) {</span>
<span class="fc" id="L552">            SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (sm != null) {</span>
                // Calls to getContextClassLoader from this class
                // never trigger a security check, but we check
                // whether our callers have this permission anyways.
<span class="fc" id="L557">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>

                // Whether setContextClassLoader turns out to be necessary
                // or not, we fail fast if permission is not available.
<span class="fc" id="L561">                sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));</span>
            }
<span class="fc" id="L563">            this.task = task;</span>
<span class="fc" id="L564">            this.acc = AccessController.getContext();</span>
<span class="fc" id="L565">            this.ccl = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L566">        }</span>

        public T call() throws Exception {
            try {
<span class="fc" id="L570">                return AccessController.doPrivileged(</span>
<span class="fc" id="L571">                    new PrivilegedExceptionAction&lt;T&gt;() {</span>
                        public T run() throws Exception {
<span class="fc" id="L573">                            Thread t = Thread.currentThread();</span>
<span class="fc" id="L574">                            ClassLoader cl = t.getContextClassLoader();</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                            if (ccl == cl) {</span>
<span class="fc" id="L576">                                return task.call();</span>
                            } else {
<span class="nc" id="L578">                                t.setContextClassLoader(ccl);</span>
                                try {
<span class="nc" id="L580">                                    return task.call();</span>
                                } finally {
<span class="nc" id="L582">                                    t.setContextClassLoader(cl);</span>
                                }
                            }
                        }
                    }, acc);
<span class="fc" id="L587">            } catch (PrivilegedActionException e) {</span>
<span class="fc" id="L588">                throw e.getException();</span>
            }
        }
    }

    /**
     * The default thread factory
     */
    static class DefaultThreadFactory implements ThreadFactory {
<span class="fc" id="L597">        private static final AtomicInteger poolNumber = new AtomicInteger(1);</span>
        private final ThreadGroup group;
<span class="fc" id="L599">        private final AtomicInteger threadNumber = new AtomicInteger(1);</span>
        private final String namePrefix;

<span class="fc" id="L602">        DefaultThreadFactory() {</span>
<span class="fc" id="L603">            SecurityManager s = System.getSecurityManager();</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            group = (s != null) ? s.getThreadGroup() :</span>
<span class="fc" id="L605">                                  Thread.currentThread().getThreadGroup();</span>
<span class="fc" id="L606">            namePrefix = &quot;pool-&quot; +</span>
<span class="fc" id="L607">                          poolNumber.getAndIncrement() +</span>
                         &quot;-thread-&quot;;
<span class="fc" id="L609">        }</span>

        public Thread newThread(Runnable r) {
<span class="fc" id="L612">            Thread t = new Thread(group, r,</span>
<span class="fc" id="L613">                                  namePrefix + threadNumber.getAndIncrement(),</span>
                                  0);
<span class="fc bfc" id="L615" title="All 2 branches covered.">            if (t.isDaemon())</span>
<span class="fc" id="L616">                t.setDaemon(false);</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">            if (t.getPriority() != Thread.NORM_PRIORITY)</span>
<span class="nc" id="L618">                t.setPriority(Thread.NORM_PRIORITY);</span>
<span class="fc" id="L619">            return t;</span>
        }
    }

    /**
     * Thread factory capturing access control context and class loader
     */
    static class PrivilegedThreadFactory extends DefaultThreadFactory {
        private final AccessControlContext acc;
        private final ClassLoader ccl;

        PrivilegedThreadFactory() {
<span class="fc" id="L631">            super();</span>
<span class="fc" id="L632">            SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (sm != null) {</span>
                // Calls to getContextClassLoader from this class
                // never trigger a security check, but we check
                // whether our callers have this permission anyways.
<span class="fc" id="L637">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>

                // Fail fast
<span class="fc" id="L640">                sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));</span>
            }
<span class="fc" id="L642">            this.acc = AccessController.getContext();</span>
<span class="fc" id="L643">            this.ccl = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L644">        }</span>

        public Thread newThread(final Runnable r) {
<span class="nc" id="L647">            return super.newThread(new Runnable() {</span>
                public void run() {
<span class="nc" id="L649">                    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                        public Void run() {
<span class="nc" id="L651">                            Thread.currentThread().setContextClassLoader(ccl);</span>
<span class="nc" id="L652">                            r.run();</span>
<span class="nc" id="L653">                            return null;</span>
                        }
<span class="nc" id="L655">                    }, acc);</span>
<span class="nc" id="L656">                }</span>
            });
        }
    }

    /**
     * A wrapper class that exposes only the ExecutorService methods
     * of an ExecutorService implementation.
     */
    static class DelegatedExecutorService extends AbstractExecutorService {
        private final ExecutorService e;
<span class="fc" id="L667">        DelegatedExecutorService(ExecutorService executor) { e = executor; }</span>
<span class="fc" id="L668">        public void execute(Runnable command) { e.execute(command); }</span>
<span class="fc" id="L669">        public void shutdown() { e.shutdown(); }</span>
<span class="fc" id="L670">        public List&lt;Runnable&gt; shutdownNow() { return e.shutdownNow(); }</span>
<span class="nc" id="L671">        public boolean isShutdown() { return e.isShutdown(); }</span>
<span class="nc" id="L672">        public boolean isTerminated() { return e.isTerminated(); }</span>
        public boolean awaitTermination(long timeout, TimeUnit unit)
            throws InterruptedException {
<span class="nc" id="L675">            return e.awaitTermination(timeout, unit);</span>
        }
        public Future&lt;?&gt; submit(Runnable task) {
<span class="nc" id="L678">            return e.submit(task);</span>
        }
        public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
<span class="fc" id="L681">            return e.submit(task);</span>
        }
        public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
<span class="nc" id="L684">            return e.submit(task, result);</span>
        }
        public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
            throws InterruptedException {
<span class="nc" id="L688">            return e.invokeAll(tasks);</span>
        }
        public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                             long timeout, TimeUnit unit)
            throws InterruptedException {
<span class="nc" id="L693">            return e.invokeAll(tasks, timeout, unit);</span>
        }
        public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
            throws InterruptedException, ExecutionException {
<span class="fc" id="L697">            return e.invokeAny(tasks);</span>
        }
        public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                               long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L702">            return e.invokeAny(tasks, timeout, unit);</span>
        }
    }

    static class FinalizableDelegatedExecutorService
        extends DelegatedExecutorService {
        FinalizableDelegatedExecutorService(ExecutorService executor) {
<span class="fc" id="L709">            super(executor);</span>
<span class="fc" id="L710">        }</span>
        protected void finalize() {
<span class="fc" id="L712">            super.shutdown();</span>
<span class="fc" id="L713">        }</span>
    }

    /**
     * A wrapper class that exposes only the ScheduledExecutorService
     * methods of a ScheduledExecutorService implementation.
     */
    static class DelegatedScheduledExecutorService
            extends DelegatedExecutorService
            implements ScheduledExecutorService {
        private final ScheduledExecutorService e;
        DelegatedScheduledExecutorService(ScheduledExecutorService executor) {
<span class="fc" id="L725">            super(executor);</span>
<span class="fc" id="L726">            e = executor;</span>
<span class="fc" id="L727">        }</span>
        public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) {
<span class="fc" id="L729">            return e.schedule(command, delay, unit);</span>
        }
        public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) {
<span class="nc" id="L732">            return e.schedule(callable, delay, unit);</span>
        }
        public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
<span class="nc" id="L735">            return e.scheduleAtFixedRate(command, initialDelay, period, unit);</span>
        }
        public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
<span class="nc" id="L738">            return e.scheduleWithFixedDelay(command, initialDelay, delay, unit);</span>
        }
    }

    /** Cannot instantiate. */
<span class="nc" id="L743">    private Executors() {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>