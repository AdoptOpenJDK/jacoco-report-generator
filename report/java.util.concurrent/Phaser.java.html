<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Phaser.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">Phaser.java</span></div><h1>Phaser.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.LockSupport;

/**
 * A reusable synchronization barrier, similar in functionality to
 * {@link java.util.concurrent.CyclicBarrier CyclicBarrier} and
 * {@link java.util.concurrent.CountDownLatch CountDownLatch}
 * but supporting more flexible usage.
 *
 * &lt;p&gt;&lt;b&gt;Registration.&lt;/b&gt; Unlike the case for other barriers, the
 * number of parties &lt;em&gt;registered&lt;/em&gt; to synchronize on a phaser
 * may vary over time.  Tasks may be registered at any time (using
 * methods {@link #register}, {@link #bulkRegister}, or forms of
 * constructors establishing initial numbers of parties), and
 * optionally deregistered upon any arrival (using {@link
 * #arriveAndDeregister}).  As is the case with most basic
 * synchronization constructs, registration and deregistration affect
 * only internal counts; they do not establish any further internal
 * bookkeeping, so tasks cannot query whether they are registered.
 * (However, you can introduce such bookkeeping by subclassing this
 * class.)
 *
 * &lt;p&gt;&lt;b&gt;Synchronization.&lt;/b&gt; Like a {@code CyclicBarrier}, a {@code
 * Phaser} may be repeatedly awaited.  Method {@link
 * #arriveAndAwaitAdvance} has effect analogous to {@link
 * java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each
 * generation of a phaser has an associated phase number. The phase
 * number starts at zero, and advances when all parties arrive at the
 * phaser, wrapping around to zero after reaching {@code
 * Integer.MAX_VALUE}. The use of phase numbers enables independent
 * control of actions upon arrival at a phaser and upon awaiting
 * others, via two kinds of methods that may be invoked by any
 * registered party:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt; &lt;b&gt;Arrival.&lt;/b&gt; Methods {@link #arrive} and
 *       {@link #arriveAndDeregister} record arrival.  These methods
 *       do not block, but return an associated &lt;em&gt;arrival phase
 *       number&lt;/em&gt;; that is, the phase number of the phaser to which
 *       the arrival applied. When the final party for a given phase
 *       arrives, an optional action is performed and the phase
 *       advances.  These actions are performed by the party
 *       triggering a phase advance, and are arranged by overriding
 *       method {@link #onAdvance(int, int)}, which also controls
 *       termination. Overriding this method is similar to, but more
 *       flexible than, providing a barrier action to a {@code
 *       CyclicBarrier}.
 *
 *   &lt;li&gt; &lt;b&gt;Waiting.&lt;/b&gt; Method {@link #awaitAdvance} requires an
 *       argument indicating an arrival phase number, and returns when
 *       the phaser advances to (or is already at) a different phase.
 *       Unlike similar constructions using {@code CyclicBarrier},
 *       method {@code awaitAdvance} continues to wait even if the
 *       waiting thread is interrupted. Interruptible and timeout
 *       versions are also available, but exceptions encountered while
 *       tasks wait interruptibly or with timeout do not change the
 *       state of the phaser. If necessary, you can perform any
 *       associated recovery within handlers of those exceptions,
 *       often after invoking {@code forceTermination}.  Phasers may
 *       also be used by tasks executing in a {@link ForkJoinPool},
 *       which will ensure sufficient parallelism to execute tasks
 *       when others are blocked waiting for a phase to advance.
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;b&gt;Termination.&lt;/b&gt; A phaser may enter a &lt;em&gt;termination&lt;/em&gt;
 * state, that may be checked using method {@link #isTerminated}. Upon
 * termination, all synchronization methods immediately return without
 * waiting for advance, as indicated by a negative return value.
 * Similarly, attempts to register upon termination have no effect.
 * Termination is triggered when an invocation of {@code onAdvance}
 * returns {@code true}. The default implementation returns {@code
 * true} if a deregistration has caused the number of registered
 * parties to become zero.  As illustrated below, when phasers control
 * actions with a fixed number of iterations, it is often convenient
 * to override this method to cause termination when the current phase
 * number reaches a threshold. Method {@link #forceTermination} is
 * also available to abruptly release waiting threads and allow them
 * to terminate.
 *
 * &lt;p&gt;&lt;b&gt;Tiering.&lt;/b&gt; Phasers may be &lt;em&gt;tiered&lt;/em&gt; (i.e.,
 * constructed in tree structures) to reduce contention. Phasers with
 * large numbers of parties that would otherwise experience heavy
 * synchronization contention costs may instead be set up so that
 * groups of sub-phasers share a common parent.  This may greatly
 * increase throughput even though it incurs greater per-operation
 * overhead.
 *
 * &lt;p&gt;In a tree of tiered phasers, registration and deregistration of
 * child phasers with their parent are managed automatically.
 * Whenever the number of registered parties of a child phaser becomes
 * non-zero (as established in the {@link #Phaser(Phaser,int)}
 * constructor, {@link #register}, or {@link #bulkRegister}), the
 * child phaser is registered with its parent.  Whenever the number of
 * registered parties becomes zero as the result of an invocation of
 * {@link #arriveAndDeregister}, the child phaser is deregistered
 * from its parent.
 *
 * &lt;p&gt;&lt;b&gt;Monitoring.&lt;/b&gt; While synchronization methods may be invoked
 * only by registered parties, the current state of a phaser may be
 * monitored by any caller.  At any given moment there are {@link
 * #getRegisteredParties} parties in total, of which {@link
 * #getArrivedParties} have arrived at the current phase ({@link
 * #getPhase}).  When the remaining ({@link #getUnarrivedParties})
 * parties arrive, the phase advances.  The values returned by these
 * methods may reflect transient states and so are not in general
 * useful for synchronization control.  Method {@link #toString}
 * returns snapshots of these state queries in a form convenient for
 * informal monitoring.
 *
 * &lt;p&gt;&lt;b&gt;Sample usages:&lt;/b&gt;
 *
 * &lt;p&gt;A {@code Phaser} may be used instead of a {@code CountDownLatch}
 * to control a one-shot action serving a variable number of parties.
 * The typical idiom is for the method setting this up to first
 * register, then start the actions, then deregister, as in:
 *
 *  &lt;pre&gt; {@code
 * void runTasks(List&lt;Runnable&gt; tasks) {
 *   final Phaser phaser = new Phaser(1); // &quot;1&quot; to register self
 *   // create and start threads
 *   for (final Runnable task : tasks) {
 *     phaser.register();
 *     new Thread() {
 *       public void run() {
 *         phaser.arriveAndAwaitAdvance(); // await all creation
 *         task.run();
 *       }
 *     }.start();
 *   }
 *
 *   // allow threads to start and deregister self
 *   phaser.arriveAndDeregister();
 * }}&lt;/pre&gt;
 *
 * &lt;p&gt;One way to cause a set of threads to repeatedly perform actions
 * for a given number of iterations is to override {@code onAdvance}:
 *
 *  &lt;pre&gt; {@code
 * void startTasks(List&lt;Runnable&gt; tasks, final int iterations) {
 *   final Phaser phaser = new Phaser() {
 *     protected boolean onAdvance(int phase, int registeredParties) {
 *       return phase &gt;= iterations || registeredParties == 0;
 *     }
 *   };
 *   phaser.register();
 *   for (final Runnable task : tasks) {
 *     phaser.register();
 *     new Thread() {
 *       public void run() {
 *         do {
 *           task.run();
 *           phaser.arriveAndAwaitAdvance();
 *         } while (!phaser.isTerminated());
 *       }
 *     }.start();
 *   }
 *   phaser.arriveAndDeregister(); // deregister self, don't wait
 * }}&lt;/pre&gt;
 *
 * If the main task must later await termination, it
 * may re-register and then execute a similar loop:
 *  &lt;pre&gt; {@code
 *   // ...
 *   phaser.register();
 *   while (!phaser.isTerminated())
 *     phaser.arriveAndAwaitAdvance();}&lt;/pre&gt;
 *
 * &lt;p&gt;Related constructions may be used to await particular phase numbers
 * in contexts where you are sure that the phase will never wrap around
 * {@code Integer.MAX_VALUE}. For example:
 *
 *  &lt;pre&gt; {@code
 * void awaitPhase(Phaser phaser, int phase) {
 *   int p = phaser.register(); // assumes caller not already registered
 *   while (p &lt; phase) {
 *     if (phaser.isTerminated())
 *       // ... deal with unexpected termination
 *     else
 *       p = phaser.arriveAndAwaitAdvance();
 *   }
 *   phaser.arriveAndDeregister();
 * }}&lt;/pre&gt;
 *
 *
 * &lt;p&gt;To create a set of {@code n} tasks using a tree of phasers, you
 * could use code of the following form, assuming a Task class with a
 * constructor accepting a {@code Phaser} that it registers with upon
 * construction. After invocation of {@code build(new Task[n], 0, n,
 * new Phaser())}, these tasks could then be started, for example by
 * submitting to a pool:
 *
 *  &lt;pre&gt; {@code
 * void build(Task[] tasks, int lo, int hi, Phaser ph) {
 *   if (hi - lo &gt; TASKS_PER_PHASER) {
 *     for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
 *       int j = Math.min(i + TASKS_PER_PHASER, hi);
 *       build(tasks, i, j, new Phaser(ph));
 *     }
 *   } else {
 *     for (int i = lo; i &lt; hi; ++i)
 *       tasks[i] = new Task(ph);
 *       // assumes new Task(ph) performs ph.register()
 *   }
 * }}&lt;/pre&gt;
 *
 * The best value of {@code TASKS_PER_PHASER} depends mainly on
 * expected synchronization rates. A value as low as four may
 * be appropriate for extremely small per-phase task bodies (thus
 * high rates), or up to hundreds for extremely large ones.
 *
 * &lt;p&gt;&lt;b&gt;Implementation notes&lt;/b&gt;: This implementation restricts the
 * maximum number of parties to 65535. Attempts to register additional
 * parties result in {@code IllegalStateException}. However, you can and
 * should create tiered phasers to accommodate arbitrarily large sets
 * of participants.
 *
 * @since 1.7
 * @author Doug Lea
 */
public class Phaser {
    /*
     * This class implements an extension of X10 &quot;clocks&quot;.  Thanks to
     * Vijay Saraswat for the idea, and to Vivek Sarkar for
     * enhancements to extend functionality.
     */

    /**
     * Primary state representation, holding four bit-fields:
     *
     * unarrived  -- the number of parties yet to hit barrier (bits  0-15)
     * parties    -- the number of parties to wait            (bits 16-31)
     * phase      -- the generation of the barrier            (bits 32-62)
     * terminated -- set if barrier is terminated             (bit  63 / sign)
     *
     * Except that a phaser with no registered parties is
     * distinguished by the otherwise illegal state of having zero
     * parties and one unarrived parties (encoded as EMPTY below).
     *
     * To efficiently maintain atomicity, these values are packed into
     * a single (atomic) long. Good performance relies on keeping
     * state decoding and encoding simple, and keeping race windows
     * short.
     *
     * All state updates are performed via CAS except initial
     * registration of a sub-phaser (i.e., one with a non-null
     * parent).  In this (relatively rare) case, we use built-in
     * synchronization to lock while first registering with its
     * parent.
     *
     * The phase of a subphaser is allowed to lag that of its
     * ancestors until it is actually accessed -- see method
     * reconcileState.
     */
    private volatile long state;

    private static final int  MAX_PARTIES     = 0xffff;
    private static final int  MAX_PHASE       = Integer.MAX_VALUE;
    private static final int  PARTIES_SHIFT   = 16;
    private static final int  PHASE_SHIFT     = 32;
    private static final int  UNARRIVED_MASK  = 0xffff;      // to mask ints
    private static final long PARTIES_MASK    = 0xffff0000L; // to mask longs
    private static final long COUNTS_MASK     = 0xffffffffL;
    private static final long TERMINATION_BIT = 1L &lt;&lt; 63;

    // some special values
    private static final int  ONE_ARRIVAL     = 1;
    private static final int  ONE_PARTY       = 1 &lt;&lt; PARTIES_SHIFT;
    private static final int  ONE_DEREGISTER  = ONE_ARRIVAL|ONE_PARTY;
    private static final int  EMPTY           = 1;

    // The following unpacking methods are usually manually inlined

    private static int unarrivedOf(long s) {
<span class="nc" id="L315">        int counts = (int)s;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        return (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);</span>
    }

    private static int partiesOf(long s) {
<span class="fc" id="L320">        return (int)s &gt;&gt;&gt; PARTIES_SHIFT;</span>
    }

    private static int phaseOf(long s) {
<span class="nc" id="L324">        return (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
    }

    private static int arrivedOf(long s) {
<span class="fc" id="L328">        int counts = (int)s;</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        return (counts == EMPTY) ? 0 :</span>
            (counts &gt;&gt;&gt; PARTIES_SHIFT) - (counts &amp; UNARRIVED_MASK);
    }

    /**
     * The parent of this phaser, or null if none
     */
    private final Phaser parent;

    /**
     * The root of phaser tree. Equals this if not in a tree.
     */
    private final Phaser root;

    /**
     * Heads of Treiber stacks for waiting threads. To eliminate
     * contention when releasing some threads while adding others, we
     * use two of them, alternating across even and odd phases.
     * Subphasers share queues with root to speed up releases.
     */
    private final AtomicReference&lt;QNode&gt; evenQ;
    private final AtomicReference&lt;QNode&gt; oddQ;

    private AtomicReference&lt;QNode&gt; queueFor(int phase) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">        return ((phase &amp; 1) == 0) ? evenQ : oddQ;</span>
    }

    /**
     * Returns message string for bounds exceptions on arrival.
     */
    private String badArrive(long s) {
<span class="nc" id="L360">        return &quot;Attempted arrival of unregistered party for &quot; +</span>
<span class="nc" id="L361">            stateToString(s);</span>
    }

    /**
     * Returns message string for bounds exceptions on registration.
     */
    private String badRegister(long s) {
<span class="nc" id="L368">        return &quot;Attempt to register more than &quot; +</span>
<span class="nc" id="L369">            MAX_PARTIES + &quot; parties for &quot; + stateToString(s);</span>
    }

    /**
     * Main implementation for methods arrive and arriveAndDeregister.
     * Manually tuned to speed up and minimize race windows for the
     * common case of just decrementing unarrived field.
     *
     * @param adjust value to subtract from state;
     *               ONE_ARRIVAL for arrive,
     *               ONE_DEREGISTER for arriveAndDeregister
     */
    private int doArrive(int adjust) {
<span class="fc" id="L382">        final Phaser root = this.root;</span>
        for (;;) {
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            long s = (root == this) ? state : reconcileState();</span>
<span class="fc" id="L385">            int phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (phase &lt; 0)</span>
<span class="nc" id="L387">                return phase;</span>
<span class="fc" id="L388">            int counts = (int)s;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            int unarrived = (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">            if (unarrived &lt;= 0)</span>
<span class="nc" id="L391">                throw new IllegalStateException(badArrive(s));</span>
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">            if (UNSAFE.compareAndSwapLong(this, stateOffset, s, s-=adjust)) {</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                if (unarrived == 1) {</span>
<span class="fc" id="L394">                    long n = s &amp; PARTIES_MASK;  // base of next state</span>
<span class="fc" id="L395">                    int nextUnarrived = (int)n &gt;&gt;&gt; PARTIES_SHIFT;</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">                    if (root == this) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">                        if (onAdvance(phase, nextUnarrived))</span>
<span class="nc" id="L398">                            n |= TERMINATION_BIT;</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                        else if (nextUnarrived == 0)</span>
<span class="nc" id="L400">                            n |= EMPTY;</span>
                        else
<span class="fc" id="L402">                            n |= nextUnarrived;</span>
<span class="fc" id="L403">                        int nextPhase = (phase + 1) &amp; MAX_PHASE;</span>
<span class="fc" id="L404">                        n |= (long)nextPhase &lt;&lt; PHASE_SHIFT;</span>
<span class="fc" id="L405">                        UNSAFE.compareAndSwapLong(this, stateOffset, s, n);</span>
<span class="fc" id="L406">                        releaseWaiters(phase);</span>
<span class="fc" id="L407">                    }</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                    else if (nextUnarrived == 0) { // propagate deregistration</span>
<span class="nc" id="L409">                        phase = parent.doArrive(ONE_DEREGISTER);</span>
<span class="nc" id="L410">                        UNSAFE.compareAndSwapLong(this, stateOffset,</span>
                                                  s, s | EMPTY);
                    }
                    else
<span class="nc" id="L414">                        phase = parent.doArrive(ONE_ARRIVAL);</span>
                }
<span class="fc" id="L416">                return phase;</span>
            }
<span class="nc" id="L418">        }</span>
    }

    /**
     * Implementation of register, bulkRegister
     *
     * @param registrations number to add to both parties and
     * unarrived fields. Must be greater than zero.
     */
    private int doRegister(int registrations) {
        // adjustment to state
<span class="nc" id="L429">        long adjust = ((long)registrations &lt;&lt; PARTIES_SHIFT) | registrations;</span>
<span class="nc" id="L430">        final Phaser parent = this.parent;</span>
        int phase;
        for (;;) {
<span class="nc bnc" id="L433" title="All 2 branches missed.">            long s = (parent == null) ? state : reconcileState();</span>
<span class="nc" id="L434">            int counts = (int)s;</span>
<span class="nc" id="L435">            int parties = counts &gt;&gt;&gt; PARTIES_SHIFT;</span>
<span class="nc" id="L436">            int unarrived = counts &amp; UNARRIVED_MASK;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            if (registrations &gt; MAX_PARTIES - parties)</span>
<span class="nc" id="L438">                throw new IllegalStateException(badRegister(s));</span>
<span class="nc" id="L439">            phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            if (phase &lt; 0)</span>
<span class="nc" id="L441">                break;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (counts != EMPTY) {                  // not 1st registration</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">                if (parent == null || reconcileState() == s) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (unarrived == 0)             // wait out advance</span>
<span class="nc" id="L445">                        root.internalAwaitAdvance(phase, null);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    else if (UNSAFE.compareAndSwapLong(this, stateOffset,</span>
                                                       s, s + adjust))
<span class="nc" id="L448">                        break;</span>
                }
            }
<span class="nc bnc" id="L451" title="All 2 branches missed.">            else if (parent == null) {              // 1st root registration</span>
<span class="nc" id="L452">                long next = ((long)phase &lt;&lt; PHASE_SHIFT) | adjust;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (UNSAFE.compareAndSwapLong(this, stateOffset, s, next))</span>
<span class="nc" id="L454">                    break;</span>
<span class="nc" id="L455">            }</span>
            else {
<span class="nc" id="L457">                synchronized (this) {               // 1st sub registration</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (state == s) {               // recheck under lock</span>
<span class="nc" id="L459">                        phase = parent.doRegister(1);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                        if (phase &lt; 0)</span>
<span class="nc" id="L461">                            break;</span>
                        // finish registration whenever parent registration
                        // succeeded, even when racing with termination,
                        // since these are part of the same &quot;transaction&quot;.
<span class="nc" id="L465">                        while (!UNSAFE.compareAndSwapLong</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                               (this, stateOffset, s,</span>
                                ((long)phase &lt;&lt; PHASE_SHIFT) | adjust)) {
<span class="nc" id="L468">                            s = state;</span>
<span class="nc" id="L469">                            phase = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span>
                            // assert (int)s == EMPTY;
                        }
<span class="nc" id="L472">                        break;</span>
                    }
<span class="nc" id="L474">                }</span>
            }
<span class="nc" id="L476">        }</span>
<span class="nc" id="L477">        return phase;</span>
    }

    /**
     * Resolves lagged phase propagation from root if necessary.
     * Reconciliation normally occurs when root has advanced but
     * subphasers have not yet done so, in which case they must finish
     * their own advance by setting unarrived to parties (or if
     * parties is zero, resetting to unregistered EMPTY state).
     *
     * @return reconciled state
     */
    private long reconcileState() {
<span class="fc" id="L490">        final Phaser root = this.root;</span>
<span class="fc" id="L491">        long s = state;</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if (root != this) {</span>
            int phase, p;
            // CAS to root phase with current parties, tripping unarrived
<span class="nc bnc" id="L495" title="All 6 branches missed.">            while ((phase = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT)) !=</span>
                   (int)(s &gt;&gt;&gt; PHASE_SHIFT) &amp;&amp;
                   !UNSAFE.compareAndSwapLong
<span class="nc bnc" id="L498" title="All 2 branches missed.">                   (this, stateOffset, s,</span>
                    s = (((long)phase &lt;&lt; PHASE_SHIFT) |
                         ((phase &lt; 0) ? (s &amp; COUNTS_MASK) :
                          (((p = (int)s &gt;&gt;&gt; PARTIES_SHIFT) == 0) ? EMPTY :
                           ((s &amp; PARTIES_MASK) | p))))))
<span class="nc" id="L503">                s = state;</span>
        }
<span class="fc" id="L505">        return s;</span>
    }

    /**
     * Creates a new phaser with no initially registered parties, no
     * parent, and initial phase number 0. Any thread using this
     * phaser will need to first register for it.
     */
    public Phaser() {
<span class="nc" id="L514">        this(null, 0);</span>
<span class="nc" id="L515">    }</span>

    /**
     * Creates a new phaser with the given number of registered
     * unarrived parties, no parent, and initial phase number 0.
     *
     * @param parties the number of parties required to advance to the
     * next phase
     * @throws IllegalArgumentException if parties less than zero
     * or greater than the maximum number of parties supported
     */
    public Phaser(int parties) {
<span class="fc" id="L527">        this(null, parties);</span>
<span class="fc" id="L528">    }</span>

    /**
     * Equivalent to {@link #Phaser(Phaser, int) Phaser(parent, 0)}.
     *
     * @param parent the parent phaser
     */
    public Phaser(Phaser parent) {
<span class="nc" id="L536">        this(parent, 0);</span>
<span class="nc" id="L537">    }</span>

    /**
     * Creates a new phaser with the given parent and number of
     * registered unarrived parties.  When the given parent is non-null
     * and the given number of parties is greater than zero, this
     * child phaser is registered with its parent.
     *
     * @param parent the parent phaser
     * @param parties the number of parties required to advance to the
     * next phase
     * @throws IllegalArgumentException if parties less than zero
     * or greater than the maximum number of parties supported
     */
<span class="fc" id="L551">    public Phaser(Phaser parent, int parties) {</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (parties &gt;&gt;&gt; PARTIES_SHIFT != 0)</span>
<span class="nc" id="L553">            throw new IllegalArgumentException(&quot;Illegal number of parties&quot;);</span>
<span class="fc" id="L554">        int phase = 0;</span>
<span class="fc" id="L555">        this.parent = parent;</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L557">            final Phaser root = parent.root;</span>
<span class="nc" id="L558">            this.root = root;</span>
<span class="nc" id="L559">            this.evenQ = root.evenQ;</span>
<span class="nc" id="L560">            this.oddQ = root.oddQ;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (parties != 0)</span>
<span class="nc" id="L562">                phase = parent.doRegister(1);</span>
<span class="nc" id="L563">        }</span>
        else {
<span class="fc" id="L565">            this.root = this;</span>
<span class="fc" id="L566">            this.evenQ = new AtomicReference&lt;QNode&gt;();</span>
<span class="fc" id="L567">            this.oddQ = new AtomicReference&lt;QNode&gt;();</span>
        }
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">        this.state = (parties == 0) ? (long)EMPTY :</span>
            ((long)phase &lt;&lt; PHASE_SHIFT) |
            ((long)parties &lt;&lt; PARTIES_SHIFT) |
            ((long)parties);
<span class="fc" id="L573">    }</span>

    /**
     * Adds a new unarrived party to this phaser.  If an ongoing
     * invocation of {@link #onAdvance} is in progress, this method
     * may await its completion before returning.  If this phaser has
     * a parent, and this phaser previously had no registered parties,
     * this child phaser is also registered with its parent. If
     * this phaser is terminated, the attempt to register has
     * no effect, and a negative value is returned.
     *
     * @return the arrival phase number to which this registration
     * applied.  If this value is negative, then this phaser has
     * terminated, in which case registration has no effect.
     * @throws IllegalStateException if attempting to register more
     * than the maximum supported number of parties
     */
    public int register() {
<span class="nc" id="L591">        return doRegister(1);</span>
    }

    /**
     * Adds the given number of new unarrived parties to this phaser.
     * If an ongoing invocation of {@link #onAdvance} is in progress,
     * this method may await its completion before returning.  If this
     * phaser has a parent, and the given number of parties is greater
     * than zero, and this phaser previously had no registered
     * parties, this child phaser is also registered with its parent.
     * If this phaser is terminated, the attempt to register has no
     * effect, and a negative value is returned.
     *
     * @param parties the number of additional parties required to
     * advance to the next phase
     * @return the arrival phase number to which this registration
     * applied.  If this value is negative, then this phaser has
     * terminated, in which case registration has no effect.
     * @throws IllegalStateException if attempting to register more
     * than the maximum supported number of parties
     * @throws IllegalArgumentException if {@code parties &lt; 0}
     */
    public int bulkRegister(int parties) {
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (parties &lt; 0)</span>
<span class="nc" id="L615">            throw new IllegalArgumentException();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (parties == 0)</span>
<span class="nc" id="L617">            return getPhase();</span>
<span class="nc" id="L618">        return doRegister(parties);</span>
    }

    /**
     * Arrives at this phaser, without waiting for others to arrive.
     *
     * &lt;p&gt;It is a usage error for an unregistered party to invoke this
     * method.  However, this error may result in an {@code
     * IllegalStateException} only upon some subsequent operation on
     * this phaser, if ever.
     *
     * @return the arrival phase number, or a negative value if terminated
     * @throws IllegalStateException if not terminated and the number
     * of unarrived parties would become negative
     */
    public int arrive() {
<span class="fc" id="L634">        return doArrive(ONE_ARRIVAL);</span>
    }

    /**
     * Arrives at this phaser and deregisters from it without waiting
     * for others to arrive. Deregistration reduces the number of
     * parties required to advance in future phases.  If this phaser
     * has a parent, and deregistration causes this phaser to have
     * zero parties, this phaser is also deregistered from its parent.
     *
     * &lt;p&gt;It is a usage error for an unregistered party to invoke this
     * method.  However, this error may result in an {@code
     * IllegalStateException} only upon some subsequent operation on
     * this phaser, if ever.
     *
     * @return the arrival phase number, or a negative value if terminated
     * @throws IllegalStateException if not terminated and the number
     * of registered or unarrived parties would become negative
     */
    public int arriveAndDeregister() {
<span class="nc" id="L654">        return doArrive(ONE_DEREGISTER);</span>
    }

    /**
     * Arrives at this phaser and awaits others. Equivalent in effect
     * to {@code awaitAdvance(arrive())}.  If you need to await with
     * interruption or timeout, you can arrange this with an analogous
     * construction using one of the other forms of the {@code
     * awaitAdvance} method.  If instead you need to deregister upon
     * arrival, use {@code awaitAdvance(arriveAndDeregister())}.
     *
     * &lt;p&gt;It is a usage error for an unregistered party to invoke this
     * method.  However, this error may result in an {@code
     * IllegalStateException} only upon some subsequent operation on
     * this phaser, if ever.
     *
     * @return the arrival phase number, or the (negative)
     * {@linkplain #getPhase() current phase} if terminated
     * @throws IllegalStateException if not terminated and the number
     * of unarrived parties would become negative
     */
    public int arriveAndAwaitAdvance() {
        // Specialization of doArrive+awaitAdvance eliminating some reads/paths
<span class="fc" id="L677">        final Phaser root = this.root;</span>
        for (;;) {
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">            long s = (root == this) ? state : reconcileState();</span>
<span class="fc" id="L680">            int phase = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">            if (phase &lt; 0)</span>
<span class="nc" id="L682">                return phase;</span>
<span class="fc" id="L683">            int counts = (int)s;</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">            int unarrived = (counts == EMPTY) ? 0 : (counts &amp; UNARRIVED_MASK);</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">            if (unarrived &lt;= 0)</span>
<span class="nc" id="L686">                throw new IllegalStateException(badArrive(s));</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">            if (UNSAFE.compareAndSwapLong(this, stateOffset, s,</span>
                                          s -= ONE_ARRIVAL)) {
<span class="fc bfc" id="L689" title="All 2 branches covered.">                if (unarrived &gt; 1)</span>
<span class="fc" id="L690">                    return root.internalAwaitAdvance(phase, null);</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">                if (root != this)</span>
<span class="nc" id="L692">                    return parent.arriveAndAwaitAdvance();</span>
<span class="fc" id="L693">                long n = s &amp; PARTIES_MASK;  // base of next state</span>
<span class="fc" id="L694">                int nextUnarrived = (int)n &gt;&gt;&gt; PARTIES_SHIFT;</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">                if (onAdvance(phase, nextUnarrived))</span>
<span class="nc" id="L696">                    n |= TERMINATION_BIT;</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                else if (nextUnarrived == 0)</span>
<span class="nc" id="L698">                    n |= EMPTY;</span>
                else
<span class="fc" id="L700">                    n |= nextUnarrived;</span>
<span class="fc" id="L701">                int nextPhase = (phase + 1) &amp; MAX_PHASE;</span>
<span class="fc" id="L702">                n |= (long)nextPhase &lt;&lt; PHASE_SHIFT;</span>
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">                if (!UNSAFE.compareAndSwapLong(this, stateOffset, s, n))</span>
<span class="nc" id="L704">                    return (int)(state &gt;&gt;&gt; PHASE_SHIFT); // terminated</span>
<span class="fc" id="L705">                releaseWaiters(phase);</span>
<span class="fc" id="L706">                return nextPhase;</span>
            }
<span class="nc" id="L708">        }</span>
    }

    /**
     * Awaits the phase of this phaser to advance from the given phase
     * value, returning immediately if the current phase is not equal
     * to the given phase value or this phaser is terminated.
     *
     * @param phase an arrival phase number, or negative value if
     * terminated; this argument is normally the value returned by a
     * previous call to {@code arrive} or {@code arriveAndDeregister}.
     * @return the next arrival phase number, or the argument if it is
     * negative, or the (negative) {@linkplain #getPhase() current phase}
     * if terminated
     */
    public int awaitAdvance(int phase) {
<span class="fc" id="L724">        final Phaser root = this.root;</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        long s = (root == this) ? state : reconcileState();</span>
<span class="fc" id="L726">        int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">        if (phase &lt; 0)</span>
<span class="nc" id="L728">            return phase;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (p == phase)</span>
<span class="fc" id="L730">            return root.internalAwaitAdvance(phase, null);</span>
<span class="fc" id="L731">        return p;</span>
    }

    /**
     * Awaits the phase of this phaser to advance from the given phase
     * value, throwing {@code InterruptedException} if interrupted
     * while waiting, or returning immediately if the current phase is
     * not equal to the given phase value or this phaser is
     * terminated.
     *
     * @param phase an arrival phase number, or negative value if
     * terminated; this argument is normally the value returned by a
     * previous call to {@code arrive} or {@code arriveAndDeregister}.
     * @return the next arrival phase number, or the argument if it is
     * negative, or the (negative) {@linkplain #getPhase() current phase}
     * if terminated
     * @throws InterruptedException if thread interrupted while waiting
     */
    public int awaitAdvanceInterruptibly(int phase)
        throws InterruptedException {
<span class="nc" id="L751">        final Phaser root = this.root;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">        long s = (root == this) ? state : reconcileState();</span>
<span class="nc" id="L753">        int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (phase &lt; 0)</span>
<span class="nc" id="L755">            return phase;</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (p == phase) {</span>
<span class="nc" id="L757">            QNode node = new QNode(this, phase, true, false, 0L);</span>
<span class="nc" id="L758">            p = root.internalAwaitAdvance(phase, node);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if (node.wasInterrupted)</span>
<span class="nc" id="L760">                throw new InterruptedException();</span>
        }
<span class="nc" id="L762">        return p;</span>
    }

    /**
     * Awaits the phase of this phaser to advance from the given phase
     * value or the given timeout to elapse, throwing {@code
     * InterruptedException} if interrupted while waiting, or
     * returning immediately if the current phase is not equal to the
     * given phase value or this phaser is terminated.
     *
     * @param phase an arrival phase number, or negative value if
     * terminated; this argument is normally the value returned by a
     * previous call to {@code arrive} or {@code arriveAndDeregister}.
     * @param timeout how long to wait before giving up, in units of
     *        {@code unit}
     * @param unit a {@code TimeUnit} determining how to interpret the
     *        {@code timeout} parameter
     * @return the next arrival phase number, or the argument if it is
     * negative, or the (negative) {@linkplain #getPhase() current phase}
     * if terminated
     * @throws InterruptedException if thread interrupted while waiting
     * @throws TimeoutException if timed out while waiting
     */
    public int awaitAdvanceInterruptibly(int phase,
                                         long timeout, TimeUnit unit)
        throws InterruptedException, TimeoutException {
<span class="fc" id="L788">        long nanos = unit.toNanos(timeout);</span>
<span class="fc" id="L789">        final Phaser root = this.root;</span>
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">        long s = (root == this) ? state : reconcileState();</span>
<span class="fc" id="L791">        int p = (int)(s &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">        if (phase &lt; 0)</span>
<span class="nc" id="L793">            return phase;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (p == phase) {</span>
<span class="fc" id="L795">            QNode node = new QNode(this, phase, true, true, nanos);</span>
<span class="fc" id="L796">            p = root.internalAwaitAdvance(phase, node);</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (node.wasInterrupted)</span>
<span class="nc" id="L798">                throw new InterruptedException();</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">            else if (p == phase)</span>
<span class="nc" id="L800">                throw new TimeoutException();</span>
        }
<span class="fc" id="L802">        return p;</span>
    }

    /**
     * Forces this phaser to enter termination state.  Counts of
     * registered parties are unaffected.  If this phaser is a member
     * of a tiered set of phasers, then all of the phasers in the set
     * are terminated.  If this phaser is already terminated, this
     * method has no effect.  This method may be useful for
     * coordinating recovery after one or more tasks encounter
     * unexpected exceptions.
     */
    public void forceTermination() {
        // Only need to change root state
<span class="nc" id="L816">        final Phaser root = this.root;</span>
        long s;
<span class="nc bnc" id="L818" title="All 2 branches missed.">        while ((s = root.state) &gt;= 0) {</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (UNSAFE.compareAndSwapLong(root, stateOffset,</span>
                                          s, s | TERMINATION_BIT)) {
                // signal all threads
<span class="nc" id="L822">                releaseWaiters(0); // Waiters on evenQ</span>
<span class="nc" id="L823">                releaseWaiters(1); // Waiters on oddQ</span>
<span class="nc" id="L824">                return;</span>
            }
        }
<span class="nc" id="L827">    }</span>

    /**
     * Returns the current phase number. The maximum phase number is
     * {@code Integer.MAX_VALUE}, after which it restarts at
     * zero. Upon termination, the phase number is negative,
     * in which case the prevailing phase prior to termination
     * may be obtained via {@code getPhase() + Integer.MIN_VALUE}.
     *
     * @return the phase number, or a negative value if terminated
     */
    public final int getPhase() {
<span class="fc" id="L839">        return (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span>
    }

    /**
     * Returns the number of parties registered at this phaser.
     *
     * @return the number of parties
     */
    public int getRegisteredParties() {
<span class="fc" id="L848">        return partiesOf(state);</span>
    }

    /**
     * Returns the number of registered parties that have arrived at
     * the current phase of this phaser. If this phaser has terminated,
     * the returned value is meaningless and arbitrary.
     *
     * @return the number of arrived parties
     */
    public int getArrivedParties() {
<span class="fc" id="L859">        return arrivedOf(reconcileState());</span>
    }

    /**
     * Returns the number of registered parties that have not yet
     * arrived at the current phase of this phaser. If this phaser has
     * terminated, the returned value is meaningless and arbitrary.
     *
     * @return the number of unarrived parties
     */
    public int getUnarrivedParties() {
<span class="nc" id="L870">        return unarrivedOf(reconcileState());</span>
    }

    /**
     * Returns the parent of this phaser, or {@code null} if none.
     *
     * @return the parent of this phaser, or {@code null} if none
     */
    public Phaser getParent() {
<span class="nc" id="L879">        return parent;</span>
    }

    /**
     * Returns the root ancestor of this phaser, which is the same as
     * this phaser if it has no parent.
     *
     * @return the root ancestor of this phaser
     */
    public Phaser getRoot() {
<span class="nc" id="L889">        return root;</span>
    }

    /**
     * Returns {@code true} if this phaser has been terminated.
     *
     * @return {@code true} if this phaser has been terminated
     */
    public boolean isTerminated() {
<span class="nc bnc" id="L898" title="All 2 branches missed.">        return root.state &lt; 0L;</span>
    }

    /**
     * Overridable method to perform an action upon impending phase
     * advance, and to control termination. This method is invoked
     * upon arrival of the party advancing this phaser (when all other
     * waiting parties are dormant).  If this method returns {@code
     * true}, this phaser will be set to a final termination state
     * upon advance, and subsequent calls to {@link #isTerminated}
     * will return true. Any (unchecked) Exception or Error thrown by
     * an invocation of this method is propagated to the party
     * attempting to advance this phaser, in which case no advance
     * occurs.
     *
     * &lt;p&gt;The arguments to this method provide the state of the phaser
     * prevailing for the current transition.  The effects of invoking
     * arrival, registration, and waiting methods on this phaser from
     * within {@code onAdvance} are unspecified and should not be
     * relied on.
     *
     * &lt;p&gt;If this phaser is a member of a tiered set of phasers, then
     * {@code onAdvance} is invoked only for its root phaser on each
     * advance.
     *
     * &lt;p&gt;To support the most common use cases, the default
     * implementation of this method returns {@code true} when the
     * number of registered parties has become zero as the result of a
     * party invoking {@code arriveAndDeregister}.  You can disable
     * this behavior, thus enabling continuation upon future
     * registrations, by overriding this method to always return
     * {@code false}:
     *
     * &lt;pre&gt; {@code
     * Phaser phaser = new Phaser() {
     *   protected boolean onAdvance(int phase, int parties) { return false; }
     * }}&lt;/pre&gt;
     *
     * @param phase the current phase number on entry to this method,
     * before this phaser is advanced
     * @param registeredParties the current number of registered parties
     * @return {@code true} if this phaser should terminate
     */
    protected boolean onAdvance(int phase, int registeredParties) {
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        return registeredParties == 0;</span>
    }

    /**
     * Returns a string identifying this phaser, as well as its
     * state.  The state, in brackets, includes the String {@code
     * &quot;phase = &quot;} followed by the phase number, {@code &quot;parties = &quot;}
     * followed by the number of registered parties, and {@code
     * &quot;arrived = &quot;} followed by the number of arrived parties.
     *
     * @return a string identifying this phaser, as well as its state
     */
    public String toString() {
<span class="nc" id="L955">        return stateToString(reconcileState());</span>
    }

    /**
     * Implementation of toString and string-based error messages
     */
    private String stateToString(long s) {
<span class="nc" id="L962">        return super.toString() +</span>
<span class="nc" id="L963">            &quot;[phase = &quot; + phaseOf(s) +</span>
<span class="nc" id="L964">            &quot; parties = &quot; + partiesOf(s) +</span>
<span class="nc" id="L965">            &quot; arrived = &quot; + arrivedOf(s) + &quot;]&quot;;</span>
    }

    // Waiting mechanics

    /**
     * Removes and signals threads from queue for phase.
     */
    private void releaseWaiters(int phase) {
        QNode q;   // first element of queue
        Thread t;  // its thread
<span class="fc bfc" id="L976" title="All 2 branches covered.">        AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;</span>
<span class="pc bpc" id="L977" title="1 of 4 branches missed.">        while ((q = head.get()) != null &amp;&amp;</span>
               q.phase != (int)(root.state &gt;&gt;&gt; PHASE_SHIFT)) {
<span class="pc bpc" id="L979" title="1 of 4 branches missed.">            if (head.compareAndSet(q, q.next) &amp;&amp;</span>
                (t = q.thread) != null) {
<span class="fc" id="L981">                q.thread = null;</span>
<span class="fc" id="L982">                LockSupport.unpark(t);</span>
            }
        }
<span class="fc" id="L985">    }</span>

    /**
     * Variant of releaseWaiters that additionally tries to remove any
     * nodes no longer waiting for advance due to timeout or
     * interrupt. Currently, nodes are removed only if they are at
     * head of queue, which suffices to reduce memory footprint in
     * most usages.
     *
     * @return current phase on exit
     */
    private int abortWait(int phase) {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;</span>
        for (;;) {
            Thread t;
<span class="nc" id="L1000">            QNode q = head.get();</span>
<span class="nc" id="L1001">            int p = (int)(root.state &gt;&gt;&gt; PHASE_SHIFT);</span>
<span class="nc bnc" id="L1002" title="All 6 branches missed.">            if (q == null || ((t = q.thread) != null &amp;&amp; q.phase == p))</span>
<span class="nc" id="L1003">                return p;</span>
<span class="nc bnc" id="L1004" title="All 4 branches missed.">            if (head.compareAndSet(q, q.next) &amp;&amp; t != null) {</span>
<span class="nc" id="L1005">                q.thread = null;</span>
<span class="nc" id="L1006">                LockSupport.unpark(t);</span>
            }
<span class="nc" id="L1008">        }</span>
    }

    /** The number of CPUs, for spin control */
<span class="fc" id="L1012">    private static final int NCPU = Runtime.getRuntime().availableProcessors();</span>

    /**
     * The number of times to spin before blocking while waiting for
     * advance, per arrival while waiting. On multiprocessors, fully
     * blocking and waking up a large number of threads all at once is
     * usually a very slow process, so we use rechargeable spins to
     * avoid it when threads regularly arrive: When a thread in
     * internalAwaitAdvance notices another arrival before blocking,
     * and there appear to be enough CPUs available, it spins
     * SPINS_PER_ARRIVAL more times before blocking. The value trades
     * off good-citizenship vs big unnecessary slowdowns.
     */
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">    static final int SPINS_PER_ARRIVAL = (NCPU &lt; 2) ? 1 : 1 &lt;&lt; 8;</span>

    /**
     * Possibly blocks and waits for phase to advance unless aborted.
     * Call only on root phaser.
     *
     * @param phase current phase
     * @param node if non-null, the wait node to track interrupt and timeout;
     * if null, denotes noninterruptible wait
     * @return current phase
     */
    private int internalAwaitAdvance(int phase, QNode node) {
        // assert root == this;
<span class="fc" id="L1038">        releaseWaiters(phase-1);          // ensure old queue clean</span>
<span class="fc" id="L1039">        boolean queued = false;           // true when node is enqueued</span>
<span class="fc" id="L1040">        int lastUnarrived = 0;            // to increase spins upon change</span>
<span class="fc" id="L1041">        int spins = SPINS_PER_ARRIVAL;</span>
        long s;
        int p;
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        while ((p = (int)((s = state) &gt;&gt;&gt; PHASE_SHIFT)) == phase) {</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">            if (node == null) {           // spinning in noninterruptible mode</span>
<span class="fc" id="L1046">                int unarrived = (int)s &amp; UNARRIVED_MASK;</span>
<span class="pc bpc" id="L1047" title="1 of 4 branches missed.">                if (unarrived != lastUnarrived &amp;&amp;</span>
                    (lastUnarrived = unarrived) &lt; NCPU)
<span class="fc" id="L1049">                    spins += SPINS_PER_ARRIVAL;</span>
<span class="fc" id="L1050">                boolean interrupted = Thread.interrupted();</span>
<span class="pc bpc" id="L1051" title="1 of 4 branches missed.">                if (interrupted || --spins &lt; 0) { // need node to record intr</span>
<span class="fc" id="L1052">                    node = new QNode(this, phase, false, false, 0L);</span>
<span class="fc" id="L1053">                    node.wasInterrupted = interrupted;</span>
                }
<span class="fc" id="L1055">            }</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            else if (node.isReleasable()) // done or aborted</span>
<span class="fc" id="L1057">                break;</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">            else if (!queued) {           // push onto queue</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">                AtomicReference&lt;QNode&gt; head = (phase &amp; 1) == 0 ? evenQ : oddQ;</span>
<span class="fc" id="L1060">                QNode q = node.next = head.get();</span>
<span class="pc bpc" id="L1061" title="2 of 6 branches missed.">                if ((q == null || q.phase == phase) &amp;&amp;</span>
                    (int)(state &gt;&gt;&gt; PHASE_SHIFT) == phase) // avoid stale enq
<span class="fc" id="L1063">                    queued = head.compareAndSet(q, node);</span>
<span class="fc" id="L1064">            }</span>
            else {
                try {
<span class="fc" id="L1067">                    ForkJoinPool.managedBlock(node);</span>
<span class="nc" id="L1068">                } catch (InterruptedException ie) {</span>
<span class="nc" id="L1069">                    node.wasInterrupted = true;</span>
<span class="pc" id="L1070">                }</span>
            }
        }

<span class="fc bfc" id="L1074" title="All 2 branches covered.">        if (node != null) {</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (node.thread != null)</span>
<span class="fc" id="L1076">                node.thread = null;       // avoid need for unpark()</span>
<span class="pc bpc" id="L1077" title="3 of 4 branches missed.">            if (node.wasInterrupted &amp;&amp; !node.interruptible)</span>
<span class="nc" id="L1078">                Thread.currentThread().interrupt();</span>
<span class="pc bpc" id="L1079" title="1 of 4 branches missed.">            if (p == phase &amp;&amp; (p = (int)(state &gt;&gt;&gt; PHASE_SHIFT)) == phase)</span>
<span class="nc" id="L1080">                return abortWait(phase); // possibly clean up on abort</span>
        }
<span class="fc" id="L1082">        releaseWaiters(phase);</span>
<span class="fc" id="L1083">        return p;</span>
    }

    /**
     * Wait nodes for Treiber stack representing wait queue
     */
    static final class QNode implements ForkJoinPool.ManagedBlocker {
        final Phaser phaser;
        final int phase;
        final boolean interruptible;
        final boolean timed;
        boolean wasInterrupted;
        long nanos;
        final long deadline;
        volatile Thread thread; // nulled to cancel wait
        QNode next;

        QNode(Phaser phaser, int phase, boolean interruptible,
<span class="fc" id="L1101">              boolean timed, long nanos) {</span>
<span class="fc" id="L1102">            this.phaser = phaser;</span>
<span class="fc" id="L1103">            this.phase = phase;</span>
<span class="fc" id="L1104">            this.interruptible = interruptible;</span>
<span class="fc" id="L1105">            this.nanos = nanos;</span>
<span class="fc" id="L1106">            this.timed = timed;</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">            this.deadline = timed ? System.nanoTime() + nanos : 0L;</span>
<span class="fc" id="L1108">            thread = Thread.currentThread();</span>
<span class="fc" id="L1109">        }</span>

        public boolean isReleasable() {
<span class="fc bfc" id="L1112" title="All 2 branches covered.">            if (thread == null)</span>
<span class="fc" id="L1113">                return true;</span>
<span class="fc bfc" id="L1114" title="All 2 branches covered.">            if (phaser.getPhase() != phase) {</span>
<span class="fc" id="L1115">                thread = null;</span>
<span class="fc" id="L1116">                return true;</span>
            }
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">            if (Thread.interrupted())</span>
<span class="nc" id="L1119">                wasInterrupted = true;</span>
<span class="pc bpc" id="L1120" title="3 of 4 branches missed.">            if (wasInterrupted &amp;&amp; interruptible) {</span>
<span class="nc" id="L1121">                thread = null;</span>
<span class="nc" id="L1122">                return true;</span>
            }
<span class="fc bfc" id="L1124" title="All 2 branches covered.">            if (timed) {</span>
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">                if (nanos &gt; 0L) {</span>
<span class="fc" id="L1126">                    nanos = deadline - System.nanoTime();</span>
                }
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">                if (nanos &lt;= 0L) {</span>
<span class="nc" id="L1129">                    thread = null;</span>
<span class="nc" id="L1130">                    return true;</span>
                }
            }
<span class="fc" id="L1133">            return false;</span>
        }

        public boolean block() {
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">            if (isReleasable())</span>
<span class="nc" id="L1138">                return true;</span>
<span class="fc bfc" id="L1139" title="All 2 branches covered.">            else if (!timed)</span>
<span class="fc" id="L1140">                LockSupport.park(this);</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">            else if (nanos &gt; 0L)</span>
<span class="fc" id="L1142">                LockSupport.parkNanos(this, nanos);</span>
<span class="fc" id="L1143">            return isReleasable();</span>
        }
    }

    // Unsafe mechanics

    private static final sun.misc.Unsafe UNSAFE;
    private static final long stateOffset;
    static {
        try {
<span class="fc" id="L1153">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L1154">            Class&lt;?&gt; k = Phaser.class;</span>
<span class="fc" id="L1155">            stateOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L1156">                (k.getDeclaredField(&quot;state&quot;));</span>
<span class="nc" id="L1157">        } catch (Exception e) {</span>
<span class="nc" id="L1158">            throw new Error(e);</span>
<span class="fc" id="L1159">        }</span>
<span class="fc" id="L1160">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>