<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ForkJoinTask.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.concurrent</a> &gt; <span class="el_source">ForkJoinTask.java</span></div><h1>ForkJoinTask.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Written by Doug Lea with assistance from members of JCP JSR-166
 * Expert Group and released to the public domain, as explained at
 * http://creativecommons.org/publicdomain/zero/1.0/
 */

package java.util.concurrent;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.RandomAccess;
import java.lang.ref.WeakReference;
import java.lang.ref.ReferenceQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.ReentrantLock;
import java.lang.reflect.Constructor;

/**
 * Abstract base class for tasks that run within a {@link ForkJoinPool}.
 * A {@code ForkJoinTask} is a thread-like entity that is much
 * lighter weight than a normal thread.  Huge numbers of tasks and
 * subtasks may be hosted by a small number of actual threads in a
 * ForkJoinPool, at the price of some usage limitations.
 *
 * &lt;p&gt;A &quot;main&quot; {@code ForkJoinTask} begins execution when it is
 * explicitly submitted to a {@link ForkJoinPool}, or, if not already
 * engaged in a ForkJoin computation, commenced in the {@link
 * ForkJoinPool#commonPool()} via {@link #fork}, {@link #invoke}, or
 * related methods.  Once started, it will usually in turn start other
 * subtasks.  As indicated by the name of this class, many programs
 * using {@code ForkJoinTask} employ only methods {@link #fork} and
 * {@link #join}, or derivatives such as {@link
 * #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also
 * provides a number of other methods that can come into play in
 * advanced usages, as well as extension mechanics that allow support
 * of new forms of fork/join processing.
 *
 * &lt;p&gt;A {@code ForkJoinTask} is a lightweight form of {@link Future}.
 * The efficiency of {@code ForkJoinTask}s stems from a set of
 * restrictions (that are only partially statically enforceable)
 * reflecting their main use as computational tasks calculating pure
 * functions or operating on purely isolated objects.  The primary
 * coordination mechanisms are {@link #fork}, that arranges
 * asynchronous execution, and {@link #join}, that doesn't proceed
 * until the task's result has been computed.  Computations should
 * ideally avoid {@code synchronized} methods or blocks, and should
 * minimize other blocking synchronization apart from joining other
 * tasks or using synchronizers such as Phasers that are advertised to
 * cooperate with fork/join scheduling. Subdividable tasks should also
 * not perform blocking I/O, and should ideally access variables that
 * are completely independent of those accessed by other running
 * tasks. These guidelines are loosely enforced by not permitting
 * checked exceptions such as {@code IOExceptions} to be
 * thrown. However, computations may still encounter unchecked
 * exceptions, that are rethrown to callers attempting to join
 * them. These exceptions may additionally include {@link
 * RejectedExecutionException} stemming from internal resource
 * exhaustion, such as failure to allocate internal task
 * queues. Rethrown exceptions behave in the same way as regular
 * exceptions, but, when possible, contain stack traces (as displayed
 * for example using {@code ex.printStackTrace()}) of both the thread
 * that initiated the computation as well as the thread actually
 * encountering the exception; minimally only the latter.
 *
 * &lt;p&gt;It is possible to define and use ForkJoinTasks that may block,
 * but doing do requires three further considerations: (1) Completion
 * of few if any &lt;em&gt;other&lt;/em&gt; tasks should be dependent on a task
 * that blocks on external synchronization or I/O. Event-style async
 * tasks that are never joined (for example, those subclassing {@link
 * CountedCompleter}) often fall into this category.  (2) To minimize
 * resource impact, tasks should be small; ideally performing only the
 * (possibly) blocking action. (3) Unless the {@link
 * ForkJoinPool.ManagedBlocker} API is used, or the number of possibly
 * blocked tasks is known to be less than the pool's {@link
 * ForkJoinPool#getParallelism} level, the pool cannot guarantee that
 * enough threads will be available to ensure progress or good
 * performance.
 *
 * &lt;p&gt;The primary method for awaiting completion and extracting
 * results of a task is {@link #join}, but there are several variants:
 * The {@link Future#get} methods support interruptible and/or timed
 * waits for completion and report results using {@code Future}
 * conventions. Method {@link #invoke} is semantically
 * equivalent to {@code fork(); join()} but always attempts to begin
 * execution in the current thread. The &quot;&lt;em&gt;quiet&lt;/em&gt;&quot; forms of
 * these methods do not extract results or report exceptions. These
 * may be useful when a set of tasks are being executed, and you need
 * to delay processing of results or exceptions until all complete.
 * Method {@code invokeAll} (available in multiple versions)
 * performs the most common form of parallel invocation: forking a set
 * of tasks and joining them all.
 *
 * &lt;p&gt;In the most typical usages, a fork-join pair act like a call
 * (fork) and return (join) from a parallel recursive function. As is
 * the case with other forms of recursive calls, returns (joins)
 * should be performed innermost-first. For example, {@code a.fork();
 * b.fork(); b.join(); a.join();} is likely to be substantially more
 * efficient than joining {@code a} before {@code b}.
 *
 * &lt;p&gt;The execution status of tasks may be queried at several levels
 * of detail: {@link #isDone} is true if a task completed in any way
 * (including the case where a task was cancelled without executing);
 * {@link #isCompletedNormally} is true if a task completed without
 * cancellation or encountering an exception; {@link #isCancelled} is
 * true if the task was cancelled (in which case {@link #getException}
 * returns a {@link java.util.concurrent.CancellationException}); and
 * {@link #isCompletedAbnormally} is true if a task was either
 * cancelled or encountered an exception, in which case {@link
 * #getException} will return either the encountered exception or
 * {@link java.util.concurrent.CancellationException}.
 *
 * &lt;p&gt;The ForkJoinTask class is not usually directly subclassed.
 * Instead, you subclass one of the abstract classes that support a
 * particular style of fork/join processing, typically {@link
 * RecursiveAction} for most computations that do not return results,
 * {@link RecursiveTask} for those that do, and {@link
 * CountedCompleter} for those in which completed actions trigger
 * other actions.  Normally, a concrete ForkJoinTask subclass declares
 * fields comprising its parameters, established in a constructor, and
 * then defines a {@code compute} method that somehow uses the control
 * methods supplied by this base class.
 *
 * &lt;p&gt;Method {@link #join} and its variants are appropriate for use
 * only when completion dependencies are acyclic; that is, the
 * parallel computation can be described as a directed acyclic graph
 * (DAG). Otherwise, executions may encounter a form of deadlock as
 * tasks cyclically wait for each other.  However, this framework
 * supports other methods and techniques (for example the use of
 * {@link Phaser}, {@link #helpQuiesce}, and {@link #complete}) that
 * may be of use in constructing custom subclasses for problems that
 * are not statically structured as DAGs. To support such usages, a
 * ForkJoinTask may be atomically &lt;em&gt;tagged&lt;/em&gt; with a {@code short}
 * value using {@link #setForkJoinTaskTag} or {@link
 * #compareAndSetForkJoinTaskTag} and checked using {@link
 * #getForkJoinTaskTag}. The ForkJoinTask implementation does not use
 * these {@code protected} methods or tags for any purpose, but they
 * may be of use in the construction of specialized subclasses.  For
 * example, parallel graph traversals can use the supplied methods to
 * avoid revisiting nodes/tasks that have already been processed.
 * (Method names for tagging are bulky in part to encourage definition
 * of methods that reflect their usage patterns.)
 *
 * &lt;p&gt;Most base support methods are {@code final}, to prevent
 * overriding of implementations that are intrinsically tied to the
 * underlying lightweight task scheduling framework.  Developers
 * creating new basic styles of fork/join processing should minimally
 * implement {@code protected} methods {@link #exec}, {@link
 * #setRawResult}, and {@link #getRawResult}, while also introducing
 * an abstract computational method that can be implemented in its
 * subclasses, possibly relying on other {@code protected} methods
 * provided by this class.
 *
 * &lt;p&gt;ForkJoinTasks should perform relatively small amounts of
 * computation. Large tasks should be split into smaller subtasks,
 * usually via recursive decomposition. As a very rough rule of thumb,
 * a task should perform more than 100 and less than 10000 basic
 * computational steps, and should avoid indefinite looping. If tasks
 * are too big, then parallelism cannot improve throughput. If too
 * small, then memory and internal task maintenance overhead may
 * overwhelm processing.
 *
 * &lt;p&gt;This class provides {@code adapt} methods for {@link Runnable}
 * and {@link Callable}, that may be of use when mixing execution of
 * {@code ForkJoinTasks} with other kinds of tasks. When all tasks are
 * of this form, consider using a pool constructed in &lt;em&gt;asyncMode&lt;/em&gt;.
 *
 * &lt;p&gt;ForkJoinTasks are {@code Serializable}, which enables them to be
 * used in extensions such as remote execution frameworks. It is
 * sensible to serialize tasks only before or after, but not during,
 * execution. Serialization is not relied on during execution itself.
 *
 * @since 1.7
 * @author Doug Lea
 */
<span class="fc" id="L212">public abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;, Serializable {</span>

    /*
     * See the internal documentation of class ForkJoinPool for a
     * general implementation overview.  ForkJoinTasks are mainly
     * responsible for maintaining their &quot;status&quot; field amidst relays
     * to methods in ForkJoinWorkerThread and ForkJoinPool.
     *
     * The methods of this class are more-or-less layered into
     * (1) basic status maintenance
     * (2) execution and awaiting completion
     * (3) user-level methods that additionally report results.
     * This is sometimes hard to see because this file orders exported
     * methods in a way that flows well in javadocs.
     */

    /*
     * The status field holds run control status bits packed into a
     * single int to minimize footprint and to ensure atomicity (via
     * CAS).  Status is initially zero, and takes on nonnegative
     * values until completed, upon which status (anded with
     * DONE_MASK) holds value NORMAL, CANCELLED, or EXCEPTIONAL. Tasks
     * undergoing blocking waits by other threads have the SIGNAL bit
     * set.  Completion of a stolen task with SIGNAL set awakens any
     * waiters via notifyAll. Even though suboptimal for some
     * purposes, we use basic builtin wait/notify to take advantage of
     * &quot;monitor inflation&quot; in JVMs that we would otherwise need to
     * emulate to avoid adding further per-task bookkeeping overhead.
     * We want these monitors to be &quot;fat&quot;, i.e., not use biasing or
     * thin-lock techniques, so use some odd coding idioms that tend
     * to avoid them, mainly by arranging that every synchronized
     * block performs a wait, notifyAll or both.
     *
     * These control bits occupy only (some of) the upper half (16
     * bits) of status field. The lower bits are used for user-defined
     * tags.
     */

    /** The run status of this task */
    volatile int status; // accessed directly by pool and workers
    static final int DONE_MASK   = 0xf0000000;  // mask out non-completion bits
    static final int NORMAL      = 0xf0000000;  // must be negative
    static final int CANCELLED   = 0xc0000000;  // must be &lt; NORMAL
    static final int EXCEPTIONAL = 0x80000000;  // must be &lt; CANCELLED
    static final int SIGNAL      = 0x00010000;  // must be &gt;= 1 &lt;&lt; 16
    static final int SMASK       = 0x0000ffff;  // short bits for tags

    /**
     * Marks completion and wakes up threads waiting to join this
     * task.
     *
     * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL
     * @return completion status on exit
     */
    private int setCompletion(int completion) {
        for (int s;;) {
<span class="fc bfc" id="L268" title="All 2 branches covered.">            if ((s = status) &lt; 0)</span>
<span class="fc" id="L269">                return s;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (U.compareAndSwapInt(this, STATUS, s, s | completion)) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                if ((s &gt;&gt;&gt; 16) != 0)</span>
<span class="pc" id="L272">                    synchronized (this) { notifyAll(); }</span>
<span class="fc" id="L273">                return completion;</span>
            }
        }
    }

    /**
     * Primary execution method for stolen tasks. Unless done, calls
     * exec and records status if completed, but doesn't wait for
     * completion otherwise.
     *
     * @return status on exit from this method
     */
    final int doExec() {
        int s; boolean completed;
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if ((s = status) &gt;= 0) {</span>
            try {
<span class="fc" id="L289">                completed = exec();</span>
<span class="fc" id="L290">            } catch (Throwable rex) {</span>
<span class="fc" id="L291">                return setExceptionalCompletion(rex);</span>
<span class="fc" id="L292">            }</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (completed)</span>
<span class="fc" id="L294">                s = setCompletion(NORMAL);</span>
        }
<span class="fc" id="L296">        return s;</span>
    }

    /**
     * Tries to set SIGNAL status unless already completed. Used by
     * ForkJoinPool. Other variants are directly incorporated into
     * externalAwaitDone etc.
     *
     * @return true if successful
     */
    final boolean trySetSignal() {
<span class="fc" id="L307">        int s = status;</span>
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        return s &gt;= 0 &amp;&amp; U.compareAndSwapInt(this, STATUS, s, s | SIGNAL);</span>
    }

    /**
     * Blocks a non-worker-thread until completion.
     * @return status upon completion
     */
    private int externalAwaitDone() {
        int s;
<span class="fc" id="L317">        ForkJoinPool cp = ForkJoinPool.common;</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if ((s = status) &gt;= 0) {</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (cp != null) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">                if (this instanceof CountedCompleter)</span>
<span class="fc" id="L321">                    s = cp.externalHelpComplete((CountedCompleter&lt;?&gt;)this, Integer.MAX_VALUE);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                else if (cp.tryExternalUnpush(this))</span>
<span class="fc" id="L323">                    s = doExec();</span>
            }
<span class="fc bfc" id="L325" title="All 4 branches covered.">            if (s &gt;= 0 &amp;&amp; (s = status) &gt;= 0) {</span>
<span class="fc" id="L326">                boolean interrupted = false;</span>
                do {
<span class="fc bfc" id="L328" title="All 2 branches covered.">                    if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {</span>
<span class="fc" id="L329">                        synchronized (this) {</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                            if (status &gt;= 0) {</span>
                                try {
<span class="fc" id="L332">                                    wait();</span>
<span class="nc" id="L333">                                } catch (InterruptedException ie) {</span>
<span class="nc" id="L334">                                    interrupted = true;</span>
<span class="pc" id="L335">                                }</span>
                            }
                            else
<span class="fc" id="L338">                                notifyAll();</span>
<span class="pc" id="L339">                        }</span>
                    }
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                } while ((s = status) &gt;= 0);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">                if (interrupted)</span>
<span class="nc" id="L343">                    Thread.currentThread().interrupt();</span>
            }
        }
<span class="fc" id="L346">        return s;</span>
    }

    /**
     * Blocks a non-worker-thread until completion or interruption.
     */
    private int externalInterruptibleAwaitDone() throws InterruptedException {
        int s;
<span class="fc" id="L354">        ForkJoinPool cp = ForkJoinPool.common;</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (Thread.interrupted())</span>
<span class="nc" id="L356">            throw new InterruptedException();</span>
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">        if ((s = status) &gt;= 0 &amp;&amp; cp != null) {</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (this instanceof CountedCompleter)</span>
<span class="nc" id="L359">                cp.externalHelpComplete((CountedCompleter&lt;?&gt;)this, Integer.MAX_VALUE);</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            else if (cp.tryExternalUnpush(this))</span>
<span class="nc" id="L361">                doExec();</span>
        }
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        while ((s = status) &gt;= 0) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {</span>
<span class="nc" id="L365">                synchronized (this) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                    if (status &gt;= 0)</span>
<span class="nc" id="L367">                        wait();</span>
                    else
<span class="nc" id="L369">                        notifyAll();</span>
<span class="nc" id="L370">                }</span>
            }
        }
<span class="fc" id="L373">        return s;</span>
    }

    /**
     * Implementation for join, get, quietlyJoin. Directly handles
     * only cases of already-completed, external wait, and
     * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.
     *
     * @return status upon completion
     */
    private int doJoin() {
        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
<span class="fc bfc" id="L385" title="All 2 branches covered.">        return (s = status) &lt; 0 ? s :</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span>
            (w = (wt = (ForkJoinWorkerThread)t).workQueue).
<span class="pc bpc" id="L388" title="3 of 4 branches missed.">            tryUnpush(this) &amp;&amp; (s = doExec()) &lt; 0 ? s :</span>
<span class="fc" id="L389">            wt.pool.awaitJoin(w, this) :</span>
<span class="fc" id="L390">            externalAwaitDone();</span>
    }

    /**
     * Implementation for invoke, quietlyInvoke.
     *
     * @return status upon completion
     */
    private int doInvoke() {
        int s; Thread t; ForkJoinWorkerThread wt;
<span class="fc bfc" id="L400" title="All 2 branches covered.">        return (s = doExec()) &lt; 0 ? s :</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span>
<span class="pc" id="L402">            (wt = (ForkJoinWorkerThread)t).pool.awaitJoin(wt.workQueue, this) :</span>
<span class="fc" id="L403">            externalAwaitDone();</span>
    }

    // Exception table support

    /**
     * Table of exceptions thrown by tasks, to enable reporting by
     * callers. Because exceptions are rare, we don't directly keep
     * them with task objects, but instead use a weak ref table.  Note
     * that cancellation exceptions don't appear in the table, but are
     * instead recorded as status values.
     *
     * Note: These statics are initialized below in static block.
     */
    private static final ExceptionNode[] exceptionTable;
    private static final ReentrantLock exceptionTableLock;
    private static final ReferenceQueue&lt;Object&gt; exceptionTableRefQueue;

    /**
     * Fixed capacity for exceptionTable.
     */
    private static final int EXCEPTION_MAP_CAPACITY = 32;

    /**
     * Key-value nodes for exception table.  The chained hash table
     * uses identity comparisons, full locking, and weak references
     * for keys. The table has a fixed capacity because it only
     * maintains task exceptions long enough for joiners to access
     * them, so should never become very large for sustained
     * periods. However, since we do not know when the last joiner
     * completes, we must use weak references and expunge them. We do
     * so on each operation (hence full locking). Also, some thread in
     * any ForkJoinPool will call helpExpungeStaleExceptions when its
     * pool becomes isQuiescent.
     */
    static final class ExceptionNode extends WeakReference&lt;ForkJoinTask&lt;?&gt;&gt; {
        final Throwable ex;
        ExceptionNode next;
        final long thrower;  // use id not ref to avoid weak cycles
        final int hashCode;  // store task hashCode before weak ref disappears
        ExceptionNode(ForkJoinTask&lt;?&gt; task, Throwable ex, ExceptionNode next) {
<span class="fc" id="L444">            super(task, exceptionTableRefQueue);</span>
<span class="fc" id="L445">            this.ex = ex;</span>
<span class="fc" id="L446">            this.next = next;</span>
<span class="fc" id="L447">            this.thrower = Thread.currentThread().getId();</span>
<span class="fc" id="L448">            this.hashCode = System.identityHashCode(task);</span>
<span class="fc" id="L449">        }</span>
    }

    /**
     * Records exception and sets status.
     *
     * @return status on exit
     */
    final int recordExceptionalCompletion(Throwable ex) {
        int s;
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if ((s = status) &gt;= 0) {</span>
<span class="fc" id="L460">            int h = System.identityHashCode(this);</span>
<span class="fc" id="L461">            final ReentrantLock lock = exceptionTableLock;</span>
<span class="fc" id="L462">            lock.lock();</span>
            try {
<span class="fc" id="L464">                expungeStaleExceptions();</span>
<span class="fc" id="L465">                ExceptionNode[] t = exceptionTable;</span>
<span class="fc" id="L466">                int i = h &amp; (t.length - 1);</span>
<span class="fc" id="L467">                for (ExceptionNode e = t[i]; ; e = e.next) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">                    if (e == null) {</span>
<span class="fc" id="L469">                        t[i] = new ExceptionNode(this, ex, t[i]);</span>
<span class="fc" id="L470">                        break;</span>
                    }
<span class="fc bfc" id="L472" title="All 2 branches covered.">                    if (e.get() == this) // already present</span>
<span class="fc" id="L473">                        break;</span>
                }
            } finally {
<span class="pc" id="L476">                lock.unlock();</span>
<span class="fc" id="L477">            }</span>
<span class="fc" id="L478">            s = setCompletion(EXCEPTIONAL);</span>
        }
<span class="fc" id="L480">        return s;</span>
    }

    /**
     * Records exception and possibly propagates.
     *
     * @return status on exit
     */
    private int setExceptionalCompletion(Throwable ex) {
<span class="fc" id="L489">        int s = recordExceptionalCompletion(ex);</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if ((s &amp; DONE_MASK) == EXCEPTIONAL)</span>
<span class="fc" id="L491">            internalPropagateException(ex);</span>
<span class="fc" id="L492">        return s;</span>
    }

    /**
     * Hook for exception propagation support for tasks with completers.
     */
    void internalPropagateException(Throwable ex) {
<span class="fc" id="L499">    }</span>

    /**
     * Cancels, ignoring any exceptions thrown by cancel. Used during
     * worker and pool shutdown. Cancel is spec'ed not to throw any
     * exceptions, but if it does anyway, we have no recourse during
     * shutdown, so guard against this case.
     */
    static final void cancelIgnoringExceptions(ForkJoinTask&lt;?&gt; t) {
<span class="pc bpc" id="L508" title="1 of 4 branches missed.">        if (t != null &amp;&amp; t.status &gt;= 0) {</span>
            try {
<span class="nc" id="L510">                t.cancel(false);</span>
<span class="nc" id="L511">            } catch (Throwable ignore) {</span>
<span class="nc" id="L512">            }</span>
        }
<span class="fc" id="L514">    }</span>

    /**
     * Removes exception node and clears status.
     */
    private void clearExceptionalCompletion() {
<span class="nc" id="L520">        int h = System.identityHashCode(this);</span>
<span class="nc" id="L521">        final ReentrantLock lock = exceptionTableLock;</span>
<span class="nc" id="L522">        lock.lock();</span>
        try {
<span class="nc" id="L524">            ExceptionNode[] t = exceptionTable;</span>
<span class="nc" id="L525">            int i = h &amp; (t.length - 1);</span>
<span class="nc" id="L526">            ExceptionNode e = t[i];</span>
<span class="nc" id="L527">            ExceptionNode pred = null;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            while (e != null) {</span>
<span class="nc" id="L529">                ExceptionNode next = e.next;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                if (e.get() == this) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                    if (pred == null)</span>
<span class="nc" id="L532">                        t[i] = next;</span>
                    else
<span class="nc" id="L534">                        pred.next = next;</span>
<span class="nc" id="L535">                    break;</span>
                }
<span class="nc" id="L537">                pred = e;</span>
<span class="nc" id="L538">                e = next;</span>
<span class="nc" id="L539">            }</span>
<span class="nc" id="L540">            expungeStaleExceptions();</span>
<span class="nc" id="L541">            status = 0;</span>
        } finally {
<span class="nc" id="L543">            lock.unlock();</span>
<span class="nc" id="L544">        }</span>
<span class="nc" id="L545">    }</span>

    /**
     * Returns a rethrowable exception for the given task, if
     * available. To provide accurate stack traces, if the exception
     * was not thrown by the current thread, we try to create a new
     * exception of the same type as the one thrown, but with the
     * recorded exception as its cause. If there is no such
     * constructor, we instead try to use a no-arg constructor,
     * followed by initCause, to the same effect. If none of these
     * apply, or any fail due to other exceptions, we return the
     * recorded exception, which is still correct, although it may
     * contain a misleading stack trace.
     *
     * @return the exception, or null if none
     */
    private Throwable getThrowableException() {
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if ((status &amp; DONE_MASK) != EXCEPTIONAL)</span>
<span class="nc" id="L563">            return null;</span>
<span class="fc" id="L564">        int h = System.identityHashCode(this);</span>
        ExceptionNode e;
<span class="fc" id="L566">        final ReentrantLock lock = exceptionTableLock;</span>
<span class="fc" id="L567">        lock.lock();</span>
        try {
<span class="fc" id="L569">            expungeStaleExceptions();</span>
<span class="fc" id="L570">            ExceptionNode[] t = exceptionTable;</span>
<span class="fc" id="L571">            e = t[h &amp; (t.length - 1)];</span>
<span class="pc bpc" id="L572" title="1 of 4 branches missed.">            while (e != null &amp;&amp; e.get() != this)</span>
<span class="fc" id="L573">                e = e.next;</span>
        } finally {
<span class="pc" id="L575">            lock.unlock();</span>
<span class="fc" id="L576">        }</span>
        Throwable ex;
<span class="pc bpc" id="L578" title="2 of 4 branches missed.">        if (e == null || (ex = e.ex) == null)</span>
<span class="nc" id="L579">            return null;</span>
        if (false &amp;&amp; e.thrower != Thread.currentThread().getId()) {
            Class&lt;? extends Throwable&gt; ec = ex.getClass();
            try {
                Constructor&lt;?&gt; noArgCtor = null;
                Constructor&lt;?&gt;[] cs = ec.getConstructors();// public ctors only
                for (int i = 0; i &lt; cs.length; ++i) {
                    Constructor&lt;?&gt; c = cs[i];
                    Class&lt;?&gt;[] ps = c.getParameterTypes();
                    if (ps.length == 0)
                        noArgCtor = c;
                    else if (ps.length == 1 &amp;&amp; ps[0] == Throwable.class)
                        return (Throwable)(c.newInstance(ex));
                }
                if (noArgCtor != null) {
                    Throwable wx = (Throwable)(noArgCtor.newInstance());
                    wx.initCause(ex);
                    return wx;
                }
            } catch (Exception ignore) {
            }
        }
<span class="fc" id="L601">        return ex;</span>
    }

    /**
     * Poll stale refs and remove them. Call only while holding lock.
     */
    private static void expungeStaleExceptions() {
<span class="fc bfc" id="L608" title="All 2 branches covered.">        for (Object x; (x = exceptionTableRefQueue.poll()) != null;) {</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if (x instanceof ExceptionNode) {</span>
<span class="fc" id="L610">                int hashCode = ((ExceptionNode)x).hashCode;</span>
<span class="fc" id="L611">                ExceptionNode[] t = exceptionTable;</span>
<span class="fc" id="L612">                int i = hashCode &amp; (t.length - 1);</span>
<span class="fc" id="L613">                ExceptionNode e = t[i];</span>
<span class="fc" id="L614">                ExceptionNode pred = null;</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">                while (e != null) {</span>
<span class="fc" id="L616">                    ExceptionNode next = e.next;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                    if (e == x) {</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">                        if (pred == null)</span>
<span class="fc" id="L619">                            t[i] = next;</span>
                        else
<span class="fc" id="L621">                            pred.next = next;</span>
<span class="fc" id="L622">                        break;</span>
                    }
<span class="fc" id="L624">                    pred = e;</span>
<span class="fc" id="L625">                    e = next;</span>
<span class="fc" id="L626">                }</span>
<span class="fc" id="L627">            }</span>
        }
<span class="fc" id="L629">    }</span>

    /**
     * If lock is available, poll stale refs and remove them.
     * Called from ForkJoinPool when pools become quiescent.
     */
    static final void helpExpungeStaleExceptions() {
<span class="fc" id="L636">        final ReentrantLock lock = exceptionTableLock;</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">        if (lock.tryLock()) {</span>
            try {
<span class="fc" id="L639">                expungeStaleExceptions();</span>
            } finally {
<span class="pc" id="L641">                lock.unlock();</span>
<span class="fc" id="L642">            }</span>
        }
<span class="fc" id="L644">    }</span>

    /**
     * A version of &quot;sneaky throw&quot; to relay exceptions
     */
    static void rethrow(Throwable ex) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (ex != null)</span>
<span class="nc" id="L651">            ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);</span>
<span class="nc" id="L652">    }</span>

    /**
     * The sneaky part of sneaky throw, relying on generics
     * limitations to evade compiler complaints about rethrowing
     * unchecked exceptions
     */
    @SuppressWarnings(&quot;unchecked&quot;) static &lt;T extends Throwable&gt;
        void uncheckedThrow(Throwable t) throws T {
<span class="fc" id="L661">        throw (T)t; // rely on vacuous cast</span>
    }

    /**
     * Throws exception, if any, associated with the given status.
     */
    private void reportException(int s) {
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (s == CANCELLED)</span>
<span class="nc" id="L669">            throw new CancellationException();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (s == EXCEPTIONAL)</span>
<span class="nc" id="L671">            rethrow(getThrowableException());</span>
<span class="nc" id="L672">    }</span>

    // public methods

    /**
     * Arranges to asynchronously execute this task in the pool the
     * current task is running in, if applicable, or using the {@link
     * ForkJoinPool#commonPool()} if not {@link #inForkJoinPool}.  While
     * it is not necessarily enforced, it is a usage error to fork a
     * task more than once unless it has completed and been
     * reinitialized.  Subsequent modifications to the state of this
     * task or any data it operates on are not necessarily
     * consistently observable by any thread other than the one
     * executing it unless preceded by a call to {@link #join} or
     * related methods, or a call to {@link #isDone} returning {@code
     * true}.
     *
     * @return {@code this}, to simplify usage
     */
    public final ForkJoinTask&lt;V&gt; fork() {
        Thread t;
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)</span>
<span class="fc" id="L694">            ((ForkJoinWorkerThread)t).workQueue.push(this);</span>
        else
<span class="fc" id="L696">            ForkJoinPool.common.externalPush(this);</span>
<span class="fc" id="L697">        return this;</span>
    }

    /**
     * Returns the result of the computation when it {@link #isDone is
     * done}.  This method differs from {@link #get()} in that
     * abnormal completion results in {@code RuntimeException} or
     * {@code Error}, not {@code ExecutionException}, and that
     * interrupts of the calling thread do &lt;em&gt;not&lt;/em&gt; cause the
     * method to abruptly return by throwing {@code
     * InterruptedException}.
     *
     * @return the computed result
     */
    public final V join() {
        int s;
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">        if ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span>
<span class="nc" id="L714">            reportException(s);</span>
<span class="fc" id="L715">        return getRawResult();</span>
    }

    /**
     * Commences performing this task, awaits its completion if
     * necessary, and returns its result, or throws an (unchecked)
     * {@code RuntimeException} or {@code Error} if the underlying
     * computation did so.
     *
     * @return the computed result
     */
    public final V invoke() {
        int s;
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span>
<span class="nc" id="L729">            reportException(s);</span>
<span class="fc" id="L730">        return getRawResult();</span>
    }

    /**
     * Forks the given tasks, returning when {@code isDone} holds for
     * each task or an (unchecked) exception is encountered, in which
     * case the exception is rethrown. If more than one task
     * encounters an exception, then this method throws any one of
     * these exceptions. If any task encounters an exception, the
     * other may be cancelled. However, the execution status of
     * individual tasks is not guaranteed upon exceptional return. The
     * status of each task may be obtained using {@link
     * #getException()} and related methods to check if they have been
     * cancelled, completed normally or exceptionally, or left
     * unprocessed.
     *
     * @param t1 the first task
     * @param t2 the second task
     * @throws NullPointerException if any task is null
     */
    public static void invokeAll(ForkJoinTask&lt;?&gt; t1, ForkJoinTask&lt;?&gt; t2) {
        int s1, s2;
<span class="fc" id="L752">        t2.fork();</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if ((s1 = t1.doInvoke() &amp; DONE_MASK) != NORMAL)</span>
<span class="nc" id="L754">            t1.reportException(s1);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        if ((s2 = t2.doJoin() &amp; DONE_MASK) != NORMAL)</span>
<span class="nc" id="L756">            t2.reportException(s2);</span>
<span class="fc" id="L757">    }</span>

    /**
     * Forks the given tasks, returning when {@code isDone} holds for
     * each task or an (unchecked) exception is encountered, in which
     * case the exception is rethrown. If more than one task
     * encounters an exception, then this method throws any one of
     * these exceptions. If any task encounters an exception, others
     * may be cancelled. However, the execution status of individual
     * tasks is not guaranteed upon exceptional return. The status of
     * each task may be obtained using {@link #getException()} and
     * related methods to check if they have been cancelled, completed
     * normally or exceptionally, or left unprocessed.
     *
     * @param tasks the tasks
     * @throws NullPointerException if any task is null
     */
    public static void invokeAll(ForkJoinTask&lt;?&gt;... tasks) {
<span class="nc" id="L775">        Throwable ex = null;</span>
<span class="nc" id="L776">        int last = tasks.length - 1;</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">        for (int i = last; i &gt;= 0; --i) {</span>
<span class="nc" id="L778">            ForkJoinTask&lt;?&gt; t = tasks[i];</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if (t == null) {</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">                if (ex == null)</span>
<span class="nc" id="L781">                    ex = new NullPointerException();</span>
            }
<span class="nc bnc" id="L783" title="All 2 branches missed.">            else if (i != 0)</span>
<span class="nc" id="L784">                t.fork();</span>
<span class="nc bnc" id="L785" title="All 4 branches missed.">            else if (t.doInvoke() &lt; NORMAL &amp;&amp; ex == null)</span>
<span class="nc" id="L786">                ex = t.getException();</span>
        }
<span class="nc bnc" id="L788" title="All 2 branches missed.">        for (int i = 1; i &lt;= last; ++i) {</span>
<span class="nc" id="L789">            ForkJoinTask&lt;?&gt; t = tasks[i];</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                if (ex != null)</span>
<span class="nc" id="L792">                    t.cancel(false);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                else if (t.doJoin() &lt; NORMAL)</span>
<span class="nc" id="L794">                    ex = t.getException();</span>
            }
        }
<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (ex != null)</span>
<span class="nc" id="L798">            rethrow(ex);</span>
<span class="nc" id="L799">    }</span>

    /**
     * Forks all tasks in the specified collection, returning when
     * {@code isDone} holds for each task or an (unchecked) exception
     * is encountered, in which case the exception is rethrown. If
     * more than one task encounters an exception, then this method
     * throws any one of these exceptions. If any task encounters an
     * exception, others may be cancelled. However, the execution
     * status of individual tasks is not guaranteed upon exceptional
     * return. The status of each task may be obtained using {@link
     * #getException()} and related methods to check if they have been
     * cancelled, completed normally or exceptionally, or left
     * unprocessed.
     *
     * @param tasks the collection of tasks
     * @param &lt;T&gt; the type of the values returned from the tasks
     * @return the tasks argument, to simplify usage
     * @throws NullPointerException if tasks or any element are null
     */
    public static &lt;T extends ForkJoinTask&lt;?&gt;&gt; Collection&lt;T&gt; invokeAll(Collection&lt;T&gt; tasks) {
<span class="nc bnc" id="L820" title="All 4 branches missed.">        if (!(tasks instanceof RandomAccess) || !(tasks instanceof List&lt;?&gt;)) {</span>
<span class="nc" id="L821">            invokeAll(tasks.toArray(new ForkJoinTask&lt;?&gt;[tasks.size()]));</span>
<span class="nc" id="L822">            return tasks;</span>
        }
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L825">        List&lt;? extends ForkJoinTask&lt;?&gt;&gt; ts =</span>
            (List&lt;? extends ForkJoinTask&lt;?&gt;&gt;) tasks;
<span class="nc" id="L827">        Throwable ex = null;</span>
<span class="nc" id="L828">        int last = ts.size() - 1;</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">        for (int i = last; i &gt;= 0; --i) {</span>
<span class="nc" id="L830">            ForkJoinTask&lt;?&gt; t = ts.get(i);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (t == null) {</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                if (ex == null)</span>
<span class="nc" id="L833">                    ex = new NullPointerException();</span>
            }
<span class="nc bnc" id="L835" title="All 2 branches missed.">            else if (i != 0)</span>
<span class="nc" id="L836">                t.fork();</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">            else if (t.doInvoke() &lt; NORMAL &amp;&amp; ex == null)</span>
<span class="nc" id="L838">                ex = t.getException();</span>
        }
<span class="nc bnc" id="L840" title="All 2 branches missed.">        for (int i = 1; i &lt;= last; ++i) {</span>
<span class="nc" id="L841">            ForkJoinTask&lt;?&gt; t = ts.get(i);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                if (ex != null)</span>
<span class="nc" id="L844">                    t.cancel(false);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">                else if (t.doJoin() &lt; NORMAL)</span>
<span class="nc" id="L846">                    ex = t.getException();</span>
            }
        }
<span class="nc bnc" id="L849" title="All 2 branches missed.">        if (ex != null)</span>
<span class="nc" id="L850">            rethrow(ex);</span>
<span class="nc" id="L851">        return tasks;</span>
    }

    /**
     * Attempts to cancel execution of this task. This attempt will
     * fail if the task has already completed or could not be
     * cancelled for some other reason. If successful, and this task
     * has not started when {@code cancel} is called, execution of
     * this task is suppressed. After this method returns
     * successfully, unless there is an intervening call to {@link
     * #reinitialize}, subsequent calls to {@link #isCancelled},
     * {@link #isDone}, and {@code cancel} will return {@code true}
     * and calls to {@link #join} and related methods will result in
     * {@code CancellationException}.
     *
     * &lt;p&gt;This method may be overridden in subclasses, but if so, must
     * still ensure that these properties hold. In particular, the
     * {@code cancel} method itself must not throw exceptions.
     *
     * &lt;p&gt;This method is designed to be invoked by &lt;em&gt;other&lt;/em&gt;
     * tasks. To terminate the current task, you can just return or
     * throw an unchecked exception from its computation method, or
     * invoke {@link #completeExceptionally(Throwable)}.
     *
     * @param mayInterruptIfRunning this value has no effect in the
     * default implementation because interrupts are not used to
     * control cancellation.
     *
     * @return {@code true} if this task is now cancelled
     */
    public boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc bnc" id="L882" title="All 2 branches missed.">        return (setCompletion(CANCELLED) &amp; DONE_MASK) == CANCELLED;</span>
    }

    public final boolean isDone() {
<span class="nc bnc" id="L886" title="All 2 branches missed.">        return status &lt; 0;</span>
    }

    public final boolean isCancelled() {
<span class="nc bnc" id="L890" title="All 2 branches missed.">        return (status &amp; DONE_MASK) == CANCELLED;</span>
    }

    /**
     * Returns {@code true} if this task threw an exception or was cancelled.
     *
     * @return {@code true} if this task threw an exception or was cancelled
     */
    public final boolean isCompletedAbnormally() {
<span class="nc bnc" id="L899" title="All 2 branches missed.">        return status &lt; NORMAL;</span>
    }

    /**
     * Returns {@code true} if this task completed without throwing an
     * exception and was not cancelled.
     *
     * @return {@code true} if this task completed without throwing an
     * exception and was not cancelled
     */
    public final boolean isCompletedNormally() {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        return (status &amp; DONE_MASK) == NORMAL;</span>
    }

    /**
     * Returns the exception thrown by the base computation, or a
     * {@code CancellationException} if cancelled, or {@code null} if
     * none or if the method has not yet completed.
     *
     * @return the exception, or {@code null} if none
     */
    public final Throwable getException() {
<span class="nc" id="L921">        int s = status &amp; DONE_MASK;</span>
<span class="nc bnc" id="L922" title="All 4 branches missed.">        return ((s &gt;= NORMAL)    ? null :</span>
                (s == CANCELLED) ? new CancellationException() :
<span class="nc" id="L924">                getThrowableException());</span>
    }

    /**
     * Completes this task abnormally, and if not already aborted or
     * cancelled, causes it to throw the given exception upon
     * {@code join} and related operations. This method may be used
     * to induce exceptions in asynchronous tasks, or to force
     * completion of tasks that would not otherwise complete.  Its use
     * in other situations is discouraged.  This method is
     * overridable, but overridden versions must invoke {@code super}
     * implementation to maintain guarantees.
     *
     * @param ex the exception to throw. If this exception is not a
     * {@code RuntimeException} or {@code Error}, the actual exception
     * thrown will be a {@code RuntimeException} with cause {@code ex}.
     */
    public void completeExceptionally(Throwable ex) {
<span class="nc bnc" id="L942" title="All 4 branches missed.">        setExceptionalCompletion((ex instanceof RuntimeException) ||</span>
                                 (ex instanceof Error) ? ex :
                                 new RuntimeException(ex));
<span class="nc" id="L945">    }</span>

    /**
     * Completes this task, and if not already aborted or cancelled,
     * returning the given value as the result of subsequent
     * invocations of {@code join} and related operations. This method
     * may be used to provide results for asynchronous tasks, or to
     * provide alternative handling for tasks that would not otherwise
     * complete normally. Its use in other situations is
     * discouraged. This method is overridable, but overridden
     * versions must invoke {@code super} implementation to maintain
     * guarantees.
     *
     * @param value the result value for this task
     */
    public void complete(V value) {
        try {
<span class="nc" id="L962">            setRawResult(value);</span>
<span class="nc" id="L963">        } catch (Throwable rex) {</span>
<span class="nc" id="L964">            setExceptionalCompletion(rex);</span>
<span class="nc" id="L965">            return;</span>
<span class="nc" id="L966">        }</span>
<span class="nc" id="L967">        setCompletion(NORMAL);</span>
<span class="nc" id="L968">    }</span>

    /**
     * Completes this task normally without setting a value. The most
     * recent value established by {@link #setRawResult} (or {@code
     * null} by default) will be returned as the result of subsequent
     * invocations of {@code join} and related operations.
     *
     * @since 1.8
     */
    public final void quietlyComplete() {
<span class="fc" id="L979">        setCompletion(NORMAL);</span>
<span class="fc" id="L980">    }</span>

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     *
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread is not a
     * member of a ForkJoinPool and was interrupted while waiting
     */
    public final V get() throws InterruptedException, ExecutionException {
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">        int s = (Thread.currentThread() instanceof ForkJoinWorkerThread) ?</span>
<span class="pc" id="L995">            doJoin() : externalInterruptibleAwaitDone();</span>
        Throwable ex;
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">        if ((s &amp;= DONE_MASK) == CANCELLED)</span>
<span class="nc" id="L998">            throw new CancellationException();</span>
<span class="pc bpc" id="L999" title="3 of 4 branches missed.">        if (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != null)</span>
<span class="nc" id="L1000">            throw new ExecutionException(ex);</span>
<span class="fc" id="L1001">        return getRawResult();</span>
    }

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return the computed result
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an
     * exception
     * @throws InterruptedException if the current thread is not a
     * member of a ForkJoinPool and was interrupted while waiting
     * @throws TimeoutException if the wait timed out
     */
    public final V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (Thread.interrupted())</span>
<span class="nc" id="L1021">            throw new InterruptedException();</span>
        // Messy in part because we measure in nanosecs, but wait in millisecs
        int s; long ms;
<span class="nc" id="L1024">        long ns = unit.toNanos(timeout);</span>
        ForkJoinPool cp;
<span class="nc bnc" id="L1026" title="All 4 branches missed.">        if ((s = status) &gt;= 0 &amp;&amp; ns &gt; 0L) {</span>
<span class="nc" id="L1027">            long deadline = System.nanoTime() + ns;</span>
<span class="nc" id="L1028">            ForkJoinPool p = null;</span>
<span class="nc" id="L1029">            ForkJoinPool.WorkQueue w = null;</span>
<span class="nc" id="L1030">            Thread t = Thread.currentThread();</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (t instanceof ForkJoinWorkerThread) {</span>
<span class="nc" id="L1032">                ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;</span>
<span class="nc" id="L1033">                p = wt.pool;</span>
<span class="nc" id="L1034">                w = wt.workQueue;</span>
<span class="nc" id="L1035">                p.helpJoinOnce(w, this); // no retries on failure</span>
<span class="nc" id="L1036">            }</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            else if ((cp = ForkJoinPool.common) != null) {</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                if (this instanceof CountedCompleter)</span>
<span class="nc" id="L1039">                    cp.externalHelpComplete((CountedCompleter&lt;?&gt;)this, Integer.MAX_VALUE);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                else if (cp.tryExternalUnpush(this))</span>
<span class="nc" id="L1041">                    doExec();</span>
            }
<span class="nc" id="L1043">            boolean canBlock = false;</span>
<span class="nc" id="L1044">            boolean interrupted = false;</span>
            try {
<span class="nc bnc" id="L1046" title="All 2 branches missed.">                while ((s = status) &gt;= 0) {</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">                    if (w != null &amp;&amp; w.qlock &lt; 0)</span>
<span class="nc" id="L1048">                        cancelIgnoringExceptions(this);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                    else if (!canBlock) {</span>
<span class="nc bnc" id="L1050" title="All 4 branches missed.">                        if (p == null || p.tryCompensate(p.ctl))</span>
<span class="nc" id="L1051">                            canBlock = true;</span>
                    }
                    else {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                        if ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &gt; 0L &amp;&amp;</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                            U.compareAndSwapInt(this, STATUS, s, s | SIGNAL)) {</span>
<span class="nc" id="L1056">                            synchronized (this) {</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                                if (status &gt;= 0) {</span>
                                    try {
<span class="nc" id="L1059">                                        wait(ms);</span>
<span class="nc" id="L1060">                                    } catch (InterruptedException ie) {</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                                        if (p == null)</span>
<span class="nc" id="L1062">                                            interrupted = true;</span>
<span class="nc" id="L1063">                                    }</span>
                                }
                                else
<span class="nc" id="L1066">                                    notifyAll();</span>
<span class="nc" id="L1067">                            }</span>
                        }
<span class="nc bnc" id="L1069" title="All 4 branches missed.">                        if ((s = status) &lt; 0 || interrupted ||</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                            (ns = deadline - System.nanoTime()) &lt;= 0L)</span>
<span class="nc" id="L1071">                            break;</span>
                    }
                }
            } finally {
<span class="nc bnc" id="L1075" title="All 8 branches missed.">                if (p != null &amp;&amp; canBlock)</span>
<span class="nc" id="L1076">                    p.incrementActiveCount();</span>
            }
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (interrupted)</span>
<span class="nc" id="L1079">                throw new InterruptedException();</span>
        }
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        if ((s &amp;= DONE_MASK) != NORMAL) {</span>
            Throwable ex;
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (s == CANCELLED)</span>
<span class="nc" id="L1084">                throw new CancellationException();</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (s != EXCEPTIONAL)</span>
<span class="nc" id="L1086">                throw new TimeoutException();</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if ((ex = getThrowableException()) != null)</span>
<span class="nc" id="L1088">                throw new ExecutionException(ex);</span>
        }
<span class="nc" id="L1090">        return getRawResult();</span>
    }

    /**
     * Joins this task, without returning its result or throwing its
     * exception. This method may be useful when processing
     * collections of tasks when some have been cancelled or otherwise
     * known to have aborted.
     */
    public final void quietlyJoin() {
<span class="fc" id="L1100">        doJoin();</span>
<span class="fc" id="L1101">    }</span>

    /**
     * Commences performing this task and awaits its completion if
     * necessary, without returning its result or throwing its
     * exception.
     */
    public final void quietlyInvoke() {
<span class="nc" id="L1109">        doInvoke();</span>
<span class="nc" id="L1110">    }</span>

    /**
     * Possibly executes tasks until the pool hosting the current task
     * {@link ForkJoinPool#isQuiescent is quiescent}. This method may
     * be of use in designs in which many tasks are forked, but none
     * are explicitly joined, instead executing them until all are
     * processed.
     */
    public static void helpQuiesce() {
        Thread t;
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {</span>
<span class="nc" id="L1122">            ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t;</span>
<span class="nc" id="L1123">            wt.pool.helpQuiescePool(wt.workQueue);</span>
<span class="nc" id="L1124">        }</span>
        else
<span class="nc" id="L1126">            ForkJoinPool.quiesceCommonPool();</span>
<span class="nc" id="L1127">    }</span>

    /**
     * Resets the internal bookkeeping state of this task, allowing a
     * subsequent {@code fork}. This method allows repeated reuse of
     * this task, but only if reuse occurs when this task has either
     * never been forked, or has been forked, then completed and all
     * outstanding joins of this task have also completed. Effects
     * under any other usage conditions are not guaranteed.
     * This method may be useful when executing
     * pre-constructed trees of subtasks in loops.
     *
     * &lt;p&gt;Upon completion of this method, {@code isDone()} reports
     * {@code false}, and {@code getException()} reports {@code
     * null}. However, the value returned by {@code getRawResult} is
     * unaffected. To clear this value, you can invoke {@code
     * setRawResult(null)}.
     */
    public void reinitialize() {
<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if ((status &amp; DONE_MASK) == EXCEPTIONAL)</span>
<span class="nc" id="L1147">            clearExceptionalCompletion();</span>
        else
<span class="nc" id="L1149">            status = 0;</span>
<span class="nc" id="L1150">    }</span>

    /**
     * Returns the pool hosting the current task execution, or null
     * if this task is executing outside of any ForkJoinPool.
     *
     * @see #inForkJoinPool
     * @return the pool, or {@code null} if none
     */
    public static ForkJoinPool getPool() {
<span class="nc" id="L1160">        Thread t = Thread.currentThread();</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        return (t instanceof ForkJoinWorkerThread) ?</span>
            ((ForkJoinWorkerThread) t).pool : null;
    }

    /**
     * Returns {@code true} if the current thread is a {@link
     * ForkJoinWorkerThread} executing as a ForkJoinPool computation.
     *
     * @return {@code true} if the current thread is a {@link
     * ForkJoinWorkerThread} executing as a ForkJoinPool computation,
     * or {@code false} otherwise
     */
    public static boolean inForkJoinPool() {
<span class="nc" id="L1174">        return Thread.currentThread() instanceof ForkJoinWorkerThread;</span>
    }

    /**
     * Tries to unschedule this task for execution. This method will
     * typically (but is not guaranteed to) succeed if this task is
     * the most recently forked task by the current thread, and has
     * not commenced executing in another thread.  This method may be
     * useful when arranging alternative local processing of tasks
     * that could have been, but were not, stolen.
     *
     * @return {@code true} if unforked
     */
    public boolean tryUnfork() {
        Thread t;
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">        return (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span>
<span class="pc" id="L1190">                ((ForkJoinWorkerThread)t).workQueue.tryUnpush(this) :</span>
<span class="pc" id="L1191">                ForkJoinPool.common.tryExternalUnpush(this));</span>
    }

    /**
     * Returns an estimate of the number of tasks that have been
     * forked by the current worker thread but not yet executed. This
     * value may be useful for heuristic decisions about whether to
     * fork other tasks.
     *
     * @return the number of tasks
     */
    public static int getQueuedTaskCount() {
        Thread t; ForkJoinPool.WorkQueue q;
<span class="nc bnc" id="L1204" title="All 2 branches missed.">        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)</span>
<span class="nc" id="L1205">            q = ((ForkJoinWorkerThread)t).workQueue;</span>
        else
<span class="nc" id="L1207">            q = ForkJoinPool.commonSubmitterQueue();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        return (q == null) ? 0 : q.queueSize();</span>
    }

    /**
     * Returns an estimate of how many more locally queued tasks are
     * held by the current worker thread than there are other worker
     * threads that might steal them, or zero if this thread is not
     * operating in a ForkJoinPool. This value may be useful for
     * heuristic decisions about whether to fork other tasks. In many
     * usages of ForkJoinTasks, at steady state, each worker should
     * aim to maintain a small constant surplus (for example, 3) of
     * tasks, and to process computations locally if this threshold is
     * exceeded.
     *
     * @return the surplus number of tasks, which may be negative
     */
    public static int getSurplusQueuedTaskCount() {
<span class="fc" id="L1225">        return ForkJoinPool.getSurplusQueuedTaskCount();</span>
    }

    // Extension methods

    /**
     * Returns the result that would be returned by {@link #join}, even
     * if this task completed abnormally, or {@code null} if this task
     * is not known to have been completed.  This method is designed
     * to aid debugging, as well as to support extensions. Its use in
     * any other context is discouraged.
     *
     * @return the result, or {@code null} if not completed
     */
    public abstract V getRawResult();

    /**
     * Forces the given value to be returned as a result.  This method
     * is designed to support extensions, and should not in general be
     * called otherwise.
     *
     * @param value the value
     */
    protected abstract void setRawResult(V value);

    /**
     * Immediately performs the base action of this task and returns
     * true if, upon return from this method, this task is guaranteed
     * to have completed normally. This method may return false
     * otherwise, to indicate that this task is not necessarily
     * complete (or is not known to be complete), for example in
     * asynchronous actions that require explicit invocations of
     * completion methods. This method may also throw an (unchecked)
     * exception to indicate abnormal exit. This method is designed to
     * support extensions, and should not in general be called
     * otherwise.
     *
     * @return {@code true} if this task is known to have completed normally
     */
    protected abstract boolean exec();

    /**
     * Returns, but does not unschedule or execute, a task queued by
     * the current thread but not yet executed, if one is immediately
     * available. There is no guarantee that this task will actually
     * be polled or executed next. Conversely, this method may return
     * null even if a task exists but cannot be accessed without
     * contention with other threads.  This method is designed
     * primarily to support extensions, and is unlikely to be useful
     * otherwise.
     *
     * @return the next task, or {@code null} if none are available
     */
    protected static ForkJoinTask&lt;?&gt; peekNextLocalTask() {
        Thread t; ForkJoinPool.WorkQueue q;
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)</span>
<span class="nc" id="L1281">            q = ((ForkJoinWorkerThread)t).workQueue;</span>
        else
<span class="nc" id="L1283">            q = ForkJoinPool.commonSubmitterQueue();</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">        return (q == null) ? null : q.peek();</span>
    }

    /**
     * Unschedules and returns, without executing, the next task
     * queued by the current thread but not yet executed, if the
     * current thread is operating in a ForkJoinPool.  This method is
     * designed primarily to support extensions, and is unlikely to be
     * useful otherwise.
     *
     * @return the next task, or {@code null} if none are available
     */
    protected static ForkJoinTask&lt;?&gt; pollNextLocalTask() {
        Thread t;
<span class="nc bnc" id="L1298" title="All 2 branches missed.">        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span>
<span class="nc" id="L1299">            ((ForkJoinWorkerThread)t).workQueue.nextLocalTask() :</span>
            null;
    }

    /**
     * If the current thread is operating in a ForkJoinPool,
     * unschedules and returns, without executing, the next task
     * queued by the current thread but not yet executed, if one is
     * available, or if not available, a task that was forked by some
     * other thread, if available. Availability may be transient, so a
     * {@code null} result does not necessarily imply quiescence of
     * the pool this task is operating in.  This method is designed
     * primarily to support extensions, and is unlikely to be useful
     * otherwise.
     *
     * @return a task, or {@code null} if none are available
     */
    protected static ForkJoinTask&lt;?&gt; pollTask() {
        Thread t; ForkJoinWorkerThread wt;
<span class="nc bnc" id="L1318" title="All 2 branches missed.">        return ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?</span>
<span class="nc" id="L1319">            (wt = (ForkJoinWorkerThread)t).pool.nextTaskFor(wt.workQueue) :</span>
            null;
    }

    // tag operations

    /**
     * Returns the tag for this task.
     *
     * @return the tag for this task
     * @since 1.8
     */
    public final short getForkJoinTaskTag() {
<span class="nc" id="L1332">        return (short)status;</span>
    }

    /**
     * Atomically sets the tag value for this task.
     *
     * @param tag the tag value
     * @return the previous value of the tag
     * @since 1.8
     */
    public final short setForkJoinTaskTag(short tag) {
        for (int s;;) {
<span class="nc bnc" id="L1344" title="All 2 branches missed.">            if (U.compareAndSwapInt(this, STATUS, s = status,</span>
                                    (s &amp; ~SMASK) | (tag &amp; SMASK)))
<span class="nc" id="L1346">                return (short)s;</span>
        }
    }

    /**
     * Atomically conditionally sets the tag value for this task.
     * Among other applications, tags can be used as visit markers
     * in tasks operating on graphs, as in methods that check: {@code
     * if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))}
     * before processing, otherwise exiting because the node has
     * already been visited.
     *
     * @param e the expected tag value
     * @param tag the new tag value
     * @return {@code true} if successful; i.e., the current value was
     * equal to e and is now tag.
     * @since 1.8
     */
    public final boolean compareAndSetForkJoinTaskTag(short e, short tag) {
        for (int s;;) {
<span class="nc bnc" id="L1366" title="All 2 branches missed.">            if ((short)(s = status) != e)</span>
<span class="nc" id="L1367">                return false;</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (U.compareAndSwapInt(this, STATUS, s,</span>
                                    (s &amp; ~SMASK) | (tag &amp; SMASK)))
<span class="nc" id="L1370">                return true;</span>
        }
    }

    /**
     * Adaptor for Runnables. This implements RunnableFuture
     * to be compliant with AbstractExecutorService constraints
     * when used in ForkJoinPool.
     */
    static final class AdaptedRunnable&lt;T&gt; extends ForkJoinTask&lt;T&gt;
        implements RunnableFuture&lt;T&gt; {
        final Runnable runnable;
        T result;
<span class="nc" id="L1383">        AdaptedRunnable(Runnable runnable, T result) {</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            if (runnable == null) throw new NullPointerException();</span>
<span class="nc" id="L1385">            this.runnable = runnable;</span>
<span class="nc" id="L1386">            this.result = result; // OK to set this even before completion</span>
<span class="nc" id="L1387">        }</span>
<span class="nc" id="L1388">        public final T getRawResult() { return result; }</span>
<span class="nc" id="L1389">        public final void setRawResult(T v) { result = v; }</span>
<span class="nc" id="L1390">        public final boolean exec() { runnable.run(); return true; }</span>
<span class="nc" id="L1391">        public final void run() { invoke(); }</span>
        private static final long serialVersionUID = 5232453952276885070L;
    }

    /**
     * Adaptor for Runnables without results
     */
    static final class AdaptedRunnableAction extends ForkJoinTask&lt;Void&gt;
        implements RunnableFuture&lt;Void&gt; {
        final Runnable runnable;
<span class="nc" id="L1401">        AdaptedRunnableAction(Runnable runnable) {</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">            if (runnable == null) throw new NullPointerException();</span>
<span class="nc" id="L1403">            this.runnable = runnable;</span>
<span class="nc" id="L1404">        }</span>
<span class="nc" id="L1405">        public final Void getRawResult() { return null; }</span>
<span class="nc" id="L1406">        public final void setRawResult(Void v) { }</span>
<span class="nc" id="L1407">        public final boolean exec() { runnable.run(); return true; }</span>
<span class="nc" id="L1408">        public final void run() { invoke(); }</span>
        private static final long serialVersionUID = 5232453952276885070L;
    }

    /**
     * Adaptor for Runnables in which failure forces worker exception
     */
    static final class RunnableExecuteAction extends ForkJoinTask&lt;Void&gt; {
        final Runnable runnable;
<span class="fc" id="L1417">        RunnableExecuteAction(Runnable runnable) {</span>
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">            if (runnable == null) throw new NullPointerException();</span>
<span class="fc" id="L1419">            this.runnable = runnable;</span>
<span class="fc" id="L1420">        }</span>
<span class="nc" id="L1421">        public final Void getRawResult() { return null; }</span>
<span class="nc" id="L1422">        public final void setRawResult(Void v) { }</span>
<span class="nc" id="L1423">        public final boolean exec() { runnable.run(); return true; }</span>
        void internalPropagateException(Throwable ex) {
<span class="nc" id="L1425">            rethrow(ex); // rethrow outside exec() catches.</span>
<span class="nc" id="L1426">        }</span>
        private static final long serialVersionUID = 5232453952276885070L;
    }

    /**
     * Adaptor for Callables
     */
<span class="fc" id="L1433">    static final class AdaptedCallable&lt;T&gt; extends ForkJoinTask&lt;T&gt;</span>
        implements RunnableFuture&lt;T&gt; {
        final Callable&lt;? extends T&gt; callable;
        T result;
<span class="nc" id="L1437">        AdaptedCallable(Callable&lt;? extends T&gt; callable) {</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">            if (callable == null) throw new NullPointerException();</span>
<span class="nc" id="L1439">            this.callable = callable;</span>
<span class="nc" id="L1440">        }</span>
<span class="nc" id="L1441">        public final T getRawResult() { return result; }</span>
<span class="nc" id="L1442">        public final void setRawResult(T v) { result = v; }</span>
        public final boolean exec() {
            try {
<span class="nc" id="L1445">                result = callable.call();</span>
<span class="nc" id="L1446">                return true;</span>
<span class="nc" id="L1447">            } catch (Error err) {</span>
<span class="nc" id="L1448">                throw err;</span>
<span class="nc" id="L1449">            } catch (RuntimeException rex) {</span>
<span class="nc" id="L1450">                throw rex;</span>
<span class="nc" id="L1451">            } catch (Exception ex) {</span>
<span class="nc" id="L1452">                throw new RuntimeException(ex);</span>
            }
        }
<span class="nc" id="L1455">        public final void run() { invoke(); }</span>
        private static final long serialVersionUID = 2838392045355241008L;
    }

    /**
     * Returns a new {@code ForkJoinTask} that performs the {@code run}
     * method of the given {@code Runnable} as its action, and returns
     * a null result upon {@link #join}.
     *
     * @param runnable the runnable action
     * @return the task
     */
    public static ForkJoinTask&lt;?&gt; adapt(Runnable runnable) {
<span class="nc" id="L1468">        return new AdaptedRunnableAction(runnable);</span>
    }

    /**
     * Returns a new {@code ForkJoinTask} that performs the {@code run}
     * method of the given {@code Runnable} as its action, and returns
     * the given result upon {@link #join}.
     *
     * @param runnable the runnable action
     * @param result the result upon completion
     * @param &lt;T&gt; the type of the result
     * @return the task
     */
    public static &lt;T&gt; ForkJoinTask&lt;T&gt; adapt(Runnable runnable, T result) {
<span class="nc" id="L1482">        return new AdaptedRunnable&lt;T&gt;(runnable, result);</span>
    }

    /**
     * Returns a new {@code ForkJoinTask} that performs the {@code call}
     * method of the given {@code Callable} as its action, and returns
     * its result upon {@link #join}, translating any checked exceptions
     * encountered into {@code RuntimeException}.
     *
     * @param callable the callable action
     * @param &lt;T&gt; the type of the callable's result
     * @return the task
     */
    public static &lt;T&gt; ForkJoinTask&lt;T&gt; adapt(Callable&lt;? extends T&gt; callable) {
<span class="nc" id="L1496">        return new AdaptedCallable&lt;T&gt;(callable);</span>
    }

    // Serialization support

    private static final long serialVersionUID = -7721805057305804111L;

    /**
     * Saves this task to a stream (that is, serializes it).
     *
     * @param s the stream
     * @throws java.io.IOException if an I/O error occurs
     * @serialData the current run status and the exception thrown
     * during execution, or {@code null} if none
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
<span class="nc" id="L1513">        s.defaultWriteObject();</span>
<span class="nc" id="L1514">        s.writeObject(getException());</span>
<span class="nc" id="L1515">    }</span>

    /**
     * Reconstitutes this task from a stream (that is, deserializes it).
     * @param s the stream
     * @throws ClassNotFoundException if the class of a serialized object
     *         could not be found
     * @throws java.io.IOException if an I/O error occurs
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L1526">        s.defaultReadObject();</span>
<span class="nc" id="L1527">        Object ex = s.readObject();</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        if (ex != null)</span>
<span class="nc" id="L1529">            setExceptionalCompletion((Throwable)ex);</span>
<span class="nc" id="L1530">    }</span>

    // Unsafe mechanics
    private static final sun.misc.Unsafe U;
    private static final long STATUS;

    static {
<span class="fc" id="L1537">        exceptionTableLock = new ReentrantLock();</span>
<span class="fc" id="L1538">        exceptionTableRefQueue = new ReferenceQueue&lt;Object&gt;();</span>
<span class="fc" id="L1539">        exceptionTable = new ExceptionNode[EXCEPTION_MAP_CAPACITY];</span>
        try {
<span class="fc" id="L1541">            U = sun.misc.Unsafe.getUnsafe();</span>
<span class="fc" id="L1542">            Class&lt;?&gt; k = ForkJoinTask.class;</span>
<span class="fc" id="L1543">            STATUS = U.objectFieldOffset</span>
<span class="fc" id="L1544">                (k.getDeclaredField(&quot;status&quot;));</span>
<span class="nc" id="L1545">        } catch (Exception e) {</span>
<span class="nc" id="L1546">            throw new Error(e);</span>
<span class="fc" id="L1547">        }</span>
<span class="fc" id="L1548">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>