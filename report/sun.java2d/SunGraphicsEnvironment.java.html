<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SunGraphicsEnvironment.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d</a> &gt; <span class="el_source">SunGraphicsEnvironment.java</span></div><h1>SunGraphicsEnvironment.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d;

import java.awt.AWTError;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.awt.peer.ComponentPeer;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.InputStreamReader;
import java.io.IOException;
import java.text.AttributedCharacterIterator;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;
import sun.awt.AppContext;
import sun.awt.DisplayChangedListener;
import sun.awt.FontConfiguration;
import sun.awt.SunDisplayChanger;
import sun.font.CompositeFontDescriptor;
import sun.font.Font2D;
import sun.font.FontManager;
import sun.font.FontManagerFactory;
import sun.font.FontManagerForSGE;
import sun.font.NativeFont;

/**
 * This is an implementation of a GraphicsEnvironment object for the
 * default local GraphicsEnvironment.
 *
 * @see GraphicsDevice
 * @see GraphicsConfiguration
 */
public abstract class SunGraphicsEnvironment extends GraphicsEnvironment
    implements DisplayChangedListener {

    public static boolean isOpenSolaris;
    private static Font defaultFont;

<span class="fc" id="L83">    public SunGraphicsEnvironment() {</span>
<span class="fc" id="L84">        java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L85">                                    new java.security.PrivilegedAction() {</span>
            public Object run() {
<span class="fc" id="L87">                    String version = System.getProperty(&quot;os.version&quot;, &quot;0.0&quot;);</span>
                    try {
<span class="nc" id="L89">                        float ver = Float.parseFloat(version);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">                        if (ver &gt; 5.10f) {</span>
<span class="nc" id="L91">                            File f = new File(&quot;/etc/release&quot;);</span>
<span class="nc" id="L92">                            FileInputStream fis = new FileInputStream(f);</span>
<span class="nc" id="L93">                            InputStreamReader isr</span>
                                = new InputStreamReader(fis, &quot;ISO-8859-1&quot;);
<span class="nc" id="L95">                            BufferedReader br = new BufferedReader(isr);</span>
<span class="nc" id="L96">                            String line = br.readLine();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                            if (line.indexOf(&quot;OpenSolaris&quot;) &gt;= 0) {</span>
<span class="nc" id="L98">                                isOpenSolaris = true;</span>
                            } else {
                                /* We are using isOpenSolaris as meaning
                                 * we know the Solaris commercial fonts aren't
                                 * present. &quot;Solaris Next&quot; (03/10) did not
                                 * include these even though its was not
                                 * OpenSolaris. Need to revisit how this is
                                 * handled but for now as in 6ux, we'll use
                                 * the test for a standard font resource as
                                 * being an indicator as to whether we need
                                 * to treat this as OpenSolaris from a font
                                 * config perspective.
                                 */
<span class="nc" id="L111">                                String courierNew =</span>
                                    &quot;/usr/openwin/lib/X11/fonts/TrueType/CourierNew.ttf&quot;;
<span class="nc" id="L113">                                File courierFile = new File(courierNew);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                                isOpenSolaris = !courierFile.exists();</span>
                            }
<span class="nc" id="L116">                            fis.close();</span>
                        }
<span class="fc" id="L118">                    } catch (Exception e) {</span>
<span class="nc" id="L119">                    }</span>

                /* Establish the default font to be used by SG2D etc */
<span class="fc" id="L122">                defaultFont = new Font(Font.DIALOG, Font.PLAIN, 12);</span>

<span class="fc" id="L124">                return null;</span>
            }
        });
<span class="fc" id="L127">    }</span>

    protected GraphicsDevice[] screens;

    /**
     * Returns an array of all of the screen devices.
     */
    public synchronized GraphicsDevice[] getScreenDevices() {
<span class="nc" id="L135">        GraphicsDevice[] ret = screens;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (ret == null) {</span>
<span class="nc" id="L137">            int num = getNumScreens();</span>
<span class="nc" id="L138">            ret = new GraphicsDevice[num];</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            for (int i = 0; i &lt; num; i++) {</span>
<span class="nc" id="L140">                ret[i] = makeScreenDevice(i);</span>
            }
<span class="nc" id="L142">            screens = ret;</span>
        }
<span class="nc" id="L144">        return ret;</span>
    }

    /**
     * Returns the number of screen devices of this graphics environment.
     *
     * @return the number of screen devices of this graphics environment
     */
    protected abstract int getNumScreens();

    /**
     * Create and return the screen device with the specified number. The
     * device with number &lt;code&gt;0&lt;/code&gt; will be the default device (returned
     * by {@link #getDefaultScreenDevice()}.
     *
     * @param screennum the number of the screen to create
     *
     * @return the created screen device
     */
    protected abstract GraphicsDevice makeScreenDevice(int screennum);

    /**
     * Returns the default screen graphics device.
     */
    public GraphicsDevice getDefaultScreenDevice() {
<span class="nc" id="L169">        GraphicsDevice[] screens = getScreenDevices();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (screens.length == 0) {</span>
<span class="nc" id="L171">            throw new AWTError(&quot;no screen devices&quot;);</span>
        }
<span class="nc" id="L173">        return screens[0];</span>
    }

    /**
     * Returns a Graphics2D object for rendering into the
     * given BufferedImage.
     * @throws NullPointerException if BufferedImage argument is null
     */
    public Graphics2D createGraphics(BufferedImage img) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L183">            throw new NullPointerException(&quot;BufferedImage cannot be null&quot;);</span>
        }
<span class="nc" id="L185">        SurfaceData sd = SurfaceData.getPrimarySurfaceData(img);</span>
<span class="nc" id="L186">        return new SunGraphics2D(sd, Color.white, Color.black, defaultFont);</span>
    }

    public static FontManagerForSGE getFontManagerForSGE() {
<span class="nc" id="L190">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L191">        return (FontManagerForSGE) fm;</span>
    }

    /* Modifies the behaviour of a subsequent call to preferLocaleFonts()
     * to use Mincho instead of Gothic for dialoginput in JA locales
     * on windows. Not needed on other platforms.
     *
     * DO NOT MOVE OR RENAME OR OTHERWISE ALTER THIS METHOD.
     * ITS USED BY SOME NON-JRE INTERNAL CODE.
     */
    public static void useAlternateFontforJALocales() {
<span class="nc" id="L202">        getFontManagerForSGE().useAlternateFontforJALocales();</span>
<span class="nc" id="L203">    }</span>

     /**
     * Returns all fonts available in this environment.
     */
    public Font[] getAllFonts() {
<span class="nc" id="L209">        FontManagerForSGE fm = getFontManagerForSGE();</span>
<span class="nc" id="L210">        Font[] installedFonts = fm.getAllInstalledFonts();</span>
<span class="nc" id="L211">        Font[] created = fm.getCreatedFonts();</span>
<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (created == null || created.length == 0) {</span>
<span class="nc" id="L213">            return installedFonts;</span>
        } else {
<span class="nc" id="L215">            int newlen = installedFonts.length + created.length;</span>
<span class="nc" id="L216">            Font [] fonts = java.util.Arrays.copyOf(installedFonts, newlen);</span>
<span class="nc" id="L217">            System.arraycopy(created, 0, fonts,</span>
                             installedFonts.length, created.length);
<span class="nc" id="L219">            return fonts;</span>
        }
    }

    public String[] getAvailableFontFamilyNames(Locale requestedLocale) {
<span class="nc" id="L224">        FontManagerForSGE fm = getFontManagerForSGE();</span>
<span class="nc" id="L225">        String[] installed = fm.getInstalledFontFamilyNames(requestedLocale);</span>
        /* Use a new TreeMap as used in getInstalledFontFamilyNames
         * and insert all the keys in lower case, so that the sort order
         * is the same as the installed families. This preserves historical
         * behaviour and inserts new families in the right place.
         * It would have been marginally more efficient to directly obtain
         * the tree map and just insert new entries, but not so much as
         * to justify the extra internal interface.
         */
<span class="nc" id="L234">        TreeMap&lt;String, String&gt; map = fm.getCreatedFontFamilyNames();</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">        if (map == null || map.size() == 0) {</span>
<span class="nc" id="L236">            return installed;</span>
        } else {
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int i=0; i&lt;installed.length; i++) {</span>
<span class="nc" id="L239">                map.put(installed[i].toLowerCase(requestedLocale),</span>
                        installed[i]);
            }
<span class="nc" id="L242">            String[] retval =  new String[map.size()];</span>
<span class="nc" id="L243">            Object [] keyNames = map.keySet().toArray();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            for (int i=0; i &lt; keyNames.length; i++) {</span>
<span class="nc" id="L245">                retval[i] = (String)map.get(keyNames[i]);</span>
            }
<span class="nc" id="L247">            return retval;</span>
        }
    }

    public String[] getAvailableFontFamilyNames() {
<span class="nc" id="L252">        return getAvailableFontFamilyNames(Locale.getDefault());</span>
    }

    /**
     * Return the bounds of a GraphicsDevice, less its screen insets.
     * See also java.awt.GraphicsEnvironment.getUsableBounds();
     */
    public static Rectangle getUsableBounds(GraphicsDevice gd) {
<span class="nc" id="L260">        GraphicsConfiguration gc = gd.getDefaultConfiguration();</span>
<span class="nc" id="L261">        Insets insets = Toolkit.getDefaultToolkit().getScreenInsets(gc);</span>
<span class="nc" id="L262">        Rectangle usableBounds = gc.getBounds();</span>

<span class="nc" id="L264">        usableBounds.x += insets.left;</span>
<span class="nc" id="L265">        usableBounds.y += insets.top;</span>
<span class="nc" id="L266">        usableBounds.width -= (insets.left + insets.right);</span>
<span class="nc" id="L267">        usableBounds.height -= (insets.top + insets.bottom);</span>

<span class="nc" id="L269">        return usableBounds;</span>
    }

    /**
     * From the DisplayChangedListener interface; called
     * when the display mode has been changed.
     */
    public void displayChanged() {
        // notify screens in device array to do display update stuff
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (GraphicsDevice gd : getScreenDevices()) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (gd instanceof DisplayChangedListener) {</span>
<span class="nc" id="L280">                ((DisplayChangedListener) gd).displayChanged();</span>
            }
        }

        // notify SunDisplayChanger list (e.g. VolatileSurfaceManagers and
        // SurfaceDataProxies) about the display change event
<span class="nc" id="L286">        displayChanger.notifyListeners();</span>
<span class="nc" id="L287">    }</span>

    /**
     * Part of the DisplayChangedListener interface:
     * propagate this event to listeners
     */
    public void paletteChanged() {
<span class="nc" id="L294">        displayChanger.notifyPaletteChanged();</span>
<span class="nc" id="L295">    }</span>

    /**
     * Returns true when the display is local, false for remote displays.
     *
     * @return true when the display is local, false for remote displays
     */
    public abstract boolean isDisplayLocal();

    /*
     * ----DISPLAY CHANGE SUPPORT----
     */

<span class="fc" id="L308">    protected SunDisplayChanger displayChanger = new SunDisplayChanger();</span>

    /**
     * Add a DisplayChangeListener to be notified when the display settings
     * are changed.
     */
    public void addDisplayChangedListener(DisplayChangedListener client) {
<span class="nc" id="L315">        displayChanger.add(client);</span>
<span class="nc" id="L316">    }</span>

    /**
     * Remove a DisplayChangeListener from Win32GraphicsEnvironment
     */
    public void removeDisplayChangedListener(DisplayChangedListener client) {
<span class="nc" id="L322">        displayChanger.remove(client);</span>
<span class="nc" id="L323">    }</span>

    /*
     * ----END DISPLAY CHANGE SUPPORT----
     */

    /**
     * Returns true if FlipBufferStrategy with COPIED buffer contents
     * is preferred for this peer's GraphicsConfiguration over
     * BlitBufferStrategy, false otherwise.
     *
     * The reason FlipBS could be preferred is that in some configurations
     * an accelerated copy to the screen is supported (like Direct3D 9)
     *
     * @return true if flip strategy should be used, false otherwise
     */
    public boolean isFlipStrategyPreferred(ComponentPeer peer) {
<span class="nc" id="L340">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>