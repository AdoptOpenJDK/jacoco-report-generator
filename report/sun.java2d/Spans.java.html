<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Spans.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d</a> &gt; <span class="el_source">Spans.java</span></div><h1>Spans.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2000, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d;

import java.util.Comparator;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

/**
 * Maintains a list of half-open intervals, called Spans.
 * A Span can be tested against the list of Spans
 * for intersection.
 */
public class Spans {

    /**
     * This class will sort and collapse its span
     * entries after this many span additions via
     * the &lt;code&gt;add&lt;/code&gt; method.
     */
    private static final int kMaxAddsSinceSort = 256;

    /**
     * Holds a list of individual
     * Span instances.
     */
<span class="nc" id="L52">    private List mSpans = new Vector(kMaxAddsSinceSort);</span>

    /**
     * The number of &lt;code&gt;Span&lt;/code&gt;
     * instances that have been added
     * to this object without a sort
     * and collapse taking place.
     */
<span class="nc" id="L60">    private int mAddsSinceSort = 0;</span>

<span class="nc" id="L62">    public Spans() {</span>

<span class="nc" id="L64">    }</span>

    /**
     * Add a span covering the half open interval
     * including &lt;code&gt;start&lt;/code&gt; up to
     * but not including &lt;code&gt;end&lt;/code&gt;.
     */
    public void add(float start, float end) {

<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (mSpans != null) {</span>
<span class="nc" id="L74">            mSpans.add(new Span(start, end));</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">            if (++mAddsSinceSort &gt;= kMaxAddsSinceSort) {</span>
<span class="nc" id="L77">                sortAndCollapse();</span>
            }
        }
<span class="nc" id="L80">    }</span>

    /**
     * Add a span which covers the entire range.
     * This call is logically equivalent to
     * &lt;code&gt;add(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY)&lt;/code&gt;
     * The result of making this call is that
     * all future &lt;code&gt;add&lt;/code&gt; calls are ignored
     * and the &lt;code&gt;intersects&lt;/code&gt; method always
     * returns true.
     */
    public void addInfinite() {
<span class="nc" id="L92">        mSpans = null;</span>
<span class="nc" id="L93">    }</span>

    /**
     * Returns true if the span defined by the half-open
     * interval from &lt;code&gt;start&lt;/code&gt; up to,
     * but not including, &lt;code&gt;end&lt;/code&gt; intersects
     * any of the spans defined by this instance.
     */
    public boolean intersects(float start, float end) {
        boolean doesIntersect;

<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (mSpans != null) {</span>

            /* If we have added any spans since we last
             * sorted and collapsed our list of spans
             * then we need to resort and collapse.
             */
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (mAddsSinceSort &gt; 0) {</span>
<span class="nc" id="L111">                sortAndCollapse();</span>
            }

            /* The SpanIntersection comparator considers
             * two spans equal if they intersect. If
             * the search finds a match then we have an
             * intersection.
             */
<span class="nc" id="L119">            int found = Collections.binarySearch(mSpans,</span>
                                                 new Span(start, end),
                                                 SpanIntersection.instance);

<span class="nc bnc" id="L123" title="All 2 branches missed.">            doesIntersect = found &gt;= 0;</span>

        /* The addInfinite() method has been invoked so
         * everything intersect this instance.
         */
<span class="nc" id="L128">        } else {</span>
<span class="nc" id="L129">           doesIntersect = true;</span>
        }

<span class="nc" id="L132">        return doesIntersect;</span>
    }

    /**
     * Sort the spans in ascending order by their
     * start position. After the spans are sorted
     * collapse any spans that intersect into a
     * single span. The result is a sorted,
     * non-overlapping list of spans.
     */
    private void sortAndCollapse() {

<span class="nc" id="L144">        Collections.sort(mSpans);</span>
<span class="nc" id="L145">        mAddsSinceSort = 0;</span>

<span class="nc" id="L147">        Iterator iter = mSpans.iterator();</span>

        /* Have 'span' start at the first span in
         * the collection. The collection may be empty
         * so we're careful.
         */
<span class="nc" id="L153">        Span span = null;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (iter.hasNext()) {</span>
<span class="nc" id="L155">            span = (Span) iter.next();</span>
        }

        /* Loop over the spans collapsing those that intersect
         * into a single span.
         */
<span class="nc bnc" id="L161" title="All 2 branches missed.">        while (iter.hasNext()) {</span>

<span class="nc" id="L163">            Span nextSpan = (Span) iter.next();</span>

            /* The spans are in ascending start position
             * order and so the next span's starting point
             * is either in the span we are trying to grow
             * or it is beyond the first span and thus the
             * two spans do not intersect.
             *
             * span:    &lt;----------&lt;
             * nextSpan:        &lt;------         (intersects)
             * nextSpan:                &lt;------ (doesn't intersect)
             *
             * If the spans intersect then we'll remove
             * nextSpan from the list. If nextSpan's
             * ending was beyond the first's then
             * we extend the first.
             *
             * span:    &lt;----------&lt;
             * nextSpan:   &lt;-----&lt;              (don't change span)
             * nextSpan:        &lt;-----------&lt;   (grow span)
             */

<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (span.subsume(nextSpan)) {</span>
<span class="nc" id="L186">                iter.remove();</span>

            /* The next span did not intersect the current
             * span and so it can not be collapsed. Instead
             * it becomes the start of the next set of spans
             * to be collapsed.
             */
            } else {
<span class="nc" id="L194">                span = nextSpan;</span>
            }
<span class="nc" id="L196">        }</span>
<span class="nc" id="L197">    }</span>

    /*
    // For debugging.

    private void printSpans() {
        System.out.println(&quot;----------&quot;);
        if (mSpans != null) {
            Iterator iter = mSpans.iterator();
            while (iter.hasNext()) {
                Span span = (Span) iter.next();
                System.out.println(span);
            }
        }
        System.out.println(&quot;----------&quot;);

    }
    */

    /**
     * Holds a single half-open interval.
     */
    static class Span implements Comparable {

        /**
         * The span includes the starting point.
         */
        private float mStart;

        /**
         * The span goes up to but does not include
         * the ending point.
         */
        private float mEnd;

        /**
         * Create a half-open interval including
         * &lt;code&gt;start&lt;/code&gt; but not including
         * &lt;code&gt;end&lt;/code&gt;.
         */
<span class="nc" id="L237">        Span(float start, float end) {</span>
<span class="nc" id="L238">            mStart = start;</span>
<span class="nc" id="L239">            mEnd = end;</span>
<span class="nc" id="L240">        }</span>

        /**
         * Return the start of the &lt;code&gt;Span&lt;/code&gt;.
         * The start is considered part of the
         * half-open interval.
         */
        final float getStart() {
<span class="nc" id="L248">            return mStart;</span>
        }

        /**
         * Return the end of the &lt;code&gt;Span&lt;/code&gt;.
         * The end is not considered part of the
         * half-open interval.
         */
        final float getEnd() {
<span class="nc" id="L257">            return mEnd;</span>
        }

        /**
         * Change the initial position of the
         * &lt;code&gt;Span&lt;/code&gt;.
         */
        final void setStart(float start) {
<span class="nc" id="L265">            mStart = start;</span>
<span class="nc" id="L266">        }</span>

        /**
         * Change the terminal position of the
         * &lt;code&gt;Span&lt;/code&gt;.
         */
        final void setEnd(float end) {
<span class="nc" id="L273">            mEnd = end;</span>
<span class="nc" id="L274">        }</span>

        /**
         * Attempt to alter this &lt;code&gt;Span&lt;/code&gt;
         * to include &lt;code&gt;otherSpan&lt;/code&gt; without
         * altering this span's starting position.
         * If &lt;code&gt;otherSpan&lt;/code&gt; can be so consumed
         * by this &lt;code&gt;Span&lt;/code&gt; then &lt;code&gt;true&lt;/code&gt;
         * is returned.
         */
        boolean subsume(Span otherSpan) {

            /* We can only subsume 'otherSpan' if
             * its starting position lies in our
             * interval.
             */
<span class="nc" id="L290">            boolean isSubsumed = contains(otherSpan.mStart);</span>

            /* If the other span's starting position
             * was in our interval and the other span
             * was longer than this span, then we need
             * to grow this span to cover the difference.
             */
<span class="nc bnc" id="L297" title="All 4 branches missed.">            if (isSubsumed &amp;&amp; otherSpan.mEnd &gt; mEnd) {</span>
<span class="nc" id="L298">                mEnd = otherSpan.mEnd;</span>
            }

<span class="nc" id="L301">            return isSubsumed;</span>
        }

        /**
         * Return true if the passed in position
         * lies in the half-open interval defined
         * by this &lt;code&gt;Span&lt;/code&gt;.
         */
        boolean contains(float pos) {
<span class="nc bnc" id="L310" title="All 4 branches missed.">            return mStart &lt;= pos &amp;&amp; pos &lt; mEnd;</span>
        }

        /**
         * Rank spans according to their starting
         * position. The end position is ignored
         * in this ranking.
         */
        public int compareTo(Object o) {
<span class="nc" id="L319">            Span otherSpan = (Span) o;</span>
<span class="nc" id="L320">            float otherStart = otherSpan.getStart();</span>
            int result;

<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (mStart &lt; otherStart) {</span>
<span class="nc" id="L324">                result = -1;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            } else if (mStart &gt; otherStart) {</span>
<span class="nc" id="L326">                result = 1;</span>
            } else {
<span class="nc" id="L328">                result = 0;</span>
            }

<span class="nc" id="L331">            return result;</span>
        }

        public String toString() {
<span class="nc" id="L335">            return &quot;Span: &quot; + mStart + &quot; to &quot; + mEnd;</span>
        }

    }

    /**
     * This class ranks a pair of &lt;code&gt;Span&lt;/code&gt;
     * instances. If the instances intersect they
     * are deemed equal otherwise they are ranked
     * by their relative position. Use
     * &lt;code&gt;SpanIntersection.instance&lt;/code&gt; to
     * get the single instance of this class.
     */
    static class SpanIntersection implements Comparator {

        /**
         * This class is a Singleton and the following
         * is the single instance.
         */
<span class="nc" id="L354">        static final SpanIntersection instance =</span>
                                      new SpanIntersection();

        /**
         * Only this class can create instances of itself.
         */
<span class="nc" id="L360">        private SpanIntersection() {</span>

<span class="nc" id="L362">        }</span>

        public int compare(Object o1, Object o2) {
            int result;
<span class="nc" id="L366">            Span span1 = (Span) o1;</span>
<span class="nc" id="L367">            Span span2 = (Span) o2;</span>

            /* Span 1 is entirely to the left of span2.
             * span1:   &lt;-----&lt;
             * span2:            &lt;-----&lt;
             */
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (span1.getEnd() &lt;= span2.getStart()) {</span>
<span class="nc" id="L374">                result = -1;</span>

            /* Span 2 is entirely to the right of span2.
             * span1:                     &lt;-----&lt;
             * span2:            &lt;-----&lt;
             */
<span class="nc bnc" id="L380" title="All 2 branches missed.">            } else if (span1.getStart() &gt;= span2.getEnd()) {</span>
<span class="nc" id="L381">                result = 1;</span>

            /* Otherwise they intersect and we declare them equal.
            */
            } else {
<span class="nc" id="L386">                result = 0;</span>
            }

<span class="nc" id="L389">            return result;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>