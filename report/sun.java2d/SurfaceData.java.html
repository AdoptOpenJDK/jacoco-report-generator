<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SurfaceData.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d</a> &gt; <span class="el_source">SurfaceData.java</span></div><h1>SurfaceData.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.Transparency;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.Raster;

import sun.java2d.loops.RenderCache;
import sun.java2d.loops.RenderLoops;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.SurfaceType;
import sun.java2d.loops.MaskFill;
import sun.java2d.loops.DrawLine;
import sun.java2d.loops.FillRect;
import sun.java2d.loops.DrawRect;
import sun.java2d.loops.DrawPolygons;
import sun.java2d.loops.DrawPath;
import sun.java2d.loops.FillPath;
import sun.java2d.loops.FillSpans;
import sun.java2d.loops.FillParallelogram;
import sun.java2d.loops.DrawParallelogram;
import sun.java2d.loops.FontInfo;
import sun.java2d.loops.DrawGlyphList;
import sun.java2d.loops.DrawGlyphListAA;
import sun.java2d.loops.DrawGlyphListLCD;
import sun.java2d.pipe.LoopPipe;
import sun.java2d.pipe.ShapeDrawPipe;
import sun.java2d.pipe.ParallelogramPipe;
import sun.java2d.pipe.CompositePipe;
import sun.java2d.pipe.GeneralCompositePipe;
import sun.java2d.pipe.SpanClipRenderer;
import sun.java2d.pipe.SpanShapeRenderer;
import sun.java2d.pipe.AAShapePipe;
import sun.java2d.pipe.AlphaPaintPipe;
import sun.java2d.pipe.AlphaColorPipe;
import sun.java2d.pipe.PixelToShapeConverter;
import sun.java2d.pipe.PixelToParallelogramConverter;
import sun.java2d.pipe.TextPipe;
import sun.java2d.pipe.TextRenderer;
import sun.java2d.pipe.AATextRenderer;
import sun.java2d.pipe.LCDTextRenderer;
import sun.java2d.pipe.SolidTextRenderer;
import sun.java2d.pipe.OutlineTextRenderer;
import sun.java2d.pipe.DrawImagePipe;
import sun.java2d.pipe.DrawImage;
import sun.awt.SunHints;
import sun.awt.image.SurfaceManager;
import sun.java2d.pipe.LoopBasedPipe;

/**
 * This class provides various pieces of information relevant to a
 * particular drawing surface.  The information obtained from this
 * object describes the pixels of a particular instance of a drawing
 * surface and can only be shared among the various graphics objects
 * that target the same BufferedImage or the same screen Component.
 * &lt;p&gt;
 * Each SurfaceData object holds a StateTrackableDelegate object
 * which tracks both changes to the content of the pixels of this
 * surface and changes to the overall state of the pixels - such
 * as becoming invalid or losing the surface.  The delegate is
 * marked &quot;dirty&quot; whenever the setSurfaceLost() or invalidate()
 * methods are called and should also be marked &quot;dirty&quot; by the
 * rendering pipelines whenever they modify the pixels of this
 * SurfaceData.
 * &lt;p&gt;
 * If you get a StateTracker from a SurfaceData and it reports
 * that it is still &quot;current&quot;, then you can trust that the pixels
 * have not changed and that the SurfaceData is still valid and
 * has not lost its underlying storage (surfaceLost) since you
 * retrieved the tracker.
 */
public abstract class SurfaceData
    implements Transparency, DisposerTarget, StateTrackable, Surface
{
    private long pData;
    private boolean valid;
    private boolean surfaceLost; // = false;
    private SurfaceType surfaceType;
    private ColorModel colorModel;

<span class="nc" id="L110">    private Object disposerReferent = new Object();</span>

    private static native void initIDs();

    private Object blitProxyKey;
    private StateTrackableDelegate stateDelegate;

    static {
<span class="nc" id="L118">        initIDs();</span>
    }

    protected SurfaceData(SurfaceType surfaceType, ColorModel cm) {
<span class="nc" id="L122">        this(State.STABLE, surfaceType, cm);</span>
<span class="nc" id="L123">    }</span>

    protected SurfaceData(State state, SurfaceType surfaceType, ColorModel cm) {
<span class="nc" id="L126">        this(StateTrackableDelegate.createInstance(state), surfaceType, cm);</span>
<span class="nc" id="L127">    }</span>

    protected SurfaceData(StateTrackableDelegate trackable,
                          SurfaceType surfaceType, ColorModel cm)
<span class="nc" id="L131">    {</span>
<span class="nc" id="L132">        this.stateDelegate = trackable;</span>
<span class="nc" id="L133">        this.colorModel = cm;</span>
<span class="nc" id="L134">        this.surfaceType = surfaceType;</span>
<span class="nc" id="L135">        valid = true;</span>
<span class="nc" id="L136">    }</span>

<span class="nc" id="L138">    protected SurfaceData(State state) {</span>
<span class="nc" id="L139">        this.stateDelegate = StateTrackableDelegate.createInstance(state);</span>
<span class="nc" id="L140">        valid = true;</span>
<span class="nc" id="L141">    }</span>

    /**
     * Subclasses can set a &quot;blit proxy key&quot; which will be used
     * along with the SurfaceManager.getCacheData() mechanism to
     * store acceleration-compatible cached copies of source images.
     * This key is a &quot;tag&quot; used to identify which cached copies
     * are compatible with this destination SurfaceData.
     * The getSourceSurfaceData() method uses this key to manage
     * cached copies of a source image as described below.
     * &lt;p&gt;
     * The Object used as this key should be as unique as it needs
     * to be to ensure that multiple acceleratible destinations can
     * each store their cached copies separately under different keys
     * without interfering with each other or getting back the wrong
     * cached copy.
     * &lt;p&gt;
     * Many acceleratable SurfaceData objects can use their own
     * GraphicsConfiguration as their proxy key as the GC object will
     * typically be unique to a given screen and pixel format, but
     * other rendering destinations may have more or less stringent
     * sharing requirements.  For instance, X11 pixmaps can be
     * shared on a given screen by any GraphicsConfiguration that
     * has the same depth and SurfaceType.  Multiple such GCs with
     * the same depth and SurfaceType can exist per screen so storing
     * a different cached proxy for each would be a waste.  One can
     * imagine platforms where a single cached copy can be created
     * and shared across all screens and pixel formats - such
     * implementations could use a single heavily shared key Object.
     */
    protected void setBlitProxyKey(Object key) {
        // Caching is effectively disabled if we never have a proxy key
        // since the getSourceSurfaceData() method only does caching
        // if the key is not null.
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (SurfaceDataProxy.isCachingAllowed()) {</span>
<span class="nc" id="L176">            this.blitProxyKey = key;</span>
        }
<span class="nc" id="L178">    }</span>

    /**
     * This method is called on a destination SurfaceData to choose
     * the best SurfaceData from a source Image for an imaging
     * operation, with help from its SurfaceManager.
     * The method may determine that the default SurfaceData was
     * really the best choice in the first place, or it may decide
     * to use a cached surface.  Some general decisions about whether
     * acceleration is enabled are made by this method, but any
     * decision based on the type of the source image is made in
     * the makeProxyFor method below when it comes up with the
     * appropriate SurfaceDataProxy instance.
     * The parameters describe the type of imaging operation being performed.
     * &lt;p&gt;
     * If a blitProxyKey was supplied by the subclass then it is
     * used to potentially override the choice of source SurfaceData.
     * The outline of this process is:
     * &lt;ol&gt;
     * &lt;li&gt; Image pipeline asks destSD to find an appropriate
     *      srcSD for a given source Image object.
     * &lt;li&gt; destSD gets the SurfaceManager of the source Image
     *      and first retrieves the default SD from it using
     *      getPrimarySurfaceData()
     * &lt;li&gt; destSD uses its &quot;blit proxy key&quot; (if set) to look for
     *      some cached data stored in the source SurfaceManager
     * &lt;li&gt; If the cached data is null then makeProxyFor() is used
     *      to create some cached data which is stored back in the
     *      source SurfaceManager under the same key for future uses.
     * &lt;li&gt; The cached data will be a SurfaceDataProxy object.
     * &lt;li&gt; The SurfaceDataProxy object is then consulted to
     *      return a replacement SurfaceData object (typically
     *      a cached copy if appropriate, or the original if not).
     * &lt;/ol&gt;
     */
    public SurfaceData getSourceSurfaceData(Image img,
                                            int txtype,
                                            CompositeType comp,
                                            Color bgColor)
    {
<span class="nc" id="L218">        SurfaceManager srcMgr = SurfaceManager.getManager(img);</span>
<span class="nc" id="L219">        SurfaceData srcData = srcMgr.getPrimarySurfaceData();</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">        if (img.getAccelerationPriority() &gt; 0.0f &amp;&amp;</span>
            blitProxyKey != null)
        {
<span class="nc" id="L223">            SurfaceDataProxy sdp =</span>
<span class="nc" id="L224">                (SurfaceDataProxy) srcMgr.getCacheData(blitProxyKey);</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">            if (sdp == null || !sdp.isValid()) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                if (srcData.getState() == State.UNTRACKABLE) {</span>
<span class="nc" id="L227">                    sdp = SurfaceDataProxy.UNCACHED;</span>
                } else {
<span class="nc" id="L229">                    sdp = makeProxyFor(srcData);</span>
                }
<span class="nc" id="L231">                srcMgr.setCacheData(blitProxyKey, sdp);</span>
            }
<span class="nc" id="L233">            srcData = sdp.replaceData(srcData, txtype, comp, bgColor);</span>
        }
<span class="nc" id="L235">        return srcData;</span>
    }

    /**
     * This method is called on a destination SurfaceData to choose
     * a proper SurfaceDataProxy subclass for a source SurfaceData
     * to use to control when and with what surface to override a
     * given image operation.  The argument is the default SurfaceData
     * for the source Image.
     * &lt;p&gt;
     * The type of the return object is chosen based on the
     * acceleration capabilities of this SurfaceData and the
     * type of the given source SurfaceData object.
     * &lt;p&gt;
     * In some cases the original SurfaceData will always be the
     * best choice to use to blit to this SurfaceData.  This can
     * happen if the source image is a hardware surface of the
     * same type as this one and so acceleration will happen without
     * any caching.  It may also be the case that the source image
     * can never be accelerated on this SurfaceData - for example
     * because it is translucent and there are no accelerated
     * translucent image ops for this surface.
     * &lt;p&gt;
     * In those cases there is a special SurfaceDataProxy.UNCACHED
     * instance that represents a NOP for caching purposes - it
     * always returns the original sourceSD object as the replacement
     * copy so no caching is ever performed.
     */
    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
<span class="nc" id="L264">        return SurfaceDataProxy.UNCACHED;</span>
    }

    /**
     * Extracts the SurfaceManager from the given Image, and then
     * returns the SurfaceData object that would best be suited as the
     * destination surface in some rendering operation.
     */
    public static SurfaceData getPrimarySurfaceData(Image img) {
<span class="nc" id="L273">        SurfaceManager sMgr = SurfaceManager.getManager(img);</span>
<span class="nc" id="L274">        return sMgr.getPrimarySurfaceData();</span>
    }

    /**
     * Restores the contents of the given Image and then returns the new
     * SurfaceData object in use by the Image's SurfaceManager.
     */
    public static SurfaceData restoreContents(Image img) {
<span class="nc" id="L282">        SurfaceManager sMgr = SurfaceManager.getManager(img);</span>
<span class="nc" id="L283">        return sMgr.restoreContents();</span>
    }

    public State getState() {
<span class="nc" id="L287">        return stateDelegate.getState();</span>
    }

    public StateTracker getStateTracker() {
<span class="nc" id="L291">        return stateDelegate.getStateTracker();</span>
    }

    /**
     * Marks this surface as dirty.
     */
    public final void markDirty() {
<span class="nc" id="L298">        stateDelegate.markDirty();</span>
<span class="nc" id="L299">    }</span>

    /**
     * Sets the value of the surfaceLost variable, which indicates whether
     * something has happened to the rendering surface such that it needs
     * to be restored and re-rendered.
     */
    public void setSurfaceLost(boolean lost) {
<span class="nc" id="L307">        surfaceLost = lost;</span>
<span class="nc" id="L308">        stateDelegate.markDirty();</span>
<span class="nc" id="L309">    }</span>

    public boolean isSurfaceLost() {
<span class="nc" id="L312">        return surfaceLost;</span>
    }

    /**
     * Returns a boolean indicating whether or not this SurfaceData is valid.
     */
    public final boolean isValid() {
<span class="nc" id="L319">        return valid;</span>
    }

    public Object getDisposerReferent() {
<span class="nc" id="L323">        return disposerReferent;</span>
    }

    public long getNativeOps() {
<span class="nc" id="L327">        return pData;</span>
    }

    /**
     * Sets this SurfaceData object to the invalid state.  All Graphics
     * objects must get a new SurfaceData object via the refresh method
     * and revalidate their pipelines before continuing.
     */
    public void invalidate() {
<span class="nc" id="L336">        valid = false;</span>
<span class="nc" id="L337">        stateDelegate.markDirty();</span>
<span class="nc" id="L338">    }</span>

    /**
     * Certain changes in the configuration of a surface require the
     * invalidation of existing associated SurfaceData objects and
     * the creation of brand new ones.  These changes include size,
     * ColorModel, or SurfaceType.  Existing Graphics objects
     * which are directed at such surfaces, however, must continue
     * to render to them even after the change occurs underneath
     * the covers.  The getReplacement() method is called from
     * SunGraphics2D.revalidateAll() when the associated SurfaceData
     * is found to be invalid so that a Graphics object can continue
     * to render to the surface in its new configuration.
     *
     * Such changes only tend to happen to window based surfaces since
     * most image based surfaces never change size or pixel format.
     * Even VolatileImage objects never change size and they only
     * change their pixel format when manually validated against a
     * new GraphicsConfiguration, at which point old Graphics objects
     * are no longer expected to render to them after the validation
     * step.  Thus, only window based surfaces really need to deal
     * with this form of replacement.
     */
    public abstract SurfaceData getReplacement();

    protected static final LoopPipe colorPrimitives;

    public static final TextPipe outlineTextRenderer;
    public static final TextPipe solidTextRenderer;
    public static final TextPipe aaTextRenderer;
    public static final TextPipe lcdTextRenderer;

    protected static final AlphaColorPipe colorPipe;
    protected static final PixelToShapeConverter colorViaShape;
    protected static final PixelToParallelogramConverter colorViaPgram;
    protected static final TextPipe colorText;
    protected static final CompositePipe clipColorPipe;
    protected static final TextPipe clipColorText;
    protected static final AAShapePipe AAColorShape;
    protected static final PixelToParallelogramConverter AAColorViaShape;
    protected static final PixelToParallelogramConverter AAColorViaPgram;
    protected static final AAShapePipe AAClipColorShape;
    protected static final PixelToParallelogramConverter AAClipColorViaShape;

    protected static final CompositePipe paintPipe;
    protected static final SpanShapeRenderer paintShape;
    protected static final PixelToShapeConverter paintViaShape;
    protected static final TextPipe paintText;
    protected static final CompositePipe clipPaintPipe;
    protected static final TextPipe clipPaintText;
    protected static final AAShapePipe AAPaintShape;
    protected static final PixelToParallelogramConverter AAPaintViaShape;
    protected static final AAShapePipe AAClipPaintShape;
    protected static final PixelToParallelogramConverter AAClipPaintViaShape;

    protected static final CompositePipe compPipe;
    protected static final SpanShapeRenderer compShape;
    protected static final PixelToShapeConverter compViaShape;
    protected static final TextPipe compText;
    protected static final CompositePipe clipCompPipe;
    protected static final TextPipe clipCompText;
    protected static final AAShapePipe AACompShape;
    protected static final PixelToParallelogramConverter AACompViaShape;
    protected static final AAShapePipe AAClipCompShape;
    protected static final PixelToParallelogramConverter AAClipCompViaShape;

    protected static final DrawImagePipe imagepipe;

    // Utility subclass to add the LoopBasedPipe tagging interface
    static class PixelToShapeLoopConverter
        extends PixelToShapeConverter
        implements LoopBasedPipe
    {
        public PixelToShapeLoopConverter(ShapeDrawPipe pipe) {
<span class="nc" id="L412">            super(pipe);</span>
<span class="nc" id="L413">        }</span>
    }

    // Utility subclass to add the LoopBasedPipe tagging interface
    static class PixelToPgramLoopConverter
        extends PixelToParallelogramConverter
        implements LoopBasedPipe
    {
        public PixelToPgramLoopConverter(ShapeDrawPipe shapepipe,
                                         ParallelogramPipe pgrampipe,
                                         double minPenSize,
                                         double normPosition,
                                         boolean adjustfill)
        {
<span class="nc" id="L427">            super(shapepipe, pgrampipe, minPenSize, normPosition, adjustfill);</span>
<span class="nc" id="L428">        }</span>
    }

    private static PixelToParallelogramConverter
        makeConverter(AAShapePipe renderer,
                      ParallelogramPipe pgrampipe)
    {
<span class="nc" id="L435">        return new PixelToParallelogramConverter(renderer,</span>
                                                 pgrampipe,
                                                 1.0/8.0, 0.499,
                                                 false);
    }

    private static PixelToParallelogramConverter
        makeConverter(AAShapePipe renderer)
    {
<span class="nc" id="L444">        return makeConverter(renderer, renderer);</span>
    }

    static {
<span class="nc" id="L448">        colorPrimitives = new LoopPipe();</span>

<span class="nc" id="L450">        outlineTextRenderer = new OutlineTextRenderer();</span>
<span class="nc" id="L451">        solidTextRenderer = new SolidTextRenderer();</span>
<span class="nc" id="L452">        aaTextRenderer = new AATextRenderer();</span>
<span class="nc" id="L453">        lcdTextRenderer = new LCDTextRenderer();</span>

<span class="nc" id="L455">        colorPipe = new AlphaColorPipe();</span>
        // colorShape = colorPrimitives;
<span class="nc" id="L457">        colorViaShape = new PixelToShapeLoopConverter(colorPrimitives);</span>
<span class="nc" id="L458">        colorViaPgram = new PixelToPgramLoopConverter(colorPrimitives,</span>
                                                      colorPrimitives,
                                                      1.0, 0.25, true);
<span class="nc" id="L461">        colorText = new TextRenderer(colorPipe);</span>
<span class="nc" id="L462">        clipColorPipe = new SpanClipRenderer(colorPipe);</span>
<span class="nc" id="L463">        clipColorText = new TextRenderer(clipColorPipe);</span>
<span class="nc" id="L464">        AAColorShape = new AAShapePipe(colorPipe);</span>
<span class="nc" id="L465">        AAColorViaShape = makeConverter(AAColorShape);</span>
<span class="nc" id="L466">        AAColorViaPgram = makeConverter(AAColorShape, colorPipe);</span>
<span class="nc" id="L467">        AAClipColorShape = new AAShapePipe(clipColorPipe);</span>
<span class="nc" id="L468">        AAClipColorViaShape = makeConverter(AAClipColorShape);</span>

<span class="nc" id="L470">        paintPipe = new AlphaPaintPipe();</span>
<span class="nc" id="L471">        paintShape = new SpanShapeRenderer.Composite(paintPipe);</span>
<span class="nc" id="L472">        paintViaShape = new PixelToShapeConverter(paintShape);</span>
<span class="nc" id="L473">        paintText = new TextRenderer(paintPipe);</span>
<span class="nc" id="L474">        clipPaintPipe = new SpanClipRenderer(paintPipe);</span>
<span class="nc" id="L475">        clipPaintText = new TextRenderer(clipPaintPipe);</span>
<span class="nc" id="L476">        AAPaintShape = new AAShapePipe(paintPipe);</span>
<span class="nc" id="L477">        AAPaintViaShape = makeConverter(AAPaintShape);</span>
<span class="nc" id="L478">        AAClipPaintShape = new AAShapePipe(clipPaintPipe);</span>
<span class="nc" id="L479">        AAClipPaintViaShape = makeConverter(AAClipPaintShape);</span>

<span class="nc" id="L481">        compPipe = new GeneralCompositePipe();</span>
<span class="nc" id="L482">        compShape = new SpanShapeRenderer.Composite(compPipe);</span>
<span class="nc" id="L483">        compViaShape = new PixelToShapeConverter(compShape);</span>
<span class="nc" id="L484">        compText = new TextRenderer(compPipe);</span>
<span class="nc" id="L485">        clipCompPipe = new SpanClipRenderer(compPipe);</span>
<span class="nc" id="L486">        clipCompText = new TextRenderer(clipCompPipe);</span>
<span class="nc" id="L487">        AACompShape = new AAShapePipe(compPipe);</span>
<span class="nc" id="L488">        AACompViaShape = makeConverter(AACompShape);</span>
<span class="nc" id="L489">        AAClipCompShape = new AAShapePipe(clipCompPipe);</span>
<span class="nc" id="L490">        AAClipCompViaShape = makeConverter(AAClipCompShape);</span>

<span class="nc" id="L492">        imagepipe = new DrawImage();</span>
    }

    /* Not all surfaces and rendering mode combinations support LCD text. */
    static final int LOOP_UNKNOWN = 0;
    static final int LOOP_FOUND = 1;
    static final int LOOP_NOTFOUND = 2;
    int haveLCDLoop;
    int havePgramXORLoop;
    int havePgramSolidLoop;

    public boolean canRenderLCDText(SunGraphics2D sg2d) {
        // For now the answer can only be true in the following cases:
<span class="nc bnc" id="L505" title="All 6 branches missed.">        if (sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;</span>
            sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR &amp;&amp;
            sg2d.clipState &lt;= SunGraphics2D.CLIP_RECTANGULAR &amp;&amp;
<span class="nc bnc" id="L508" title="All 2 branches missed.">            sg2d.surfaceData.getTransparency() == Transparency.OPAQUE)</span>
        {
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (haveLCDLoop == LOOP_UNKNOWN) {</span>
<span class="nc" id="L511">                DrawGlyphListLCD loop =</span>
<span class="nc" id="L512">                    DrawGlyphListLCD.locate(SurfaceType.AnyColor,</span>
                                            CompositeType.SrcNoEa,
<span class="nc" id="L514">                                            getSurfaceType());</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                haveLCDLoop = (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;</span>
            }
<span class="nc bnc" id="L517" title="All 2 branches missed.">            return haveLCDLoop == LOOP_FOUND;</span>
        }
<span class="nc" id="L519">        return false; /* for now - in the future we may want to search */</span>
    }

    public boolean canRenderParallelograms(SunGraphics2D sg2d) {
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">            if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (havePgramXORLoop == LOOP_UNKNOWN) {</span>
<span class="nc" id="L526">                    FillParallelogram loop =</span>
<span class="nc" id="L527">                        FillParallelogram.locate(SurfaceType.AnyColor,</span>
                                                 CompositeType.Xor,
<span class="nc" id="L529">                                                 getSurfaceType());</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                    havePgramXORLoop =</span>
                        (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;
                }
<span class="nc bnc" id="L533" title="All 2 branches missed.">                return havePgramXORLoop == LOOP_FOUND;</span>
<span class="nc bnc" id="L534" title="All 6 branches missed.">            } else if (sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;</span>
                       sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON &amp;&amp;
                       sg2d.clipState != SunGraphics2D.CLIP_SHAPE)
            {
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (havePgramSolidLoop == LOOP_UNKNOWN) {</span>
<span class="nc" id="L539">                    FillParallelogram loop =</span>
<span class="nc" id="L540">                        FillParallelogram.locate(SurfaceType.AnyColor,</span>
                                                 CompositeType.SrcNoEa,
<span class="nc" id="L542">                                                 getSurfaceType());</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                    havePgramSolidLoop =</span>
                        (loop != null) ? LOOP_FOUND : LOOP_NOTFOUND;
                }
<span class="nc bnc" id="L546" title="All 2 branches missed.">                return havePgramSolidLoop == LOOP_FOUND;</span>
            }
        }
<span class="nc" id="L549">        return false;</span>
    }

    public void validatePipe(SunGraphics2D sg2d) {
<span class="nc" id="L553">        sg2d.imagepipe = imagepipe;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR) {</span>
<span class="nc" id="L556">                sg2d.drawpipe = paintViaShape;</span>
<span class="nc" id="L557">                sg2d.fillpipe = paintViaShape;</span>
<span class="nc" id="L558">                sg2d.shapepipe = paintShape;</span>
                // REMIND: Ideally custom paint mode would use glyph
                // rendering as opposed to outline rendering but the
                // glyph paint rendering pipeline uses MaskBlit which
                // is not defined for XOR.  This means that text drawn
                // in XOR mode with a Color object is different than
                // text drawn in XOR mode with a Paint object.
<span class="nc" id="L565">                sg2d.textpipe = outlineTextRenderer;</span>
            } else {
                PixelToShapeConverter converter;
<span class="nc bnc" id="L568" title="All 2 branches missed.">                if (canRenderParallelograms(sg2d)) {</span>
<span class="nc" id="L569">                    converter = colorViaPgram;</span>
                    // Note that we use the transforming pipe here because it
                    // will examine the shape and possibly perform an optimized
                    // operation if it can be simplified.  The simplifications
                    // will be valid for all STROKE and TRANSFORM types.
<span class="nc" id="L574">                    sg2d.shapepipe = colorViaPgram;</span>
                } else {
<span class="nc" id="L576">                    converter = colorViaShape;</span>
<span class="nc" id="L577">                    sg2d.shapepipe = colorPrimitives;</span>
                }
<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L580">                    sg2d.drawpipe = converter;</span>
<span class="nc" id="L581">                    sg2d.fillpipe = converter;</span>
                    // REMIND: We should not be changing text strategies
                    // between outline and glyph rendering based upon the
                    // presence of a complex clip as that could cause a
                    // mismatch when drawing the same text both clipped
                    // and unclipped on two separate rendering passes.
                    // Unfortunately, all of the clipped glyph rendering
                    // pipelines rely on the use of the MaskBlit operation
                    // which is not defined for XOR.
<span class="nc" id="L590">                    sg2d.textpipe = outlineTextRenderer;</span>
                } else {
<span class="nc bnc" id="L592" title="All 2 branches missed.">                    if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L593">                        sg2d.drawpipe = converter;</span>
<span class="nc" id="L594">                        sg2d.fillpipe = converter;</span>
                    } else {
<span class="nc bnc" id="L596" title="All 2 branches missed.">                        if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {</span>
<span class="nc" id="L597">                            sg2d.drawpipe = converter;</span>
                        } else {
<span class="nc" id="L599">                            sg2d.drawpipe = colorPrimitives;</span>
                        }
<span class="nc" id="L601">                        sg2d.fillpipe = colorPrimitives;</span>
                    }
<span class="nc" id="L603">                    sg2d.textpipe = solidTextRenderer;</span>
                }
                // assert(sg2d.surfaceData == this);
<span class="nc" id="L606">            }</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        } else if (sg2d.compositeState == SunGraphics2D.COMP_CUSTOM) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">            if (sg2d.antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L610">                    sg2d.drawpipe = AAClipCompViaShape;</span>
<span class="nc" id="L611">                    sg2d.fillpipe = AAClipCompViaShape;</span>
<span class="nc" id="L612">                    sg2d.shapepipe = AAClipCompViaShape;</span>
<span class="nc" id="L613">                    sg2d.textpipe = clipCompText;</span>
                } else {
<span class="nc" id="L615">                    sg2d.drawpipe = AACompViaShape;</span>
<span class="nc" id="L616">                    sg2d.fillpipe = AACompViaShape;</span>
<span class="nc" id="L617">                    sg2d.shapepipe = AACompViaShape;</span>
<span class="nc" id="L618">                    sg2d.textpipe = compText;</span>
                }
            } else {
<span class="nc" id="L621">                sg2d.drawpipe = compViaShape;</span>
<span class="nc" id="L622">                sg2d.fillpipe = compViaShape;</span>
<span class="nc" id="L623">                sg2d.shapepipe = compShape;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L625">                    sg2d.textpipe = clipCompText;</span>
                } else {
<span class="nc" id="L627">                    sg2d.textpipe = compText;</span>
                }
            }
<span class="nc bnc" id="L630" title="All 2 branches missed.">        } else if (sg2d.antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {</span>
<span class="nc" id="L631">            sg2d.alphafill = getMaskFill(sg2d);</span>
            // assert(sg2d.surfaceData == this);
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (sg2d.alphafill != null) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L635">                    sg2d.drawpipe = AAClipColorViaShape;</span>
<span class="nc" id="L636">                    sg2d.fillpipe = AAClipColorViaShape;</span>
<span class="nc" id="L637">                    sg2d.shapepipe = AAClipColorViaShape;</span>
<span class="nc" id="L638">                    sg2d.textpipe = clipColorText;</span>
                } else {
<span class="nc" id="L640">                    PixelToParallelogramConverter converter =</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                        (sg2d.alphafill.canDoParallelograms()</span>
                         ? AAColorViaPgram
                         : AAColorViaShape);
<span class="nc" id="L644">                    sg2d.drawpipe = converter;</span>
<span class="nc" id="L645">                    sg2d.fillpipe = converter;</span>
<span class="nc" id="L646">                    sg2d.shapepipe = converter;</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">                    if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR ||</span>
                        sg2d.compositeState &gt; SunGraphics2D.COMP_ISCOPY)
                    {
<span class="nc" id="L650">                        sg2d.textpipe = colorText;</span>
                    } else {
<span class="nc" id="L652">                        sg2d.textpipe = getTextPipe(sg2d, true /* AA==ON */);</span>
                    }
<span class="nc" id="L654">                }</span>
            } else {
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L657">                    sg2d.drawpipe = AAClipPaintViaShape;</span>
<span class="nc" id="L658">                    sg2d.fillpipe = AAClipPaintViaShape;</span>
<span class="nc" id="L659">                    sg2d.shapepipe = AAClipPaintViaShape;</span>
<span class="nc" id="L660">                    sg2d.textpipe = clipPaintText;</span>
                } else {
<span class="nc" id="L662">                    sg2d.drawpipe = AAPaintViaShape;</span>
<span class="nc" id="L663">                    sg2d.fillpipe = AAPaintViaShape;</span>
<span class="nc" id="L664">                    sg2d.shapepipe = AAPaintViaShape;</span>
<span class="nc" id="L665">                    sg2d.textpipe = paintText;</span>
                }
            }
<span class="nc bnc" id="L668" title="All 6 branches missed.">        } else if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR ||</span>
                   sg2d.compositeState &gt; SunGraphics2D.COMP_ISCOPY ||
                   sg2d.clipState == SunGraphics2D.CLIP_SHAPE)
        {
<span class="nc" id="L672">            sg2d.drawpipe = paintViaShape;</span>
<span class="nc" id="L673">            sg2d.fillpipe = paintViaShape;</span>
<span class="nc" id="L674">            sg2d.shapepipe = paintShape;</span>
<span class="nc" id="L675">            sg2d.alphafill = getMaskFill(sg2d);</span>
            // assert(sg2d.surfaceData == this);
<span class="nc bnc" id="L677" title="All 2 branches missed.">            if (sg2d.alphafill != null) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L679">                    sg2d.textpipe = clipColorText;</span>
                } else {
<span class="nc" id="L681">                    sg2d.textpipe = colorText;</span>
                }
            } else {
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (sg2d.clipState == SunGraphics2D.CLIP_SHAPE) {</span>
<span class="nc" id="L685">                    sg2d.textpipe = clipPaintText;</span>
                } else {
<span class="nc" id="L687">                    sg2d.textpipe = paintText;</span>
                }
            }
        } else {
            PixelToShapeConverter converter;
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (canRenderParallelograms(sg2d)) {</span>
<span class="nc" id="L693">                converter = colorViaPgram;</span>
                // Note that we use the transforming pipe here because it
                // will examine the shape and possibly perform an optimized
                // operation if it can be simplified.  The simplifications
                // will be valid for all STROKE and TRANSFORM types.
<span class="nc" id="L698">                sg2d.shapepipe = colorViaPgram;</span>
            } else {
<span class="nc" id="L700">                converter = colorViaShape;</span>
<span class="nc" id="L701">                sg2d.shapepipe = colorPrimitives;</span>
            }
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L704">                sg2d.drawpipe = converter;</span>
<span class="nc" id="L705">                sg2d.fillpipe = converter;</span>
            } else {
<span class="nc bnc" id="L707" title="All 2 branches missed.">                if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {</span>
<span class="nc" id="L708">                    sg2d.drawpipe = converter;</span>
                } else {
<span class="nc" id="L710">                    sg2d.drawpipe = colorPrimitives;</span>
                }
<span class="nc" id="L712">                sg2d.fillpipe = colorPrimitives;</span>
            }

<span class="nc" id="L715">            sg2d.textpipe = getTextPipe(sg2d, false /* AA==OFF */);</span>
            // assert(sg2d.surfaceData == this);
        }

        // check for loops
<span class="nc bnc" id="L720" title="All 10 branches missed.">        if (sg2d.textpipe  instanceof LoopBasedPipe ||</span>
            sg2d.shapepipe instanceof LoopBasedPipe ||
            sg2d.fillpipe  instanceof LoopBasedPipe ||
            sg2d.drawpipe  instanceof LoopBasedPipe ||
            sg2d.imagepipe instanceof LoopBasedPipe)
        {
<span class="nc" id="L726">            sg2d.loops = getRenderLoops(sg2d);</span>
        }
<span class="nc" id="L728">    }</span>

    /* Return the text pipe to be used based on the graphics AA hint setting,
     * and the rest of the graphics state is compatible with these loops.
     * If the text AA hint is &quot;DEFAULT&quot;, then the AA graphics hint requests
     * the AA text renderer, else it requests the B&amp;W text renderer.
     */
    private TextPipe getTextPipe(SunGraphics2D sg2d, boolean aaHintIsOn) {

        /* Try to avoid calling getFontInfo() unless its needed to
         * resolve one of the new AA types.
         */
<span class="nc bnc" id="L740" title="All 4 branches missed.">        switch (sg2d.textAntialiasHint) {</span>
        case SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT:
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (aaHintIsOn) {</span>
<span class="nc" id="L743">                return aaTextRenderer;</span>
            } else {
<span class="nc" id="L745">                return solidTextRenderer;</span>
            }
        case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:
<span class="nc" id="L748">            return solidTextRenderer;</span>

        case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
<span class="nc" id="L751">            return aaTextRenderer;</span>

        default:
<span class="nc bnc" id="L754" title="All 4 branches missed.">            switch (sg2d.getFontInfo().aaHint) {</span>

            case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:
            case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:
<span class="nc" id="L758">                return lcdTextRenderer;</span>

            case SunHints.INTVAL_TEXT_ANTIALIAS_ON:
<span class="nc" id="L761">                return aaTextRenderer;</span>

            case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:
<span class="nc" id="L764">                return solidTextRenderer;</span>

                 /* This should not be reached as the FontInfo will
                 * always explicitly set its hint value. So whilst
                 * this could be collapsed to returning say just
                 * solidTextRenderer, or even removed, its left
                 * here in case DEFAULT is ever passed in.
                 */
            default:
<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (aaHintIsOn) {</span>
<span class="nc" id="L774">                    return aaTextRenderer;</span>
                } else {
<span class="nc" id="L776">                    return solidTextRenderer;</span>
                }
            }
        }
    }

    private static SurfaceType getPaintSurfaceType(SunGraphics2D sg2d) {
<span class="nc bnc" id="L783" title="All 7 branches missed.">        switch (sg2d.paintState) {</span>
        case SunGraphics2D.PAINT_OPAQUECOLOR:
<span class="nc" id="L785">            return SurfaceType.OpaqueColor;</span>
        case SunGraphics2D.PAINT_ALPHACOLOR:
<span class="nc" id="L787">            return SurfaceType.AnyColor;</span>
        case SunGraphics2D.PAINT_GRADIENT:
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (sg2d.paint.getTransparency() == OPAQUE) {</span>
<span class="nc" id="L790">                return SurfaceType.OpaqueGradientPaint;</span>
            } else {
<span class="nc" id="L792">                return SurfaceType.GradientPaint;</span>
            }
        case SunGraphics2D.PAINT_LIN_GRADIENT:
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (sg2d.paint.getTransparency() == OPAQUE) {</span>
<span class="nc" id="L796">                return SurfaceType.OpaqueLinearGradientPaint;</span>
            } else {
<span class="nc" id="L798">                return SurfaceType.LinearGradientPaint;</span>
            }
        case SunGraphics2D.PAINT_RAD_GRADIENT:
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (sg2d.paint.getTransparency() == OPAQUE) {</span>
<span class="nc" id="L802">                return SurfaceType.OpaqueRadialGradientPaint;</span>
            } else {
<span class="nc" id="L804">                return SurfaceType.RadialGradientPaint;</span>
            }
        case SunGraphics2D.PAINT_TEXTURE:
<span class="nc bnc" id="L807" title="All 2 branches missed.">            if (sg2d.paint.getTransparency() == OPAQUE) {</span>
<span class="nc" id="L808">                return SurfaceType.OpaqueTexturePaint;</span>
            } else {
<span class="nc" id="L810">                return SurfaceType.TexturePaint;</span>
            }
        default:
        case SunGraphics2D.PAINT_CUSTOM:
<span class="nc" id="L814">            return SurfaceType.AnyPaint;</span>
        }
    }

    private static CompositeType getFillCompositeType(SunGraphics2D sg2d) {
<span class="nc" id="L819">        CompositeType compType = sg2d.imageComp;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (sg2d.compositeState == SunGraphics2D.COMP_ISCOPY) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (compType == CompositeType.SrcOverNoEa) {</span>
<span class="nc" id="L822">                compType = CompositeType.OpaqueSrcOverNoEa;</span>
            } else {
<span class="nc" id="L824">                compType = CompositeType.SrcNoEa;</span>
            }
        }
<span class="nc" id="L827">        return compType;</span>
    }

    /**
     * Returns a MaskFill object that can be used on this destination
     * with the source (paint) and composite types determined by the given
     * SunGraphics2D, or null if no such MaskFill object can be located.
     * Subclasses can override this method if they wish to filter other
     * attributes (such as the hardware capabilities of the destination
     * surface) before returning a specific MaskFill object.
     */
    protected MaskFill getMaskFill(SunGraphics2D sg2d) {
<span class="nc" id="L839">        SurfaceType src = getPaintSurfaceType(sg2d);</span>
<span class="nc" id="L840">        CompositeType comp = getFillCompositeType(sg2d);</span>
<span class="nc" id="L841">        SurfaceType dst = getSurfaceType();</span>
<span class="nc" id="L842">        return MaskFill.getFromCache(src, comp, dst);</span>
    }

<span class="nc" id="L845">    private static RenderCache loopcache = new RenderCache(30);</span>

    /**
     * Return a RenderLoops object containing all of the basic
     * GraphicsPrimitive objects for rendering to the destination
     * surface with the current attributes of the given SunGraphics2D.
     */
    public RenderLoops getRenderLoops(SunGraphics2D sg2d) {
<span class="nc" id="L853">        SurfaceType src = getPaintSurfaceType(sg2d);</span>
<span class="nc" id="L854">        CompositeType comp = getFillCompositeType(sg2d);</span>
<span class="nc" id="L855">        SurfaceType dst = sg2d.getSurfaceData().getSurfaceType();</span>

<span class="nc" id="L857">        Object o = loopcache.get(src, comp, dst);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (o != null) {</span>
<span class="nc" id="L859">            return (RenderLoops) o;</span>
        }

<span class="nc" id="L862">        RenderLoops loops = makeRenderLoops(src, comp, dst);</span>
<span class="nc" id="L863">        loopcache.put(src, comp, dst, loops);</span>
<span class="nc" id="L864">        return loops;</span>
    }

    /**
     * Construct and return a RenderLoops object containing all of
     * the basic GraphicsPrimitive objects for rendering to the
     * destination surface with the given source, destination, and
     * composite types.
     */
    public static RenderLoops makeRenderLoops(SurfaceType src,
                                              CompositeType comp,
                                              SurfaceType dst)
    {
<span class="nc" id="L877">        RenderLoops loops = new RenderLoops();</span>
<span class="nc" id="L878">        loops.drawLineLoop = DrawLine.locate(src, comp, dst);</span>
<span class="nc" id="L879">        loops.fillRectLoop = FillRect.locate(src, comp, dst);</span>
<span class="nc" id="L880">        loops.drawRectLoop = DrawRect.locate(src, comp, dst);</span>
<span class="nc" id="L881">        loops.drawPolygonsLoop = DrawPolygons.locate(src, comp, dst);</span>
<span class="nc" id="L882">        loops.drawPathLoop = DrawPath.locate(src, comp, dst);</span>
<span class="nc" id="L883">        loops.fillPathLoop = FillPath.locate(src, comp, dst);</span>
<span class="nc" id="L884">        loops.fillSpansLoop = FillSpans.locate(src, comp, dst);</span>
<span class="nc" id="L885">        loops.fillParallelogramLoop = FillParallelogram.locate(src, comp, dst);</span>
<span class="nc" id="L886">        loops.drawParallelogramLoop = DrawParallelogram.locate(src, comp, dst);</span>
<span class="nc" id="L887">        loops.drawGlyphListLoop = DrawGlyphList.locate(src, comp, dst);</span>
<span class="nc" id="L888">        loops.drawGlyphListAALoop = DrawGlyphListAA.locate(src, comp, dst);</span>
<span class="nc" id="L889">        loops.drawGlyphListLCDLoop = DrawGlyphListLCD.locate(src, comp, dst);</span>
        /*
        System.out.println(&quot;drawLine: &quot;+loops.drawLineLoop);
        System.out.println(&quot;fillRect: &quot;+loops.fillRectLoop);
        System.out.println(&quot;drawRect: &quot;+loops.drawRectLoop);
        System.out.println(&quot;drawPolygons: &quot;+loops.drawPolygonsLoop);
        System.out.println(&quot;fillSpans: &quot;+loops.fillSpansLoop);
        System.out.println(&quot;drawGlyphList: &quot;+loops.drawGlyphListLoop);
        System.out.println(&quot;drawGlyphListAA: &quot;+loops.drawGlyphListAALoop);
        System.out.println(&quot;drawGlyphListLCD: &quot;+loops.drawGlyphListLCDLoop);
        */
<span class="nc" id="L900">        return loops;</span>
    }

    /**
     * Return the GraphicsConfiguration object that describes this
     * destination surface.
     */
    public abstract GraphicsConfiguration getDeviceConfiguration();

    /**
     * Return the SurfaceType object that describes the destination
     * surface.
     */
    public final SurfaceType getSurfaceType() {
<span class="nc" id="L914">        return surfaceType;</span>
    }

    /**
     * Return the ColorModel for the destination surface.
     */
    public final ColorModel getColorModel() {
<span class="nc" id="L921">        return colorModel;</span>
    }

    /**
     * Returns the type of this &lt;code&gt;Transparency&lt;/code&gt;.
     * @return the field type of this &lt;code&gt;Transparency&lt;/code&gt;, which is
     *          either OPAQUE, BITMASK or TRANSLUCENT.
     */
    public int getTransparency() {
<span class="nc" id="L930">        return getColorModel().getTransparency();</span>
    }

    /**
     * Return a readable Raster which contains the pixels for the
     * specified rectangular region of the destination surface.
     * The coordinate origin of the returned Raster is the same as
     * the device space origin of the destination surface.
     * In some cases the returned Raster might also be writeable.
     * In most cases, the returned Raster might contain more pixels
     * than requested.
     *
     * @see useTightBBoxes
     */
    public abstract Raster getRaster(int x, int y, int w, int h);

    /**
     * Does the pixel accessibility of the destination surface
     * suggest that rendering algorithms might want to take
     * extra time to calculate a more accurate bounding box for
     * the operation being performed?
     * The typical case when this will be true is when a copy of
     * the pixels has to be made when doing a getRaster.  The
     * fewer pixels copied, the faster the operation will go.
     *
     * @see getRaster
     */
    public boolean useTightBBoxes() {
        // Note: The native equivalent would trigger on VISIBLE_TO_NATIVE
        // REMIND: This is not used - should be obsoleted maybe
<span class="nc" id="L960">        return true;</span>
    }

    /**
     * Returns the pixel data for the specified Argb value packed
     * into an integer for easy storage and conveyance.
     */
    public int pixelFor(int rgb) {
<span class="nc" id="L968">        return surfaceType.pixelFor(rgb, colorModel);</span>
    }

    /**
     * Returns the pixel data for the specified color packed into an
     * integer for easy storage and conveyance.
     *
     * This method will use the getRGB() method of the Color object
     * and defer to the pixelFor(int rgb) method if not overridden.
     *
     * For now this is a convenience function, but for cases where
     * the highest quality color conversion is requested, this method
     * should be overridden in those cases so that a more direct
     * conversion of the color to the destination color space
     * can be done using the additional information in the Color
     * object.
     */
    public int pixelFor(Color c) {
<span class="nc" id="L986">        return pixelFor(c.getRGB());</span>
    }

    /**
     * Returns the Argb representation for the specified integer value
     * which is packed in the format of the associated ColorModel.
     */
    public int rgbFor(int pixel) {
<span class="nc" id="L994">        return surfaceType.rgbFor(pixel, colorModel);</span>
    }

    /**
     * Returns the bounds of the destination surface.
     */
    public abstract Rectangle getBounds();

    static java.security.Permission compPermission;

    /**
     * Performs Security Permissions checks to see if a Custom
     * Composite object should be allowed access to the pixels
     * of this surface.
     */
    protected void checkCustomComposite() {
<span class="nc" id="L1010">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">            if (compPermission == null) {</span>
<span class="nc" id="L1013">                compPermission =</span>
                    new java.awt.AWTPermission(&quot;readDisplayPixels&quot;);
            }
<span class="nc" id="L1016">            sm.checkPermission(compPermission);</span>
        }
<span class="nc" id="L1018">    }</span>

    /**
     * Fetches private field IndexColorModel.allgrayopaque
     * which is true when all palette entries in the color
     * model are gray and opaque.
     */
    protected static native boolean isOpaqueGray(IndexColorModel icm);

    /**
     * For our purposes null and NullSurfaceData are the same as
     * they represent a disposed surface.
     */
    public static boolean isNull(SurfaceData sd) {
<span class="nc bnc" id="L1032" title="All 4 branches missed.">        if (sd == null || sd == NullSurfaceData.theInstance) {</span>
<span class="nc" id="L1033">            return true;</span>
        }
<span class="nc" id="L1035">        return false;</span>
    }

    /**
     * Performs a copyarea within this surface.  Returns
     * false if there is no algorithm to perform the copyarea
     * given the current settings of the SunGraphics2D.
     */
    public boolean copyArea(SunGraphics2D sg2d,
                            int x, int y, int w, int h, int dx, int dy)
    {
<span class="nc" id="L1046">        return false;</span>
    }

    /**
     * Synchronously releases resources associated with this surface.
     */
<span class="nc" id="L1052">    public void flush() {}</span>

    /**
     * Returns destination associated with this SurfaceData.  This could be
     * either an Image or a Component; subclasses of SurfaceData are
     * responsible for returning the appropriate object.
     */
    public abstract Object getDestination();

    /**
     * Returns default scale factor of the destination surface. Scale factor
     * describes the mapping between virtual and physical coordinates of the
     * SurfaceData. If the scale is 2 then virtual pixel coordinates need to be
     * doubled for physical pixels.
     */
    public int getDefaultScale() {
<span class="nc" id="L1068">        return 1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>