<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SunGraphics2D.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d</a> &gt; <span class="el_source">SunGraphics2D.java</span></div><h1>SunGraphics2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.RenderingHints.Key;
import java.awt.geom.Area;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.awt.image.renderable.RenderContext;
import java.awt.image.AffineTransformOp;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.Image;
import java.awt.Composite;
import java.awt.Color;
import java.awt.image.ColorModel;
import java.awt.GraphicsConfiguration;
import java.awt.Paint;
import java.awt.GradientPaint;
import java.awt.LinearGradientPaint;
import java.awt.RadialGradientPaint;
import java.awt.TexturePaint;
import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.GeneralPath;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.FontMetrics;
import java.awt.Rectangle;
import java.text.AttributedCharacterIterator;
import java.awt.Font;
import java.awt.image.ImageObserver;
import java.awt.Transparency;
import java.awt.font.GlyphVector;
import java.awt.font.TextLayout;

import sun.awt.image.SurfaceManager;
import sun.font.FontDesignMetrics;
import sun.font.FontUtilities;
import sun.java2d.pipe.PixelDrawPipe;
import sun.java2d.pipe.PixelFillPipe;
import sun.java2d.pipe.ShapeDrawPipe;
import sun.java2d.pipe.ValidatePipe;
import sun.java2d.pipe.ShapeSpanIterator;
import sun.java2d.pipe.Region;
import sun.java2d.pipe.TextPipe;
import sun.java2d.pipe.DrawImagePipe;
import sun.java2d.pipe.LoopPipe;
import sun.java2d.loops.FontInfo;
import sun.java2d.loops.RenderLoops;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.SurfaceType;
import sun.java2d.loops.Blit;
import sun.java2d.loops.MaskFill;
import java.awt.font.FontRenderContext;
import sun.java2d.loops.XORComposite;
import sun.awt.ConstrainableGraphics;
import sun.awt.SunHints;
import java.util.Map;
import java.util.Iterator;
import sun.misc.PerformanceLogger;

import java.lang.annotation.Native;

/**
 * This is a the master Graphics2D superclass for all of the Sun
 * Graphics implementations.  This class relies on subclasses to
 * manage the various device information, but provides an overall
 * general framework for performing all of the requests in the
 * Graphics and Graphics2D APIs.
 *
 * @author Jim Graham
 */
public final class SunGraphics2D
    extends Graphics2D
    implements ConstrainableGraphics, Cloneable, DestSurfaceProvider
{
    /*
     * Attribute States
     */
    /* Paint */
    @Native
    public static final int PAINT_CUSTOM       = 6; /* Any other Paint object */
    @Native
    public static final int PAINT_TEXTURE      = 5; /* Tiled Image */
    @Native
    public static final int PAINT_RAD_GRADIENT = 4; /* Color RadialGradient */
    @Native
    public static final int PAINT_LIN_GRADIENT = 3; /* Color LinearGradient */
    @Native
    public static final int PAINT_GRADIENT     = 2; /* Color Gradient */
    @Native
    public static final int PAINT_ALPHACOLOR   = 1; /* Non-opaque Color */
    @Native
    public static final int PAINT_OPAQUECOLOR  = 0; /* Opaque Color */

    /* Composite*/
    @Native
    public static final int COMP_CUSTOM = 3;/* Custom Composite */
    @Native
    public static final int COMP_XOR    = 2;/* XOR Mode Composite */
    @Native
    public static final int COMP_ALPHA  = 1;/* AlphaComposite */
    @Native
    public static final int COMP_ISCOPY = 0;/* simple stores into destination,
                                             * i.e. Src, SrcOverNoEa, and other
                                             * alpha modes which replace
                                             * the destination.
                                             */

    /* Stroke */
    @Native
    public static final int STROKE_CUSTOM = 3; /* custom Stroke */
    @Native
    public static final int STROKE_WIDE   = 2; /* BasicStroke */
    @Native
    public static final int STROKE_THINDASHED   = 1; /* BasicStroke */
    @Native
    public static final int STROKE_THIN   = 0; /* BasicStroke */

    /* Transform */
    @Native
    public static final int TRANSFORM_GENERIC = 4; /* any 3x2 */
    @Native
    public static final int TRANSFORM_TRANSLATESCALE = 3; /* scale XY */
    @Native
    public static final int TRANSFORM_ANY_TRANSLATE = 2; /* non-int translate */
    @Native
    public static final int TRANSFORM_INT_TRANSLATE = 1; /* int translate */
    @Native
    public static final int TRANSFORM_ISIDENT = 0; /* Identity */

    /* Clipping */
    @Native
    public static final int CLIP_SHAPE       = 2; /* arbitrary clip */
    @Native
    public static final int CLIP_RECTANGULAR = 1; /* rectangular clip */
    @Native
    public static final int CLIP_DEVICE      = 0; /* no clipping set */

    /* The following fields are used when the current Paint is a Color. */
    public int eargb;  // ARGB value with ExtraAlpha baked in
    public int pixel;  // pixel value for eargb

    public SurfaceData surfaceData;

    public PixelDrawPipe drawpipe;
    public PixelFillPipe fillpipe;
    public DrawImagePipe imagepipe;
    public ShapeDrawPipe shapepipe;
    public TextPipe textpipe;
    public MaskFill alphafill;

    public RenderLoops loops;

    public CompositeType imageComp;     /* Image Transparency checked on fly */

    public int paintState;
    public int compositeState;
    public int strokeState;
    public int transformState;
    public int clipState;

    public Color foregroundColor;
    public Color backgroundColor;

    public AffineTransform transform;
    public int transX;
    public int transY;

<span class="nc" id="L203">    protected static final Stroke defaultStroke = new BasicStroke();</span>
<span class="nc" id="L204">    protected static final Composite defaultComposite = AlphaComposite.SrcOver;</span>
<span class="nc" id="L205">    private static final Font defaultFont =</span>
        new Font(Font.DIALOG, Font.PLAIN, 12);

    public Paint paint;
    public Stroke stroke;
    public Composite composite;
    protected Font font;
    protected FontMetrics fontMetrics;

    public int renderHint;
    public int antialiasHint;
    public int textAntialiasHint;
    protected int fractionalMetricsHint;

    /* A gamma adjustment to the colour used in lcd text blitting */
    public int lcdTextContrast;
<span class="nc" id="L221">    private static int lcdTextContrastDefaultValue = 140;</span>

    private int interpolationHint;      // raw value of rendering Hint
    public int strokeHint;

    public int interpolationType;       // algorithm choice based on
                                        // interpolation and render Hints

    public RenderingHints hints;

    public Region constrainClip;        // lightweight bounds in pixels
    public int constrainX;
    public int constrainY;

    public Region clipRegion;
    public Shape usrClip;
    protected Region devClip;           // Actual physical drawable in pixels

    private final int devScale;         // Actual physical scale factor

    // cached state for text rendering
    private boolean validFontInfo;
    private FontInfo fontInfo;
    private FontInfo glyphVectorFontInfo;
    private FontRenderContext glyphVectorFRC;

    private final static int slowTextTransformMask =
                            AffineTransform.TYPE_GENERAL_TRANSFORM
                        |   AffineTransform.TYPE_MASK_ROTATION
                        |   AffineTransform.TYPE_FLIP;

    static {
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (PerformanceLogger.loggingEnabled()) {</span>
<span class="nc" id="L254">            PerformanceLogger.setTime(&quot;SunGraphics2D static initialization&quot;);</span>
        }
    }

<span class="nc" id="L258">    public SunGraphics2D(SurfaceData sd, Color fg, Color bg, Font f) {</span>
<span class="nc" id="L259">        surfaceData = sd;</span>
<span class="nc" id="L260">        foregroundColor = fg;</span>
<span class="nc" id="L261">        backgroundColor = bg;</span>

<span class="nc" id="L263">        transform = new AffineTransform();</span>
<span class="nc" id="L264">        stroke = defaultStroke;</span>
<span class="nc" id="L265">        composite = defaultComposite;</span>
<span class="nc" id="L266">        paint = foregroundColor;</span>

<span class="nc" id="L268">        imageComp = CompositeType.SrcOverNoEa;</span>

<span class="nc" id="L270">        renderHint = SunHints.INTVAL_RENDER_DEFAULT;</span>
<span class="nc" id="L271">        antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;</span>
<span class="nc" id="L272">        textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;</span>
<span class="nc" id="L273">        fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</span>
<span class="nc" id="L274">        lcdTextContrast = lcdTextContrastDefaultValue;</span>
<span class="nc" id="L275">        interpolationHint = -1;</span>
<span class="nc" id="L276">        strokeHint = SunHints.INTVAL_STROKE_DEFAULT;</span>

<span class="nc" id="L278">        interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;</span>

<span class="nc" id="L280">        validateColor();</span>

<span class="nc" id="L282">        devScale = sd.getDefaultScale();</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (devScale != 1) {</span>
<span class="nc" id="L284">            transform.setToScale(devScale, devScale);</span>
<span class="nc" id="L285">            invalidateTransform();</span>
        }

<span class="nc" id="L288">        font = f;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (font == null) {</span>
<span class="nc" id="L290">            font = defaultFont;</span>
        }

<span class="nc" id="L293">        setDevClip(sd.getBounds());</span>
<span class="nc" id="L294">        invalidatePipe();</span>
<span class="nc" id="L295">    }</span>

    protected Object clone() {
        try {
<span class="nc" id="L299">            SunGraphics2D g = (SunGraphics2D) super.clone();</span>
<span class="nc" id="L300">            g.transform = new AffineTransform(this.transform);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (hints != null) {</span>
<span class="nc" id="L302">                g.hints = (RenderingHints) this.hints.clone();</span>
            }
            /* FontInfos are re-used, so must be cloned too, if they
             * are valid, and be nulled out if invalid.
             * The implied trade-off is that there is more to be gained
             * from re-using these objects than is lost by having to
             * clone them when the SG2D is cloned.
             */
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (this.fontInfo != null) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (this.validFontInfo) {</span>
<span class="nc" id="L312">                    g.fontInfo = (FontInfo)this.fontInfo.clone();</span>
                } else {
<span class="nc" id="L314">                    g.fontInfo = null;</span>
                }
            }
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (this.glyphVectorFontInfo != null) {</span>
<span class="nc" id="L318">                g.glyphVectorFontInfo =</span>
<span class="nc" id="L319">                    (FontInfo)this.glyphVectorFontInfo.clone();</span>
<span class="nc" id="L320">                g.glyphVectorFRC = this.glyphVectorFRC;</span>
            }
            //g.invalidatePipe();
<span class="nc" id="L323">            return g;</span>
<span class="nc" id="L324">        } catch (CloneNotSupportedException e) {</span>
        }
<span class="nc" id="L326">        return null;</span>
    }

    /**
     * Create a new SunGraphics2D based on this one.
     */
    public Graphics create() {
<span class="nc" id="L333">        return (Graphics) clone();</span>
    }

    public void setDevClip(int x, int y, int w, int h) {
<span class="nc" id="L337">        Region c = constrainClip;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L339">            devClip = Region.getInstanceXYWH(x, y, w, h);</span>
        } else {
<span class="nc" id="L341">            devClip = c.getIntersectionXYWH(x, y, w, h);</span>
        }
<span class="nc" id="L343">        validateCompClip();</span>
<span class="nc" id="L344">    }</span>

    public void setDevClip(Rectangle r) {
<span class="nc" id="L347">        setDevClip(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L348">    }</span>

    /**
     * Constrain rendering for lightweight objects.
     */
    public void constrain(int x, int y, int w, int h, Region region) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if ((x | y) != 0) {</span>
<span class="nc" id="L355">            translate(x, y);</span>
        }
<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (transformState &gt; TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L358">            clipRect(0, 0, w, h);</span>
<span class="nc" id="L359">            return;</span>
        }
        // changes parameters according to the current scale and translate.
<span class="nc" id="L362">        final double scaleX = transform.getScaleX();</span>
<span class="nc" id="L363">        final double scaleY = transform.getScaleY();</span>
<span class="nc" id="L364">        x = constrainX = (int) transform.getTranslateX();</span>
<span class="nc" id="L365">        y = constrainY = (int) transform.getTranslateY();</span>
<span class="nc" id="L366">        w = Region.dimAdd(x, Region.clipScale(w, scaleX));</span>
<span class="nc" id="L367">        h = Region.dimAdd(y, Region.clipScale(h, scaleY));</span>

<span class="nc" id="L369">        Region c = constrainClip;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L371">            c = Region.getInstanceXYXY(x, y, w, h);</span>
        } else {
<span class="nc" id="L373">            c = c.getIntersectionXYXY(x, y, w, h);</span>
        }
<span class="nc bnc" id="L375" title="All 2 branches missed.">        if (region != null) {</span>
<span class="nc" id="L376">            region = region.getScaledRegion(scaleX, scaleY);</span>
<span class="nc" id="L377">            region = region.getTranslatedRegion(x, y);</span>
<span class="nc" id="L378">            c = c.getIntersection(region);</span>
        }

<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (c == constrainClip) {</span>
            // Common case to ignore
<span class="nc" id="L383">            return;</span>
        }

<span class="nc" id="L386">        constrainClip = c;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (!devClip.isInsideQuickCheck(c)) {</span>
<span class="nc" id="L388">            devClip = devClip.getIntersection(c);</span>
<span class="nc" id="L389">            validateCompClip();</span>
        }
<span class="nc" id="L391">    }</span>

    /**
     * Constrain rendering for lightweight objects.
     *
     * REMIND: This method will back off to the &quot;workaround&quot;
     * of using translate and clipRect if the Graphics
     * to be constrained has a complex transform.  The
     * drawback of the workaround is that the resulting
     * clip and device origin cannot be &quot;enforced&quot;.
     *
     * @exception IllegalStateException If the Graphics
     * to be constrained has a complex transform.
     */
    @Override
    public void constrain(int x, int y, int w, int h) {
<span class="nc" id="L407">        constrain(x, y, w, h, null);</span>
<span class="nc" id="L408">    }</span>

<span class="nc" id="L410">    protected static ValidatePipe invalidpipe = new ValidatePipe();</span>

    /*
     * Invalidate the pipeline
     */
    protected void invalidatePipe() {
<span class="nc" id="L416">        drawpipe = invalidpipe;</span>
<span class="nc" id="L417">        fillpipe = invalidpipe;</span>
<span class="nc" id="L418">        shapepipe = invalidpipe;</span>
<span class="nc" id="L419">        textpipe = invalidpipe;</span>
<span class="nc" id="L420">        imagepipe = invalidpipe;</span>
<span class="nc" id="L421">        loops = null;</span>
<span class="nc" id="L422">    }</span>

    public void validatePipe() {
        /* This workaround is for the situation when we update the Pipelines
         * for invalid SurfaceData and run further code when the current
         * pipeline doesn't support the type of new SurfaceData created during
         * the current pipeline's work (in place of the invalid SurfaceData).
         * Usually SurfaceData and Pipelines are repaired (through revalidateAll)
         * and called again in the exception handlers */

<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (!surfaceData.isValid()) {</span>
<span class="nc" id="L433">            throw new InvalidPipeException(&quot;attempt to validate Pipe with invalid SurfaceData&quot;);</span>
        }

<span class="nc" id="L436">        surfaceData.validatePipe(this);</span>
<span class="nc" id="L437">    }</span>

    /*
     * Intersect two Shapes by the simplest method, attempting to produce
     * a simplified result.
     * The boolean arguments keep1 and keep2 specify whether or not
     * the first or second shapes can be modified during the operation
     * or whether that shape must be &quot;kept&quot; unmodified.
     */
    Shape intersectShapes(Shape s1, Shape s2, boolean keep1, boolean keep2) {
<span class="nc bnc" id="L447" title="All 4 branches missed.">        if (s1 instanceof Rectangle &amp;&amp; s2 instanceof Rectangle) {</span>
<span class="nc" id="L448">            return ((Rectangle) s1).intersection((Rectangle) s2);</span>
        }
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (s1 instanceof Rectangle2D) {</span>
<span class="nc" id="L451">            return intersectRectShape((Rectangle2D) s1, s2, keep1, keep2);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        } else if (s2 instanceof Rectangle2D) {</span>
<span class="nc" id="L453">            return intersectRectShape((Rectangle2D) s2, s1, keep2, keep1);</span>
        }
<span class="nc" id="L455">        return intersectByArea(s1, s2, keep1, keep2);</span>
    }

    /*
     * Intersect a Rectangle with a Shape by the simplest method,
     * attempting to produce a simplified result.
     * The boolean arguments keep1 and keep2 specify whether or not
     * the first or second shapes can be modified during the operation
     * or whether that shape must be &quot;kept&quot; unmodified.
     */
    Shape intersectRectShape(Rectangle2D r, Shape s,
                             boolean keep1, boolean keep2) {
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (s instanceof Rectangle2D) {</span>
<span class="nc" id="L468">            Rectangle2D r2 = (Rectangle2D) s;</span>
            Rectangle2D outrect;
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (!keep1) {</span>
<span class="nc" id="L471">                outrect = r;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            } else if (!keep2) {</span>
<span class="nc" id="L473">                outrect = r2;</span>
            } else {
<span class="nc" id="L475">                outrect = new Rectangle2D.Float();</span>
            }
<span class="nc" id="L477">            double x1 = Math.max(r.getX(), r2.getX());</span>
<span class="nc" id="L478">            double x2 = Math.min(r.getX()  + r.getWidth(),</span>
<span class="nc" id="L479">                                 r2.getX() + r2.getWidth());</span>
<span class="nc" id="L480">            double y1 = Math.max(r.getY(), r2.getY());</span>
<span class="nc" id="L481">            double y2 = Math.min(r.getY()  + r.getHeight(),</span>
<span class="nc" id="L482">                                 r2.getY() + r2.getHeight());</span>

<span class="nc bnc" id="L484" title="All 4 branches missed.">            if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0))</span>
                // Width or height is negative. No intersection.
<span class="nc" id="L486">                outrect.setFrameFromDiagonal(0, 0, 0, 0);</span>
            else
<span class="nc" id="L488">                outrect.setFrameFromDiagonal(x1, y1, x2, y2);</span>
<span class="nc" id="L489">            return outrect;</span>
        }
<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (r.contains(s.getBounds2D())) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (keep2) {</span>
<span class="nc" id="L493">                s = cloneShape(s);</span>
            }
<span class="nc" id="L495">            return s;</span>
        }
<span class="nc" id="L497">        return intersectByArea(r, s, keep1, keep2);</span>
    }

    protected static Shape cloneShape(Shape s) {
<span class="nc" id="L501">        return new GeneralPath(s);</span>
    }

    /*
     * Intersect two Shapes using the Area class.  Presumably other
     * attempts at simpler intersection methods proved fruitless.
     * The boolean arguments keep1 and keep2 specify whether or not
     * the first or second shapes can be modified during the operation
     * or whether that shape must be &quot;kept&quot; unmodified.
     * @see #intersectShapes
     * @see #intersectRectShape
     */
    Shape intersectByArea(Shape s1, Shape s2, boolean keep1, boolean keep2) {
        Area a1, a2;

        // First see if we can find an overwriteable source shape
        // to use as our destination area to avoid duplication.
<span class="nc bnc" id="L518" title="All 4 branches missed.">        if (!keep1 &amp;&amp; (s1 instanceof Area)) {</span>
<span class="nc" id="L519">            a1 = (Area) s1;</span>
<span class="nc bnc" id="L520" title="All 4 branches missed.">        } else if (!keep2 &amp;&amp; (s2 instanceof Area)) {</span>
<span class="nc" id="L521">            a1 = (Area) s2;</span>
<span class="nc" id="L522">            s2 = s1;</span>
        } else {
<span class="nc" id="L524">            a1 = new Area(s1);</span>
        }

<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (s2 instanceof Area) {</span>
<span class="nc" id="L528">            a2 = (Area) s2;</span>
        } else {
<span class="nc" id="L530">            a2 = new Area(s2);</span>
        }

<span class="nc" id="L533">        a1.intersect(a2);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (a1.isRectangular()) {</span>
<span class="nc" id="L535">            return a1.getBounds();</span>
        }

<span class="nc" id="L538">        return a1;</span>
    }

    /*
     * Intersect usrClip bounds and device bounds to determine the composite
     * rendering boundaries.
     */
    public Region getCompClip() {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (!surfaceData.isValid()) {</span>
            // revalidateAll() implicitly recalculcates the composite clip
<span class="nc" id="L548">            revalidateAll();</span>
        }

<span class="nc" id="L551">        return clipRegion;</span>
    }

    public Font getFont() {
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (font == null) {</span>
<span class="nc" id="L556">            font = defaultFont;</span>
        }
<span class="nc" id="L558">        return font;</span>
    }

<span class="nc" id="L561">    private static final double[] IDENT_MATRIX = {1, 0, 0, 1};</span>
<span class="nc" id="L562">    private static final AffineTransform IDENT_ATX =</span>
        new AffineTransform();

    private static final int MINALLOCATED = 8;
    private static final int TEXTARRSIZE = 17;
<span class="nc" id="L567">    private static double[][] textTxArr = new double[TEXTARRSIZE][];</span>
<span class="nc" id="L568">    private static AffineTransform[] textAtArr =</span>
        new AffineTransform[TEXTARRSIZE];

    static {
<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (int i=MINALLOCATED;i&lt;TEXTARRSIZE;i++) {</span>
<span class="nc" id="L573">          textTxArr[i] = new double [] {i, 0, 0, i};</span>
<span class="nc" id="L574">          textAtArr[i] = new AffineTransform( textTxArr[i]);</span>
        }
    }

    // cached state for various draw[String,Char,Byte] optimizations
    public FontInfo checkFontInfo(FontInfo info, Font font,
                                  FontRenderContext frc) {
        /* Do not create a FontInfo object as part of construction of an
         * SG2D as its possible it may never be needed - ie if no text
         * is drawn using this SG2D.
         */
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L586">            info = new FontInfo();</span>
        }

<span class="nc" id="L589">        float ptSize = font.getSize2D();</span>
        int txFontType;
<span class="nc" id="L591">        AffineTransform devAt, textAt=null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (font.isTransformed()) {</span>
<span class="nc" id="L593">            textAt = font.getTransform();</span>
<span class="nc" id="L594">            textAt.scale(ptSize, ptSize);</span>
<span class="nc" id="L595">            txFontType = textAt.getType();</span>
<span class="nc" id="L596">            info.originX = (float)textAt.getTranslateX();</span>
<span class="nc" id="L597">            info.originY = (float)textAt.getTranslateY();</span>
<span class="nc" id="L598">            textAt.translate(-info.originX, -info.originY);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L600">                transform.getMatrix(info.devTx = new double[4]);</span>
<span class="nc" id="L601">                devAt = new AffineTransform(info.devTx);</span>
<span class="nc" id="L602">                textAt.preConcatenate(devAt);</span>
            } else {
<span class="nc" id="L604">                info.devTx = IDENT_MATRIX;</span>
<span class="nc" id="L605">                devAt = IDENT_ATX;</span>
            }
<span class="nc" id="L607">            textAt.getMatrix(info.glyphTx = new double[4]);</span>
<span class="nc" id="L608">            double shearx = textAt.getShearX();</span>
<span class="nc" id="L609">            double scaley = textAt.getScaleY();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (shearx != 0) {</span>
<span class="nc" id="L611">                scaley = Math.sqrt(shearx * shearx + scaley * scaley);</span>
            }
<span class="nc" id="L613">            info.pixelHeight = (int)(Math.abs(scaley)+0.5);</span>
<span class="nc" id="L614">        } else {</span>
<span class="nc" id="L615">            txFontType = AffineTransform.TYPE_IDENTITY;</span>
<span class="nc" id="L616">            info.originX = info.originY = 0;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L618">                transform.getMatrix(info.devTx = new double[4]);</span>
<span class="nc" id="L619">                devAt = new AffineTransform(info.devTx);</span>
<span class="nc" id="L620">                info.glyphTx = new double[4];</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L622">                    info.glyphTx[i] = info.devTx[i] * ptSize;</span>
                }
<span class="nc" id="L624">                textAt = new AffineTransform(info.glyphTx);</span>
<span class="nc" id="L625">                double shearx = transform.getShearX();</span>
<span class="nc" id="L626">                double scaley = transform.getScaleY();</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                if (shearx != 0) {</span>
<span class="nc" id="L628">                    scaley = Math.sqrt(shearx * shearx + scaley * scaley);</span>
                }
<span class="nc" id="L630">                info.pixelHeight = (int)(Math.abs(scaley * ptSize)+0.5);</span>
<span class="nc" id="L631">            } else {</span>
                /* If the double represents a common integral, we
                 * may have pre-allocated objects.
                 * A &quot;sparse&quot; array be seems to be as fast as a switch
                 * even for 3 or 4 pt sizes, and is more flexible.
                 * This should perform comparably in single-threaded
                 * rendering to the old code which synchronized on the
                 * class and scale better on MP systems.
                 */
<span class="nc" id="L640">                int pszInt = (int)ptSize;</span>
<span class="nc bnc" id="L641" title="All 6 branches missed.">                if (ptSize == pszInt &amp;&amp;</span>
                    pszInt &gt;= MINALLOCATED &amp;&amp; pszInt &lt; TEXTARRSIZE) {
<span class="nc" id="L643">                    info.glyphTx = textTxArr[pszInt];</span>
<span class="nc" id="L644">                    textAt = textAtArr[pszInt];</span>
<span class="nc" id="L645">                    info.pixelHeight = pszInt;</span>
                } else {
<span class="nc" id="L647">                    info.pixelHeight = (int)(ptSize+0.5);</span>
                }
<span class="nc bnc" id="L649" title="All 2 branches missed.">                if (textAt == null) {</span>
<span class="nc" id="L650">                    info.glyphTx = new double[] {ptSize, 0, 0, ptSize};</span>
<span class="nc" id="L651">                    textAt = new AffineTransform(info.glyphTx);</span>
                }

<span class="nc" id="L654">                info.devTx = IDENT_MATRIX;</span>
<span class="nc" id="L655">                devAt = IDENT_ATX;</span>
            }
        }

<span class="nc" id="L659">        info.font2D = FontUtilities.getFont2D(font);</span>

<span class="nc" id="L661">        int fmhint = fractionalMetricsHint;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (fmhint == SunHints.INTVAL_FRACTIONALMETRICS_DEFAULT) {</span>
<span class="nc" id="L663">            fmhint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</span>
        }
<span class="nc" id="L665">        info.lcdSubPixPos = false; // conditionally set true in LCD mode.</span>

        /* The text anti-aliasing hints that are set by the client need
         * to be interpreted for the current state and stored in the
         * FontInfo.aahint which is what will actually be used and
         * will be one of OFF, ON, LCD_HRGB or LCD_VRGB.
         * This is what pipe selection code should typically refer to, not
         * textAntialiasHint. This means we are now evaluating the meaning
         * of &quot;default&quot; here. Any pipe that really cares about that will
         * also need to consult that variable.
         * Otherwise these are being used only as args to getStrike,
         * and are encapsulated in that object which is part of the
         * FontInfo, so we do not need to store them directly as fields
         * in the FontInfo object.
         * That could change if FontInfo's were more selectively
         * revalidated when graphics state changed. Presently this
         * method re-evaluates all fields in the fontInfo.
         * The strike doesn't need to know the RGB subpixel order. Just
         * if its H or V orientation, so if an LCD option is specified we
         * always pass in the RGB hint to the strike.
         * frc is non-null only if this is a GlyphVector. For reasons
         * which are probably a historical mistake the AA hint in a GV
         * is honoured when we render, overriding the Graphics setting.
         */
        int aahint;
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (frc == null) {</span>
<span class="nc" id="L691">            aahint = textAntialiasHint;</span>
        } else {
<span class="nc" id="L693">            aahint = ((SunHints.Value)frc.getAntiAliasingHint()).getIndex();</span>
        }
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT) {</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {</span>
<span class="nc" id="L697">                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</span>
            } else {
<span class="nc" id="L699">                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;</span>
            }
        } else {
            /* If we are in checkFontInfo because a rendering hint has been
             * set then all pipes are revalidated. But we can also
             * be here because setFont() has been called when the 'gasp'
             * hint is set, as then the font size determines the text pipe.
             * See comments in SunGraphics2d.setFont(Font).
             */
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                if (info.font2D.useAAForPtSize(info.pixelHeight)) {</span>
<span class="nc" id="L710">                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</span>
                } else {
<span class="nc" id="L712">                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_OFF;</span>
                }
<span class="nc bnc" id="L714" title="All 2 branches missed.">            } else if (aahint &gt;= SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB) {</span>
                /* loops for default rendering modes are installed in the SG2D
                 * constructor. If there are none this will be null.
                 * Not all compositing modes update the render loops, so
                 * we also test that this is a mode we know should support
                 * this. One minor issue is that the loops aren't necessarily
                 * installed for a new rendering mode until after this
                 * method is called during pipeline validation. So it is
                 * theoretically possible that it was set to null for a
                 * compositing mode, the composite is then set back to Src,
                 * but the loop is still null when this is called and AA=ON
                 * is installed instead of an LCD mode.
                 * However this is done in the right order in SurfaceData.java
                 * so this is not likely to be a problem - but not
                 * guaranteed.
                 */
<span class="nc" id="L730">                if (</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    !surfaceData.canRenderLCDText(this)</span>
//                    loops.drawGlyphListLCDLoop == null ||
//                    compositeState &gt; COMP_ISCOPY ||
//                    paintState &gt; PAINT_ALPHACOLOR
                      ) {
<span class="nc" id="L736">                    aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</span>
                } else {
<span class="nc" id="L738">                    info.lcdRGBOrder = true;</span>
                    /* Collapse these into just HRGB or VRGB.
                     * Pipe selection code needs only to test for these two.
                     * Since these both select the same pipe anyway its
                     * tempting to collapse into one value. But they are
                     * different strikes (glyph caches) so the distinction
                     * needs to be made for that purpose.
                     */
<span class="nc bnc" id="L746" title="All 2 branches missed.">                    if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HBGR) {</span>
<span class="nc" id="L747">                        aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;</span>
<span class="nc" id="L748">                        info.lcdRGBOrder = false;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                    } else if</span>
                        (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VBGR) {
<span class="nc" id="L751">                        aahint = SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB;</span>
<span class="nc" id="L752">                        info.lcdRGBOrder = false;</span>
                    }
                    /* Support subpixel positioning only for the case in
                     * which the horizontal resolution is increased
                     */
<span class="nc bnc" id="L757" title="All 4 branches missed.">                    info.lcdSubPixPos =</span>
                        fmhint == SunHints.INTVAL_FRACTIONALMETRICS_ON &amp;&amp;
                        aahint == SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB;
                }
            }
        }
<span class="nc" id="L763">        info.aaHint = aahint;</span>
<span class="nc" id="L764">        info.fontStrike = info.font2D.getStrike(font, devAt, textAt,</span>
                                                aahint, fmhint);
<span class="nc" id="L766">        return info;</span>
    }

    public static boolean isRotated(double [] mtx) {
<span class="nc bnc" id="L770" title="All 8 branches missed.">        if ((mtx[0] == mtx[3]) &amp;&amp;</span>
            (mtx[1] == 0.0) &amp;&amp;
            (mtx[2] == 0.0) &amp;&amp;
            (mtx[0] &gt; 0.0))
        {
<span class="nc" id="L775">            return false;</span>
        }

<span class="nc" id="L778">        return true;</span>
    }

    public void setFont(Font font) {
        /* replacing the reference equality test font != this.font with
         * !font.equals(this.font) did not yield any measurable difference
         * in testing, but there may be yet to be identified cases where it
         * is beneficial.
         */
<span class="nc bnc" id="L787" title="All 4 branches missed.">        if (font != null &amp;&amp; font!=this.font/*!font.equals(this.font)*/) {</span>
            /* In the GASP AA case the textpipe depends on the glyph size
             * as determined by graphics and font transforms as well as the
             * font size, and information in the font. But we may invalidate
             * the pipe only to find that it made no difference.
             * Deferring pipe invalidation to checkFontInfo won't work because
             * when called we may already be rendering to the wrong pipe.
             * So, if the font is transformed, or the graphics has more than
             * a simple scale, we'll take that as enough of a hint to
             * revalidate everything. But if they aren't we will
             * use the font's point size to query the gasp table and see if
             * what it says matches what's currently being used, in which
             * case there's no need to invalidate the textpipe.
             * This should be sufficient for all typical uses cases.
             */
<span class="nc bnc" id="L802" title="All 6 branches missed.">            if (textAntialiasHint == SunHints.INTVAL_TEXT_ANTIALIAS_GASP &amp;&amp;</span>
                textpipe != invalidpipe &amp;&amp;
                (transformState &gt; TRANSFORM_ANY_TRANSLATE ||
<span class="nc bnc" id="L805" title="All 6 branches missed.">                 font.isTransformed() ||</span>
                 fontInfo == null || // Precaution, if true shouldn't get here
                 (fontInfo.aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_ON) !=
<span class="nc" id="L808">                     FontUtilities.getFont2D(font).</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                         useAAForPtSize(font.getSize()))) {</span>
<span class="nc" id="L810">                textpipe = invalidpipe;</span>
            }
<span class="nc" id="L812">            this.font = font;</span>
<span class="nc" id="L813">            this.fontMetrics = null;</span>
<span class="nc" id="L814">            this.validFontInfo = false;</span>
        }
<span class="nc" id="L816">    }</span>

    public FontInfo getFontInfo() {
<span class="nc bnc" id="L819" title="All 2 branches missed.">        if (!validFontInfo) {</span>
<span class="nc" id="L820">            this.fontInfo = checkFontInfo(this.fontInfo, font, null);</span>
<span class="nc" id="L821">            validFontInfo = true;</span>
        }
<span class="nc" id="L823">        return this.fontInfo;</span>
    }

    /* Used by drawGlyphVector which specifies its own font. */
    public FontInfo getGVFontInfo(Font font, FontRenderContext frc) {
<span class="nc bnc" id="L828" title="All 6 branches missed.">        if (glyphVectorFontInfo != null &amp;&amp;</span>
            glyphVectorFontInfo.font == font &amp;&amp;
            glyphVectorFRC == frc) {
<span class="nc" id="L831">            return glyphVectorFontInfo;</span>
        } else {
<span class="nc" id="L833">            glyphVectorFRC = frc;</span>
<span class="nc" id="L834">            return glyphVectorFontInfo =</span>
<span class="nc" id="L835">                checkFontInfo(glyphVectorFontInfo, font, frc);</span>
        }
    }

    public FontMetrics getFontMetrics() {
<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (this.fontMetrics != null) {</span>
<span class="nc" id="L841">            return this.fontMetrics;</span>
        }
        /* NB the constructor and the setter disallow &quot;font&quot; being null */
<span class="nc" id="L844">        return this.fontMetrics =</span>
<span class="nc" id="L845">           FontDesignMetrics.getMetrics(font, getFontRenderContext());</span>
    }

    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L849" title="All 4 branches missed.">        if ((this.fontMetrics != null) &amp;&amp; (font == this.font)) {</span>
<span class="nc" id="L850">            return this.fontMetrics;</span>
        }
<span class="nc" id="L852">        FontMetrics fm =</span>
<span class="nc" id="L853">          FontDesignMetrics.getMetrics(font, getFontRenderContext());</span>

<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (this.font == font) {</span>
<span class="nc" id="L856">            this.fontMetrics = fm;</span>
        }
<span class="nc" id="L858">        return fm;</span>
    }

    /**
     * Checks to see if a Path intersects the specified Rectangle in device
     * space.  The rendering attributes taken into account include the
     * clip, transform, and stroke attributes.
     * @param rect The area in device space to check for a hit.
     * @param p The path to check for a hit.
     * @param onStroke Flag to choose between testing the stroked or
     * the filled path.
     * @return True if there is a hit, false otherwise.
     * @see #setStroke
     * @see #fillPath
     * @see #drawPath
     * @see #transform
     * @see #setTransform
     * @see #clip
     * @see #setClip
     */
    public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (onStroke) {</span>
<span class="nc" id="L880">            s = stroke.createStrokedShape(s);</span>
        }

<span class="nc" id="L883">        s = transformShape(s);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if ((constrainX|constrainY) != 0) {</span>
<span class="nc" id="L885">            rect = new Rectangle(rect);</span>
<span class="nc" id="L886">            rect.translate(constrainX, constrainY);</span>
        }

<span class="nc" id="L889">        return s.intersects(rect);</span>
    }

    /**
     * Return the ColorModel associated with this Graphics2D.
     */
    public ColorModel getDeviceColorModel() {
<span class="nc" id="L896">        return surfaceData.getColorModel();</span>
    }

    /**
     * Return the device configuration associated with this Graphics2D.
     */
    public GraphicsConfiguration getDeviceConfiguration() {
<span class="nc" id="L903">        return surfaceData.getDeviceConfiguration();</span>
    }

    /**
     * Return the SurfaceData object assigned to manage the destination
     * drawable surface of this Graphics2D.
     */
    public final SurfaceData getSurfaceData() {
<span class="nc" id="L911">        return surfaceData;</span>
    }

    /**
     * Sets the Composite in the current graphics state. Composite is used
     * in all drawing methods such as drawImage, drawString, drawPath,
     * and fillPath.  It specifies how new pixels are to be combined with
     * the existing pixels on the graphics device in the rendering process.
     * @param comp The Composite object to be used for drawing.
     * @see java.awt.Graphics#setXORMode
     * @see java.awt.Graphics#setPaintMode
     * @see AlphaComposite
     */
    public void setComposite(Composite comp) {
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (composite == comp) {</span>
<span class="nc" id="L926">            return;</span>
        }
        int newCompState;
        CompositeType newCompType;
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (comp instanceof AlphaComposite) {</span>
<span class="nc" id="L931">            AlphaComposite alphacomp = (AlphaComposite) comp;</span>
<span class="nc" id="L932">            newCompType = CompositeType.forAlphaComposite(alphacomp);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (newCompType == CompositeType.SrcOverNoEa) {</span>
<span class="nc bnc" id="L934" title="All 4 branches missed.">                if (paintState == PAINT_OPAQUECOLOR ||</span>
                    (paintState &gt; PAINT_ALPHACOLOR &amp;&amp;
<span class="nc bnc" id="L936" title="All 2 branches missed.">                     paint.getTransparency() == Transparency.OPAQUE))</span>
                {
<span class="nc" id="L938">                    newCompState = COMP_ISCOPY;</span>
                } else {
<span class="nc" id="L940">                    newCompState = COMP_ALPHA;</span>
                }
<span class="nc bnc" id="L942" title="All 6 branches missed.">            } else if (newCompType == CompositeType.SrcNoEa ||</span>
                       newCompType == CompositeType.Src ||
                       newCompType == CompositeType.Clear)
            {
<span class="nc" id="L946">                newCompState = COMP_ISCOPY;</span>
<span class="nc bnc" id="L947" title="All 4 branches missed.">            } else if (surfaceData.getTransparency() == Transparency.OPAQUE &amp;&amp;</span>
                       newCompType == CompositeType.SrcIn)
            {
<span class="nc" id="L950">                newCompState = COMP_ISCOPY;</span>
            } else {
<span class="nc" id="L952">                newCompState = COMP_ALPHA;</span>
            }
<span class="nc bnc" id="L954" title="All 2 branches missed.">        } else if (comp instanceof XORComposite) {</span>
<span class="nc" id="L955">            newCompState = COMP_XOR;</span>
<span class="nc" id="L956">            newCompType = CompositeType.Xor;</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">        } else if (comp == null) {</span>
<span class="nc" id="L958">            throw new IllegalArgumentException(&quot;null Composite&quot;);</span>
        } else {
<span class="nc" id="L960">            surfaceData.checkCustomComposite();</span>
<span class="nc" id="L961">            newCompState = COMP_CUSTOM;</span>
<span class="nc" id="L962">            newCompType = CompositeType.General;</span>
        }
<span class="nc bnc" id="L964" title="All 4 branches missed.">        if (compositeState != newCompState ||</span>
            imageComp != newCompType)
        {
<span class="nc" id="L967">            compositeState = newCompState;</span>
<span class="nc" id="L968">            imageComp = newCompType;</span>
<span class="nc" id="L969">            invalidatePipe();</span>
<span class="nc" id="L970">            validFontInfo = false;</span>
        }
<span class="nc" id="L972">        composite = comp;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        if (paintState &lt;= PAINT_ALPHACOLOR) {</span>
<span class="nc" id="L974">            validateColor();</span>
        }
<span class="nc" id="L976">    }</span>

    /**
     * Sets the Paint in the current graphics state.
     * @param paint The Paint object to be used to generate color in
     * the rendering process.
     * @see java.awt.Graphics#setColor
     * @see GradientPaint
     * @see TexturePaint
     */
    public void setPaint(Paint paint) {
<span class="nc bnc" id="L987" title="All 2 branches missed.">        if (paint instanceof Color) {</span>
<span class="nc" id="L988">            setColor((Color) paint);</span>
<span class="nc" id="L989">            return;</span>
        }
<span class="nc bnc" id="L991" title="All 4 branches missed.">        if (paint == null || this.paint == paint) {</span>
<span class="nc" id="L992">            return;</span>
        }
<span class="nc" id="L994">        this.paint = paint;</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (imageComp == CompositeType.SrcOverNoEa) {</span>
            // special case where compState depends on opacity of paint
<span class="nc bnc" id="L997" title="All 2 branches missed.">            if (paint.getTransparency() == Transparency.OPAQUE) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                if (compositeState != COMP_ISCOPY) {</span>
<span class="nc" id="L999">                    compositeState = COMP_ISCOPY;</span>
                }
            } else {
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                if (compositeState == COMP_ISCOPY) {</span>
<span class="nc" id="L1003">                    compositeState = COMP_ALPHA;</span>
                }
            }
        }
<span class="nc" id="L1007">        Class&lt;? extends Paint&gt; paintClass = paint.getClass();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (paintClass == GradientPaint.class) {</span>
<span class="nc" id="L1009">            paintState = PAINT_GRADIENT;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        } else if (paintClass == LinearGradientPaint.class) {</span>
<span class="nc" id="L1011">            paintState = PAINT_LIN_GRADIENT;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        } else if (paintClass == RadialGradientPaint.class) {</span>
<span class="nc" id="L1013">            paintState = PAINT_RAD_GRADIENT;</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">        } else if (paintClass == TexturePaint.class) {</span>
<span class="nc" id="L1015">            paintState = PAINT_TEXTURE;</span>
        } else {
<span class="nc" id="L1017">            paintState = PAINT_CUSTOM;</span>
        }
<span class="nc" id="L1019">        validFontInfo = false;</span>
<span class="nc" id="L1020">        invalidatePipe();</span>
<span class="nc" id="L1021">    }</span>

    static final int NON_UNIFORM_SCALE_MASK =
        (AffineTransform.TYPE_GENERAL_TRANSFORM |
         AffineTransform.TYPE_GENERAL_SCALE);
    public static final double MinPenSizeAA =
<span class="nc" id="L1027">        sun.java2d.pipe.RenderingEngine.getInstance().getMinimumAAPenSize();</span>
<span class="nc" id="L1028">    public static final double MinPenSizeAASquared =</span>
        (MinPenSizeAA * MinPenSizeAA);
    // Since inaccuracies in the trig package can cause us to
    // calculated a rotated pen width of just slightly greater
    // than 1.0, we add a fudge factor to our comparison value
    // here so that we do not misclassify single width lines as
    // wide lines under certain rotations.
    public static final double MinPenSizeSquared = 1.000000001;

    private void validateBasicStroke(BasicStroke bs) {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        boolean aa = (antialiasHint == SunHints.INTVAL_ANTIALIAS_ON);</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (transformState &lt; TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">            if (aa) {</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">                if (bs.getLineWidth() &lt;= MinPenSizeAA) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                    if (bs.getDashArray() == null) {</span>
<span class="nc" id="L1043">                        strokeState = STROKE_THIN;</span>
                    } else {
<span class="nc" id="L1045">                        strokeState = STROKE_THINDASHED;</span>
                    }
                } else {
<span class="nc" id="L1048">                    strokeState = STROKE_WIDE;</span>
                }
            } else {
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                if (bs == defaultStroke) {</span>
<span class="nc" id="L1052">                    strokeState = STROKE_THIN;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                } else if (bs.getLineWidth() &lt;= 1.0f) {</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                    if (bs.getDashArray() == null) {</span>
<span class="nc" id="L1055">                        strokeState = STROKE_THIN;</span>
                    } else {
<span class="nc" id="L1057">                        strokeState = STROKE_THINDASHED;</span>
                    }
                } else {
<span class="nc" id="L1060">                    strokeState = STROKE_WIDE;</span>
                }
            }
        } else {
            double widthsquared;
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if ((transform.getType() &amp; NON_UNIFORM_SCALE_MASK) == 0) {</span>
                /* sqrt omitted, compare to squared limits below. */
<span class="nc" id="L1067">                widthsquared = Math.abs(transform.getDeterminant());</span>
            } else {
                /* First calculate the &quot;maximum scale&quot; of this transform. */
<span class="nc" id="L1070">                double A = transform.getScaleX();       // m00</span>
<span class="nc" id="L1071">                double C = transform.getShearX();       // m01</span>
<span class="nc" id="L1072">                double B = transform.getShearY();       // m10</span>
<span class="nc" id="L1073">                double D = transform.getScaleY();       // m11</span>

                /*
                 * Given a 2 x 2 affine matrix [ A B ] such that
                 *                             [ C D ]
                 * v' = [x' y'] = [Ax + Cy, Bx + Dy], we want to
                 * find the maximum magnitude (norm) of the vector v'
                 * with the constraint (x^2 + y^2 = 1).
                 * The equation to maximize is
                 *     |v'| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
                 * or  |v'| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
                 * Since sqrt is monotonic we can maximize |v'|^2
                 * instead and plug in the substitution y = sqrt(1 - x^2).
                 * Trigonometric equalities can then be used to get
                 * rid of most of the sqrt terms.
                 */
<span class="nc" id="L1089">                double EA = A*A + B*B;          // x^2 coefficient</span>
<span class="nc" id="L1090">                double EB = 2*(A*C + B*D);      // xy coefficient</span>
<span class="nc" id="L1091">                double EC = C*C + D*D;          // y^2 coefficient</span>

                /*
                 * There is a lot of calculus omitted here.
                 *
                 * Conceptually, in the interests of understanding the
                 * terms that the calculus produced we can consider
                 * that EA and EC end up providing the lengths along
                 * the major axes and the hypot term ends up being an
                 * adjustment for the additional length along the off-axis
                 * angle of rotated or sheared ellipses as well as an
                 * adjustment for the fact that the equation below
                 * averages the two major axis lengths.  (Notice that
                 * the hypot term contains a part which resolves to the
                 * difference of these two axis lengths in the absence
                 * of rotation.)
                 *
                 * In the calculus, the ratio of the EB and (EA-EC) terms
                 * ends up being the tangent of 2*theta where theta is
                 * the angle that the long axis of the ellipse makes
                 * with the horizontal axis.  Thus, this equation is
                 * calculating the length of the hypotenuse of a triangle
                 * along that axis.
                 */
<span class="nc" id="L1115">                double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));</span>

                /* sqrt omitted, compare to squared limits below. */
<span class="nc" id="L1118">                widthsquared = ((EA + EC + hypot)/2.0);</span>
            }
<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (bs != defaultStroke) {</span>
<span class="nc" id="L1121">                widthsquared *= bs.getLineWidth() * bs.getLineWidth();</span>
            }
<span class="nc bnc" id="L1123" title="All 4 branches missed.">            if (widthsquared &lt;=</span>
                (aa ? MinPenSizeAASquared : MinPenSizeSquared))
            {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                if (bs.getDashArray() == null) {</span>
<span class="nc" id="L1127">                    strokeState = STROKE_THIN;</span>
                } else {
<span class="nc" id="L1129">                    strokeState = STROKE_THINDASHED;</span>
                }
            } else {
<span class="nc" id="L1132">                strokeState = STROKE_WIDE;</span>
            }
        }
<span class="nc" id="L1135">    }</span>

    /*
     * Sets the Stroke in the current graphics state.
     * @param s The Stroke object to be used to stroke a Path in
     * the rendering process.
     * @see BasicStroke
     */
    public void setStroke(Stroke s) {
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1145">            throw new IllegalArgumentException(&quot;null Stroke&quot;);</span>
        }
<span class="nc" id="L1147">        int saveStrokeState = strokeState;</span>
<span class="nc" id="L1148">        stroke = s;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">        if (s instanceof BasicStroke) {</span>
<span class="nc" id="L1150">            validateBasicStroke((BasicStroke) s);</span>
        } else {
<span class="nc" id="L1152">            strokeState = STROKE_CUSTOM;</span>
        }
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (strokeState != saveStrokeState) {</span>
<span class="nc" id="L1155">            invalidatePipe();</span>
        }
<span class="nc" id="L1157">    }</span>

    /**
     * Sets the preferences for the rendering algorithms.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * @param hintKey The key of hint to be set. The strings are
     * defined in the RenderingHints class.
     * @param hintValue The value indicating preferences for the specified
     * hint category. These strings are defined in the RenderingHints
     * class.
     * @see RenderingHints
     */
    public void setRenderingHint(Key hintKey, Object hintValue) {
        // If we recognize the key, we must recognize the value
        //     otherwise throw an IllegalArgumentException
        //     and do not change the Hints object
        // If we do not recognize the key, just pass it through
        //     to the Hints object untouched
<span class="nc bnc" id="L1176" title="All 2 branches missed.">        if (!hintKey.isCompatibleValue(hintValue)) {</span>
<span class="nc" id="L1177">            throw new IllegalArgumentException</span>
                (hintValue+&quot; is not compatible with &quot;+hintKey);
        }
<span class="nc bnc" id="L1180" title="All 2 branches missed.">        if (hintKey instanceof SunHints.Key) {</span>
            boolean stateChanged;
<span class="nc" id="L1182">            boolean textStateChanged = false;</span>
<span class="nc" id="L1183">            boolean recognized = true;</span>
<span class="nc" id="L1184">            SunHints.Key sunKey = (SunHints.Key) hintKey;</span>
            int newHint;
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (sunKey == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST) {</span>
<span class="nc" id="L1187">                newHint = ((Integer)hintValue).intValue();</span>
            } else {
<span class="nc" id="L1189">                newHint = ((SunHints.Value) hintValue).getIndex();</span>
            }
<span class="nc bnc" id="L1191" title="All 8 branches missed.">            switch (sunKey.getIndex()) {</span>
            case SunHints.INTKEY_RENDERING:
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                stateChanged = (renderHint != newHint);</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                if (stateChanged) {</span>
<span class="nc" id="L1195">                    renderHint = newHint;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">                    if (interpolationHint == -1) {</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                        interpolationType =</span>
                            (newHint == SunHints.INTVAL_RENDER_QUALITY
                             ? AffineTransformOp.TYPE_BILINEAR
                             : AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
                    }
                }
                break;
            case SunHints.INTKEY_ANTIALIASING:
<span class="nc bnc" id="L1205" title="All 2 branches missed.">                stateChanged = (antialiasHint != newHint);</span>
<span class="nc" id="L1206">                antialiasHint = newHint;</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                if (stateChanged) {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                    textStateChanged =</span>
                        (textAntialiasHint ==
                         SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT);
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                    if (strokeState != STROKE_CUSTOM) {</span>
<span class="nc" id="L1212">                        validateBasicStroke((BasicStroke) stroke);</span>
                    }
                }
                break;
            case SunHints.INTKEY_TEXT_ANTIALIASING:
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                stateChanged = (textAntialiasHint != newHint);</span>
<span class="nc" id="L1218">                textStateChanged = stateChanged;</span>
<span class="nc" id="L1219">                textAntialiasHint = newHint;</span>
<span class="nc" id="L1220">                break;</span>
            case SunHints.INTKEY_FRACTIONALMETRICS:
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                stateChanged = (fractionalMetricsHint != newHint);</span>
<span class="nc" id="L1223">                textStateChanged = stateChanged;</span>
<span class="nc" id="L1224">                fractionalMetricsHint = newHint;</span>
<span class="nc" id="L1225">                break;</span>
            case SunHints.INTKEY_AATEXT_LCD_CONTRAST:
<span class="nc" id="L1227">                stateChanged = false;</span>
                /* Already have validated it is an int 100 &lt;= newHint &lt;= 250 */
<span class="nc" id="L1229">                lcdTextContrast = newHint;</span>
<span class="nc" id="L1230">                break;</span>
            case SunHints.INTKEY_INTERPOLATION:
<span class="nc" id="L1232">                interpolationHint = newHint;</span>
<span class="nc bnc" id="L1233" title="All 3 branches missed.">                switch (newHint) {</span>
                case SunHints.INTVAL_INTERPOLATION_BICUBIC:
<span class="nc" id="L1235">                    newHint = AffineTransformOp.TYPE_BICUBIC;</span>
<span class="nc" id="L1236">                    break;</span>
                case SunHints.INTVAL_INTERPOLATION_BILINEAR:
<span class="nc" id="L1238">                    newHint = AffineTransformOp.TYPE_BILINEAR;</span>
<span class="nc" id="L1239">                    break;</span>
                default:
                case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
<span class="nc" id="L1242">                    newHint = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;</span>
                    break;
                }
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                stateChanged = (interpolationType != newHint);</span>
<span class="nc" id="L1246">                interpolationType = newHint;</span>
<span class="nc" id="L1247">                break;</span>
            case SunHints.INTKEY_STROKE_CONTROL:
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                stateChanged = (strokeHint != newHint);</span>
<span class="nc" id="L1250">                strokeHint = newHint;</span>
<span class="nc" id="L1251">                break;</span>
            default:
<span class="nc" id="L1253">                recognized = false;</span>
<span class="nc" id="L1254">                stateChanged = false;</span>
                break;
            }
<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (recognized) {</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                if (stateChanged) {</span>
<span class="nc" id="L1259">                    invalidatePipe();</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                    if (textStateChanged) {</span>
<span class="nc" id="L1261">                        fontMetrics = null;</span>
<span class="nc" id="L1262">                        this.cachedFRC = null;</span>
<span class="nc" id="L1263">                        validFontInfo = false;</span>
<span class="nc" id="L1264">                        this.glyphVectorFontInfo = null;</span>
                    }
                }
<span class="nc bnc" id="L1267" title="All 2 branches missed.">                if (hints != null) {</span>
<span class="nc" id="L1268">                    hints.put(hintKey, hintValue);</span>
                }
<span class="nc" id="L1270">                return;</span>
            }
        }
        // Nothing we recognize so none of &quot;our state&quot; has changed
<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (hints == null) {</span>
<span class="nc" id="L1275">            hints = makeHints(null);</span>
        }
<span class="nc" id="L1277">        hints.put(hintKey, hintValue);</span>
<span class="nc" id="L1278">    }</span>


    /**
     * Returns the preferences for the rendering algorithms.
     * @param hintCategory The category of hint to be set. The strings
     * are defined in the RenderingHints class.
     * @return The preferences for rendering algorithms. The strings
     * are defined in the RenderingHints class.
     * @see RenderingHints
     */
    public Object getRenderingHint(Key hintKey) {
<span class="nc bnc" id="L1290" title="All 2 branches missed.">        if (hints != null) {</span>
<span class="nc" id="L1291">            return hints.get(hintKey);</span>
        }
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (!(hintKey instanceof SunHints.Key)) {</span>
<span class="nc" id="L1294">            return null;</span>
        }
<span class="nc" id="L1296">        int keyindex = ((SunHints.Key)hintKey).getIndex();</span>
<span class="nc bnc" id="L1297" title="All 8 branches missed.">        switch (keyindex) {</span>
        case SunHints.INTKEY_RENDERING:
<span class="nc" id="L1299">            return SunHints.Value.get(SunHints.INTKEY_RENDERING,</span>
                                      renderHint);
        case SunHints.INTKEY_ANTIALIASING:
<span class="nc" id="L1302">            return SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,</span>
                                      antialiasHint);
        case SunHints.INTKEY_TEXT_ANTIALIASING:
<span class="nc" id="L1305">            return SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,</span>
                                      textAntialiasHint);
        case SunHints.INTKEY_FRACTIONALMETRICS:
<span class="nc" id="L1308">            return SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,</span>
                                      fractionalMetricsHint);
        case SunHints.INTKEY_AATEXT_LCD_CONTRAST:
<span class="nc" id="L1311">            return new Integer(lcdTextContrast);</span>
        case SunHints.INTKEY_INTERPOLATION:
<span class="nc bnc" id="L1313" title="All 4 branches missed.">            switch (interpolationHint) {</span>
            case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
<span class="nc" id="L1315">                return SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;</span>
            case SunHints.INTVAL_INTERPOLATION_BILINEAR:
<span class="nc" id="L1317">                return SunHints.VALUE_INTERPOLATION_BILINEAR;</span>
            case SunHints.INTVAL_INTERPOLATION_BICUBIC:
<span class="nc" id="L1319">                return SunHints.VALUE_INTERPOLATION_BICUBIC;</span>
            }
<span class="nc" id="L1321">            return null;</span>
        case SunHints.INTKEY_STROKE_CONTROL:
<span class="nc" id="L1323">            return SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,</span>
                                      strokeHint);
        }
<span class="nc" id="L1326">        return null;</span>
    }

    /**
     * Sets the preferences for the rendering algorithms.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * @param hints The rendering hints to be set
     * @see RenderingHints
     */
    public void setRenderingHints(Map&lt;?,?&gt; hints) {
<span class="nc" id="L1337">        this.hints = null;</span>
<span class="nc" id="L1338">        renderHint = SunHints.INTVAL_RENDER_DEFAULT;</span>
<span class="nc" id="L1339">        antialiasHint = SunHints.INTVAL_ANTIALIAS_OFF;</span>
<span class="nc" id="L1340">        textAntialiasHint = SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT;</span>
<span class="nc" id="L1341">        fractionalMetricsHint = SunHints.INTVAL_FRACTIONALMETRICS_OFF;</span>
<span class="nc" id="L1342">        lcdTextContrast = lcdTextContrastDefaultValue;</span>
<span class="nc" id="L1343">        interpolationHint = -1;</span>
<span class="nc" id="L1344">        interpolationType = AffineTransformOp.TYPE_NEAREST_NEIGHBOR;</span>
<span class="nc" id="L1345">        boolean customHintPresent = false;</span>
<span class="nc" id="L1346">        Iterator&lt;?&gt; iter = hints.keySet().iterator();</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1348">            Object key = iter.next();</span>
<span class="nc bnc" id="L1349" title="All 14 branches missed.">            if (key == SunHints.KEY_RENDERING ||</span>
                key == SunHints.KEY_ANTIALIASING ||
                key == SunHints.KEY_TEXT_ANTIALIASING ||
                key == SunHints.KEY_FRACTIONALMETRICS ||
                key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
                key == SunHints.KEY_STROKE_CONTROL ||
                key == SunHints.KEY_INTERPOLATION)
            {
<span class="nc" id="L1357">                setRenderingHint((Key) key, hints.get(key));</span>
            } else {
<span class="nc" id="L1359">                customHintPresent = true;</span>
            }
<span class="nc" id="L1361">        }</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (customHintPresent) {</span>
<span class="nc" id="L1363">            this.hints = makeHints(hints);</span>
        }
<span class="nc" id="L1365">        invalidatePipe();</span>
<span class="nc" id="L1366">    }</span>

    /**
     * Adds a number of preferences for the rendering algorithms.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * @param hints The rendering hints to be set
     * @see RenderingHints
     */
    public void addRenderingHints(Map&lt;?,?&gt; hints) {
<span class="nc" id="L1376">        boolean customHintPresent = false;</span>
<span class="nc" id="L1377">        Iterator&lt;?&gt; iter = hints.keySet().iterator();</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L1379">            Object key = iter.next();</span>
<span class="nc bnc" id="L1380" title="All 14 branches missed.">            if (key == SunHints.KEY_RENDERING ||</span>
                key == SunHints.KEY_ANTIALIASING ||
                key == SunHints.KEY_TEXT_ANTIALIASING ||
                key == SunHints.KEY_FRACTIONALMETRICS ||
                key == SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST ||
                key == SunHints.KEY_STROKE_CONTROL ||
                key == SunHints.KEY_INTERPOLATION)
            {
<span class="nc" id="L1388">                setRenderingHint((Key) key, hints.get(key));</span>
            } else {
<span class="nc" id="L1390">                customHintPresent = true;</span>
            }
<span class="nc" id="L1392">        }</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">        if (customHintPresent) {</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">            if (this.hints == null) {</span>
<span class="nc" id="L1395">                this.hints = makeHints(hints);</span>
            } else {
<span class="nc" id="L1397">                this.hints.putAll(hints);</span>
            }
        }
<span class="nc" id="L1400">    }</span>

    /**
     * Gets the preferences for the rendering algorithms.
     * Hint categories include controls for rendering quality and
     * overall time/quality trade-off in the rendering process.
     * @see RenderingHints
     */
    public RenderingHints getRenderingHints() {
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (hints == null) {</span>
<span class="nc" id="L1410">            return makeHints(null);</span>
        } else {
<span class="nc" id="L1412">            return (RenderingHints) hints.clone();</span>
        }
    }

    RenderingHints makeHints(Map hints) {
<span class="nc" id="L1417">        RenderingHints model = new RenderingHints(hints);</span>
<span class="nc" id="L1418">        model.put(SunHints.KEY_RENDERING,</span>
<span class="nc" id="L1419">                  SunHints.Value.get(SunHints.INTKEY_RENDERING,</span>
                                     renderHint));
<span class="nc" id="L1421">        model.put(SunHints.KEY_ANTIALIASING,</span>
<span class="nc" id="L1422">                  SunHints.Value.get(SunHints.INTKEY_ANTIALIASING,</span>
                                     antialiasHint));
<span class="nc" id="L1424">        model.put(SunHints.KEY_TEXT_ANTIALIASING,</span>
<span class="nc" id="L1425">                  SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING,</span>
                                     textAntialiasHint));
<span class="nc" id="L1427">        model.put(SunHints.KEY_FRACTIONALMETRICS,</span>
<span class="nc" id="L1428">                  SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,</span>
                                     fractionalMetricsHint));
<span class="nc" id="L1430">        model.put(SunHints.KEY_TEXT_ANTIALIAS_LCD_CONTRAST,</span>
<span class="nc" id="L1431">                  Integer.valueOf(lcdTextContrast));</span>
        Object value;
<span class="nc bnc" id="L1433" title="All 4 branches missed.">        switch (interpolationHint) {</span>
        case SunHints.INTVAL_INTERPOLATION_NEAREST_NEIGHBOR:
<span class="nc" id="L1435">            value = SunHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;</span>
<span class="nc" id="L1436">            break;</span>
        case SunHints.INTVAL_INTERPOLATION_BILINEAR:
<span class="nc" id="L1438">            value = SunHints.VALUE_INTERPOLATION_BILINEAR;</span>
<span class="nc" id="L1439">            break;</span>
        case SunHints.INTVAL_INTERPOLATION_BICUBIC:
<span class="nc" id="L1441">            value = SunHints.VALUE_INTERPOLATION_BICUBIC;</span>
<span class="nc" id="L1442">            break;</span>
        default:
<span class="nc" id="L1444">            value = null;</span>
            break;
        }
<span class="nc bnc" id="L1447" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1448">            model.put(SunHints.KEY_INTERPOLATION, value);</span>
        }
<span class="nc" id="L1450">        model.put(SunHints.KEY_STROKE_CONTROL,</span>
<span class="nc" id="L1451">                  SunHints.Value.get(SunHints.INTKEY_STROKE_CONTROL,</span>
                                     strokeHint));
<span class="nc" id="L1453">        return model;</span>
    }

    /**
     * Concatenates the current transform of this Graphics2D with a
     * translation transformation.
     * This is equivalent to calling transform(T), where T is an
     * AffineTransform represented by the following matrix:
     * &lt;pre&gt;
     *          [   1    0    tx  ]
     *          [   0    1    ty  ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     */
    public void translate(double tx, double ty) {
<span class="nc" id="L1468">        transform.translate(tx, ty);</span>
<span class="nc" id="L1469">        invalidateTransform();</span>
<span class="nc" id="L1470">    }</span>

    /**
     * Concatenates the current transform of this Graphics2D with a
     * rotation transformation.
     * This is equivalent to calling transform(R), where R is an
     * AffineTransform represented by the following matrix:
     * &lt;pre&gt;
     *          [   cos(theta)    -sin(theta)    0   ]
     *          [   sin(theta)     cos(theta)    0   ]
     *          [       0              0         1   ]
     * &lt;/pre&gt;
     * Rotating with a positive angle theta rotates points on the positive
     * x axis toward the positive y axis.
     * @param theta The angle of rotation in radians.
     */
    public void rotate(double theta) {
<span class="nc" id="L1487">        transform.rotate(theta);</span>
<span class="nc" id="L1488">        invalidateTransform();</span>
<span class="nc" id="L1489">    }</span>

    /**
     * Concatenates the current transform of this Graphics2D with a
     * translated rotation transformation.
     * This is equivalent to the following sequence of calls:
     * &lt;pre&gt;
     *          translate(x, y);
     *          rotate(theta);
     *          translate(-x, -y);
     * &lt;/pre&gt;
     * Rotating with a positive angle theta rotates points on the positive
     * x axis toward the positive y axis.
     * @param theta The angle of rotation in radians.
     * @param x The x coordinate of the origin of the rotation
     * @param y The x coordinate of the origin of the rotation
     */
    public void rotate(double theta, double x, double y) {
<span class="nc" id="L1507">        transform.rotate(theta, x, y);</span>
<span class="nc" id="L1508">        invalidateTransform();</span>
<span class="nc" id="L1509">    }</span>

    /**
     * Concatenates the current transform of this Graphics2D with a
     * scaling transformation.
     * This is equivalent to calling transform(S), where S is an
     * AffineTransform represented by the following matrix:
     * &lt;pre&gt;
     *          [   sx   0    0   ]
     *          [   0    sy   0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     */
    public void scale(double sx, double sy) {
<span class="nc" id="L1523">        transform.scale(sx, sy);</span>
<span class="nc" id="L1524">        invalidateTransform();</span>
<span class="nc" id="L1525">    }</span>

    /**
     * Concatenates the current transform of this Graphics2D with a
     * shearing transformation.
     * This is equivalent to calling transform(SH), where SH is an
     * AffineTransform represented by the following matrix:
     * &lt;pre&gt;
     *          [   1   shx   0   ]
     *          [  shy   1    0   ]
     *          [   0    0    1   ]
     * &lt;/pre&gt;
     * @param shx The factor by which coordinates are shifted towards the
     * positive X axis direction according to their Y coordinate
     * @param shy The factor by which coordinates are shifted towards the
     * positive Y axis direction according to their X coordinate
     */
    public void shear(double shx, double shy) {
<span class="nc" id="L1543">        transform.shear(shx, shy);</span>
<span class="nc" id="L1544">        invalidateTransform();</span>
<span class="nc" id="L1545">    }</span>

    /**
     * Composes a Transform object with the transform in this
     * Graphics2D according to the rule last-specified-first-applied.
     * If the currrent transform is Cx, the result of composition
     * with Tx is a new transform Cx'.  Cx' becomes the current
     * transform for this Graphics2D.
     * Transforming a point p by the updated transform Cx' is
     * equivalent to first transforming p by Tx and then transforming
     * the result by the original transform Cx.  In other words,
     * Cx'(p) = Cx(Tx(p)).
     * A copy of the Tx is made, if necessary, so further
     * modifications to Tx do not affect rendering.
     * @param Tx The Transform object to be composed with the current
     * transform.
     * @see #setTransform
     * @see AffineTransform
     */
    public void transform(AffineTransform xform) {
<span class="nc" id="L1565">        this.transform.concatenate(xform);</span>
<span class="nc" id="L1566">        invalidateTransform();</span>
<span class="nc" id="L1567">    }</span>

    /**
     * Translate
     */
    public void translate(int x, int y) {
<span class="nc" id="L1573">        transform.translate(x, y);</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">        if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {</span>
<span class="nc" id="L1575">            transX += x;</span>
<span class="nc" id="L1576">            transY += y;</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">            transformState = (((transX | transY) == 0) ?</span>
                              TRANSFORM_ISIDENT : TRANSFORM_INT_TRANSLATE);
        } else {
<span class="nc" id="L1580">            invalidateTransform();</span>
        }
<span class="nc" id="L1582">    }</span>

    /**
     * Sets the Transform in the current graphics state.
     * @param Tx The Transform object to be used in the rendering process.
     * @see #transform
     * @see TransformChain
     * @see AffineTransform
     */
    @Override
    public void setTransform(AffineTransform Tx) {
<span class="nc bnc" id="L1593" title="All 4 branches missed.">        if ((constrainX | constrainY) == 0 &amp;&amp; devScale == 1) {</span>
<span class="nc" id="L1594">            transform.setTransform(Tx);</span>
        } else {
<span class="nc" id="L1596">            transform.setTransform(devScale, 0, 0, devScale, constrainX,</span>
                                   constrainY);
<span class="nc" id="L1598">            transform.concatenate(Tx);</span>
        }
<span class="nc" id="L1600">        invalidateTransform();</span>
<span class="nc" id="L1601">    }</span>

    protected void invalidateTransform() {
<span class="nc" id="L1604">        int type = transform.getType();</span>
<span class="nc" id="L1605">        int origTransformState = transformState;</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">        if (type == AffineTransform.TYPE_IDENTITY) {</span>
<span class="nc" id="L1607">            transformState = TRANSFORM_ISIDENT;</span>
<span class="nc" id="L1608">            transX = transY = 0;</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">        } else if (type == AffineTransform.TYPE_TRANSLATION) {</span>
<span class="nc" id="L1610">            double dtx = transform.getTranslateX();</span>
<span class="nc" id="L1611">            double dty = transform.getTranslateY();</span>
<span class="nc" id="L1612">            transX = (int) Math.floor(dtx + 0.5);</span>
<span class="nc" id="L1613">            transY = (int) Math.floor(dty + 0.5);</span>
<span class="nc bnc" id="L1614" title="All 4 branches missed.">            if (dtx == transX &amp;&amp; dty == transY) {</span>
<span class="nc" id="L1615">                transformState = TRANSFORM_INT_TRANSLATE;</span>
            } else {
<span class="nc" id="L1617">                transformState = TRANSFORM_ANY_TRANSLATE;</span>
            }
<span class="nc bnc" id="L1619" title="All 2 branches missed.">        } else if ((type &amp; (AffineTransform.TYPE_FLIP |</span>
                            AffineTransform.TYPE_MASK_ROTATION |
                            AffineTransform.TYPE_GENERAL_TRANSFORM)) == 0)
        {
<span class="nc" id="L1623">            transformState = TRANSFORM_TRANSLATESCALE;</span>
<span class="nc" id="L1624">            transX = transY = 0;</span>
        } else {
<span class="nc" id="L1626">            transformState = TRANSFORM_GENERIC;</span>
<span class="nc" id="L1627">            transX = transY = 0;</span>
        }

<span class="nc bnc" id="L1630" title="All 4 branches missed.">        if (transformState &gt;= TRANSFORM_TRANSLATESCALE ||</span>
            origTransformState &gt;= TRANSFORM_TRANSLATESCALE)
        {
            /* Its only in this case that the previous or current transform
             * was more than a translate that font info is invalidated
             */
<span class="nc" id="L1636">            cachedFRC = null;</span>
<span class="nc" id="L1637">            this.validFontInfo = false;</span>
<span class="nc" id="L1638">            this.fontMetrics = null;</span>
<span class="nc" id="L1639">            this.glyphVectorFontInfo = null;</span>

<span class="nc bnc" id="L1641" title="All 2 branches missed.">            if (transformState != origTransformState) {</span>
<span class="nc" id="L1642">                invalidatePipe();</span>
            }
        }
<span class="nc bnc" id="L1645" title="All 2 branches missed.">        if (strokeState != STROKE_CUSTOM) {</span>
<span class="nc" id="L1646">            validateBasicStroke((BasicStroke) stroke);</span>
        }
<span class="nc" id="L1648">    }</span>

    /**
     * Returns the current Transform in the Graphics2D state.
     * @see #transform
     * @see #setTransform
     */
    @Override
    public AffineTransform getTransform() {
<span class="nc bnc" id="L1657" title="All 4 branches missed.">        if ((constrainX | constrainY) == 0 &amp;&amp; devScale == 1) {</span>
<span class="nc" id="L1658">            return new AffineTransform(transform);</span>
        }
<span class="nc" id="L1660">        final double invScale = 1.0 / devScale;</span>
<span class="nc" id="L1661">        AffineTransform tx = new AffineTransform(invScale, 0, 0, invScale,</span>
                                                 -constrainX * invScale,
                                                 -constrainY * invScale);
<span class="nc" id="L1664">        tx.concatenate(transform);</span>
<span class="nc" id="L1665">        return tx;</span>
    }

    /**
     * Returns the current Transform ignoring the &quot;constrain&quot;
     * rectangle.
     */
    public AffineTransform cloneTransform() {
<span class="nc" id="L1673">        return new AffineTransform(transform);</span>
    }

    /**
     * Returns the current Paint in the Graphics2D state.
     * @see #setPaint
     * @see java.awt.Graphics#setColor
     */
    public Paint getPaint() {
<span class="nc" id="L1682">        return paint;</span>
    }

    /**
     * Returns the current Composite in the Graphics2D state.
     * @see #setComposite
     */
    public Composite getComposite() {
<span class="nc" id="L1690">        return composite;</span>
    }

    public Color getColor() {
<span class="nc" id="L1694">        return foregroundColor;</span>
    }

    /*
     * Validate the eargb and pixel fields against the current color.
     *
     * The eargb field must take into account the extraAlpha
     * value of an AlphaComposite.  It may also take into account
     * the Fsrc Porter-Duff blending function if such a function is
     * a constant (see handling of Clear mode below).  For instance,
     * by factoring in the (Fsrc == 0) state of the Clear mode we can
     * use a SrcNoEa loop just as easily as a general Alpha loop
     * since the math will be the same in both cases.
     *
     * The pixel field will always be the best pixel data choice for
     * the final result of all calculations applied to the eargb field.
     *
     * Note that this method is only necessary under the following
     * conditions:
     *     (paintState &lt;= PAINT_ALPHA_COLOR &amp;&amp;
     *      compositeState &lt;= COMP_CUSTOM)
     * though nothing bad will happen if it is run in other states.
     */
    final void validateColor() {
        int eargb;
<span class="nc bnc" id="L1719" title="All 2 branches missed.">        if (imageComp == CompositeType.Clear) {</span>
<span class="nc" id="L1720">            eargb = 0;</span>
        } else {
<span class="nc" id="L1722">            eargb = foregroundColor.getRGB();</span>
<span class="nc bnc" id="L1723" title="All 6 branches missed.">            if (compositeState &lt;= COMP_ALPHA &amp;&amp;</span>
                imageComp != CompositeType.SrcNoEa &amp;&amp;
                imageComp != CompositeType.SrcOverNoEa)
            {
<span class="nc" id="L1727">                AlphaComposite alphacomp = (AlphaComposite) composite;</span>
<span class="nc" id="L1728">                int a = Math.round(alphacomp.getAlpha() * (eargb &gt;&gt;&gt; 24));</span>
<span class="nc" id="L1729">                eargb = (eargb &amp; 0x00ffffff) | (a &lt;&lt; 24);</span>
            }
        }
<span class="nc" id="L1732">        this.eargb = eargb;</span>
<span class="nc" id="L1733">        this.pixel = surfaceData.pixelFor(eargb);</span>
<span class="nc" id="L1734">    }</span>

    public void setColor(Color color) {
<span class="nc bnc" id="L1737" title="All 4 branches missed.">        if (color == null || color == paint) {</span>
<span class="nc" id="L1738">            return;</span>
        }
<span class="nc" id="L1740">        this.paint = foregroundColor = color;</span>
<span class="nc" id="L1741">        validateColor();</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">        if ((eargb &gt;&gt; 24) == -1) {</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">            if (paintState == PAINT_OPAQUECOLOR) {</span>
<span class="nc" id="L1744">                return;</span>
            }
<span class="nc" id="L1746">            paintState = PAINT_OPAQUECOLOR;</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (imageComp == CompositeType.SrcOverNoEa) {</span>
                // special case where compState depends on opacity of paint
<span class="nc" id="L1749">                compositeState = COMP_ISCOPY;</span>
            }
        } else {
<span class="nc bnc" id="L1752" title="All 2 branches missed.">            if (paintState == PAINT_ALPHACOLOR) {</span>
<span class="nc" id="L1753">                return;</span>
            }
<span class="nc" id="L1755">            paintState = PAINT_ALPHACOLOR;</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">            if (imageComp == CompositeType.SrcOverNoEa) {</span>
                // special case where compState depends on opacity of paint
<span class="nc" id="L1758">                compositeState = COMP_ALPHA;</span>
            }
        }
<span class="nc" id="L1761">        validFontInfo = false;</span>
<span class="nc" id="L1762">        invalidatePipe();</span>
<span class="nc" id="L1763">    }</span>

    /**
     * Sets the background color in this context used for clearing a region.
     * When Graphics2D is constructed for a component, the backgroung color is
     * inherited from the component. Setting the background color in the
     * Graphics2D context only affects the subsequent clearRect() calls and
     * not the background color of the component. To change the background
     * of the component, use appropriate methods of the component.
     * @param color The background color that should be used in
     * subsequent calls to clearRect().
     * @see getBackground
     * @see Graphics.clearRect()
     */
    public void setBackground(Color color) {
<span class="nc" id="L1778">        backgroundColor = color;</span>
<span class="nc" id="L1779">    }</span>

    /**
     * Returns the background color used for clearing a region.
     * @see setBackground
     */
    public Color getBackground() {
<span class="nc" id="L1786">        return backgroundColor;</span>
    }

    /**
     * Returns the current Stroke in the Graphics2D state.
     * @see setStroke
     */
    public Stroke getStroke() {
<span class="nc" id="L1794">        return stroke;</span>
    }

    public Rectangle getClipBounds() {
<span class="nc bnc" id="L1798" title="All 2 branches missed.">        if (clipState == CLIP_DEVICE) {</span>
<span class="nc" id="L1799">            return null;</span>
        }
<span class="nc" id="L1801">        return getClipBounds(new Rectangle());</span>
    }

    public Rectangle getClipBounds(Rectangle r) {
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (clipState != CLIP_DEVICE) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            if (transformState &lt;= TRANSFORM_INT_TRANSLATE) {</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">                if (usrClip instanceof Rectangle) {</span>
<span class="nc" id="L1808">                    r.setBounds((Rectangle) usrClip);</span>
                } else {
<span class="nc" id="L1810">                    r.setFrame(usrClip.getBounds2D());</span>
                }
<span class="nc" id="L1812">                r.translate(-transX, -transY);</span>
            } else {
<span class="nc" id="L1814">                r.setFrame(getClip().getBounds2D());</span>
            }
<span class="nc bnc" id="L1816" title="All 2 branches missed.">        } else if (r == null) {</span>
<span class="nc" id="L1817">            throw new NullPointerException(&quot;null rectangle parameter&quot;);</span>
        }
<span class="nc" id="L1819">        return r;</span>
    }

    public boolean hitClip(int x, int y, int width, int height) {
<span class="nc bnc" id="L1823" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L1824">            return false;</span>
        }
<span class="nc bnc" id="L1826" title="All 2 branches missed.">        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {</span>
            // Note: Technically the most accurate test would be to
            // raster scan the parallelogram of the transformed rectangle
            // and do a span for span hit test against the clip, but for
            // speed we approximate the test with a bounding box of the
            // transformed rectangle.  The cost of rasterizing the
            // transformed rectangle is probably high enough that it is
            // not worth doing so to save the caller from having to call
            // a rendering method where we will end up discovering the
            // same answer in about the same amount of time anyway.
            // This logic breaks down if this hit test is being performed
            // on the bounds of a group of shapes in which case it might
            // be beneficial to be a little more accurate to avoid lots
            // of subsequent rendering calls.  In either case, this relaxed
            // test should not be significantly less accurate than the
            // optimal test for most transforms and so the conservative
            // answer should not cause too much extra work.

<span class="nc" id="L1844">            double d[] = {</span>
                x, y,
                x+width, y,
                x, y+height,
                x+width, y+height
            };
<span class="nc" id="L1850">            transform.transform(d, 0, d, 0, 4);</span>
<span class="nc" id="L1851">            x = (int) Math.floor(Math.min(Math.min(d[0], d[2]),</span>
<span class="nc" id="L1852">                                          Math.min(d[4], d[6])));</span>
<span class="nc" id="L1853">            y = (int) Math.floor(Math.min(Math.min(d[1], d[3]),</span>
<span class="nc" id="L1854">                                          Math.min(d[5], d[7])));</span>
<span class="nc" id="L1855">            width = (int) Math.ceil(Math.max(Math.max(d[0], d[2]),</span>
<span class="nc" id="L1856">                                             Math.max(d[4], d[6])));</span>
<span class="nc" id="L1857">            height = (int) Math.ceil(Math.max(Math.max(d[1], d[3]),</span>
<span class="nc" id="L1858">                                              Math.max(d[5], d[7])));</span>
<span class="nc" id="L1859">        } else {</span>
<span class="nc" id="L1860">            x += transX;</span>
<span class="nc" id="L1861">            y += transY;</span>
<span class="nc" id="L1862">            width += x;</span>
<span class="nc" id="L1863">            height += y;</span>
        }

        try {
<span class="nc bnc" id="L1867" title="All 2 branches missed.">            if (!getCompClip().intersectsQuickCheckXYXY(x, y, width, height)) {</span>
<span class="nc" id="L1868">                return false;</span>
            }
<span class="nc" id="L1870">        } catch (InvalidPipeException e) {</span>
<span class="nc" id="L1871">            return false;</span>
<span class="nc" id="L1872">        }</span>
        // REMIND: We could go one step further here and examine the
        // non-rectangular clip shape more closely if there is one.
        // Since the clip has already been rasterized, the performance
        // penalty of doing the scan is probably still within the bounds
        // of a good tradeoff between speed and quality of the answer.
<span class="nc" id="L1878">        return true;</span>
    }

    protected void validateCompClip() {
<span class="nc" id="L1882">        int origClipState = clipState;</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">        if (usrClip == null) {</span>
<span class="nc" id="L1884">            clipState = CLIP_DEVICE;</span>
<span class="nc" id="L1885">            clipRegion = devClip;</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">        } else if (usrClip instanceof Rectangle2D) {</span>
<span class="nc" id="L1887">            clipState = CLIP_RECTANGULAR;</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if (usrClip instanceof Rectangle) {</span>
<span class="nc" id="L1889">                clipRegion = devClip.getIntersection((Rectangle)usrClip);</span>
            } else {
<span class="nc" id="L1891">                clipRegion = devClip.getIntersection(usrClip.getBounds());</span>
            }
        } else {
<span class="nc" id="L1894">            PathIterator cpi = usrClip.getPathIterator(null);</span>
<span class="nc" id="L1895">            int box[] = new int[4];</span>
<span class="nc" id="L1896">            ShapeSpanIterator sr = LoopPipe.getFillSSI(this);</span>
            try {
<span class="nc" id="L1898">                sr.setOutputArea(devClip);</span>
<span class="nc" id="L1899">                sr.appendPath(cpi);</span>
<span class="nc" id="L1900">                sr.getPathBox(box);</span>
<span class="nc" id="L1901">                Region r = Region.getInstance(box);</span>
<span class="nc" id="L1902">                r.appendSpans(sr);</span>
<span class="nc" id="L1903">                clipRegion = r;</span>
<span class="nc" id="L1904">                clipState =</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">                    r.isRectangular() ? CLIP_RECTANGULAR : CLIP_SHAPE;</span>
            } finally {
<span class="nc" id="L1907">                sr.dispose();</span>
<span class="nc" id="L1908">            }</span>
        }
<span class="nc bnc" id="L1910" title="All 6 branches missed.">        if (origClipState != clipState &amp;&amp;</span>
            (clipState == CLIP_SHAPE || origClipState == CLIP_SHAPE))
        {
<span class="nc" id="L1913">            validFontInfo = false;</span>
<span class="nc" id="L1914">            invalidatePipe();</span>
        }
<span class="nc" id="L1916">    }</span>

    static final int NON_RECTILINEAR_TRANSFORM_MASK =
        (AffineTransform.TYPE_GENERAL_TRANSFORM |
         AffineTransform.TYPE_GENERAL_ROTATION);

    protected Shape transformShape(Shape s) {
<span class="nc bnc" id="L1923" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1924">            return null;</span>
        }
<span class="nc bnc" id="L1926" title="All 2 branches missed.">        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {</span>
<span class="nc" id="L1927">            return transformShape(transform, s);</span>
        } else {
<span class="nc" id="L1929">            return transformShape(transX, transY, s);</span>
        }
    }

    public Shape untransformShape(Shape s) {
<span class="nc bnc" id="L1934" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1935">            return null;</span>
        }
<span class="nc bnc" id="L1937" title="All 2 branches missed.">        if (transformState &gt; TRANSFORM_INT_TRANSLATE) {</span>
            try {
<span class="nc" id="L1939">                return transformShape(transform.createInverse(), s);</span>
<span class="nc" id="L1940">            } catch (NoninvertibleTransformException e) {</span>
<span class="nc" id="L1941">                return null;</span>
            }
        } else {
<span class="nc" id="L1944">            return transformShape(-transX, -transY, s);</span>
        }
    }

    protected static Shape transformShape(int tx, int ty, Shape s) {
<span class="nc bnc" id="L1949" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1950">            return null;</span>
        }

<span class="nc bnc" id="L1953" title="All 2 branches missed.">        if (s instanceof Rectangle) {</span>
<span class="nc" id="L1954">            Rectangle r = s.getBounds();</span>
<span class="nc" id="L1955">            r.translate(tx, ty);</span>
<span class="nc" id="L1956">            return r;</span>
        }
<span class="nc bnc" id="L1958" title="All 2 branches missed.">        if (s instanceof Rectangle2D) {</span>
<span class="nc" id="L1959">            Rectangle2D rect = (Rectangle2D) s;</span>
<span class="nc" id="L1960">            return new Rectangle2D.Double(rect.getX() + tx,</span>
<span class="nc" id="L1961">                                          rect.getY() + ty,</span>
<span class="nc" id="L1962">                                          rect.getWidth(),</span>
<span class="nc" id="L1963">                                          rect.getHeight());</span>
        }

<span class="nc bnc" id="L1966" title="All 4 branches missed.">        if (tx == 0 &amp;&amp; ty == 0) {</span>
<span class="nc" id="L1967">            return cloneShape(s);</span>
        }

<span class="nc" id="L1970">        AffineTransform mat = AffineTransform.getTranslateInstance(tx, ty);</span>
<span class="nc" id="L1971">        return mat.createTransformedShape(s);</span>
    }

    protected static Shape transformShape(AffineTransform tx, Shape clip) {
<span class="nc bnc" id="L1975" title="All 2 branches missed.">        if (clip == null) {</span>
<span class="nc" id="L1976">            return null;</span>
        }

<span class="nc bnc" id="L1979" title="All 2 branches missed.">        if (clip instanceof Rectangle2D &amp;&amp;</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">            (tx.getType() &amp; NON_RECTILINEAR_TRANSFORM_MASK) == 0)</span>
        {
<span class="nc" id="L1982">            Rectangle2D rect = (Rectangle2D) clip;</span>
<span class="nc" id="L1983">            double matrix[] = new double[4];</span>
<span class="nc" id="L1984">            matrix[0] = rect.getX();</span>
<span class="nc" id="L1985">            matrix[1] = rect.getY();</span>
<span class="nc" id="L1986">            matrix[2] = matrix[0] + rect.getWidth();</span>
<span class="nc" id="L1987">            matrix[3] = matrix[1] + rect.getHeight();</span>
<span class="nc" id="L1988">            tx.transform(matrix, 0, matrix, 0, 2);</span>
<span class="nc" id="L1989">            fixRectangleOrientation(matrix, rect);</span>
<span class="nc" id="L1990">            return new Rectangle2D.Double(matrix[0], matrix[1],</span>
                                          matrix[2] - matrix[0],
                                          matrix[3] - matrix[1]);
        }

<span class="nc bnc" id="L1995" title="All 2 branches missed.">        if (tx.isIdentity()) {</span>
<span class="nc" id="L1996">            return cloneShape(clip);</span>
        }

<span class="nc" id="L1999">        return tx.createTransformedShape(clip);</span>
    }

    /**
     * Sets orientation of the rectangle according to the clip.
     */
    private static void fixRectangleOrientation(double[] m, Rectangle2D clip) {
<span class="nc bnc" id="L2006" title="All 6 branches missed.">        if (clip.getWidth() &gt; 0 != (m[2] - m[0] &gt; 0)) {</span>
<span class="nc" id="L2007">            double t = m[0];</span>
<span class="nc" id="L2008">            m[0] = m[2];</span>
<span class="nc" id="L2009">            m[2] = t;</span>
        }
<span class="nc bnc" id="L2011" title="All 6 branches missed.">        if (clip.getHeight() &gt; 0 != (m[3] - m[1] &gt; 0)) {</span>
<span class="nc" id="L2012">            double t = m[1];</span>
<span class="nc" id="L2013">            m[1] = m[3];</span>
<span class="nc" id="L2014">            m[3] = t;</span>
        }
<span class="nc" id="L2016">    }</span>

    public void clipRect(int x, int y, int w, int h) {
<span class="nc" id="L2019">        clip(new Rectangle(x, y, w, h));</span>
<span class="nc" id="L2020">    }</span>

    public void setClip(int x, int y, int w, int h) {
<span class="nc" id="L2023">        setClip(new Rectangle(x, y, w, h));</span>
<span class="nc" id="L2024">    }</span>

    public Shape getClip() {
<span class="nc" id="L2027">        return untransformShape(usrClip);</span>
    }

    public void setClip(Shape sh) {
<span class="nc" id="L2031">        usrClip = transformShape(sh);</span>
<span class="nc" id="L2032">        validateCompClip();</span>
<span class="nc" id="L2033">    }</span>

    /**
     * Intersects the current clip with the specified Path and sets the
     * current clip to the resulting intersection. The clip is transformed
     * with the current transform in the Graphics2D state before being
     * intersected with the current clip. This method is used to make the
     * current clip smaller. To make the clip larger, use any setClip method.
     * @param p The Path to be intersected with the current clip.
     */
    public void clip(Shape s) {
<span class="nc" id="L2044">        s = transformShape(s);</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">        if (usrClip != null) {</span>
<span class="nc" id="L2046">            s = intersectShapes(usrClip, s, true, true);</span>
        }
<span class="nc" id="L2048">        usrClip = s;</span>
<span class="nc" id="L2049">        validateCompClip();</span>
<span class="nc" id="L2050">    }</span>

    public void setPaintMode() {
<span class="nc" id="L2053">        setComposite(AlphaComposite.SrcOver);</span>
<span class="nc" id="L2054">    }</span>

    public void setXORMode(Color c) {
<span class="nc bnc" id="L2057" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L2058">            throw new IllegalArgumentException(&quot;null XORColor&quot;);</span>
        }
<span class="nc" id="L2060">        setComposite(new XORComposite(c, surfaceData));</span>
<span class="nc" id="L2061">    }</span>

    Blit lastCAblit;
    Composite lastCAcomp;

    public void copyArea(int x, int y, int w, int h, int dx, int dy) {
        try {
<span class="nc" id="L2068">            doCopyArea(x, y, w, h, dx, dy);</span>
<span class="nc" id="L2069">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2071">                revalidateAll();</span>
<span class="nc" id="L2072">                doCopyArea(x, y, w, h, dx, dy);</span>
<span class="nc" id="L2073">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2077">            }</span>
        } finally {
<span class="nc" id="L2079">            surfaceData.markDirty();</span>
<span class="nc" id="L2080">        }</span>
<span class="nc" id="L2081">    }</span>

    private void doCopyArea(int x, int y, int w, int h, int dx, int dy) {
<span class="nc bnc" id="L2084" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L2085">            return;</span>
        }
<span class="nc" id="L2087">        SurfaceData theData = surfaceData;</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">        if (theData.copyArea(this, x, y, w, h, dx, dy)) {</span>
<span class="nc" id="L2089">            return;</span>
        }
<span class="nc bnc" id="L2091" title="All 2 branches missed.">        if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L2092">            throw new InternalError(&quot;transformed copyArea not implemented yet&quot;);</span>
        }
        // REMIND: This method does not deal with missing data from the
        // source object (i.e. it does not send exposure events...)

<span class="nc" id="L2097">        Region clip = getCompClip();</span>

<span class="nc" id="L2099">        Composite comp = composite;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">        if (lastCAcomp != comp) {</span>
<span class="nc" id="L2101">            SurfaceType dsttype = theData.getSurfaceType();</span>
<span class="nc" id="L2102">            CompositeType comptype = imageComp;</span>
<span class="nc bnc" id="L2103" title="All 2 branches missed.">            if (CompositeType.SrcOverNoEa.equals(comptype) &amp;&amp;</span>
<span class="nc bnc" id="L2104" title="All 2 branches missed.">                theData.getTransparency() == Transparency.OPAQUE)</span>
            {
<span class="nc" id="L2106">                comptype = CompositeType.SrcNoEa;</span>
            }
<span class="nc" id="L2108">            lastCAblit = Blit.locate(dsttype, comptype, dsttype);</span>
<span class="nc" id="L2109">            lastCAcomp = comp;</span>
        }

<span class="nc" id="L2112">        x += transX;</span>
<span class="nc" id="L2113">        y += transY;</span>

<span class="nc" id="L2115">        Blit ob = lastCAblit;</span>
<span class="nc bnc" id="L2116" title="All 6 branches missed.">        if (dy == 0 &amp;&amp; dx &gt; 0 &amp;&amp; dx &lt; w) {</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">            while (w &gt; 0) {</span>
<span class="nc" id="L2118">                int partW = Math.min(w, dx);</span>
<span class="nc" id="L2119">                w -= partW;</span>
<span class="nc" id="L2120">                int sx = x + w;</span>
<span class="nc" id="L2121">                ob.Blit(theData, theData, comp, clip,</span>
                        sx, y, sx+dx, y+dy, partW, h);
<span class="nc" id="L2123">            }</span>
<span class="nc" id="L2124">            return;</span>
        }
<span class="nc bnc" id="L2126" title="All 8 branches missed.">        if (dy &gt; 0 &amp;&amp; dy &lt; h &amp;&amp; dx &gt; -w &amp;&amp; dx &lt; w) {</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">            while (h &gt; 0) {</span>
<span class="nc" id="L2128">                int partH = Math.min(h, dy);</span>
<span class="nc" id="L2129">                h -= partH;</span>
<span class="nc" id="L2130">                int sy = y + h;</span>
<span class="nc" id="L2131">                ob.Blit(theData, theData, comp, clip,</span>
                        x, sy, x+dx, sy+dy, w, partH);
<span class="nc" id="L2133">            }</span>
<span class="nc" id="L2134">            return;</span>
        }
<span class="nc" id="L2136">        ob.Blit(theData, theData, comp, clip, x, y, x+dx, y+dy, w, h);</span>
<span class="nc" id="L2137">    }</span>

    /*
    public void XcopyArea(int x, int y, int w, int h, int dx, int dy) {
        Rectangle rect = new Rectangle(x, y, w, h);
        rect = transformBounds(rect, transform);
        Point2D    point = new Point2D.Float(dx, dy);
        Point2D    root  = new Point2D.Float(0, 0);
        point = transform.transform(point, point);
        root  = transform.transform(root, root);
        int fdx = (int)(point.getX()-root.getX());
        int fdy = (int)(point.getY()-root.getY());

        Rectangle r = getCompBounds().intersection(rect.getBounds());

        if (r.isEmpty()) {
            return;
        }

        // Begin Rasterizer for Clip Shape
        boolean skipClip = true;
        byte[] clipAlpha = null;

        if (clipState == CLIP_SHAPE) {

            int box[] = new int[4];

            clipRegion.getBounds(box);
            Rectangle devR = new Rectangle(box[0], box[1],
                                           box[2] - box[0],
                                           box[3] - box[1]);
            if (!devR.isEmpty()) {
                OutputManager mgr = getOutputManager();
                RegionIterator ri = clipRegion.getIterator();
                while (ri.nextYRange(box)) {
                    int spany = box[1];
                    int spanh = box[3] - spany;
                    while (ri.nextXBand(box)) {
                        int spanx = box[0];
                        int spanw = box[2] - spanx;
                        mgr.copyArea(this, null,
                                     spanw, 0,
                                     spanx, spany,
                                     spanw, spanh,
                                     fdx, fdy,
                                     null);
                    }
                }
            }
            return;
        }
        // End Rasterizer for Clip Shape

        getOutputManager().copyArea(this, null,
                                    r.width, 0,
                                    r.x, r.y, r.width,
                                    r.height, fdx, fdy,
                                    null);
    }
    */

    public void drawLine(int x1, int y1, int x2, int y2) {
        try {
<span class="nc" id="L2200">            drawpipe.drawLine(this, x1, y1, x2, y2);</span>
<span class="nc" id="L2201">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2203">                revalidateAll();</span>
<span class="nc" id="L2204">                drawpipe.drawLine(this, x1, y1, x2, y2);</span>
<span class="nc" id="L2205">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2209">            }</span>
        } finally {
<span class="nc" id="L2211">            surfaceData.markDirty();</span>
<span class="nc" id="L2212">        }</span>
<span class="nc" id="L2213">    }</span>

    public void drawRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
        try {
<span class="nc" id="L2217">            drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);</span>
<span class="nc" id="L2218">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2220">                revalidateAll();</span>
<span class="nc" id="L2221">                drawpipe.drawRoundRect(this, x, y, w, h, arcW, arcH);</span>
<span class="nc" id="L2222">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2226">            }</span>
        } finally {
<span class="nc" id="L2228">            surfaceData.markDirty();</span>
<span class="nc" id="L2229">        }</span>
<span class="nc" id="L2230">    }</span>

    public void fillRoundRect(int x, int y, int w, int h, int arcW, int arcH) {
        try {
<span class="nc" id="L2234">            fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);</span>
<span class="nc" id="L2235">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2237">                revalidateAll();</span>
<span class="nc" id="L2238">                fillpipe.fillRoundRect(this, x, y, w, h, arcW, arcH);</span>
<span class="nc" id="L2239">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2243">            }</span>
        } finally {
<span class="nc" id="L2245">            surfaceData.markDirty();</span>
<span class="nc" id="L2246">        }</span>
<span class="nc" id="L2247">    }</span>

    public void drawOval(int x, int y, int w, int h) {
        try {
<span class="nc" id="L2251">            drawpipe.drawOval(this, x, y, w, h);</span>
<span class="nc" id="L2252">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2254">                revalidateAll();</span>
<span class="nc" id="L2255">                drawpipe.drawOval(this, x, y, w, h);</span>
<span class="nc" id="L2256">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2260">            }</span>
        } finally {
<span class="nc" id="L2262">            surfaceData.markDirty();</span>
<span class="nc" id="L2263">        }</span>
<span class="nc" id="L2264">    }</span>

    public void fillOval(int x, int y, int w, int h) {
        try {
<span class="nc" id="L2268">            fillpipe.fillOval(this, x, y, w, h);</span>
<span class="nc" id="L2269">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2271">                revalidateAll();</span>
<span class="nc" id="L2272">                fillpipe.fillOval(this, x, y, w, h);</span>
<span class="nc" id="L2273">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2277">            }</span>
        } finally {
<span class="nc" id="L2279">            surfaceData.markDirty();</span>
<span class="nc" id="L2280">        }</span>
<span class="nc" id="L2281">    }</span>

    public void drawArc(int x, int y, int w, int h,
                        int startAngl, int arcAngl) {
        try {
<span class="nc" id="L2286">            drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);</span>
<span class="nc" id="L2287">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2289">                revalidateAll();</span>
<span class="nc" id="L2290">                drawpipe.drawArc(this, x, y, w, h, startAngl, arcAngl);</span>
<span class="nc" id="L2291">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2295">            }</span>
        } finally {
<span class="nc" id="L2297">            surfaceData.markDirty();</span>
<span class="nc" id="L2298">        }</span>
<span class="nc" id="L2299">    }</span>

    public void fillArc(int x, int y, int w, int h,
                        int startAngl, int arcAngl) {
        try {
<span class="nc" id="L2304">            fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);</span>
<span class="nc" id="L2305">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2307">                revalidateAll();</span>
<span class="nc" id="L2308">                fillpipe.fillArc(this, x, y, w, h, startAngl, arcAngl);</span>
<span class="nc" id="L2309">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2313">            }</span>
        } finally {
<span class="nc" id="L2315">            surfaceData.markDirty();</span>
<span class="nc" id="L2316">        }</span>
<span class="nc" id="L2317">    }</span>

    public void drawPolyline(int xPoints[], int yPoints[], int nPoints) {
        try {
<span class="nc" id="L2321">            drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2322">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2324">                revalidateAll();</span>
<span class="nc" id="L2325">                drawpipe.drawPolyline(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2326">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2330">            }</span>
        } finally {
<span class="nc" id="L2332">            surfaceData.markDirty();</span>
<span class="nc" id="L2333">        }</span>
<span class="nc" id="L2334">    }</span>

    public void drawPolygon(int xPoints[], int yPoints[], int nPoints) {
        try {
<span class="nc" id="L2338">            drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2339">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2341">                revalidateAll();</span>
<span class="nc" id="L2342">                drawpipe.drawPolygon(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2343">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2347">            }</span>
        } finally {
<span class="nc" id="L2349">            surfaceData.markDirty();</span>
<span class="nc" id="L2350">        }</span>
<span class="nc" id="L2351">    }</span>

    public void fillPolygon(int xPoints[], int yPoints[], int nPoints) {
        try {
<span class="nc" id="L2355">            fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2356">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2358">                revalidateAll();</span>
<span class="nc" id="L2359">                fillpipe.fillPolygon(this, xPoints, yPoints, nPoints);</span>
<span class="nc" id="L2360">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2364">            }</span>
        } finally {
<span class="nc" id="L2366">            surfaceData.markDirty();</span>
<span class="nc" id="L2367">        }</span>
<span class="nc" id="L2368">    }</span>

    public void drawRect (int x, int y, int w, int h) {
        try {
<span class="nc" id="L2372">            drawpipe.drawRect(this, x, y, w, h);</span>
<span class="nc" id="L2373">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2375">                revalidateAll();</span>
<span class="nc" id="L2376">                drawpipe.drawRect(this, x, y, w, h);</span>
<span class="nc" id="L2377">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2381">            }</span>
        } finally {
<span class="nc" id="L2383">            surfaceData.markDirty();</span>
<span class="nc" id="L2384">        }</span>
<span class="nc" id="L2385">    }</span>

    public void fillRect (int x, int y, int w, int h) {
        try {
<span class="nc" id="L2389">            fillpipe.fillRect(this, x, y, w, h);</span>
<span class="nc" id="L2390">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2392">                revalidateAll();</span>
<span class="nc" id="L2393">                fillpipe.fillRect(this, x, y, w, h);</span>
<span class="nc" id="L2394">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2398">            }</span>
        } finally {
<span class="nc" id="L2400">            surfaceData.markDirty();</span>
<span class="nc" id="L2401">        }</span>
<span class="nc" id="L2402">    }</span>

    private void revalidateAll() {
        try {
            // REMIND: This locking needs to be done around the
            // caller of this method so that the pipe stays valid
            // long enough to call the new primitive.
            // REMIND: No locking yet in screen SurfaceData objects!
            // surfaceData.lock();
<span class="nc" id="L2411">            surfaceData = surfaceData.getReplacement();</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">            if (surfaceData == null) {</span>
<span class="nc" id="L2413">                surfaceData = NullSurfaceData.theInstance;</span>
            }

            // this will recalculate the composite clip
<span class="nc" id="L2417">            setDevClip(surfaceData.getBounds());</span>

<span class="nc bnc" id="L2419" title="All 2 branches missed.">            if (paintState &lt;= PAINT_ALPHACOLOR) {</span>
<span class="nc" id="L2420">                validateColor();</span>
            }
<span class="nc bnc" id="L2422" title="All 2 branches missed.">            if (composite instanceof XORComposite) {</span>
<span class="nc" id="L2423">                Color c = ((XORComposite) composite).getXorColor();</span>
<span class="nc" id="L2424">                setComposite(new XORComposite(c, surfaceData));</span>
            }
<span class="nc" id="L2426">            validatePipe();</span>
        } finally {
            // REMIND: No locking yet in screen SurfaceData objects!
            // surfaceData.unlock();
        }
<span class="nc" id="L2431">    }</span>

    public void clearRect(int x, int y, int w, int h) {
        // REMIND: has some &quot;interesting&quot; consequences if threads are
        // not synchronized
<span class="nc" id="L2436">        Composite c = composite;</span>
<span class="nc" id="L2437">        Paint p = paint;</span>
<span class="nc" id="L2438">        setComposite(AlphaComposite.Src);</span>
<span class="nc" id="L2439">        setColor(getBackground());</span>
<span class="nc" id="L2440">        fillRect(x, y, w, h);</span>
<span class="nc" id="L2441">        setPaint(p);</span>
<span class="nc" id="L2442">        setComposite(c);</span>
<span class="nc" id="L2443">    }</span>

    /**
     * Strokes the outline of a Path using the settings of the current
     * graphics state.  The rendering attributes applied include the
     * clip, transform, paint or color, composite and stroke attributes.
     * @param p The path to be drawn.
     * @see #setStroke
     * @see #setPaint
     * @see java.awt.Graphics#setColor
     * @see #transform
     * @see #setTransform
     * @see #clip
     * @see #setClip
     * @see #setComposite
     */
    public void draw(Shape s) {
        try {
<span class="nc" id="L2461">            shapepipe.draw(this, s);</span>
<span class="nc" id="L2462">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2464">                revalidateAll();</span>
<span class="nc" id="L2465">                shapepipe.draw(this, s);</span>
<span class="nc" id="L2466">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2470">            }</span>
        } finally {
<span class="nc" id="L2472">            surfaceData.markDirty();</span>
<span class="nc" id="L2473">        }</span>
<span class="nc" id="L2474">    }</span>


    /**
     * Fills the interior of a Path using the settings of the current
     * graphics state. The rendering attributes applied include the
     * clip, transform, paint or color, and composite.
     * @see #setPaint
     * @see java.awt.Graphics#setColor
     * @see #transform
     * @see #setTransform
     * @see #setComposite
     * @see #clip
     * @see #setClip
     */
    public void fill(Shape s) {
        try {
<span class="nc" id="L2491">            shapepipe.fill(this, s);</span>
<span class="nc" id="L2492">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2494">                revalidateAll();</span>
<span class="nc" id="L2495">                shapepipe.fill(this, s);</span>
<span class="nc" id="L2496">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2500">            }</span>
        } finally {
<span class="nc" id="L2502">            surfaceData.markDirty();</span>
<span class="nc" id="L2503">        }</span>
<span class="nc" id="L2504">    }</span>

    /**
     * Returns true if the given AffineTransform is an integer
     * translation.
     */
    private static boolean isIntegerTranslation(AffineTransform xform) {
<span class="nc bnc" id="L2511" title="All 2 branches missed.">        if (xform.isIdentity()) {</span>
<span class="nc" id="L2512">            return true;</span>
        }
<span class="nc bnc" id="L2514" title="All 2 branches missed.">        if (xform.getType() == AffineTransform.TYPE_TRANSLATION) {</span>
<span class="nc" id="L2515">            double tx = xform.getTranslateX();</span>
<span class="nc" id="L2516">            double ty = xform.getTranslateY();</span>
<span class="nc bnc" id="L2517" title="All 4 branches missed.">            return (tx == (int)tx &amp;&amp; ty == (int)ty);</span>
        }
<span class="nc" id="L2519">        return false;</span>
    }

    /**
     * Returns the index of the tile corresponding to the supplied position
     * given the tile grid offset and size along the same axis.
     */
    private static int getTileIndex(int p, int tileGridOffset, int tileSize) {
<span class="nc" id="L2527">        p -= tileGridOffset;</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">        if (p &lt; 0) {</span>
<span class="nc" id="L2529">            p += 1 - tileSize;          // force round to -infinity (ceiling)</span>
        }
<span class="nc" id="L2531">        return p/tileSize;</span>
    }

    /**
     * Returns a rectangle in image coordinates that may be required
     * in order to draw the given image into the given clipping region
     * through a pair of AffineTransforms.  In addition, horizontal and
     * vertical padding factors for antialising and interpolation may
     * be used.
     */
    private static Rectangle getImageRegion(RenderedImage img,
                                            Region compClip,
                                            AffineTransform transform,
                                            AffineTransform xform,
                                            int padX, int padY) {
<span class="nc" id="L2546">        Rectangle imageRect =</span>
<span class="nc" id="L2547">            new Rectangle(img.getMinX(), img.getMinY(),</span>
<span class="nc" id="L2548">                          img.getWidth(), img.getHeight());</span>

<span class="nc" id="L2550">        Rectangle result = null;</span>
        try {
<span class="nc" id="L2552">            double p[] = new double[8];</span>
<span class="nc" id="L2553">            p[0] = p[2] = compClip.getLoX();</span>
<span class="nc" id="L2554">            p[4] = p[6] = compClip.getHiX();</span>
<span class="nc" id="L2555">            p[1] = p[5] = compClip.getLoY();</span>
<span class="nc" id="L2556">            p[3] = p[7] = compClip.getHiY();</span>

            // Inverse transform the output bounding rect
<span class="nc" id="L2559">            transform.inverseTransform(p, 0, p, 0, 4);</span>
<span class="nc" id="L2560">            xform.inverseTransform(p, 0, p, 0, 4);</span>

            // Determine a bounding box for the inverse transformed region
            double x0,x1,y0,y1;
<span class="nc" id="L2564">            x0 = x1 = p[0];</span>
<span class="nc" id="L2565">            y0 = y1 = p[1];</span>

<span class="nc bnc" id="L2567" title="All 2 branches missed.">            for (int i = 2; i &lt; 8; ) {</span>
<span class="nc" id="L2568">                double pt = p[i++];</span>
<span class="nc bnc" id="L2569" title="All 2 branches missed.">                if (pt &lt; x0)  {</span>
<span class="nc" id="L2570">                    x0 = pt;</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">                } else if (pt &gt; x1) {</span>
<span class="nc" id="L2572">                    x1 = pt;</span>
                }
<span class="nc" id="L2574">                pt = p[i++];</span>
<span class="nc bnc" id="L2575" title="All 2 branches missed.">                if (pt &lt; y0)  {</span>
<span class="nc" id="L2576">                    y0 = pt;</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">                } else if (pt &gt; y1) {</span>
<span class="nc" id="L2578">                    y1 = pt;</span>
                }
<span class="nc" id="L2580">            }</span>

            // This is padding for anti-aliasing and such.  It may
            // be more than is needed.
<span class="nc" id="L2584">            int x = (int)x0 - padX;</span>
<span class="nc" id="L2585">            int w = (int)(x1 - x0 + 2*padX);</span>
<span class="nc" id="L2586">            int y = (int)y0 - padY;</span>
<span class="nc" id="L2587">            int h = (int)(y1 - y0 + 2*padY);</span>

<span class="nc" id="L2589">            Rectangle clipRect = new Rectangle(x,y,w,h);</span>
<span class="nc" id="L2590">            result = clipRect.intersection(imageRect);</span>
<span class="nc" id="L2591">        } catch (NoninvertibleTransformException nte) {</span>
            // Worst case bounds are the bounds of the image.
<span class="nc" id="L2593">            result = imageRect;</span>
<span class="nc" id="L2594">        }</span>

<span class="nc" id="L2596">        return result;</span>
    }

    /**
     * Draws an image, applying a transform from image space into user space
     * before drawing.
     * The transformation from user space into device space is done with
     * the current transform in the Graphics2D.
     * The given transformation is applied to the image before the
     * transform attribute in the Graphics2D state is applied.
     * The rendering attributes applied include the clip, transform,
     * and composite attributes. Note that the result is
     * undefined, if the given transform is noninvertible.
     * @param img The image to be drawn. Does nothing if img is null.
     * @param xform The transformation from image space into user space.
     * @see #transform
     * @see #setTransform
     * @see #setComposite
     * @see #clip
     * @see #setClip
     */
    public void drawRenderedImage(RenderedImage img,
                                  AffineTransform xform) {

<span class="nc bnc" id="L2620" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L2621">            return;</span>
        }

        // BufferedImage case: use a simple drawImage call
<span class="nc bnc" id="L2625" title="All 2 branches missed.">        if (img instanceof BufferedImage) {</span>
<span class="nc" id="L2626">            BufferedImage bufImg = (BufferedImage)img;</span>
<span class="nc" id="L2627">            drawImage(bufImg,xform,null);</span>
<span class="nc" id="L2628">            return;</span>
        }

        // transformState tracks the state of transform and
        // transX, transY contain the integer casts of the
        // translation factors
<span class="nc bnc" id="L2634" title="All 2 branches missed.">        boolean isIntegerTranslate =</span>
            (transformState &lt;= TRANSFORM_INT_TRANSLATE) &amp;&amp;
<span class="nc bnc" id="L2636" title="All 2 branches missed.">            isIntegerTranslation(xform);</span>

        // Include padding for interpolation/antialiasing if necessary
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        int pad = isIntegerTranslate ? 0 : 3;</span>

        Region clip;
        try {
<span class="nc" id="L2643">            clip = getCompClip();</span>
<span class="nc" id="L2644">        } catch (InvalidPipeException e) {</span>
<span class="nc" id="L2645">            return;</span>
<span class="nc" id="L2646">        }</span>

        // Determine the region of the image that may contribute to
        // the clipped drawing area
<span class="nc" id="L2650">        Rectangle region = getImageRegion(img,</span>
                                          clip,
                                          transform,
                                          xform,
                                          pad, pad);
<span class="nc bnc" id="L2655" title="All 4 branches missed.">        if (region.width &lt;= 0 || region.height &lt;= 0) {</span>
<span class="nc" id="L2656">            return;</span>
        }

        // Attempt to optimize integer translation of tiled images.
        // Although theoretically we are O.K. if the concatenation of
        // the user transform and the device transform is an integer
        // translation, we'll play it safe and only optimize the case
        // where both are integer translations.
<span class="nc bnc" id="L2664" title="All 2 branches missed.">        if (isIntegerTranslate) {</span>
            // Use optimized code
            // Note that drawTranslatedRenderedImage calls copyImage
            // which takes the user space to device space transform into
            // account, but we need to provide the image space to user space
            // translations.

<span class="nc" id="L2671">            drawTranslatedRenderedImage(img, region,</span>
<span class="nc" id="L2672">                                        (int) xform.getTranslateX(),</span>
<span class="nc" id="L2673">                                        (int) xform.getTranslateY());</span>
<span class="nc" id="L2674">            return;</span>
        }

        // General case: cobble the necessary region into a single Raster
<span class="nc" id="L2678">        Raster raster = img.getData(region);</span>

        // Make a new Raster with the same contents as raster
        // but starting at (0, 0).  This raster is thus in the same
        // coordinate system as the SampleModel of the original raster.
<span class="nc" id="L2683">        WritableRaster wRaster =</span>
<span class="nc" id="L2684">              Raster.createWritableRaster(raster.getSampleModel(),</span>
<span class="nc" id="L2685">                                          raster.getDataBuffer(),</span>
                                          null);

        // If the original raster was in a different coordinate
        // system than its SampleModel, we need to perform an
        // additional translation in order to get the (minX, minY)
        // pixel of raster to be pixel (0, 0) of wRaster.  We also
        // have to have the correct width and height.
<span class="nc" id="L2693">        int minX = raster.getMinX();</span>
<span class="nc" id="L2694">        int minY = raster.getMinY();</span>
<span class="nc" id="L2695">        int width = raster.getWidth();</span>
<span class="nc" id="L2696">        int height = raster.getHeight();</span>
<span class="nc" id="L2697">        int px = minX - raster.getSampleModelTranslateX();</span>
<span class="nc" id="L2698">        int py = minY - raster.getSampleModelTranslateY();</span>
<span class="nc bnc" id="L2699" title="All 6 branches missed.">        if (px != 0 || py != 0 || width != wRaster.getWidth() ||</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">            height != wRaster.getHeight()) {</span>
<span class="nc" id="L2701">            wRaster =</span>
<span class="nc" id="L2702">                wRaster.createWritableChild(px,</span>
                                            py,
                                            width,
                                            height,
                                            0, 0,
                                            null);
        }

        // Now we have a BufferedImage starting at (0, 0)
        // with the same contents that started at (minX, minY)
        // in raster.  So we must draw the BufferedImage with a
        // translation of (minX, minY).
<span class="nc" id="L2714">        AffineTransform transXform = (AffineTransform)xform.clone();</span>
<span class="nc" id="L2715">        transXform.translate(minX, minY);</span>

<span class="nc" id="L2717">        ColorModel cm = img.getColorModel();</span>
<span class="nc" id="L2718">        BufferedImage bufImg = new BufferedImage(cm,</span>
                                                 wRaster,
<span class="nc" id="L2720">                                                 cm.isAlphaPremultiplied(),</span>
                                                 null);
<span class="nc" id="L2722">        drawImage(bufImg, transXform, null);</span>
<span class="nc" id="L2723">    }</span>

    /**
     * Intersects &lt;code&gt;destRect&lt;/code&gt; with &lt;code&gt;clip&lt;/code&gt; and
     * overwrites &lt;code&gt;destRect&lt;/code&gt; with the result.
     * Returns false if the intersection was empty, true otherwise.
     */
    private boolean clipTo(Rectangle destRect, Rectangle clip) {
<span class="nc" id="L2731">        int x1 = Math.max(destRect.x, clip.x);</span>
<span class="nc" id="L2732">        int x2 = Math.min(destRect.x + destRect.width, clip.x + clip.width);</span>
<span class="nc" id="L2733">        int y1 = Math.max(destRect.y, clip.y);</span>
<span class="nc" id="L2734">        int y2 = Math.min(destRect.y + destRect.height, clip.y + clip.height);</span>
<span class="nc bnc" id="L2735" title="All 4 branches missed.">        if (((x2 - x1) &lt; 0) || ((y2 - y1) &lt; 0)) {</span>
<span class="nc" id="L2736">            destRect.width = -1; // Set both just to be safe</span>
<span class="nc" id="L2737">            destRect.height = -1;</span>
<span class="nc" id="L2738">            return false;</span>
        } else {
<span class="nc" id="L2740">            destRect.x = x1;</span>
<span class="nc" id="L2741">            destRect.y = y1;</span>
<span class="nc" id="L2742">            destRect.width = x2 - x1;</span>
<span class="nc" id="L2743">            destRect.height = y2 - y1;</span>
<span class="nc" id="L2744">            return true;</span>
        }
    }

    /**
     * Draw a portion of a RenderedImage tile-by-tile with a given
     * integer image to user space translation.  The user to
     * device transform must also be an integer translation.
     */
    private void drawTranslatedRenderedImage(RenderedImage img,
                                             Rectangle region,
                                             int i2uTransX,
                                             int i2uTransY) {
        // Cache tile grid info
<span class="nc" id="L2758">        int tileGridXOffset = img.getTileGridXOffset();</span>
<span class="nc" id="L2759">        int tileGridYOffset = img.getTileGridYOffset();</span>
<span class="nc" id="L2760">        int tileWidth = img.getTileWidth();</span>
<span class="nc" id="L2761">        int tileHeight = img.getTileHeight();</span>

        // Determine the tile index extrema in each direction
<span class="nc" id="L2764">        int minTileX =</span>
<span class="nc" id="L2765">            getTileIndex(region.x, tileGridXOffset, tileWidth);</span>
<span class="nc" id="L2766">        int minTileY =</span>
<span class="nc" id="L2767">            getTileIndex(region.y, tileGridYOffset, tileHeight);</span>
<span class="nc" id="L2768">        int maxTileX =</span>
<span class="nc" id="L2769">            getTileIndex(region.x + region.width - 1,</span>
                         tileGridXOffset, tileWidth);
<span class="nc" id="L2771">        int maxTileY =</span>
<span class="nc" id="L2772">            getTileIndex(region.y + region.height - 1,</span>
                         tileGridYOffset, tileHeight);

        // Create a single ColorModel to use for all BufferedImages
<span class="nc" id="L2776">        ColorModel colorModel = img.getColorModel();</span>

        // Reuse the same Rectangle for each iteration
<span class="nc" id="L2779">        Rectangle tileRect = new Rectangle();</span>

<span class="nc bnc" id="L2781" title="All 2 branches missed.">        for (int ty = minTileY; ty &lt;= maxTileY; ty++) {</span>
<span class="nc bnc" id="L2782" title="All 2 branches missed.">            for (int tx = minTileX; tx &lt;= maxTileX; tx++) {</span>
                // Get the current tile.
<span class="nc" id="L2784">                Raster raster = img.getTile(tx, ty);</span>

                // Fill in tileRect with the tile bounds
<span class="nc" id="L2787">                tileRect.x = tx*tileWidth + tileGridXOffset;</span>
<span class="nc" id="L2788">                tileRect.y = ty*tileHeight + tileGridYOffset;</span>
<span class="nc" id="L2789">                tileRect.width = tileWidth;</span>
<span class="nc" id="L2790">                tileRect.height = tileHeight;</span>

                // Clip the tile against the image bounds and
                // backwards mapped clip region
                // The result can't be empty
<span class="nc" id="L2795">                clipTo(tileRect, region);</span>

                // Create a WritableRaster containing the tile
<span class="nc" id="L2798">                WritableRaster wRaster = null;</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">                if (raster instanceof WritableRaster) {</span>
<span class="nc" id="L2800">                    wRaster = (WritableRaster)raster;</span>
                } else {
                    // Create a WritableRaster in the same coordinate system
                    // as the original raster.
<span class="nc" id="L2804">                    wRaster =</span>
<span class="nc" id="L2805">                        Raster.createWritableRaster(raster.getSampleModel(),</span>
<span class="nc" id="L2806">                                                    raster.getDataBuffer(),</span>
                                                    null);
                }

                // Translate wRaster to start at (0, 0) and to contain
                // only the relevent portion of the tile
<span class="nc" id="L2812">                wRaster = wRaster.createWritableChild(tileRect.x, tileRect.y,</span>
                                                      tileRect.width,
                                                      tileRect.height,
                                                      0, 0,
                                                      null);

                // Wrap wRaster in a BufferedImage
<span class="nc" id="L2819">                BufferedImage bufImg =</span>
                    new BufferedImage(colorModel,
                                      wRaster,
<span class="nc" id="L2822">                                      colorModel.isAlphaPremultiplied(),</span>
                                      null);
                // Now we have a BufferedImage starting at (0, 0) that
                // represents data from a Raster starting at
                // (tileRect.x, tileRect.y).  Additionally, it needs
                // to be translated by (i2uTransX, i2uTransY).  We call
                // copyImage to draw just the region of interest
                // without needing to create a child image.
<span class="nc" id="L2830">                copyImage(bufImg, tileRect.x + i2uTransX,</span>
                          tileRect.y + i2uTransY, 0, 0, tileRect.width,
                          tileRect.height, null, null);
            }
        }
<span class="nc" id="L2835">    }</span>

    public void drawRenderableImage(RenderableImage img,
                                    AffineTransform xform) {

<span class="nc bnc" id="L2840" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L2841">            return;</span>
        }

<span class="nc" id="L2844">        AffineTransform pipeTransform = transform;</span>
<span class="nc" id="L2845">        AffineTransform concatTransform = new AffineTransform(xform);</span>
<span class="nc" id="L2846">        concatTransform.concatenate(pipeTransform);</span>
        AffineTransform reverseTransform;

<span class="nc" id="L2849">        RenderContext rc = new RenderContext(concatTransform);</span>

        try {
<span class="nc" id="L2852">            reverseTransform = pipeTransform.createInverse();</span>
<span class="nc" id="L2853">        } catch (NoninvertibleTransformException nte) {</span>
<span class="nc" id="L2854">            rc = new RenderContext(pipeTransform);</span>
<span class="nc" id="L2855">            reverseTransform = new AffineTransform();</span>
<span class="nc" id="L2856">        }</span>

<span class="nc" id="L2858">        RenderedImage rendering = img.createRendering(rc);</span>
<span class="nc" id="L2859">        drawRenderedImage(rendering,reverseTransform);</span>
<span class="nc" id="L2860">    }</span>



    /*
     * Transform the bounding box of the BufferedImage
     */
    protected Rectangle transformBounds(Rectangle rect,
                                        AffineTransform tx) {
<span class="nc bnc" id="L2869" title="All 2 branches missed.">        if (tx.isIdentity()) {</span>
<span class="nc" id="L2870">            return rect;</span>
        }

<span class="nc" id="L2873">        Shape s = transformShape(tx, rect);</span>
<span class="nc" id="L2874">        return s.getBounds();</span>
    }

    // text rendering methods
    public void drawString(String str, int x, int y) {
<span class="nc bnc" id="L2879" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L2880">            throw new NullPointerException(&quot;String is null&quot;);</span>
        }

<span class="nc bnc" id="L2883" title="All 2 branches missed.">        if (font.hasLayoutAttributes()) {</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            if (str.length() == 0) {</span>
<span class="nc" id="L2885">                return;</span>
            }
<span class="nc" id="L2887">            new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);</span>
<span class="nc" id="L2888">            return;</span>
        }

        try {
<span class="nc" id="L2892">            textpipe.drawString(this, str, x, y);</span>
<span class="nc" id="L2893">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2895">                revalidateAll();</span>
<span class="nc" id="L2896">                textpipe.drawString(this, str, x, y);</span>
<span class="nc" id="L2897">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2901">            }</span>
        } finally {
<span class="nc" id="L2903">            surfaceData.markDirty();</span>
<span class="nc" id="L2904">        }</span>
<span class="nc" id="L2905">    }</span>

    public void drawString(String str, float x, float y) {
<span class="nc bnc" id="L2908" title="All 2 branches missed.">        if (str == null) {</span>
<span class="nc" id="L2909">            throw new NullPointerException(&quot;String is null&quot;);</span>
        }

<span class="nc bnc" id="L2912" title="All 2 branches missed.">        if (font.hasLayoutAttributes()) {</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            if (str.length() == 0) {</span>
<span class="nc" id="L2914">                return;</span>
            }
<span class="nc" id="L2916">            new TextLayout(str, font, getFontRenderContext()).draw(this, x, y);</span>
<span class="nc" id="L2917">            return;</span>
        }

        try {
<span class="nc" id="L2921">            textpipe.drawString(this, str, x, y);</span>
<span class="nc" id="L2922">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2924">                revalidateAll();</span>
<span class="nc" id="L2925">                textpipe.drawString(this, str, x, y);</span>
<span class="nc" id="L2926">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2930">            }</span>
        } finally {
<span class="nc" id="L2932">            surfaceData.markDirty();</span>
<span class="nc" id="L2933">        }</span>
<span class="nc" id="L2934">    }</span>

    public void drawString(AttributedCharacterIterator iterator,
                           int x, int y) {
<span class="nc bnc" id="L2938" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L2939">            throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);</span>
        }
<span class="nc bnc" id="L2941" title="All 2 branches missed.">        if (iterator.getBeginIndex() == iterator.getEndIndex()) {</span>
<span class="nc" id="L2942">            return; /* nothing to draw */</span>
        }
<span class="nc" id="L2944">        TextLayout tl = new TextLayout(iterator, getFontRenderContext());</span>
<span class="nc" id="L2945">        tl.draw(this, (float) x, (float) y);</span>
<span class="nc" id="L2946">    }</span>

    public void drawString(AttributedCharacterIterator iterator,
                           float x, float y) {
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L2951">            throw new NullPointerException(&quot;AttributedCharacterIterator is null&quot;);</span>
        }
<span class="nc bnc" id="L2953" title="All 2 branches missed.">        if (iterator.getBeginIndex() == iterator.getEndIndex()) {</span>
<span class="nc" id="L2954">            return; /* nothing to draw */</span>
        }
<span class="nc" id="L2956">        TextLayout tl = new TextLayout(iterator, getFontRenderContext());</span>
<span class="nc" id="L2957">        tl.draw(this, x, y);</span>
<span class="nc" id="L2958">    }</span>

    public void drawGlyphVector(GlyphVector gv, float x, float y)
    {
<span class="nc bnc" id="L2962" title="All 2 branches missed.">        if (gv == null) {</span>
<span class="nc" id="L2963">            throw new NullPointerException(&quot;GlyphVector is null&quot;);</span>
        }

        try {
<span class="nc" id="L2967">            textpipe.drawGlyphVector(this, gv, x, y);</span>
<span class="nc" id="L2968">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L2970">                revalidateAll();</span>
<span class="nc" id="L2971">                textpipe.drawGlyphVector(this, gv, x, y);</span>
<span class="nc" id="L2972">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L2976">            }</span>
        } finally {
<span class="nc" id="L2978">            surfaceData.markDirty();</span>
<span class="nc" id="L2979">        }</span>
<span class="nc" id="L2980">    }</span>

    public void drawChars(char data[], int offset, int length, int x, int y) {

<span class="nc bnc" id="L2984" title="All 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L2985">            throw new NullPointerException(&quot;char data is null&quot;);</span>
        }
<span class="nc bnc" id="L2987" title="All 6 branches missed.">        if (offset &lt; 0 || length &lt; 0 || offset + length &gt; data.length) {</span>
<span class="nc" id="L2988">            throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);</span>
        }
<span class="nc bnc" id="L2990" title="All 2 branches missed.">        if (font.hasLayoutAttributes()) {</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">            if (data.length == 0) {</span>
<span class="nc" id="L2992">                return;</span>
            }
<span class="nc" id="L2994">            new TextLayout(new String(data, offset, length),</span>
<span class="nc" id="L2995">                           font, getFontRenderContext()).draw(this, x, y);</span>
<span class="nc" id="L2996">            return;</span>
        }

        try {
<span class="nc" id="L3000">            textpipe.drawChars(this, data, offset, length, x, y);</span>
<span class="nc" id="L3001">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3003">                revalidateAll();</span>
<span class="nc" id="L3004">                textpipe.drawChars(this, data, offset, length, x, y);</span>
<span class="nc" id="L3005">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3009">            }</span>
        } finally {
<span class="nc" id="L3011">            surfaceData.markDirty();</span>
<span class="nc" id="L3012">        }</span>
<span class="nc" id="L3013">    }</span>

    public void drawBytes(byte data[], int offset, int length, int x, int y) {
<span class="nc bnc" id="L3016" title="All 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L3017">            throw new NullPointerException(&quot;byte data is null&quot;);</span>
        }
<span class="nc bnc" id="L3019" title="All 6 branches missed.">        if (offset &lt; 0 || length &lt; 0 || offset + length &gt; data.length) {</span>
<span class="nc" id="L3020">            throw new ArrayIndexOutOfBoundsException(&quot;bad offset/length&quot;);</span>
        }
        /* Byte data is interpreted as 8-bit ASCII. Re-use drawChars loops */
<span class="nc" id="L3023">        char chData[] = new char[length];</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">        for (int i = length; i-- &gt; 0; ) {</span>
<span class="nc" id="L3025">            chData[i] = (char)(data[i+offset] &amp; 0xff);</span>
        }
<span class="nc bnc" id="L3027" title="All 2 branches missed.">        if (font.hasLayoutAttributes()) {</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">            if (data.length == 0) {</span>
<span class="nc" id="L3029">                return;</span>
            }
<span class="nc" id="L3031">            new TextLayout(new String(chData),</span>
<span class="nc" id="L3032">                           font, getFontRenderContext()).draw(this, x, y);</span>
<span class="nc" id="L3033">            return;</span>
        }

        try {
<span class="nc" id="L3037">            textpipe.drawChars(this, chData, 0, length, x, y);</span>
<span class="nc" id="L3038">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3040">                revalidateAll();</span>
<span class="nc" id="L3041">                textpipe.drawChars(this, chData, 0, length, x, y);</span>
<span class="nc" id="L3042">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3046">            }</span>
        } finally {
<span class="nc" id="L3048">            surfaceData.markDirty();</span>
<span class="nc" id="L3049">        }</span>
<span class="nc" id="L3050">    }</span>
// end of text rendering methods

    private static boolean isHiDPIImage(final Image img) {
<span class="nc bnc" id="L3054" title="All 2 branches missed.">        return SurfaceManager.getImageScale(img) != 1;</span>
    }

    private boolean drawHiDPIImage(Image img, int dx1, int dy1, int dx2,
                                   int dy2, int sx1, int sy1, int sx2, int sy2,
                                   Color bgcolor, ImageObserver observer) {
<span class="nc" id="L3060">        final int scale = SurfaceManager.getImageScale(img);</span>
<span class="nc" id="L3061">        sx1 = Region.clipScale(sx1, scale);</span>
<span class="nc" id="L3062">        sx2 = Region.clipScale(sx2, scale);</span>
<span class="nc" id="L3063">        sy1 = Region.clipScale(sy1, scale);</span>
<span class="nc" id="L3064">        sy2 = Region.clipScale(sy2, scale);</span>
        try {
<span class="nc" id="L3066">            return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1, sy1,</span>
                                        sx2, sy2, bgcolor, observer);
<span class="nc" id="L3068">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3070">                revalidateAll();</span>
<span class="nc" id="L3071">                return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2, sx1,</span>
                                            sy1, sx2, sy2, bgcolor, observer);
<span class="nc" id="L3073">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3077">                return false;</span>
            }
        } finally {
<span class="nc" id="L3080">            surfaceData.markDirty();</span>
        }
    }

    /**
     * Draws an image scaled to x,y,w,h in nonblocking mode with a
     * callback object.
     */
    public boolean drawImage(Image img, int x, int y, int width, int height,
                             ImageObserver observer) {
<span class="nc" id="L3090">        return drawImage(img, x, y, width, height, null, observer);</span>
    }

    /**
     * Not part of the advertised API but a useful utility method
     * to call internally.  This is for the case where we are
     * drawing to/from given coordinates using a given width/height,
     * but we guarantee that the surfaceData's width/height of the src and dest
     * areas are equal (no scale needed). Note that this method intentionally
     * ignore scale factor of the source image, and copy it as is.
     */
    public boolean copyImage(Image img, int dx, int dy, int sx, int sy,
                             int width, int height, Color bgcolor,
                             ImageObserver observer) {
        try {
<span class="nc" id="L3105">            return imagepipe.copyImage(this, img, dx, dy, sx, sy,</span>
                                       width, height, bgcolor, observer);
<span class="nc" id="L3107">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3109">                revalidateAll();</span>
<span class="nc" id="L3110">                return imagepipe.copyImage(this, img, dx, dy, sx, sy,</span>
                                           width, height, bgcolor, observer);
<span class="nc" id="L3112">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3116">                return false;</span>
            }
        } finally {
<span class="nc" id="L3119">            surfaceData.markDirty();</span>
        }
    }

    /**
     * Draws an image scaled to x,y,w,h in nonblocking mode with a
     * solid background color and a callback object.
     */
    public boolean drawImage(Image img, int x, int y, int width, int height,
                             Color bg, ImageObserver observer) {

<span class="nc bnc" id="L3130" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L3131">            return true;</span>
        }

<span class="nc bnc" id="L3134" title="All 4 branches missed.">        if ((width == 0) || (height == 0)) {</span>
<span class="nc" id="L3135">            return true;</span>
        }

<span class="nc" id="L3138">        final int imgW = img.getWidth(null);</span>
<span class="nc" id="L3139">        final int imgH = img.getHeight(null);</span>
<span class="nc bnc" id="L3140" title="All 2 branches missed.">        if (isHiDPIImage(img)) {</span>
<span class="nc" id="L3141">            return drawHiDPIImage(img, x, y, x + width, y + height, 0, 0, imgW,</span>
                                  imgH, bg, observer);
        }

<span class="nc bnc" id="L3145" title="All 4 branches missed.">        if (width == imgW &amp;&amp; height == imgH) {</span>
<span class="nc" id="L3146">            return copyImage(img, x, y, 0, 0, width, height, bg, observer);</span>
        }

        try {
<span class="nc" id="L3150">            return imagepipe.scaleImage(this, img, x, y, width, height,</span>
                                        bg, observer);
<span class="nc" id="L3152">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3154">                revalidateAll();</span>
<span class="nc" id="L3155">                return imagepipe.scaleImage(this, img, x, y, width, height,</span>
                                            bg, observer);
<span class="nc" id="L3157">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3161">                return false;</span>
            }
        } finally {
<span class="nc" id="L3164">            surfaceData.markDirty();</span>
        }
    }

    /**
     * Draws an image at x,y in nonblocking mode.
     */
    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
<span class="nc" id="L3172">        return drawImage(img, x, y, null, observer);</span>
    }

    /**
     * Draws an image at x,y in nonblocking mode with a solid background
     * color and a callback object.
     */
    public boolean drawImage(Image img, int x, int y, Color bg,
                             ImageObserver observer) {

<span class="nc bnc" id="L3182" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L3183">            return true;</span>
        }

<span class="nc bnc" id="L3186" title="All 2 branches missed.">        if (isHiDPIImage(img)) {</span>
<span class="nc" id="L3187">            final int imgW = img.getWidth(null);</span>
<span class="nc" id="L3188">            final int imgH = img.getHeight(null);</span>
<span class="nc" id="L3189">            return drawHiDPIImage(img, x, y, x + imgW, y + imgH, 0, 0, imgW,</span>
                                  imgH, bg, observer);
        }

        try {
<span class="nc" id="L3194">            return imagepipe.copyImage(this, img, x, y, bg, observer);</span>
<span class="nc" id="L3195">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3197">                revalidateAll();</span>
<span class="nc" id="L3198">                return imagepipe.copyImage(this, img, x, y, bg, observer);</span>
<span class="nc" id="L3199">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3203">                return false;</span>
            }
        } finally {
<span class="nc" id="L3206">            surfaceData.markDirty();</span>
        }
    }

    /**
     * Draws a subrectangle of an image scaled to a destination rectangle
     * in nonblocking mode with a callback object.
     */
    public boolean drawImage(Image img,
                             int dx1, int dy1, int dx2, int dy2,
                             int sx1, int sy1, int sx2, int sy2,
                             ImageObserver observer) {
<span class="nc" id="L3218">        return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null,</span>
                         observer);
    }

    /**
     * Draws a subrectangle of an image scaled to a destination rectangle in
     * nonblocking mode with a solid background color and a callback object.
     */
    public boolean drawImage(Image img,
                             int dx1, int dy1, int dx2, int dy2,
                             int sx1, int sy1, int sx2, int sy2,
                             Color bgcolor, ImageObserver observer) {

<span class="nc bnc" id="L3231" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L3232">            return true;</span>
        }

<span class="nc bnc" id="L3235" title="All 8 branches missed.">        if (dx1 == dx2 || dy1 == dy2 ||</span>
            sx1 == sx2 || sy1 == sy2)
        {
<span class="nc" id="L3238">            return true;</span>
        }

<span class="nc bnc" id="L3241" title="All 2 branches missed.">        if (isHiDPIImage(img)) {</span>
<span class="nc" id="L3242">            return drawHiDPIImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2,</span>
                                  bgcolor, observer);
        }

<span class="nc bnc" id="L3246" title="All 4 branches missed.">        if (((sx2 - sx1) == (dx2 - dx1)) &amp;&amp;</span>
            ((sy2 - sy1) == (dy2 - dy1)))
        {
            // Not a scale - forward it to a copy routine
            int srcX, srcY, dstX, dstY, width, height;
<span class="nc bnc" id="L3251" title="All 2 branches missed.">            if (sx2 &gt; sx1) {</span>
<span class="nc" id="L3252">                width = sx2 - sx1;</span>
<span class="nc" id="L3253">                srcX = sx1;</span>
<span class="nc" id="L3254">                dstX = dx1;</span>
            } else {
<span class="nc" id="L3256">                width = sx1 - sx2;</span>
<span class="nc" id="L3257">                srcX = sx2;</span>
<span class="nc" id="L3258">                dstX = dx2;</span>
            }
<span class="nc bnc" id="L3260" title="All 2 branches missed.">            if (sy2 &gt; sy1) {</span>
<span class="nc" id="L3261">                height = sy2-sy1;</span>
<span class="nc" id="L3262">                srcY = sy1;</span>
<span class="nc" id="L3263">                dstY = dy1;</span>
            } else {
<span class="nc" id="L3265">                height = sy1-sy2;</span>
<span class="nc" id="L3266">                srcY = sy2;</span>
<span class="nc" id="L3267">                dstY = dy2;</span>
            }
<span class="nc" id="L3269">            return copyImage(img, dstX, dstY, srcX, srcY,</span>
                             width, height, bgcolor, observer);
        }

        try {
<span class="nc" id="L3274">            return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,</span>
                                          sx1, sy1, sx2, sy2, bgcolor,
                                          observer);
<span class="nc" id="L3277">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3279">                revalidateAll();</span>
<span class="nc" id="L3280">                return imagepipe.scaleImage(this, img, dx1, dy1, dx2, dy2,</span>
                                              sx1, sy1, sx2, sy2, bgcolor,
                                              observer);
<span class="nc" id="L3283">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3287">                return false;</span>
            }
        } finally {
<span class="nc" id="L3290">            surfaceData.markDirty();</span>
        }
    }

    /**
     * Draw an image, applying a transform from image space into user space
     * before drawing.
     * The transformation from user space into device space is done with
     * the current transform in the Graphics2D.
     * The given transformation is applied to the image before the
     * transform attribute in the Graphics2D state is applied.
     * The rendering attributes applied include the clip, transform,
     * paint or color and composite attributes. Note that the result is
     * undefined, if the given transform is non-invertible.
     * @param img The image to be drawn.
     * @param xform The transformation from image space into user space.
     * @param observer The image observer to be notified on the image producing
     * progress.
     * @see #transform
     * @see #setComposite
     * @see #setClip
     */
    public boolean drawImage(Image img,
                             AffineTransform xform,
                             ImageObserver observer) {

<span class="nc bnc" id="L3316" title="All 2 branches missed.">        if (img == null) {</span>
<span class="nc" id="L3317">            return true;</span>
        }

<span class="nc bnc" id="L3320" title="All 4 branches missed.">        if (xform == null || xform.isIdentity()) {</span>
<span class="nc" id="L3321">            return drawImage(img, 0, 0, null, observer);</span>
        }

<span class="nc bnc" id="L3324" title="All 2 branches missed.">        if (isHiDPIImage(img)) {</span>
<span class="nc" id="L3325">            final int w = img.getWidth(null);</span>
<span class="nc" id="L3326">            final int h = img.getHeight(null);</span>
<span class="nc" id="L3327">            final AffineTransform tx = new AffineTransform(transform);</span>
<span class="nc" id="L3328">            transform(xform);</span>
<span class="nc" id="L3329">            boolean result = drawHiDPIImage(img, 0, 0, w, h, 0, 0, w, h, null,</span>
                                            observer);
<span class="nc" id="L3331">            transform.setTransform(tx);</span>
<span class="nc" id="L3332">            invalidateTransform();</span>
<span class="nc" id="L3333">            return result;</span>
        }

        try {
<span class="nc" id="L3337">            return imagepipe.transformImage(this, img, xform, observer);</span>
<span class="nc" id="L3338">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3340">                revalidateAll();</span>
<span class="nc" id="L3341">                return imagepipe.transformImage(this, img, xform, observer);</span>
<span class="nc" id="L3342">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3346">                return false;</span>
            }
        } finally {
<span class="nc" id="L3349">            surfaceData.markDirty();</span>
        }
    }

    public void drawImage(BufferedImage bImg,
                          BufferedImageOp op,
                          int x,
                          int y)  {

<span class="nc bnc" id="L3358" title="All 2 branches missed.">        if (bImg == null) {</span>
<span class="nc" id="L3359">            return;</span>
        }

        try {
<span class="nc" id="L3363">            imagepipe.transformImage(this, bImg, op, x, y);</span>
<span class="nc" id="L3364">        } catch (InvalidPipeException e) {</span>
            try {
<span class="nc" id="L3366">                revalidateAll();</span>
<span class="nc" id="L3367">                imagepipe.transformImage(this, bImg, op, x, y);</span>
<span class="nc" id="L3368">            } catch (InvalidPipeException e2) {</span>
                // Still catching the exception; we are not yet ready to
                // validate the surfaceData correctly.  Fail for now and
                // try again next time around.
<span class="nc" id="L3372">            }</span>
        } finally {
<span class="nc" id="L3374">            surfaceData.markDirty();</span>
<span class="nc" id="L3375">        }</span>
<span class="nc" id="L3376">    }</span>

    /**
    * Get the rendering context of the font
    * within this Graphics2D context.
    */
    public FontRenderContext getFontRenderContext() {
<span class="nc bnc" id="L3383" title="All 2 branches missed.">        if (cachedFRC == null) {</span>
<span class="nc" id="L3384">            int aahint = textAntialiasHint;</span>
<span class="nc bnc" id="L3385" title="All 4 branches missed.">            if (aahint == SunHints.INTVAL_TEXT_ANTIALIAS_DEFAULT &amp;&amp;</span>
                antialiasHint == SunHints.INTVAL_ANTIALIAS_ON) {
<span class="nc" id="L3387">                aahint = SunHints.INTVAL_TEXT_ANTIALIAS_ON;</span>
            }
            // Translation components should be excluded from the FRC transform
<span class="nc" id="L3390">            AffineTransform tx = null;</span>
<span class="nc bnc" id="L3391" title="All 2 branches missed.">            if (transformState &gt;= TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc bnc" id="L3392" title="All 2 branches missed.">                if (transform.getTranslateX() == 0 &amp;&amp;</span>
<span class="nc bnc" id="L3393" title="All 2 branches missed.">                    transform.getTranslateY() == 0) {</span>
<span class="nc" id="L3394">                    tx = transform;</span>
                } else {
<span class="nc" id="L3396">                    tx = new AffineTransform(transform.getScaleX(),</span>
<span class="nc" id="L3397">                                             transform.getShearY(),</span>
<span class="nc" id="L3398">                                             transform.getShearX(),</span>
<span class="nc" id="L3399">                                             transform.getScaleY(),</span>
                                             0, 0);
                }
            }
<span class="nc" id="L3403">            cachedFRC = new FontRenderContext(tx,</span>
<span class="nc" id="L3404">             SunHints.Value.get(SunHints.INTKEY_TEXT_ANTIALIASING, aahint),</span>
<span class="nc" id="L3405">             SunHints.Value.get(SunHints.INTKEY_FRACTIONALMETRICS,</span>
                                fractionalMetricsHint));
        }
<span class="nc" id="L3408">        return cachedFRC;</span>
    }
    private FontRenderContext cachedFRC;

    /**
     * This object has no resources to dispose of per se, but the
     * doc comments for the base method in java.awt.Graphics imply
     * that this object will not be useable after it is disposed.
     * So, we sabotage the object to prevent further use to prevent
     * developers from relying on behavior that may not work on
     * other, less forgiving, VMs that really need to dispose of
     * resources.
     */
    public void dispose() {
<span class="nc" id="L3422">        surfaceData = NullSurfaceData.theInstance;</span>
<span class="nc" id="L3423">        invalidatePipe();</span>
<span class="nc" id="L3424">    }</span>

    /**
     * Graphics has a finalize method that automatically calls dispose()
     * for subclasses.  For SunGraphics2D we do not need to be finalized
     * so that method simply causes us to be enqueued on the Finalizer
     * queues for no good reason.  Unfortunately, that method and
     * implementation are now considered part of the public contract
     * of that base class so we can not remove or gut the method.
     * We override it here with an empty method and the VM is smart
     * enough to know that if our override is empty then it should not
     * mark us as finalizeable.
     */
    public void finalize() {
        // DO NOT REMOVE THIS METHOD
<span class="nc" id="L3439">    }</span>

    /**
     * Returns destination that this Graphics renders to.  This could be
     * either an Image or a Component; subclasses of SurfaceData are
     * responsible for returning the appropriate object.
     */
    public Object getDestination() {
<span class="nc" id="L3447">        return surfaceData.getDestination();</span>
    }

    /**
     * {@inheritDoc}
     *
     * @see sun.java2d.DestSurfaceProvider#getDestSurface
     */
    @Override
    public Surface getDestSurface() {
<span class="nc" id="L3457">        return surfaceData;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>