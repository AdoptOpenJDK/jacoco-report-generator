<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SurfaceDataProxy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d</a> &gt; <span class="el_source">SurfaceDataProxy.java</span></div><h1>SurfaceDataProxy.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.AlphaComposite;
import java.awt.GraphicsEnvironment;

import sun.awt.DisplayChangedListener;
import sun.java2d.StateTrackable.State;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.SurfaceType;
import sun.java2d.loops.Blit;
import sun.java2d.loops.BlitBg;
import sun.awt.image.SurfaceManager;
import sun.awt.image.SurfaceManager.FlushableCacheData;

import java.security.AccessController;
import sun.security.action.GetPropertyAction;

/**
 * The proxy class encapsulates the logic for managing alternate
 * SurfaceData representations of a primary SurfaceData.
 * The main class will handle tracking the state changes of the
 * primary SurfaceData and updating the associated SurfaceData
 * proxy variants.
 * &lt;p&gt;
 * Subclasses have 2 main responsibilities:
 * &lt;ul&gt;
 * &lt;li&gt; Override the isSupportedOperation() method to determine if
 *      a given operation can be accelerated with a given source
 *      SurfaceData
 * &lt;li&gt; Override the validateSurfaceData() method to create or update
 *      a given accelerated surface to hold the pixels for the indicated
 *      source SurfaceData
 * &lt;/ul&gt;
 * If necessary, a subclass may also override the updateSurfaceData
 * method to transfer the pixels to the accelerated surface.
 * By default the parent class will transfer the pixels using a
 * standard Blit operation between the two SurfaceData objects.
 */
public abstract class SurfaceDataProxy
    implements DisplayChangedListener, SurfaceManager.FlushableCacheData
{
    private static boolean cachingAllowed;
    private static int defaultThreshold;

    static {
<span class="nc" id="L73">        cachingAllowed = true;</span>
<span class="nc" id="L74">        String manimg = AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;sun.java2d.managedimages&quot;));
<span class="nc bnc" id="L76" title="All 4 branches missed.">        if (manimg != null &amp;&amp; manimg.equals(&quot;false&quot;)) {</span>
<span class="nc" id="L77">            cachingAllowed = false;</span>
<span class="nc" id="L78">            System.out.println(&quot;Disabling managed images&quot;);</span>
        }

<span class="nc" id="L81">        defaultThreshold = 1;</span>
<span class="nc" id="L82">        String num = AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;sun.java2d.accthreshold&quot;));
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (num != null) {</span>
            try {
<span class="nc" id="L86">                int parsed = Integer.parseInt(num);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if (parsed &gt;= 0) {</span>
<span class="nc" id="L88">                    defaultThreshold = parsed;</span>
<span class="nc" id="L89">                    System.out.println(&quot;New Default Acceleration Threshold: &quot; +</span>
                                       defaultThreshold);
                }
<span class="nc" id="L92">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L93">                System.err.println(&quot;Error setting new threshold:&quot; + e);</span>
<span class="nc" id="L94">            }</span>
        }
    }

    public static boolean isCachingAllowed() {
<span class="nc" id="L99">        return cachingAllowed;</span>
    }

    /**
     * Determine if an alternate form for the srcData is needed
     * and appropriate from the given operational parameters.
     */
    public abstract boolean isSupportedOperation(SurfaceData srcData,
                                                 int txtype,
                                                 CompositeType comp,
                                                 Color bgColor);

    /**
     * Construct an alternate form of the given SurfaceData.
     * The contents of the returned SurfaceData may be undefined
     * since the calling code will take care of updating the
     * contents with a subsequent call to updateSurfaceData.
     * &lt;p&gt;
     * If the method returns null then there was a problem with
     * allocating the accelerated surface.  The getRetryTracker()
     * method will be called to track when to attempt another
     * revalidation.
     */
    public abstract SurfaceData validateSurfaceData(SurfaceData srcData,
                                                    SurfaceData cachedData,
                                                    int w, int h);

    /**
     * If the subclass is unable to validate or create a cached
     * SurfaceData then this method will be used to get a
     * StateTracker object that will indicate when to attempt
     * to validate the surface again.  Subclasses may return
     * trackers which count down an ever increasing threshold
     * to provide hysteresis on creating surfaces during low
     * memory conditions.  The default implementation just waits
     * another &quot;threshold&quot; number of accesses before trying again.
     */
    public StateTracker getRetryTracker(SurfaceData srcData) {
<span class="nc" id="L137">        return new CountdownTracker(threshold);</span>
    }

    public static class CountdownTracker implements StateTracker {
        private int countdown;

<span class="nc" id="L143">        public CountdownTracker(int threshold) {</span>
<span class="nc" id="L144">            this.countdown = threshold;</span>
<span class="nc" id="L145">        }</span>

        public synchronized boolean isCurrent() {
<span class="nc bnc" id="L148" title="All 2 branches missed.">            return (--countdown &gt;= 0);</span>
        }
    }

    /**
     * This instance is for cases where a caching implementation
     * determines that a particular source image will never need
     * to be cached - either the source SurfaceData was of an
     * incompatible type, or it was in an UNTRACKABLE state or
     * some other factor is discovered that permanently prevents
     * acceleration or caching.
     * This class optimally implements NOP variants of all necessary
     * methods to avoid caching with a minimum of fuss.
     */
<span class="nc" id="L162">    public static SurfaceDataProxy UNCACHED = new SurfaceDataProxy(0) {</span>
        @Override
        public boolean isAccelerated() {
<span class="nc" id="L165">            return false;</span>
        }

        @Override
        public boolean isSupportedOperation(SurfaceData srcData,
                                            int txtype,
                                            CompositeType comp,
                                            Color bgColor)
        {
<span class="nc" id="L174">            return false;</span>
        }

        @Override
        public SurfaceData validateSurfaceData(SurfaceData srcData,
                                               SurfaceData cachedData,
                                               int w, int h)
        {
<span class="nc" id="L182">            throw new InternalError(&quot;UNCACHED should never validate SDs&quot;);</span>
        }

        @Override
        public SurfaceData replaceData(SurfaceData srcData,
                                       int txtype,
                                       CompositeType comp,
                                       Color bgColor)
        {
            // Not necessary to override this, but doing so is faster
<span class="nc" id="L192">            return srcData;</span>
        }
    };

    // The number of attempts to copy from a STABLE source before
    // a cached copy is created or updated.
    private int threshold;

    /*
     * Source tracking data
     *
     * Every time that srcTracker is out of date we will reset numtries
     * to threshold and set the cacheTracker to one that is non-current.
     * numtries will then count down to 0 at which point the cacheTracker
     * will remind us that we need to update the cachedSD before we can
     * use it.
     *
     * Note that since these fields interrelate we should synchronize
     * whenever we update them, but it should be OK to read them
     * without synchronization.
     */
    private StateTracker srcTracker;
    private int numtries;

    /*
     * Cached data
     *
     * We cache a SurfaceData created by the subclass in cachedSD and
     * track its state (isValid and !surfaceLost) in cacheTracker.
     *
     * Also, when we want to note that cachedSD needs to be updated
     * we replace the cacheTracker with a NEVER_CURRENT tracker which
     * will cause us to try to revalidate and update the surface on
     * next use.
     */
    private SurfaceData cachedSD;
    private StateTracker cacheTracker;

    /*
     * Are we still the best object to control caching of data
     * for the source image?
     */
    private boolean valid;

    /**
     * Create a SurfaceData proxy manager that attempts to create
     * and cache a variant copy of the source SurfaceData after
     * the default threshold number of attempts to copy from the
     * STABLE source.
     */
    public SurfaceDataProxy() {
<span class="nc" id="L243">        this(defaultThreshold);</span>
<span class="nc" id="L244">    }</span>

    /**
     * Create a SurfaceData proxy manager that attempts to create
     * and cache a variant copy of the source SurfaceData after
     * the specified threshold number of attempts to copy from
     * the STABLE source.
     */
<span class="nc" id="L252">    public SurfaceDataProxy(int threshold) {</span>
<span class="nc" id="L253">        this.threshold = threshold;</span>

<span class="nc" id="L255">        this.srcTracker = StateTracker.NEVER_CURRENT;</span>
        // numtries will be reset on first use
<span class="nc" id="L257">        this.cacheTracker = StateTracker.NEVER_CURRENT;</span>

<span class="nc" id="L259">        this.valid = true;</span>
<span class="nc" id="L260">    }</span>

    /**
     * Returns true iff this SurfaceData proxy is still the best
     * way to control caching of the given source on the given
     * destination.
     */
    public boolean isValid() {
<span class="nc" id="L268">        return valid;</span>
    }

    /**
     * Sets the valid state to false so that the next time this
     * proxy is fetched to generate a replacement SurfaceData,
     * the code in SurfaceData knows to replace the proxy first.
     */
    public void invalidate() {
<span class="nc" id="L277">        this.valid = false;</span>
<span class="nc" id="L278">    }</span>

    /**
     * Flush all cached resources as per the FlushableCacheData interface.
     * The deaccelerated parameter indicates if the flush is
     * happening because the associated surface is no longer
     * being accelerated (for instance the acceleration priority
     * is set below the threshold needed for acceleration).
     * Returns a boolean that indicates if the cached object is
     * no longer needed and should be removed from the cache.
     */
    public boolean flush(boolean deaccelerated) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (deaccelerated) {</span>
<span class="nc" id="L291">            invalidate();</span>
        }
<span class="nc" id="L293">        flush();</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        return !isValid();</span>
    }

    /**
     * Actively flushes (drops and invalidates) the cached surface
     * so that it can be reclaimed quickly.
     */
    public synchronized void flush() {
<span class="nc" id="L302">        SurfaceData csd = this.cachedSD;</span>
<span class="nc" id="L303">        this.cachedSD = null;</span>
<span class="nc" id="L304">        this.cacheTracker = StateTracker.NEVER_CURRENT;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (csd != null) {</span>
<span class="nc" id="L306">            csd.flush();</span>
        }
<span class="nc" id="L308">    }</span>

    /**
     * Returns true iff this SurfaceData proxy is still valid
     * and if it has a currently cached replacement that is also
     * valid and current.
     */
    public boolean isAccelerated() {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        return (isValid() &amp;&amp;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                srcTracker.isCurrent() &amp;&amp;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                cacheTracker.isCurrent());</span>
    }

    /**
     * This method should be called from subclasses which create
     * cached SurfaceData objects that depend on the current
     * properties of the display.
     */
    protected void activateDisplayListener() {
        GraphicsEnvironment ge =
<span class="nc" id="L328">            GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
        // We could have a HeadlessGE at this point, so double-check before
        // assuming anything.
        // Also, no point in listening to display change events if
        // the image is never going to be accelerated.
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (ge instanceof SunGraphicsEnvironment) {</span>
<span class="nc" id="L334">            ((SunGraphicsEnvironment)ge).addDisplayChangedListener(this);</span>
        }
<span class="nc" id="L336">    }</span>

    /**
     * Invoked when the display mode has changed.
     * This method will invalidate and drop the internal cachedSD object.
     */
    public void displayChanged() {
<span class="nc" id="L343">        flush();</span>
<span class="nc" id="L344">    }</span>

    /**
     * Invoked when the palette has changed.
     */
    public void paletteChanged() {
        // We could potentially get away with just resetting cacheTracker
        // here but there is a small window of vulnerability in the
        // replaceData method where we could be just finished with
        // updating the cachedSD when this method is called and even
        // though we set a non-current cacheTracker here it will then
        // immediately get set to a current one by the thread that is
        // updating the cachedSD.  It is safer to just replace the
        // srcTracker with a non-current version that will trigger a
        // full update cycle the next time this proxy is used.
        // The downside is having to go through a full threshold count
        // before we can update and use our cache again, but palette
        // changes should be relatively rare...
<span class="nc" id="L362">        this.srcTracker = StateTracker.NEVER_CURRENT;</span>
<span class="nc" id="L363">    }</span>

    /**
     * This method attempts to replace the srcData with a cached version.
     * It relies on the subclass to determine if the cached version will
     * be useful given the operational parameters.
     * This method checks any preexisting cached copy for being &quot;up to date&quot;
     * and tries to update it if it is stale or non-existant and the
     * appropriate number of accesses have occurred since it last was stale.
     * &lt;p&gt;
     * An outline of the process is as follows:
     * &lt;ol&gt;
     * &lt;li&gt; Check the operational parameters (txtype, comp, bgColor)
     *      to make sure that the operation is supported.  Return the
     *      original SurfaceData if the operation cannot be accelerated.
     * &lt;li&gt; Check the tracker for the source surface to see if it has
     *      remained stable since it was last cached.  Update the state
     *      variables to cause both a threshold countdown and an update
     *      of the cached copy if it is not.  (Setting cacheTracker to
     *      NEVER_CURRENT effectively marks it as &quot;needing to be updated&quot;.)
     * &lt;li&gt; Check the tracker for the cached copy to see if is still
     *      valid and up to date.  Note that the cacheTracker may be
     *      non-current if either something happened to the cached copy
     *      (eg. surfaceLost) or if the source was out of date and the
     *      cacheTracker was set to NEVER_CURRENT to force an update.
     *      Decrement the countdown and copy the source to the cache
     *      as necessary and then update the variables to show that
     *      the cached copy is stable.
     * &lt;/ol&gt;
     */
    public SurfaceData replaceData(SurfaceData srcData,
                                   int txtype,
                                   CompositeType comp,
                                   Color bgColor)
    {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (isSupportedOperation(srcData, txtype, comp, bgColor)) {</span>
            // First deal with tracking the source.
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (!srcTracker.isCurrent()) {</span>
<span class="nc" id="L401">                synchronized (this) {</span>
<span class="nc" id="L402">                    this.numtries = threshold;</span>
<span class="nc" id="L403">                    this.srcTracker = srcData.getStateTracker();</span>
<span class="nc" id="L404">                    this.cacheTracker = StateTracker.NEVER_CURRENT;</span>
<span class="nc" id="L405">                }</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (!srcTracker.isCurrent()) {</span>
                    // Dynamic or Untrackable (or a very recent modification)
<span class="nc bnc" id="L409" title="All 2 branches missed.">                    if (srcData.getState() == State.UNTRACKABLE) {</span>
                        // UNTRACKABLE means we can never cache again.

                        // Invalidate so we get replaced next time we are used
                        // (presumably with an UNCACHED proxy).
<span class="nc" id="L414">                        invalidate();</span>

                        // Aggressively drop our reference to the cachedSD
                        // in case this proxy is not consulted again (and
                        // thus replaced) for a long time.
<span class="nc" id="L419">                        flush();</span>
                    }
<span class="nc" id="L421">                    return srcData;</span>
                }
            }

            // Then deal with checking the validity of the cached SurfaceData
<span class="nc" id="L426">            SurfaceData csd = this.cachedSD;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (!cacheTracker.isCurrent()) {</span>
                // Next make sure the dust has settled
<span class="nc" id="L429">                synchronized (this) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    if (numtries &gt; 0) {</span>
<span class="nc" id="L431">                        --numtries;</span>
<span class="nc" id="L432">                        return srcData;</span>
                    }
<span class="nc" id="L434">                }</span>

<span class="nc" id="L436">                Rectangle r = srcData.getBounds();</span>
<span class="nc" id="L437">                int w = r.width;</span>
<span class="nc" id="L438">                int h = r.height;</span>

                // Snapshot the tracker in case it changes while
                // we are updating the cached SD...
<span class="nc" id="L442">                StateTracker curTracker = srcTracker;</span>

<span class="nc" id="L444">                csd = validateSurfaceData(srcData, csd, w, h);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (csd == null) {</span>
<span class="nc" id="L446">                    synchronized (this) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                        if (curTracker == srcTracker) {</span>
<span class="nc" id="L448">                            this.cacheTracker = getRetryTracker(srcData);</span>
<span class="nc" id="L449">                            this.cachedSD = null;</span>
                        }
<span class="nc" id="L451">                    }</span>
<span class="nc" id="L452">                    return srcData;</span>
                }

<span class="nc" id="L455">                updateSurfaceData(srcData, csd, w, h);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if (!csd.isValid()) {</span>
<span class="nc" id="L457">                    return srcData;</span>
                }

<span class="nc" id="L460">                synchronized (this) {</span>
                    // We only reset these variables if the tracker from
                    // before the surface update is still in use and current
                    // Note that we must use a srcTracker that was fetched
                    // from before the update process to make sure that we
                    // do not lose some pixel changes in the shuffle.
<span class="nc bnc" id="L466" title="All 4 branches missed.">                    if (curTracker == srcTracker &amp;&amp; curTracker.isCurrent()) {</span>
<span class="nc" id="L467">                        this.cacheTracker = csd.getStateTracker();</span>
<span class="nc" id="L468">                        this.cachedSD = csd;</span>
                    }
<span class="nc" id="L470">                }</span>
            }

<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (csd != null) {</span>
<span class="nc" id="L474">                return csd;</span>
            }
        }

<span class="nc" id="L478">        return srcData;</span>
    }

    /**
     * This is the default implementation for updating the cached
     * SurfaceData from the source (primary) SurfaceData.
     * A simple Blit is used to copy the pixels from the source to
     * the destination SurfaceData.
     * A subclass can override this implementation if a more complex
     * operation is required to update its cached copies.
     */
    public void updateSurfaceData(SurfaceData srcData,
                                  SurfaceData dstData,
                                  int w, int h)
    {
<span class="nc" id="L493">        SurfaceType srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L494">        SurfaceType dstType = dstData.getSurfaceType();</span>
<span class="nc" id="L495">        Blit blit = Blit.getFromCache(srcType,</span>
                                      CompositeType.SrcNoEa,
                                      dstType);
<span class="nc" id="L498">        blit.Blit(srcData, dstData,</span>
                  AlphaComposite.Src, null,
                  0, 0, 0, 0, w, h);
<span class="nc" id="L501">        dstData.markDirty();</span>
<span class="nc" id="L502">    }</span>

    /**
     * This is an alternate implementation for updating the cached
     * SurfaceData from the source (primary) SurfaceData using a
     * background color for transparent pixels.
     * A simple BlitBg is used to copy the pixels from the source to
     * the destination SurfaceData with the specified bgColor.
     * A subclass can override the normal updateSurfaceData method
     * and call this implementation instead if it wants to use color
     * keying for bitmask images.
     */
    public void updateSurfaceDataBg(SurfaceData srcData,
                                    SurfaceData dstData,
                                    int w, int h, Color bgColor)
    {
<span class="nc" id="L518">        SurfaceType srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L519">        SurfaceType dstType = dstData.getSurfaceType();</span>
<span class="nc" id="L520">        BlitBg blitbg = BlitBg.getFromCache(srcType,</span>
                                            CompositeType.SrcNoEa,
                                            dstType);
<span class="nc" id="L523">        blitbg.BlitBg(srcData, dstData,</span>
<span class="nc" id="L524">                      AlphaComposite.Src, null, bgColor.getRGB(),</span>
                      0, 0, 0, 0, w, h);
<span class="nc" id="L526">        dstData.markDirty();</span>
<span class="nc" id="L527">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>