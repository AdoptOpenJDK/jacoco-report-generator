<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ExceptionMapper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.cosnaming</a> &gt; <span class="el_source">ExceptionMapper.java</span></div><h1>ExceptionMapper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.cosnaming;

import javax.naming.*;
import javax.naming.directory.*;
import javax.naming.spi.*;

import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

/**
  * A convenience class to map the COS Naming exceptions to the JNDI exceptions.
  * @author Raj Krishnamurthy
  */

public final class ExceptionMapper {
<span class="nc" id="L42">    private ExceptionMapper() {} // ensure no instance</span>
    private static final boolean debug = false;

    public static final NamingException mapException(Exception e,
        CNCtx ctx, NameComponent[] inputName) throws NamingException {
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (e instanceof NamingException) {</span>
<span class="nc" id="L48">            return (NamingException)e;</span>
        }

<span class="nc bnc" id="L51" title="All 2 branches missed.">        if (e instanceof RuntimeException) {</span>
<span class="nc" id="L52">            throw (RuntimeException)e;</span>
        }

        NamingException ne;
<span class="nc bnc" id="L56" title="All 2 branches missed.">        if (e instanceof NotFound) {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">            if (ctx.federation) {</span>
<span class="nc" id="L58">                return tryFed((NotFound)e, ctx, inputName);</span>

            } else {
<span class="nc" id="L61">                ne = new NameNotFoundException();</span>
            }

<span class="nc bnc" id="L64" title="All 2 branches missed.">        } else if (e instanceof CannotProceed) {</span>

<span class="nc" id="L66">            ne = new CannotProceedException();</span>
<span class="nc" id="L67">            NamingContext nc = ((CannotProceed) e).cxt;</span>
<span class="nc" id="L68">            NameComponent[] rest = ((CannotProceed) e).rest_of_name;</span>

            // %%% We assume that rest returns *all* unprocessed components.
            // Don't' know if that is a good assumption, given
            // NotFound doesn't set rest as expected. -RL
<span class="nc bnc" id="L73" title="All 4 branches missed.">            if (inputName != null &amp;&amp; (inputName.length &gt; rest.length)) {</span>
<span class="nc" id="L74">                NameComponent[] resolvedName =</span>
                    new NameComponent[inputName.length - rest.length];
<span class="nc" id="L76">                System.arraycopy(inputName, 0, resolvedName, 0, resolvedName.length);</span>
                // Wrap resolved NamingContext inside a CNCtx
                // Guess that its name (which is relative to ctx)
                // is the part of inputName minus rest_of_name
<span class="nc" id="L80">                ne.setResolvedObj(new CNCtx(ctx._orb, ctx.orbTracker, nc,</span>
                                                ctx._env,
<span class="nc" id="L82">                    ctx.makeFullName(resolvedName)));</span>
<span class="nc" id="L83">            } else {</span>
<span class="nc" id="L84">                ne.setResolvedObj(ctx);</span>
            }

<span class="nc" id="L87">            ne.setRemainingName(CNNameParser.cosNameToName(rest));</span>

<span class="nc bnc" id="L89" title="All 2 branches missed.">        } else if (e instanceof InvalidName) {</span>
<span class="nc" id="L90">            ne = new InvalidNameException();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        } else if (e instanceof AlreadyBound) {</span>
<span class="nc" id="L92">            ne = new NameAlreadyBoundException();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        } else if (e instanceof NotEmpty) {</span>
<span class="nc" id="L94">            ne = new ContextNotEmptyException();</span>
        } else {
<span class="nc" id="L96">            ne = new NamingException(&quot;Unknown reasons&quot;);</span>
        }

<span class="nc" id="L99">        ne.setRootCause(e);</span>
<span class="nc" id="L100">        return ne;</span>
    }

    private static final NamingException tryFed(NotFound e, CNCtx ctx,
        NameComponent[] inputName) throws NamingException {
<span class="nc" id="L105">        NameComponent[] rest = e.rest_of_name;</span>

        if (debug) {
            System.out.println(e.why.value());
            System.out.println(rest.length);
        }

        // %%% Using 1.2 &amp; 1.3 Sun's tnameserv, 'rest' contains only the first
        // component that failed, not *rest* as advertized. This is useless
        // because what if you have something like aa/aa/aa/aa/aa.
        // If one of those is not found, you get &quot;aa&quot; as 'rest'.
<span class="nc bnc" id="L116" title="All 4 branches missed.">        if (rest.length == 1 &amp;&amp; inputName != null) {</span>
            // Check that we're not talking to 1.2/1.3 Sun tnameserv
<span class="nc" id="L118">            NameComponent lastIn = inputName[inputName.length-1];</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">            if (rest[0].id.equals(lastIn.id) &amp;&amp;</span>
                rest[0].kind != null &amp;&amp;
<span class="nc bnc" id="L121" title="All 2 branches missed.">                rest[0].kind.equals(lastIn.kind)) {</span>
                // Might be legit
                ;
            } else {
                // Due to 1.2/1.3 bug that always returns single-item 'rest'
<span class="nc" id="L126">                NamingException ne = new NameNotFoundException();</span>
<span class="nc" id="L127">                ne.setRemainingName(CNNameParser.cosNameToName(rest));</span>
<span class="nc" id="L128">                ne.setRootCause(e);</span>
<span class="nc" id="L129">                throw ne;</span>
            }
        }
        // Fixed in 1.4; perform calculations based on correct (1.4) behavior

        // Calculate the components of the name that has been resolved
<span class="nc" id="L135">        NameComponent[] resolvedName = null;</span>
<span class="nc" id="L136">        int len = 0;</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">        if (inputName != null &amp;&amp; (inputName.length &gt;= rest.length)) {</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (e.why == NotFoundReason.not_context) {</span>
                // First component of rest is found but not a context; keep it
                // as part of resolved name
<span class="nc" id="L142">                len = inputName.length - (rest.length - 1);</span>

                // Remove resolved component from rest
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (rest.length == 1) {</span>
                    // No more remaining
<span class="nc" id="L147">                    rest = null;</span>
                } else {
<span class="nc" id="L149">                    NameComponent[] tmp = new NameComponent[rest.length-1];</span>
<span class="nc" id="L150">                    System.arraycopy(rest, 1, tmp, 0, tmp.length);</span>
<span class="nc" id="L151">                    rest = tmp;</span>
<span class="nc" id="L152">                }</span>
            } else {
<span class="nc" id="L154">                len = inputName.length - rest.length;</span>
            }

<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (len &gt; 0) {</span>
<span class="nc" id="L158">                resolvedName = new NameComponent[len];</span>
<span class="nc" id="L159">                System.arraycopy(inputName, 0, resolvedName, 0, len);</span>
            }
        }

        // Create CPE and set common fields
<span class="nc" id="L164">        CannotProceedException cpe = new CannotProceedException();</span>
<span class="nc" id="L165">        cpe.setRootCause(e);</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">        if (rest != null &amp;&amp; rest.length &gt; 0) {</span>
<span class="nc" id="L167">            cpe.setRemainingName(CNNameParser.cosNameToName(rest));</span>
        }
<span class="nc" id="L169">        cpe.setEnvironment(ctx._env);</span>

        if (debug) {
            System.out.println(&quot;rest of name: &quot; + cpe.getRemainingName());
        }

        // Lookup resolved name to get resolved object
<span class="nc bnc" id="L176" title="All 2 branches missed.">        final java.lang.Object resolvedObj =</span>
<span class="nc" id="L177">            (resolvedName != null) ? ctx.callResolve(resolvedName) : ctx;</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (resolvedObj instanceof javax.naming.Context) {</span>
            // obj is a context and child is not found
            // try getting its nns dynamically by constructing
            // a Reference containing obj.
<span class="nc" id="L183">            RefAddr addr = new RefAddr(&quot;nns&quot;) {</span>
                public java.lang.Object getContent() {
<span class="nc" id="L185">                    return resolvedObj;</span>
                }
                private static final long serialVersionUID =
                    669984699392133792L;
            };
<span class="nc" id="L190">            Reference ref = new Reference(&quot;java.lang.Object&quot;, addr);</span>

            // Resolved name has trailing slash to indicate nns
<span class="nc" id="L193">            CompositeName cname = new CompositeName();</span>
<span class="nc" id="L194">            cname.add(&quot;&quot;); // add trailing slash</span>

<span class="nc" id="L196">            cpe.setResolvedObj(ref);</span>
<span class="nc" id="L197">            cpe.setAltName(cname);</span>
<span class="nc" id="L198">            cpe.setAltNameCtx((javax.naming.Context)resolvedObj);</span>

<span class="nc" id="L200">            return cpe;</span>
        } else {
            // Not a context, use object factory to transform object.

<span class="nc" id="L204">            Name cname = CNNameParser.cosNameToName(resolvedName);</span>
            java.lang.Object resolvedObj2;
            try {
<span class="nc" id="L207">                resolvedObj2 = NamingManager.getObjectInstance(resolvedObj,</span>
                    cname, ctx, ctx._env);
<span class="nc" id="L209">            } catch (NamingException ge) {</span>
<span class="nc" id="L210">                throw ge;</span>
<span class="nc" id="L211">            } catch (Exception ge) {</span>
<span class="nc" id="L212">                NamingException ne = new NamingException(</span>
                    &quot;problem generating object using object factory&quot;);
<span class="nc" id="L214">                ne.setRootCause(ge);</span>
<span class="nc" id="L215">                throw ne;</span>
<span class="nc" id="L216">            }</span>

            // If a context, continue operation with context
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (resolvedObj2 instanceof javax.naming.Context) {</span>
<span class="nc" id="L220">                cpe.setResolvedObj(resolvedObj2);</span>
            } else {
                // Add trailing slash
<span class="nc" id="L223">                cname.add(&quot;&quot;);</span>
<span class="nc" id="L224">                cpe.setAltName(cname);</span>

                // Create nns reference
<span class="nc" id="L227">                final java.lang.Object rf2 = resolvedObj2;</span>
<span class="nc" id="L228">                RefAddr addr = new RefAddr(&quot;nns&quot;) {</span>
                    public java.lang.Object getContent() {
<span class="nc" id="L230">                        return rf2;</span>
                    }
                    private static final long serialVersionUID =
                        -785132553978269772L;
                };
<span class="nc" id="L235">                Reference ref = new Reference(&quot;java.lang.Object&quot;, addr);</span>
<span class="nc" id="L236">                cpe.setResolvedObj(ref);</span>
<span class="nc" id="L237">                cpe.setAltNameCtx(ctx);</span>
            }
<span class="nc" id="L239">            return cpe;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>