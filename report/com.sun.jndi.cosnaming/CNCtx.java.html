<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CNCtx.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.cosnaming</a> &gt; <span class="el_source">CNCtx.java</span></div><h1>CNCtx.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.cosnaming;

import javax.naming.*;
import javax.naming.spi.NamingManager;
import javax.naming.spi.ResolveResult;

import java.util.Hashtable;
import java.net.MalformedURLException;
import java.net.URL;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;

import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

import com.sun.jndi.toolkit.corba.CorbaUtils;

// Needed for creating default ORB
import java.applet.Applet;

/**
  * Provides a bridge to the CosNaming server provided by
  * JavaIDL. This class provides the InitialContext from CosNaming.
  *
  * @author Raj Krishnamurthy
  * @author Rosanna Lee
  */

public class CNCtx implements javax.naming.Context {

    private final static boolean debug = false;

    /*
     * Implement one shared ORB among all CNCtx.  However, there is a public constructor
     * accepting an ORB, so we need the option of using a given ORB.
     */
    private static ORB _defaultOrb;
    ORB _orb;                   // used by ExceptionMapper and RMI/IIOP factory
    public NamingContext _nc;   // public for accessing underlying NamingContext

    private synchronized static ORB getDefaultOrb() {
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (_defaultOrb == null) {</span>
<span class="nc" id="L71">            _defaultOrb = CorbaUtils.getOrb(null, -1,</span>
               new Hashtable&lt;String, java.lang.Object&gt;());
        }
<span class="nc" id="L74">        return _defaultOrb;</span>
    }

<span class="nc" id="L77">    private NameComponent[] _name = null;</span>

    Hashtable&lt;String, java.lang.Object&gt; _env; // used by ExceptionMapper
<span class="nc" id="L80">    static final CNNameParser parser = new CNNameParser();</span>

    private static final String FED_PROP = &quot;com.sun.jndi.cosnaming.federation&quot;;
<span class="nc" id="L83">    boolean federation = false;</span>

    // Reference counter for tracking _orb references
<span class="nc" id="L86">    OrbReuseTracker orbTracker = null;</span>
    int enumCount;
<span class="nc" id="L88">    boolean isCloseCalled = false;</span>

    /**
      * Create a CNCtx object. Gets the initial naming
      * reference for the COS Naming Service from the ORB.
      * The ORB can be passed in via the java.naming.corba.orb property
      * or be created using properties in the environment properties.
      * @param env Environment properties for initializing name service.
      * @exception NamingException Cannot initialize ORB or naming context.
      */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L99">    CNCtx(Hashtable&lt;?,?&gt; env) throws NamingException {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (env != null) {</span>
<span class="nc" id="L101">            env = (Hashtable&lt;?,?&gt;)env.clone();</span>
        }
<span class="nc" id="L103">        _env = (Hashtable&lt;String, java.lang.Object&gt;)env;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        federation = &quot;true&quot;.equals(env != null ? env.get(FED_PROP) : null);</span>
<span class="nc" id="L105">        initOrbAndRootContext(env);</span>
<span class="nc" id="L106">    }</span>

<span class="nc" id="L108">    private CNCtx() {</span>
<span class="nc" id="L109">    }</span>

    /**
     * This method is used by the iiop and iiopname URL Context factories.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static ResolveResult createUsingURL(String url, Hashtable&lt;?,?&gt; env)
    throws NamingException {
<span class="nc" id="L117">        CNCtx ctx = new CNCtx();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (env != null) {</span>
<span class="nc" id="L119">            env = (Hashtable&lt;?,?&gt;) env.clone();</span>
        }
<span class="nc" id="L121">        ctx._env = (Hashtable&lt;String, java.lang.Object&gt;)env;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        String rest = ctx.initUsingUrl(</span>
            env != null ?
<span class="nc" id="L124">                (org.omg.CORBA.ORB) env.get(&quot;java.naming.corba.orb&quot;)</span>
                : null,
            url, env);

        // rest is the INS name
        // Return the parsed form to prevent subsequent lookup
        // from parsing the string as a composite name
        // The caller should be aware that a toString() of the name,
        // which came from the environment will yield its INS syntax,
        // rather than a composite syntax
<span class="nc" id="L134">        return new ResolveResult(ctx, parser.parse(rest));</span>
    }

    /**
      * Creates a CNCtx object which supports the javax.naming
      * apis given a COS Naming Context object.
      * @param orb The ORB used by this context
      * @param tracker The ORB reuse tracker for tracking references to the
      *  orb object
      * @param nctx The COS NamingContext object associated with this context
      * @param name The name of this context relative to the root
      */

    CNCtx(ORB orb, OrbReuseTracker tracker, NamingContext nctx,
          Hashtable&lt;String, java.lang.Object&gt; env, NameComponent[]name)
<span class="nc" id="L149">        throws NamingException {</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">            if (orb == null || nctx == null)</span>
<span class="nc" id="L151">                throw new ConfigurationException(</span>
                    &quot;Must supply ORB or NamingContext&quot;);
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (orb != null) {</span>
<span class="nc" id="L154">                _orb = orb;</span>
            } else {
<span class="nc" id="L156">                _orb = getDefaultOrb();</span>
            }
<span class="nc" id="L158">            _nc = nctx;</span>
<span class="nc" id="L159">            _env = env;</span>
<span class="nc" id="L160">            _name = name;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            federation = &quot;true&quot;.equals(env != null ? env.get(FED_PROP) : null);</span>
<span class="nc" id="L162">    }</span>

    NameComponent[] makeFullName(NameComponent[] child) {
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if (_name == null || _name.length == 0) {</span>
<span class="nc" id="L166">            return child;</span>
        }
<span class="nc" id="L168">        NameComponent[] answer = new NameComponent[_name.length+child.length];</span>

        // parent
<span class="nc" id="L171">        System.arraycopy(_name, 0, answer, 0, _name.length);</span>

        // child
<span class="nc" id="L174">        System.arraycopy(child, 0, answer, _name.length, child.length);</span>
<span class="nc" id="L175">        return answer;</span>
    }


    public String getNameInNamespace() throws NamingException {
<span class="nc bnc" id="L180" title="All 4 branches missed.">        if (_name == null || _name.length == 0) {</span>
<span class="nc" id="L181">            return &quot;&quot;;</span>
        }
<span class="nc" id="L183">        return CNNameParser.cosNameToInsString(_name);</span>
    }

    /**
     * These are the URL schemes that need to be processed.
     * IOR and corbaloc URLs can be passed directly to ORB.string_to_object()
     */
    private static boolean isCorbaUrl(String url) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">        return url.startsWith(&quot;iiop://&quot;)</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">            || url.startsWith(&quot;iiopname://&quot;)</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            || url.startsWith(&quot;corbaname:&quot;)</span>
            ;
    }

    /**
      * Initializes the COS Naming Service.
      * This method initializes the three instance fields:
      * _nc : The root naming context.
      * _orb: The ORB to use for connecting RMI/IIOP stubs and for
      *       getting the naming context (_nc) if one was not specified
      *       explicitly via PROVIDER_URL.
      * _name: The name of the root naming context.
      *&lt;p&gt;
      * _orb is obtained from java.naming.corba.orb if it has been set.
      * Otherwise, _orb is created using the host/port from PROVIDER_URL
      * (if it contains an &quot;iiop&quot; or &quot;iiopname&quot; URL), or from initialization
      * properties specified in env.
      *&lt;p&gt;
      * _nc is obtained from the IOR stored in PROVIDER_URL if it has been
      * set and does not contain an &quot;iiop&quot; or &quot;iiopname&quot; URL. It can be
      * a stringified IOR, &quot;corbaloc&quot; URL, &quot;corbaname&quot; URL,
      * or a URL (such as file/http/ftp) to a location
      * containing a stringified IOR. If PROVIDER_URL has not been
      * set in this way, it is obtained from the result of
      *     ORB.resolve_initial_reference(&quot;NameService&quot;);
      *&lt;p&gt;
      * _name is obtained from the &quot;iiop&quot;, &quot;iiopname&quot;, or &quot;corbaname&quot; URL.
      * It is the empty name by default.
      *
      * @param env Environment The possibly null environment.
      * @exception NamingException When an error occurs while initializing the
      * ORB or the naming context.
      */
    private void initOrbAndRootContext(Hashtable&lt;?,?&gt; env) throws NamingException {
<span class="nc" id="L227">        org.omg.CORBA.ORB inOrb = null;</span>
<span class="nc" id="L228">        String ncIor = null;</span>

<span class="nc bnc" id="L230" title="All 4 branches missed.">        if (inOrb == null &amp;&amp; env != null) {</span>
<span class="nc" id="L231">            inOrb = (org.omg.CORBA.ORB) env.get(&quot;java.naming.corba.orb&quot;);</span>
        }

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (inOrb == null)</span>
<span class="nc" id="L235">            inOrb = getDefaultOrb(); // will create a default ORB if none exists</span>

        // Extract PROVIDER_URL from environment
<span class="nc" id="L238">        String provUrl = null;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (env != null) {</span>
<span class="nc" id="L240">            provUrl = (String)env.get(javax.naming.Context.PROVIDER_URL);</span>
        }

<span class="nc bnc" id="L243" title="All 4 branches missed.">        if (provUrl != null &amp;&amp; !isCorbaUrl(provUrl)) {</span>
            // Initialize the root naming context by using the IOR supplied
            // in the PROVIDER_URL
<span class="nc" id="L246">            ncIor = getStringifiedIor(provUrl);</span>
<span class="nc" id="L247">            setOrbAndRootContext(inOrb, ncIor);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        } else if (provUrl != null) {</span>
            // Initialize the root naming context by using the URL supplied
            // in the PROVIDER_URL
<span class="nc" id="L251">            String insName = initUsingUrl(inOrb, provUrl, env);</span>

            // If name supplied in URL, resolve it to a NamingContext
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (insName.length() &gt; 0) {</span>
<span class="nc" id="L255">                _name = CNNameParser.nameToCosName(parser.parse(insName));</span>
                try {
<span class="nc" id="L257">                    org.omg.CORBA.Object obj = _nc.resolve(_name);</span>
<span class="nc" id="L258">                    _nc = NamingContextHelper.narrow(obj);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                    if (_nc == null) {</span>
<span class="nc" id="L260">                        throw new ConfigurationException(insName +</span>
                            &quot; does not name a NamingContext&quot;);
                    }
<span class="nc" id="L263">                } catch (org.omg.CORBA.BAD_PARAM e) {</span>
<span class="nc" id="L264">                    throw new ConfigurationException(insName +</span>
                        &quot; does not name a NamingContext&quot;);
<span class="nc" id="L266">                } catch (Exception e) {</span>
<span class="nc" id="L267">                    throw ExceptionMapper.mapException(e, this, _name);</span>
<span class="nc" id="L268">                }</span>
            }
<span class="nc" id="L270">        } else {</span>
            // No PROVIDER_URL supplied; initialize using defaults
            if (debug) {
                System.err.println(&quot;Getting default ORB: &quot; + inOrb + env);
            }
<span class="nc" id="L275">            setOrbAndRootContext(inOrb, (String)null);</span>
        }
<span class="nc" id="L277">    }</span>


    private String initUsingUrl(ORB orb, String url, Hashtable&lt;?,?&gt; env)
        throws NamingException {
<span class="nc bnc" id="L282" title="All 4 branches missed.">        if (url.startsWith(&quot;iiop://&quot;) || url.startsWith(&quot;iiopname://&quot;)) {</span>
<span class="nc" id="L283">            return initUsingIiopUrl(orb, url, env);</span>
        } else {
<span class="nc" id="L285">            return initUsingCorbanameUrl(orb, url, env);</span>
        }
    }

    /**
     * Handles &quot;iiop&quot; and &quot;iiopname&quot; URLs (INS 98-10-11)
     */
    private String initUsingIiopUrl(ORB defOrb, String url, Hashtable&lt;?,?&gt; env)
        throws NamingException {

<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (defOrb == null)</span>
<span class="nc" id="L296">            defOrb = getDefaultOrb();</span>

        try {
<span class="nc" id="L299">            IiopUrl parsedUrl = new IiopUrl(url);</span>

<span class="nc" id="L301">            NamingException savedException = null;</span>

<span class="nc bnc" id="L303" title="All 2 branches missed.">            for (IiopUrl.Address addr : parsedUrl.getAddresses()) {</span>

                try {
                    try {
<span class="nc" id="L307">                        String tmpUrl = &quot;corbaloc:iiop:&quot; + addr.host</span>
                            + &quot;:&quot; + addr.port + &quot;/NameService&quot;;
                        if (debug) {
                            System.err.println(&quot;Using url: &quot; + tmpUrl);
                        }
<span class="nc" id="L312">                        org.omg.CORBA.Object rootCtx =</span>
<span class="nc" id="L313">                            defOrb.string_to_object(tmpUrl);</span>
<span class="nc" id="L314">                        setOrbAndRootContext(defOrb, rootCtx);</span>
<span class="nc" id="L315">                        return parsedUrl.getStringName();</span>
<span class="nc" id="L316">                    } catch (Exception e) {} // keep going</span>

                    // Get ORB
                    if (debug) {
                        System.err.println(&quot;Getting ORB for &quot; + addr.host
                            + &quot; and port &quot; + addr.port);
                    }

                    // Assign to fields
<span class="nc" id="L325">                    setOrbAndRootContext(defOrb, (String)null);</span>
<span class="nc" id="L326">                    return parsedUrl.getStringName();</span>

<span class="nc" id="L328">                } catch (NamingException ne) {</span>
<span class="nc" id="L329">                    savedException = ne;</span>
                }
<span class="nc" id="L331">            }</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (savedException != null) {</span>
<span class="nc" id="L333">                throw savedException;</span>
            } else {
<span class="nc" id="L335">                throw new ConfigurationException(&quot;Problem with URL: &quot; + url);</span>
            }
<span class="nc" id="L337">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L338">            throw new ConfigurationException(e.getMessage());</span>
        }
    }

    /**
     * Initializes using &quot;corbaname&quot; URL (INS 99-12-03)
     */
    private String initUsingCorbanameUrl(ORB orb, String url, Hashtable&lt;?,?&gt; env)
        throws NamingException {

<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (orb == null)</span>
<span class="nc" id="L349">                orb = getDefaultOrb();</span>

        try {
<span class="nc" id="L352">            CorbanameUrl parsedUrl = new CorbanameUrl(url);</span>

<span class="nc" id="L354">            String corbaloc = parsedUrl.getLocation();</span>
<span class="nc" id="L355">            String cosName = parsedUrl.getStringName();</span>

<span class="nc" id="L357">            setOrbAndRootContext(orb, corbaloc);</span>

<span class="nc" id="L359">            return parsedUrl.getStringName();</span>
<span class="nc" id="L360">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L361">            throw new ConfigurationException(e.getMessage());</span>
        }
    }

    private void setOrbAndRootContext(ORB orb, String ncIor)
        throws NamingException {
<span class="nc" id="L367">        _orb = orb;</span>
        try {
            org.omg.CORBA.Object ncRef;
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (ncIor != null) {</span>
                if (debug) {
                    System.err.println(&quot;Passing to string_to_object: &quot; + ncIor);
                }
<span class="nc" id="L374">                ncRef = _orb.string_to_object(ncIor);</span>
            } else {
<span class="nc" id="L376">                ncRef = _orb.resolve_initial_references(&quot;NameService&quot;);</span>
            }
            if (debug) {
                System.err.println(&quot;Naming Context Ref: &quot; + ncRef);
            }
<span class="nc" id="L381">            _nc = NamingContextHelper.narrow(ncRef);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (_nc == null) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                if (ncIor != null) {</span>
<span class="nc" id="L384">                    throw new ConfigurationException(</span>
                        &quot;Cannot convert IOR to a NamingContext: &quot; + ncIor);
                } else {
<span class="nc" id="L387">                    throw new ConfigurationException(</span>
&quot;ORB.resolve_initial_references(\&quot;NameService\&quot;) does not return a NamingContext&quot;);
                }
            }
<span class="nc" id="L391">        } catch (org.omg.CORBA.ORBPackage.InvalidName in) {</span>
<span class="nc" id="L392">            NamingException ne =</span>
                new ConfigurationException(
&quot;COS Name Service not registered with ORB under the name 'NameService'&quot;);
<span class="nc" id="L395">            ne.setRootCause(in);</span>
<span class="nc" id="L396">            throw ne;</span>
<span class="nc" id="L397">        } catch (org.omg.CORBA.COMM_FAILURE e) {</span>
<span class="nc" id="L398">            NamingException ne =</span>
                new CommunicationException(&quot;Cannot connect to ORB&quot;);
<span class="nc" id="L400">            ne.setRootCause(e);</span>
<span class="nc" id="L401">            throw ne;</span>
<span class="nc" id="L402">        } catch (org.omg.CORBA.BAD_PARAM e) {</span>
<span class="nc" id="L403">            NamingException ne = new ConfigurationException(</span>
                &quot;Invalid URL or IOR: &quot; + ncIor);
<span class="nc" id="L405">            ne.setRootCause(e);</span>
<span class="nc" id="L406">            throw ne;</span>
<span class="nc" id="L407">        } catch (org.omg.CORBA.INV_OBJREF e) {</span>
<span class="nc" id="L408">            NamingException ne = new ConfigurationException(</span>
                &quot;Invalid object reference: &quot; + ncIor);
<span class="nc" id="L410">            ne.setRootCause(e);</span>
<span class="nc" id="L411">            throw ne;</span>
<span class="nc" id="L412">        }</span>
<span class="nc" id="L413">    }</span>

    private void setOrbAndRootContext(ORB orb, org.omg.CORBA.Object ncRef)
        throws NamingException {
<span class="nc" id="L417">        _orb = orb;</span>
        try {
<span class="nc" id="L419">            _nc = NamingContextHelper.narrow(ncRef);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (_nc == null) {</span>
<span class="nc" id="L421">                throw new ConfigurationException(</span>
                    &quot;Cannot convert object reference to NamingContext: &quot; + ncRef);
            }
<span class="nc" id="L424">        } catch (org.omg.CORBA.COMM_FAILURE e) {</span>
<span class="nc" id="L425">            NamingException ne =</span>
                new CommunicationException(&quot;Cannot connect to ORB&quot;);
<span class="nc" id="L427">            ne.setRootCause(e);</span>
<span class="nc" id="L428">            throw ne;</span>
<span class="nc" id="L429">        }</span>
<span class="nc" id="L430">    }</span>

    private String getStringifiedIor(String url) throws NamingException {
<span class="nc bnc" id="L433" title="All 4 branches missed.">        if (url.startsWith(&quot;IOR:&quot;) || url.startsWith(&quot;corbaloc:&quot;)) {</span>
<span class="nc" id="L434">            return url;</span>
        } else {
<span class="nc" id="L436">            InputStream in = null;</span>
            try {
<span class="nc" id="L438">                URL u = new URL(url);</span>
<span class="nc" id="L439">                in = u.openStream();</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (in != null) {</span>
<span class="nc" id="L441">                    BufferedReader bufin =</span>
                        new BufferedReader(new InputStreamReader(in, &quot;8859_1&quot;));
                    String str;
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    while ((str = bufin.readLine()) != null) {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                        if (str.startsWith(&quot;IOR:&quot;)) {</span>
<span class="nc" id="L446">                            return str;</span>
                        }
                    }
                }
<span class="nc" id="L450">            } catch (IOException e) {</span>
<span class="nc" id="L451">                NamingException ne =</span>
                    new ConfigurationException(&quot;Invalid URL: &quot; + url);
<span class="nc" id="L453">                ne.setRootCause(e);</span>
<span class="nc" id="L454">                throw ne;</span>
            } finally {
<span class="nc" id="L456">                try {</span>
<span class="nc bnc" id="L457" title="All 6 branches missed.">                    if (in != null) {</span>
<span class="nc" id="L458">                        in.close();</span>
                    }
<span class="nc" id="L460">                } catch (IOException e) {</span>
<span class="nc" id="L461">                    NamingException ne =</span>
                        new ConfigurationException(&quot;Invalid URL: &quot; + url);
<span class="nc" id="L463">                    ne.setRootCause(e);</span>
<span class="nc" id="L464">                    throw ne;</span>
<span class="nc" id="L465">                }</span>
            }
<span class="nc" id="L467">            throw new ConfigurationException(url + &quot; does not contain an IOR&quot;);</span>
        }
    }


    /**
      * Does the job of calling the COS Naming API,
      * resolve, and performs the exception mapping. If the resolved
      * object is a COS Naming Context (sub-context), then this function
      * returns a new JNDI naming context object.
      * @param path the NameComponent[] object.
      * @exception NotFound No objects under the name.
      * @exception CannotProceed Unable to obtain a continuation context
      * @exception InvalidName Name not understood.
      * @return Resolved object returned by the COS Name Server.
      */
    java.lang.Object callResolve(NameComponent[] path)
        throws NamingException {
            try {
<span class="nc" id="L486">                org.omg.CORBA.Object obj = _nc.resolve(path);</span>
                try {
<span class="nc" id="L488">                    NamingContext nc =</span>
<span class="nc" id="L489">                        NamingContextHelper.narrow(obj);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if (nc != null) {</span>
<span class="nc" id="L491">                        return new CNCtx(_orb, orbTracker, nc, _env,</span>
<span class="nc" id="L492">                                        makeFullName(path));</span>
                    } else {
<span class="nc" id="L494">                        return obj;</span>
                    }
<span class="nc" id="L496">                } catch (org.omg.CORBA.SystemException e) {</span>
<span class="nc" id="L497">                    return obj;</span>
                }
<span class="nc" id="L499">            } catch (Exception e) {</span>
<span class="nc" id="L500">                throw ExceptionMapper.mapException(e, this, path);</span>
            }
    }

    /**
      * Converts the &quot;String&quot; name into a CompositeName
      * returns the object resolved by the COS Naming api,
      * resolve. Returns the current context if the name is empty.
      * Returns either an org.omg.CORBA.Object or javax.naming.Context object.
      * @param name string used to resolve the object.
      * @exception NamingException See callResolve.
      * @return the resolved object
      */
    public java.lang.Object lookup(String name) throws NamingException {
        if (debug) {
            System.out.println(&quot;Looking up: &quot; + name);
        }
<span class="nc" id="L517">        return lookup(new CompositeName(name));</span>
    }

    /**
      * Converts the &quot;Name&quot; name into a NameComponent[] object and
      * returns the object resolved by the COS Naming api,
      * resolve. Returns the current context if the name is empty.
      * Returns either an org.omg.CORBA.Object or javax.naming.Context object.
      * @param name JNDI Name used to resolve the object.
      * @exception NamingException See callResolve.
      * @return the resolved object
      */
    public java.lang.Object lookup(Name name)
        throws NamingException {
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L532">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (name.size() == 0 )</span>
<span class="nc" id="L535">                return this; // %%% should clone() so that env can be changed</span>
<span class="nc" id="L536">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>

            try {
<span class="nc" id="L539">                java.lang.Object answer = callResolve(path);</span>

                try {
<span class="nc" id="L542">                    return NamingManager.getObjectInstance(answer, name, this, _env);</span>
<span class="nc" id="L543">                } catch (NamingException e) {</span>
<span class="nc" id="L544">                    throw e;</span>
<span class="nc" id="L545">                } catch (Exception e) {</span>
<span class="nc" id="L546">                    NamingException ne = new NamingException(</span>
                        &quot;problem generating object using object factory&quot;);
<span class="nc" id="L548">                    ne.setRootCause(e);</span>
<span class="nc" id="L549">                    throw ne;</span>
                }
<span class="nc" id="L551">            } catch (CannotProceedException cpe) {</span>
<span class="nc" id="L552">                javax.naming.Context cctx = getContinuationContext(cpe);</span>
<span class="nc" id="L553">                return cctx.lookup(cpe.getRemainingName());</span>
            }
    }

    /**
      * Performs bind or rebind in the context depending on whether the
      * flag rebind is set. The only objects allowed to be bound are of
      * types org.omg.CORBA.Object, org.omg.CosNaming.NamingContext.
      * You can use a state factory to turn other objects (such as
      * Remote) into these acceptable forms.
      *
      * Uses the COS Naming apis bind/rebind or
      * bind_context/rebind_context.
      * @param pth NameComponent[] object
      * @param obj Object to be bound.
      * @param rebind perform rebind ? if true performs a rebind.
      * @exception NotFound No objects under the name.
      * @exception CannotProceed Unable to obtain a continuation context
      * @exception AlreadyBound An object is already bound to this name.
      */
    private void callBindOrRebind(NameComponent[] pth, Name name,
        java.lang.Object obj, boolean rebind) throws NamingException {
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L576">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
            try {
                // Call state factories to convert
<span class="nc" id="L580">                obj = NamingManager.getStateToBind(obj, name, this, _env);</span>

<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (obj instanceof CNCtx) {</span>
                    // Use naming context object reference
<span class="nc" id="L584">                    obj = ((CNCtx)obj)._nc;</span>
                }

<span class="nc bnc" id="L587" title="All 2 branches missed.">                if ( obj instanceof org.omg.CosNaming.NamingContext) {</span>
<span class="nc" id="L588">                    NamingContext nobj =</span>
<span class="nc" id="L589">                        NamingContextHelper.narrow((org.omg.CORBA.Object)obj);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    if (rebind)</span>
<span class="nc" id="L591">                        _nc.rebind_context(pth,nobj);</span>
                    else
<span class="nc" id="L593">                        _nc.bind_context(pth,nobj);</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">                } else if (obj instanceof org.omg.CORBA.Object) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                    if (rebind)</span>
<span class="nc" id="L597">                        _nc.rebind(pth,(org.omg.CORBA.Object)obj);</span>
                    else
<span class="nc" id="L599">                        _nc.bind(pth,(org.omg.CORBA.Object)obj);</span>
                }
                else
<span class="nc" id="L602">                    throw new IllegalArgumentException(</span>
                &quot;Only instances of org.omg.CORBA.Object can be bound&quot;);
<span class="nc" id="L604">            } catch (BAD_PARAM e) {</span>
                // probably narrow() failed?
<span class="nc" id="L606">                NamingException ne = new NotContextException(name.toString());</span>
<span class="nc" id="L607">                ne.setRootCause(e);</span>
<span class="nc" id="L608">                throw ne;</span>
<span class="nc" id="L609">            } catch (Exception e) {</span>
<span class="nc" id="L610">                throw ExceptionMapper.mapException(e, this, pth);</span>
<span class="nc" id="L611">            }</span>
<span class="nc" id="L612">    }</span>

    /**
      * Converts the &quot;Name&quot; name into a NameComponent[] object and
      * performs the bind operation. Uses callBindOrRebind. Throws an
      * invalid name exception if the name is empty. We need a name to
      * bind the object even when we work within the current context.
      * @param name JNDI Name object
      * @param obj Object to be bound.
      * @exception NamingException See callBindOrRebind
      */
    public  void bind(Name name, java.lang.Object obj)
        throws NamingException {
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (name.size() == 0 ) {</span>
<span class="nc" id="L626">                throw new InvalidNameException(&quot;Name is empty&quot;);</span>
            }

            if (debug) {
                System.out.println(&quot;Bind: &quot; + name);
            }
<span class="nc" id="L632">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>

            try {
<span class="nc" id="L635">                callBindOrRebind(path, name, obj, false);</span>
<span class="nc" id="L636">            } catch (CannotProceedException e) {</span>
<span class="nc" id="L637">                javax.naming.Context cctx = getContinuationContext(e);</span>
<span class="nc" id="L638">                cctx.bind(e.getRemainingName(), obj);</span>
<span class="nc" id="L639">            }</span>
<span class="nc" id="L640">    }</span>

    static private javax.naming.Context
        getContinuationContext(CannotProceedException cpe)
        throws NamingException {
        try {
<span class="nc" id="L646">            return NamingManager.getContinuationContext(cpe);</span>
<span class="nc" id="L647">        } catch (CannotProceedException e) {</span>
<span class="nc" id="L648">            java.lang.Object resObj = e.getResolvedObj();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (resObj instanceof Reference) {</span>
<span class="nc" id="L650">                Reference ref = (Reference)resObj;</span>
<span class="nc" id="L651">                RefAddr addr = ref.get(&quot;nns&quot;);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (addr.getContent() instanceof javax.naming.Context) {</span>
<span class="nc" id="L653">                    NamingException ne = new NameNotFoundException(</span>
                        &quot;No object reference bound for specified name&quot;);
<span class="nc" id="L655">                    ne.setRootCause(cpe.getRootCause());</span>
<span class="nc" id="L656">                    ne.setRemainingName(cpe.getRemainingName());</span>
<span class="nc" id="L657">                    throw ne;</span>
                }
            }
<span class="nc" id="L660">            throw e;</span>
        }
    }

    /**
      * Converts the &quot;String&quot; name into a CompositeName object and
      * performs the bind operation. Uses callBindOrRebind. Throws an
      * invalid name exception if the name is empty.
      * @param name string
      * @param obj Object to be bound.
      * @exception NamingException See callBindOrRebind
      */
    public void bind(String name, java.lang.Object obj) throws NamingException {
<span class="nc" id="L673">        bind(new CompositeName(name), obj);</span>
<span class="nc" id="L674">    }</span>

    /**
      * Converts the &quot;Name&quot; name into a NameComponent[] object and
      * performs the rebind operation. Uses callBindOrRebind. Throws an
      * invalid name exception if the name is empty. We must have a name
      * to rebind the object to even if we are working within the current
      * context.
      * @param name string
      * @param obj Object to be bound.
      * @exception NamingException See callBindOrRebind
      */
    public  void rebind(Name name, java.lang.Object obj)
        throws NamingException {
<span class="nc bnc" id="L688" title="All 2 branches missed.">            if (name.size() == 0 ) {</span>
<span class="nc" id="L689">                throw new InvalidNameException(&quot;Name is empty&quot;);</span>
            }
<span class="nc" id="L691">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>
            try {
<span class="nc" id="L693">                callBindOrRebind(path, name, obj, true);</span>
<span class="nc" id="L694">            } catch (CannotProceedException e) {</span>
<span class="nc" id="L695">                javax.naming.Context cctx = getContinuationContext(e);</span>
<span class="nc" id="L696">                cctx.rebind(e.getRemainingName(), obj);</span>
<span class="nc" id="L697">            }</span>
<span class="nc" id="L698">    }</span>

    /**
      * Converts the &quot;String&quot; name into a CompositeName object and
      * performs the rebind operation. Uses callBindOrRebind. Throws an
      * invalid name exception if the name is an empty string.
      * @param name string
      * @param obj Object to be bound.
      * @exception NamingException See callBindOrRebind
      */
    public  void rebind(String name, java.lang.Object obj)
        throws NamingException {
<span class="nc" id="L710">            rebind(new CompositeName(name), obj);</span>
<span class="nc" id="L711">    }</span>

    /**
      * Calls the unbind api of COS Naming and uses the exception mapper
      * class  to map the exceptions
      * @param path NameComponent[] object
      * @exception NotFound No objects under the name. If leaf
      * is not found, that's OK according to the JNDI spec
      * @exception CannotProceed Unable to obtain a continuation context
      * @exception InvalidName Name not understood.
      */
    private void callUnbind(NameComponent[] path) throws NamingException {
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L724">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
            try {
<span class="nc" id="L727">                _nc.unbind(path);</span>
<span class="nc" id="L728">            } catch (NotFound e) {</span>
                // If leaf is the one missing, return success
                // as per JNDI spec

<span class="nc bnc" id="L732" title="All 2 branches missed.">                if (leafNotFound(e, path[path.length-1])) {</span>
                    // do nothing
                } else {
<span class="nc" id="L735">                    throw ExceptionMapper.mapException(e, this, path);</span>
                }
<span class="nc" id="L737">            } catch (Exception e) {</span>
<span class="nc" id="L738">                throw ExceptionMapper.mapException(e, this, path);</span>
<span class="nc" id="L739">            }</span>
<span class="nc" id="L740">    }</span>

    private boolean leafNotFound(NotFound e, NameComponent leaf) {

        // This test is not foolproof because some name servers
        // always just return one component in rest_of_name
        // so you might not be able to tell whether that is
        // the leaf (e.g. aa/aa/aa, which one is missing?)

        NameComponent rest;
<span class="nc bnc" id="L750" title="All 4 branches missed.">        return e.why.value() == NotFoundReason._missing_node &amp;&amp;</span>
            e.rest_of_name.length == 1 &amp;&amp;
<span class="nc bnc" id="L752" title="All 6 branches missed.">            (rest=e.rest_of_name[0]).id.equals(leaf.id) &amp;&amp;</span>
            (rest.kind == leaf.kind ||
<span class="nc bnc" id="L754" title="All 2 branches missed.">             (rest.kind != null &amp;&amp; rest.kind.equals(leaf.kind)));</span>
    }

    /**
      * Converts the &quot;String&quot; name into a CompositeName object and
      * performs the unbind operation. Uses callUnbind. If the name is
      * empty, throws an invalid name exception. Do we unbind the
      * current context (JNDI spec says work with the current context if
      * the name is empty) ?
      * @param name string
      * @exception NamingException See callUnbind
      */
    public  void unbind(String name) throws NamingException {
<span class="nc" id="L767">        unbind(new CompositeName(name));</span>
<span class="nc" id="L768">    }</span>

    /**
      * Converts the &quot;Name&quot; name into a NameComponent[] object and
      * performs the unbind operation. Uses callUnbind. Throws an
      * invalid name exception if the name is empty.
      * @param name string
      * @exception NamingException See callUnbind
      */
    public  void unbind(Name name)
        throws NamingException {
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if (name.size() == 0 )</span>
<span class="nc" id="L780">                throw new InvalidNameException(&quot;Name is empty&quot;);</span>
<span class="nc" id="L781">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>
            try {
<span class="nc" id="L783">                callUnbind(path);</span>
<span class="nc" id="L784">            } catch (CannotProceedException e) {</span>
<span class="nc" id="L785">                javax.naming.Context cctx = getContinuationContext(e);</span>
<span class="nc" id="L786">                cctx.unbind(e.getRemainingName());</span>
<span class="nc" id="L787">            }</span>
<span class="nc" id="L788">    }</span>

    /**
      * Renames an object. Since COS Naming does not support a rename
      * api, this method unbinds the object with the &quot;oldName&quot; and
      * creates a new binding.
      * @param oldName string, existing name for the binding.
      * @param newName string, name used to replace.
      * @exception NamingException See bind
      */
    public  void rename(String oldName,String newName)
        throws NamingException {
<span class="nc" id="L800">            rename(new CompositeName(oldName), new CompositeName(newName));</span>
<span class="nc" id="L801">    }</span>

    /**
      * Renames an object. Since COS Naming does not support a rename
      * api, this method unbinds the object with the &quot;oldName&quot; and
      * creates a new binding.
      * @param oldName JNDI Name, existing name for the binding.
      * @param newName JNDI Name, name used to replace.
      * @exception NamingException See bind
      */
    public  void rename(Name oldName,Name newName)
        throws NamingException {
<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L814">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
<span class="nc bnc" id="L816" title="All 4 branches missed.">            if (oldName.size() == 0 || newName.size() == 0)</span>
<span class="nc" id="L817">                throw new InvalidNameException(&quot;One or both names empty&quot;);</span>
<span class="nc" id="L818">            java.lang.Object obj = lookup(oldName);</span>
<span class="nc" id="L819">            bind(newName,obj);</span>
<span class="nc" id="L820">            unbind(oldName);</span>
<span class="nc" id="L821">    }</span>

    /**
      * Returns a NameClassEnumeration object which has a list of name
      * class pairs. Lists the current context if the name is empty.
      * @param name string
      * @exception NamingException All exceptions thrown by lookup
      * with a non-null argument
      * @return a list of name-class objects as a NameClassEnumeration.
      */
    public  NamingEnumeration&lt;NameClassPair&gt; list(String name) throws NamingException {
<span class="nc" id="L832">            return list(new CompositeName(name));</span>
    }

    /**
      * Returns a NameClassEnumeration object which has a list of name
      * class pairs. Lists the current context if the name is empty.
      * @param name JNDI Name
      * @exception NamingException All exceptions thrown by lookup
      * @return a list of name-class objects as a NameClassEnumeration.
      */
    @SuppressWarnings(&quot;unchecked&quot;)
    public  NamingEnumeration&lt;NameClassPair&gt; list(Name name)
        throws NamingException {
<span class="nc" id="L845">            return (NamingEnumeration)listBindings(name);</span>
    }

    /**
      * Returns a BindingEnumeration object which has a list of name
      * object pairs. Lists the current context if the name is empty.
      * @param name string
      * @exception NamingException all exceptions returned by lookup
      * @return a list of bindings as a BindingEnumeration.
      */
    public  NamingEnumeration&lt;javax.naming.Binding&gt; listBindings(String name)
        throws NamingException {
<span class="nc" id="L857">            return listBindings(new CompositeName(name));</span>
    }

    /**
      * Returns a BindingEnumeration object which has a list of name
      * class pairs. Lists the current context if the name is empty.
      * @param name JNDI Name
      * @exception NamingException all exceptions returned by lookup.
      * @return a list of bindings as a BindingEnumeration.
      */
    public  NamingEnumeration&lt;javax.naming.Binding&gt; listBindings(Name name)
        throws NamingException {
<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L870">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
<span class="nc bnc" id="L872" title="All 2 branches missed.">            if (name.size() &gt; 0) {</span>
                try {
<span class="nc" id="L874">                    java.lang.Object obj = lookup(name);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                    if (obj instanceof CNCtx) {</span>
<span class="nc" id="L876">                        return new CNBindingEnumeration(</span>
                                        (CNCtx) obj, true, _env);
                    } else {
<span class="nc" id="L879">                        throw new NotContextException(name.toString());</span>
                    }
<span class="nc" id="L881">                } catch (NamingException ne) {</span>
<span class="nc" id="L882">                    throw ne;</span>
<span class="nc" id="L883">                } catch (BAD_PARAM e) {</span>
<span class="nc" id="L884">                    NamingException ne =</span>
<span class="nc" id="L885">                        new NotContextException(name.toString());</span>
<span class="nc" id="L886">                    ne.setRootCause(e);</span>
<span class="nc" id="L887">                    throw ne;</span>
                }
            }
<span class="nc" id="L890">            return new CNBindingEnumeration(this, false, _env);</span>
    }

    /**
      * Calls the destroy on the COS Naming Server
      * @param nc The NamingContext object to use.
      * @exception NotEmpty when the context is not empty and cannot be destroyed.
      */
    private void callDestroy(NamingContext nc)
        throws NamingException {
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L901">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
            try {
<span class="nc" id="L904">                nc.destroy();</span>
<span class="nc" id="L905">            } catch (Exception e) {</span>
<span class="nc" id="L906">                throw ExceptionMapper.mapException(e, this, null);</span>
<span class="nc" id="L907">            }</span>
<span class="nc" id="L908">    }</span>

    /**
      * Uses the callDestroy function to destroy the context. If name is
      * empty destroys the current context.
      * @param name string
      * @exception OperationNotSupportedException when list is invoked
      * with a non-null argument
      */
    public  void destroySubcontext(String name) throws NamingException {
<span class="nc" id="L918">        destroySubcontext(new CompositeName(name));</span>
<span class="nc" id="L919">    }</span>

    /**
      * Uses the callDestroy function to destroy the context. Destroys
      * the current context if name is empty.
      * @param name JNDI Name
      * @exception OperationNotSupportedException when list is invoked
      * with a non-null argument
      */
    public  void destroySubcontext(Name name)
        throws NamingException {
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L931">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
<span class="nc" id="L933">            NamingContext the_nc = _nc;</span>
<span class="nc" id="L934">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if ( name.size() &gt; 0) {</span>
                try {
<span class="nc" id="L937">                    javax.naming.Context ctx =</span>
<span class="nc" id="L938">                        (javax.naming.Context) callResolve(path);</span>
<span class="nc" id="L939">                    CNCtx cnc = (CNCtx)ctx;</span>
<span class="nc" id="L940">                    the_nc = cnc._nc;</span>
<span class="nc" id="L941">                    cnc.close(); //remove the reference to the context</span>
<span class="nc" id="L942">                } catch (ClassCastException e) {</span>
<span class="nc" id="L943">                    throw new NotContextException(name.toString());</span>
<span class="nc" id="L944">                } catch (CannotProceedException e) {</span>
<span class="nc" id="L945">                    javax.naming.Context cctx = getContinuationContext(e);</span>
<span class="nc" id="L946">                    cctx.destroySubcontext(e.getRemainingName());</span>
<span class="nc" id="L947">                    return;</span>
<span class="nc" id="L948">                } catch (NameNotFoundException e) {</span>
                    // If leaf is the one missing, return success
                    // as per JNDI spec

<span class="nc bnc" id="L952" title="All 2 branches missed.">                    if (e.getRootCause() instanceof NotFound &amp;&amp;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                        leafNotFound((NotFound)e.getRootCause(),</span>
                            path[path.length-1])) {
<span class="nc" id="L955">                        return; // leaf missing OK</span>
                    }
<span class="nc" id="L957">                    throw e;</span>
<span class="nc" id="L958">                } catch (NamingException e) {</span>
<span class="nc" id="L959">                    throw e;</span>
<span class="nc" id="L960">                }</span>
            }
<span class="nc" id="L962">            callDestroy(the_nc);</span>
<span class="nc" id="L963">            callUnbind(path);</span>
<span class="nc" id="L964">    }</span>

    /**
      * Calls the bind_new_context COS naming api to create a new subcontext.
      * @param path NameComponent[] object
      * @exception NotFound No objects under the name.
      * @exception CannotProceed Unable to obtain a continuation context
      * @exception InvalidName Name not understood.
      * @exception AlreadyBound An object is already bound to this name.
      * @return the new context object.
      */
    private javax.naming.Context callBindNewContext(NameComponent[] path)
        throws NamingException {
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (_nc == null)</span>
<span class="nc" id="L978">                throw new ConfigurationException(</span>
                    &quot;Context does not have a corresponding NamingContext&quot;);
            try {
<span class="nc" id="L981">                NamingContext nctx = _nc.bind_new_context(path);</span>
<span class="nc" id="L982">                return new CNCtx(_orb, orbTracker, nctx, _env,</span>
<span class="nc" id="L983">                                        makeFullName(path));</span>
<span class="nc" id="L984">            } catch (Exception e) {</span>
<span class="nc" id="L985">                throw ExceptionMapper.mapException(e, this, path);</span>
            }
    }

    /**
      * Uses the callBindNewContext convenience function to create a new
      * context. Throws an invalid name exception if the name is empty.
      * @param name string
      * @exception NamingException See callBindNewContext
      * @return the new context object.
      */
    public  javax.naming.Context createSubcontext(String name)
        throws NamingException {
<span class="nc" id="L998">            return createSubcontext(new CompositeName(name));</span>
    }

    /**
      * Uses the callBindNewContext convenience function to create a new
      * context. Throws an invalid name exception if the name is empty.
      * @param name string
      * @exception NamingException See callBindNewContext
      * @return the new context object.
      */
    public  javax.naming.Context createSubcontext(Name name)
        throws NamingException {
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if (name.size() == 0 )</span>
<span class="nc" id="L1011">                throw new InvalidNameException(&quot;Name is empty&quot;);</span>
<span class="nc" id="L1012">            NameComponent[] path = CNNameParser.nameToCosName(name);</span>
            try {
<span class="nc" id="L1014">                return callBindNewContext(path);</span>
<span class="nc" id="L1015">            } catch (CannotProceedException e) {</span>
<span class="nc" id="L1016">                javax.naming.Context cctx = getContinuationContext(e);</span>
<span class="nc" id="L1017">                return cctx.createSubcontext(e.getRemainingName());</span>
            }
    }

    /**
      * Is mapped to resolve in the COS Naming api.
      * @param name string
      * @exception NamingException See lookup.
      * @return the resolved object.
      */
    public  java.lang.Object lookupLink(String name) throws NamingException {
<span class="nc" id="L1028">            return lookupLink(new CompositeName(name));</span>
    }

    /**
      * Is mapped to resolve in the COS Naming api.
      * @param name string
      * @exception NamingException See lookup.
      * @return the resolved object.
      */
    public  java.lang.Object lookupLink(Name name) throws NamingException {
<span class="nc" id="L1038">            return lookup(name);</span>
    }

    /**
      * Allow access to the name parser object.
      * @param String JNDI name, is ignored since there is only one Name
      * Parser object.
      * @exception NamingException --
      * @return NameParser object
      */
    public  NameParser getNameParser(String name) throws NamingException {
<span class="nc" id="L1049">        return parser;</span>
    }

    /**
      * Allow access to the name parser object.
      * @param Name JNDI name, is ignored since there is only one Name
      * Parser object.
      * @exception NamingException --
      * @return NameParser object
      */
    public  NameParser getNameParser(Name name) throws NamingException {
<span class="nc" id="L1060">        return parser;</span>
    }

    /**
      * Returns the current environment.
      * @return Environment.
      */
    @SuppressWarnings(&quot;unchecked&quot;)
    public  Hashtable&lt;String, java.lang.Object&gt; getEnvironment() throws NamingException {
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (_env == null) {</span>
<span class="nc" id="L1070">            return new Hashtable&lt;&gt;(5, 0.75f);</span>
        } else {
<span class="nc" id="L1072">            return (Hashtable&lt;String, java.lang.Object&gt;)_env.clone();</span>
        }
    }

    public String composeName(String name, String prefix) throws NamingException {
<span class="nc" id="L1077">        return composeName(new CompositeName(name),</span>
<span class="nc" id="L1078">            new CompositeName(prefix)).toString();</span>
    }

    public Name composeName(Name name, Name prefix) throws NamingException {
<span class="nc" id="L1082">        Name result = (Name)prefix.clone();</span>
<span class="nc" id="L1083">        return result.addAll(name);</span>
    }

    /**
      * Adds to the environment for the current context.
      * Record change but do not reinitialize ORB.
      *
      * @param propName The property name.
      * @param propVal  The ORB.
      * @return the previous value of this property if any.
      */
    @SuppressWarnings(&quot;unchecked&quot;)
    public java.lang.Object addToEnvironment(String propName,
        java.lang.Object propValue)
        throws NamingException {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            if (_env == null) {</span>
<span class="nc" id="L1099">                _env = new Hashtable&lt;&gt;(7, 0.75f);</span>
            } else {
                // copy-on-write
<span class="nc" id="L1102">                _env = (Hashtable&lt;String, java.lang.Object&gt;)_env.clone();</span>
            }

<span class="nc" id="L1105">            return _env.put(propName, propValue);</span>
    }

    // Record change but do not reinitialize ORB
    @SuppressWarnings(&quot;unchecked&quot;)
    public java.lang.Object removeFromEnvironment(String propName)
        throws NamingException {
<span class="nc bnc" id="L1112" title="All 4 branches missed.">            if (_env != null  &amp;&amp; _env.get(propName) != null) {</span>
                // copy-on-write
<span class="nc" id="L1114">                _env = (Hashtable&lt;String, java.lang.Object&gt;)_env.clone();</span>
<span class="nc" id="L1115">                return _env.remove(propName);</span>
            }
<span class="nc" id="L1117">            return null;</span>
    }

    synchronized public void incEnumCount() {
<span class="nc" id="L1121">        enumCount++;</span>
        if (debug) {
            System.out.println(&quot;incEnumCount, new count:&quot; + enumCount);
        }
<span class="nc" id="L1125">    }</span>

    synchronized public void decEnumCount()
            throws NamingException {
<span class="nc" id="L1129">        enumCount--;</span>
        if (debug) {
            System.out.println(&quot;decEnumCount, new count:&quot; + enumCount +
                        &quot;    isCloseCalled:&quot; + isCloseCalled);
        }
<span class="nc bnc" id="L1134" title="All 4 branches missed.">        if ((enumCount == 0) &amp;&amp; isCloseCalled) {</span>
<span class="nc" id="L1135">            close();</span>
        }
<span class="nc" id="L1137">    }</span>

    synchronized public void close() throws NamingException {

<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (enumCount &gt; 0) {</span>
<span class="nc" id="L1142">            isCloseCalled = true;</span>
<span class="nc" id="L1143">            return;</span>
        }

        // Never destroy an orb in CNCtx.
        // The orb we have is either the shared/default orb, or one passed in to a constructor
        // from elsewhere, so that orb is somebody else's reponsibility.
<span class="nc" id="L1149">    }</span>

    protected void finalize() {
        try {
<span class="nc" id="L1153">            close();</span>
<span class="nc" id="L1154">        } catch (NamingException e) {</span>
            // ignore failures
<span class="nc" id="L1156">        }</span>
<span class="nc" id="L1157">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>