<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CNNameParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.cosnaming</a> &gt; <span class="el_source">CNNameParser.java</span></div><h1>CNNameParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.cosnaming;

import javax.naming.*;
import java.util.Properties;
import java.util.Vector;
import java.util.Enumeration;

import org.omg.CosNaming.NameComponent;

/**
  * Parsing routines for NameParser as well as COS Naming stringified names.
  * This is used by CNCtx to create a NameComponent[] object and vice versa.
  * It follows Section 4.5 of Interoperable Naming Service (INS) 98-10-11.
  * In summary, the stringified form is a left-to-right, forward-slash
  * separated name. id and kinds are separated by '.'. backslash is the
  * escape character.
  *
  * @author Rosanna Lee
  */

final public class CNNameParser implements NameParser {

<span class="nc" id="L48">    private static final Properties mySyntax = new Properties();</span>
    private static final char kindSeparator = '.';
    private static final char compSeparator = '/';
    private static final char escapeChar = '\\';
    static {
<span class="nc" id="L53">        mySyntax.put(&quot;jndi.syntax.direction&quot;, &quot;left_to_right&quot;);</span>
<span class="nc" id="L54">        mySyntax.put(&quot;jndi.syntax.separator&quot;, &quot;&quot;+compSeparator);</span>
<span class="nc" id="L55">        mySyntax.put(&quot;jndi.syntax.escape&quot;, &quot;&quot;+escapeChar);</span>
<span class="nc" id="L56">    };</span>

  /**
    * Constructs a new name parser for parsing names in INS syntax.
    */
<span class="nc" id="L61">    public CNNameParser() {</span>
<span class="nc" id="L62">    }</span>

  /**
    * Returns a CompoundName given a string in INS syntax.
    * @param name The non-null string representation of the name.
    * @return a non-null CompoundName
    */
    public Name parse(String name) throws NamingException {
<span class="nc" id="L70">        Vector&lt;String&gt; comps = insStringToStringifiedComps(name);</span>
<span class="nc" id="L71">        return new CNCompoundName(comps.elements());</span>
    }

    /**
     * Creates a NameComponent[] from a Name structure.
     * Used by CNCtx to convert the input Name arg into a NameComponent[].
     * @param a CompoundName or a CompositeName;
     * each component must be the stringified form of a NameComponent.
     */
    static NameComponent[] nameToCosName(Name name)
        throws InvalidNameException {
<span class="nc" id="L82">            int len = name.size();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L84">                return new NameComponent[0];</span>
            }

<span class="nc" id="L87">            NameComponent[] answer = new NameComponent[len];</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L89">                answer[i] = parseComponent(name.get(i));</span>
            }
<span class="nc" id="L91">            return answer;</span>
    }

    /**
     * Returns the INS stringified form of a NameComponent[].
     * Used by CNCtx.getNameInNamespace(), CNCompoundName.toString().
     */
    static String cosNameToInsString(NameComponent[] cname) {
<span class="nc" id="L99">      StringBuffer str = new StringBuffer();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">      for ( int i = 0; i &lt; cname.length; i++) {</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">          if ( i &gt; 0) {</span>
<span class="nc" id="L102">              str.append(compSeparator);</span>
          }
<span class="nc" id="L104">          str.append(stringifyComponent(cname[i]));</span>
      }
<span class="nc" id="L106">      return str.toString();</span>
    }

    /**
     * Creates a CompositeName from a NameComponent[].
     * Used by ExceptionMapper and CNBindingEnumeration to convert
     * a NameComponent[] into a composite name.
     */
    static Name cosNameToName(NameComponent[] cname) {
<span class="nc" id="L115">        Name nm = new CompositeName();</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">        for ( int i = 0; cname != null &amp;&amp; i &lt; cname.length; i++) {</span>
            try {
<span class="nc" id="L118">                nm.add(stringifyComponent(cname[i]));</span>
<span class="nc" id="L119">            } catch (InvalidNameException e) {</span>
                // ignore
<span class="nc" id="L121">            }</span>
        }
<span class="nc" id="L123">        return nm;</span>
    }

    /**
     * Converts an INS-syntax string name into a Vector in which
     * each element of the vector contains a stringified form of
     * a NameComponent.
     */
    private static Vector&lt;String&gt; insStringToStringifiedComps(String str)
        throws InvalidNameException {

<span class="nc" id="L134">        int len = str.length();</span>
<span class="nc" id="L135">        Vector&lt;String&gt; components = new Vector&lt;&gt;(10);</span>
<span class="nc" id="L136">        char[] id = new char[len];</span>
<span class="nc" id="L137">        char[] kind = new char[len];</span>
        int idCount, kindCount;
        boolean idMode;
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int i = 0; i &lt; len; ) {</span>
<span class="nc" id="L141">            idCount = kindCount = 0; // reset for new component</span>
<span class="nc" id="L142">            idMode = true;           // always start off parsing id</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            while (i &lt; len) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                if (str.charAt(i) == compSeparator) {</span>
<span class="nc" id="L145">                    break;</span>

<span class="nc bnc" id="L147" title="All 2 branches missed.">                } else if (str.charAt(i) == escapeChar) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    if (i + 1 &gt;= len) {</span>
<span class="nc" id="L149">                        throw new InvalidNameException(str +</span>
                            &quot;: unescaped \\ at end of component&quot;);
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    } else if (isMeta(str.charAt(i+1))) {</span>
<span class="nc" id="L152">                        ++i; // skip escape and let meta through</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                        if (idMode) {</span>
<span class="nc" id="L154">                            id[idCount++] = str.charAt(i++);</span>
                        } else {
<span class="nc" id="L156">                            kind[kindCount++] = str.charAt(i++);</span>
                        }
                    } else {
<span class="nc" id="L159">                        throw new InvalidNameException(str +</span>
                            &quot;: invalid character being escaped&quot;);
                    }

<span class="nc bnc" id="L163" title="All 4 branches missed.">                } else if (idMode &amp;&amp; str.charAt(i) == kindSeparator) {</span>
                    // just look for the first kindSeparator
<span class="nc" id="L165">                    ++i; // skip kind separator</span>
<span class="nc" id="L166">                    idMode = false;</span>

                } else {
<span class="nc bnc" id="L169" title="All 2 branches missed.">                    if (idMode) {</span>
<span class="nc" id="L170">                        id[idCount++] = str.charAt(i++);</span>
                    } else {
<span class="nc" id="L172">                        kind[kindCount++] = str.charAt(i++);</span>
                    }
                }
            }
<span class="nc" id="L176">            components.addElement(stringifyComponent(</span>
                new NameComponent(new String(id, 0, idCount),
                    new String(kind, 0, kindCount))));

<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (i &lt; len) {</span>
<span class="nc" id="L181">                ++i; // skip separator</span>
            }
        }

<span class="nc" id="L185">        return components;</span>
    }

    /**
     * Return a NameComponent given its stringified form.
     */
    private static NameComponent parseComponent(String compStr)
    throws InvalidNameException {
<span class="nc" id="L193">        NameComponent comp = new NameComponent();</span>
<span class="nc" id="L194">        int kindSep = -1;</span>
<span class="nc" id="L195">        int len = compStr.length();</span>

<span class="nc" id="L197">        int j = 0;</span>
<span class="nc" id="L198">        char[] newStr = new char[len];</span>
<span class="nc" id="L199">        boolean escaped = false;</span>

        // Find the kind separator
<span class="nc bnc" id="L202" title="All 4 branches missed.">        for (int i = 0; i &lt; len &amp;&amp; kindSep &lt; 0; i++) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (escaped) {</span>
<span class="nc" id="L204">                newStr[j++] = compStr.charAt(i);</span>
<span class="nc" id="L205">                escaped = false;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            } else if (compStr.charAt(i) == escapeChar) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (i + 1 &gt;= len) {</span>
<span class="nc" id="L208">                    throw new InvalidNameException(compStr +</span>
                            &quot;: unescaped \\ at end of component&quot;);
<span class="nc bnc" id="L210" title="All 2 branches missed.">                } else if (isMeta(compStr.charAt(i+1))) {</span>
<span class="nc" id="L211">                    escaped = true;</span>
                } else {
<span class="nc" id="L213">                    throw new InvalidNameException(compStr +</span>
                        &quot;: invalid character being escaped&quot;);
                }
<span class="nc bnc" id="L216" title="All 2 branches missed.">            } else if (compStr.charAt(i) == kindSeparator) {</span>
<span class="nc" id="L217">                kindSep = i;</span>
            } else {
<span class="nc" id="L219">                newStr[j++] = compStr.charAt(i);</span>
            }
        }

        // Set id
<span class="nc" id="L224">        comp.id = new String(newStr, 0, j);</span>

        // Set kind
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (kindSep &lt; 0) {</span>
<span class="nc" id="L228">            comp.kind = &quot;&quot;;  // no kind separator</span>
        } else {
            // unescape kind
<span class="nc" id="L231">            j = 0;</span>
<span class="nc" id="L232">            escaped = false;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            for (int i = kindSep+1; i &lt; len; i++) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (escaped) {</span>
<span class="nc" id="L235">                    newStr[j++] = compStr.charAt(i);</span>
<span class="nc" id="L236">                    escaped = false;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                } else if (compStr.charAt(i) == escapeChar) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                    if (i + 1 &gt;= len) {</span>
<span class="nc" id="L239">                        throw new InvalidNameException(compStr +</span>
                            &quot;: unescaped \\ at end of component&quot;);
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    } else if (isMeta(compStr.charAt(i+1))) {</span>
<span class="nc" id="L242">                        escaped = true;</span>
                    } else {
<span class="nc" id="L244">                        throw new InvalidNameException(compStr +</span>
                            &quot;: invalid character being escaped&quot;);
                    }
                } else {
<span class="nc" id="L248">                    newStr[j++] = compStr.charAt(i);</span>
                }
            }
<span class="nc" id="L251">            comp.kind = new String(newStr, 0, j);</span>
        }
<span class="nc" id="L253">        return comp;</span>
    }

    private static String stringifyComponent(NameComponent comp) {
<span class="nc" id="L257">        StringBuffer one = new StringBuffer(escape(comp.id));</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (comp.kind != null &amp;&amp; !comp.kind.equals(&quot;&quot;)) {</span>
<span class="nc" id="L259">            one.append(kindSeparator + escape(comp.kind));</span>
        }
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (one.length() == 0) {</span>
<span class="nc" id="L262">            return &quot;&quot;+kindSeparator;  // if neither id nor kind specified</span>
        } else {
<span class="nc" id="L264">            return one.toString();</span>
        }
    }

    /**
     * Returns a string with '.', '\', '/' escaped. Used when
     * stringifying the name into its INS stringified form.
     */
    private static String escape(String str) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (str.indexOf(kindSeparator) &lt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            str.indexOf(compSeparator) &lt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            str.indexOf(escapeChar) &lt; 0) {</span>
<span class="nc" id="L276">            return str;                         // no meta characters to escape</span>
        } else {
<span class="nc" id="L278">            int len = str.length();</span>
<span class="nc" id="L279">            int j = 0;</span>
<span class="nc" id="L280">            char[] newStr = new char[len+len];</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (isMeta(str.charAt(i))) {</span>
<span class="nc" id="L283">                    newStr[j++] = escapeChar;   // escape meta character</span>
                }
<span class="nc" id="L285">                newStr[j++] = str.charAt(i);</span>
            }
<span class="nc" id="L287">            return new String(newStr, 0, j);</span>
        }
    }

    /**
     * In INS, there are three meta characters: '.', '/' and '\'.
     */
    private static boolean isMeta(char ch) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        switch (ch) {</span>
        case kindSeparator:
        case compSeparator:
        case escapeChar:
<span class="nc" id="L299">            return true;</span>
        }
<span class="nc" id="L301">        return false;</span>
    }

    /**
     * An implementation of CompoundName that bypasses the parsing
     * and stringifying code of the default CompoundName.
     */
    static final class CNCompoundName extends CompoundName {
        CNCompoundName(Enumeration&lt;String&gt; enum_) {
<span class="nc" id="L310">            super(enum_, CNNameParser.mySyntax);</span>
<span class="nc" id="L311">        }</span>

        public Object clone() {
<span class="nc" id="L314">            return new CNCompoundName(getAll());</span>
        }

        public Name getPrefix(int posn) {
<span class="nc" id="L318">            Enumeration&lt;String&gt; comps = super.getPrefix(posn).getAll();</span>
<span class="nc" id="L319">            return new CNCompoundName(comps);</span>
        }

        public Name getSuffix(int posn) {
<span class="nc" id="L323">            Enumeration&lt;String&gt; comps = super.getSuffix(posn).getAll();</span>
<span class="nc" id="L324">            return new CNCompoundName(comps);</span>
        }

        public String toString() {
            try {
                // Convert Name to NameComponent[] then stringify
<span class="nc" id="L330">                return cosNameToInsString(nameToCosName(this));</span>
<span class="nc" id="L331">            } catch (InvalidNameException e) {</span>
<span class="nc" id="L332">                return super.toString();</span>
            }
        }

        private static final long serialVersionUID = -6599252802678482317L;
    }

// for testing only
/*
    private static void print(String input) {
        try {
            System.out.println(&quot;\n &gt;&gt;&gt;&gt;&gt;&gt; input: &quot; + input);

            System.out.println(&quot;--Compound Name: &quot;);
            NameParser parser = new CNNameParser();
            Name name = parser.parse(input);
            for (int i = 0; i &lt; name.size(); i++) {
                System.out.println(&quot;\t&quot; + i + &quot;: &quot; + name.get(i));
                NameComponent cp = parseComponent(name.get(i));
                System.out.println(&quot;\t\t&quot; + &quot;id: &quot; + cp.id + &quot;;kind: &quot; + cp.kind);
            }
            System.out.println(&quot;\t&quot; + name.toString());

            System.out.println(&quot;--Composite Name: &quot;);
            Name composite = new CompositeName(input);
            for (int i = 0; i &lt; composite.size(); i++) {
                System.out.println(&quot;\t&quot; + i+&quot;: &quot; + composite.get(i));
            }
            System.out.println(&quot;\t&quot; + composite.toString());

            System.out.println(&quot;--Composite To NameComponent&quot;);
            NameComponent[] names = nameToCosName(composite);
            for (int i = 0; i &lt; composite.size(); i++) {
                System.out.println(&quot;\t&quot; + i+&quot;: id: &quot; + names[i].id + &quot;; kind: &quot; + names[i].kind);
            }
            System.out.println(&quot;\t&quot; + cosNameToInsString(names));
        } catch (NamingException e) {
            System.out.println(e);
        }
    }

    private static void checkName(Name name, String[] comps) throws Exception {
        if (name.size() != comps.length) {
            throw new Exception(
                &quot;test failed; incorrect component count in &quot; + name + &quot;; &quot; +
                &quot;expecting &quot; + comps.length + &quot; got &quot; + name.size());
        }
        for (int i = 0; i &lt; name.size(); i++) {
            if (!comps[i].equals(name.get(i))) {
                throw new Exception (
                    &quot;test failed; invalid component in &quot; + name + &quot;; &quot; +
                    &quot;expecting '&quot; + comps[i] + &quot;' got '&quot; + name.get(i) + &quot;'&quot;);
            }
        }
    }

    private static void checkCompound(NameParser parser,
        String input, String[] comps) throws Exception {
        checkName(parser.parse(input), comps);
    }

    private static void checkComposite(String input, String[] comps)
    throws Exception {
        checkName(new CompositeName(input), comps);
    }

    private static String[] compounds = {
        &quot;a/b/c&quot;,
        &quot;a.b/c.d&quot;,
        &quot;a&quot;,
        &quot;.&quot;,
        &quot;a.&quot;,
        &quot;c.d&quot;,
        &quot;.e&quot;,
        &quot;a/x\\/y\\/z/b&quot;,
        &quot;a\\.b.c\\.d/e.f&quot;,
        &quot;a/b\\\\/c&quot;,
        &quot;x\\\\.y&quot;,
        &quot;x\\.y&quot;,
        &quot;x.\\\\y&quot;,
        &quot;x.y\\\\&quot;,
        &quot;\\\\x.y&quot;,
        &quot;a.b\\.c/d&quot;
    };
    private static String[][] compoundComps = {
        {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},
        {&quot;a.b&quot;, &quot;c.d&quot;},
        {&quot;a&quot;},
        {&quot;.&quot;},
        {&quot;a&quot;},
        {&quot;c.d&quot;},
        {&quot;.e&quot;},
        {&quot;a&quot;, &quot;x\\/y\\/z&quot;, &quot;b&quot;},
        {&quot;a\\.b.c\\.d&quot;, &quot;e.f&quot;},
        {&quot;a&quot;, &quot;b\\\\&quot;, &quot;c&quot;},
        {&quot;x\\\\.y&quot;},
        {&quot;x\\.y&quot;},
        {&quot;x.\\\\y&quot;},
        {&quot;x.y\\\\&quot;},
        {&quot;\\\\x.y&quot;},
        {&quot;a.b\\.c&quot;, &quot;d&quot;},
    };

    private static String[] composites = {
        &quot;a/b/c&quot;,
        &quot;a.b/c.d&quot;,
        &quot;a&quot;,
        &quot;.&quot;,
        &quot;a.&quot;,
        &quot;c.d&quot;,
        &quot;.e&quot;,
        &quot;a/x\\\\\\/y\\\\\\/z/b&quot;,
        &quot;a\\\\.b.c\\\\.d/e.f&quot;,
        &quot;a/b\\\\\\\\/c&quot;,
        &quot;x\\\\\\.y&quot;,
        &quot;x\\\\.y&quot;,
        &quot;x.\\\\\\\\y&quot;,
        &quot;x.y\\\\\\\\&quot;,
        &quot;\\\\\\\\x.y&quot;
    };

    private static String[][] compositeComps = {
        {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;},
        {&quot;a.b&quot;, &quot;c.d&quot;},
        {&quot;a&quot;},
        {&quot;.&quot;},
        {&quot;a.&quot;},  // unlike compound, kind sep is not consumed
        {&quot;c.d&quot;},
        {&quot;.e&quot;},
        {&quot;a&quot;, &quot;x\\/y\\/z&quot;, &quot;b&quot;},
        {&quot;a\\.b.c\\.d&quot;, &quot;e.f&quot;},
        {&quot;a&quot;, &quot;b\\\\&quot;, &quot;c&quot;},
        {&quot;x\\\\.y&quot;},
        {&quot;x\\.y&quot;},
        {&quot;x.\\\\y&quot;},
        {&quot;x.y\\\\&quot;},
        {&quot;\\\\x.y&quot;}
    };

    public static void main(String[] args) throws Exception {
        if (args.length &gt; 0) {
            for (int i = 0; i &lt; args.length; i++) {
                print(args[0]);
            }
        } else {
            print(&quot;x\\\\.y&quot;);
            print(&quot;x\\.y&quot;);
            print(&quot;x.\\\\y&quot;);
            print(&quot;x.y\\\\&quot;);
            print(&quot;\\\\x.y&quot;);
        }

        NameParser parser = new com.sun.jndi.cosnaming.CNNameParser();
        for (int i = 0; i &lt; compounds.length; i++) {
            checkCompound(parser, compounds[i], compoundComps[i]);
        }
        for (int i = 0; i &lt; composites.length; i++) {
            checkComposite(composites[i], compositeComps[i]);
        }

        System.out.println(&quot;hardwire&quot;);
        NameComponent[] foo = new NameComponent[1];
        foo[0] = new NameComponent(&quot;foo\\&quot;, &quot;bar&quot;);

        System.out.println(cosNameToInsString(foo));
        System.out.println(cosNameToName(foo));
    }
*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>