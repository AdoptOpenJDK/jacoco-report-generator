<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MethodAccessorGenerator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.reflect</a> &gt; <span class="el_source">MethodAccessorGenerator.java</span></div><h1>MethodAccessorGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect;

import java.security.AccessController;
import java.security.PrivilegedAction;

/** Generator for sun.reflect.MethodAccessor and
    sun.reflect.ConstructorAccessor objects using bytecodes to
    implement reflection. A java.lang.reflect.Method or
    java.lang.reflect.Constructor object can delegate its invoke or
    newInstance method to an accessor using native code or to one
    generated by this class. (Methods and Constructors were merged
    together in this class to ensure maximum code sharing.) */

class MethodAccessorGenerator extends AccessorGenerator {

    private static final short NUM_BASE_CPOOL_ENTRIES   = (short) 12;
    // One for invoke() plus one for constructor
    private static final short NUM_METHODS              = (short) 2;
    // Only used if forSerialization is true
    private static final short NUM_SERIALIZATION_CPOOL_ENTRIES = (short) 2;

<span class="fc" id="L47">    private static volatile int methodSymnum = 0;</span>
<span class="fc" id="L48">    private static volatile int constructorSymnum = 0;</span>
<span class="fc" id="L49">    private static volatile int serializationConstructorSymnum = 0;</span>

    private Class&lt;?&gt;   declaringClass;
    private Class&lt;?&gt;[] parameterTypes;
    private Class&lt;?&gt;   returnType;
    private boolean    isConstructor;
    private boolean    forSerialization;

    private short targetMethodRef;
    private short invokeIdx;
    private short invokeDescriptorIdx;
    // Constant pool index of CONSTANT_Class_info for first
    // non-primitive parameter type. Should be incremented by 2.
    private short nonPrimitiveParametersBaseIdx;

<span class="fc" id="L64">    MethodAccessorGenerator() {</span>
<span class="fc" id="L65">    }</span>

    /** This routine is not thread-safe */
    public MethodAccessor generateMethod(Class&lt;?&gt; declaringClass,
                                         String   name,
                                         Class&lt;?&gt;[] parameterTypes,
                                         Class&lt;?&gt;   returnType,
                                         Class&lt;?&gt;[] checkedExceptions,
                                         int modifiers)
    {
<span class="fc" id="L75">        return (MethodAccessor) generate(declaringClass,</span>
                                         name,
                                         parameterTypes,
                                         returnType,
                                         checkedExceptions,
                                         modifiers,
                                         false,
                                         false,
                                         null);
    }

    /** This routine is not thread-safe */
    public ConstructorAccessor generateConstructor(Class&lt;?&gt; declaringClass,
                                                   Class&lt;?&gt;[] parameterTypes,
                                                   Class&lt;?&gt;[] checkedExceptions,
                                                   int modifiers)
    {
<span class="fc" id="L92">        return (ConstructorAccessor) generate(declaringClass,</span>
                                              &quot;&lt;init&gt;&quot;,
                                              parameterTypes,
                                              Void.TYPE,
                                              checkedExceptions,
                                              modifiers,
                                              true,
                                              false,
                                              null);
    }

    /** This routine is not thread-safe */
    public SerializationConstructorAccessorImpl
    generateSerializationConstructor(Class&lt;?&gt; declaringClass,
                                     Class&lt;?&gt;[] parameterTypes,
                                     Class&lt;?&gt;[] checkedExceptions,
                                     int modifiers,
                                     Class&lt;?&gt; targetConstructorClass)
    {
<span class="fc" id="L111">        return (SerializationConstructorAccessorImpl)</span>
<span class="fc" id="L112">            generate(declaringClass,</span>
                     &quot;&lt;init&gt;&quot;,
                     parameterTypes,
                     Void.TYPE,
                     checkedExceptions,
                     modifiers,
                     true,
                     true,
                     targetConstructorClass);
    }

    /** This routine is not thread-safe */
    private MagicAccessorImpl generate(final Class&lt;?&gt; declaringClass,
                                       String name,
                                       Class&lt;?&gt;[] parameterTypes,
                                       Class&lt;?&gt;   returnType,
                                       Class&lt;?&gt;[] checkedExceptions,
                                       int modifiers,
                                       boolean isConstructor,
                                       boolean forSerialization,
                                       Class&lt;?&gt; serializationTargetClass)
    {
<span class="fc" id="L134">        ByteVector vec = ByteVectorFactory.create();</span>
<span class="fc" id="L135">        asm = new ClassFileAssembler(vec);</span>
<span class="fc" id="L136">        this.declaringClass = declaringClass;</span>
<span class="fc" id="L137">        this.parameterTypes = parameterTypes;</span>
<span class="fc" id="L138">        this.returnType = returnType;</span>
<span class="fc" id="L139">        this.modifiers = modifiers;</span>
<span class="fc" id="L140">        this.isConstructor = isConstructor;</span>
<span class="fc" id="L141">        this.forSerialization = forSerialization;</span>

<span class="fc" id="L143">        asm.emitMagicAndVersion();</span>

        // Constant pool entries:
        // ( * = Boxing information: optional)
        // (+  = Shared entries provided by AccessorGenerator)
        // (^  = Only present if generating SerializationConstructorAccessor)
        //     [UTF-8] [This class's name]
        //     [CONSTANT_Class_info] for above
        //     [UTF-8] &quot;sun/reflect/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}&quot;
        //     [CONSTANT_Class_info] for above
        //     [UTF-8] [Target class's name]
        //     [CONSTANT_Class_info] for above
        // ^   [UTF-8] [Serialization: Class's name in which to invoke constructor]
        // ^   [CONSTANT_Class_info] for above
        //     [UTF-8] target method or constructor name
        //     [UTF-8] target method or constructor signature
        //     [CONSTANT_NameAndType_info] for above
        //     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method
        //     [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot;
        //     [UTF-8] invoke or newInstance descriptor
        //     [UTF-8] descriptor for type of non-primitive parameter 1
        //     [CONSTANT_Class_info] for type of non-primitive parameter 1
        //     ...
        //     [UTF-8] descriptor for type of non-primitive parameter n
        //     [CONSTANT_Class_info] for type of non-primitive parameter n
        // +   [UTF-8] &quot;java/lang/Exception&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;java/lang/ClassCastException&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;java/lang/NullPointerException&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;java/lang/IllegalArgumentException&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;java/lang/InvocationTargetException&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;&lt;init&gt;&quot;
        // +   [UTF-8] &quot;()V&quot;
        // +   [CONSTANT_NameAndType_info] for above
        // +   [CONSTANT_Methodref_info] for NullPointerException's constructor
        // +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor
        // +   [UTF-8] &quot;(Ljava/lang/String;)V&quot;
        // +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot;
        // +   [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String
        // +   [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot;
        // +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot;
        // +   [CONSTANT_Methodref_info] for InvocationTargetException's constructor
        // +   [CONSTANT_Methodref_info] for &quot;super()&quot;
        // +   [UTF-8] &quot;java/lang/Object&quot;
        // +   [CONSTANT_Class_info] for above
        // +   [UTF-8] &quot;toString&quot;
        // +   [UTF-8] &quot;()Ljava/lang/String;&quot;
        // +   [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot;
        // +   [CONSTANT_Methodref_info] for Object's toString method
        // +   [UTF-8] &quot;Code&quot;
        // +   [UTF-8] &quot;Exceptions&quot;
        //  *  [UTF-8] &quot;java/lang/Boolean&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(Z)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;booleanValue&quot;
        //  *  [UTF-8] &quot;()Z&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Byte&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(B)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;byteValue&quot;
        //  *  [UTF-8] &quot;()B&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Character&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(C)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;charValue&quot;
        //  *  [UTF-8] &quot;()C&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Double&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(D)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;doubleValue&quot;
        //  *  [UTF-8] &quot;()D&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Float&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(F)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;floatValue&quot;
        //  *  [UTF-8] &quot;()F&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Integer&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(I)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;intValue&quot;
        //  *  [UTF-8] &quot;()I&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Long&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(J)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;longValue&quot;
        //  *  [UTF-8] &quot;()J&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;java/lang/Short&quot;
        //  *  [CONSTANT_Class_info] for above
        //  *  [UTF-8] &quot;(S)V&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above
        //  *  [UTF-8] &quot;shortValue&quot;
        //  *  [UTF-8] &quot;()S&quot;
        //  *  [CONSTANT_NameAndType_info] for above
        //  *  [CONSTANT_Methodref_info] for above

<span class="fc" id="L271">        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;</span>
<span class="fc" id="L272">        boolean usesPrimitives = usesPrimitiveTypes();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (usesPrimitives) {</span>
<span class="fc" id="L274">            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;</span>
        }
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (forSerialization) {</span>
<span class="fc" id="L277">            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;</span>
        }

        // Add in variable-length number of entries to be able to describe
        // non-primitive parameter types and checked exceptions.
<span class="fc" id="L282">        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());</span>

<span class="fc" id="L284">        asm.emitShort(add(numCPEntries, S1));</span>

<span class="fc" id="L286">        final String generatedName = generateName(isConstructor, forSerialization);</span>
<span class="fc" id="L287">        asm.emitConstantPoolUTF8(generatedName);</span>
<span class="fc" id="L288">        asm.emitConstantPoolClass(asm.cpi());</span>
<span class="fc" id="L289">        thisClass = asm.cpi();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (forSerialization) {</span>
<span class="fc" id="L292">                asm.emitConstantPoolUTF8</span>
<span class="fc" id="L293">                    (&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;);</span>
            } else {
<span class="fc" id="L295">                asm.emitConstantPoolUTF8(&quot;sun/reflect/ConstructorAccessorImpl&quot;);</span>
            }
        } else {
<span class="fc" id="L298">            asm.emitConstantPoolUTF8(&quot;sun/reflect/MethodAccessorImpl&quot;);</span>
        }
<span class="fc" id="L300">        asm.emitConstantPoolClass(asm.cpi());</span>
<span class="fc" id="L301">        superClass = asm.cpi();</span>
<span class="fc" id="L302">        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));</span>
<span class="fc" id="L303">        asm.emitConstantPoolClass(asm.cpi());</span>
<span class="fc" id="L304">        targetClass = asm.cpi();</span>
<span class="fc" id="L305">        short serializationTargetClassIdx = (short) 0;</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (forSerialization) {</span>
<span class="fc" id="L307">            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));</span>
<span class="fc" id="L308">            asm.emitConstantPoolClass(asm.cpi());</span>
<span class="fc" id="L309">            serializationTargetClassIdx = asm.cpi();</span>
        }
<span class="fc" id="L311">        asm.emitConstantPoolUTF8(name);</span>
<span class="fc" id="L312">        asm.emitConstantPoolUTF8(buildInternalSignature());</span>
<span class="fc" id="L313">        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (isInterface()) {</span>
<span class="fc" id="L315">            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());</span>
        } else {
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (forSerialization) {</span>
<span class="fc" id="L318">                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());</span>
            } else {
<span class="fc" id="L320">                asm.emitConstantPoolMethodref(targetClass, asm.cpi());</span>
            }
        }
<span class="fc" id="L323">        targetMethodRef = asm.cpi();</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc" id="L325">            asm.emitConstantPoolUTF8(&quot;newInstance&quot;);</span>
        } else {
<span class="fc" id="L327">            asm.emitConstantPoolUTF8(&quot;invoke&quot;);</span>
        }
<span class="fc" id="L329">        invokeIdx = asm.cpi();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc" id="L331">            asm.emitConstantPoolUTF8(&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span>
        } else {
<span class="fc" id="L333">            asm.emitConstantPoolUTF8</span>
<span class="fc" id="L334">                (&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span>
        }
<span class="fc" id="L336">        invokeDescriptorIdx = asm.cpi();</span>

        // Output class information for non-primitive parameter types
<span class="fc" id="L339">        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc" id="L341">            Class&lt;?&gt; c = parameterTypes[i];</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            if (!isPrimitive(c)) {</span>
<span class="fc" id="L343">                asm.emitConstantPoolUTF8(getClassName(c, false));</span>
<span class="fc" id="L344">                asm.emitConstantPoolClass(asm.cpi());</span>
            }
        }

        // Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor
<span class="fc" id="L349">        emitCommonConstantPoolEntries();</span>

        // Boxing entries
<span class="fc bfc" id="L352" title="All 2 branches covered.">        if (usesPrimitives) {</span>
<span class="fc" id="L353">            emitBoxingContantPoolEntries();</span>
        }

<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (asm.cpi() != numCPEntries) {</span>
<span class="nc" id="L357">            throw new InternalError(&quot;Adjust this code (cpi = &quot; + asm.cpi() +</span>
                                    &quot;, numCPEntries = &quot; + numCPEntries + &quot;)&quot;);
        }

        // Access flags
<span class="fc" id="L362">        asm.emitShort(ACC_PUBLIC);</span>

        // This class
<span class="fc" id="L365">        asm.emitShort(thisClass);</span>

        // Superclass
<span class="fc" id="L368">        asm.emitShort(superClass);</span>

        // Interfaces count and interfaces
<span class="fc" id="L371">        asm.emitShort(S0);</span>

        // Fields count and fields
<span class="fc" id="L374">        asm.emitShort(S0);</span>

        // Methods count and methods
<span class="fc" id="L377">        asm.emitShort(NUM_METHODS);</span>

<span class="fc" id="L379">        emitConstructor();</span>
<span class="fc" id="L380">        emitInvoke();</span>

        // Additional attributes (none)
<span class="fc" id="L383">        asm.emitShort(S0);</span>

        // Load class
<span class="fc" id="L386">        vec.trim();</span>
<span class="fc" id="L387">        final byte[] bytes = vec.getData();</span>
        // Note: the class loader is the only thing that really matters
        // here -- it's important to get the generated code into the
        // same namespace as the target class. Since the generated code
        // is privileged anyway, the protection domain probably doesn't
        // matter.
<span class="fc" id="L393">        return AccessController.doPrivileged(</span>
<span class="fc" id="L394">            new PrivilegedAction&lt;MagicAccessorImpl&gt;() {</span>
                public MagicAccessorImpl run() {
                        try {
<span class="fc" id="L397">                        return (MagicAccessorImpl)</span>
                        ClassDefiner.defineClass
<span class="fc" id="L399">                                (generatedName,</span>
                                 bytes,
                                 0,
                                 bytes.length,
<span class="fc" id="L403">                                 declaringClass.getClassLoader()).newInstance();</span>
<span class="nc" id="L404">                        } catch (InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L405">                            throw new InternalError(e);</span>
                        }
                    }
                });
    }

    /** This emits the code for either invoke() or newInstance() */
    private void emitInvoke() {
        // NOTE that this code will only handle 65535 parameters since we
        // use the sipush instruction to get the array index on the
        // operand stack.
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (parameterTypes.length &gt; 65535) {</span>
<span class="nc" id="L417">            throw new InternalError(&quot;Can't handle more than 65535 parameters&quot;);</span>
        }

        // Generate code into fresh code buffer
<span class="fc" id="L421">        ClassFileAssembler cb = new ClassFileAssembler();</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (isConstructor) {</span>
            // 1 incoming argument
<span class="fc" id="L424">            cb.setMaxLocals(2);</span>
        } else {
            // 2 incoming arguments
<span class="fc" id="L427">            cb.setMaxLocals(3);</span>
        }

<span class="fc" id="L430">        short illegalArgStartPC = 0;</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (isConstructor) {</span>
            // Instantiate target class before continuing
            // new &lt;target class type&gt;
            // dup
<span class="fc" id="L436">            cb.opc_new(targetClass);</span>
<span class="fc" id="L437">            cb.opc_dup();</span>
        } else {
            // Setup before iterating down argument list
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (isPrimitive(returnType)) {</span>
                // new &lt;boxing type for primitive type&gt;
                // dup
                // ... (see below:)
                // invokespecial &lt;constructor for boxing type for primitive type&gt;
                // areturn
<span class="fc" id="L446">                cb.opc_new(indexForPrimitiveType(returnType));</span>
<span class="fc" id="L447">                cb.opc_dup();</span>
            }

            // Get target object on operand stack if necessary.

            // We need to do an explicit null check here; we won't see
            // NullPointerExceptions from the invoke bytecode, since it's
            // covered by an exception handler.
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (!isStatic()) {</span>
                // aload_1
                // ifnonnull &lt;checkcast label&gt;
                // new &lt;NullPointerException&gt;
                // dup
                // invokespecial &lt;NullPointerException ctor&gt;
                // athrow
                // &lt;checkcast label:&gt;
                // aload_1
                // checkcast &lt;target class's type&gt;
<span class="fc" id="L465">                cb.opc_aload_1();</span>
<span class="fc" id="L466">                Label l = new Label();</span>
<span class="fc" id="L467">                cb.opc_ifnonnull(l);</span>
<span class="fc" id="L468">                cb.opc_new(nullPointerClass);</span>
<span class="fc" id="L469">                cb.opc_dup();</span>
<span class="fc" id="L470">                cb.opc_invokespecial(nullPointerCtorIdx, 0, 0);</span>
<span class="fc" id="L471">                cb.opc_athrow();</span>
<span class="fc" id="L472">                l.bind();</span>
<span class="fc" id="L473">                illegalArgStartPC = cb.getLength();</span>
<span class="fc" id="L474">                cb.opc_aload_1();</span>
<span class="fc" id="L475">                cb.opc_checkcast(targetClass);</span>
            }
        }

        // Have to check length of incoming array and throw
        // IllegalArgumentException if not correct. A concession to the
        // JCK (isn't clearly specified in the spec): we allow null in the
        // case where the argument list is zero length.
        // if no-arg:
        //   aload_2 | aload_1 (Method | Constructor)
        //   ifnull &lt;success label&gt;
        // aload_2 | aload_1
        // arraylength
        // sipush &lt;num parameter types&gt;
        // if_icmpeq &lt;success label&gt;
        // new &lt;IllegalArgumentException&gt;
        // dup
        // invokespecial &lt;IllegalArgumentException ctor&gt;
        // athrow
        // &lt;success label:&gt;
<span class="fc" id="L495">        Label successLabel = new Label();</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (parameterTypes.length == 0) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (isConstructor) {</span>
<span class="fc" id="L498">                cb.opc_aload_1();</span>
            } else {
<span class="fc" id="L500">                cb.opc_aload_2();</span>
            }
<span class="fc" id="L502">            cb.opc_ifnull(successLabel);</span>
        }
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc" id="L505">            cb.opc_aload_1();</span>
        } else {
<span class="fc" id="L507">            cb.opc_aload_2();</span>
        }
<span class="fc" id="L509">        cb.opc_arraylength();</span>
<span class="fc" id="L510">        cb.opc_sipush((short) parameterTypes.length);</span>
<span class="fc" id="L511">        cb.opc_if_icmpeq(successLabel);</span>
<span class="fc" id="L512">        cb.opc_new(illegalArgumentClass);</span>
<span class="fc" id="L513">        cb.opc_dup();</span>
<span class="fc" id="L514">        cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);</span>
<span class="fc" id="L515">        cb.opc_athrow();</span>
<span class="fc" id="L516">        successLabel.bind();</span>

        // Iterate through incoming actual parameters, ensuring that each
        // is compatible with the formal parameter type, and pushing the
        // actual on the operand stack (unboxing and widening if necessary).

<span class="fc" id="L522">        short paramTypeCPIdx = nonPrimitiveParametersBaseIdx;</span>
<span class="fc" id="L523">        Label nextParamLabel = null;</span>
<span class="fc" id="L524">        byte count = 1; // both invokeinterface opcode's &quot;count&quot; as well as</span>
        // num args of other invoke bytecodes
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc" id="L527">            Class&lt;?&gt; paramType = parameterTypes[i];</span>
<span class="fc" id="L528">            count += (byte) typeSizeInStackSlots(paramType);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (nextParamLabel != null) {</span>
<span class="fc" id="L530">                nextParamLabel.bind();</span>
<span class="fc" id="L531">                nextParamLabel = null;</span>
            }
            // aload_2 | aload_1
            // sipush &lt;index&gt;
            // aaload
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (isConstructor) {</span>
<span class="fc" id="L537">                cb.opc_aload_1();</span>
            } else {
<span class="fc" id="L539">                cb.opc_aload_2();</span>
            }
<span class="fc" id="L541">            cb.opc_sipush((short) i);</span>
<span class="fc" id="L542">            cb.opc_aaload();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            if (isPrimitive(paramType)) {</span>
                // Unboxing code.
                // Put parameter into temporary local variable
                // astore_3 | astore_2
<span class="fc bfc" id="L547" title="All 2 branches covered.">                if (isConstructor) {</span>
<span class="fc" id="L548">                    cb.opc_astore_2();</span>
                } else {
<span class="fc" id="L550">                    cb.opc_astore_3();</span>
                }

                // repeat for all possible widening conversions:
                //   aload_3 | aload_2
                //   instanceof &lt;primitive boxing type&gt;
                //   ifeq &lt;next unboxing label&gt;
                //   aload_3 | aload_2
                //   checkcast &lt;primitive boxing type&gt; // Note: this is &quot;redundant&quot;,
                //                                     // but necessary for the verifier
                //   invokevirtual &lt;unboxing method&gt;
                //   &lt;widening conversion bytecode, if necessary&gt;
                //   goto &lt;next parameter label&gt;
                // &lt;next unboxing label:&gt; ...
                // last unboxing label:
                //   new &lt;IllegalArgumentException&gt;
                //   dup
                //   invokespecial &lt;IllegalArgumentException ctor&gt;
                //   athrow

<span class="fc" id="L570">                Label l = null; // unboxing label</span>
<span class="fc" id="L571">                nextParamLabel = new Label();</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">                for (int j = 0; j &lt; primitiveTypes.length; j++) {</span>
<span class="fc" id="L574">                    Class&lt;?&gt; c = primitiveTypes[j];</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                    if (canWidenTo(c, paramType)) {</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">                        if (l != null) {</span>
<span class="fc" id="L577">                            l.bind();</span>
                        }
                        // Emit checking and unboxing code for this type
<span class="fc bfc" id="L580" title="All 2 branches covered.">                        if (isConstructor) {</span>
<span class="fc" id="L581">                            cb.opc_aload_2();</span>
                        } else {
<span class="fc" id="L583">                            cb.opc_aload_3();</span>
                        }
<span class="fc" id="L585">                        cb.opc_instanceof(indexForPrimitiveType(c));</span>
<span class="fc" id="L586">                        l = new Label();</span>
<span class="fc" id="L587">                        cb.opc_ifeq(l);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                        if (isConstructor) {</span>
<span class="fc" id="L589">                            cb.opc_aload_2();</span>
                        } else {
<span class="fc" id="L591">                            cb.opc_aload_3();</span>
                        }
<span class="fc" id="L593">                        cb.opc_checkcast(indexForPrimitiveType(c));</span>
<span class="fc" id="L594">                        cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),</span>
                                             0,
<span class="fc" id="L596">                                             typeSizeInStackSlots(c));</span>
<span class="fc" id="L597">                        emitWideningBytecodeForPrimitiveConversion(cb,</span>
                                                                   c,
                                                                   paramType);
<span class="fc" id="L600">                        cb.opc_goto(nextParamLabel);</span>
                    }
                }

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">                if (l == null) {</span>
<span class="nc" id="L605">                    throw new InternalError</span>
                        (&quot;Must have found at least identity conversion&quot;);
                }

                // Fell through; given object is null or invalid. According to
                // the spec, we can throw IllegalArgumentException for both of
                // these cases.

<span class="fc" id="L613">                l.bind();</span>
<span class="fc" id="L614">                cb.opc_new(illegalArgumentClass);</span>
<span class="fc" id="L615">                cb.opc_dup();</span>
<span class="fc" id="L616">                cb.opc_invokespecial(illegalArgumentCtorIdx, 0, 0);</span>
<span class="fc" id="L617">                cb.opc_athrow();</span>
<span class="fc" id="L618">            } else {</span>
                // Emit appropriate checkcast
<span class="fc" id="L620">                cb.opc_checkcast(paramTypeCPIdx);</span>
<span class="fc" id="L621">                paramTypeCPIdx = add(paramTypeCPIdx, S2);</span>
                // Fall through to next argument
            }
        }
        // Bind last goto if present
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (nextParamLabel != null) {</span>
<span class="fc" id="L627">            nextParamLabel.bind();</span>
        }

<span class="fc" id="L630">        short invokeStartPC = cb.getLength();</span>

        // OK, ready to perform the invocation.
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc" id="L634">            cb.opc_invokespecial(targetMethodRef, count, 0);</span>
        } else {
<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (isStatic()) {</span>
<span class="fc" id="L637">                cb.opc_invokestatic(targetMethodRef,</span>
                                    count,
<span class="fc" id="L639">                                    typeSizeInStackSlots(returnType));</span>
            } else {
<span class="fc bfc" id="L641" title="All 2 branches covered.">                if (isInterface()) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">                    if (isPrivate()) {</span>
<span class="fc" id="L643">                        cb.opc_invokespecial(targetMethodRef, count, 0);</span>
                    } else {
<span class="fc" id="L645">                        cb.opc_invokeinterface(targetMethodRef,</span>
                                               count,
                                               count,
<span class="fc" id="L648">                                               typeSizeInStackSlots(returnType));</span>
                    }
                } else {
<span class="fc" id="L651">                    cb.opc_invokevirtual(targetMethodRef,</span>
                                         count,
<span class="fc" id="L653">                                         typeSizeInStackSlots(returnType));</span>
                }
            }
        }

<span class="fc" id="L658">        short invokeEndPC = cb.getLength();</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (!isConstructor) {</span>
            // Box return value if necessary
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (isPrimitive(returnType)) {</span>
<span class="fc" id="L663">                cb.opc_invokespecial(ctorIndexForPrimitiveType(returnType),</span>
<span class="fc" id="L664">                                     typeSizeInStackSlots(returnType),</span>
                                     0);
<span class="fc bfc" id="L666" title="All 2 branches covered.">            } else if (returnType == Void.TYPE) {</span>
<span class="fc" id="L667">                cb.opc_aconst_null();</span>
            }
        }
<span class="fc" id="L670">        cb.opc_areturn();</span>

        // We generate two exception handlers; one which is responsible
        // for catching ClassCastException and NullPointerException and
        // throwing IllegalArgumentException, and the other which catches
        // all java/lang/Throwable objects thrown from the target method
        // and wraps them in InvocationTargetExceptions.

<span class="fc" id="L678">        short classCastHandler = cb.getLength();</span>

        // ClassCast, etc. exception handler
<span class="fc" id="L681">        cb.setStack(1);</span>
<span class="fc" id="L682">        cb.opc_invokespecial(toStringIdx, 0, 1);</span>
<span class="fc" id="L683">        cb.opc_new(illegalArgumentClass);</span>
<span class="fc" id="L684">        cb.opc_dup_x1();</span>
<span class="fc" id="L685">        cb.opc_swap();</span>
<span class="fc" id="L686">        cb.opc_invokespecial(illegalArgumentStringCtorIdx, 1, 0);</span>
<span class="fc" id="L687">        cb.opc_athrow();</span>

<span class="fc" id="L689">        short invocationTargetHandler = cb.getLength();</span>

        // InvocationTargetException exception handler
<span class="fc" id="L692">        cb.setStack(1);</span>
<span class="fc" id="L693">        cb.opc_new(invocationTargetClass);</span>
<span class="fc" id="L694">        cb.opc_dup_x1();</span>
<span class="fc" id="L695">        cb.opc_swap();</span>
<span class="fc" id="L696">        cb.opc_invokespecial(invocationTargetCtorIdx, 1, 0);</span>
<span class="fc" id="L697">        cb.opc_athrow();</span>

        // Generate exception table. We cover the entire code sequence
        // with an exception handler which catches ClassCastException and
        // converts it into an IllegalArgumentException.

<span class="fc" id="L703">        ClassFileAssembler exc = new ClassFileAssembler();</span>

<span class="fc" id="L705">        exc.emitShort(illegalArgStartPC);       // start PC</span>
<span class="fc" id="L706">        exc.emitShort(invokeStartPC);           // end PC</span>
<span class="fc" id="L707">        exc.emitShort(classCastHandler);        // handler PC</span>
<span class="fc" id="L708">        exc.emitShort(classCastClass);          // catch type</span>

<span class="fc" id="L710">        exc.emitShort(illegalArgStartPC);       // start PC</span>
<span class="fc" id="L711">        exc.emitShort(invokeStartPC);           // end PC</span>
<span class="fc" id="L712">        exc.emitShort(classCastHandler);        // handler PC</span>
<span class="fc" id="L713">        exc.emitShort(nullPointerClass);        // catch type</span>

<span class="fc" id="L715">        exc.emitShort(invokeStartPC);           // start PC</span>
<span class="fc" id="L716">        exc.emitShort(invokeEndPC);             // end PC</span>
<span class="fc" id="L717">        exc.emitShort(invocationTargetHandler); // handler PC</span>
<span class="fc" id="L718">        exc.emitShort(throwableClass);          // catch type</span>

<span class="fc" id="L720">        emitMethod(invokeIdx, cb.getMaxLocals(), cb, exc,</span>
                   new short[] { invocationTargetClass });
<span class="fc" id="L722">    }</span>

    private boolean usesPrimitiveTypes() {
        // We need to emit boxing/unboxing constant pool information if
        // the method takes a primitive type for any of its parameters or
        // returns a primitive value (except void)
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (returnType.isPrimitive()) {</span>
<span class="fc" id="L729">            return true;</span>
        }
<span class="fc bfc" id="L731" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            if (parameterTypes[i].isPrimitive()) {</span>
<span class="fc" id="L733">                return true;</span>
            }
        }
<span class="fc" id="L736">        return false;</span>
    }

    private int numNonPrimitiveParameterTypes() {
<span class="fc" id="L740">        int num = 0;</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">            if (!parameterTypes[i].isPrimitive()) {</span>
<span class="fc" id="L743">                ++num;</span>
            }
        }
<span class="fc" id="L746">        return num;</span>
    }

    private boolean isInterface() {
<span class="fc" id="L750">        return declaringClass.isInterface();</span>
    }

    private String buildInternalSignature() {
<span class="fc" id="L754">        StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L755">        buf.append(&quot;(&quot;);</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc" id="L757">            buf.append(getClassName(parameterTypes[i], true));</span>
        }
<span class="fc" id="L759">        buf.append(&quot;)&quot;);</span>
<span class="fc" id="L760">        buf.append(getClassName(returnType, true));</span>
<span class="fc" id="L761">        return buf.toString();</span>
    }

    private static synchronized String generateName(boolean isConstructor,
                                                    boolean forSerialization)
    {
<span class="fc bfc" id="L767" title="All 2 branches covered.">        if (isConstructor) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            if (forSerialization) {</span>
<span class="fc" id="L769">                int num = ++serializationConstructorSymnum;</span>
<span class="fc" id="L770">                return &quot;sun/reflect/GeneratedSerializationConstructorAccessor&quot; + num;</span>
            } else {
<span class="fc" id="L772">                int num = ++constructorSymnum;</span>
<span class="fc" id="L773">                return &quot;sun/reflect/GeneratedConstructorAccessor&quot; + num;</span>
            }
        } else {
<span class="fc" id="L776">            int num = ++methodSymnum;</span>
<span class="fc" id="L777">            return &quot;sun/reflect/GeneratedMethodAccessor&quot; + num;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>