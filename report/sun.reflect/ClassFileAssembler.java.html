<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassFileAssembler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.reflect</a> &gt; <span class="el_source">ClassFileAssembler.java</span></div><h1>ClassFileAssembler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect;

class ClassFileAssembler implements ClassFileConstants {
    private ByteVector vec;
<span class="fc" id="L30">    private short cpIdx = 0;</span>

    public ClassFileAssembler() {
<span class="fc" id="L33">        this(ByteVectorFactory.create());</span>
<span class="fc" id="L34">    }</span>

<span class="fc" id="L36">    public ClassFileAssembler(ByteVector vec) {</span>
<span class="fc" id="L37">        this.vec = vec;</span>
<span class="fc" id="L38">    }</span>

    public ByteVector getData() {
<span class="nc" id="L41">        return vec;</span>
    }

    /** Length in bytes */
    public short getLength() {
<span class="fc" id="L46">        return (short) vec.getLength();</span>
    }

    public void emitMagicAndVersion() {
<span class="fc" id="L50">        emitInt(0xCAFEBABE);</span>
<span class="fc" id="L51">        emitShort((short) 0);</span>
<span class="fc" id="L52">        emitShort((short) 49);</span>
<span class="fc" id="L53">    }</span>

    public void emitInt(int val) {
<span class="fc" id="L56">        emitByte((byte) (val &gt;&gt; 24));</span>
<span class="fc" id="L57">        emitByte((byte) ((val &gt;&gt; 16) &amp; 0xFF));</span>
<span class="fc" id="L58">        emitByte((byte) ((val &gt;&gt; 8) &amp; 0xFF));</span>
<span class="fc" id="L59">        emitByte((byte) (val &amp; 0xFF));</span>
<span class="fc" id="L60">    }</span>

    public void emitShort(short val) {
<span class="fc" id="L63">        emitByte((byte) ((val &gt;&gt; 8) &amp; 0xFF));</span>
<span class="fc" id="L64">        emitByte((byte) (val &amp; 0xFF));</span>
<span class="fc" id="L65">    }</span>

    // Support for labels; package-private
    void emitShort(short bci, short val) {
<span class="fc" id="L69">        vec.put(bci,     (byte) ((val &gt;&gt; 8) &amp; 0xFF));</span>
<span class="fc" id="L70">        vec.put(bci + 1, (byte) (val &amp; 0xFF));</span>
<span class="fc" id="L71">    }</span>

    public void emitByte(byte val) {
<span class="fc" id="L74">        vec.add(val);</span>
<span class="fc" id="L75">    }</span>

    public void append(ClassFileAssembler asm) {
<span class="fc" id="L78">        append(asm.vec);</span>
<span class="fc" id="L79">    }</span>

    public void append(ByteVector vec) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i = 0; i &lt; vec.getLength(); i++) {</span>
<span class="fc" id="L83">            emitByte(vec.get(i));</span>
        }
<span class="fc" id="L85">    }</span>

    /** Keeps track of the current (one-based) constant pool index;
        incremented after emitting one of the following constant pool
        entries. Can fetch the current constant pool index for use in
        later entries.  Index points at the last valid constant pool
        entry; initially invalid. It is illegal to fetch the constant
        pool index before emitting at least one constant pool entry. */
    public short cpi() {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (cpIdx == 0) {</span>
<span class="nc" id="L95">            throw new RuntimeException(&quot;Illegal use of ClassFileAssembler&quot;);</span>
        }
<span class="fc" id="L97">        return cpIdx;</span>
    }

    public void emitConstantPoolUTF8(String str) {
        // NOTE: can not use str.getBytes(&quot;UTF-8&quot;) here because of
        // bootstrapping issues with the character set converters.
<span class="fc" id="L103">        byte[] bytes = UTF8.encode(str);</span>
<span class="fc" id="L104">        emitByte(CONSTANT_Utf8);</span>
<span class="fc" id="L105">        emitShort((short) bytes.length);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (int i = 0; i &lt; bytes.length; i++) {</span>
<span class="fc" id="L107">            emitByte(bytes[i]);</span>
        }
<span class="fc" id="L109">        cpIdx++;</span>
<span class="fc" id="L110">    }</span>

    public void emitConstantPoolClass(short index) {
<span class="fc" id="L113">        emitByte(CONSTANT_Class);</span>
<span class="fc" id="L114">        emitShort(index);</span>
<span class="fc" id="L115">        cpIdx++;</span>
<span class="fc" id="L116">    }</span>

    public void emitConstantPoolNameAndType(short nameIndex, short typeIndex) {
<span class="fc" id="L119">        emitByte(CONSTANT_NameAndType);</span>
<span class="fc" id="L120">        emitShort(nameIndex);</span>
<span class="fc" id="L121">        emitShort(typeIndex);</span>
<span class="fc" id="L122">        cpIdx++;</span>
<span class="fc" id="L123">    }</span>

    public void emitConstantPoolFieldref
        (short classIndex, short nameAndTypeIndex)
    {
<span class="nc" id="L128">        emitByte(CONSTANT_Fieldref);</span>
<span class="nc" id="L129">        emitShort(classIndex);</span>
<span class="nc" id="L130">        emitShort(nameAndTypeIndex);</span>
<span class="nc" id="L131">        cpIdx++;</span>
<span class="nc" id="L132">    }</span>

    public void emitConstantPoolMethodref
        (short classIndex, short nameAndTypeIndex)
    {
<span class="fc" id="L137">        emitByte(CONSTANT_Methodref);</span>
<span class="fc" id="L138">        emitShort(classIndex);</span>
<span class="fc" id="L139">        emitShort(nameAndTypeIndex);</span>
<span class="fc" id="L140">        cpIdx++;</span>
<span class="fc" id="L141">    }</span>

    public void emitConstantPoolInterfaceMethodref
        (short classIndex, short nameAndTypeIndex)
    {
<span class="fc" id="L146">        emitByte(CONSTANT_InterfaceMethodref);</span>
<span class="fc" id="L147">        emitShort(classIndex);</span>
<span class="fc" id="L148">        emitShort(nameAndTypeIndex);</span>
<span class="fc" id="L149">        cpIdx++;</span>
<span class="fc" id="L150">    }</span>

    public void emitConstantPoolString(short utf8Index) {
<span class="nc" id="L153">        emitByte(CONSTANT_String);</span>
<span class="nc" id="L154">        emitShort(utf8Index);</span>
<span class="nc" id="L155">        cpIdx++;</span>
<span class="nc" id="L156">    }</span>

    //----------------------------------------------------------------------
    // Opcodes. Keeps track of maximum stack and locals. Make a new
    // assembler for each piece of assembled code, then append the
    // result to the previous assembler's class file.
    //

<span class="fc" id="L164">    private int stack     = 0;</span>
<span class="fc" id="L165">    private int maxStack  = 0;</span>
<span class="fc" id="L166">    private int maxLocals = 0;</span>

    private void incStack() {
<span class="fc" id="L169">        setStack(stack + 1);</span>
<span class="fc" id="L170">    }</span>

    private void decStack() {
<span class="fc" id="L173">        --stack;</span>
<span class="fc" id="L174">    }</span>

    public short getMaxStack() {
<span class="fc" id="L177">        return (short) maxStack;</span>
    }

    public short getMaxLocals() {
<span class="fc" id="L181">        return (short) maxLocals;</span>
    }

    /** It's necessary to be able to specify the number of arguments at
        the beginning of the method (which translates to the initial
        value of max locals) */
    public void setMaxLocals(int maxLocals) {
<span class="fc" id="L188">        this.maxLocals = maxLocals;</span>
<span class="fc" id="L189">    }</span>

    /** Needed to do flow control. Returns current stack depth. */
    public int getStack() {
<span class="fc" id="L193">        return stack;</span>
    }

    /** Needed to do flow control. */
    public void setStack(int value) {
<span class="fc" id="L198">        stack = value;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (stack &gt; maxStack) {</span>
<span class="fc" id="L200">            maxStack = stack;</span>
        }
<span class="fc" id="L202">    }</span>

    ///////////////
    // Constants //
    ///////////////

    public void opc_aconst_null() {
<span class="fc" id="L209">        emitByte(opc_aconst_null);</span>
<span class="fc" id="L210">        incStack();</span>
<span class="fc" id="L211">    }</span>

    public void opc_sipush(short constant) {
<span class="fc" id="L214">        emitByte(opc_sipush);</span>
<span class="fc" id="L215">        emitShort(constant);</span>
<span class="fc" id="L216">        incStack();</span>
<span class="fc" id="L217">    }</span>

    public void opc_ldc(byte cpIdx) {
<span class="nc" id="L220">        emitByte(opc_ldc);</span>
<span class="nc" id="L221">        emitByte(cpIdx);</span>
<span class="nc" id="L222">        incStack();</span>
<span class="nc" id="L223">    }</span>

    /////////////////////////////////////
    // Local variable loads and stores //
    /////////////////////////////////////

    public void opc_iload_0() {
<span class="nc" id="L230">        emitByte(opc_iload_0);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (maxLocals &lt; 1) maxLocals = 1;</span>
<span class="nc" id="L232">        incStack();</span>
<span class="nc" id="L233">    }</span>

    public void opc_iload_1() {
<span class="nc" id="L236">        emitByte(opc_iload_1);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="nc" id="L238">        incStack();</span>
<span class="nc" id="L239">    }</span>

    public void opc_iload_2() {
<span class="nc" id="L242">        emitByte(opc_iload_2);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="nc" id="L244">        incStack();</span>
<span class="nc" id="L245">    }</span>

    public void opc_iload_3() {
<span class="nc" id="L248">        emitByte(opc_iload_3);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="nc" id="L250">        incStack();</span>
<span class="nc" id="L251">    }</span>

    public void opc_lload_0() {
<span class="nc" id="L254">        emitByte(opc_lload_0);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="nc" id="L256">        incStack();</span>
<span class="nc" id="L257">        incStack();</span>
<span class="nc" id="L258">    }</span>

    public void opc_lload_1() {
<span class="nc" id="L261">        emitByte(opc_lload_1);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="nc" id="L263">        incStack();</span>
<span class="nc" id="L264">        incStack();</span>
<span class="nc" id="L265">    }</span>

    public void opc_lload_2() {
<span class="nc" id="L268">        emitByte(opc_lload_2);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="nc" id="L270">        incStack();</span>
<span class="nc" id="L271">        incStack();</span>
<span class="nc" id="L272">    }</span>

    public void opc_lload_3() {
<span class="nc" id="L275">        emitByte(opc_lload_3);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (maxLocals &lt; 5) maxLocals = 5;</span>
<span class="nc" id="L277">        incStack();</span>
<span class="nc" id="L278">        incStack();</span>
<span class="nc" id="L279">    }</span>

    public void opc_fload_0() {
<span class="nc" id="L282">        emitByte(opc_fload_0);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (maxLocals &lt; 1) maxLocals = 1;</span>
<span class="nc" id="L284">        incStack();</span>
<span class="nc" id="L285">    }</span>

    public void opc_fload_1() {
<span class="nc" id="L288">        emitByte(opc_fload_1);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="nc" id="L290">        incStack();</span>
<span class="nc" id="L291">    }</span>

    public void opc_fload_2() {
<span class="nc" id="L294">        emitByte(opc_fload_2);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="nc" id="L296">        incStack();</span>
<span class="nc" id="L297">    }</span>

    public void opc_fload_3() {
<span class="nc" id="L300">        emitByte(opc_fload_3);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="nc" id="L302">        incStack();</span>
<span class="nc" id="L303">    }</span>

    public void opc_dload_0() {
<span class="nc" id="L306">        emitByte(opc_dload_0);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="nc" id="L308">        incStack();</span>
<span class="nc" id="L309">        incStack();</span>
<span class="nc" id="L310">    }</span>

    public void opc_dload_1() {
<span class="nc" id="L313">        emitByte(opc_dload_1);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="nc" id="L315">        incStack();</span>
<span class="nc" id="L316">        incStack();</span>
<span class="nc" id="L317">    }</span>

    public void opc_dload_2() {
<span class="nc" id="L320">        emitByte(opc_dload_2);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="nc" id="L322">        incStack();</span>
<span class="nc" id="L323">        incStack();</span>
<span class="nc" id="L324">    }</span>

    public void opc_dload_3() {
<span class="nc" id="L327">        emitByte(opc_dload_3);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (maxLocals &lt; 5) maxLocals = 5;</span>
<span class="nc" id="L329">        incStack();</span>
<span class="nc" id="L330">        incStack();</span>
<span class="nc" id="L331">    }</span>

    public void opc_aload_0() {
<span class="fc" id="L334">        emitByte(opc_aload_0);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (maxLocals &lt; 1) maxLocals = 1;</span>
<span class="fc" id="L336">        incStack();</span>
<span class="fc" id="L337">    }</span>

    public void opc_aload_1() {
<span class="fc" id="L340">        emitByte(opc_aload_1);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="fc" id="L342">        incStack();</span>
<span class="fc" id="L343">    }</span>

    public void opc_aload_2() {
<span class="fc" id="L346">        emitByte(opc_aload_2);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="fc" id="L348">        incStack();</span>
<span class="fc" id="L349">    }</span>

    public void opc_aload_3() {
<span class="fc" id="L352">        emitByte(opc_aload_3);</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="fc" id="L354">        incStack();</span>
<span class="fc" id="L355">    }</span>

    public void opc_aaload() {
<span class="fc" id="L358">        emitByte(opc_aaload);</span>
<span class="fc" id="L359">        decStack();</span>
<span class="fc" id="L360">    }</span>

    public void opc_astore_0() {
<span class="nc" id="L363">        emitByte(opc_astore_0);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (maxLocals &lt; 1) maxLocals = 1;</span>
<span class="nc" id="L365">        decStack();</span>
<span class="nc" id="L366">    }</span>

    public void opc_astore_1() {
<span class="nc" id="L369">        emitByte(opc_astore_1);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (maxLocals &lt; 2) maxLocals = 2;</span>
<span class="nc" id="L371">        decStack();</span>
<span class="nc" id="L372">    }</span>

    public void opc_astore_2() {
<span class="fc" id="L375">        emitByte(opc_astore_2);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (maxLocals &lt; 3) maxLocals = 3;</span>
<span class="fc" id="L377">        decStack();</span>
<span class="fc" id="L378">    }</span>

    public void opc_astore_3() {
<span class="fc" id="L381">        emitByte(opc_astore_3);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (maxLocals &lt; 4) maxLocals = 4;</span>
<span class="fc" id="L383">        decStack();</span>
<span class="fc" id="L384">    }</span>

    ////////////////////////
    // Stack manipulation //
    ////////////////////////

    public void opc_pop() {
<span class="nc" id="L391">        emitByte(opc_pop);</span>
<span class="nc" id="L392">        decStack();</span>
<span class="nc" id="L393">    }</span>

    public void opc_dup() {
<span class="fc" id="L396">        emitByte(opc_dup);</span>
<span class="fc" id="L397">        incStack();</span>
<span class="fc" id="L398">    }</span>

    public void opc_dup_x1() {
<span class="fc" id="L401">        emitByte(opc_dup_x1);</span>
<span class="fc" id="L402">        incStack();</span>
<span class="fc" id="L403">    }</span>

    public void opc_swap() {
<span class="fc" id="L406">        emitByte(opc_swap);</span>
<span class="fc" id="L407">    }</span>

    ///////////////////////////////
    // Widening conversions only //
    ///////////////////////////////

    public void opc_i2l() {
<span class="fc" id="L414">        emitByte(opc_i2l);</span>
<span class="fc" id="L415">    }</span>

    public void opc_i2f() {
<span class="nc" id="L418">        emitByte(opc_i2f);</span>
<span class="nc" id="L419">    }</span>

    public void opc_i2d() {
<span class="nc" id="L422">        emitByte(opc_i2d);</span>
<span class="nc" id="L423">    }</span>

    public void opc_l2f() {
<span class="nc" id="L426">        emitByte(opc_l2f);</span>
<span class="nc" id="L427">    }</span>

    public void opc_l2d() {
<span class="nc" id="L430">        emitByte(opc_l2d);</span>
<span class="nc" id="L431">    }</span>

    public void opc_f2d() {
<span class="nc" id="L434">        emitByte(opc_f2d);</span>
<span class="nc" id="L435">    }</span>

    //////////////////
    // Control flow //
    //////////////////

    public void opc_ifeq(short bciOffset) {
<span class="nc" id="L442">        emitByte(opc_ifeq);</span>
<span class="nc" id="L443">        emitShort(bciOffset);</span>
<span class="nc" id="L444">        decStack();</span>
<span class="nc" id="L445">    }</span>

    /** Control flow with forward-reference BCI. Stack assumes
        straight-through control flow. */
    public void opc_ifeq(Label l) {
<span class="fc" id="L450">        short instrBCI = getLength();</span>
<span class="fc" id="L451">        emitByte(opc_ifeq);</span>
<span class="fc" id="L452">        l.add(this, instrBCI, getLength(), getStack() - 1);</span>
<span class="fc" id="L453">        emitShort((short) -1); // Must be patched later</span>
<span class="fc" id="L454">    }</span>

    public void opc_if_icmpeq(short bciOffset) {
<span class="nc" id="L457">        emitByte(opc_if_icmpeq);</span>
<span class="nc" id="L458">        emitShort(bciOffset);</span>
<span class="nc" id="L459">        setStack(getStack() - 2);</span>
<span class="nc" id="L460">    }</span>

    /** Control flow with forward-reference BCI. Stack assumes straight
        control flow. */
    public void opc_if_icmpeq(Label l) {
<span class="fc" id="L465">        short instrBCI = getLength();</span>
<span class="fc" id="L466">        emitByte(opc_if_icmpeq);</span>
<span class="fc" id="L467">        l.add(this, instrBCI, getLength(), getStack() - 2);</span>
<span class="fc" id="L468">        emitShort((short) -1); // Must be patched later</span>
<span class="fc" id="L469">    }</span>

    public void opc_goto(short bciOffset) {
<span class="nc" id="L472">        emitByte(opc_goto);</span>
<span class="nc" id="L473">        emitShort(bciOffset);</span>
<span class="nc" id="L474">    }</span>

    /** Control flow with forward-reference BCI. Stack assumes straight
        control flow. */
    public void opc_goto(Label l) {
<span class="fc" id="L479">        short instrBCI = getLength();</span>
<span class="fc" id="L480">        emitByte(opc_goto);</span>
<span class="fc" id="L481">        l.add(this, instrBCI, getLength(), getStack());</span>
<span class="fc" id="L482">        emitShort((short) -1); // Must be patched later</span>
<span class="fc" id="L483">    }</span>

    public void opc_ifnull(short bciOffset) {
<span class="nc" id="L486">        emitByte(opc_ifnull);</span>
<span class="nc" id="L487">        emitShort(bciOffset);</span>
<span class="nc" id="L488">        decStack();</span>
<span class="nc" id="L489">    }</span>

    /** Control flow with forward-reference BCI. Stack assumes straight
        control flow. */
    public void opc_ifnull(Label l) {
<span class="fc" id="L494">        short instrBCI = getLength();</span>
<span class="fc" id="L495">        emitByte(opc_ifnull);</span>
<span class="fc" id="L496">        l.add(this, instrBCI, getLength(), getStack() - 1);</span>
<span class="fc" id="L497">        emitShort((short) -1); // Must be patched later</span>
<span class="fc" id="L498">        decStack();</span>
<span class="fc" id="L499">    }</span>

    public void opc_ifnonnull(short bciOffset) {
<span class="nc" id="L502">        emitByte(opc_ifnonnull);</span>
<span class="nc" id="L503">        emitShort(bciOffset);</span>
<span class="nc" id="L504">        decStack();</span>
<span class="nc" id="L505">    }</span>

    /** Control flow with forward-reference BCI. Stack assumes straight
        control flow. */
    public void opc_ifnonnull(Label l) {
<span class="fc" id="L510">        short instrBCI = getLength();</span>
<span class="fc" id="L511">        emitByte(opc_ifnonnull);</span>
<span class="fc" id="L512">        l.add(this, instrBCI, getLength(), getStack() - 1);</span>
<span class="fc" id="L513">        emitShort((short) -1); // Must be patched later</span>
<span class="fc" id="L514">        decStack();</span>
<span class="fc" id="L515">    }</span>

    /////////////////////////
    // Return instructions //
    /////////////////////////

    public void opc_ireturn() {
<span class="nc" id="L522">        emitByte(opc_ireturn);</span>
<span class="nc" id="L523">        setStack(0);</span>
<span class="nc" id="L524">    }</span>

    public void opc_lreturn() {
<span class="nc" id="L527">        emitByte(opc_lreturn);</span>
<span class="nc" id="L528">        setStack(0);</span>
<span class="nc" id="L529">    }</span>

    public void opc_freturn() {
<span class="nc" id="L532">        emitByte(opc_freturn);</span>
<span class="nc" id="L533">        setStack(0);</span>
<span class="nc" id="L534">    }</span>

    public void opc_dreturn() {
<span class="nc" id="L537">        emitByte(opc_dreturn);</span>
<span class="nc" id="L538">        setStack(0);</span>
<span class="nc" id="L539">    }</span>

    public void opc_areturn() {
<span class="fc" id="L542">        emitByte(opc_areturn);</span>
<span class="fc" id="L543">        setStack(0);</span>
<span class="fc" id="L544">    }</span>

    public void opc_return() {
<span class="fc" id="L547">        emitByte(opc_return);</span>
<span class="fc" id="L548">        setStack(0);</span>
<span class="fc" id="L549">    }</span>

    //////////////////////
    // Field operations //
    //////////////////////

    public void opc_getstatic(short fieldIndex, int fieldSizeInStackSlots) {
<span class="nc" id="L556">        emitByte(opc_getstatic);</span>
<span class="nc" id="L557">        emitShort(fieldIndex);</span>
<span class="nc" id="L558">        setStack(getStack() + fieldSizeInStackSlots);</span>
<span class="nc" id="L559">    }</span>

    public void opc_putstatic(short fieldIndex, int fieldSizeInStackSlots) {
<span class="nc" id="L562">        emitByte(opc_putstatic);</span>
<span class="nc" id="L563">        emitShort(fieldIndex);</span>
<span class="nc" id="L564">        setStack(getStack() - fieldSizeInStackSlots);</span>
<span class="nc" id="L565">    }</span>

    public void opc_getfield(short fieldIndex, int fieldSizeInStackSlots) {
<span class="nc" id="L568">        emitByte(opc_getfield);</span>
<span class="nc" id="L569">        emitShort(fieldIndex);</span>
<span class="nc" id="L570">        setStack(getStack() + fieldSizeInStackSlots - 1);</span>
<span class="nc" id="L571">    }</span>

    public void opc_putfield(short fieldIndex, int fieldSizeInStackSlots) {
<span class="nc" id="L574">        emitByte(opc_putfield);</span>
<span class="nc" id="L575">        emitShort(fieldIndex);</span>
<span class="nc" id="L576">        setStack(getStack() - fieldSizeInStackSlots - 1);</span>
<span class="nc" id="L577">    }</span>

    ////////////////////////
    // Method invocations //
    ////////////////////////

    /** Long and double arguments and return types count as 2 arguments;
        other values count as 1. */
    public void opc_invokevirtual(short methodIndex,
                                  int numArgs,
                                  int numReturnValues)
    {
<span class="fc" id="L589">        emitByte(opc_invokevirtual);</span>
<span class="fc" id="L590">        emitShort(methodIndex);</span>
<span class="fc" id="L591">        setStack(getStack() - numArgs - 1 + numReturnValues);</span>
<span class="fc" id="L592">    }</span>

    /** Long and double arguments and return types count as 2 arguments;
        other values count as 1. */
    public void opc_invokespecial(short methodIndex,
                                  int numArgs,
                                  int numReturnValues)
    {
<span class="fc" id="L600">        emitByte(opc_invokespecial);</span>
<span class="fc" id="L601">        emitShort(methodIndex);</span>
<span class="fc" id="L602">        setStack(getStack() - numArgs - 1 + numReturnValues);</span>
<span class="fc" id="L603">    }</span>

    /** Long and double arguments and return types count as 2 arguments;
        other values count as 1. */
    public void opc_invokestatic(short methodIndex,
                                 int numArgs,
                                 int numReturnValues)
    {
<span class="fc" id="L611">        emitByte(opc_invokestatic);</span>
<span class="fc" id="L612">        emitShort(methodIndex);</span>
<span class="fc" id="L613">        setStack(getStack() - numArgs + numReturnValues);</span>
<span class="fc" id="L614">    }</span>

    /** Long and double arguments and return types count as 2 arguments;
        other values count as 1. */
    public void opc_invokeinterface(short methodIndex,
                                    int numArgs,
                                    byte count,
                                    int numReturnValues)
    {
<span class="fc" id="L623">        emitByte(opc_invokeinterface);</span>
<span class="fc" id="L624">        emitShort(methodIndex);</span>
<span class="fc" id="L625">        emitByte(count);</span>
<span class="fc" id="L626">        emitByte((byte) 0);</span>
<span class="fc" id="L627">        setStack(getStack() - numArgs - 1 + numReturnValues);</span>
<span class="fc" id="L628">    }</span>

    //////////////////
    // Array length //
    //////////////////

    public void opc_arraylength() {
<span class="fc" id="L635">        emitByte(opc_arraylength);</span>
<span class="fc" id="L636">    }</span>

    /////////
    // New //
    /////////

    public void opc_new(short classIndex) {
<span class="fc" id="L643">        emitByte(opc_new);</span>
<span class="fc" id="L644">        emitShort(classIndex);</span>
<span class="fc" id="L645">        incStack();</span>
<span class="fc" id="L646">    }</span>

    ////////////
    // Athrow //
    ////////////

    public void opc_athrow() {
<span class="fc" id="L653">        emitByte(opc_athrow);</span>
<span class="fc" id="L654">        setStack(1);</span>
<span class="fc" id="L655">    }</span>

    //////////////////////////////
    // Checkcast and instanceof //
    //////////////////////////////

    /** Assumes the checkcast succeeds */
    public void opc_checkcast(short classIndex) {
<span class="fc" id="L663">        emitByte(opc_checkcast);</span>
<span class="fc" id="L664">        emitShort(classIndex);</span>
<span class="fc" id="L665">    }</span>

    public void opc_instanceof(short classIndex) {
<span class="fc" id="L668">        emitByte(opc_instanceof);</span>
<span class="fc" id="L669">        emitShort(classIndex);</span>
<span class="fc" id="L670">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>