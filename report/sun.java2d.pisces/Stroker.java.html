<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Stroker.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pisces</a> &gt; <span class="el_source">Stroker.java</span></div><h1>Stroker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pisces;

import java.util.Arrays;
import java.util.Iterator;
import static java.lang.Math.ulp;
import static java.lang.Math.sqrt;

import sun.awt.geom.PathConsumer2D;

// TODO: some of the arithmetic here is too verbose and prone to hard to
// debug typos. We should consider making a small Point/Vector class that
// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
<span class="nc bnc" id="L38" title="All 2 branches missed.">final class Stroker implements PathConsumer2D {</span>

    private static final int MOVE_TO = 0;
    private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
    private static final int CLOSE = 2;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_MITER = 0;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_ROUND = 1;

    /**
     * Constant value for join style.
     */
    public static final int JOIN_BEVEL = 2;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_BUTT = 0;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_ROUND = 1;

    /**
     * Constant value for end cap style.
     */
    public static final int CAP_SQUARE = 2;

    private final PathConsumer2D out;

    private final int capStyle;
    private final int joinStyle;

    private final float lineWidth2;

<span class="nc" id="L81">    private final float[][] offset = new float[3][2];</span>
<span class="nc" id="L82">    private final float[] miter = new float[2];</span>
    private final float miterLimitSq;

    private int prev;

    // The starting point of the path, and the slope there.
    private float sx0, sy0, sdx, sdy;
    // the current point and the slope there.
    private float cx0, cy0, cdx, cdy; // c stands for current
    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
    // first and last points on the left parallel path. Since this path is
    // parallel, it's slope at any point is parallel to the slope of the
    // original path (thought they may have different directions), so these
    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
    // would be error prone and hard to read, so we keep these anyway.
    private float smx, smy, cmx, cmy;

<span class="nc" id="L99">    private final PolyStack reverse = new PolyStack();</span>

    /**
     * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
     *
     * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
     * @param lineWidth the desired line width in pixels
     * @param capStyle the desired end cap style, one of
     * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
     * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
     * @param joinStyle the desired line join style, one of
     * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
     * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
     * @param miterLimit the desired miter limit
     */
    public Stroker(PathConsumer2D pc2d,
                   float lineWidth,
                   int capStyle,
                   int joinStyle,
                   float miterLimit)
<span class="nc" id="L119">    {</span>
<span class="nc" id="L120">        this.out = pc2d;</span>

<span class="nc" id="L122">        this.lineWidth2 = lineWidth / 2;</span>
<span class="nc" id="L123">        this.capStyle = capStyle;</span>
<span class="nc" id="L124">        this.joinStyle = joinStyle;</span>

<span class="nc" id="L126">        float limit = miterLimit * lineWidth2;</span>
<span class="nc" id="L127">        this.miterLimitSq = limit*limit;</span>

<span class="nc" id="L129">        this.prev = CLOSE;</span>
<span class="nc" id="L130">    }</span>

    private static void computeOffset(final float lx, final float ly,
                                      final float w, final float[] m)
    {
<span class="nc" id="L135">        final float len = (float) sqrt(lx*lx + ly*ly);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc" id="L137">            m[0] = m[1] = 0;</span>
        } else {
<span class="nc" id="L139">            m[0] = (ly * w)/len;</span>
<span class="nc" id="L140">            m[1] = -(lx * w)/len;</span>
        }
<span class="nc" id="L142">    }</span>

    // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
    // clockwise (if dx1,dy1 needs to be rotated clockwise to close
    // the smallest angle between it and dx2,dy2).
    // This is equivalent to detecting whether a point q is on the right side
    // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
    // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
    // clockwise order.
    // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
    private static boolean isCW(final float dx1, final float dy1,
                                final float dx2, final float dy2)
    {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        return dx1 * dy2 &lt;= dy1 * dx2;</span>
    }

    // pisces used to use fixed point arithmetic with 16 decimal digits. I
    // didn't want to change the values of the constant below when I converted
    // it to floating point, so that's why the divisions by 2^16 are there.
    private static final float ROUND_JOIN_THRESHOLD = 1000/65536f;

    private void drawRoundJoin(float x, float y,
                               float omx, float omy, float mx, float my,
                               boolean rev,
                               float threshold)
    {
<span class="nc bnc" id="L168" title="All 8 branches missed.">        if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {</span>
<span class="nc" id="L169">            return;</span>
        }

<span class="nc" id="L172">        float domx = omx - mx;</span>
<span class="nc" id="L173">        float domy = omy - my;</span>
<span class="nc" id="L174">        float len = domx*domx + domy*domy;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (len &lt; threshold) {</span>
<span class="nc" id="L176">            return;</span>
        }

<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (rev) {</span>
<span class="nc" id="L180">            omx = -omx;</span>
<span class="nc" id="L181">            omy = -omy;</span>
<span class="nc" id="L182">            mx = -mx;</span>
<span class="nc" id="L183">            my = -my;</span>
        }
<span class="nc" id="L185">        drawRoundJoin(x, y, omx, omy, mx, my, rev);</span>
<span class="nc" id="L186">    }</span>

    private void drawRoundJoin(float cx, float cy,
                               float omx, float omy,
                               float mx, float my,
                               boolean rev)
    {
        // The sign of the dot product of mx,my and omx,omy is equal to the
        // the sign of the cosine of ext
        // (ext is the angle between omx,omy and mx,my).
<span class="nc" id="L196">        double cosext = omx * mx + omy * my;</span>
        // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
        // need 1 curve to approximate the circle section that joins omx,omy
        // and mx,my.
<span class="nc bnc" id="L200" title="All 2 branches missed.">        final int numCurves = cosext &gt;= 0 ? 1 : 2;</span>

<span class="nc bnc" id="L202" title="All 3 branches missed.">        switch (numCurves) {</span>
        case 1:
<span class="nc" id="L204">            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);</span>
<span class="nc" id="L205">            break;</span>
        case 2:
            // we need to split the arc into 2 arcs spanning the same angle.
            // The point we want will be one of the 2 intersections of the
            // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
            // circle. We could find this by scaling the vector
            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
            // on the circle), but that can have numerical problems when the angle
            // between omx,omy and mx,my is close to 180 degrees. So we compute a
            // normal of (omx,omy)-(mx,my). This will be the direction of the
            // perpendicular bisector. To get one of the intersections, we just scale
            // this vector that its length is lineWidth2 (this works because the
            // perpendicular bisector goes through the origin). This scaling doesn't
            // have numerical problems because we know that lineWidth2 divided by
            // this normal's length is at least 0.5 and at most sqrt(2)/2 (because
            // we know the angle of the arc is &gt; 90 degrees).
<span class="nc" id="L221">            float nx = my - omy, ny = omx - mx;</span>
<span class="nc" id="L222">            float nlen = (float) sqrt(nx*nx + ny*ny);</span>
<span class="nc" id="L223">            float scale = lineWidth2/nlen;</span>
<span class="nc" id="L224">            float mmx = nx * scale, mmy = ny * scale;</span>

            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've
            // computed the wrong intersection so we get the other one.
            // The test above is equivalent to if (rev).
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (rev) {</span>
<span class="nc" id="L230">                mmx = -mmx;</span>
<span class="nc" id="L231">                mmy = -mmy;</span>
            }
<span class="nc" id="L233">            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);</span>
<span class="nc" id="L234">            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);</span>
            break;
        }
<span class="nc" id="L237">    }</span>

    // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
    private void drawBezApproxForArc(final float cx, final float cy,
                                     final float omx, final float omy,
                                     final float mx, final float my,
                                     boolean rev)
    {
<span class="nc" id="L245">        float cosext2 = (omx * mx + omy * my) / (2 * lineWidth2 * lineWidth2);</span>
        // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
        // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
        // define the bezier curve we're computing.
        // It is computed using the constraints that P1-P0 and P3-P2 are parallel
        // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
<span class="nc" id="L251">        float cv = (float) ((4.0 / 3.0) * sqrt(0.5-cosext2) /</span>
<span class="nc" id="L252">                            (1.0 + sqrt(cosext2+0.5)));</span>
        // if clockwise, we need to negate cv.
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)</span>
<span class="nc" id="L255">            cv = -cv;</span>
        }
<span class="nc" id="L257">        final float x1 = cx + omx;</span>
<span class="nc" id="L258">        final float y1 = cy + omy;</span>
<span class="nc" id="L259">        final float x2 = x1 - cv * omy;</span>
<span class="nc" id="L260">        final float y2 = y1 + cv * omx;</span>

<span class="nc" id="L262">        final float x4 = cx + mx;</span>
<span class="nc" id="L263">        final float y4 = cy + my;</span>
<span class="nc" id="L264">        final float x3 = x4 + cv * my;</span>
<span class="nc" id="L265">        final float y3 = y4 - cv * mx;</span>

<span class="nc" id="L267">        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);</span>
<span class="nc" id="L268">    }</span>

    private void drawRoundCap(float cx, float cy, float mx, float my) {
        final float C = 0.5522847498307933f;
        // the first and second arguments of the following two calls
        // are really will be ignored by emitCurveTo (because of the false),
        // but we put them in anyway, as opposed to just giving it 4 zeroes,
        // because it's just 4 additions and it's not good to rely on this
        // sort of assumption (right now it's true, but that may change).
<span class="nc" id="L277">        emitCurveTo(cx+mx,      cy+my,</span>
                    cx+mx-C*my, cy+my+C*mx,
                    cx-my+C*mx, cy+mx+C*my,
                    cx-my,      cy+mx,
                    false);
<span class="nc" id="L282">        emitCurveTo(cx-my,      cy+mx,</span>
                    cx-my-C*mx, cy+mx-C*my,
                    cx-mx-C*my, cy-my+C*mx,
                    cx-mx,      cy-my,
                    false);
<span class="nc" id="L287">    }</span>

    // Put the intersection point of the lines (x0, y0) -&gt; (x1, y1)
    // and (x0p, y0p) -&gt; (x1p, y1p) in m[off] and m[off+1].
    // If the lines are parallel, it will put a non finite number in m.
    private void computeIntersection(final float x0, final float y0,
                                     final float x1, final float y1,
                                     final float x0p, final float y0p,
                                     final float x1p, final float y1p,
                                     final float[] m, int off)
    {
<span class="nc" id="L298">        float x10 = x1 - x0;</span>
<span class="nc" id="L299">        float y10 = y1 - y0;</span>
<span class="nc" id="L300">        float x10p = x1p - x0p;</span>
<span class="nc" id="L301">        float y10p = y1p - y0p;</span>

<span class="nc" id="L303">        float den = x10*y10p - x10p*y10;</span>
<span class="nc" id="L304">        float t = x10p*(y0-y0p) - y10p*(x0-x0p);</span>
<span class="nc" id="L305">        t /= den;</span>
<span class="nc" id="L306">        m[off++] = x0 + t*x10;</span>
<span class="nc" id="L307">        m[off] = y0 + t*y10;</span>
<span class="nc" id="L308">    }</span>

    private void drawMiter(final float pdx, final float pdy,
                           final float x0, final float y0,
                           final float dx, final float dy,
                           float omx, float omy, float mx, float my,
                           boolean rev)
    {
<span class="nc bnc" id="L316" title="All 12 branches missed.">        if ((mx == omx &amp;&amp; my == omy) ||</span>
            (pdx == 0 &amp;&amp; pdy == 0) ||
            (dx == 0 &amp;&amp; dy == 0))
        {
<span class="nc" id="L320">            return;</span>
        }

<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (rev) {</span>
<span class="nc" id="L324">            omx = -omx;</span>
<span class="nc" id="L325">            omy = -omy;</span>
<span class="nc" id="L326">            mx = -mx;</span>
<span class="nc" id="L327">            my = -my;</span>
        }

<span class="nc" id="L330">        computeIntersection((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,</span>
                            (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
                            miter, 0);

<span class="nc" id="L334">        float lenSq = (miter[0]-x0)*(miter[0]-x0) + (miter[1]-y0)*(miter[1]-y0);</span>

        // If the lines are parallel, lenSq will be either NaN or +inf
        // (actually, I'm not sure if the latter is possible. The important
        // thing is that -inf is not possible, because lenSq is a square).
        // For both of those values, the comparison below will fail and
        // no miter will be drawn, which is correct.
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (lenSq &lt; miterLimitSq) {</span>
<span class="nc" id="L342">            emitLineTo(miter[0], miter[1], rev);</span>
        }
<span class="nc" id="L344">    }</span>

    public void moveTo(float x0, float y0) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (prev == DRAWING_OP_TO) {</span>
<span class="nc" id="L348">            finish();</span>
        }
<span class="nc" id="L350">        this.sx0 = this.cx0 = x0;</span>
<span class="nc" id="L351">        this.sy0 = this.cy0 = y0;</span>
<span class="nc" id="L352">        this.cdx = this.sdx = 1;</span>
<span class="nc" id="L353">        this.cdy = this.sdy = 0;</span>
<span class="nc" id="L354">        this.prev = MOVE_TO;</span>
<span class="nc" id="L355">    }</span>

    public void lineTo(float x1, float y1) {
<span class="nc" id="L358">        float dx = x1 - cx0;</span>
<span class="nc" id="L359">        float dy = y1 - cy0;</span>
<span class="nc bnc" id="L360" title="All 4 branches missed.">        if (dx == 0f &amp;&amp; dy == 0f) {</span>
<span class="nc" id="L361">            dx = 1;</span>
        }
<span class="nc" id="L363">        computeOffset(dx, dy, lineWidth2, offset[0]);</span>
<span class="nc" id="L364">        float mx = offset[0][0];</span>
<span class="nc" id="L365">        float my = offset[0][1];</span>

<span class="nc" id="L367">        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my);</span>

<span class="nc" id="L369">        emitLineTo(cx0 + mx, cy0 + my);</span>
<span class="nc" id="L370">        emitLineTo(x1 + mx, y1 + my);</span>

<span class="nc" id="L372">        emitLineTo(cx0 - mx, cy0 - my, true);</span>
<span class="nc" id="L373">        emitLineTo(x1 - mx, y1 - my, true);</span>

<span class="nc" id="L375">        this.cmx = mx;</span>
<span class="nc" id="L376">        this.cmy = my;</span>
<span class="nc" id="L377">        this.cdx = dx;</span>
<span class="nc" id="L378">        this.cdy = dy;</span>
<span class="nc" id="L379">        this.cx0 = x1;</span>
<span class="nc" id="L380">        this.cy0 = y1;</span>
<span class="nc" id="L381">        this.prev = DRAWING_OP_TO;</span>
<span class="nc" id="L382">    }</span>

    public void closePath() {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (prev != DRAWING_OP_TO) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            if (prev == CLOSE) {</span>
<span class="nc" id="L387">                return;</span>
            }
<span class="nc" id="L389">            emitMoveTo(cx0, cy0 - lineWidth2);</span>
<span class="nc" id="L390">            this.cmx = this.smx = 0;</span>
<span class="nc" id="L391">            this.cmy = this.smy = -lineWidth2;</span>
<span class="nc" id="L392">            this.cdx = this.sdx = 1;</span>
<span class="nc" id="L393">            this.cdy = this.sdy = 0;</span>
<span class="nc" id="L394">            finish();</span>
<span class="nc" id="L395">            return;</span>
        }

<span class="nc bnc" id="L398" title="All 4 branches missed.">        if (cx0 != sx0 || cy0 != sy0) {</span>
<span class="nc" id="L399">            lineTo(sx0, sy0);</span>
        }

<span class="nc" id="L402">        drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy);</span>

<span class="nc" id="L404">        emitLineTo(sx0 + smx, sy0 + smy);</span>

<span class="nc" id="L406">        emitMoveTo(sx0 - smx, sy0 - smy);</span>
<span class="nc" id="L407">        emitReverse();</span>

<span class="nc" id="L409">        this.prev = CLOSE;</span>
<span class="nc" id="L410">        emitClose();</span>
<span class="nc" id="L411">    }</span>

    private void emitReverse() {
<span class="nc bnc" id="L414" title="All 2 branches missed.">        while(!reverse.isEmpty()) {</span>
<span class="nc" id="L415">            reverse.pop(out);</span>
        }
<span class="nc" id="L417">    }</span>

    public void pathDone() {
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (prev == DRAWING_OP_TO) {</span>
<span class="nc" id="L421">            finish();</span>
        }

<span class="nc" id="L424">        out.pathDone();</span>
        // this shouldn't matter since this object won't be used
        // after the call to this method.
<span class="nc" id="L427">        this.prev = CLOSE;</span>
<span class="nc" id="L428">    }</span>

    private void finish() {
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (capStyle == CAP_ROUND) {</span>
<span class="nc" id="L432">            drawRoundCap(cx0, cy0, cmx, cmy);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        } else if (capStyle == CAP_SQUARE) {</span>
<span class="nc" id="L434">            emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);</span>
<span class="nc" id="L435">            emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);</span>
        }

<span class="nc" id="L438">        emitReverse();</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (capStyle == CAP_ROUND) {</span>
<span class="nc" id="L441">            drawRoundCap(sx0, sy0, -smx, -smy);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        } else if (capStyle == CAP_SQUARE) {</span>
<span class="nc" id="L443">            emitLineTo(sx0 + smy - smx, sy0 - smx - smy);</span>
<span class="nc" id="L444">            emitLineTo(sx0 + smy + smx, sy0 - smx + smy);</span>
        }

<span class="nc" id="L447">        emitClose();</span>
<span class="nc" id="L448">    }</span>

    private void emitMoveTo(final float x0, final float y0) {
<span class="nc" id="L451">        out.moveTo(x0, y0);</span>
<span class="nc" id="L452">    }</span>

    private void emitLineTo(final float x1, final float y1) {
<span class="nc" id="L455">        out.lineTo(x1, y1);</span>
<span class="nc" id="L456">    }</span>

    private void emitLineTo(final float x1, final float y1,
                            final boolean rev)
    {
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (rev) {</span>
<span class="nc" id="L462">            reverse.pushLine(x1, y1);</span>
        } else {
<span class="nc" id="L464">            emitLineTo(x1, y1);</span>
        }
<span class="nc" id="L466">    }</span>

    private void emitQuadTo(final float x0, final float y0,
                            final float x1, final float y1,
                            final float x2, final float y2, final boolean rev)
    {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (rev) {</span>
<span class="nc" id="L473">            reverse.pushQuad(x0, y0, x1, y1);</span>
        } else {
<span class="nc" id="L475">            out.quadTo(x1, y1, x2, y2);</span>
        }
<span class="nc" id="L477">    }</span>

    private void emitCurveTo(final float x0, final float y0,
                             final float x1, final float y1,
                             final float x2, final float y2,
                             final float x3, final float y3, final boolean rev)
    {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (rev) {</span>
<span class="nc" id="L485">            reverse.pushCubic(x0, y0, x1, y1, x2, y2);</span>
        } else {
<span class="nc" id="L487">            out.curveTo(x1, y1, x2, y2, x3, y3);</span>
        }
<span class="nc" id="L489">    }</span>

    private void emitClose() {
<span class="nc" id="L492">        out.closePath();</span>
<span class="nc" id="L493">    }</span>

    private void drawJoin(float pdx, float pdy,
                          float x0, float y0,
                          float dx, float dy,
                          float omx, float omy,
                          float mx, float my)
    {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (prev != DRAWING_OP_TO) {</span>
<span class="nc" id="L502">            emitMoveTo(x0 + mx, y0 + my);</span>
<span class="nc" id="L503">            this.sdx = dx;</span>
<span class="nc" id="L504">            this.sdy = dy;</span>
<span class="nc" id="L505">            this.smx = mx;</span>
<span class="nc" id="L506">            this.smy = my;</span>
        } else {
<span class="nc" id="L508">            boolean cw = isCW(pdx, pdy, dx, dy);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            if (joinStyle == JOIN_MITER) {</span>
<span class="nc" id="L510">                drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            } else if (joinStyle == JOIN_ROUND) {</span>
<span class="nc" id="L512">                drawRoundJoin(x0, y0,</span>
                              omx, omy,
                              mx, my, cw,
                              ROUND_JOIN_THRESHOLD);
            }
<span class="nc bnc" id="L517" title="All 2 branches missed.">            emitLineTo(x0, y0, !cw);</span>
        }
<span class="nc" id="L519">        prev = DRAWING_OP_TO;</span>
<span class="nc" id="L520">    }</span>

    private static boolean within(final float x1, final float y1,
                                  final float x2, final float y2,
                                  final float ERR)
    {
<span class="nc bnc" id="L526" title="All 4 branches missed.">        assert ERR &gt; 0 : &quot;&quot;;</span>
        // compare taxicab distance. ERR will always be small, so using
        // true distance won't give much benefit
<span class="nc bnc" id="L529" title="All 2 branches missed.">        return (Helpers.within(x1, x2, ERR) &amp;&amp;  // we want to avoid calling Math.abs</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                Helpers.within(y1, y2, ERR)); // this is just as good.</span>
    }

    private void getLineOffsets(float x1, float y1,
                                float x2, float y2,
                                float[] left, float[] right) {
<span class="nc" id="L536">        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset[0]);</span>
<span class="nc" id="L537">        left[0] = x1 + offset[0][0];</span>
<span class="nc" id="L538">        left[1] = y1 + offset[0][1];</span>
<span class="nc" id="L539">        left[2] = x2 + offset[0][0];</span>
<span class="nc" id="L540">        left[3] = y2 + offset[0][1];</span>
<span class="nc" id="L541">        right[0] = x1 - offset[0][0];</span>
<span class="nc" id="L542">        right[1] = y1 - offset[0][1];</span>
<span class="nc" id="L543">        right[2] = x2 - offset[0][0];</span>
<span class="nc" id="L544">        right[3] = y2 - offset[0][1];</span>
<span class="nc" id="L545">    }</span>

    private int computeOffsetCubic(float[] pts, final int off,
                                   float[] leftOff, float[] rightOff)
    {
        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
        // vanishes, which creates problems with computeOffset. Usually
        // this happens when this stroker object is trying to winden
        // a curve with a cusp. What happens is that curveTo splits
        // the input curve at the cusp, and passes it to this function.
        // because of inaccuracies in the splitting, we consider points
        // equal if they're very close to each other.
<span class="nc" id="L557">        final float x1 = pts[off + 0], y1 = pts[off + 1];</span>
<span class="nc" id="L558">        final float x2 = pts[off + 2], y2 = pts[off + 3];</span>
<span class="nc" id="L559">        final float x3 = pts[off + 4], y3 = pts[off + 5];</span>
<span class="nc" id="L560">        final float x4 = pts[off + 6], y4 = pts[off + 7];</span>

<span class="nc" id="L562">        float dx4 = x4 - x3;</span>
<span class="nc" id="L563">        float dy4 = y4 - y3;</span>
<span class="nc" id="L564">        float dx1 = x2 - x1;</span>
<span class="nc" id="L565">        float dy1 = y2 - y1;</span>

        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
        // in which case ignore if p1 == p2
<span class="nc" id="L569">        final boolean p1eqp2 = within(x1,y1,x2,y2, 6 * ulp(y2));</span>
<span class="nc" id="L570">        final boolean p3eqp4 = within(x3,y3,x4,y4, 6 * ulp(y4));</span>
<span class="nc bnc" id="L571" title="All 4 branches missed.">        if (p1eqp2 &amp;&amp; p3eqp4) {</span>
<span class="nc" id="L572">            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</span>
<span class="nc" id="L573">            return 4;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        } else if (p1eqp2) {</span>
<span class="nc" id="L575">            dx1 = x3 - x1;</span>
<span class="nc" id="L576">            dy1 = y3 - y1;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        } else if (p3eqp4) {</span>
<span class="nc" id="L578">            dx4 = x4 - x2;</span>
<span class="nc" id="L579">            dy4 = y4 - y2;</span>
        }

        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
<span class="nc" id="L583">        float dotsq = (dx1 * dx4 + dy1 * dy4);</span>
<span class="nc" id="L584">        dotsq = dotsq * dotsq;</span>
<span class="nc" id="L585">        float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        if (Helpers.within(dotsq, l1sq * l4sq, 4 * ulp(dotsq))) {</span>
<span class="nc" id="L587">            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</span>
<span class="nc" id="L588">            return 4;</span>
        }

//      What we're trying to do in this function is to approximate an ideal
//      offset curve (call it I) of the input curve B using a bezier curve Bp.
//      The constraints I use to get the equations are:
//
//      1. The computed curve Bp should go through I(0) and I(1). These are
//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
//
//      2. Bp should have slope equal in absolute value to I at the endpoints. So,
//      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
//      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that
//      vectors I'(0) and Bp'(0) are aligned, which is the same as saying
//      that the tangent lines of I and Bp at 0 are parallel. Mathematically
//      this means (I'(t) || Bp'(t)) &lt;==&gt; (I'(t) = c * Bp'(t)) where c is some
//      nonzero constant.)
//      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and
//      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).
//      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same
//      is true for any bezier curve; therefore, we get the equations
//          (1) p2p = c1 * (p2-p1) + p1p
//          (2) p3p = c2 * (p4-p3) + p4p
//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
//      of unknowns from 4 to 2 (i.e. just c1 and c2).
//      To eliminate these 2 unknowns we use the following constraint:
//
//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
//      We can substitute (1) and (2) from above into (4) and we get:
//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
//      which is equivalent to
//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
//
//      The right side of this is a 2D vector, and we know I(0.5), which gives us
//      Bp(0.5), which gives us the value of the right side.
//      The left side is just a matrix vector multiplication in disguise. It is
//
//      [x2-x1, x4-x3][c1]
//      [y2-y1, y4-y3][c2]
//      which, is equal to
//      [dx1, dx4][c1]
//      [dy1, dy4][c2]
//      At this point we are left with a simple linear system and we solve it by
//      getting the inverse of the matrix above. Then we use [c1,c2] to compute
//      p2p and p3p.

<span class="nc" id="L638">        float x = 0.125f * (x1 + 3 * (x2 + x3) + x4);</span>
<span class="nc" id="L639">        float y = 0.125f * (y1 + 3 * (y2 + y3) + y4);</span>
        // (dxm,dym) is some tangent of B at t=0.5. This means it's equal to
        // c*B'(0.5) for some constant c.
<span class="nc" id="L642">        float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;</span>

        // this computes the offsets at t=0, 0.5, 1, using the property that
        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
        // the (dx/dt, dy/dt) vectors at the endpoints.
<span class="nc" id="L647">        computeOffset(dx1, dy1, lineWidth2, offset[0]);</span>
<span class="nc" id="L648">        computeOffset(dxm, dym, lineWidth2, offset[1]);</span>
<span class="nc" id="L649">        computeOffset(dx4, dy4, lineWidth2, offset[2]);</span>
<span class="nc" id="L650">        float x1p = x1 + offset[0][0]; // start</span>
<span class="nc" id="L651">        float y1p = y1 + offset[0][1]; // point</span>
<span class="nc" id="L652">        float xi  = x + offset[1][0]; // interpolation</span>
<span class="nc" id="L653">        float yi  = y + offset[1][1]; // point</span>
<span class="nc" id="L654">        float x4p = x4 + offset[2][0]; // end</span>
<span class="nc" id="L655">        float y4p = y4 + offset[2][1]; // point</span>

<span class="nc" id="L657">        float invdet43 = 4f / (3f * (dx1 * dy4 - dy1 * dx4));</span>

<span class="nc" id="L659">        float two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;</span>
<span class="nc" id="L660">        float two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;</span>
<span class="nc" id="L661">        float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</span>
<span class="nc" id="L662">        float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</span>

        float x2p, y2p, x3p, y3p;
<span class="nc" id="L665">        x2p = x1p + c1*dx1;</span>
<span class="nc" id="L666">        y2p = y1p + c1*dy1;</span>
<span class="nc" id="L667">        x3p = x4p + c2*dx4;</span>
<span class="nc" id="L668">        y3p = y4p + c2*dy4;</span>

<span class="nc" id="L670">        leftOff[0] = x1p; leftOff[1] = y1p;</span>
<span class="nc" id="L671">        leftOff[2] = x2p; leftOff[3] = y2p;</span>
<span class="nc" id="L672">        leftOff[4] = x3p; leftOff[5] = y3p;</span>
<span class="nc" id="L673">        leftOff[6] = x4p; leftOff[7] = y4p;</span>

<span class="nc" id="L675">        x1p = x1 - offset[0][0]; y1p = y1 - offset[0][1];</span>
<span class="nc" id="L676">        xi = xi - 2 * offset[1][0]; yi = yi - 2 * offset[1][1];</span>
<span class="nc" id="L677">        x4p = x4 - offset[2][0]; y4p = y4 - offset[2][1];</span>

<span class="nc" id="L679">        two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;</span>
<span class="nc" id="L680">        two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;</span>
<span class="nc" id="L681">        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</span>
<span class="nc" id="L682">        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</span>

<span class="nc" id="L684">        x2p = x1p + c1*dx1;</span>
<span class="nc" id="L685">        y2p = y1p + c1*dy1;</span>
<span class="nc" id="L686">        x3p = x4p + c2*dx4;</span>
<span class="nc" id="L687">        y3p = y4p + c2*dy4;</span>

<span class="nc" id="L689">        rightOff[0] = x1p; rightOff[1] = y1p;</span>
<span class="nc" id="L690">        rightOff[2] = x2p; rightOff[3] = y2p;</span>
<span class="nc" id="L691">        rightOff[4] = x3p; rightOff[5] = y3p;</span>
<span class="nc" id="L692">        rightOff[6] = x4p; rightOff[7] = y4p;</span>
<span class="nc" id="L693">        return 8;</span>
    }

    // return the kind of curve in the right and left arrays.
    private int computeOffsetQuad(float[] pts, final int off,
                                  float[] leftOff, float[] rightOff)
    {
<span class="nc" id="L700">        final float x1 = pts[off + 0], y1 = pts[off + 1];</span>
<span class="nc" id="L701">        final float x2 = pts[off + 2], y2 = pts[off + 3];</span>
<span class="nc" id="L702">        final float x3 = pts[off + 4], y3 = pts[off + 5];</span>

<span class="nc" id="L704">        final float dx3 = x3 - x2;</span>
<span class="nc" id="L705">        final float dy3 = y3 - y2;</span>
<span class="nc" id="L706">        final float dx1 = x2 - x1;</span>
<span class="nc" id="L707">        final float dy1 = y2 - y1;</span>

        // this computes the offsets at t = 0, 1
<span class="nc" id="L710">        computeOffset(dx1, dy1, lineWidth2, offset[0]);</span>
<span class="nc" id="L711">        computeOffset(dx3, dy3, lineWidth2, offset[1]);</span>

<span class="nc" id="L713">        leftOff[0]  = x1 + offset[0][0];  leftOff[1] = y1 + offset[0][1];</span>
<span class="nc" id="L714">        leftOff[4]  = x3 + offset[1][0];  leftOff[5] = y3 + offset[1][1];</span>
<span class="nc" id="L715">        rightOff[0] = x1 - offset[0][0]; rightOff[1] = y1 - offset[0][1];</span>
<span class="nc" id="L716">        rightOff[4] = x3 - offset[1][0]; rightOff[5] = y3 - offset[1][1];</span>

<span class="nc" id="L718">        float x1p = leftOff[0]; // start</span>
<span class="nc" id="L719">        float y1p = leftOff[1]; // point</span>
<span class="nc" id="L720">        float x3p = leftOff[4]; // end</span>
<span class="nc" id="L721">        float y3p = leftOff[5]; // point</span>

        // Corner cases:
        // 1. If the two control vectors are parallel, we'll end up with NaN's
        //    in leftOff (and rightOff in the body of the if below), so we'll
        //    do getLineOffsets, which is right.
        // 2. If the first or second two points are equal, then (dx1,dy1)==(0,0)
        //    or (dx3,dy3)==(0,0), so (x1p, y1p)==(x1p+dx1, y1p+dy1)
        //    or (x3p, y3p)==(x3p-dx3, y3p-dy3), which means that
        //    computeIntersection will put NaN's in leftOff and right off, and
        //    we will do getLineOffsets, which is right.
<span class="nc" id="L732">        computeIntersection(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);</span>
<span class="nc" id="L733">        float cx = leftOff[2];</span>
<span class="nc" id="L734">        float cy = leftOff[3];</span>

<span class="nc bnc" id="L736" title="All 4 branches missed.">        if (!(isFinite(cx) &amp;&amp; isFinite(cy))) {</span>
            // maybe the right path is not degenerate.
<span class="nc" id="L738">            x1p = rightOff[0];</span>
<span class="nc" id="L739">            y1p = rightOff[1];</span>
<span class="nc" id="L740">            x3p = rightOff[4];</span>
<span class="nc" id="L741">            y3p = rightOff[5];</span>
<span class="nc" id="L742">            computeIntersection(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);</span>
<span class="nc" id="L743">            cx = rightOff[2];</span>
<span class="nc" id="L744">            cy = rightOff[3];</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">            if (!(isFinite(cx) &amp;&amp; isFinite(cy))) {</span>
                // both are degenerate. This curve is a line.
<span class="nc" id="L747">                getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);</span>
<span class="nc" id="L748">                return 4;</span>
            }
            // {left,right}Off[0,1,4,5] are already set to the correct values.
<span class="nc" id="L751">            leftOff[2] = 2*x2 - cx;</span>
<span class="nc" id="L752">            leftOff[3] = 2*y2 - cy;</span>
<span class="nc" id="L753">            return 6;</span>
        }

        // rightOff[2,3] = (x2,y2) - ((left_x2, left_y2) - (x2, y2))
        // == 2*(x2, y2) - (left_x2, left_y2)
<span class="nc" id="L758">        rightOff[2] = 2*x2 - cx;</span>
<span class="nc" id="L759">        rightOff[3] = 2*y2 - cy;</span>
<span class="nc" id="L760">        return 6;</span>
    }

    private static boolean isFinite(float x) {
<span class="nc bnc" id="L764" title="All 4 branches missed.">        return (Float.NEGATIVE_INFINITY &lt; x &amp;&amp; x &lt; Float.POSITIVE_INFINITY);</span>
    }

    // This is where the curve to be processed is put. We give it
    // enough room to store 2 curves: one for the current subdivision, the
    // other for the rest of the curve.
<span class="nc" id="L770">    private float[] middle = new float[2*8];</span>
<span class="nc" id="L771">    private float[] lp = new float[8];</span>
<span class="nc" id="L772">    private float[] rp = new float[8];</span>
    private static final int MAX_N_CURVES = 11;
<span class="nc" id="L774">    private float[] subdivTs = new float[MAX_N_CURVES - 1];</span>

    // If this class is compiled with ecj, then Hotspot crashes when OSR
    // compiling this function. See bugs 7004570 and 6675699
    // TODO: until those are fixed, we should work around that by
    // manually inlining this into curveTo and quadTo.
/******************************* WORKAROUND **********************************
    private void somethingTo(final int type) {
        // need these so we can update the state at the end of this method
        final float xf = middle[type-2], yf = middle[type-1];
        float dxs = middle[2] - middle[0];
        float dys = middle[3] - middle[1];
        float dxf = middle[type - 2] - middle[type - 4];
        float dyf = middle[type - 1] - middle[type - 3];
        switch(type) {
        case 6:
            if ((dxs == 0f &amp;&amp; dys == 0f) ||
                (dxf == 0f &amp;&amp; dyf == 0f)) {
               dxs = dxf = middle[4] - middle[0];
               dys = dyf = middle[5] - middle[1];
            }
            break;
        case 8:
            boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
            boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
            if (p1eqp2) {
                dxs = middle[4] - middle[0];
                dys = middle[5] - middle[1];
                if (dxs == 0f &amp;&amp; dys == 0f) {
                    dxs = middle[6] - middle[0];
                    dys = middle[7] - middle[1];
                }
            }
            if (p3eqp4) {
                dxf = middle[6] - middle[2];
                dyf = middle[7] - middle[3];
                if (dxf == 0f &amp;&amp; dyf == 0f) {
                    dxf = middle[6] - middle[0];
                    dyf = middle[7] - middle[1];
                }
            }
        }
        if (dxs == 0f &amp;&amp; dys == 0f) {
            // this happens iff the &quot;curve&quot; is just a point
            lineTo(middle[0], middle[1]);
            return;
        }
        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
            float len = (float) sqrt(dxs*dxs + dys*dys);
            dxs /= len;
            dys /= len;
        }
        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
            float len = (float) sqrt(dxf*dxf + dyf*dyf);
            dxf /= len;
            dyf /= len;
        }

        computeOffset(dxs, dys, lineWidth2, offset[0]);
        final float mx = offset[0][0];
        final float my = offset[0][1];
        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);

        int nSplits = findSubdivPoints(middle, subdivTs, type, lineWidth2);

        int kind = 0;
        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
        while(it.hasNext()) {
            int curCurveOff = it.next();

            switch (type) {
            case 8:
                kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
                break;
            case 6:
                kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
                break;
            }
            emitLineTo(lp[0], lp[1]);
            switch(kind) {
            case 8:
                emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
                emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
                break;
            case 6:
                emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
                emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
                break;
            case 4:
                emitLineTo(lp[2], lp[3]);
                emitLineTo(rp[0], rp[1], true);
                break;
            }
            emitLineTo(rp[kind - 2], rp[kind - 1], true);
        }

        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
        this.cdx = dxf;
        this.cdy = dyf;
        this.cx0 = xf;
        this.cy0 = yf;
        this.prev = DRAWING_OP_TO;
    }
****************************** END WORKAROUND *******************************/

    // finds values of t where the curve in pts should be subdivided in order
    // to get good offset curves a distance of w away from the middle curve.
    // Stores the points in ts, and returns how many of them there were.
<span class="nc" id="L885">    private static Curve c = new Curve();</span>
    private static int findSubdivPoints(float[] pts, float[] ts, final int type, final float w)
    {
<span class="nc" id="L888">        final float x12 = pts[2] - pts[0];</span>
<span class="nc" id="L889">        final float y12 = pts[3] - pts[1];</span>
        // if the curve is already parallel to either axis we gain nothing
        // from rotating it.
<span class="nc bnc" id="L892" title="All 4 branches missed.">        if (y12 != 0f &amp;&amp; x12 != 0f) {</span>
            // we rotate it so that the first vector in the control polygon is
            // parallel to the x-axis. This will ensure that rotated quarter
            // circles won't be subdivided.
<span class="nc" id="L896">            final float hypot = (float) sqrt(x12 * x12 + y12 * y12);</span>
<span class="nc" id="L897">            final float cos = x12 / hypot;</span>
<span class="nc" id="L898">            final float sin = y12 / hypot;</span>
<span class="nc" id="L899">            final float x1 = cos * pts[0] + sin * pts[1];</span>
<span class="nc" id="L900">            final float y1 = cos * pts[1] - sin * pts[0];</span>
<span class="nc" id="L901">            final float x2 = cos * pts[2] + sin * pts[3];</span>
<span class="nc" id="L902">            final float y2 = cos * pts[3] - sin * pts[2];</span>
<span class="nc" id="L903">            final float x3 = cos * pts[4] + sin * pts[5];</span>
<span class="nc" id="L904">            final float y3 = cos * pts[5] - sin * pts[4];</span>
<span class="nc bnc" id="L905" title="All 3 branches missed.">            switch(type) {</span>
            case 8:
<span class="nc" id="L907">                final float x4 = cos * pts[6] + sin * pts[7];</span>
<span class="nc" id="L908">                final float y4 = cos * pts[7] - sin * pts[6];</span>
<span class="nc" id="L909">                c.set(x1, y1, x2, y2, x3, y3, x4, y4);</span>
<span class="nc" id="L910">                break;</span>
            case 6:
<span class="nc" id="L912">                c.set(x1, y1, x2, y2, x3, y3);</span>
                break;
            }
<span class="nc" id="L915">        } else {</span>
<span class="nc" id="L916">            c.set(pts, type);</span>
        }

<span class="nc" id="L919">        int ret = 0;</span>
        // we subdivide at values of t such that the remaining rotated
        // curves are monotonic in x and y.
<span class="nc" id="L922">        ret += c.dxRoots(ts, ret);</span>
<span class="nc" id="L923">        ret += c.dyRoots(ts, ret);</span>
        // subdivide at inflection points.
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (type == 8) {</span>
            // quadratic curves can't have inflection points
<span class="nc" id="L927">            ret += c.infPoints(ts, ret);</span>
        }

        // now we must subdivide at points where one of the offset curves will have
        // a cusp. This happens at ts where the radius of curvature is equal to w.
<span class="nc" id="L932">        ret += c.rootsOfROCMinusW(ts, ret, w, 0.0001f);</span>

<span class="nc" id="L934">        ret = Helpers.filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);</span>
<span class="nc" id="L935">        Helpers.isort(ts, 0, ret);</span>
<span class="nc" id="L936">        return ret;</span>
    }

    @Override public void curveTo(float x1, float y1,
                                  float x2, float y2,
                                  float x3, float y3)
    {
<span class="nc" id="L943">        middle[0] = cx0; middle[1] = cy0;</span>
<span class="nc" id="L944">        middle[2] = x1;  middle[3] = y1;</span>
<span class="nc" id="L945">        middle[4] = x2;  middle[5] = y2;</span>
<span class="nc" id="L946">        middle[6] = x3;  middle[7] = y3;</span>

        // inlined version of somethingTo(8);
        // See the TODO on somethingTo

        // need these so we can update the state at the end of this method
<span class="nc" id="L952">        final float xf = middle[6], yf = middle[7];</span>
<span class="nc" id="L953">        float dxs = middle[2] - middle[0];</span>
<span class="nc" id="L954">        float dys = middle[3] - middle[1];</span>
<span class="nc" id="L955">        float dxf = middle[6] - middle[4];</span>
<span class="nc" id="L956">        float dyf = middle[7] - middle[5];</span>

<span class="nc bnc" id="L958" title="All 4 branches missed.">        boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);</span>
<span class="nc bnc" id="L959" title="All 4 branches missed.">        boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">        if (p1eqp2) {</span>
<span class="nc" id="L961">            dxs = middle[4] - middle[0];</span>
<span class="nc" id="L962">            dys = middle[5] - middle[1];</span>
<span class="nc bnc" id="L963" title="All 4 branches missed.">            if (dxs == 0f &amp;&amp; dys == 0f) {</span>
<span class="nc" id="L964">                dxs = middle[6] - middle[0];</span>
<span class="nc" id="L965">                dys = middle[7] - middle[1];</span>
            }
        }
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (p3eqp4) {</span>
<span class="nc" id="L969">            dxf = middle[6] - middle[2];</span>
<span class="nc" id="L970">            dyf = middle[7] - middle[3];</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">            if (dxf == 0f &amp;&amp; dyf == 0f) {</span>
<span class="nc" id="L972">                dxf = middle[6] - middle[0];</span>
<span class="nc" id="L973">                dyf = middle[7] - middle[1];</span>
            }
        }
<span class="nc bnc" id="L976" title="All 4 branches missed.">        if (dxs == 0f &amp;&amp; dys == 0f) {</span>
            // this happens iff the &quot;curve&quot; is just a point
<span class="nc" id="L978">            lineTo(middle[0], middle[1]);</span>
<span class="nc" id="L979">            return;</span>
        }

        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
<span class="nc bnc" id="L984" title="All 4 branches missed.">        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {</span>
<span class="nc" id="L985">            float len = (float) sqrt(dxs*dxs + dys*dys);</span>
<span class="nc" id="L986">            dxs /= len;</span>
<span class="nc" id="L987">            dys /= len;</span>
        }
<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {</span>
<span class="nc" id="L990">            float len = (float) sqrt(dxf*dxf + dyf*dyf);</span>
<span class="nc" id="L991">            dxf /= len;</span>
<span class="nc" id="L992">            dyf /= len;</span>
        }

<span class="nc" id="L995">        computeOffset(dxs, dys, lineWidth2, offset[0]);</span>
<span class="nc" id="L996">        final float mx = offset[0][0];</span>
<span class="nc" id="L997">        final float my = offset[0][1];</span>
<span class="nc" id="L998">        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);</span>

<span class="nc" id="L1000">        int nSplits = findSubdivPoints(middle, subdivTs, 8, lineWidth2);</span>

<span class="nc" id="L1002">        int kind = 0;</span>
<span class="nc" id="L1003">        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, 8, subdivTs, nSplits);</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        while(it.hasNext()) {</span>
<span class="nc" id="L1005">            int curCurveOff = it.next();</span>

<span class="nc" id="L1007">            kind = computeOffsetCubic(middle, curCurveOff, lp, rp);</span>
<span class="nc" id="L1008">            emitLineTo(lp[0], lp[1]);</span>
<span class="nc bnc" id="L1009" title="All 3 branches missed.">            switch(kind) {</span>
            case 8:
<span class="nc" id="L1011">                emitCurveTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);</span>
<span class="nc" id="L1012">                emitCurveTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);</span>
<span class="nc" id="L1013">                break;</span>
            case 4:
<span class="nc" id="L1015">                emitLineTo(lp[2], lp[3]);</span>
<span class="nc" id="L1016">                emitLineTo(rp[0], rp[1], true);</span>
                break;
            }
<span class="nc" id="L1019">            emitLineTo(rp[kind - 2], rp[kind - 1], true);</span>
<span class="nc" id="L1020">        }</span>

<span class="nc" id="L1022">        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;</span>
<span class="nc" id="L1023">        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;</span>
<span class="nc" id="L1024">        this.cdx = dxf;</span>
<span class="nc" id="L1025">        this.cdy = dyf;</span>
<span class="nc" id="L1026">        this.cx0 = xf;</span>
<span class="nc" id="L1027">        this.cy0 = yf;</span>
<span class="nc" id="L1028">        this.prev = DRAWING_OP_TO;</span>
<span class="nc" id="L1029">    }</span>

    @Override public void quadTo(float x1, float y1, float x2, float y2) {
<span class="nc" id="L1032">        middle[0] = cx0; middle[1] = cy0;</span>
<span class="nc" id="L1033">        middle[2] = x1;  middle[3] = y1;</span>
<span class="nc" id="L1034">        middle[4] = x2;  middle[5] = y2;</span>

        // inlined version of somethingTo(8);
        // See the TODO on somethingTo

        // need these so we can update the state at the end of this method
<span class="nc" id="L1040">        final float xf = middle[4], yf = middle[5];</span>
<span class="nc" id="L1041">        float dxs = middle[2] - middle[0];</span>
<span class="nc" id="L1042">        float dys = middle[3] - middle[1];</span>
<span class="nc" id="L1043">        float dxf = middle[4] - middle[2];</span>
<span class="nc" id="L1044">        float dyf = middle[5] - middle[3];</span>
<span class="nc bnc" id="L1045" title="All 8 branches missed.">        if ((dxs == 0f &amp;&amp; dys == 0f) || (dxf == 0f &amp;&amp; dyf == 0f)) {</span>
<span class="nc" id="L1046">            dxs = dxf = middle[4] - middle[0];</span>
<span class="nc" id="L1047">            dys = dyf = middle[5] - middle[1];</span>
        }
<span class="nc bnc" id="L1049" title="All 4 branches missed.">        if (dxs == 0f &amp;&amp; dys == 0f) {</span>
            // this happens iff the &quot;curve&quot; is just a point
<span class="nc" id="L1051">            lineTo(middle[0], middle[1]);</span>
<span class="nc" id="L1052">            return;</span>
        }
        // if these vectors are too small, normalize them, to avoid future
        // precision problems.
<span class="nc bnc" id="L1056" title="All 4 branches missed.">        if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {</span>
<span class="nc" id="L1057">            float len = (float) sqrt(dxs*dxs + dys*dys);</span>
<span class="nc" id="L1058">            dxs /= len;</span>
<span class="nc" id="L1059">            dys /= len;</span>
        }
<span class="nc bnc" id="L1061" title="All 4 branches missed.">        if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {</span>
<span class="nc" id="L1062">            float len = (float) sqrt(dxf*dxf + dyf*dyf);</span>
<span class="nc" id="L1063">            dxf /= len;</span>
<span class="nc" id="L1064">            dyf /= len;</span>
        }

<span class="nc" id="L1067">        computeOffset(dxs, dys, lineWidth2, offset[0]);</span>
<span class="nc" id="L1068">        final float mx = offset[0][0];</span>
<span class="nc" id="L1069">        final float my = offset[0][1];</span>
<span class="nc" id="L1070">        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);</span>

<span class="nc" id="L1072">        int nSplits = findSubdivPoints(middle, subdivTs, 6, lineWidth2);</span>

<span class="nc" id="L1074">        int kind = 0;</span>
<span class="nc" id="L1075">        Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, 6, subdivTs, nSplits);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        while(it.hasNext()) {</span>
<span class="nc" id="L1077">            int curCurveOff = it.next();</span>

<span class="nc" id="L1079">            kind = computeOffsetQuad(middle, curCurveOff, lp, rp);</span>
<span class="nc" id="L1080">            emitLineTo(lp[0], lp[1]);</span>
<span class="nc bnc" id="L1081" title="All 3 branches missed.">            switch(kind) {</span>
            case 6:
<span class="nc" id="L1083">                emitQuadTo(lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);</span>
<span class="nc" id="L1084">                emitQuadTo(rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);</span>
<span class="nc" id="L1085">                break;</span>
            case 4:
<span class="nc" id="L1087">                emitLineTo(lp[2], lp[3]);</span>
<span class="nc" id="L1088">                emitLineTo(rp[0], rp[1], true);</span>
                break;
            }
<span class="nc" id="L1091">            emitLineTo(rp[kind - 2], rp[kind - 1], true);</span>
<span class="nc" id="L1092">        }</span>

<span class="nc" id="L1094">        this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;</span>
<span class="nc" id="L1095">        this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;</span>
<span class="nc" id="L1096">        this.cdx = dxf;</span>
<span class="nc" id="L1097">        this.cdy = dyf;</span>
<span class="nc" id="L1098">        this.cx0 = xf;</span>
<span class="nc" id="L1099">        this.cy0 = yf;</span>
<span class="nc" id="L1100">        this.prev = DRAWING_OP_TO;</span>
<span class="nc" id="L1101">    }</span>

    @Override public long getNativeConsumer() {
<span class="nc" id="L1104">        throw new InternalError(&quot;Stroker doesn't use a native consumer&quot;);</span>
    }

    // a stack of polynomial curves where each curve shares endpoints with
    // adjacent ones.
    private static final class PolyStack {
        float[] curves;
        int end;
        int[] curveTypes;
        int numCurves;

        private static final int INIT_SIZE = 50;

<span class="nc" id="L1117">        PolyStack() {</span>
<span class="nc" id="L1118">            curves = new float[8 * INIT_SIZE];</span>
<span class="nc" id="L1119">            curveTypes = new int[INIT_SIZE];</span>
<span class="nc" id="L1120">            end = 0;</span>
<span class="nc" id="L1121">            numCurves = 0;</span>
<span class="nc" id="L1122">        }</span>

        public boolean isEmpty() {
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            return numCurves == 0;</span>
        }

        private void ensureSpace(int n) {
<span class="nc bnc" id="L1129" title="All 2 branches missed.">            if (end + n &gt;= curves.length) {</span>
<span class="nc" id="L1130">                int newSize = (end + n) * 2;</span>
<span class="nc" id="L1131">                curves = Arrays.copyOf(curves, newSize);</span>
            }
<span class="nc bnc" id="L1133" title="All 2 branches missed.">            if (numCurves &gt;= curveTypes.length) {</span>
<span class="nc" id="L1134">                int newSize = numCurves * 2;</span>
<span class="nc" id="L1135">                curveTypes = Arrays.copyOf(curveTypes, newSize);</span>
            }
<span class="nc" id="L1137">        }</span>

        public void pushCubic(float x0, float y0,
                              float x1, float y1,
                              float x2, float y2)
        {
<span class="nc" id="L1143">            ensureSpace(6);</span>
<span class="nc" id="L1144">            curveTypes[numCurves++] = 8;</span>
            // assert(x0 == lastX &amp;&amp; y0 == lastY)

            // we reverse the coordinate order to make popping easier
<span class="nc" id="L1148">            curves[end++] = x2;    curves[end++] = y2;</span>
<span class="nc" id="L1149">            curves[end++] = x1;    curves[end++] = y1;</span>
<span class="nc" id="L1150">            curves[end++] = x0;    curves[end++] = y0;</span>
<span class="nc" id="L1151">        }</span>

        public void pushQuad(float x0, float y0,
                             float x1, float y1)
        {
<span class="nc" id="L1156">            ensureSpace(4);</span>
<span class="nc" id="L1157">            curveTypes[numCurves++] = 6;</span>
            // assert(x0 == lastX &amp;&amp; y0 == lastY)
<span class="nc" id="L1159">            curves[end++] = x1;    curves[end++] = y1;</span>
<span class="nc" id="L1160">            curves[end++] = x0;    curves[end++] = y0;</span>
<span class="nc" id="L1161">        }</span>

        public void pushLine(float x, float y) {
<span class="nc" id="L1164">            ensureSpace(2);</span>
<span class="nc" id="L1165">            curveTypes[numCurves++] = 4;</span>
            // assert(x0 == lastX &amp;&amp; y0 == lastY)
<span class="nc" id="L1167">            curves[end++] = x;    curves[end++] = y;</span>
<span class="nc" id="L1168">        }</span>

        @SuppressWarnings(&quot;unused&quot;)
        public int pop(float[] pts) {
<span class="nc" id="L1172">            int ret = curveTypes[numCurves - 1];</span>
<span class="nc" id="L1173">            numCurves--;</span>
<span class="nc" id="L1174">            end -= (ret - 2);</span>
<span class="nc" id="L1175">            System.arraycopy(curves, end, pts, 0, ret - 2);</span>
<span class="nc" id="L1176">            return ret;</span>
        }

        public void pop(PathConsumer2D io) {
<span class="nc" id="L1180">            numCurves--;</span>
<span class="nc" id="L1181">            int type = curveTypes[numCurves];</span>
<span class="nc" id="L1182">            end -= (type - 2);</span>
<span class="nc bnc" id="L1183" title="All 4 branches missed.">            switch(type) {</span>
            case 8:
<span class="nc" id="L1185">                io.curveTo(curves[end+0], curves[end+1],</span>
                           curves[end+2], curves[end+3],
                           curves[end+4], curves[end+5]);
<span class="nc" id="L1188">                break;</span>
            case 6:
<span class="nc" id="L1190">                io.quadTo(curves[end+0], curves[end+1],</span>
                           curves[end+2], curves[end+3]);
<span class="nc" id="L1192">                 break;</span>
            case 4:
<span class="nc" id="L1194">                io.lineTo(curves[end], curves[end+1]);</span>
            }
<span class="nc" id="L1196">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L1200">            String ret = &quot;&quot;;</span>
<span class="nc" id="L1201">            int nc = numCurves;</span>
<span class="nc" id="L1202">            int end = this.end;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">            while (nc &gt; 0) {</span>
<span class="nc" id="L1204">                nc--;</span>
<span class="nc" id="L1205">                int type = curveTypes[numCurves];</span>
<span class="nc" id="L1206">                end -= (type - 2);</span>
<span class="nc bnc" id="L1207" title="All 4 branches missed.">                switch(type) {</span>
                case 8:
<span class="nc" id="L1209">                    ret += &quot;cubic: &quot;;</span>
<span class="nc" id="L1210">                    break;</span>
                case 6:
<span class="nc" id="L1212">                    ret += &quot;quad: &quot;;</span>
<span class="nc" id="L1213">                    break;</span>
                case 4:
<span class="nc" id="L1215">                    ret += &quot;line: &quot;;</span>
                    break;
                }
<span class="nc" id="L1218">                ret += Arrays.toString(Arrays.copyOfRange(curves, end, end+type-2)) + &quot;\n&quot;;</span>
<span class="nc" id="L1219">            }</span>
<span class="nc" id="L1220">            return ret;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>