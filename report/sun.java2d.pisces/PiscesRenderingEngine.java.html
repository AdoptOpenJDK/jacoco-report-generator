<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PiscesRenderingEngine.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pisces</a> &gt; <span class="el_source">PiscesRenderingEngine.java</span></div><h1>PiscesRenderingEngine.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pisces;

import java.awt.Shape;
import java.awt.BasicStroke;
import java.awt.geom.Path2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;

import sun.awt.geom.PathConsumer2D;
import sun.java2d.pipe.Region;
import sun.java2d.pipe.RenderingEngine;
import sun.java2d.pipe.AATileGenerator;

<span class="nc" id="L39">public class PiscesRenderingEngine extends RenderingEngine {</span>
<span class="nc" id="L40">    private static enum NormMode {OFF, ON_NO_AA, ON_WITH_AA}</span>

    /**
     * Create a widened path as specified by the parameters.
     * &lt;p&gt;
     * The specified {@code src} {@link Shape} is widened according
     * to the specified attribute parameters as per the
     * {@link BasicStroke} specification.
     *
     * @param src the source path to be widened
     * @param width the width of the widened path as per {@code BasicStroke}
     * @param caps the end cap decorations as per {@code BasicStroke}
     * @param join the segment join decorations as per {@code BasicStroke}
     * @param miterlimit the miter limit as per {@code BasicStroke}
     * @param dashes the dash length array as per {@code BasicStroke}
     * @param dashphase the initial dash phase as per {@code BasicStroke}
     * @return the widened path stored in a new {@code Shape} object
     * @since 1.7
     */
    public Shape createStrokedShape(Shape src,
                                    float width,
                                    int caps,
                                    int join,
                                    float miterlimit,
                                    float dashes[],
                                    float dashphase)
    {
<span class="nc" id="L67">        final Path2D p2d = new Path2D.Float();</span>

<span class="nc" id="L69">        strokeTo(src,</span>
                 null,
                 width,
                 NormMode.OFF,
                 caps,
                 join,
                 miterlimit,
                 dashes,
                 dashphase,
<span class="nc" id="L78">                 new PathConsumer2D() {</span>
                     public void moveTo(float x0, float y0) {
<span class="nc" id="L80">                         p2d.moveTo(x0, y0);</span>
<span class="nc" id="L81">                     }</span>
                     public void lineTo(float x1, float y1) {
<span class="nc" id="L83">                         p2d.lineTo(x1, y1);</span>
<span class="nc" id="L84">                     }</span>
                     public void closePath() {
<span class="nc" id="L86">                         p2d.closePath();</span>
<span class="nc" id="L87">                     }</span>
<span class="nc" id="L88">                     public void pathDone() {}</span>
                     public void curveTo(float x1, float y1,
                                         float x2, float y2,
                                         float x3, float y3) {
<span class="nc" id="L92">                         p2d.curveTo(x1, y1, x2, y2, x3, y3);</span>
<span class="nc" id="L93">                     }</span>
                     public void quadTo(float x1, float y1, float x2, float y2) {
<span class="nc" id="L95">                         p2d.quadTo(x1, y1, x2, y2);</span>
<span class="nc" id="L96">                     }</span>
                     public long getNativeConsumer() {
<span class="nc" id="L98">                         throw new InternalError(&quot;Not using a native peer&quot;);</span>
                     }
                 });
<span class="nc" id="L101">        return p2d;</span>
    }

    /**
     * Sends the geometry for a widened path as specified by the parameters
     * to the specified consumer.
     * &lt;p&gt;
     * The specified {@code src} {@link Shape} is widened according
     * to the parameters specified by the {@link BasicStroke} object.
     * Adjustments are made to the path as appropriate for the
     * {@link VALUE_STROKE_NORMALIZE} hint if the {@code normalize}
     * boolean parameter is true.
     * Adjustments are made to the path as appropriate for the
     * {@link VALUE_ANTIALIAS_ON} hint if the {@code antialias}
     * boolean parameter is true.
     * &lt;p&gt;
     * The geometry of the widened path is forwarded to the indicated
     * {@link PathConsumer2D} object as it is calculated.
     *
     * @param src the source path to be widened
     * @param bs the {@code BasicSroke} object specifying the
     *           decorations to be applied to the widened path
     * @param normalize indicates whether stroke normalization should
     *                  be applied
     * @param antialias indicates whether or not adjustments appropriate
     *                  to antialiased rendering should be applied
     * @param consumer the {@code PathConsumer2D} instance to forward
     *                 the widened geometry to
     * @since 1.7
     */
    public void strokeTo(Shape src,
                         AffineTransform at,
                         BasicStroke bs,
                         boolean thin,
                         boolean normalize,
                         boolean antialias,
                         final PathConsumer2D consumer)
    {
<span class="nc bnc" id="L139" title="All 4 branches missed.">        NormMode norm = (normalize) ?</span>
                ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)
                : NormMode.OFF;
<span class="nc" id="L142">        strokeTo(src, at, bs, thin, norm, antialias, consumer);</span>
<span class="nc" id="L143">    }</span>

    void strokeTo(Shape src,
                  AffineTransform at,
                  BasicStroke bs,
                  boolean thin,
                  NormMode normalize,
                  boolean antialias,
                  PathConsumer2D pc2d)
    {
        float lw;
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (thin) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (antialias) {</span>
<span class="nc" id="L156">                lw = userSpaceLineWidth(at, 0.5f);</span>
            } else {
<span class="nc" id="L158">                lw = userSpaceLineWidth(at, 1.0f);</span>
            }
        } else {
<span class="nc" id="L161">            lw = bs.getLineWidth();</span>
        }
<span class="nc" id="L163">        strokeTo(src,</span>
                 at,
                 lw,
                 normalize,
<span class="nc" id="L167">                 bs.getEndCap(),</span>
<span class="nc" id="L168">                 bs.getLineJoin(),</span>
<span class="nc" id="L169">                 bs.getMiterLimit(),</span>
<span class="nc" id="L170">                 bs.getDashArray(),</span>
<span class="nc" id="L171">                 bs.getDashPhase(),</span>
                 pc2d);
<span class="nc" id="L173">    }</span>

    private float userSpaceLineWidth(AffineTransform at, float lw) {

        double widthScale;

<span class="nc bnc" id="L179" title="All 2 branches missed.">        if ((at.getType() &amp; (AffineTransform.TYPE_GENERAL_TRANSFORM |</span>
                            AffineTransform.TYPE_GENERAL_SCALE)) != 0) {
<span class="nc" id="L181">            widthScale = Math.sqrt(at.getDeterminant());</span>
        } else {
            /* First calculate the &quot;maximum scale&quot; of this transform. */
<span class="nc" id="L184">            double A = at.getScaleX();       // m00</span>
<span class="nc" id="L185">            double C = at.getShearX();       // m01</span>
<span class="nc" id="L186">            double B = at.getShearY();       // m10</span>
<span class="nc" id="L187">            double D = at.getScaleY();       // m11</span>

            /*
             * Given a 2 x 2 affine matrix [ A B ] such that
             *                             [ C D ]
             * v' = [x' y'] = [Ax + Cy, Bx + Dy], we want to
             * find the maximum magnitude (norm) of the vector v'
             * with the constraint (x^2 + y^2 = 1).
             * The equation to maximize is
             *     |v'| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)
             * or  |v'| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).
             * Since sqrt is monotonic we can maximize |v'|^2
             * instead and plug in the substitution y = sqrt(1 - x^2).
             * Trigonometric equalities can then be used to get
             * rid of most of the sqrt terms.
             */

<span class="nc" id="L204">            double EA = A*A + B*B;          // x^2 coefficient</span>
<span class="nc" id="L205">            double EB = 2*(A*C + B*D);      // xy coefficient</span>
<span class="nc" id="L206">            double EC = C*C + D*D;          // y^2 coefficient</span>

            /*
             * There is a lot of calculus omitted here.
             *
             * Conceptually, in the interests of understanding the
             * terms that the calculus produced we can consider
             * that EA and EC end up providing the lengths along
             * the major axes and the hypot term ends up being an
             * adjustment for the additional length along the off-axis
             * angle of rotated or sheared ellipses as well as an
             * adjustment for the fact that the equation below
             * averages the two major axis lengths.  (Notice that
             * the hypot term contains a part which resolves to the
             * difference of these two axis lengths in the absence
             * of rotation.)
             *
             * In the calculus, the ratio of the EB and (EA-EC) terms
             * ends up being the tangent of 2*theta where theta is
             * the angle that the long axis of the ellipse makes
             * with the horizontal axis.  Thus, this equation is
             * calculating the length of the hypotenuse of a triangle
             * along that axis.
             */

<span class="nc" id="L231">            double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));</span>
            /* sqrt omitted, compare to squared limits below. */
<span class="nc" id="L233">            double widthsquared = ((EA + EC + hypot)/2.0);</span>

<span class="nc" id="L235">            widthScale = Math.sqrt(widthsquared);</span>
        }

<span class="nc" id="L238">        return (float) (lw / widthScale);</span>
    }

    void strokeTo(Shape src,
                  AffineTransform at,
                  float width,
                  NormMode normalize,
                  int caps,
                  int join,
                  float miterlimit,
                  float dashes[],
                  float dashphase,
                  PathConsumer2D pc2d)
    {
        // We use strokerat and outat so that in Stroker and Dasher we can work only
        // with the pre-transformation coordinates. This will repeat a lot of
        // computations done in the path iterator, but the alternative is to
        // work with transformed paths and compute untransformed coordinates
        // as needed. This would be faster but I do not think the complexity
        // of working with both untransformed and transformed coordinates in
        // the same code is worth it.
        // However, if a path's width is constant after a transformation,
        // we can skip all this untransforming.

        // If normalization is off we save some transformations by not
        // transforming the input to pisces. Instead, we apply the
        // transformation after the path processing has been done.
        // We can't do this if normalization is on, because it isn't a good
        // idea to normalize before the transformation is applied.
<span class="nc" id="L267">        AffineTransform strokerat = null;</span>
<span class="nc" id="L268">        AffineTransform outat = null;</span>

<span class="nc" id="L270">        PathIterator pi = null;</span>

<span class="nc bnc" id="L272" title="All 4 branches missed.">        if (at != null &amp;&amp; !at.isIdentity()) {</span>
<span class="nc" id="L273">            final double a = at.getScaleX();</span>
<span class="nc" id="L274">            final double b = at.getShearX();</span>
<span class="nc" id="L275">            final double c = at.getShearY();</span>
<span class="nc" id="L276">            final double d = at.getScaleY();</span>
<span class="nc" id="L277">            final double det = a * d - c * b;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (Math.abs(det) &lt;= 2 * Float.MIN_VALUE) {</span>
                // this rendering engine takes one dimensional curves and turns
                // them into 2D shapes by giving them width.
                // However, if everything is to be passed through a singular
                // transformation, these 2D shapes will be squashed down to 1D
                // again so, nothing can be drawn.

                // Every path needs an initial moveTo and a pathDone. If these
                // are not there this causes a SIGSEGV in libawt.so (at the time
                // of writing of this comment (September 16, 2010)). Actually,
                // I am not sure if the moveTo is necessary to avoid the SIGSEGV
                // but the pathDone is definitely needed.
<span class="nc" id="L290">                pc2d.moveTo(0, 0);</span>
<span class="nc" id="L291">                pc2d.pathDone();</span>
<span class="nc" id="L292">                return;</span>
            }

            // If the transform is a constant multiple of an orthogonal transformation
            // then every length is just multiplied by a constant, so we just
            // need to transform input paths to stroker and tell stroker
            // the scaled width. This condition is satisfied if
            // a*b == -c*d &amp;&amp; a*a+c*c == b*b+d*d. In the actual check below, we
            // leave a bit of room for error.
<span class="nc bnc" id="L301" title="All 4 branches missed.">            if (nearZero(a*b + c*d, 2) &amp;&amp; nearZero(a*a+c*c - (b*b+d*d), 2)) {</span>
<span class="nc" id="L302">                double scale = Math.sqrt(a*a + c*c);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (dashes != null) {</span>
<span class="nc" id="L304">                    dashes = java.util.Arrays.copyOf(dashes, dashes.length);</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">                    for (int i = 0; i &lt; dashes.length; i++) {</span>
<span class="nc" id="L306">                        dashes[i] = (float)(scale * dashes[i]);</span>
                    }
<span class="nc" id="L308">                    dashphase = (float)(scale * dashphase);</span>
                }
<span class="nc" id="L310">                width = (float)(scale * width);</span>
<span class="nc" id="L311">                pi = src.getPathIterator(at);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (normalize != NormMode.OFF) {</span>
<span class="nc" id="L313">                    pi = new NormalizingPathIterator(pi, normalize);</span>
                }
                // by now strokerat == null &amp;&amp; outat == null. Input paths to
                // stroker (and maybe dasher) will have the full transform at
                // applied to them and nothing will happen to the output paths.
<span class="nc" id="L318">            } else {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                if (normalize != NormMode.OFF) {</span>
<span class="nc" id="L320">                    strokerat = at;</span>
<span class="nc" id="L321">                    pi = src.getPathIterator(at);</span>
<span class="nc" id="L322">                    pi = new NormalizingPathIterator(pi, normalize);</span>
                    // by now strokerat == at &amp;&amp; outat == null. Input paths to
                    // stroker (and maybe dasher) will have the full transform at
                    // applied to them, then they will be normalized, and then
                    // the inverse of *only the non translation part of at* will
                    // be applied to the normalized paths. This won't cause problems
                    // in stroker, because, suppose at = T*A, where T is just the
                    // translation part of at, and A is the rest. T*A has already
                    // been applied to Stroker/Dasher's input. Then Ainv will be
                    // applied. Ainv*T*A is not equal to T, but it is a translation,
                    // which means that none of stroker's assumptions about its
                    // input will be violated. After all this, A will be applied
                    // to stroker's output.
                } else {
<span class="nc" id="L336">                    outat = at;</span>
<span class="nc" id="L337">                    pi = src.getPathIterator(null);</span>
                    // outat == at &amp;&amp; strokerat == null. This is because if no
                    // normalization is done, we can just apply all our
                    // transformations to stroker's output.
                }
            }
<span class="nc" id="L343">        } else {</span>
            // either at is null or it's the identity. In either case
            // we don't transform the path.
<span class="nc" id="L346">            pi = src.getPathIterator(null);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (normalize != NormMode.OFF) {</span>
<span class="nc" id="L348">                pi = new NormalizingPathIterator(pi, normalize);</span>
            }
        }

        // by now, at least one of outat and strokerat will be null. Unless at is not
        // a constant multiple of an orthogonal transformation, they will both be
        // null. In other cases, outat == at if normalization is off, and if
        // normalization is on, strokerat == at.
<span class="nc" id="L356">        pc2d = TransformingPathConsumer2D.transformConsumer(pc2d, outat);</span>
<span class="nc" id="L357">        pc2d = TransformingPathConsumer2D.deltaTransformConsumer(pc2d, strokerat);</span>
<span class="nc" id="L358">        pc2d = new Stroker(pc2d, width, caps, join, miterlimit);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (dashes != null) {</span>
<span class="nc" id="L360">            pc2d = new Dasher(pc2d, dashes, dashphase);</span>
        }
<span class="nc" id="L362">        pc2d = TransformingPathConsumer2D.inverseDeltaTransformConsumer(pc2d, strokerat);</span>
<span class="nc" id="L363">        pathTo(pi, pc2d);</span>
<span class="nc" id="L364">    }</span>

    private static boolean nearZero(double num, int nulps) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        return Math.abs(num) &lt; nulps * Math.ulp(num);</span>
    }

<span class="nc" id="L370">    private static class NormalizingPathIterator implements PathIterator {</span>

        private final PathIterator src;

        // the adjustment applied to the current position.
        private float curx_adjust, cury_adjust;
        // the adjustment applied to the last moveTo position.
        private float movx_adjust, movy_adjust;

        // constants used in normalization computations
        private final float lval, rval;

<span class="nc" id="L382">        NormalizingPathIterator(PathIterator src, NormMode mode) {</span>
<span class="nc" id="L383">            this.src = src;</span>
<span class="nc bnc" id="L384" title="All 4 branches missed.">            switch (mode) {</span>
            case ON_NO_AA:
                // round to nearest (0.25, 0.25) pixel
<span class="nc" id="L387">                lval = rval = 0.25f;</span>
<span class="nc" id="L388">                break;</span>
            case ON_WITH_AA:
                // round to nearest pixel center
<span class="nc" id="L391">                lval = 0f;</span>
<span class="nc" id="L392">                rval = 0.5f;</span>
<span class="nc" id="L393">                break;</span>
            case OFF:
<span class="nc" id="L395">                throw new InternalError(&quot;A NormalizingPathIterator should &quot; +</span>
                         &quot;not be created if no normalization is being done&quot;);
            default:
<span class="nc" id="L398">                throw new InternalError(&quot;Unrecognized normalization mode&quot;);</span>
            }
<span class="nc" id="L400">        }</span>

        public int currentSegment(float[] coords) {
<span class="nc" id="L403">            int type = src.currentSegment(coords);</span>

            int lastCoord;
<span class="nc bnc" id="L406" title="All 5 branches missed.">            switch(type) {</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L408">                lastCoord = 4;</span>
<span class="nc" id="L409">                break;</span>
            case PathIterator.SEG_QUADTO:
<span class="nc" id="L411">                lastCoord = 2;</span>
<span class="nc" id="L412">                break;</span>
            case PathIterator.SEG_LINETO:
            case PathIterator.SEG_MOVETO:
<span class="nc" id="L415">                lastCoord = 0;</span>
<span class="nc" id="L416">                break;</span>
            case PathIterator.SEG_CLOSE:
                // we don't want to deal with this case later. We just exit now
<span class="nc" id="L419">                curx_adjust = movx_adjust;</span>
<span class="nc" id="L420">                cury_adjust = movy_adjust;</span>
<span class="nc" id="L421">                return type;</span>
            default:
<span class="nc" id="L423">                throw new InternalError(&quot;Unrecognized curve type&quot;);</span>
            }

            // normalize endpoint
<span class="nc" id="L427">            float x_adjust = (float)Math.floor(coords[lastCoord] + lval) +</span>
                         rval - coords[lastCoord];
<span class="nc" id="L429">            float y_adjust = (float)Math.floor(coords[lastCoord+1] + lval) +</span>
                         rval - coords[lastCoord + 1];

<span class="nc" id="L432">            coords[lastCoord    ] += x_adjust;</span>
<span class="nc" id="L433">            coords[lastCoord + 1] += y_adjust;</span>

            // now that the end points are done, normalize the control points
<span class="nc bnc" id="L436" title="All 6 branches missed.">            switch(type) {</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L438">                coords[0] += curx_adjust;</span>
<span class="nc" id="L439">                coords[1] += cury_adjust;</span>
<span class="nc" id="L440">                coords[2] += x_adjust;</span>
<span class="nc" id="L441">                coords[3] += y_adjust;</span>
<span class="nc" id="L442">                break;</span>
            case PathIterator.SEG_QUADTO:
<span class="nc" id="L444">                coords[0] += (curx_adjust + x_adjust) / 2;</span>
<span class="nc" id="L445">                coords[1] += (cury_adjust + y_adjust) / 2;</span>
<span class="nc" id="L446">                break;</span>
            case PathIterator.SEG_LINETO:
<span class="nc" id="L448">                break;</span>
            case PathIterator.SEG_MOVETO:
<span class="nc" id="L450">                movx_adjust = x_adjust;</span>
<span class="nc" id="L451">                movy_adjust = y_adjust;</span>
<span class="nc" id="L452">                break;</span>
            case PathIterator.SEG_CLOSE:
<span class="nc" id="L454">                throw new InternalError(&quot;This should be handled earlier.&quot;);</span>
            }
<span class="nc" id="L456">            curx_adjust = x_adjust;</span>
<span class="nc" id="L457">            cury_adjust = y_adjust;</span>
<span class="nc" id="L458">            return type;</span>
        }

        public int currentSegment(double[] coords) {
<span class="nc" id="L462">            float[] tmp = new float[6];</span>
<span class="nc" id="L463">            int type = this.currentSegment(tmp);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc" id="L465">                coords[i] = (float) tmp[i];</span>
            }
<span class="nc" id="L467">            return type;</span>
        }

        public int getWindingRule() {
<span class="nc" id="L471">            return src.getWindingRule();</span>
        }

        public boolean isDone() {
<span class="nc" id="L475">            return src.isDone();</span>
        }

        public void next() {
<span class="nc" id="L479">            src.next();</span>
<span class="nc" id="L480">        }</span>
    }

    static void pathTo(PathIterator pi, PathConsumer2D pc2d) {
<span class="nc" id="L484">        RenderingEngine.feedConsumer(pi, pc2d);</span>
<span class="nc" id="L485">        pc2d.pathDone();</span>
<span class="nc" id="L486">    }</span>

    /**
     * Construct an antialiased tile generator for the given shape with
     * the given rendering attributes and store the bounds of the tile
     * iteration in the bbox parameter.
     * The {@code at} parameter specifies a transform that should affect
     * both the shape and the {@code BasicStroke} attributes.
     * The {@code clip} parameter specifies the current clip in effect
     * in device coordinates and can be used to prune the data for the
     * operation, but the renderer is not required to perform any
     * clipping.
     * If the {@code BasicStroke} parameter is null then the shape
     * should be filled as is, otherwise the attributes of the
     * {@code BasicStroke} should be used to specify a draw operation.
     * The {@code thin} parameter indicates whether or not the
     * transformed {@code BasicStroke} represents coordinates smaller
     * than the minimum resolution of the antialiasing rasterizer as
     * specified by the {@code getMinimumAAPenWidth()} method.
     * &lt;p&gt;
     * Upon returning, this method will fill the {@code bbox} parameter
     * with 4 values indicating the bounds of the iteration of the
     * tile generator.
     * The iteration order of the tiles will be as specified by the
     * pseudo-code:
     * &lt;pre&gt;
     *     for (y = bbox[1]; y &lt; bbox[3]; y += tileheight) {
     *         for (x = bbox[0]; x &lt; bbox[2]; x += tilewidth) {
     *         }
     *     }
     * &lt;/pre&gt;
     * If there is no output to be rendered, this method may return
     * null.
     *
     * @param s the shape to be rendered (fill or draw)
     * @param at the transform to be applied to the shape and the
     *           stroke attributes
     * @param clip the current clip in effect in device coordinates
     * @param bs if non-null, a {@code BasicStroke} whose attributes
     *           should be applied to this operation
     * @param thin true if the transformed stroke attributes are smaller
     *             than the minimum dropout pen width
     * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}
     *                  {@code RenderingHint} is in effect
     * @param bbox returns the bounds of the iteration
     * @return the {@code AATileGenerator} instance to be consulted
     *         for tile coverages, or null if there is no output to render
     * @since 1.7
     */
    public AATileGenerator getAATileGenerator(Shape s,
                                              AffineTransform at,
                                              Region clip,
                                              BasicStroke bs,
                                              boolean thin,
                                              boolean normalize,
                                              int bbox[])
    {
        Renderer r;
<span class="nc bnc" id="L544" title="All 2 branches missed.">        NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (bs == null) {</span>
            PathIterator pi;
<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (normalize) {</span>
<span class="nc" id="L548">                pi = new NormalizingPathIterator(s.getPathIterator(at), norm);</span>
            } else {
<span class="nc" id="L550">                pi = s.getPathIterator(at);</span>
            }
<span class="nc" id="L552">            r = new Renderer(3, 3,</span>
<span class="nc" id="L553">                             clip.getLoX(), clip.getLoY(),</span>
<span class="nc" id="L554">                             clip.getWidth(), clip.getHeight(),</span>
<span class="nc" id="L555">                             pi.getWindingRule());</span>
<span class="nc" id="L556">            pathTo(pi, r);</span>
<span class="nc" id="L557">        } else {</span>
<span class="nc" id="L558">            r = new Renderer(3, 3,</span>
<span class="nc" id="L559">                             clip.getLoX(), clip.getLoY(),</span>
<span class="nc" id="L560">                             clip.getWidth(), clip.getHeight(),</span>
                             PathIterator.WIND_NON_ZERO);
<span class="nc" id="L562">            strokeTo(s, at, bs, thin, norm, true, r);</span>
        }
<span class="nc" id="L564">        r.endRendering();</span>
<span class="nc" id="L565">        PiscesTileGenerator ptg = new PiscesTileGenerator(r, r.MAX_AA_ALPHA);</span>
<span class="nc" id="L566">        ptg.getBbox(bbox);</span>
<span class="nc" id="L567">        return ptg;</span>
    }

    public AATileGenerator getAATileGenerator(double x, double y,
                                              double dx1, double dy1,
                                              double dx2, double dy2,
                                              double lw1, double lw2,
                                              Region clip,
                                              int bbox[])
    {
        // REMIND: Deal with large coordinates!
        double ldx1, ldy1, ldx2, ldy2;
<span class="nc bnc" id="L579" title="All 4 branches missed.">        boolean innerpgram = (lw1 &gt; 0 &amp;&amp; lw2 &gt; 0);</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (innerpgram) {</span>
<span class="nc" id="L582">            ldx1 = dx1 * lw1;</span>
<span class="nc" id="L583">            ldy1 = dy1 * lw1;</span>
<span class="nc" id="L584">            ldx2 = dx2 * lw2;</span>
<span class="nc" id="L585">            ldy2 = dy2 * lw2;</span>
<span class="nc" id="L586">            x -= (ldx1 + ldx2) / 2.0;</span>
<span class="nc" id="L587">            y -= (ldy1 + ldy2) / 2.0;</span>
<span class="nc" id="L588">            dx1 += ldx1;</span>
<span class="nc" id="L589">            dy1 += ldy1;</span>
<span class="nc" id="L590">            dx2 += ldx2;</span>
<span class="nc" id="L591">            dy2 += ldy2;</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">            if (lw1 &gt; 1 &amp;&amp; lw2 &gt; 1) {</span>
                // Inner parallelogram was entirely consumed by stroke...
<span class="nc" id="L594">                innerpgram = false;</span>
            }
        } else {
<span class="nc" id="L597">            ldx1 = ldy1 = ldx2 = ldy2 = 0;</span>
        }

<span class="nc" id="L600">        Renderer r = new Renderer(3, 3,</span>
<span class="nc" id="L601">                clip.getLoX(), clip.getLoY(),</span>
<span class="nc" id="L602">                clip.getWidth(), clip.getHeight(),</span>
                PathIterator.WIND_EVEN_ODD);

<span class="nc" id="L605">        r.moveTo((float) x, (float) y);</span>
<span class="nc" id="L606">        r.lineTo((float) (x+dx1), (float) (y+dy1));</span>
<span class="nc" id="L607">        r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));</span>
<span class="nc" id="L608">        r.lineTo((float) (x+dx2), (float) (y+dy2));</span>
<span class="nc" id="L609">        r.closePath();</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (innerpgram) {</span>
<span class="nc" id="L612">            x += ldx1 + ldx2;</span>
<span class="nc" id="L613">            y += ldy1 + ldy2;</span>
<span class="nc" id="L614">            dx1 -= 2.0 * ldx1;</span>
<span class="nc" id="L615">            dy1 -= 2.0 * ldy1;</span>
<span class="nc" id="L616">            dx2 -= 2.0 * ldx2;</span>
<span class="nc" id="L617">            dy2 -= 2.0 * ldy2;</span>
<span class="nc" id="L618">            r.moveTo((float) x, (float) y);</span>
<span class="nc" id="L619">            r.lineTo((float) (x+dx1), (float) (y+dy1));</span>
<span class="nc" id="L620">            r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));</span>
<span class="nc" id="L621">            r.lineTo((float) (x+dx2), (float) (y+dy2));</span>
<span class="nc" id="L622">            r.closePath();</span>
        }

<span class="nc" id="L625">        r.pathDone();</span>

<span class="nc" id="L627">        r.endRendering();</span>
<span class="nc" id="L628">        PiscesTileGenerator ptg = new PiscesTileGenerator(r, r.MAX_AA_ALPHA);</span>
<span class="nc" id="L629">        ptg.getBbox(bbox);</span>
<span class="nc" id="L630">        return ptg;</span>
    }

    /**
     * Returns the minimum pen width that the antialiasing rasterizer
     * can represent without dropouts occurring.
     * @since 1.7
     */
    public float getMinimumAAPenSize() {
<span class="nc" id="L639">        return 0.5f;</span>
    }

    static {
        if (PathIterator.WIND_NON_ZERO != Renderer.WIND_NON_ZERO ||
            PathIterator.WIND_EVEN_ODD != Renderer.WIND_EVEN_ODD ||
            BasicStroke.JOIN_MITER != Stroker.JOIN_MITER ||
            BasicStroke.JOIN_ROUND != Stroker.JOIN_ROUND ||
            BasicStroke.JOIN_BEVEL != Stroker.JOIN_BEVEL ||
            BasicStroke.CAP_BUTT != Stroker.CAP_BUTT ||
            BasicStroke.CAP_ROUND != Stroker.CAP_ROUND ||
            BasicStroke.CAP_SQUARE != Stroker.CAP_SQUARE)
        {
            throw new InternalError(&quot;mismatched renderer constants&quot;);
        }
<span class="nc" id="L654">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>