<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Renderer.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pisces</a> &gt; <span class="el_source">Renderer.java</span></div><h1>Renderer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pisces;

import sun.awt.geom.PathConsumer2D;

final class Renderer implements PathConsumer2D {

    private class ScanlineIterator {

        private int[] crossings;

        // crossing bounds. The bounds are not necessarily tight (the scan line
        // at minY, for example, might have no crossings). The x bounds will
        // be accumulated as crossings are computed.
        private final int maxY;
        private int nextY;

        // indices into the segment pointer lists. They indicate the &quot;active&quot;
        // sublist in the segment lists (the portion of the list that contains
        // all the segments that cross the next scan line).
        private int edgeCount;
        private int[] edgePtrs;

        private static final int INIT_CROSSINGS_SIZE = 10;

        // Preconditions: Only subpixel scanlines in the range
        // (start &lt;= subpixel_y &lt;= end) will be evaluated. No
        // edge may have a valid (i.e. inside the supplied clip)
        // crossing that would be generated outside that range.
<span class="nc" id="L54">        private ScanlineIterator(int start, int end) {</span>
<span class="nc" id="L55">            crossings = new int[INIT_CROSSINGS_SIZE];</span>
<span class="nc" id="L56">            edgePtrs = new int[INIT_CROSSINGS_SIZE];</span>

<span class="nc" id="L58">            nextY = start;</span>
<span class="nc" id="L59">            maxY = end;</span>
<span class="nc" id="L60">            edgeCount = 0;</span>
<span class="nc" id="L61">        }</span>

        private int next() {
<span class="nc" id="L64">            int cury = nextY++;</span>
<span class="nc" id="L65">            int bucket = cury - boundsMinY;</span>
<span class="nc" id="L66">            int count = this.edgeCount;</span>
<span class="nc" id="L67">            int ptrs[] = this.edgePtrs;</span>
<span class="nc" id="L68">            int bucketcount = edgeBucketCounts[bucket];</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            if ((bucketcount &amp; 0x1) != 0) {</span>
<span class="nc" id="L70">                int newCount = 0;</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L72">                    int ecur = ptrs[i];</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">                    if (edges[ecur+YMAX] &gt; cury) {</span>
<span class="nc" id="L74">                        ptrs[newCount++] = ecur;</span>
                    }
                }
<span class="nc" id="L77">                count = newCount;</span>
            }
<span class="nc" id="L79">            ptrs = Helpers.widenArray(ptrs, count, bucketcount &gt;&gt; 1);</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">            for (int ecur = edgeBuckets[bucket]; ecur != NULL; ecur = (int)edges[ecur+NEXT]) {</span>
<span class="nc" id="L81">                ptrs[count++] = ecur;</span>
                // REMIND: Adjust start Y if necessary
            }
<span class="nc" id="L84">            this.edgePtrs = ptrs;</span>
<span class="nc" id="L85">            this.edgeCount = count;</span>
//            if ((count &amp; 0x1) != 0) {
//                System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
//            }
<span class="nc" id="L89">            int xings[] = this.crossings;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (xings.length &lt; count) {</span>
<span class="nc" id="L91">                this.crossings = xings = new int[ptrs.length];</span>
            }
<span class="nc bnc" id="L93" title="All 2 branches missed.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L94">                int ecur = ptrs[i];</span>
<span class="nc" id="L95">                float curx = edges[ecur+CURX];</span>
<span class="nc" id="L96">                int cross = ((int) curx) &lt;&lt; 1;</span>
<span class="nc" id="L97">                edges[ecur+CURX] = curx + edges[ecur+SLOPE];</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (edges[ecur+OR] &gt; 0) {</span>
<span class="nc" id="L99">                    cross |= 1;</span>
                }
<span class="nc" id="L101">                int j = i;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                while (--j &gt;= 0) {</span>
<span class="nc" id="L103">                    int jcross = xings[j];</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">                    if (jcross &lt;= cross) {</span>
<span class="nc" id="L105">                        break;</span>
                    }
<span class="nc" id="L107">                    xings[j+1] = jcross;</span>
<span class="nc" id="L108">                    ptrs[j+1] = ptrs[j];</span>
<span class="nc" id="L109">                }</span>
<span class="nc" id="L110">                xings[j+1] = cross;</span>
<span class="nc" id="L111">                ptrs[j+1] = ecur;</span>
            }
<span class="nc" id="L113">            return count;</span>
        }

        private boolean hasNext() {
<span class="nc bnc" id="L117" title="All 2 branches missed.">            return nextY &lt; maxY;</span>
        }

        private int curY() {
<span class="nc" id="L121">            return nextY - 1;</span>
        }
    }


//////////////////////////////////////////////////////////////////////////////
//  EDGE LIST
//////////////////////////////////////////////////////////////////////////////
// TODO(maybe): very tempting to use fixed point here. A lot of opportunities
// for shifts and just removing certain operations altogether.

    // common to all types of input path segments.
    private static final int YMAX = 0;
    private static final int CURX = 1;
    // NEXT and OR are meant to be indices into &quot;int&quot; fields, but arrays must
    // be homogenous, so every field is a float. However floats can represent
    // exactly up to 26 bit ints, so we're ok.
    private static final int OR   = 2;
    private static final int SLOPE = 3;
    private static final int NEXT = 4;

<span class="nc" id="L142">    private float edgeMinY = Float.POSITIVE_INFINITY;</span>
<span class="nc" id="L143">    private float edgeMaxY = Float.NEGATIVE_INFINITY;</span>
<span class="nc" id="L144">    private float edgeMinX = Float.POSITIVE_INFINITY;</span>
<span class="nc" id="L145">    private float edgeMaxX = Float.NEGATIVE_INFINITY;</span>

    private static final int SIZEOF_EDGE = 5;
    // don't just set NULL to -1, because we want NULL+NEXT to be negative.
    private static final int NULL = -SIZEOF_EDGE;
<span class="nc" id="L150">    private float[] edges = null;</span>
    private static final int INIT_NUM_EDGES = 8;
<span class="nc" id="L152">    private int[] edgeBuckets = null;</span>
<span class="nc" id="L153">    private int[] edgeBucketCounts = null; // 2*newedges + (1 if pruning needed)</span>
    private int numEdges;

    private static final float DEC_BND = 20f;
    private static final float INC_BND = 8f;

    // each bucket is a linked list. this method adds eptr to the
    // start of the &quot;bucket&quot;th linked list.
    private void addEdgeToBucket(final int eptr, final int bucket) {
<span class="nc" id="L162">        edges[eptr+NEXT] = edgeBuckets[bucket];</span>
<span class="nc" id="L163">        edgeBuckets[bucket] = eptr;</span>
<span class="nc" id="L164">        edgeBucketCounts[bucket] += 2;</span>
<span class="nc" id="L165">    }</span>

    // Flattens using adaptive forward differencing. This only carries out
    // one iteration of the AFD loop. All it does is update AFD variables (i.e.
    // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
    private void quadBreakIntoLinesAndAdd(float x0, float y0,
                                          final Curve c,
                                          final float x2, final float y2)
    {
        final float QUAD_DEC_BND = 32;
        final int countlg = 4;
<span class="nc" id="L176">        int count = 1 &lt;&lt; countlg;</span>
<span class="nc" id="L177">        int countsq = count * count;</span>
<span class="nc" id="L178">        float maxDD = Math.max(c.dbx / countsq, c.dby / countsq);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        while (maxDD &gt; QUAD_DEC_BND) {</span>
<span class="nc" id="L180">            maxDD /= 4;</span>
<span class="nc" id="L181">            count &lt;&lt;= 1;</span>
        }

<span class="nc" id="L184">        countsq = count * count;</span>
<span class="nc" id="L185">        final float ddx = c.dbx / countsq;</span>
<span class="nc" id="L186">        final float ddy = c.dby / countsq;</span>
<span class="nc" id="L187">        float dx = c.bx / countsq + c.cx / count;</span>
<span class="nc" id="L188">        float dy = c.by / countsq + c.cy / count;</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        while (count-- &gt; 1) {</span>
<span class="nc" id="L191">            float x1 = x0 + dx;</span>
<span class="nc" id="L192">            dx += ddx;</span>
<span class="nc" id="L193">            float y1 = y0 + dy;</span>
<span class="nc" id="L194">            dy += ddy;</span>
<span class="nc" id="L195">            addLine(x0, y0, x1, y1);</span>
<span class="nc" id="L196">            x0 = x1;</span>
<span class="nc" id="L197">            y0 = y1;</span>
<span class="nc" id="L198">        }</span>
<span class="nc" id="L199">        addLine(x0, y0, x2, y2);</span>
<span class="nc" id="L200">    }</span>

    // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
    // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
    // numerical errors, and our callers already have the exact values.
    // Another alternative would be to pass all the control points, and call c.set
    // here, but then too many numbers are passed around.
    private void curveBreakIntoLinesAndAdd(float x0, float y0,
                                           final Curve c,
                                           final float x3, final float y3)
    {
        final int countlg = 3;
<span class="nc" id="L212">        int count = 1 &lt;&lt; countlg;</span>

        // the dx and dy refer to forward differencing variables, not the last
        // coefficients of the &quot;points&quot; polynomial
        float dddx, dddy, ddx, ddy, dx, dy;
<span class="nc" id="L217">        dddx = 2f * c.dax / (1 &lt;&lt; (3 * countlg));</span>
<span class="nc" id="L218">        dddy = 2f * c.day / (1 &lt;&lt; (3 * countlg));</span>

<span class="nc" id="L220">        ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));</span>
<span class="nc" id="L221">        ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));</span>
<span class="nc" id="L222">        dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);</span>
<span class="nc" id="L223">        dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);</span>

        // we use x0, y0 to walk the line
<span class="nc" id="L226">        float x1 = x0, y1 = y0;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        while (count &gt; 0) {</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">            while (Math.abs(ddx) &gt; DEC_BND || Math.abs(ddy) &gt; DEC_BND) {</span>
<span class="nc" id="L229">                dddx /= 8;</span>
<span class="nc" id="L230">                dddy /= 8;</span>
<span class="nc" id="L231">                ddx = ddx/4 - dddx;</span>
<span class="nc" id="L232">                ddy = ddy/4 - dddy;</span>
<span class="nc" id="L233">                dx = (dx - ddx) / 2;</span>
<span class="nc" id="L234">                dy = (dy - ddy) / 2;</span>
<span class="nc" id="L235">                count &lt;&lt;= 1;</span>
            }
            // can only do this on even &quot;count&quot; values, because we must divide count by 2
<span class="nc bnc" id="L238" title="All 6 branches missed.">            while (count % 2 == 0 &amp;&amp; Math.abs(dx) &lt;= INC_BND &amp;&amp; Math.abs(dy) &lt;= INC_BND) {</span>
<span class="nc" id="L239">                dx = 2 * dx + ddx;</span>
<span class="nc" id="L240">                dy = 2 * dy + ddy;</span>
<span class="nc" id="L241">                ddx = 4 * (ddx + dddx);</span>
<span class="nc" id="L242">                ddy = 4 * (ddy + dddy);</span>
<span class="nc" id="L243">                dddx = 8 * dddx;</span>
<span class="nc" id="L244">                dddy = 8 * dddy;</span>
<span class="nc" id="L245">                count &gt;&gt;= 1;</span>
            }
<span class="nc" id="L247">            count--;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (count &gt; 0) {</span>
<span class="nc" id="L249">                x1 += dx;</span>
<span class="nc" id="L250">                dx += ddx;</span>
<span class="nc" id="L251">                ddx += dddx;</span>
<span class="nc" id="L252">                y1 += dy;</span>
<span class="nc" id="L253">                dy += ddy;</span>
<span class="nc" id="L254">                ddy += dddy;</span>
            } else {
<span class="nc" id="L256">                x1 = x3;</span>
<span class="nc" id="L257">                y1 = y3;</span>
            }
<span class="nc" id="L259">            addLine(x0, y0, x1, y1);</span>
<span class="nc" id="L260">            x0 = x1;</span>
<span class="nc" id="L261">            y0 = y1;</span>
        }
<span class="nc" id="L263">    }</span>

    private void addLine(float x1, float y1, float x2, float y2) {
<span class="nc" id="L266">        float or = 1; // orientation of the line. 1 if y increases, 0 otherwise.</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (y2 &lt; y1) {</span>
<span class="nc" id="L268">            or = y2; // no need to declare a temp variable. We have or.</span>
<span class="nc" id="L269">            y2 = y1;</span>
<span class="nc" id="L270">            y1 = or;</span>
<span class="nc" id="L271">            or = x2;</span>
<span class="nc" id="L272">            x2 = x1;</span>
<span class="nc" id="L273">            x1 = or;</span>
<span class="nc" id="L274">            or = 0;</span>
        }
<span class="nc" id="L276">        final int firstCrossing = Math.max((int)Math.ceil(y1), boundsMinY);</span>
<span class="nc" id="L277">        final int lastCrossing = Math.min((int)Math.ceil(y2), boundsMaxY);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (firstCrossing &gt;= lastCrossing) {</span>
<span class="nc" id="L279">            return;</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (y1 &lt; edgeMinY) { edgeMinY = y1; }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        if (y2 &gt; edgeMaxY) { edgeMaxY = y2; }</span>

<span class="nc" id="L284">        final float slope = (x2 - x1) / (y2 - y1);</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (x1 &lt; edgeMinX) { edgeMinX = x1; }</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (x2 &gt; edgeMaxX) { edgeMaxX = x2; }</span>
        } else {
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (x2 &lt; edgeMinX) { edgeMinX = x2; }</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (x1 &gt; edgeMaxX) { edgeMaxX = x1; }</span>
        }

<span class="nc" id="L294">        final int ptr = numEdges * SIZEOF_EDGE;</span>
<span class="nc" id="L295">        edges = Helpers.widenArray(edges, ptr, SIZEOF_EDGE);</span>
<span class="nc" id="L296">        numEdges++;</span>
<span class="nc" id="L297">        edges[ptr+OR] = or;</span>
<span class="nc" id="L298">        edges[ptr+CURX] = x1 + (firstCrossing - y1) * slope;</span>
<span class="nc" id="L299">        edges[ptr+SLOPE] = slope;</span>
<span class="nc" id="L300">        edges[ptr+YMAX] = lastCrossing;</span>
<span class="nc" id="L301">        final int bucketIdx = firstCrossing - boundsMinY;</span>
<span class="nc" id="L302">        addEdgeToBucket(ptr, bucketIdx);</span>
<span class="nc" id="L303">        edgeBucketCounts[lastCrossing - boundsMinY] |= 1;</span>
<span class="nc" id="L304">    }</span>

// END EDGE LIST
//////////////////////////////////////////////////////////////////////////////


    public static final int WIND_EVEN_ODD = 0;
    public static final int WIND_NON_ZERO = 1;

    // Antialiasing
    final private int SUBPIXEL_LG_POSITIONS_X;
    final private int SUBPIXEL_LG_POSITIONS_Y;
    final private int SUBPIXEL_POSITIONS_X;
    final private int SUBPIXEL_POSITIONS_Y;
    final private int SUBPIXEL_MASK_X;
    final private int SUBPIXEL_MASK_Y;
    final int MAX_AA_ALPHA;

    // Cache to store RLE-encoded coverage mask of the current primitive
    PiscesCache cache;

    // Bounds of the drawing region, at subpixel precision.
    private final int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;

    // Current winding rule
    private final int windingRule;

    // Current drawing position, i.e., final point of last segment
    private float x0, y0;

    // Position of most recent 'moveTo' command
    private float pix_sx0, pix_sy0;

    public Renderer(int subpixelLgPositionsX, int subpixelLgPositionsY,
                    int pix_boundsX, int pix_boundsY,
                    int pix_boundsWidth, int pix_boundsHeight,
                    int windingRule)
<span class="nc" id="L341">    {</span>
<span class="nc" id="L342">        this.SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;</span>
<span class="nc" id="L343">        this.SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;</span>
<span class="nc" id="L344">        this.SUBPIXEL_MASK_X = (1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X)) - 1;</span>
<span class="nc" id="L345">        this.SUBPIXEL_MASK_Y = (1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y)) - 1;</span>
<span class="nc" id="L346">        this.SUBPIXEL_POSITIONS_X = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X);</span>
<span class="nc" id="L347">        this.SUBPIXEL_POSITIONS_Y = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y);</span>
<span class="nc" id="L348">        this.MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);</span>

<span class="nc" id="L350">        this.windingRule = windingRule;</span>

<span class="nc" id="L352">        this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;</span>
<span class="nc" id="L353">        this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;</span>
<span class="nc" id="L354">        this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;</span>
<span class="nc" id="L355">        this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;</span>

<span class="nc" id="L357">        edges = new float[INIT_NUM_EDGES * SIZEOF_EDGE];</span>
<span class="nc" id="L358">        numEdges = 0;</span>
<span class="nc" id="L359">        edgeBuckets = new int[boundsMaxY - boundsMinY];</span>
<span class="nc" id="L360">        java.util.Arrays.fill(edgeBuckets, NULL);</span>
<span class="nc" id="L361">        edgeBucketCounts = new int[edgeBuckets.length + 1];</span>
<span class="nc" id="L362">    }</span>

    private float tosubpixx(float pix_x) {
<span class="nc" id="L365">        return pix_x * SUBPIXEL_POSITIONS_X;</span>
    }
    private float tosubpixy(float pix_y) {
<span class="nc" id="L368">        return pix_y * SUBPIXEL_POSITIONS_Y;</span>
    }

    public void moveTo(float pix_x0, float pix_y0) {
<span class="nc" id="L372">        closePath();</span>
<span class="nc" id="L373">        this.pix_sx0 = pix_x0;</span>
<span class="nc" id="L374">        this.pix_sy0 = pix_y0;</span>
<span class="nc" id="L375">        this.y0 = tosubpixy(pix_y0);</span>
<span class="nc" id="L376">        this.x0 = tosubpixx(pix_x0);</span>
<span class="nc" id="L377">    }</span>

    public void lineTo(float pix_x1, float pix_y1) {
<span class="nc" id="L380">        float x1 = tosubpixx(pix_x1);</span>
<span class="nc" id="L381">        float y1 = tosubpixy(pix_y1);</span>
<span class="nc" id="L382">        addLine(x0, y0, x1, y1);</span>
<span class="nc" id="L383">        x0 = x1;</span>
<span class="nc" id="L384">        y0 = y1;</span>
<span class="nc" id="L385">    }</span>

<span class="nc" id="L387">    private Curve c = new Curve();</span>
    @Override public void curveTo(float x1, float y1,
                                  float x2, float y2,
                                  float x3, float y3)
    {
<span class="nc" id="L392">        final float xe = tosubpixx(x3);</span>
<span class="nc" id="L393">        final float ye = tosubpixy(y3);</span>
<span class="nc" id="L394">        c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), tosubpixx(x2), tosubpixy(y2), xe, ye);</span>
<span class="nc" id="L395">        curveBreakIntoLinesAndAdd(x0, y0, c, xe, ye);</span>
<span class="nc" id="L396">        x0 = xe;</span>
<span class="nc" id="L397">        y0 = ye;</span>
<span class="nc" id="L398">    }</span>

    @Override public void quadTo(float x1, float y1, float x2, float y2) {
<span class="nc" id="L401">        final float xe = tosubpixx(x2);</span>
<span class="nc" id="L402">        final float ye = tosubpixy(y2);</span>
<span class="nc" id="L403">        c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);</span>
<span class="nc" id="L404">        quadBreakIntoLinesAndAdd(x0, y0, c, xe, ye);</span>
<span class="nc" id="L405">        x0 = xe;</span>
<span class="nc" id="L406">        y0 = ye;</span>
<span class="nc" id="L407">    }</span>

    public void closePath() {
        // lineTo expects its input in pixel coordinates.
<span class="nc" id="L411">        lineTo(pix_sx0, pix_sy0);</span>
<span class="nc" id="L412">    }</span>

    public void pathDone() {
<span class="nc" id="L415">        closePath();</span>
<span class="nc" id="L416">    }</span>


    @Override
    public long getNativeConsumer() {
<span class="nc" id="L421">        throw new InternalError(&quot;Renderer does not use a native consumer.&quot;);</span>
    }

    private void _endRendering(final int pix_bboxx0, final int pix_bboxx1,
                               int ymin, int ymax)
    {
        // Mask to determine the relevant bit of the crossing sum
        // 0x1 if EVEN_ODD, all bits if NON_ZERO
<span class="nc bnc" id="L429" title="All 2 branches missed.">        int mask = (windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;</span>

        // add 2 to better deal with the last pixel in a pixel row.
<span class="nc" id="L432">        int width = pix_bboxx1 - pix_bboxx0;</span>
<span class="nc" id="L433">        int[] alpha = new int[width+2];</span>

<span class="nc" id="L435">        int bboxx0 = pix_bboxx0 &lt;&lt; SUBPIXEL_LG_POSITIONS_X;</span>
<span class="nc" id="L436">        int bboxx1 = pix_bboxx1 &lt;&lt; SUBPIXEL_LG_POSITIONS_X;</span>

        // Now we iterate through the scanlines. We must tell emitRow the coord
        // of the first non-transparent pixel, so we must keep accumulators for
        // the first and last pixels of the section of the current pixel row
        // that we will emit.
        // We also need to accumulate pix_bbox*, but the iterator does it
        // for us. We will just get the values from it once this loop is done
<span class="nc" id="L444">        int pix_maxX = Integer.MIN_VALUE;</span>
<span class="nc" id="L445">        int pix_minX = Integer.MAX_VALUE;</span>

<span class="nc" id="L447">        int y = boundsMinY; // needs to be declared here so we emit the last row properly.</span>
<span class="nc" id="L448">        ScanlineIterator it = this.new ScanlineIterator(ymin, ymax);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for ( ; it.hasNext(); ) {</span>
<span class="nc" id="L450">            int numCrossings = it.next();</span>
<span class="nc" id="L451">            int[] crossings = it.crossings;</span>
<span class="nc" id="L452">            y = it.curY();</span>

<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (numCrossings &gt; 0) {</span>
<span class="nc" id="L455">                int lowx = crossings[0] &gt;&gt; 1;</span>
<span class="nc" id="L456">                int highx = crossings[numCrossings - 1] &gt;&gt; 1;</span>
<span class="nc" id="L457">                int x0 = Math.max(lowx, bboxx0);</span>
<span class="nc" id="L458">                int x1 = Math.min(highx, bboxx1);</span>

<span class="nc" id="L460">                pix_minX = Math.min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);</span>
<span class="nc" id="L461">                pix_maxX = Math.max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);</span>
            }

<span class="nc" id="L464">            int sum = 0;</span>
<span class="nc" id="L465">            int prev = bboxx0;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            for (int i = 0; i &lt; numCrossings; i++) {</span>
<span class="nc" id="L467">                int curxo = crossings[i];</span>
<span class="nc" id="L468">                int curx = curxo &gt;&gt; 1;</span>
                // to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.
<span class="nc" id="L470">                int crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if ((sum &amp; mask) != 0) {</span>
<span class="nc" id="L472">                    int x0 = Math.max(prev, bboxx0);</span>
<span class="nc" id="L473">                    int x1 = Math.min(curx, bboxx1);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">                    if (x0 &lt; x1) {</span>
<span class="nc" id="L475">                        x0 -= bboxx0; // turn x0, x1 from coords to indeces</span>
<span class="nc" id="L476">                        x1 -= bboxx0; // in the alpha array.</span>

<span class="nc" id="L478">                        int pix_x = x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;</span>
<span class="nc" id="L479">                        int pix_xmaxm1 = (x1 - 1) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">                        if (pix_x == pix_xmaxm1) {</span>
                            // Start and end in same pixel
<span class="nc" id="L483">                            alpha[pix_x] += (x1 - x0);</span>
<span class="nc" id="L484">                            alpha[pix_x+1] -= (x1 - x0);</span>
                        } else {
<span class="nc" id="L486">                            int pix_xmax = x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;</span>
<span class="nc" id="L487">                            alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 &amp; SUBPIXEL_MASK_X);</span>
<span class="nc" id="L488">                            alpha[pix_x+1] += (x0 &amp; SUBPIXEL_MASK_X);</span>
<span class="nc" id="L489">                            alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 &amp; SUBPIXEL_MASK_X);</span>
<span class="nc" id="L490">                            alpha[pix_xmax+1] -= (x1 &amp; SUBPIXEL_MASK_X);</span>
                        }
                    }
                }
<span class="nc" id="L494">                sum += crorientation;</span>
<span class="nc" id="L495">                prev = curx;</span>
            }

            // even if this last row had no crossings, alpha will be zeroed
            // from the last emitRow call. But this doesn't matter because
            // maxX &lt; minX, so no row will be emitted to the cache.
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {</span>
<span class="nc" id="L502">                emitRow(alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y, pix_minX, pix_maxX);</span>
<span class="nc" id="L503">                pix_minX = Integer.MAX_VALUE;</span>
<span class="nc" id="L504">                pix_maxX = Integer.MIN_VALUE;</span>
            }
<span class="nc" id="L506">        }</span>

        // Emit final row
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (pix_maxX &gt;= pix_minX) {</span>
<span class="nc" id="L510">            emitRow(alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y, pix_minX, pix_maxX);</span>
        }
<span class="nc" id="L512">    }</span>

    public void endRendering() {
<span class="nc" id="L515">        int spminX = Math.max((int)Math.ceil(edgeMinX), boundsMinX);</span>
<span class="nc" id="L516">        int spmaxX = Math.min((int)Math.ceil(edgeMaxX), boundsMaxX);</span>
<span class="nc" id="L517">        int spminY = Math.max((int)Math.ceil(edgeMinY), boundsMinY);</span>
<span class="nc" id="L518">        int spmaxY = Math.min((int)Math.ceil(edgeMaxY), boundsMaxY);</span>

<span class="nc" id="L520">        int pminX = spminX &gt;&gt; SUBPIXEL_LG_POSITIONS_X;</span>
<span class="nc" id="L521">        int pmaxX = (spmaxX + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;</span>
<span class="nc" id="L522">        int pminY = spminY &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;</span>
<span class="nc" id="L523">        int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;</span>

<span class="nc bnc" id="L525" title="All 4 branches missed.">        if (pminX &gt; pmaxX || pminY &gt; pmaxY) {</span>
<span class="nc" id="L526">            this.cache = new PiscesCache(boundsMinX &gt;&gt; SUBPIXEL_LG_POSITIONS_X,</span>
                                         boundsMinY &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
                                         boundsMaxX &gt;&gt; SUBPIXEL_LG_POSITIONS_X,
                                         boundsMaxY &gt;&gt; SUBPIXEL_LG_POSITIONS_Y);
<span class="nc" id="L530">            return;</span>
        }

<span class="nc" id="L533">        this.cache = new PiscesCache(pminX, pminY, pmaxX, pmaxY);</span>
<span class="nc" id="L534">        _endRendering(pminX, pmaxX, spminY, spmaxY);</span>
<span class="nc" id="L535">    }</span>

    public PiscesCache getCache() {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L539">            throw new InternalError(&quot;cache not yet initialized&quot;);</span>
        }
<span class="nc" id="L541">        return cache;</span>
    }

    private void emitRow(int[] alphaRow, int pix_y, int pix_from, int pix_to) {
        // Copy rowAA data into the cache if one is present
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (cache != null) {</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (pix_to &gt;= pix_from) {</span>
<span class="nc" id="L548">                cache.startRow(pix_y, pix_from);</span>

                // Perform run-length encoding and store results in the cache
<span class="nc" id="L551">                int from = pix_from - cache.bboxX0;</span>
<span class="nc" id="L552">                int to = pix_to - cache.bboxX0;</span>

<span class="nc" id="L554">                int runLen = 1;</span>
<span class="nc" id="L555">                int startVal = alphaRow[from];</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                for (int i = from + 1; i &lt;= to; i++) {</span>
<span class="nc" id="L557">                    int nextVal = startVal + alphaRow[i];</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                    if (nextVal == startVal) {</span>
<span class="nc" id="L559">                        runLen++;</span>
                    } else {
<span class="nc" id="L561">                        cache.addRLERun(startVal, runLen);</span>
<span class="nc" id="L562">                        runLen = 1;</span>
<span class="nc" id="L563">                        startVal = nextVal;</span>
                    }
                }
<span class="nc" id="L566">                cache.addRLERun(startVal, runLen);</span>
            }
        }
<span class="nc" id="L569">        java.util.Arrays.fill(alphaRow, 0);</span>
<span class="nc" id="L570">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>