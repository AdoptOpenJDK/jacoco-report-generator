<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PiscesCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pisces</a> &gt; <span class="el_source">PiscesCache.java</span></div><h1>PiscesCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pisces;

import java.util.Arrays;

/**
 * An object used to cache pre-rendered complex paths.
 *
 * @see PiscesRenderer#render
 */
<span class="nc bnc" id="L35" title="All 2 branches missed.">final class PiscesCache {</span>

    final int bboxX0, bboxY0, bboxX1, bboxY1;

    // rowAARLE[i] holds the encoding of the pixel row with y = bboxY0+i.
    // The format of each of the inner arrays is: rowAARLE[i][0,1] = (x0, n)
    // where x0 is the first x in row i with nonzero alpha, and n is the
    // number of RLE entries in this row. rowAARLE[i][j,j+1] for j&gt;1 is
    // (val,runlen)
    final int[][] rowAARLE;

    // RLE encodings are added in increasing y rows and then in increasing
    // x inside those rows. Therefore, at any one time there is a well
    // defined position (x,y) where a run length is about to be added (or
    // the row terminated). x0,y0 is this (x,y)-(bboxX0,bboxY0). They
    // are used to get indices into the current tile.
<span class="nc" id="L51">    private int x0 = Integer.MIN_VALUE, y0 = Integer.MIN_VALUE;</span>

    // touchedTile[i][j] is the sum of all the alphas in the tile with
    // y=i*TILE_SIZE+bboxY0 and x=j*TILE_SIZE+bboxX0.
    private final int[][] touchedTile;

    static final int TILE_SIZE_LG = 5;
    static final int TILE_SIZE = 1 &lt;&lt; TILE_SIZE_LG; // 32
    private static final int INIT_ROW_SIZE = 8; // enough for 3 run lengths

<span class="nc" id="L61">    PiscesCache(int minx, int miny, int maxx, int maxy) {</span>
<span class="nc bnc" id="L62" title="All 6 branches missed.">        assert maxy &gt;= miny &amp;&amp; maxx &gt;= minx;</span>
<span class="nc" id="L63">        bboxX0 = minx;</span>
<span class="nc" id="L64">        bboxY0 = miny;</span>
<span class="nc" id="L65">        bboxX1 = maxx + 1;</span>
<span class="nc" id="L66">        bboxY1 = maxy + 1;</span>
        // we could just leave the inner arrays as null and allocate them
        // lazily (which would be beneficial for shapes with gaps), but we
        // assume there won't be too many of those so we allocate everything
        // up front (which is better for other cases)
<span class="nc" id="L71">        rowAARLE = new int[bboxY1 - bboxY0 + 1][INIT_ROW_SIZE];</span>
<span class="nc" id="L72">        x0 = 0;</span>
<span class="nc" id="L73">        y0 = -1; // -1 makes the first assert in startRow succeed</span>
        // the ceiling of (maxy - miny + 1) / TILE_SIZE;
<span class="nc" id="L75">        int nyTiles = (maxy - miny + TILE_SIZE) &gt;&gt; TILE_SIZE_LG;</span>
<span class="nc" id="L76">        int nxTiles = (maxx - minx + TILE_SIZE) &gt;&gt; TILE_SIZE_LG;</span>

<span class="nc" id="L78">        touchedTile = new int[nyTiles][nxTiles];</span>
<span class="nc" id="L79">    }</span>

    void addRLERun(int val, int runLen) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (runLen &gt; 0) {</span>
<span class="nc" id="L83">            addTupleToRow(y0, val, runLen);</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">            if (val != 0) {</span>
                // the x and y of the current row, minus bboxX0, bboxY0
<span class="nc" id="L86">                int tx = x0 &gt;&gt; TILE_SIZE_LG;</span>
<span class="nc" id="L87">                int ty = y0 &gt;&gt; TILE_SIZE_LG;</span>
<span class="nc" id="L88">                int tx1 = (x0 + runLen - 1) &gt;&gt; TILE_SIZE_LG;</span>
                // while we forbid rows from starting before bboxx0, our users
                // can still store rows that go beyond bboxx1 (although this
                // shouldn't happen), so it's a good idea to check that i
                // is not going out of bounds in touchedTile[ty]
<span class="nc bnc" id="L93" title="All 2 branches missed.">                if (tx1 &gt;= touchedTile[ty].length) {</span>
<span class="nc" id="L94">                    tx1 = touchedTile[ty].length - 1;</span>
                }
<span class="nc bnc" id="L96" title="All 2 branches missed.">                if (tx &lt;= tx1) {</span>
<span class="nc" id="L97">                    int nextTileXCoord = (tx + 1) &lt;&lt; TILE_SIZE_LG;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                    if (nextTileXCoord &gt; x0+runLen) {</span>
<span class="nc" id="L99">                        touchedTile[ty][tx] += val * runLen;</span>
                    } else {
<span class="nc" id="L101">                        touchedTile[ty][tx] += val * (nextTileXCoord - x0);</span>
                    }
<span class="nc" id="L103">                    tx++;</span>
                }
                // don't go all the way to tx1 - we need to handle the last
                // tile as a special case (just like we did with the first
<span class="nc bnc" id="L107" title="All 2 branches missed.">                for (; tx &lt; tx1; tx++) {</span>
//                    try {
<span class="nc" id="L109">                    touchedTile[ty][tx] += (val &lt;&lt; TILE_SIZE_LG);</span>
//                    } catch (RuntimeException e) {
//                        System.out.println(&quot;x0, y0: &quot; + x0 + &quot;, &quot; + y0);
//                        System.out.printf(&quot;tx, ty, tx1: %d, %d, %d %n&quot;, tx, ty, tx1);
//                        System.out.printf(&quot;bboxX/Y0/1: %d, %d, %d, %d %n&quot;,
//                                bboxX0, bboxY0, bboxX1, bboxY1);
//                        throw e;
//                    }
                }
                // they will be equal unless x0&gt;&gt;TILE_SIZE_LG == tx1
<span class="nc bnc" id="L119" title="All 2 branches missed.">                if (tx == tx1) {</span>
<span class="nc" id="L120">                    int lastXCoord = Math.min(x0 + runLen, (tx + 1) &lt;&lt; TILE_SIZE_LG);</span>
<span class="nc" id="L121">                    int txXCoord = tx &lt;&lt; TILE_SIZE_LG;</span>
<span class="nc" id="L122">                    touchedTile[ty][tx] += val * (lastXCoord - txXCoord);</span>
                }
            }
<span class="nc" id="L125">            x0 += runLen;</span>
        }
<span class="nc" id="L127">    }</span>

    void startRow(int y, int x) {
        // rows are supposed to be added by increasing y.
<span class="nc bnc" id="L131" title="All 4 branches missed.">        assert y - bboxY0 &gt; y0;</span>
<span class="nc bnc" id="L132" title="All 4 branches missed.">        assert y &lt;= bboxY1; // perhaps this should be &lt; instead of &lt;=</span>

<span class="nc" id="L134">        y0 = y - bboxY0;</span>
        // this should be a new, uninitialized row.
<span class="nc bnc" id="L136" title="All 4 branches missed.">        assert rowAARLE[y0][1] == 0;</span>

<span class="nc" id="L138">        x0 = x - bboxX0;</span>
<span class="nc bnc" id="L139" title="All 4 branches missed.">        assert x0 &gt;= 0 : &quot;Input must not be to the left of bbox bounds&quot;;</span>

        // the way addTupleToRow is implemented it would work for this but it's
        // not a good idea to use it because it is meant for adding
        // RLE tuples, not the first tuple (which is special).
<span class="nc" id="L144">        rowAARLE[y0][0] = x;</span>
<span class="nc" id="L145">        rowAARLE[y0][1] = 2;</span>
<span class="nc" id="L146">    }</span>

    int alphaSumInTile(int x, int y) {
<span class="nc" id="L149">        x -= bboxX0;</span>
<span class="nc" id="L150">        y -= bboxY0;</span>
<span class="nc" id="L151">        return touchedTile[y&gt;&gt;TILE_SIZE_LG][x&gt;&gt;TILE_SIZE_LG];</span>
    }

    int minTouched(int rowidx) {
<span class="nc" id="L155">        return rowAARLE[rowidx][0];</span>
    }

    int rowLength(int rowidx) {
<span class="nc" id="L159">        return rowAARLE[rowidx][1];</span>
    }

    private void addTupleToRow(int row, int a, int b) {
<span class="nc" id="L163">        int end = rowAARLE[row][1];</span>
<span class="nc" id="L164">        rowAARLE[row] = Helpers.widenArray(rowAARLE[row], end, 2);</span>
<span class="nc" id="L165">        rowAARLE[row][end++] = a;</span>
<span class="nc" id="L166">        rowAARLE[row][end++] = b;</span>
<span class="nc" id="L167">        rowAARLE[row][1] = end;</span>
<span class="nc" id="L168">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L172">        String ret = &quot;bbox = [&quot;+</span>
                      bboxX0+&quot;, &quot;+bboxY0+&quot; =&gt; &quot;+
                      bboxX1+&quot;, &quot;+bboxY1+&quot;]\n&quot;;
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (int[] row : rowAARLE) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (row != null) {</span>
<span class="nc" id="L177">                ret += (&quot;minTouchedX=&quot; + row[0] +</span>
<span class="nc" id="L178">                        &quot;\tRLE Entries: &quot; + Arrays.toString(</span>
<span class="nc" id="L179">                                Arrays.copyOfRange(row, 2, row[1])) + &quot;\n&quot;);</span>
            } else {
<span class="nc" id="L181">                ret += &quot;[]\n&quot;;</span>
            }
        }
<span class="nc" id="L184">        return ret;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>