<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PiscesTileGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.pisces</a> &gt; <span class="el_source">PiscesTileGenerator.java</span></div><h1>PiscesTileGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pisces;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import sun.java2d.pipe.AATileGenerator;

<span class="nc bnc" id="L33" title="All 2 branches missed.">final class PiscesTileGenerator implements AATileGenerator {</span>
    public static final int TILE_SIZE = PiscesCache.TILE_SIZE;

    // perhaps we should be using weak references here, but right now
    // that's not necessary. The way the renderer is, this map will
    // never contain more than one element - the one with key 64, since
    // we only do 8x8 supersampling.
<span class="nc" id="L40">    private static final Map&lt;Integer, byte[]&gt; alphaMapsCache = new</span>
                   ConcurrentHashMap&lt;Integer, byte[]&gt;();

    PiscesCache cache;
    int x, y;
    final int maxalpha;
    private final int maxTileAlphaSum;

    // The alpha map used by this object (taken out of our map cache) to convert
    // pixel coverage counts gotten from PiscesCache (which are in the range
    // [0, maxalpha]) into alpha values, which are in [0,256).
    byte alphaMap[];

<span class="nc" id="L53">    public PiscesTileGenerator(Renderer r, int maxalpha) {</span>
<span class="nc" id="L54">        this.cache = r.getCache();</span>
<span class="nc" id="L55">        this.x = cache.bboxX0;</span>
<span class="nc" id="L56">        this.y = cache.bboxY0;</span>
<span class="nc" id="L57">        this.alphaMap = getAlphaMap(maxalpha);</span>
<span class="nc" id="L58">        this.maxalpha = maxalpha;</span>
<span class="nc" id="L59">        this.maxTileAlphaSum = TILE_SIZE*TILE_SIZE*maxalpha;</span>
<span class="nc" id="L60">    }</span>

    private static byte[] buildAlphaMap(int maxalpha) {
<span class="nc" id="L63">        byte[] alMap = new byte[maxalpha+1];</span>
<span class="nc" id="L64">        int halfmaxalpha = maxalpha&gt;&gt;2;</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxalpha; i++) {</span>
<span class="nc" id="L66">            alMap[i] = (byte) ((i * 255 + halfmaxalpha) / maxalpha);</span>
        }
<span class="nc" id="L68">        return alMap;</span>
    }

    public static byte[] getAlphaMap(int maxalpha) {
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if (!alphaMapsCache.containsKey(maxalpha)) {</span>
<span class="nc" id="L73">            alphaMapsCache.put(maxalpha, buildAlphaMap(maxalpha));</span>
        }
<span class="nc" id="L75">        return alphaMapsCache.get(maxalpha);</span>
    }

    public void getBbox(int bbox[]) {
<span class="nc" id="L79">        bbox[0] = cache.bboxX0;</span>
<span class="nc" id="L80">        bbox[1] = cache.bboxY0;</span>
<span class="nc" id="L81">        bbox[2] = cache.bboxX1;</span>
<span class="nc" id="L82">        bbox[3] = cache.bboxY1;</span>
        //System.out.println(&quot;bbox[&quot;+bbox[0]+&quot;, &quot;+bbox[1]+&quot; =&gt; &quot;+bbox[2]+&quot;, &quot;+bbox[3]+&quot;]&quot;);
<span class="nc" id="L84">    }</span>

    /**
     * Gets the width of the tiles that the generator batches output into.
     * @return the width of the standard alpha tile
     */
    public int getTileWidth() {
<span class="nc" id="L91">        return TILE_SIZE;</span>
    }

    /**
     * Gets the height of the tiles that the generator batches output into.
     * @return the height of the standard alpha tile
     */
    public int getTileHeight() {
<span class="nc" id="L99">        return TILE_SIZE;</span>
    }

    /**
     * Gets the typical alpha value that will characterize the current
     * tile.
     * The answer may be 0x00 to indicate that the current tile has
     * no coverage in any of its pixels, or it may be 0xff to indicate
     * that the current tile is completely covered by the path, or any
     * other value to indicate non-trivial coverage cases.
     * @return 0x00 for no coverage, 0xff for total coverage, or any other
     *         value for partial coverage of the tile
     */
    public int getTypicalAlpha() {
<span class="nc" id="L113">        int al = cache.alphaSumInTile(x, y);</span>
        // Note: if we have a filled rectangle that doesn't end on a tile
        // border, we could still return 0xff, even though al!=maxTileAlphaSum
        // This is because if we return 0xff, our users will fill a rectangle
        // starting at x,y that has width = Math.min(TILE_SIZE, bboxX1-x),
        // and height min(TILE_SIZE,bboxY1-y), which is what should happen.
        // However, to support this, we would have to use 2 Math.min's
        // and 2 multiplications per tile, instead of just 2 multiplications
        // to compute maxTileAlphaSum. The savings offered would probably
        // not be worth it, considering how rare this case is.
        // Note: I have not tested this, so in the future if it is determined
        // that it is worth it, it should be implemented. Perhaps this method's
        // interface should be changed to take arguments the width and height
        // of the current tile. This would eliminate the 2 Math.min calls that
        // would be needed here, since our caller needs to compute these 2
        // values anyway.
<span class="nc bnc" id="L129" title="All 4 branches missed.">        return (al == 0x00 ? 0x00 :</span>
            (al == maxTileAlphaSum ? 0xff : 0x80));
    }

    /**
     * Skips the current tile and moves on to the next tile.
     * Either this method, or the getAlpha() method should be called
     * once per tile, but not both.
     */
    public void nextTile() {
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if ((x += TILE_SIZE) &gt;= cache.bboxX1) {</span>
<span class="nc" id="L140">            x = cache.bboxX0;</span>
<span class="nc" id="L141">            y += TILE_SIZE;</span>
        }
<span class="nc" id="L143">    }</span>

    /**
     * Gets the alpha coverage values for the current tile.
     * Either this method, or the nextTile() method should be called
     * once per tile, but not both.
     */
    public void getAlpha(byte tile[], int offset, int rowstride) {
        // Decode run-length encoded alpha mask data
        // The data for row j begins at cache.rowOffsetsRLE[j]
        // and is encoded as a set of 2-byte pairs (val, runLen)
        // terminated by a (0, 0) pair.

<span class="nc" id="L156">        int x0 = this.x;</span>
<span class="nc" id="L157">        int x1 = x0 + TILE_SIZE;</span>
<span class="nc" id="L158">        int y0 = this.y;</span>
<span class="nc" id="L159">        int y1 = y0 + TILE_SIZE;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (x1 &gt; cache.bboxX1) x1 = cache.bboxX1;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (y1 &gt; cache.bboxY1) y1 = cache.bboxY1;</span>
<span class="nc" id="L162">        y0 -= cache.bboxY0;</span>
<span class="nc" id="L163">        y1 -= cache.bboxY0;</span>

<span class="nc" id="L165">        int idx = offset;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (int cy = y0; cy &lt; y1; cy++) {</span>
<span class="nc" id="L167">            int[] row = cache.rowAARLE[cy];</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">            assert row != null;</span>
<span class="nc" id="L169">            int cx = cache.minTouched(cy);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (cx &gt; x1) cx = x1;</span>

<span class="nc bnc" id="L172" title="All 2 branches missed.">            for (int i = x0; i &lt; cx; i++) {</span>
<span class="nc" id="L173">                tile[idx++] = 0x00;</span>
            }

<span class="nc" id="L176">            int pos = 2;</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">            while (cx &lt; x1 &amp;&amp; pos &lt; row[1]) {</span>
                byte val;
<span class="nc" id="L179">                int runLen = 0;</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">                assert row[1] &gt; 2;</span>
                try {
<span class="nc" id="L182">                    val = alphaMap[row[pos]];</span>
<span class="nc" id="L183">                    runLen = row[pos + 1];</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">                    assert runLen &gt; 0;</span>
<span class="nc" id="L185">                } catch (RuntimeException e0) {</span>
<span class="nc" id="L186">                    System.out.println(&quot;maxalpha = &quot;+maxalpha);</span>
<span class="nc" id="L187">                    System.out.println(&quot;tile[&quot;+x0+&quot;, &quot;+y0+</span>
                                       &quot; =&gt; &quot;+x1+&quot;, &quot;+y1+&quot;]&quot;);
<span class="nc" id="L189">                    System.out.println(&quot;cx = &quot;+cx+&quot;, cy = &quot;+cy);</span>
<span class="nc" id="L190">                    System.out.println(&quot;idx = &quot;+idx+&quot;, pos = &quot;+pos);</span>
<span class="nc" id="L191">                    System.out.println(&quot;len = &quot;+runLen);</span>
<span class="nc" id="L192">                    System.out.print(cache.toString());</span>
<span class="nc" id="L193">                    e0.printStackTrace();</span>
<span class="nc" id="L194">                    throw e0;</span>
<span class="nc" id="L195">                }</span>

<span class="nc" id="L197">                int rx0 = cx;</span>
<span class="nc" id="L198">                cx += runLen;</span>
<span class="nc" id="L199">                int rx1 = cx;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (rx0 &lt; x0) rx0 = x0;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (rx1 &gt; x1) rx1 = x1;</span>
<span class="nc" id="L202">                runLen = rx1 - rx0;</span>
                //System.out.println(&quot;M[&quot;+runLen+&quot;]&quot;);
<span class="nc bnc" id="L204" title="All 2 branches missed.">                while (--runLen &gt;= 0) {</span>
                    try {
<span class="nc" id="L206">                        tile[idx++] = val;</span>
<span class="nc" id="L207">                    } catch (RuntimeException e) {</span>
<span class="nc" id="L208">                        System.out.println(&quot;maxalpha = &quot;+maxalpha);</span>
<span class="nc" id="L209">                        System.out.println(&quot;tile[&quot;+x0+&quot;, &quot;+y0+</span>
                                           &quot; =&gt; &quot;+x1+&quot;, &quot;+y1+&quot;]&quot;);
<span class="nc" id="L211">                        System.out.println(&quot;cx = &quot;+cx+&quot;, cy = &quot;+cy);</span>
<span class="nc" id="L212">                        System.out.println(&quot;idx = &quot;+idx+&quot;, pos = &quot;+pos);</span>
<span class="nc" id="L213">                        System.out.println(&quot;rx0 = &quot;+rx0+&quot;, rx1 = &quot;+rx1);</span>
<span class="nc" id="L214">                        System.out.println(&quot;len = &quot;+runLen);</span>
<span class="nc" id="L215">                        System.out.print(cache.toString());</span>
<span class="nc" id="L216">                        e.printStackTrace();</span>
<span class="nc" id="L217">                        throw e;</span>
<span class="nc" id="L218">                    }</span>
                }
<span class="nc" id="L220">                pos += 2;</span>
<span class="nc" id="L221">            }</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">            if (cx &lt; x0) { cx = x0; }</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            while (cx &lt; x1) {</span>
<span class="nc" id="L224">                tile[idx++] = 0x00;</span>
<span class="nc" id="L225">                cx++;</span>
            }
            /*
            for (int i = idx - (x1-x0); i &lt; idx; i++) {
                System.out.print(hex(tile[i], 2));
            }
            System.out.println();
            */
<span class="nc" id="L233">            idx += (rowstride - (x1-x0));</span>
        }
<span class="nc" id="L235">        nextTile();</span>
<span class="nc" id="L236">    }</span>

    static String hex(int v, int d) {
<span class="nc" id="L239">        String s = Integer.toHexString(v);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        while (s.length() &lt; d) {</span>
<span class="nc" id="L241">            s = &quot;0&quot;+s;</span>
        }
<span class="nc" id="L243">        return s.substring(0, d);</span>
    }

    /**
     * Disposes this tile generator.
     * No further calls will be made on this instance.
     */
<span class="nc" id="L250">    public void dispose() {}</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>