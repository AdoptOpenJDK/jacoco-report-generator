<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GssKrb5Server.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.security.sasl.gsskerb</a> &gt; <span class="el_source">GssKrb5Server.java</span></div><h1>GssKrb5Server.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.sasl.gsskerb;

import javax.security.sasl.*;
import java.io.*;
import java.util.Map;
import java.util.logging.Level;

// JAAS
import javax.security.auth.callback.*;

// JGSS
import org.ietf.jgss.*;

/**
  * Implements the GSSAPI SASL server mechanism for Kerberos V5.
  * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
  * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-00.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-00.txt&lt;/a&gt;).
  *
  * Expects thread's Subject to contain server's Kerberos credentials
  * - If not, underlying KRB5 mech will attempt to acquire Kerberos creds
  *   by logging into Kerberos (via default TextCallbackHandler).
  * - These creds will be used for exchange with client.
  *
  * Required callbacks:
  * - AuthorizeCallback
  *      handler must verify that authid/authzids are allowed and set
  *      authorized ID to be the canonicalized authzid (if applicable).
  *
  * Environment properties that affect behavior of implementation:
  *
  * javax.security.sasl.qop
  * - quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
  * javax.security.sasl.maxbuf
  * - max receive buffer size; default is 65536
  * javax.security.sasl.sendmaxbuffer
  * - max send buffer size; default is 65536; (min with client max recv size)
  *
  * @author Rosanna Lee
  */
final class GssKrb5Server extends GssKrb5Base implements SaslServer {
<span class="fc" id="L66">    private static final String MY_CLASS_NAME = GssKrb5Server.class.getName();</span>

<span class="fc" id="L68">    private int handshakeStage = 0;</span>
    private String peer;
    private String me;
    private String authzid;
    private CallbackHandler cbh;

    // When serverName is null, the server will be unbound. We need to save and
    // check the protocol name after the context is established. This value
    // will be null if serverName is not null.
    private final String protocolSaved;
    /**
     * Creates a SASL mechanism with server credentials that it needs
     * to participate in GSS-API/Kerberos v5 authentication exchange
     * with the client.
     */
    GssKrb5Server(String protocol, String serverName,
        Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {

<span class="fc" id="L86">        super(props, MY_CLASS_NAME);</span>

<span class="fc" id="L88">        this.cbh = cbh;</span>

        String service;
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (serverName == null) {</span>
<span class="fc" id="L92">            protocolSaved = protocol;</span>
<span class="fc" id="L93">            service = null;</span>
        } else {
<span class="fc" id="L95">            protocolSaved = null;</span>
<span class="fc" id="L96">            service = protocol + &quot;@&quot; + serverName;</span>
        }

<span class="fc" id="L99">        logger.log(Level.FINE, &quot;KRB5SRV01:Using service name: {0}&quot;, service);</span>

        try {
<span class="fc" id="L102">            GSSManager mgr = GSSManager.getInstance();</span>

            // Create the name for the requested service entity for Krb5 mech
<span class="fc bfc" id="L105" title="All 2 branches covered.">            GSSName serviceName = service == null ? null:</span>
<span class="fc" id="L106">                    mgr.createName(service, GSSName.NT_HOSTBASED_SERVICE, KRB5_OID);</span>

<span class="fc" id="L108">            GSSCredential cred = mgr.createCredential(serviceName,</span>
                GSSCredential.INDEFINITE_LIFETIME,
                KRB5_OID, GSSCredential.ACCEPT_ONLY);

            // Create a context using the server's credentials
<span class="fc" id="L113">            secCtx = mgr.createContext(cred);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">            if ((allQop&amp;INTEGRITY_ONLY_PROTECTION) != 0) {</span>
                // Might need integrity
<span class="fc" id="L117">                secCtx.requestInteg(true);</span>
            }

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if ((allQop&amp;PRIVACY_PROTECTION) != 0) {</span>
                // Might need privacy
<span class="fc" id="L122">                secCtx.requestConf(true);</span>
            }
<span class="nc" id="L124">        } catch (GSSException e) {</span>
<span class="nc" id="L125">            throw new SaslException(&quot;Failure to initialize security context&quot;, e);</span>
<span class="fc" id="L126">        }</span>
<span class="fc" id="L127">        logger.log(Level.FINE, &quot;KRB5SRV02:Initialization complete&quot;);</span>
<span class="fc" id="L128">    }</span>


    /**
     * Processes the response data.
     *
     * The client sends response data to which the server must
     * process using GSS_accept_sec_context.
     * As per RFC 2222, the GSS authenication completes (GSS_S_COMPLETE)
     * we do an extra hand shake to determine the negotiated security protection
     * and buffer sizes.
     *
     * @param responseData A non-null but possible empty byte array containing the
     * response data from the client.
     * @return A non-null byte array containing the challenge to be
     * sent to the client, or null when no more data is to be sent.
     */
    public byte[] evaluateResponse(byte[] responseData) throws SaslException {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (completed) {</span>
<span class="nc" id="L147">            throw new SaslException(</span>
                &quot;SASL authentication already complete&quot;);
        }

<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L152">            traceOutput(MY_CLASS_NAME, &quot;evaluateResponse&quot;,</span>
                &quot;KRB5SRV03:Response [raw]:&quot;, responseData);
        }

<span class="nc bnc" id="L156" title="All 3 branches missed.">        switch (handshakeStage) {</span>
        case 1:
<span class="nc" id="L158">            return doHandshake1(responseData);</span>

        case 2:
<span class="nc" id="L161">            return doHandshake2(responseData);</span>

        default:
            // Security context not established yet; continue with accept

            try {
<span class="nc" id="L167">                byte[] gssOutToken = secCtx.acceptSecContext(responseData,</span>
                    0, responseData.length);

<span class="nc bnc" id="L170" title="All 2 branches missed.">                if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L171">                    traceOutput(MY_CLASS_NAME, &quot;evaluateResponse&quot;,</span>
                        &quot;KRB5SRV04:Challenge: [after acceptSecCtx]&quot;, gssOutToken);
                }

<span class="nc bnc" id="L175" title="All 2 branches missed.">                if (secCtx.isEstablished()) {</span>
<span class="nc" id="L176">                    handshakeStage = 1;</span>

<span class="nc" id="L178">                    peer = secCtx.getSrcName().toString();</span>
<span class="nc" id="L179">                    me = secCtx.getTargName().toString();</span>

<span class="nc" id="L181">                    logger.log(Level.FINE,</span>
                            &quot;KRB5SRV05:Peer name is : {0}, my name is : {1}&quot;,
                            new Object[]{peer, me});

                    // me might take the form of proto@host or proto/host
<span class="nc bnc" id="L186" title="All 2 branches missed.">                    if (protocolSaved != null &amp;&amp;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                            !protocolSaved.equalsIgnoreCase(me.split(&quot;[/@]&quot;)[0])) {</span>
<span class="nc" id="L188">                        throw new SaslException(</span>
                                &quot;GSS context targ name protocol error: &quot; + me);
                    }

<span class="nc bnc" id="L192" title="All 2 branches missed.">                    if (gssOutToken == null) {</span>
<span class="nc" id="L193">                        return doHandshake1(EMPTY);</span>
                    }
                }

<span class="nc" id="L197">                return gssOutToken;</span>
<span class="nc" id="L198">            } catch (GSSException e) {</span>
<span class="nc" id="L199">                throw new SaslException(&quot;GSS initiate failed&quot;, e);</span>
            }
        }
    }

    private byte[] doHandshake1(byte[] responseData) throws SaslException {
        try {
            // Security context already established. responseData
            // should contain no data
<span class="nc bnc" id="L208" title="All 4 branches missed.">            if (responseData != null &amp;&amp; responseData.length &gt; 0) {</span>
<span class="nc" id="L209">                throw new SaslException(</span>
                    &quot;Handshake expecting no response data from server&quot;);
            }

            // Construct 4 octets of data:
            // First octet contains bitmask specifying protections supported
            // 2nd-4th octets contains max receive buffer of server

<span class="nc" id="L217">            byte[] gssInToken = new byte[4];</span>
<span class="nc" id="L218">            gssInToken[0] = allQop;</span>
<span class="nc" id="L219">            intToNetworkByteOrder(recvMaxBufSize, gssInToken, 1, 3);</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L222">                logger.log(Level.FINE,</span>
                    &quot;KRB5SRV06:Supported protections: {0}; recv max buf size: {1}&quot;,
                    new Object[]{new Byte(allQop),
                                 new Integer(recvMaxBufSize)});
            }

<span class="nc" id="L228">            handshakeStage = 2;  // progress to next stage</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L231">                traceOutput(MY_CLASS_NAME, &quot;doHandshake1&quot;,</span>
                    &quot;KRB5SRV07:Challenge [raw]&quot;, gssInToken);
            }

<span class="nc" id="L235">            byte[] gssOutToken = secCtx.wrap(gssInToken, 0, gssInToken.length,</span>
                new MessageProp(0 /* gop */, false /* privacy */));

<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L239">                traceOutput(MY_CLASS_NAME, &quot;doHandshake1&quot;,</span>
                    &quot;KRB5SRV08:Challenge [after wrap]&quot;, gssOutToken);
            }
<span class="nc" id="L242">            return gssOutToken;</span>

<span class="nc" id="L244">        } catch (GSSException e) {</span>
<span class="nc" id="L245">            throw new SaslException(&quot;Problem wrapping handshake1&quot;, e);</span>
        }
    }

    private byte[] doHandshake2(byte[] responseData) throws SaslException {
        try {
            // Expecting 4 octets from client selected protection
            // and client's receive buffer size
<span class="nc" id="L253">            byte[] gssOutToken = secCtx.unwrap(responseData, 0,</span>
                responseData.length, new MessageProp(0, false));

<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L257">                traceOutput(MY_CLASS_NAME, &quot;doHandshake2&quot;,</span>
                    &quot;KRB5SRV09:Response [after unwrap]&quot;, gssOutToken);
            }

            // First octet is a bit-mask specifying the selected protection
<span class="nc" id="L262">            byte selectedQop = gssOutToken[0];</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if ((selectedQop&amp;allQop) == 0) {</span>
<span class="nc" id="L264">                throw new SaslException(&quot;Client selected unsupported protection: &quot;</span>
                    + selectedQop);
            }
<span class="nc bnc" id="L267" title="All 2 branches missed.">            if ((selectedQop&amp;PRIVACY_PROTECTION) != 0) {</span>
<span class="nc" id="L268">                privacy = true;</span>
<span class="nc" id="L269">                integrity = true;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            } else if ((selectedQop&amp;INTEGRITY_ONLY_PROTECTION) != 0) {</span>
<span class="nc" id="L271">                integrity = true;</span>
            }

            // 2nd-4th octets specifies maximum buffer size expected by
            // client (in network byte order). This is the server's send
            // buffer maximum.
<span class="nc" id="L277">            int clntMaxBufSize = networkByteOrderToInt(gssOutToken, 1, 3);</span>

            // Determine the max send buffer size based on what the
            // client is able to receive and our specified max
<span class="nc bnc" id="L281" title="All 2 branches missed.">            sendMaxBufSize = (sendMaxBufSize == 0) ? clntMaxBufSize :</span>
<span class="nc" id="L282">                Math.min(sendMaxBufSize, clntMaxBufSize);</span>

            // Update context to limit size of returned buffer
<span class="nc" id="L285">            rawSendSize = secCtx.getWrapSizeLimit(JGSS_QOP, privacy,</span>
                sendMaxBufSize);

<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L289">                logger.log(Level.FINE,</span>
            &quot;KRB5SRV10:Selected protection: {0}; privacy: {1}; integrity: {2}&quot;,
                    new Object[]{new Byte(selectedQop),
<span class="nc" id="L292">                                 Boolean.valueOf(privacy),</span>
<span class="nc" id="L293">                                 Boolean.valueOf(integrity)});</span>
<span class="nc" id="L294">                logger.log(Level.FINE,</span>
&quot;KRB5SRV11:Client max recv size: {0}; server max send size: {1}; rawSendSize: {2}&quot;,
                    new Object[] {new Integer(clntMaxBufSize),
                                  new Integer(sendMaxBufSize),
                                  new Integer(rawSendSize)});
            }

            // Get authorization identity, if any
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (gssOutToken.length &gt; 4) {</span>
                try {
<span class="nc" id="L304">                    authzid = new String(gssOutToken, 4,</span>
                        gssOutToken.length - 4, &quot;UTF-8&quot;);
<span class="nc" id="L306">                } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L307">                    throw new SaslException (&quot;Cannot decode authzid&quot;, uee);</span>
<span class="nc" id="L308">                }</span>
            } else {
<span class="nc" id="L310">                authzid = peer;</span>
            }
<span class="nc" id="L312">            logger.log(Level.FINE, &quot;KRB5SRV12:Authzid: {0}&quot;, authzid);</span>

<span class="nc" id="L314">            AuthorizeCallback acb = new AuthorizeCallback(peer, authzid);</span>

            // In Kerberos, realm is embedded in peer name
<span class="nc" id="L317">            cbh.handle(new Callback[] {acb});</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if (acb.isAuthorized()) {</span>
<span class="nc" id="L319">                authzid = acb.getAuthorizedID();</span>
<span class="nc" id="L320">                completed = true;</span>
            } else {
                // Authorization failed
<span class="nc" id="L323">                throw new SaslException(peer +</span>
                    &quot; is not authorized to connect as &quot; + authzid);
            }

<span class="nc" id="L327">            return null;</span>
<span class="nc" id="L328">        } catch (GSSException e) {</span>
<span class="nc" id="L329">            throw new SaslException(&quot;Final handshake step failed&quot;, e);</span>
<span class="nc" id="L330">        } catch (IOException e) {</span>
<span class="nc" id="L331">            throw new SaslException(&quot;Problem with callback handler&quot;, e);</span>
<span class="nc" id="L332">        } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L333">            throw new SaslException(&quot;Problem with callback handler&quot;, e);</span>
        }
    }

    public String getAuthorizationID() {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (completed) {</span>
<span class="nc" id="L339">            return authzid;</span>
        } else {
<span class="nc" id="L341">            throw new IllegalStateException(&quot;Authentication incomplete&quot;);</span>
        }
    }

    public Object getNegotiatedProperty(String propName) {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (!completed) {</span>
<span class="nc" id="L347">            throw new IllegalStateException(&quot;Authentication incomplete&quot;);</span>
        }

        Object result;
<span class="nc bnc" id="L351" title="All 6 branches missed.">        switch (propName) {</span>
            case Sasl.BOUND_SERVER_NAME:
                try {
                    // me might take the form of proto@host or proto/host
<span class="nc" id="L355">                    result = me.split(&quot;[/@]&quot;)[1];</span>
<span class="nc" id="L356">                } catch (Exception e) {</span>
<span class="nc" id="L357">                    result = null;</span>
<span class="nc" id="L358">                }</span>
<span class="nc" id="L359">                break;</span>
            default:
<span class="nc" id="L361">                result = super.getNegotiatedProperty(propName);</span>
        }
<span class="nc" id="L363">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>