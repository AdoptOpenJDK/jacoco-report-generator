<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>GssKrb5Client.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.security.sasl.gsskerb</a> &gt; <span class="el_source">GssKrb5Client.java</span></div><h1>GssKrb5Client.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.sasl.gsskerb;

import java.io.IOException;
import java.util.Map;
import java.util.logging.Level;
import javax.security.sasl.*;

// JAAS
import javax.security.auth.callback.CallbackHandler;

// JGSS
import org.ietf.jgss.*;

/**
  * Implements the GSSAPI SASL client mechanism for Kerberos V5.
  * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
  * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-04.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-04.txt&lt;/a&gt;).
  * It uses the Java Bindings for GSSAPI
  * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/A&gt;)
  * for getting GSSAPI/Kerberos V5 support.
  *
  * The client/server interactions are:
  * C0: bind (GSSAPI, initial response)
  * S0: sasl-bind-in-progress, challenge 1 (output of accept_sec_context or [])
  * C1: bind (GSSAPI, response 1 (output of init_sec_context or []))
  * S1: sasl-bind-in-progress challenge 2 (security layer, server max recv size)
  * C2: bind (GSSAPI, response 2 (security layer, client max recv size, authzid))
  * S2: bind success response
  *
  * Expects the client's credentials to be supplied from the
  * javax.security.sasl.credentials property or from the thread's Subject.
  * Otherwise the underlying KRB5 mech will attempt to acquire Kerberos creds
  * by logging into Kerberos (via default TextCallbackHandler).
  * These creds will be used for exchange with server.
  *
  * Required callbacks: none.
  *
  * Environment properties that affect behavior of implementation:
  *
  * javax.security.sasl.qop
  * - quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
  * javax.security.sasl.maxbuf
  * - max receive buffer size; default is 65536
  * javax.security.sasl.sendmaxbuffer
  * - max send buffer size; default is 65536; (min with server max recv size)
  *
  * javax.security.sasl.server.authentication
  * - &quot;true&quot; means require mutual authentication; default is &quot;false&quot;
  *
  * javax.security.sasl.credentials
  * - an {@link org.ietf.jgss.GSSCredential} used for delegated authentication.
  *
  * @author Rosanna Lee
  */

final class GssKrb5Client extends GssKrb5Base implements SaslClient {
    // ---------------- Constants -----------------
<span class="fc" id="L83">    private static final String MY_CLASS_NAME = GssKrb5Client.class.getName();</span>

<span class="fc" id="L85">    private boolean finalHandshake = false;</span>
<span class="fc" id="L86">    private boolean mutual = false;       // default false</span>
    private byte[] authzID;

    /**
     * Creates a SASL mechanism with client credentials that it needs
     * to participate in GSS-API/Kerberos v5 authentication exchange
     * with the server.
     */
    GssKrb5Client(String authzID, String protocol, String serverName,
        Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {

<span class="fc" id="L97">        super(props, MY_CLASS_NAME);</span>

<span class="fc" id="L99">        String service = protocol + &quot;@&quot; + serverName;</span>
<span class="fc" id="L100">        logger.log(Level.FINE, &quot;KRB5CLNT01:Requesting service name: {0}&quot;,</span>
            service);

        try {
<span class="fc" id="L104">            GSSManager mgr = GSSManager.getInstance();</span>

            // Create the name for the requested service entity for Krb5 mech
<span class="fc" id="L107">            GSSName acceptorName = mgr.createName(service,</span>
                GSSName.NT_HOSTBASED_SERVICE, KRB5_OID);

            // Parse properties to check for supplied credentials
<span class="fc" id="L111">            GSSCredential credentials = null;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (props != null) {</span>
<span class="fc" id="L113">                Object prop = props.get(Sasl.CREDENTIALS);</span>
<span class="pc bpc" id="L114" title="3 of 4 branches missed.">                if (prop != null &amp;&amp; prop instanceof GSSCredential) {</span>
<span class="nc" id="L115">                    credentials = (GSSCredential) prop;</span>
<span class="nc" id="L116">                    logger.log(Level.FINE,</span>
                        &quot;KRB5CLNT01:Using the credentials supplied in &quot; +
                        &quot;javax.security.sasl.credentials&quot;);
                }
            }

            // Create a context using credentials for Krb5 mech
<span class="fc" id="L123">            secCtx = mgr.createContext(acceptorName,</span>
                KRB5_OID,   /* mechanism */
                credentials, /* credentials */
                GSSContext.INDEFINITE_LIFETIME);

            // Request credential delegation when credentials have been supplied
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            if (credentials != null) {</span>
<span class="nc" id="L130">                secCtx.requestCredDeleg(true);</span>
            }

            // Parse properties  to set desired context options
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">            if (props != null) {</span>
                // Mutual authentication
<span class="fc" id="L136">                String prop = (String)props.get(Sasl.SERVER_AUTH);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">                if (prop != null) {</span>
<span class="nc" id="L138">                    mutual = &quot;true&quot;.equalsIgnoreCase(prop);</span>
                }
            }
<span class="fc" id="L141">            secCtx.requestMutualAuth(mutual);</span>

            // Always specify potential need for integrity and confidentiality
            // Decision will be made during final handshake
<span class="fc" id="L145">            secCtx.requestConf(true);</span>
<span class="fc" id="L146">            secCtx.requestInteg(true);</span>

<span class="nc" id="L148">        } catch (GSSException e) {</span>
<span class="nc" id="L149">            throw new SaslException(&quot;Failure to initialize security context&quot;, e);</span>
<span class="fc" id="L150">        }</span>

<span class="pc bpc" id="L152" title="3 of 4 branches missed.">        if (authzID != null &amp;&amp; authzID.length() &gt; 0) {</span>
            try {
<span class="nc" id="L154">                this.authzID = authzID.getBytes(&quot;UTF8&quot;);</span>
<span class="nc" id="L155">            } catch (IOException e) {</span>
<span class="nc" id="L156">                throw new SaslException(&quot;Cannot encode authorization ID&quot;, e);</span>
<span class="nc" id="L157">            }</span>
        }
<span class="fc" id="L159">    }</span>

    public boolean hasInitialResponse() {
<span class="nc" id="L162">        return true;</span>
    }

    /**
     * Processes the challenge data.
     *
     * The server sends a challenge data using which the client must
     * process using GSS_Init_sec_context.
     * As per RFC 2222, when GSS_S_COMPLETE is returned, we do
     * an extra handshake to determine the negotiated security protection
     * and buffer sizes.
     *
     * @param challengeData A non-null byte array containing the
     * challenge data from the server.
     * @return A non-null byte array containing the response to be
     * sent to the server.
     */
    public byte[] evaluateChallenge(byte[] challengeData) throws SaslException {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (completed) {</span>
<span class="nc" id="L181">            throw new IllegalStateException(</span>
                &quot;GSSAPI authentication already complete&quot;);
        }

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (finalHandshake) {</span>
<span class="nc" id="L186">            return doFinalHandshake(challengeData);</span>
        } else {

            // Security context not established yet; continue with init

            try {
<span class="nc" id="L192">                byte[] gssOutToken = secCtx.initSecContext(challengeData,</span>
                    0, challengeData.length);
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L195">                    traceOutput(MY_CLASS_NAME, &quot;evaluteChallenge&quot;,</span>
                        &quot;KRB5CLNT02:Challenge: [raw]&quot;, challengeData);
<span class="nc" id="L197">                    traceOutput(MY_CLASS_NAME, &quot;evaluateChallenge&quot;,</span>
                        &quot;KRB5CLNT03:Response: [after initSecCtx]&quot;, gssOutToken);
                }

<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (secCtx.isEstablished()) {</span>
<span class="nc" id="L202">                    finalHandshake = true;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                    if (gssOutToken == null) {</span>
                        // RFC 2222 7.2.1:  Client responds with no data
<span class="nc" id="L205">                        return EMPTY;</span>
                    }
                }

<span class="nc" id="L209">                return gssOutToken;</span>
<span class="fc" id="L210">            } catch (GSSException e) {</span>
<span class="fc" id="L211">                throw new SaslException(&quot;GSS initiate failed&quot;, e);</span>
            }
        }
    }

    private byte[] doFinalHandshake(byte[] challengeData) throws SaslException {
        try {
            // Security context already established. challengeData
            // should contain security layers and server's maximum buffer size

<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L222">                traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,</span>
                    &quot;KRB5CLNT04:Challenge [raw]:&quot;, challengeData);
            }

<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (challengeData.length == 0) {</span>
                // Received S0, should return []
<span class="nc" id="L228">                return EMPTY;</span>
            }

            // Received S1 (security layer, server max recv size)

<span class="nc" id="L233">            byte[] gssOutToken = secCtx.unwrap(challengeData, 0,</span>
                challengeData.length, new MessageProp(0, false));

            // First octet is a bit-mask specifying the protections
            // supported by the server
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L240">                    traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,</span>
                        &quot;KRB5CLNT05:Challenge [unwrapped]:&quot;, gssOutToken);
                }
<span class="nc" id="L243">                logger.log(Level.FINE, &quot;KRB5CLNT06:Server protections: {0}&quot;,</span>
                    new Byte(gssOutToken[0]));
            }

            // Client selects preferred protection
            // qop is ordered list of qop values
<span class="nc" id="L249">            byte selectedQop = findPreferredMask(gssOutToken[0], qop);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (selectedQop == 0) {</span>
<span class="nc" id="L251">                throw new SaslException(</span>
                    &quot;No common protection layer between client and server&quot;);
            }

<span class="nc bnc" id="L255" title="All 2 branches missed.">            if ((selectedQop&amp;PRIVACY_PROTECTION) != 0) {</span>
<span class="nc" id="L256">                privacy = true;</span>
<span class="nc" id="L257">                integrity = true;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            } else if ((selectedQop&amp;INTEGRITY_ONLY_PROTECTION) != 0) {</span>
<span class="nc" id="L259">                integrity = true;</span>
            }

            // 2nd-4th octets specifies maximum buffer size expected by
            // server (in network byte order)
<span class="nc" id="L264">            int srvMaxBufSize = networkByteOrderToInt(gssOutToken, 1, 3);</span>

            // Determine the max send buffer size based on what the
            // server is able to receive and our specified max
<span class="nc bnc" id="L268" title="All 2 branches missed.">            sendMaxBufSize = (sendMaxBufSize == 0) ? srvMaxBufSize :</span>
<span class="nc" id="L269">                Math.min(sendMaxBufSize, srvMaxBufSize);</span>

            // Update context to limit size of returned buffer
<span class="nc" id="L272">            rawSendSize = secCtx.getWrapSizeLimit(JGSS_QOP, privacy,</span>
                sendMaxBufSize);

<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L276">                logger.log(Level.FINE,</span>
&quot;KRB5CLNT07:Client max recv size: {0}; server max recv size: {1}; rawSendSize: {2}&quot;,
                    new Object[] {new Integer(recvMaxBufSize),
                                  new Integer(srvMaxBufSize),
                                  new Integer(rawSendSize)});
            }

            // Construct negotiated security layers and client's max
            // receive buffer size and authzID
<span class="nc" id="L285">            int len = 4;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            if (authzID != null) {</span>
<span class="nc" id="L287">                len += authzID.length;</span>
            }

<span class="nc" id="L290">            byte[] gssInToken = new byte[len];</span>
<span class="nc" id="L291">            gssInToken[0] = selectedQop;</span>

<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINE)) {</span>
<span class="nc" id="L294">                logger.log(Level.FINE,</span>
            &quot;KRB5CLNT08:Selected protection: {0}; privacy: {1}; integrity: {2}&quot;,
                    new Object[]{new Byte(selectedQop),
<span class="nc" id="L297">                                 Boolean.valueOf(privacy),</span>
<span class="nc" id="L298">                                 Boolean.valueOf(integrity)});</span>
            }

<span class="nc" id="L301">            intToNetworkByteOrder(recvMaxBufSize, gssInToken, 1, 3);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (authzID != null) {</span>
                // copy authorization id
<span class="nc" id="L304">                System.arraycopy(authzID, 0, gssInToken, 4, authzID.length);</span>
<span class="nc" id="L305">                logger.log(Level.FINE, &quot;KRB5CLNT09:Authzid: {0}&quot;, authzID);</span>
            }

<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L309">                traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,</span>
                    &quot;KRB5CLNT10:Response [raw]&quot;, gssInToken);
            }

<span class="nc" id="L313">            gssOutToken = secCtx.wrap(gssInToken,</span>
                0, gssInToken.length,
                new MessageProp(0 /* qop */, false /* privacy */));

<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (logger.isLoggable(Level.FINER)) {</span>
<span class="nc" id="L318">                traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,</span>
                    &quot;KRB5CLNT11:Response [after wrap]&quot;, gssOutToken);
            }

<span class="nc" id="L322">            completed = true;  // server authenticated</span>

<span class="nc" id="L324">            return gssOutToken;</span>
<span class="nc" id="L325">        } catch (GSSException e) {</span>
<span class="nc" id="L326">            throw new SaslException(&quot;Final handshake failed&quot;, e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>