<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PerfDataBuffer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.perfdata.monitor.v1_0</a> &gt; <span class="el_source">PerfDataBuffer.java</span></div><h1>PerfDataBuffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.v1_0;

import sun.jvmstat.monitor.*;
import sun.jvmstat.perfdata.monitor.*;
import java.util.*;
import java.util.regex.*;
import java.nio.*;

/**
 * The concrete implementation of version 1.0 of the HotSpot PerfData
 * Instrumentation buffer. This class is responsible for parsing the
 * instrumentation memory and constructing the necessary objects to
 * represent and access the instrumentation objects contained in the
 * memory buffer.
 *
 * @author Brian Doherty
 * @since 1.5
 * @see AbstractPerfDataBuffer
 */
<span class="nc bnc" id="L45" title="All 2 branches missed.">public class PerfDataBuffer extends PerfDataBufferImpl {</span>

    private static final boolean DEBUG = false;
<span class="nc" id="L48">    private static final int syncWaitMs =</span>
<span class="nc" id="L49">            Integer.getInteger(&quot;sun.jvmstat.perdata.syncWaitMs&quot;, 5000);</span>
<span class="nc" id="L50">    private static final ArrayList EMPTY_LIST = new ArrayList(0);</span>

    /*
     * the following constants must be kept in sync with struct
     * PerfDataEntry in perfMemory.hpp
     */
    private final static int PERFDATA_ENTRYLENGTH_OFFSET=0;
    private final static int PERFDATA_ENTRYLENGTH_SIZE=4;   // sizeof(int)
    private final static int PERFDATA_NAMELENGTH_OFFSET=4;
    private final static int PERFDATA_NAMELENGTH_SIZE=4;    // sizeof(int)
    private final static int PERFDATA_VECTORLENGTH_OFFSET=8;
    private final static int PERFDATA_VECTORLENGTH_SIZE=4;  // sizeof(int)
    private final static int PERFDATA_DATATYPE_OFFSET=12;
    private final static int PERFDATA_DATATYPE_SIZE=1;      // sizeof(byte)
    private final static int PERFDATA_FLAGS_OFFSET=13;
    private final static int PERFDATA_FLAGS_SIZE=1;        // sizeof(byte)
    private final static int PERFDATA_DATAUNITS_OFFSET=14;
    private final static int PERFDATA_DATAUNITS_SIZE=1;     // sizeof(byte)
    private final static int PERFDATA_DATAATTR_OFFSET=15;
    private final static int PERFDATA_DATAATTR_SIZE=1;      // sizeof(byte)
    private final static int PERFDATA_NAME_OFFSET=16;

    PerfDataBufferPrologue prologue;
    int nextEntry;
    int pollForEntry;
    int perfDataItem;
    long lastModificationTime;
    int lastUsed;
    IntegerMonitor overflow;
    ArrayList&lt;Monitor&gt; insertedMonitors;

    /**
     * Construct a PerfDataBufferImpl instance.
     * &lt;p&gt;
     * This class is dynamically loaded by
     * {@link AbstractPerfDataBuffer#createPerfDataBuffer}, and this
     * constructor is called to instantiate the instance.
     *
     * @param buffer the buffer containing the instrumentation data
     * @param lvmid the Local Java Virtual Machine Identifier for this
     *              instrumentation buffer.
     */
    public PerfDataBuffer(ByteBuffer buffer, int lvmid)
           throws MonitorException {
<span class="nc" id="L94">        super(buffer, lvmid);</span>
<span class="nc" id="L95">        prologue = new PerfDataBufferPrologue(buffer);</span>
<span class="nc" id="L96">        this.buffer.order(prologue.getByteOrder());</span>
<span class="nc" id="L97">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void buildMonitorMap(Map&lt;String, Monitor&gt; map) throws MonitorException {
<span class="nc bnc" id="L103" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>

        // start at the beginning of the buffer
<span class="nc" id="L106">        buffer.rewind();</span>

        // create pseudo monitors
<span class="nc" id="L109">        buildPseudoMonitors(map);</span>

        // position buffer to start of the data section
<span class="nc" id="L112">        buffer.position(prologue.getSize());</span>
<span class="nc" id="L113">        nextEntry = buffer.position();</span>
<span class="nc" id="L114">        perfDataItem = 0;</span>

<span class="nc" id="L116">        int used = prologue.getUsed();</span>
<span class="nc" id="L117">        long modificationTime = prologue.getModificationTimeStamp();</span>

<span class="nc" id="L119">        Monitor m = getNextMonitorEntry();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        while (m != null) {</span>
<span class="nc" id="L121">            map.put(m.getName(), m);</span>
<span class="nc" id="L122">            m = getNextMonitorEntry();</span>
        }

        /*
         * set the last modification data. These are set to the values
         * recorded before parsing the data structure. This allows the
         * the data structure to be modified while the Map is being built.
         * The Map may contain more entries than indicated based on the
         * time stamp, but this is handled by ignoring duplicate entries
         * when the Map is updated in getNewMonitors().
         */
<span class="nc" id="L133">        lastUsed = used;</span>
<span class="nc" id="L134">        lastModificationTime = modificationTime;</span>

        // synchronize with the target jvm
<span class="nc" id="L137">        synchWithTarget(map);</span>

        // work around 1.4.2 counter inititization bugs
<span class="nc" id="L140">        kludge(map);</span>

<span class="nc" id="L142">        insertedMonitors = new ArrayList&lt;Monitor&gt;(map.values());</span>
<span class="nc" id="L143">    }</span>

    /**
     * {@inheritDoc}
     */
    protected void getNewMonitors(Map&lt;String, Monitor&gt; map) throws MonitorException {
<span class="nc bnc" id="L149" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>

<span class="nc" id="L151">        int used = prologue.getUsed();</span>
<span class="nc" id="L152">        long modificationTime = prologue.getModificationTimeStamp();</span>

<span class="nc bnc" id="L154" title="All 4 branches missed.">        if ((used &gt; lastUsed) || (lastModificationTime &gt; modificationTime)) {</span>

<span class="nc" id="L156">            lastUsed = used;</span>
<span class="nc" id="L157">            lastModificationTime = modificationTime;</span>

<span class="nc" id="L159">            Monitor monitor = getNextMonitorEntry();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            while (monitor != null) {</span>
<span class="nc" id="L161">                String name = monitor.getName();</span>

                // guard against duplicate entries
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (!map.containsKey(name)) {</span>
<span class="nc" id="L165">                    map.put(name, monitor);</span>

                    /*
                     * insertedMonitors is null when called from pollFor()
                     * via buildMonitorMap(). Since we update insertedMonitors
                     * at the end of buildMonitorMap(), it's ok to skip the
                     * add here.
                     */
<span class="nc bnc" id="L173" title="All 2 branches missed.">                    if (insertedMonitors != null) {</span>
<span class="nc" id="L174">                        insertedMonitors.add(monitor);</span>
                    }
                }
<span class="nc" id="L177">                monitor = getNextMonitorEntry();</span>
<span class="nc" id="L178">            }</span>
        }
<span class="nc" id="L180">    }</span>

    /**
     * {@inheritDoc}
     */
    protected MonitorStatus getMonitorStatus(Map&lt;String, Monitor&gt; map) throws MonitorException {
<span class="nc bnc" id="L186" title="All 4 branches missed.">        assert Thread.holdsLock(this);</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">        assert insertedMonitors != null;</span>

        // load any new monitors
<span class="nc" id="L190">        getNewMonitors(map);</span>

        // current implementation doesn't support deletion or reuse of entries
<span class="nc" id="L193">        ArrayList removed = EMPTY_LIST;</span>
<span class="nc" id="L194">        ArrayList inserted = insertedMonitors;</span>

<span class="nc" id="L196">        insertedMonitors = new ArrayList&lt;Monitor&gt;();</span>
<span class="nc" id="L197">        return new MonitorStatus(inserted, removed);</span>
    }

    /**
     * Build the pseudo monitors used to map the prolog data into counters.
     */
    protected void buildPseudoMonitors(Map&lt;String, Monitor&gt; map) {
<span class="nc" id="L204">        Monitor monitor = null;</span>
<span class="nc" id="L205">        String name = null;</span>
<span class="nc" id="L206">        IntBuffer ib = null;</span>

<span class="nc" id="L208">        name = PerfDataBufferPrologue.PERFDATA_MAJOR_NAME;</span>
<span class="nc" id="L209">        ib = prologue.majorVersionBuffer();</span>
<span class="nc" id="L210">        monitor = new PerfIntegerMonitor(name, Units.NONE,</span>
                                         Variability.CONSTANT, false, ib);
<span class="nc" id="L212">        map.put(name, monitor);</span>

<span class="nc" id="L214">        name = PerfDataBufferPrologue.PERFDATA_MINOR_NAME;</span>
<span class="nc" id="L215">        ib = prologue.minorVersionBuffer();</span>
<span class="nc" id="L216">        monitor = new PerfIntegerMonitor(name, Units.NONE,</span>
                                         Variability.CONSTANT, false, ib);
<span class="nc" id="L218">        map.put(name, monitor);</span>

<span class="nc" id="L220">        name = PerfDataBufferPrologue.PERFDATA_BUFFER_SIZE_NAME;</span>
<span class="nc" id="L221">        ib = prologue.sizeBuffer();</span>
<span class="nc" id="L222">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L224">        map.put(name, monitor);</span>

<span class="nc" id="L226">        name = PerfDataBufferPrologue.PERFDATA_BUFFER_USED_NAME;</span>
<span class="nc" id="L227">        ib = prologue.usedBuffer();</span>
<span class="nc" id="L228">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L230">        map.put(name, monitor);</span>

<span class="nc" id="L232">        name = PerfDataBufferPrologue.PERFDATA_OVERFLOW_NAME;</span>
<span class="nc" id="L233">        ib = prologue.overflowBuffer();</span>
<span class="nc" id="L234">        monitor = new PerfIntegerMonitor(name, Units.BYTES,</span>
                                         Variability.MONOTONIC, false, ib);
<span class="nc" id="L236">        map.put(name, monitor);</span>
<span class="nc" id="L237">        this.overflow = (IntegerMonitor)monitor;</span>

<span class="nc" id="L239">        name = PerfDataBufferPrologue.PERFDATA_MODTIMESTAMP_NAME;</span>
<span class="nc" id="L240">        LongBuffer lb = prologue.modificationTimeStampBuffer();</span>
<span class="nc" id="L241">        monitor = new PerfLongMonitor(name, Units.TICKS,</span>
                                      Variability.MONOTONIC, false, lb);
<span class="nc" id="L243">        map.put(name, monitor);</span>
<span class="nc" id="L244">    }</span>

    /**
     * Method to provide a gross level of synchronization with the
     * target monitored jvm.
     *
     * gross synchronization works by polling for the hotspot.rt.hrt.ticks
     * counter, which is the last counter created by the StatSampler
     * initialization code. The counter is updated when the watcher thread
     * starts scheduling tasks, which is the last thing done in vm
     * initialization.
     */
    protected void synchWithTarget(Map&lt;String, Monitor&gt; map) throws MonitorException {
        /*
         * synch must happen with syncWaitMs from now. Default is 5 seconds,
         * which is reasonabally generous and should provide for extreme
         * situations like startup delays due to allocation of large ISM heaps.
         */
<span class="nc" id="L262">        long timeLimit = System.currentTimeMillis() + syncWaitMs;</span>

<span class="nc" id="L264">        String name = &quot;hotspot.rt.hrt.ticks&quot;;</span>
<span class="nc" id="L265">        LongMonitor ticks = (LongMonitor)pollFor(map, name, timeLimit);</span>

        /*
         * loop waiting for the ticks counter to be non zero. This is
         * an indication that the jvm is initialized.
         */
<span class="nc" id="L271">        log(&quot;synchWithTarget: &quot; + lvmid + &quot; &quot;);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        while (ticks.longValue() == 0) {</span>
<span class="nc" id="L273">            log(&quot;.&quot;);</span>

<span class="nc" id="L275">            try { Thread.sleep(20); } catch (InterruptedException e) { }</span>

<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (System.currentTimeMillis() &gt; timeLimit) {</span>
<span class="nc" id="L278">                lognl(&quot;failed: &quot; + lvmid);</span>
<span class="nc" id="L279">                throw new MonitorException(&quot;Could Not Synchronize with target&quot;);</span>
            }
        }
<span class="nc" id="L282">        lognl(&quot;success: &quot; + lvmid);</span>
<span class="nc" id="L283">    }</span>

    /**
     * Method to poll the instrumentation memory for a counter with
     * the given name. The polling period is bounded by the timeLimit
     * argument.
     */
    protected Monitor pollFor(Map&lt;String, Monitor&gt; map, String name, long timeLimit)
                      throws MonitorException {
<span class="nc" id="L292">        Monitor monitor = null;</span>

<span class="nc" id="L294">        log(&quot;polling for: &quot; + lvmid + &quot;,&quot; + name + &quot; &quot;);</span>

<span class="nc" id="L296">        pollForEntry = nextEntry;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        while ((monitor = map.get(name)) == null) {</span>
<span class="nc" id="L298">            log(&quot;.&quot;);</span>

<span class="nc" id="L300">            try { Thread.sleep(20); } catch (InterruptedException e) { }</span>

<span class="nc" id="L302">            long t = System.currentTimeMillis();</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">            if ((t &gt; timeLimit) || (overflow.intValue() &gt; 0)) {</span>
<span class="nc" id="L304">                lognl(&quot;failed: &quot; + lvmid + &quot;,&quot; + name);</span>
<span class="nc" id="L305">                dumpAll(map, lvmid);</span>
<span class="nc" id="L306">                throw new MonitorException(&quot;Could not find expected counter&quot;);</span>
            }

<span class="nc" id="L309">            getNewMonitors(map);</span>
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">        lognl(&quot;success: &quot; + lvmid + &quot;,&quot; + name);</span>
<span class="nc" id="L312">        return monitor;</span>
    }

    /**
     * method to make adjustments for known counter problems. This
     * method depends on the availability of certain counters, which
     * is generally guaranteed by the synchWithTarget() method.
     */
    protected void kludge(Map&lt;String, Monitor&gt; map) {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (Boolean.getBoolean(&quot;sun.jvmstat.perfdata.disableKludge&quot;)) {</span>
            // bypass all kludges
<span class="nc" id="L323">            return;</span>
        }

<span class="nc" id="L326">        String name = &quot;java.vm.version&quot;;</span>
<span class="nc" id="L327">        StringMonitor jvm_version = (StringMonitor)map.get(name);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (jvm_version == null) {</span>
<span class="nc" id="L329">            jvm_version = (StringMonitor)findByAlias(name);</span>
        }

<span class="nc" id="L332">        name = &quot;java.vm.name&quot;;</span>
<span class="nc" id="L333">        StringMonitor jvm_name = (StringMonitor)map.get(name);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (jvm_name == null) {</span>
<span class="nc" id="L335">            jvm_name = (StringMonitor)findByAlias(name);</span>
        }

<span class="nc" id="L338">        name = &quot;hotspot.vm.args&quot;;</span>
<span class="nc" id="L339">        StringMonitor args = (StringMonitor)map.get(name);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (args == null) {</span>
<span class="nc" id="L341">            args = (StringMonitor)findByAlias(name);</span>
        }

<span class="nc bnc" id="L344" title="All 8 branches missed.">        assert ((jvm_name != null) &amp;&amp; (jvm_version != null) &amp;&amp; (args != null));</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (jvm_name.stringValue().indexOf(&quot;HotSpot&quot;) &gt;= 0) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (jvm_version.stringValue().startsWith(&quot;1.4.2&quot;)) {</span>
<span class="nc" id="L348">                kludgeMantis(map, args);</span>
            }
        }
<span class="nc" id="L351">    }</span>

    /**
     * method to repair the 1.4.2 parallel scavenge counters that are
     * incorrectly initialized by the JVM when UseAdaptiveSizePolicy
     * is set. This bug couldn't be fixed for 1.4.2 FCS due to putback
     * restrictions.
     */
    private void kludgeMantis(Map&lt;String, Monitor&gt; map, StringMonitor args) {
        /*
         * the HotSpot 1.4.2 JVM with the +UseParallelGC option along
         * with its default +UseAdaptiveSizePolicy option has a bug with
         * the initialization of the sizes of the eden and survivor spaces.
         * See bugid 4890736.
         *
         * note - use explicit 1.4.2 counter names here - don't update
         * to latest counter names or attempt to find aliases.
         */

<span class="nc" id="L370">        String cname = &quot;hotspot.gc.collector.0.name&quot;;</span>
<span class="nc" id="L371">        StringMonitor collector = (StringMonitor)map.get(cname);</span>

<span class="nc bnc" id="L373" title="All 2 branches missed.">        if (collector.stringValue().compareTo(&quot;PSScavenge&quot;) == 0) {</span>
<span class="nc" id="L374">            boolean adaptiveSizePolicy = true;</span>

            /*
             * HotSpot processes the -XX:Flags/.hotspotrc arguments prior to
             * processing the command line arguments. This allows the command
             * line arguments to override any defaults set in .hotspotrc
             */
<span class="nc" id="L381">            cname = &quot;hotspot.vm.flags&quot;;</span>
<span class="nc" id="L382">            StringMonitor flags = (StringMonitor)map.get(cname);</span>
<span class="nc" id="L383">            String allArgs = flags.stringValue() + &quot; &quot; + args.stringValue();</span>

            /*
             * ignore the -XX: prefix as it only applies to the arguments
             * passed from the command line (i.e. the invocation api).
             * arguments passed through .hotspotrc omit the -XX: prefix.
             */
<span class="nc" id="L390">            int ahi = allArgs.lastIndexOf(&quot;+AggressiveHeap&quot;);</span>
<span class="nc" id="L391">            int aspi = allArgs.lastIndexOf(&quot;-UseAdaptiveSizePolicy&quot;);</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (ahi != -1) {</span>
                /*
                 * +AggressiveHeap was set, check if -UseAdaptiveSizePolicy
                 * is set after +AggressiveHeap.
                 */
                //
<span class="nc bnc" id="L399" title="All 4 branches missed.">                if ((aspi != -1) &amp;&amp; (aspi &gt; ahi)) {</span>
<span class="nc" id="L400">                    adaptiveSizePolicy = false;</span>
                }
            } else {
                /*
                 * +AggressiveHeap not set, must be +UseParallelGC. The
                 * relative position of -UseAdaptiveSizePolicy is not
                 * important in this case, as it will override the
                 * UseParallelGC default (+UseAdaptiveSizePolicy) if it
                 * appears anywhere in the JVM arguments.
                 */
<span class="nc bnc" id="L410" title="All 2 branches missed.">                if (aspi != -1) {</span>
<span class="nc" id="L411">                    adaptiveSizePolicy = false;</span>
                }
            }

<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (adaptiveSizePolicy) {</span>
                // adjust the buggy AdaptiveSizePolicy size counters.

                // first remove the real counters.
<span class="nc" id="L419">                String eden_size = &quot;hotspot.gc.generation.0.space.0.size&quot;;</span>
<span class="nc" id="L420">                String s0_size = &quot;hotspot.gc.generation.0.space.1.size&quot;;</span>
<span class="nc" id="L421">                String s1_size = &quot;hotspot.gc.generation.0.space.2.size&quot;;</span>
<span class="nc" id="L422">                map.remove(eden_size);</span>
<span class="nc" id="L423">                map.remove(s0_size);</span>
<span class="nc" id="L424">                map.remove(s1_size);</span>

                // get the maximum new generation size
<span class="nc" id="L427">                String new_max_name = &quot;hotspot.gc.generation.0.capacity.max&quot;;</span>
<span class="nc" id="L428">                LongMonitor new_max = (LongMonitor)map.get(new_max_name);</span>

                /*
                 * replace the real counters with pseudo counters that are
                 * initialized to to the correct values. The maximum size of
                 * the eden and survivor spaces are supposed to be:
                 *    max_eden_size = new_size - (2*alignment).
                 *    max_survivor_size = new_size - (2*alignment).
                 * since we don't know the alignment value used, and because
                 * of other parallel scavenge bugs that result in oversized
                 * spaces, we just set the maximum size of each space to the
                 * full new gen size.
                 */
<span class="nc" id="L441">                Monitor monitor = null;</span>

<span class="nc" id="L443">                LongBuffer lb = LongBuffer.allocate(1);</span>
<span class="nc" id="L444">                lb.put(new_max.longValue());</span>
<span class="nc" id="L445">                monitor = new PerfLongMonitor(eden_size, Units.BYTES,</span>
                                              Variability.CONSTANT, false, lb);
<span class="nc" id="L447">                map.put(eden_size, monitor);</span>

<span class="nc" id="L449">                monitor = new PerfLongMonitor(s0_size, Units.BYTES,</span>
                                              Variability.CONSTANT, false, lb);
<span class="nc" id="L451">                map.put(s0_size, monitor);</span>

<span class="nc" id="L453">                monitor = new PerfLongMonitor(s1_size, Units.BYTES,</span>
                                              Variability.CONSTANT, false, lb);
<span class="nc" id="L455">                map.put(s1_size, monitor);</span>
            }
        }
<span class="nc" id="L458">    }</span>

    /**
     * method to extract the next monitor entry from the instrumentation memory.
     * assumes that nextEntry is the offset into the byte array
     * at which to start the search for the next entry. method leaves
     * next entry pointing to the next entry or to the end of data.
     */
    protected Monitor getNextMonitorEntry() throws MonitorException {
<span class="nc" id="L467">        Monitor monitor = null;</span>

        // entries are always 4 byte aligned.
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if ((nextEntry % 4) != 0) {</span>
<span class="nc" id="L471">            throw new MonitorStructureException(</span>
                   &quot;Entry index not properly aligned: &quot; + nextEntry);
        }

        // protect against a corrupted shared memory region.
<span class="nc bnc" id="L476" title="All 4 branches missed.">        if ((nextEntry &lt; 0) || (nextEntry &gt; buffer.limit())) {</span>
<span class="nc" id="L477">            throw new MonitorStructureException(</span>
                   &quot;Entry index out of bounds: nextEntry = &quot; + nextEntry
<span class="nc" id="L479">                   + &quot;, limit = &quot; + buffer.limit());</span>
        }

        // check for the end of the buffer
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (nextEntry == buffer.limit()) {</span>
<span class="nc" id="L484">            lognl(&quot;getNextMonitorEntry():&quot;</span>
                  + &quot; nextEntry == buffer.limit(): returning&quot;);
<span class="nc" id="L486">            return null;</span>
        }

<span class="nc" id="L489">        buffer.position(nextEntry);</span>

<span class="nc" id="L491">        int entryStart = buffer.position();</span>
<span class="nc" id="L492">        int entryLength = buffer.getInt();</span>

        // check for valid entry length
<span class="nc bnc" id="L495" title="All 4 branches missed.">        if ((entryLength &lt; 0) || (entryLength &gt; buffer.limit())) {</span>
<span class="nc" id="L496">            throw new MonitorStructureException(</span>
                   &quot;Invalid entry length: entryLength = &quot; + entryLength);
        }

        // check if last entry occurs before the eof.
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if ((entryStart + entryLength) &gt; buffer.limit()) {</span>
<span class="nc" id="L502">            throw new MonitorStructureException(</span>
                   &quot;Entry extends beyond end of buffer: &quot;
                   + &quot; entryStart = &quot; + entryStart
                   + &quot; entryLength = &quot; + entryLength
<span class="nc" id="L506">                   + &quot; buffer limit = &quot; + buffer.limit());</span>
        }

<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (entryLength == 0) {</span>
            // end of data
<span class="nc" id="L511">            return null;</span>
        }

<span class="nc" id="L514">        int nameLength = buffer.getInt();</span>
<span class="nc" id="L515">        int vectorLength = buffer.getInt();</span>
<span class="nc" id="L516">        byte dataType = buffer.get();</span>
<span class="nc" id="L517">        byte flags = buffer.get();</span>
<span class="nc" id="L518">        Units u = Units.toUnits(buffer.get());</span>
<span class="nc" id="L519">        Variability v = Variability.toVariability(buffer.get());</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        boolean supported = (flags &amp; 0x01) != 0;</span>

        // defend against corrupt entries
<span class="nc bnc" id="L523" title="All 4 branches missed.">        if ((nameLength &lt;= 0) || (nameLength &gt; entryLength)) {</span>
<span class="nc" id="L524">            throw new MonitorStructureException(</span>
                   &quot;Invalid Monitor name length: &quot; + nameLength);
        }

<span class="nc bnc" id="L528" title="All 4 branches missed.">        if ((vectorLength &lt; 0) || (vectorLength &gt; entryLength)) {</span>
<span class="nc" id="L529">            throw new MonitorStructureException(</span>
                   &quot;Invalid Monitor vector length: &quot; + vectorLength);
        }

        // read in the perfData item name, casting bytes to chars. skip the
        // null terminator
        //
<span class="nc" id="L536">        byte[] nameBytes = new byte[nameLength-1];</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (int i = 0; i &lt; nameLength-1; i++) {</span>
<span class="nc" id="L538">            nameBytes[i] = buffer.get();</span>
        }

        // convert name into a String
<span class="nc" id="L542">        String name = new String(nameBytes, 0, nameLength-1);</span>

<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (v == Variability.INVALID) {</span>
<span class="nc" id="L545">            throw new MonitorDataException(&quot;Invalid variability attribute:&quot;</span>
                                           + &quot; entry index = &quot; + perfDataItem
                                           + &quot; name = &quot; + name);
        }
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (u == Units.INVALID) {</span>
<span class="nc" id="L550">            throw new MonitorDataException(&quot;Invalid units attribute: &quot;</span>
                                           + &quot; entry index = &quot; + perfDataItem
                                           + &quot; name = &quot; + name);
        }

        int offset;
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (vectorLength == 0) {</span>
            // scalar Types
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (dataType == BasicType.LONG.intValue()) {</span>
<span class="nc" id="L559">                offset = entryStart + entryLength - 8;  /* 8 = sizeof(long) */</span>
<span class="nc" id="L560">                buffer.position(offset);</span>
<span class="nc" id="L561">                LongBuffer lb = buffer.asLongBuffer();</span>
<span class="nc" id="L562">                lb.limit(1);</span>
<span class="nc" id="L563">                monitor = new PerfLongMonitor(name, u, v, supported, lb);</span>
<span class="nc" id="L564">                perfDataItem++;</span>
<span class="nc" id="L565">            } else {</span>
                // bad data types.
<span class="nc" id="L567">                throw new MonitorTypeException(&quot;Invalid Monitor type:&quot;</span>
                                    + &quot; entry index = &quot; + perfDataItem
                                    + &quot; name = &quot; + name
                                    + &quot; type = &quot; + dataType);
            }
        } else {
            // vector types
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (dataType == BasicType.BYTE.intValue()) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                if (u != Units.STRING) {</span>
                    // only byte arrays of type STRING are currently supported
<span class="nc" id="L577">                    throw new MonitorTypeException(&quot;Invalid Monitor type:&quot;</span>
                                      + &quot; entry index = &quot; + perfDataItem
                                      + &quot; name = &quot; + name
                                      + &quot; type = &quot; + dataType);
                }

<span class="nc" id="L583">                offset = entryStart + PERFDATA_NAME_OFFSET + nameLength;</span>
<span class="nc" id="L584">                buffer.position(offset);</span>
<span class="nc" id="L585">                ByteBuffer bb = buffer.slice();</span>
<span class="nc" id="L586">                bb.limit(vectorLength);</span>
<span class="nc" id="L587">                bb.position(0);</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (v == Variability.CONSTANT) {</span>
<span class="nc" id="L590">                    monitor = new PerfStringConstantMonitor(name, supported,</span>
                                                            bb);
<span class="nc bnc" id="L592" title="All 2 branches missed.">                } else if (v == Variability.VARIABLE) {</span>
<span class="nc" id="L593">                    monitor = new PerfStringVariableMonitor(name, supported,</span>
                                                            bb, vectorLength-1);
                } else {
                    // Monotonically increasing byte arrays are not supported
<span class="nc" id="L597">                    throw new MonitorDataException(</span>
                            &quot;Invalid variability attribute:&quot;
                            + &quot; entry index = &quot; + perfDataItem
                            + &quot; name = &quot; + name
                            + &quot; variability = &quot; + v);
                }
<span class="nc" id="L603">                perfDataItem++;</span>
<span class="nc" id="L604">            } else {</span>
                // bad data types.
<span class="nc" id="L606">                throw new MonitorTypeException(</span>
                        &quot;Invalid Monitor type:&quot; + &quot; entry index = &quot;
                        + perfDataItem + &quot; name = &quot; + name
                        + &quot; type = &quot; + dataType);
            }
        }

        // setup index to next entry for next iteration of the loop.
<span class="nc" id="L614">        nextEntry = entryStart + entryLength;</span>
<span class="nc" id="L615">        return monitor;</span>
    }

    /**
     * Method to dump debugging information
     */
    private void dumpAll(Map map, int lvmid) {
        if (DEBUG) {
            Set keys = map.keySet();

            System.err.println(&quot;Dump for &quot; + lvmid);
            int j = 0;
            for (Iterator i = keys.iterator(); i.hasNext(); j++) {
                Monitor monitor = (Monitor)map.get(i.next());
                System.err.println(j + &quot;\t&quot; + monitor.getName()
                                   + &quot;=&quot; + monitor.getValue());
            }
            System.err.println(&quot;nextEntry = &quot; + nextEntry
                               + &quot; pollForEntry = &quot; + pollForEntry);
            System.err.println(&quot;Buffer info:&quot;);
            System.err.println(&quot;buffer = &quot; + buffer);
        }
<span class="nc" id="L637">    }</span>

    private void lognl(String s) {
        if (DEBUG) {
            System.err.println(s);
        }
<span class="nc" id="L643">    }</span>

    private void log(String s) {
        if (DEBUG) {
            System.err.print(s);
        }
<span class="nc" id="L649">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>