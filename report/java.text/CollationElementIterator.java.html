<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CollationElementIterator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">CollationElementIterator.java</span></div><h1>CollationElementIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.lang.Character;
import java.util.Vector;
import sun.text.CollatorUtilities;
import sun.text.normalizer.NormalizerBase;

/**
 * The &lt;code&gt;CollationElementIterator&lt;/code&gt; class is used as an iterator
 * to walk through each character of an international string. Use the iterator
 * to return the ordering priority of the positioned character. The ordering
 * priority of a character, which we refer to as a key, defines how a character
 * is collated in the given collation object.
 *
 * &lt;p&gt;
 * For example, consider the following in Spanish:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * &quot;ca&quot; &amp;rarr; the first key is key('c') and second key is key('a').
 * &quot;cha&quot; &amp;rarr; the first key is key('ch') and second key is key('a').
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * And in German,
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * &quot;\u00e4b&quot; &amp;rarr; the first key is key('a'), the second key is key('e'), and
 * the third key is key('b').
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * The key of a character is an integer composed of primary order(short),
 * secondary order(byte), and tertiary order(byte). Java strictly defines
 * the size and signedness of its primitive data types. Therefore, the static
 * functions &lt;code&gt;primaryOrder&lt;/code&gt;, &lt;code&gt;secondaryOrder&lt;/code&gt;, and
 * &lt;code&gt;tertiaryOrder&lt;/code&gt; return &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;,
 * and &lt;code&gt;short&lt;/code&gt; respectively to ensure the correctness of the key
 * value.
 *
 * &lt;p&gt;
 * Example of the iterator usage,
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 *
 *  String testString = &quot;This is a test&quot;;
 *  Collator col = Collator.getInstance();
 *  if (col instanceof RuleBasedCollator) {
 *      RuleBasedCollator ruleBasedCollator = (RuleBasedCollator)col;
 *      CollationElementIterator collationElementIterator = ruleBasedCollator.getCollationElementIterator(testString);
 *      int primaryOrder = CollationElementIterator.primaryOrder(collationElementIterator.next());
 *          :
 *  }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * &lt;code&gt;CollationElementIterator.next&lt;/code&gt; returns the collation order
 * of the next character. A collation order consists of primary order,
 * secondary order and tertiary order. The data type of the collation
 * order is &lt;strong&gt;int&lt;/strong&gt;. The first 16 bits of a collation order
 * is its primary order; the next 8 bits is the secondary order and the
 * last 8 bits is the tertiary order.
 *
 * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;CollationElementIterator&lt;/code&gt; is a part of
 * &lt;code&gt;RuleBasedCollator&lt;/code&gt; implementation. It is only usable
 * with &lt;code&gt;RuleBasedCollator&lt;/code&gt; instances.
 *
 * @see                Collator
 * @see                RuleBasedCollator
 * @author             Helena Shih, Laura Werner, Richard Gillam
 */
public final class CollationElementIterator
{
    /**
     * Null order which indicates the end of string is reached by the
     * cursor.
     */
    public final static int NULLORDER = 0xffffffff;

    /**
     * CollationElementIterator constructor.  This takes the source string and
     * the collation object.  The cursor will walk thru the source string based
     * on the predefined collation rules.  If the source string is empty,
     * NULLORDER will be returned on the calls to next().
     * @param sourceText the source string.
     * @param owner the collation object.
     */
<span class="nc" id="L124">    CollationElementIterator(String sourceText, RuleBasedCollator owner) {</span>
<span class="nc" id="L125">        this.owner = owner;</span>
<span class="nc" id="L126">        ordering = owner.getTables();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if ( sourceText.length() != 0 ) {</span>
<span class="nc" id="L128">            NormalizerBase.Mode mode =</span>
<span class="nc" id="L129">                CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc" id="L130">            text = new NormalizerBase(sourceText, mode);</span>
        }
<span class="nc" id="L132">    }</span>

    /**
     * CollationElementIterator constructor.  This takes the source string and
     * the collation object.  The cursor will walk thru the source string based
     * on the predefined collation rules.  If the source string is empty,
     * NULLORDER will be returned on the calls to next().
     * @param sourceText the source string.
     * @param owner the collation object.
     */
<span class="nc" id="L142">    CollationElementIterator(CharacterIterator sourceText, RuleBasedCollator owner) {</span>
<span class="nc" id="L143">        this.owner = owner;</span>
<span class="nc" id="L144">        ordering = owner.getTables();</span>
<span class="nc" id="L145">        NormalizerBase.Mode mode =</span>
<span class="nc" id="L146">            CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc" id="L147">        text = new NormalizerBase(sourceText, mode);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Resets the cursor to the beginning of the string.  The next call
     * to next() will return the first collation element in the string.
     */
    public void reset()
    {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L157">            text.reset();</span>
<span class="nc" id="L158">            NormalizerBase.Mode mode =</span>
<span class="nc" id="L159">                CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc" id="L160">            text.setMode(mode);</span>
        }
<span class="nc" id="L162">        buffer = null;</span>
<span class="nc" id="L163">        expIndex = 0;</span>
<span class="nc" id="L164">        swapOrder = 0;</span>
<span class="nc" id="L165">    }</span>

    /**
     * Get the next collation element in the string.  &lt;p&gt;This iterator iterates
     * over a sequence of collation elements that were built from the string.
     * Because there isn't necessarily a one-to-one mapping from characters to
     * collation elements, this doesn't mean the same thing as &quot;return the
     * collation element [or ordering priority] of the next character in the
     * string&quot;.&lt;/p&gt;
     * &lt;p&gt;This function returns the collation element that the iterator is currently
     * pointing to and then updates the internal pointer to point to the next element.
     * previous() updates the pointer first and then returns the element.  This
     * means that when you change direction while iterating (i.e., call next() and
     * then call previous(), or call previous() and then call next()), you'll get
     * back the same element twice.&lt;/p&gt;
     *
     * @return the next collation element
     */
    public int next()
    {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L186">            return NULLORDER;</span>
        }
<span class="nc" id="L188">        NormalizerBase.Mode textMode = text.getMode();</span>
        // convert the owner's mode to something the Normalizer understands
<span class="nc" id="L190">        NormalizerBase.Mode ownerMode =</span>
<span class="nc" id="L191">            CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (textMode != ownerMode) {</span>
<span class="nc" id="L193">            text.setMode(ownerMode);</span>
        }

        // if buffer contains any decomposed char values
        // return their strength orders before continuing in
        // the Normalizer's CharacterIterator.
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (buffer != null) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (expIndex &lt; buffer.length) {</span>
<span class="nc" id="L201">                return strengthOrder(buffer[expIndex++]);</span>
            } else {
<span class="nc" id="L203">                buffer = null;</span>
<span class="nc" id="L204">                expIndex = 0;</span>
            }
<span class="nc bnc" id="L206" title="All 2 branches missed.">        } else if (swapOrder != 0) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (Character.isSupplementaryCodePoint(swapOrder)) {</span>
<span class="nc" id="L208">                char[] chars = Character.toChars(swapOrder);</span>
<span class="nc" id="L209">                swapOrder = chars[1];</span>
<span class="nc" id="L210">                return chars[0] &lt;&lt; 16;</span>
            }
<span class="nc" id="L212">            int order = swapOrder &lt;&lt; 16;</span>
<span class="nc" id="L213">            swapOrder = 0;</span>
<span class="nc" id="L214">            return order;</span>
        }
<span class="nc" id="L216">        int ch  = text.next();</span>

        // are we at the end of Normalizer's text?
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (ch == NormalizerBase.DONE) {</span>
<span class="nc" id="L220">            return NULLORDER;</span>
        }

<span class="nc" id="L223">        int value = ordering.getUnicodeOrder(ch);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (value == RuleBasedCollator.UNMAPPED) {</span>
<span class="nc" id="L225">            swapOrder = ch;</span>
<span class="nc" id="L226">            return UNMAPPEDCHARVALUE;</span>
        }
<span class="nc bnc" id="L228" title="All 2 branches missed.">        else if (value &gt;= RuleBasedCollator.CONTRACTCHARINDEX) {</span>
<span class="nc" id="L229">            value = nextContractChar(ch);</span>
        }
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (value &gt;= RuleBasedCollator.EXPANDCHARINDEX) {</span>
<span class="nc" id="L232">            buffer = ordering.getExpandValueList(value);</span>
<span class="nc" id="L233">            expIndex = 0;</span>
<span class="nc" id="L234">            value = buffer[expIndex++];</span>
        }

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (ordering.isSEAsianSwapping()) {</span>
            int consonant;
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (isThaiPreVowel(ch)) {</span>
<span class="nc" id="L240">                consonant = text.next();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                if (isThaiBaseConsonant(consonant)) {</span>
<span class="nc" id="L242">                    buffer = makeReorderedBuffer(consonant, value, buffer, true);</span>
<span class="nc" id="L243">                    value = buffer[0];</span>
<span class="nc" id="L244">                    expIndex = 1;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                } else if (consonant != NormalizerBase.DONE) {</span>
<span class="nc" id="L246">                    text.previous();</span>
                }
            }
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (isLaoPreVowel(ch)) {</span>
<span class="nc" id="L250">                consonant = text.next();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">                if (isLaoBaseConsonant(consonant)) {</span>
<span class="nc" id="L252">                    buffer = makeReorderedBuffer(consonant, value, buffer, true);</span>
<span class="nc" id="L253">                    value = buffer[0];</span>
<span class="nc" id="L254">                    expIndex = 1;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                } else if (consonant != NormalizerBase.DONE) {</span>
<span class="nc" id="L256">                    text.previous();</span>
                }
            }
        }

<span class="nc" id="L261">        return strengthOrder(value);</span>
    }

    /**
     * Get the previous collation element in the string.  &lt;p&gt;This iterator iterates
     * over a sequence of collation elements that were built from the string.
     * Because there isn't necessarily a one-to-one mapping from characters to
     * collation elements, this doesn't mean the same thing as &quot;return the
     * collation element [or ordering priority] of the previous character in the
     * string&quot;.&lt;/p&gt;
     * &lt;p&gt;This function updates the iterator's internal pointer to point to the
     * collation element preceding the one it's currently pointing to and then
     * returns that element, while next() returns the current element and then
     * updates the pointer.  This means that when you change direction while
     * iterating (i.e., call next() and then call previous(), or call previous()
     * and then call next()), you'll get back the same element twice.&lt;/p&gt;
     *
     * @return the previous collation element
     * @since 1.2
     */
    public int previous()
    {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L284">            return NULLORDER;</span>
        }
<span class="nc" id="L286">        NormalizerBase.Mode textMode = text.getMode();</span>
        // convert the owner's mode to something the Normalizer understands
<span class="nc" id="L288">        NormalizerBase.Mode ownerMode =</span>
<span class="nc" id="L289">            CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (textMode != ownerMode) {</span>
<span class="nc" id="L291">            text.setMode(ownerMode);</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (buffer != null) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (expIndex &gt; 0) {</span>
<span class="nc" id="L295">                return strengthOrder(buffer[--expIndex]);</span>
            } else {
<span class="nc" id="L297">                buffer = null;</span>
<span class="nc" id="L298">                expIndex = 0;</span>
            }
<span class="nc bnc" id="L300" title="All 2 branches missed.">        } else if (swapOrder != 0) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (Character.isSupplementaryCodePoint(swapOrder)) {</span>
<span class="nc" id="L302">                char[] chars = Character.toChars(swapOrder);</span>
<span class="nc" id="L303">                swapOrder = chars[1];</span>
<span class="nc" id="L304">                return chars[0] &lt;&lt; 16;</span>
            }
<span class="nc" id="L306">            int order = swapOrder &lt;&lt; 16;</span>
<span class="nc" id="L307">            swapOrder = 0;</span>
<span class="nc" id="L308">            return order;</span>
        }
<span class="nc" id="L310">        int ch = text.previous();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (ch == NormalizerBase.DONE) {</span>
<span class="nc" id="L312">            return NULLORDER;</span>
        }

<span class="nc" id="L315">        int value = ordering.getUnicodeOrder(ch);</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (value == RuleBasedCollator.UNMAPPED) {</span>
<span class="nc" id="L318">            swapOrder = UNMAPPEDCHARVALUE;</span>
<span class="nc" id="L319">            return ch;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        } else if (value &gt;= RuleBasedCollator.CONTRACTCHARINDEX) {</span>
<span class="nc" id="L321">            value = prevContractChar(ch);</span>
        }
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (value &gt;= RuleBasedCollator.EXPANDCHARINDEX) {</span>
<span class="nc" id="L324">            buffer = ordering.getExpandValueList(value);</span>
<span class="nc" id="L325">            expIndex = buffer.length;</span>
<span class="nc" id="L326">            value = buffer[--expIndex];</span>
        }

<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (ordering.isSEAsianSwapping()) {</span>
            int vowel;
<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (isThaiBaseConsonant(ch)) {</span>
<span class="nc" id="L332">                vowel = text.previous();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (isThaiPreVowel(vowel)) {</span>
<span class="nc" id="L334">                    buffer = makeReorderedBuffer(vowel, value, buffer, false);</span>
<span class="nc" id="L335">                    expIndex = buffer.length - 1;</span>
<span class="nc" id="L336">                    value = buffer[expIndex];</span>
                } else {
<span class="nc" id="L338">                    text.next();</span>
                }
            }
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (isLaoBaseConsonant(ch)) {</span>
<span class="nc" id="L342">                vowel = text.previous();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (isLaoPreVowel(vowel)) {</span>
<span class="nc" id="L344">                    buffer = makeReorderedBuffer(vowel, value, buffer, false);</span>
<span class="nc" id="L345">                    expIndex = buffer.length - 1;</span>
<span class="nc" id="L346">                    value = buffer[expIndex];</span>
                } else {
<span class="nc" id="L348">                    text.next();</span>
                }
            }
        }

<span class="nc" id="L353">        return strengthOrder(value);</span>
    }

    /**
     * Return the primary component of a collation element.
     * @param order the collation element
     * @return the element's primary component
     */
    public final static int primaryOrder(int order)
    {
<span class="nc" id="L363">        order &amp;= RBCollationTables.PRIMARYORDERMASK;</span>
<span class="nc" id="L364">        return (order &gt;&gt;&gt; RBCollationTables.PRIMARYORDERSHIFT);</span>
    }
    /**
     * Return the secondary component of a collation element.
     * @param order the collation element
     * @return the element's secondary component
     */
    public final static short secondaryOrder(int order)
    {
<span class="nc" id="L373">        order = order &amp; RBCollationTables.SECONDARYORDERMASK;</span>
<span class="nc" id="L374">        return ((short)(order &gt;&gt; RBCollationTables.SECONDARYORDERSHIFT));</span>
    }
    /**
     * Return the tertiary component of a collation element.
     * @param order the collation element
     * @return the element's tertiary component
     */
    public final static short tertiaryOrder(int order)
    {
<span class="nc" id="L383">        return ((short)(order &amp;= RBCollationTables.TERTIARYORDERMASK));</span>
    }

    /**
     *  Get the comparison order in the desired strength.  Ignore the other
     *  differences.
     *  @param order The order value
     */
    final int strengthOrder(int order)
    {
<span class="nc" id="L393">        int s = owner.getStrength();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (s == Collator.PRIMARY)</span>
        {
<span class="nc" id="L396">            order &amp;= RBCollationTables.PRIMARYDIFFERENCEONLY;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">        } else if (s == Collator.SECONDARY)</span>
        {
<span class="nc" id="L399">            order &amp;= RBCollationTables.SECONDARYDIFFERENCEONLY;</span>
        }
<span class="nc" id="L401">        return order;</span>
    }

    /**
     * Sets the iterator to point to the collation element corresponding to
     * the specified character (the parameter is a CHARACTER offset in the
     * original string, not an offset into its corresponding sequence of
     * collation elements).  The value returned by the next call to next()
     * will be the collation element corresponding to the specified position
     * in the text.  If that position is in the middle of a contracting
     * character sequence, the result of the next call to next() is the
     * collation element for that sequence.  This means that getOffset()
     * is not guaranteed to return the same value as was passed to a preceding
     * call to setOffset().
     *
     * @param newOffset The new character offset into the original text.
     * @since 1.2
     */
    @SuppressWarnings(&quot;deprecation&quot;) // getBeginIndex, getEndIndex and setIndex are deprecated
    public void setOffset(int newOffset)
    {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (newOffset &lt; text.getBeginIndex()</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                || newOffset &gt;= text.getEndIndex()) {</span>
<span class="nc" id="L425">                    text.setIndexOnly(newOffset);</span>
            } else {
<span class="nc" id="L427">                int c = text.setIndex(newOffset);</span>

                // if the desired character isn't used in a contracting character
                // sequence, bypass all the backing-up logic-- we're sitting on
                // the right character already
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (ordering.usedInContractSeq(c)) {</span>
                    // walk backwards through the string until we see a character
                    // that DOESN'T participate in a contracting character sequence
<span class="nc bnc" id="L435" title="All 2 branches missed.">                    while (ordering.usedInContractSeq(c)) {</span>
<span class="nc" id="L436">                        c = text.previous();</span>
                    }
                    // now walk forward using this object's next() method until
                    // we pass the starting point and set our current position
                    // to the beginning of the last &quot;character&quot; before or at
                    // our starting position
<span class="nc" id="L442">                    int last = text.getIndex();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    while (text.getIndex() &lt;= newOffset) {</span>
<span class="nc" id="L444">                        last = text.getIndex();</span>
<span class="nc" id="L445">                        next();</span>
                    }
<span class="nc" id="L447">                    text.setIndexOnly(last);</span>
                    // we don't need this, since last is the last index
                    // that is the starting of the contraction which encompass
                    // newOffset
                    // text.previous();
                }
            }
        }
<span class="nc" id="L455">        buffer = null;</span>
<span class="nc" id="L456">        expIndex = 0;</span>
<span class="nc" id="L457">        swapOrder = 0;</span>
<span class="nc" id="L458">    }</span>

    /**
     * Returns the character offset in the original text corresponding to the next
     * collation element.  (That is, getOffset() returns the position in the text
     * corresponding to the collation element that will be returned by the next
     * call to next().)  This value will always be the index of the FIRST character
     * corresponding to the collation element (a contracting character sequence is
     * when two or more characters all correspond to the same collation element).
     * This means if you do setOffset(x) followed immediately by getOffset(), getOffset()
     * won't necessarily return x.
     *
     * @return The character offset in the original text corresponding to the collation
     * element that will be returned by the next call to next().
     * @since 1.2
     */
    public int getOffset()
    {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        return (text != null) ? text.getIndex() : 0;</span>
    }


    /**
     * Return the maximum length of any expansion sequences that end
     * with the specified comparison order.
     * @param order a collation order returned by previous or next.
     * @return the maximum length of any expansion sequences ending
     *         with the specified order.
     * @since 1.2
     */
    public int getMaxExpansion(int order)
    {
<span class="nc" id="L490">        return ordering.getMaxExpansion(order);</span>
    }

    /**
     * Set a new string over which to iterate.
     *
     * @param source  the new source text
     * @since 1.2
     */
    public void setText(String source)
    {
<span class="nc" id="L501">        buffer = null;</span>
<span class="nc" id="L502">        swapOrder = 0;</span>
<span class="nc" id="L503">        expIndex = 0;</span>
<span class="nc" id="L504">        NormalizerBase.Mode mode =</span>
<span class="nc" id="L505">            CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L507">            text = new NormalizerBase(source, mode);</span>
        } else {
<span class="nc" id="L509">            text.setMode(mode);</span>
<span class="nc" id="L510">            text.setText(source);</span>
        }
<span class="nc" id="L512">    }</span>

    /**
     * Set a new string over which to iterate.
     *
     * @param source  the new source text.
     * @since 1.2
     */
    public void setText(CharacterIterator source)
    {
<span class="nc" id="L522">        buffer = null;</span>
<span class="nc" id="L523">        swapOrder = 0;</span>
<span class="nc" id="L524">        expIndex = 0;</span>
<span class="nc" id="L525">        NormalizerBase.Mode mode =</span>
<span class="nc" id="L526">            CollatorUtilities.toNormalizerMode(owner.getDecomposition());</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L528">            text = new NormalizerBase(source, mode);</span>
        } else {
<span class="nc" id="L530">            text.setMode(mode);</span>
<span class="nc" id="L531">            text.setText(source);</span>
        }
<span class="nc" id="L533">    }</span>

    //============================================================
    // privates
    //============================================================

    /**
     * Determine if a character is a Thai vowel (which sorts after
     * its base consonant).
     */
    private final static boolean isThaiPreVowel(int ch) {
<span class="nc bnc" id="L544" title="All 4 branches missed.">        return (ch &gt;= 0x0e40) &amp;&amp; (ch &lt;= 0x0e44);</span>
    }

    /**
     * Determine if a character is a Thai base consonant
     */
    private final static boolean isThaiBaseConsonant(int ch) {
<span class="nc bnc" id="L551" title="All 4 branches missed.">        return (ch &gt;= 0x0e01) &amp;&amp; (ch &lt;= 0x0e2e);</span>
    }

    /**
     * Determine if a character is a Lao vowel (which sorts after
     * its base consonant).
     */
    private final static boolean isLaoPreVowel(int ch) {
<span class="nc bnc" id="L559" title="All 4 branches missed.">        return (ch &gt;= 0x0ec0) &amp;&amp; (ch &lt;= 0x0ec4);</span>
    }

    /**
     * Determine if a character is a Lao base consonant
     */
    private final static boolean isLaoBaseConsonant(int ch) {
<span class="nc bnc" id="L566" title="All 4 branches missed.">        return (ch &gt;= 0x0e81) &amp;&amp; (ch &lt;= 0x0eae);</span>
    }

    /**
     * This method produces a buffer which contains the collation
     * elements for the two characters, with colFirst's values preceding
     * another character's.  Presumably, the other character precedes colFirst
     * in logical order (otherwise you wouldn't need this method would you?).
     * The assumption is that the other char's value(s) have already been
     * computed.  If this char has a single element it is passed to this
     * method as lastValue, and lastExpansion is null.  If it has an
     * expansion it is passed in lastExpansion, and colLastValue is ignored.
     */
    private int[] makeReorderedBuffer(int colFirst,
                                      int lastValue,
                                      int[] lastExpansion,
                                      boolean forward) {

        int[] result;

<span class="nc" id="L586">        int firstValue = ordering.getUnicodeOrder(colFirst);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (firstValue &gt;= RuleBasedCollator.CONTRACTCHARINDEX) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            firstValue = forward? nextContractChar(colFirst) : prevContractChar(colFirst);</span>
        }

<span class="nc" id="L591">        int[] firstExpansion = null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (firstValue &gt;= RuleBasedCollator.EXPANDCHARINDEX) {</span>
<span class="nc" id="L593">            firstExpansion = ordering.getExpandValueList(firstValue);</span>
        }

<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (!forward) {</span>
<span class="nc" id="L597">            int temp1 = firstValue;</span>
<span class="nc" id="L598">            firstValue = lastValue;</span>
<span class="nc" id="L599">            lastValue = temp1;</span>
<span class="nc" id="L600">            int[] temp2 = firstExpansion;</span>
<span class="nc" id="L601">            firstExpansion = lastExpansion;</span>
<span class="nc" id="L602">            lastExpansion = temp2;</span>
        }

<span class="nc bnc" id="L605" title="All 4 branches missed.">        if (firstExpansion == null &amp;&amp; lastExpansion == null) {</span>
<span class="nc" id="L606">            result = new int [2];</span>
<span class="nc" id="L607">            result[0] = firstValue;</span>
<span class="nc" id="L608">            result[1] = lastValue;</span>
        }
        else {
<span class="nc bnc" id="L611" title="All 2 branches missed.">            int firstLength = firstExpansion==null? 1 : firstExpansion.length;</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            int lastLength = lastExpansion==null? 1 : lastExpansion.length;</span>
<span class="nc" id="L613">            result = new int[firstLength + lastLength];</span>

<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (firstExpansion == null) {</span>
<span class="nc" id="L616">                result[0] = firstValue;</span>
            }
            else {
<span class="nc" id="L619">                System.arraycopy(firstExpansion, 0, result, 0, firstLength);</span>
            }

<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (lastExpansion == null) {</span>
<span class="nc" id="L623">                result[firstLength] = lastValue;</span>
            }
            else {
<span class="nc" id="L626">                System.arraycopy(lastExpansion, 0, result, firstLength, lastLength);</span>
            }
        }

<span class="nc" id="L630">        return result;</span>
    }

    /**
     *  Check if a comparison order is ignorable.
     *  @return true if a character is ignorable, false otherwise.
     */
    final static boolean isIgnorable(int order)
    {
<span class="nc bnc" id="L639" title="All 2 branches missed.">        return ((primaryOrder(order) == 0) ? true : false);</span>
    }

    /**
     * Get the ordering priority of the next contracting character in the
     * string.
     * @param ch the starting character of a contracting character token
     * @return the next contracting character's ordering.  Returns NULLORDER
     * if the end of string is reached.
     */
    private int nextContractChar(int ch)
    {
        // First get the ordering of this single character,
        // which is always the first element in the list
<span class="nc" id="L653">        Vector&lt;EntryPair&gt; list = ordering.getContractValues(ch);</span>
<span class="nc" id="L654">        EntryPair pair = list.firstElement();</span>
<span class="nc" id="L655">        int order = pair.value;</span>

        // find out the length of the longest contracting character sequence in the list.
        // There's logic in the builder code to make sure the longest sequence is always
        // the last.
<span class="nc" id="L660">        pair = list.lastElement();</span>
<span class="nc" id="L661">        int maxLength = pair.entryName.length();</span>

        // (the Normalizer is cloned here so that the seeking we do in the next loop
        // won't affect our real position in the text)
<span class="nc" id="L665">        NormalizerBase tempText = (NormalizerBase)text.clone();</span>

        // extract the next maxLength characters in the string (we have to do this using the
        // Normalizer to ensure that our offsets correspond to those the rest of the
        // iterator is using) and store it in &quot;fragment&quot;.
<span class="nc" id="L670">        tempText.previous();</span>
<span class="nc" id="L671">        key.setLength(0);</span>
<span class="nc" id="L672">        int c = tempText.next();</span>
<span class="nc bnc" id="L673" title="All 4 branches missed.">        while (maxLength &gt; 0 &amp;&amp; c != NormalizerBase.DONE) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            if (Character.isSupplementaryCodePoint(c)) {</span>
<span class="nc" id="L675">                key.append(Character.toChars(c));</span>
<span class="nc" id="L676">                maxLength -= 2;</span>
            } else {
<span class="nc" id="L678">                key.append((char)c);</span>
<span class="nc" id="L679">                --maxLength;</span>
            }
<span class="nc" id="L681">            c = tempText.next();</span>
        }
<span class="nc" id="L683">        String fragment = key.toString();</span>
        // now that we have that fragment, iterate through this list looking for the
        // longest sequence that matches the characters in the actual text.  (maxLength
        // is used here to keep track of the length of the longest sequence)
        // Upon exit from this loop, maxLength will contain the length of the matching
        // sequence and order will contain the collation-element value corresponding
        // to this sequence
<span class="nc" id="L690">        maxLength = 1;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        for (int i = list.size() - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L692">            pair = list.elementAt(i);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (!pair.fwd)</span>
<span class="nc" id="L694">                continue;</span>

<span class="nc bnc" id="L696" title="All 4 branches missed.">            if (fragment.startsWith(pair.entryName) &amp;&amp; pair.entryName.length()</span>
                    &gt; maxLength) {
<span class="nc" id="L698">                maxLength = pair.entryName.length();</span>
<span class="nc" id="L699">                order = pair.value;</span>
            }
        }

        // seek our current iteration position to the end of the matching sequence
        // and return the appropriate collation-element value (if there was no matching
        // sequence, we're already seeked to the right position and order already contains
        // the correct collation-element value for the single character)
<span class="nc bnc" id="L707" title="All 2 branches missed.">        while (maxLength &gt; 1) {</span>
<span class="nc" id="L708">            c = text.next();</span>
<span class="nc" id="L709">            maxLength -= Character.charCount(c);</span>
        }
<span class="nc" id="L711">        return order;</span>
    }

    /**
     * Get the ordering priority of the previous contracting character in the
     * string.
     * @param ch the starting character of a contracting character token
     * @return the next contracting character's ordering.  Returns NULLORDER
     * if the end of string is reached.
     */
    private int prevContractChar(int ch)
    {
        // This function is identical to nextContractChar(), except that we've
        // switched things so that the next() and previous() calls on the Normalizer
        // are switched and so that we skip entry pairs with the fwd flag turned on
        // rather than off.  Notice that we still use append() and startsWith() when
        // working on the fragment.  This is because the entry pairs that are used
        // in reverse iteration have their names reversed already.
<span class="nc" id="L729">        Vector&lt;EntryPair&gt; list = ordering.getContractValues(ch);</span>
<span class="nc" id="L730">        EntryPair pair = list.firstElement();</span>
<span class="nc" id="L731">        int order = pair.value;</span>

<span class="nc" id="L733">        pair = list.lastElement();</span>
<span class="nc" id="L734">        int maxLength = pair.entryName.length();</span>

<span class="nc" id="L736">        NormalizerBase tempText = (NormalizerBase)text.clone();</span>

<span class="nc" id="L738">        tempText.next();</span>
<span class="nc" id="L739">        key.setLength(0);</span>
<span class="nc" id="L740">        int c = tempText.previous();</span>
<span class="nc bnc" id="L741" title="All 4 branches missed.">        while (maxLength &gt; 0 &amp;&amp; c != NormalizerBase.DONE) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (Character.isSupplementaryCodePoint(c)) {</span>
<span class="nc" id="L743">                key.append(Character.toChars(c));</span>
<span class="nc" id="L744">                maxLength -= 2;</span>
            } else {
<span class="nc" id="L746">                key.append((char)c);</span>
<span class="nc" id="L747">                --maxLength;</span>
            }
<span class="nc" id="L749">            c = tempText.previous();</span>
        }
<span class="nc" id="L751">        String fragment = key.toString();</span>

<span class="nc" id="L753">        maxLength = 1;</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        for (int i = list.size() - 1; i &gt; 0; i--) {</span>
<span class="nc" id="L755">            pair = list.elementAt(i);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">            if (pair.fwd)</span>
<span class="nc" id="L757">                continue;</span>

<span class="nc bnc" id="L759" title="All 4 branches missed.">            if (fragment.startsWith(pair.entryName) &amp;&amp; pair.entryName.length()</span>
                    &gt; maxLength) {
<span class="nc" id="L761">                maxLength = pair.entryName.length();</span>
<span class="nc" id="L762">                order = pair.value;</span>
            }
        }

<span class="nc bnc" id="L766" title="All 2 branches missed.">        while (maxLength &gt; 1) {</span>
<span class="nc" id="L767">            c = text.previous();</span>
<span class="nc" id="L768">            maxLength -= Character.charCount(c);</span>
        }
<span class="nc" id="L770">        return order;</span>
    }

    final static int UNMAPPEDCHARVALUE = 0x7FFF0000;

<span class="nc" id="L775">    private NormalizerBase text = null;</span>
<span class="nc" id="L776">    private int[] buffer = null;</span>
<span class="nc" id="L777">    private int expIndex = 0;</span>
<span class="nc" id="L778">    private StringBuffer key = new StringBuffer(5);</span>
<span class="nc" id="L779">    private int swapOrder = 0;</span>
    private RBCollationTables ordering;
    private RuleBasedCollator owner;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>