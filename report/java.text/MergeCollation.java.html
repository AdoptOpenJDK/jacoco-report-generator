<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MergeCollation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">MergeCollation.java</span></div><h1>MergeCollation.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996, 1997 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.util.ArrayList;

/**
 * Utility class for normalizing and merging patterns for collation.
 * Patterns are strings of the form &lt;entry&gt;*, where &lt;entry&gt; has the
 * form:
 * &lt;pattern&gt; := &lt;entry&gt;*
 * &lt;entry&gt; := &lt;separator&gt;&lt;chars&gt;{&quot;/&quot;&lt;extension&gt;}
 * &lt;separator&gt; := &quot;=&quot;, &quot;,&quot;, &quot;;&quot;, &quot;&lt;&quot;, &quot;&amp;&quot;
 * &lt;chars&gt;, and &lt;extension&gt; are both arbitrary strings.
 * unquoted whitespaces are ignored.
 * 'xxx' can be used to quote characters
 * One difference from Collator is that &amp; is used to reset to a current
 * point. Or, in other words, it introduces a new sequence which is to
 * be added to the old.
 * That is: &quot;a &lt; b &lt; c &lt; d&quot; is the same as &quot;a &lt; b &amp; b &lt; c &amp; c &lt; d&quot; OR
 * &quot;a &lt; b &lt; d &amp; b &lt; c&quot;
 * XXX: make '' be a single quote.
 * @see PatternEntry
 * @author             Mark Davis, Helena Shih
 */

final class MergeCollation {

    /**
     * Creates from a pattern
     * @exception ParseException If the input pattern is incorrect.
     */
    public MergeCollation(String pattern) throws ParseException
<span class="nc" id="L70">    {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        for (int i = 0; i &lt; statusArray.length; i++)</span>
<span class="nc" id="L72">            statusArray[i] = 0;</span>
<span class="nc" id="L73">        setPattern(pattern);</span>
<span class="nc" id="L74">    }</span>

    /**
     * recovers current pattern
     */
    public String getPattern() {
<span class="nc" id="L80">        return getPattern(true);</span>
    }

    /**
     * recovers current pattern.
     * @param withWhiteSpace puts spacing around the entries, and \n
     * before &amp; and &lt;
     */
    public String getPattern(boolean withWhiteSpace) {
<span class="nc" id="L89">        StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L90">        PatternEntry tmp = null;</span>
<span class="nc" id="L91">        ArrayList&lt;PatternEntry&gt; extList = null;</span>
        int i;
<span class="nc bnc" id="L93" title="All 2 branches missed.">        for (i = 0; i &lt; patterns.size(); ++i) {</span>
<span class="nc" id="L94">            PatternEntry entry = patterns.get(i);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (entry.extension.length() != 0) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                if (extList == null)</span>
<span class="nc" id="L97">                    extList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L98">                extList.add(entry);</span>
            } else {
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (extList != null) {</span>
<span class="nc" id="L101">                    PatternEntry last = findLastWithNoExtension(i-1);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                    for (int j = extList.size() - 1; j &gt;= 0 ; j--) {</span>
<span class="nc" id="L103">                        tmp = extList.get(j);</span>
<span class="nc" id="L104">                        tmp.addToBuffer(result, false, withWhiteSpace, last);</span>
                    }
<span class="nc" id="L106">                    extList = null;</span>
                }
<span class="nc" id="L108">                entry.addToBuffer(result, false, withWhiteSpace, null);</span>
            }
        }
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (extList != null) {</span>
<span class="nc" id="L112">            PatternEntry last = findLastWithNoExtension(i-1);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            for (int j = extList.size() - 1; j &gt;= 0 ; j--) {</span>
<span class="nc" id="L114">                tmp = extList.get(j);</span>
<span class="nc" id="L115">                tmp.addToBuffer(result, false, withWhiteSpace, last);</span>
            }
<span class="nc" id="L117">            extList = null;</span>
        }
<span class="nc" id="L119">        return result.toString();</span>
    }

    private final PatternEntry findLastWithNoExtension(int i) {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        for (--i;i &gt;= 0; --i) {</span>
<span class="nc" id="L124">            PatternEntry entry = patterns.get(i);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (entry.extension.length() == 0) {</span>
<span class="nc" id="L126">                return entry;</span>
            }
        }
<span class="nc" id="L129">        return null;</span>
    }

    /**
     * emits the pattern for collation builder.
     * @return emits the string in the format understable to the collation
     * builder.
     */
    public String emitPattern() {
<span class="nc" id="L138">        return emitPattern(true);</span>
    }

    /**
     * emits the pattern for collation builder.
     * @param withWhiteSpace puts spacing around the entries, and \n
     * before &amp; and &lt;
     * @return emits the string in the format understable to the collation
     * builder.
     */
    public String emitPattern(boolean withWhiteSpace) {
<span class="nc" id="L149">        StringBuffer result = new StringBuffer();</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        for (int i = 0; i &lt; patterns.size(); ++i)</span>
        {
<span class="nc" id="L152">            PatternEntry entry = patterns.get(i);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (entry != null) {</span>
<span class="nc" id="L154">                entry.addToBuffer(result, true, withWhiteSpace, null);</span>
            }
        }
<span class="nc" id="L157">        return result.toString();</span>
    }

    /**
     * sets the pattern.
     */
    public void setPattern(String pattern) throws ParseException
    {
<span class="nc" id="L165">        patterns.clear();</span>
<span class="nc" id="L166">        addPattern(pattern);</span>
<span class="nc" id="L167">    }</span>

    /**
     * adds a pattern to the current one.
     * @param pattern the new pattern to be added
     */
    public void addPattern(String pattern) throws ParseException
    {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (pattern == null)</span>
<span class="nc" id="L176">            return;</span>

<span class="nc" id="L178">        PatternEntry.Parser parser = new PatternEntry.Parser(pattern);</span>

<span class="nc" id="L180">        PatternEntry entry = parser.next();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        while (entry != null) {</span>
<span class="nc" id="L182">            fixEntry(entry);</span>
<span class="nc" id="L183">            entry = parser.next();</span>
        }
<span class="nc" id="L185">    }</span>

    /**
     * gets count of separate entries
     * @return the size of pattern entries
     */
    public int getCount() {
<span class="nc" id="L192">        return patterns.size();</span>
    }

    /**
     * gets count of separate entries
     * @param index the offset of the desired pattern entry
     * @return the requested pattern entry
     */
    public PatternEntry getItemAt(int index) {
<span class="nc" id="L201">        return patterns.get(index);</span>
    }

    //============================================================
    // privates
    //============================================================
<span class="nc" id="L207">    ArrayList&lt;PatternEntry&gt; patterns = new ArrayList&lt;&gt;(); // a list of PatternEntries</span>

<span class="nc" id="L209">    private transient PatternEntry saveEntry = null;</span>
<span class="nc" id="L210">    private transient PatternEntry lastEntry = null;</span>

    // This is really used as a local variable inside fixEntry, but we cache
    // it here to avoid newing it up every time the method is called.
<span class="nc" id="L214">    private transient StringBuffer excess = new StringBuffer();</span>

    //
    // When building a MergeCollation, we need to do lots of searches to see
    // whether a given entry is already in the table.  Since we're using an
    // array, this would make the algorithm O(N*N).  To speed things up, we
    // use this bit array to remember whether the array contains any entries
    // starting with each Unicode character.  If not, we can avoid the search.
    // Using BitSet would make this easier, but it's significantly slower.
    //
<span class="nc" id="L224">    private transient byte[] statusArray = new byte[8192];</span>
<span class="nc" id="L225">    private final byte BITARRAYMASK = (byte)0x1;</span>
<span class="nc" id="L226">    private final int  BYTEPOWER = 3;</span>
<span class="nc" id="L227">    private final int  BYTEMASK = (1 &lt;&lt; BYTEPOWER) - 1;</span>

    /*
      If the strength is RESET, then just change the lastEntry to
      be the current. (If the current is not in patterns, signal an error).
      If not, then remove the current entry, and add it after lastEntry
      (which is usually at the end).
      */
    private final void fixEntry(PatternEntry newEntry) throws ParseException
    {
        // check to see whether the new entry has the same characters as the previous
        // entry did (this can happen when a pattern declaring a difference between two
        // strings that are canonically equivalent is normalized).  If so, and the strength
        // is anything other than IDENTICAL or RESET, throw an exception (you can't
        // declare a string to be unequal to itself).       --rtg 5/24/99
<span class="nc bnc" id="L242" title="All 4 branches missed.">        if (lastEntry != null &amp;&amp; newEntry.chars.equals(lastEntry.chars)</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                &amp;&amp; newEntry.extension.equals(lastEntry.extension)) {</span>
<span class="nc bnc" id="L244" title="All 4 branches missed.">            if (newEntry.strength != Collator.IDENTICAL</span>
                &amp;&amp; newEntry.strength != PatternEntry.RESET) {
<span class="nc" id="L246">                    throw new ParseException(&quot;The entries &quot; + lastEntry + &quot; and &quot;</span>
                            + newEntry + &quot; are adjacent in the rules, but have conflicting &quot;
                            + &quot;strengths: A character can't be unequal to itself.&quot;, -1);
            } else {
                // otherwise, just skip this entry and behave as though you never saw it
<span class="nc" id="L251">                return;</span>
            }
        }

<span class="nc" id="L255">        boolean changeLastEntry = true;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (newEntry.strength != PatternEntry.RESET) {</span>
<span class="nc" id="L257">            int oldIndex = -1;</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">            if ((newEntry.chars.length() == 1)) {</span>

<span class="nc" id="L261">                char c = newEntry.chars.charAt(0);</span>
<span class="nc" id="L262">                int statusIndex = c &gt;&gt; BYTEPOWER;</span>
<span class="nc" id="L263">                byte bitClump = statusArray[statusIndex];</span>
<span class="nc" id="L264">                byte setBit = (byte)(BITARRAYMASK &lt;&lt; (c &amp; BYTEMASK));</span>

<span class="nc bnc" id="L266" title="All 4 branches missed.">                if (bitClump != 0 &amp;&amp; (bitClump &amp; setBit) != 0) {</span>
<span class="nc" id="L267">                    oldIndex = patterns.lastIndexOf(newEntry);</span>
                } else {
                    // We're going to add an element that starts with this
                    // character, so go ahead and set its bit.
<span class="nc" id="L271">                    statusArray[statusIndex] = (byte)(bitClump | setBit);</span>
                }
<span class="nc" id="L273">            } else {</span>
<span class="nc" id="L274">                oldIndex = patterns.lastIndexOf(newEntry);</span>
            }
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (oldIndex != -1) {</span>
<span class="nc" id="L277">                patterns.remove(oldIndex);</span>
            }

<span class="nc" id="L280">            excess.setLength(0);</span>
<span class="nc" id="L281">            int lastIndex = findLastEntry(lastEntry, excess);</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (excess.length() != 0) {</span>
<span class="nc" id="L284">                newEntry.extension = excess + newEntry.extension;</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                if (lastIndex != patterns.size()) {</span>
<span class="nc" id="L286">                    lastEntry = saveEntry;</span>
<span class="nc" id="L287">                    changeLastEntry = false;</span>
                }
            }
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (lastIndex == patterns.size()) {</span>
<span class="nc" id="L291">                patterns.add(newEntry);</span>
<span class="nc" id="L292">                saveEntry = newEntry;</span>
            } else {
<span class="nc" id="L294">                patterns.add(lastIndex, newEntry);</span>
            }
        }
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (changeLastEntry) {</span>
<span class="nc" id="L298">            lastEntry = newEntry;</span>
        }
<span class="nc" id="L300">    }</span>

    private final int findLastEntry(PatternEntry entry,
                              StringBuffer excessChars) throws ParseException
    {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (entry == null)</span>
<span class="nc" id="L306">            return 0;</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (entry.strength != PatternEntry.RESET) {</span>
            // Search backwards for string that contains this one;
            // most likely entry is last one

<span class="nc" id="L312">            int oldIndex = -1;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            if ((entry.chars.length() == 1)) {</span>
<span class="nc" id="L314">                int index = entry.chars.charAt(0) &gt;&gt; BYTEPOWER;</span>
<span class="nc" id="L315">                if ((statusArray[index] &amp;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                    (BITARRAYMASK &lt;&lt; (entry.chars.charAt(0) &amp; BYTEMASK))) != 0) {</span>
<span class="nc" id="L317">                    oldIndex = patterns.lastIndexOf(entry);</span>
                }
<span class="nc" id="L319">            } else {</span>
<span class="nc" id="L320">                oldIndex = patterns.lastIndexOf(entry);</span>
            }
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if ((oldIndex == -1))</span>
<span class="nc" id="L323">                throw new ParseException(&quot;couldn't find last entry: &quot;</span>
                                          + entry, oldIndex);
<span class="nc" id="L325">            return oldIndex + 1;</span>
        } else {
            int i;
<span class="nc bnc" id="L328" title="All 2 branches missed.">            for (i = patterns.size() - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L329">                PatternEntry e = patterns.get(i);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                if (e.chars.regionMatches(0,entry.chars,0,</span>
<span class="nc" id="L331">                                              e.chars.length())) {</span>
<span class="nc" id="L332">                    excessChars.append(entry.chars.substring(e.chars.length(),</span>
<span class="nc" id="L333">                                                            entry.chars.length()));</span>
<span class="nc" id="L334">                    break;</span>
                }
            }
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (i == -1)</span>
<span class="nc" id="L338">                throw new ParseException(&quot;couldn't find: &quot; + entry, i);</span>
<span class="nc" id="L339">            return i + 1;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>