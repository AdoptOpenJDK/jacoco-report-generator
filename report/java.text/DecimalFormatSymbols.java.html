<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DecimalFormatSymbols.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">DecimalFormatSymbols.java</span></div><h1>DecimalFormatSymbols.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.text.spi.DecimalFormatSymbolsProvider;
import java.util.ArrayList;
import java.util.Currency;
import java.util.List;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleServiceProviderPool;
import sun.util.locale.provider.ResourceBundleBasedAdapter;

/**
 * This class represents the set of symbols (such as the decimal separator,
 * the grouping separator, and so on) needed by &lt;code&gt;DecimalFormat&lt;/code&gt;
 * to format numbers. &lt;code&gt;DecimalFormat&lt;/code&gt; creates for itself an instance of
 * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; from its locale data.  If you need to change any
 * of these symbols, you can get the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object from
 * your &lt;code&gt;DecimalFormat&lt;/code&gt; and modify it.
 *
 * @see          java.util.Locale
 * @see          DecimalFormat
 * @author       Mark Davis
 * @author       Alan Liu
 */

public class DecimalFormatSymbols implements Cloneable, Serializable {

    /**
     * Create a DecimalFormatSymbols object for the default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * This constructor can only construct instances for the locales
     * supported by the Java runtime environment, not for those
     * supported by installed
     * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
     * implementations. For full locale coverage, use the
     * {@link #getInstance(Locale) getInstance} method.
     * &lt;p&gt;This is equivalent to calling
     * {@link #DecimalFormatSymbols(Locale)
     *     DecimalFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     */
<span class="nc" id="L88">    public DecimalFormatSymbols() {</span>
<span class="nc" id="L89">        initialize( Locale.getDefault(Locale.Category.FORMAT) );</span>
<span class="nc" id="L90">    }</span>

    /**
     * Create a DecimalFormatSymbols object for the given locale.
     * This constructor can only construct instances for the locales
     * supported by the Java runtime environment, not for those
     * supported by installed
     * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
     * implementations. For full locale coverage, use the
     * {@link #getInstance(Locale) getInstance} method.
     * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
     * for the numbering system, the instance is initialized with the specified numbering
     * system if the JRE implementation supports it. For example,
     * &lt;pre&gt;
     * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
     * &lt;/pre&gt;
     * This may return a {@code NumberFormat} instance with the Thai numbering system,
     * instead of the Latin numbering system.
     *
     * @param locale the desired locale
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     */
<span class="fc" id="L112">    public DecimalFormatSymbols( Locale locale ) {</span>
<span class="fc" id="L113">        initialize( locale );</span>
<span class="fc" id="L114">    }</span>

    /**
     * Returns an array of all locales for which the
     * &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return
     * localized instances.
     * The returned array represents the union of locales supported by the Java
     * runtime and by installed
     * {@link java.text.spi.DecimalFormatSymbolsProvider DecimalFormatSymbolsProvider}
     * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
     * instance equal to {@link java.util.Locale#US Locale.US}.
     *
     * @return an array of locales for which localized
     *         &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instances are available.
     * @since 1.6
     */
    public static Locale[] getAvailableLocales() {
<span class="fc" id="L131">        LocaleServiceProviderPool pool =</span>
<span class="fc" id="L132">            LocaleServiceProviderPool.getPool(DecimalFormatSymbolsProvider.class);</span>
<span class="fc" id="L133">        return pool.getAvailableLocales();</span>
    }

    /**
     * Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the default
     * locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;
     * instances for locales supported by the Java runtime itself as well
     * as for those supported by installed
     * {@link java.text.spi.DecimalFormatSymbolsProvider
     * DecimalFormatSymbolsProvider} implementations.
     * &lt;p&gt;This is equivalent to calling
     * {@link #getInstance(Locale)
     *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     * @return a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.
     * @since 1.6
     */
    public static final DecimalFormatSymbols getInstance() {
<span class="fc" id="L152">        return getInstance(Locale.getDefault(Locale.Category.FORMAT));</span>
    }

    /**
     * Gets the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance for the specified
     * locale.  This method provides access to &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;
     * instances for locales supported by the Java runtime itself as well
     * as for those supported by installed
     * {@link java.text.spi.DecimalFormatSymbolsProvider
     * DecimalFormatSymbolsProvider} implementations.
     * If the specified locale contains the {@link java.util.Locale#UNICODE_LOCALE_EXTENSION}
     * for the numbering system, the instance is initialized with the specified numbering
     * system if the JRE implementation supports it. For example,
     * &lt;pre&gt;
     * NumberFormat.getNumberInstance(Locale.forLanguageTag(&quot;th-TH-u-nu-thai&quot;))
     * &lt;/pre&gt;
     * This may return a {@code NumberFormat} instance with the Thai numbering system,
     * instead of the Latin numbering system.
     *
     * @param locale the desired locale.
     * @return a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; instance.
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     * @since 1.6
     */
    public static final DecimalFormatSymbols getInstance(Locale locale) {
        LocaleProviderAdapter adapter;
<span class="fc" id="L178">        adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);</span>
<span class="fc" id="L179">        DecimalFormatSymbolsProvider provider = adapter.getDecimalFormatSymbolsProvider();</span>
<span class="fc" id="L180">        DecimalFormatSymbols dfsyms = provider.getInstance(locale);</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (dfsyms == null) {</span>
<span class="nc" id="L182">            provider = LocaleProviderAdapter.forJRE().getDecimalFormatSymbolsProvider();</span>
<span class="nc" id="L183">            dfsyms = provider.getInstance(locale);</span>
        }
<span class="fc" id="L185">        return dfsyms;</span>
    }

    /**
     * Gets the character used for zero. Different for Arabic, etc.
     *
     * @return the character used for zero
     */
    public char getZeroDigit() {
<span class="fc" id="L194">        return zeroDigit;</span>
    }

    /**
     * Sets the character used for zero. Different for Arabic, etc.
     *
     * @param zeroDigit the character used for zero
     */
    public void setZeroDigit(char zeroDigit) {
<span class="nc" id="L203">        this.zeroDigit = zeroDigit;</span>
<span class="nc" id="L204">    }</span>

    /**
     * Gets the character used for thousands separator. Different for French, etc.
     *
     * @return the grouping separator
     */
    public char getGroupingSeparator() {
<span class="fc" id="L212">        return groupingSeparator;</span>
    }

    /**
     * Sets the character used for thousands separator. Different for French, etc.
     *
     * @param groupingSeparator the grouping separator
     */
    public void setGroupingSeparator(char groupingSeparator) {
<span class="nc" id="L221">        this.groupingSeparator = groupingSeparator;</span>
<span class="nc" id="L222">    }</span>

    /**
     * Gets the character used for decimal sign. Different for French, etc.
     *
     * @return the character used for decimal sign
     */
    public char getDecimalSeparator() {
<span class="fc" id="L230">        return decimalSeparator;</span>
    }

    /**
     * Sets the character used for decimal sign. Different for French, etc.
     *
     * @param decimalSeparator the character used for decimal sign
     */
    public void setDecimalSeparator(char decimalSeparator) {
<span class="nc" id="L239">        this.decimalSeparator = decimalSeparator;</span>
<span class="nc" id="L240">    }</span>

    /**
     * Gets the character used for per mille sign. Different for Arabic, etc.
     *
     * @return the character used for per mille sign
     */
    public char getPerMill() {
<span class="nc" id="L248">        return perMill;</span>
    }

    /**
     * Sets the character used for per mille sign. Different for Arabic, etc.
     *
     * @param perMill the character used for per mille sign
     */
    public void setPerMill(char perMill) {
<span class="nc" id="L257">        this.perMill = perMill;</span>
<span class="nc" id="L258">    }</span>

    /**
     * Gets the character used for percent sign. Different for Arabic, etc.
     *
     * @return the character used for percent sign
     */
    public char getPercent() {
<span class="fc" id="L266">        return percent;</span>
    }

    /**
     * Sets the character used for percent sign. Different for Arabic, etc.
     *
     * @param percent the character used for percent sign
     */
    public void setPercent(char percent) {
<span class="nc" id="L275">        this.percent = percent;</span>
<span class="nc" id="L276">    }</span>

    /**
     * Gets the character used for a digit in a pattern.
     *
     * @return the character used for a digit in a pattern
     */
    public char getDigit() {
<span class="nc" id="L284">        return digit;</span>
    }

    /**
     * Sets the character used for a digit in a pattern.
     *
     * @param digit the character used for a digit in a pattern
     */
    public void setDigit(char digit) {
<span class="nc" id="L293">        this.digit = digit;</span>
<span class="nc" id="L294">    }</span>

    /**
     * Gets the character used to separate positive and negative subpatterns
     * in a pattern.
     *
     * @return the pattern separator
     */
    public char getPatternSeparator() {
<span class="nc" id="L303">        return patternSeparator;</span>
    }

    /**
     * Sets the character used to separate positive and negative subpatterns
     * in a pattern.
     *
     * @param patternSeparator the pattern separator
     */
    public void setPatternSeparator(char patternSeparator) {
<span class="nc" id="L313">        this.patternSeparator = patternSeparator;</span>
<span class="nc" id="L314">    }</span>

    /**
     * Gets the string used to represent infinity. Almost always left
     * unchanged.
     *
     * @return the string representing infinity
     */
    public String getInfinity() {
<span class="fc" id="L323">        return infinity;</span>
    }

    /**
     * Sets the string used to represent infinity. Almost always left
     * unchanged.
     *
     * @param infinity the string representing infinity
     */
    public void setInfinity(String infinity) {
<span class="nc" id="L333">        this.infinity = infinity;</span>
<span class="nc" id="L334">    }</span>

    /**
     * Gets the string used to represent &quot;not a number&quot;. Almost always left
     * unchanged.
     *
     * @return the string representing &quot;not a number&quot;
     */
    public String getNaN() {
<span class="fc" id="L343">        return NaN;</span>
    }

    /**
     * Sets the string used to represent &quot;not a number&quot;. Almost always left
     * unchanged.
     *
     * @param NaN the string representing &quot;not a number&quot;
     */
    public void setNaN(String NaN) {
<span class="nc" id="L353">        this.NaN = NaN;</span>
<span class="nc" id="L354">    }</span>

    /**
     * Gets the character used to represent minus sign. If no explicit
     * negative format is specified, one is formed by prefixing
     * minusSign to the positive format.
     *
     * @return the character representing minus sign
     */
    public char getMinusSign() {
<span class="fc" id="L364">        return minusSign;</span>
    }

    /**
     * Sets the character used to represent minus sign. If no explicit
     * negative format is specified, one is formed by prefixing
     * minusSign to the positive format.
     *
     * @param minusSign the character representing minus sign
     */
    public void setMinusSign(char minusSign) {
<span class="fc" id="L375">        this.minusSign = minusSign;</span>
<span class="fc" id="L376">    }</span>

    /**
     * Returns the currency symbol for the currency of these
     * DecimalFormatSymbols in their locale.
     *
     * @return the currency symbol
     * @since 1.2
     */
    public String getCurrencySymbol()
    {
<span class="fc" id="L387">        return currencySymbol;</span>
    }

    /**
     * Sets the currency symbol for the currency of these
     * DecimalFormatSymbols in their locale.
     *
     * @param currency the currency symbol
     * @since 1.2
     */
    public void setCurrencySymbol(String currency)
    {
<span class="nc" id="L399">        currencySymbol = currency;</span>
<span class="nc" id="L400">    }</span>

    /**
     * Returns the ISO 4217 currency code of the currency of these
     * DecimalFormatSymbols.
     *
     * @return the currency code
     * @since 1.2
     */
    public String getInternationalCurrencySymbol()
    {
<span class="nc" id="L411">        return intlCurrencySymbol;</span>
    }

    /**
     * Sets the ISO 4217 currency code of the currency of these
     * DecimalFormatSymbols.
     * If the currency code is valid (as defined by
     * {@link java.util.Currency#getInstance(java.lang.String) Currency.getInstance}),
     * this also sets the currency attribute to the corresponding Currency
     * instance and the currency symbol attribute to the currency's symbol
     * in the DecimalFormatSymbols' locale. If the currency code is not valid,
     * then the currency attribute is set to null and the currency symbol
     * attribute is not modified.
     *
     * @param currencyCode the currency code
     * @see #setCurrency
     * @see #setCurrencySymbol
     * @since 1.2
     */
    public void setInternationalCurrencySymbol(String currencyCode)
    {
<span class="nc" id="L432">        intlCurrencySymbol = currencyCode;</span>
<span class="nc" id="L433">        currency = null;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (currencyCode != null) {</span>
            try {
<span class="nc" id="L436">                currency = Currency.getInstance(currencyCode);</span>
<span class="nc" id="L437">                currencySymbol = currency.getSymbol();</span>
<span class="nc" id="L438">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L439">            }</span>
        }
<span class="nc" id="L441">    }</span>

    /**
     * Gets the currency of these DecimalFormatSymbols. May be null if the
     * currency symbol attribute was previously set to a value that's not
     * a valid ISO 4217 currency code.
     *
     * @return the currency used, or null
     * @since 1.4
     */
    public Currency getCurrency() {
<span class="fc" id="L452">        return currency;</span>
    }

    /**
     * Sets the currency of these DecimalFormatSymbols.
     * This also sets the currency symbol attribute to the currency's symbol
     * in the DecimalFormatSymbols' locale, and the international currency
     * symbol attribute to the currency's ISO 4217 currency code.
     *
     * @param currency the new currency to be used
     * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null
     * @since 1.4
     * @see #setCurrencySymbol
     * @see #setInternationalCurrencySymbol
     */
    public void setCurrency(Currency currency) {
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (currency == null) {</span>
<span class="nc" id="L469">            throw new NullPointerException();</span>
        }
<span class="nc" id="L471">        this.currency = currency;</span>
<span class="nc" id="L472">        intlCurrencySymbol = currency.getCurrencyCode();</span>
<span class="nc" id="L473">        currencySymbol = currency.getSymbol(locale);</span>
<span class="nc" id="L474">    }</span>


    /**
     * Returns the monetary decimal separator.
     *
     * @return the monetary decimal separator
     * @since 1.2
     */
    public char getMonetaryDecimalSeparator()
    {
<span class="fc" id="L485">        return monetarySeparator;</span>
    }

    /**
     * Sets the monetary decimal separator.
     *
     * @param sep the monetary decimal separator
     * @since 1.2
     */
    public void setMonetaryDecimalSeparator(char sep)
    {
<span class="nc" id="L496">        monetarySeparator = sep;</span>
<span class="nc" id="L497">    }</span>

    //------------------------------------------------------------
    // BEGIN   Package Private methods ... to be made public later
    //------------------------------------------------------------

    /**
     * Returns the character used to separate the mantissa from the exponent.
     */
    char getExponentialSymbol()
    {
<span class="nc" id="L508">        return exponential;</span>
    }
  /**
   * Returns the string used to separate the mantissa from the exponent.
   * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
   *
   * @return the exponent separator string
   * @see #setExponentSeparator(java.lang.String)
   * @since 1.6
   */
    public String getExponentSeparator()
    {
<span class="fc" id="L520">        return exponentialSeparator;</span>
    }

    /**
     * Sets the character used to separate the mantissa from the exponent.
     */
    void setExponentialSymbol(char exp)
    {
<span class="nc" id="L528">        exponential = exp;</span>
<span class="nc" id="L529">    }</span>

  /**
   * Sets the string used to separate the mantissa from the exponent.
   * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
   *
   * @param exp the exponent separator string
   * @exception NullPointerException if &lt;code&gt;exp&lt;/code&gt; is null
   * @see #getExponentSeparator()
   * @since 1.6
   */
    public void setExponentSeparator(String exp)
    {
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (exp == null) {</span>
<span class="nc" id="L543">            throw new NullPointerException();</span>
        }
<span class="nc" id="L545">        exponentialSeparator = exp;</span>
<span class="nc" id="L546">     }</span>


    //------------------------------------------------------------
    // END     Package Private methods ... to be made public later
    //------------------------------------------------------------

    /**
     * Standard override.
     */
    @Override
    public Object clone() {
        try {
<span class="fc" id="L559">            return (DecimalFormatSymbols)super.clone();</span>
            // other fields are bit-copied
<span class="nc" id="L561">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L562">            throw new InternalError(e);</span>
        }
    }

    /**
     * Override equals.
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (obj == null) return false;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if (this == obj) return true;</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">        if (getClass() != obj.getClass()) return false;</span>
<span class="fc" id="L574">        DecimalFormatSymbols other = (DecimalFormatSymbols) obj;</span>
<span class="pc bpc" id="L575" title="8 of 16 branches missed.">        return (zeroDigit == other.zeroDigit &amp;&amp;</span>
        groupingSeparator == other.groupingSeparator &amp;&amp;
        decimalSeparator == other.decimalSeparator &amp;&amp;
        percent == other.percent &amp;&amp;
        perMill == other.perMill &amp;&amp;
        digit == other.digit &amp;&amp;
        minusSign == other.minusSign &amp;&amp;
        patternSeparator == other.patternSeparator &amp;&amp;
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        infinity.equals(other.infinity) &amp;&amp;</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        NaN.equals(other.NaN) &amp;&amp;</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">        currencySymbol.equals(other.currencySymbol) &amp;&amp;</span>
<span class="pc bpc" id="L586" title="3 of 6 branches missed.">        intlCurrencySymbol.equals(other.intlCurrencySymbol) &amp;&amp;</span>
        currency == other.currency &amp;&amp;
        monetarySeparator == other.monetarySeparator &amp;&amp;
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        exponentialSeparator.equals(other.exponentialSeparator) &amp;&amp;</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        locale.equals(other.locale));</span>
    }

    /**
     * Override hashCode.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L598">            int result = zeroDigit;</span>
<span class="nc" id="L599">            result = result * 37 + groupingSeparator;</span>
<span class="nc" id="L600">            result = result * 37 + decimalSeparator;</span>
<span class="nc" id="L601">            return result;</span>
    }

    /**
     * Initializes the symbols from the FormatData resource bundle.
     */
    private void initialize( Locale locale ) {
<span class="fc" id="L608">        this.locale = locale;</span>

        // get resource bundle data
<span class="fc" id="L611">        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, locale);</span>
        // Avoid potential recursions
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (!(adapter instanceof ResourceBundleBasedAdapter)) {</span>
<span class="fc" id="L614">            adapter = LocaleProviderAdapter.getResourceBundleBased();</span>
        }
<span class="fc" id="L616">        Object[] data = adapter.getLocaleResources(locale).getDecimalFormatSymbolsData();</span>
<span class="fc" id="L617">        String[] numberElements = (String[]) data[0];</span>

<span class="fc" id="L619">        decimalSeparator = numberElements[0].charAt(0);</span>
<span class="fc" id="L620">        groupingSeparator = numberElements[1].charAt(0);</span>
<span class="fc" id="L621">        patternSeparator = numberElements[2].charAt(0);</span>
<span class="fc" id="L622">        percent = numberElements[3].charAt(0);</span>
<span class="fc" id="L623">        zeroDigit = numberElements[4].charAt(0); //different for Arabic,etc.</span>
<span class="fc" id="L624">        digit = numberElements[5].charAt(0);</span>
<span class="fc" id="L625">        minusSign = numberElements[6].charAt(0);</span>
<span class="fc" id="L626">        exponential = numberElements[7].charAt(0);</span>
<span class="fc" id="L627">        exponentialSeparator = numberElements[7]; //string representation new since 1.6</span>
<span class="fc" id="L628">        perMill = numberElements[8].charAt(0);</span>
<span class="fc" id="L629">        infinity  = numberElements[9];</span>
<span class="fc" id="L630">        NaN = numberElements[10];</span>

        // Try to obtain the currency used in the locale's country.
        // Check for empty country string separately because it's a valid
        // country ID for Locale (and used for the C locale), but not a valid
        // ISO 3166 country code, and exceptions are expensive.
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (locale.getCountry().length() &gt; 0) {</span>
            try {
<span class="fc" id="L638">                currency = Currency.getInstance(locale);</span>
<span class="fc" id="L639">            } catch (IllegalArgumentException e) {</span>
                // use default values below for compatibility
<span class="fc" id="L641">            }</span>
        }
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if (currency != null) {</span>
<span class="fc" id="L644">            intlCurrencySymbol = currency.getCurrencyCode();</span>
<span class="pc bpc" id="L645" title="1 of 4 branches missed.">            if (data[1] != null &amp;&amp; data[1] == intlCurrencySymbol) {</span>
<span class="fc" id="L646">                currencySymbol = (String) data[2];</span>
            } else {
<span class="fc" id="L648">                currencySymbol = currency.getSymbol(locale);</span>
<span class="fc" id="L649">                data[1] = intlCurrencySymbol;</span>
<span class="fc" id="L650">                data[2] = currencySymbol;</span>
            }
        } else {
            // default values
<span class="fc" id="L654">            intlCurrencySymbol = &quot;XXX&quot;;</span>
            try {
<span class="fc" id="L656">                currency = Currency.getInstance(intlCurrencySymbol);</span>
<span class="nc" id="L657">            } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L658">            }</span>
<span class="fc" id="L659">            currencySymbol = &quot;\u00A4&quot;;</span>
        }
        // Currently the monetary decimal separator is the same as the
        // standard decimal separator for all locales that we support.
        // If that changes, add a new entry to NumberElements.
<span class="fc" id="L664">        monetarySeparator = decimalSeparator;</span>
<span class="fc" id="L665">    }</span>

    /**
     * Reads the default serializable fields, provides default values for objects
     * in older serial versions, and initializes non-serializable fields.
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt;
     * is less than 1, initializes &lt;code&gt;monetarySeparator&lt;/code&gt; to be
     * the same as &lt;code&gt;decimalSeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;
     * to be 'E'.
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 2,
     * initializes &lt;code&gt;locale&lt;/code&gt;to the root locale, and initializes
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, it initializes
     * &lt;code&gt;exponentialSeparator&lt;/code&gt; using &lt;code&gt;exponential&lt;/code&gt;.
     * Sets &lt;code&gt;serialVersionOnStream&lt;/code&gt; back to the maximum allowed value so that
     * default serialization will work properly if this object is streamed out again.
     * Initializes the currency from the intlCurrencySymbol field.
     *
     * @since JDK 1.1.6
     */
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L686">        stream.defaultReadObject();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // Didn't have monetarySeparator or exponential field;
            // use defaults.
<span class="nc" id="L690">            monetarySeparator = decimalSeparator;</span>
<span class="nc" id="L691">            exponential       = 'E';</span>
        }
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 2) {</span>
            // didn't have locale; use root locale
<span class="nc" id="L695">            locale = Locale.ROOT;</span>
        }
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 3) {</span>
            // didn't have exponentialSeparator. Create one using exponential
<span class="nc" id="L699">            exponentialSeparator = Character.toString(exponential);</span>
        }
<span class="nc" id="L701">        serialVersionOnStream = currentSerialVersion;</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (intlCurrencySymbol != null) {</span>
            try {
<span class="nc" id="L705">                 currency = Currency.getInstance(intlCurrencySymbol);</span>
<span class="nc" id="L706">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L707">            }</span>
        }
<span class="nc" id="L709">    }</span>

    /**
     * Character used for zero.
     *
     * @serial
     * @see #getZeroDigit
     */
    private  char    zeroDigit;

    /**
     * Character used for thousands separator.
     *
     * @serial
     * @see #getGroupingSeparator
     */
    private  char    groupingSeparator;

    /**
     * Character used for decimal sign.
     *
     * @serial
     * @see #getDecimalSeparator
     */
    private  char    decimalSeparator;

    /**
     * Character used for per mille sign.
     *
     * @serial
     * @see #getPerMill
     */
    private  char    perMill;

    /**
     * Character used for percent sign.
     * @serial
     * @see #getPercent
     */
    private  char    percent;

    /**
     * Character used for a digit in a pattern.
     *
     * @serial
     * @see #getDigit
     */
    private  char    digit;

    /**
     * Character used to separate positive and negative subpatterns
     * in a pattern.
     *
     * @serial
     * @see #getPatternSeparator
     */
    private  char    patternSeparator;

    /**
     * String used to represent infinity.
     * @serial
     * @see #getInfinity
     */
    private  String  infinity;

    /**
     * String used to represent &quot;not a number&quot;.
     * @serial
     * @see #getNaN
     */
    private  String  NaN;

    /**
     * Character used to represent minus sign.
     * @serial
     * @see #getMinusSign
     */
    private  char    minusSign;

    /**
     * String denoting the local currency, e.g. &quot;$&quot;.
     * @serial
     * @see #getCurrencySymbol
     */
    private  String  currencySymbol;

    /**
     * ISO 4217 currency code denoting the local currency, e.g. &quot;USD&quot;.
     * @serial
     * @see #getInternationalCurrencySymbol
     */
    private  String  intlCurrencySymbol;

    /**
     * The decimal separator used when formatting currency values.
     * @serial
     * @since JDK 1.1.6
     * @see #getMonetaryDecimalSeparator
     */
    private  char    monetarySeparator; // Field new in JDK 1.1.6

    /**
     * The character used to distinguish the exponent in a number formatted
     * in exponential notation, e.g. 'E' for a number such as &quot;1.23E45&quot;.
     * &lt;p&gt;
     * Note that the public API provides no way to set this field,
     * even though it is supported by the implementation and the stream format.
     * The intent is that this will be added to the API in the future.
     *
     * @serial
     * @since JDK 1.1.6
     */
    private  char    exponential;       // Field new in JDK 1.1.6

  /**
   * The string used to separate the mantissa from the exponent.
   * Examples: &quot;x10^&quot; for 1.23x10^4, &quot;E&quot; for 1.23E4.
   * &lt;p&gt;
   * If both &lt;code&gt;exponential&lt;/code&gt; and &lt;code&gt;exponentialSeparator&lt;/code&gt;
   * exist, this &lt;code&gt;exponentialSeparator&lt;/code&gt; has the precedence.
   *
   * @serial
   * @since 1.6
   */
    private  String    exponentialSeparator;       // Field new in JDK 1.6

    /**
     * The locale of these currency format symbols.
     *
     * @serial
     * @since 1.4
     */
    private Locale locale;

    // currency; only the ISO code is serialized.
    private transient Currency currency;

    // Proclaim JDK 1.1 FCS compatibility
    static final long serialVersionUID = 5772796243397350300L;

    // The internal serial version which says which version was written
    // - 0 (default) for version up to JDK 1.1.5
    // - 1 for version from JDK 1.1.6, which includes two new fields:
    //     monetarySeparator and exponential.
    // - 2 for version from J2SE 1.4, which includes locale field.
    // - 3 for version from J2SE 1.6, which includes exponentialSeparator field.
    private static final int currentSerialVersion = 3;

    /**
     * Describes the version of &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; present on the stream.
     * Possible values are:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): versions prior to JDK 1.1.6.
     *
     * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: Versions written by JDK 1.1.6 or later, which include
     *      two new fields: &lt;code&gt;monetarySeparator&lt;/code&gt; and &lt;code&gt;exponential&lt;/code&gt;.
     * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: Versions written by J2SE 1.4 or later, which include a
     *      new &lt;code&gt;locale&lt;/code&gt; field.
     * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: Versions written by J2SE 1.6 or later, which include a
     *      new &lt;code&gt;exponentialSeparator&lt;/code&gt; field.
     * &lt;/ul&gt;
     * When streaming out a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt;, the most recent format
     * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)
     * is always written.
     *
     * @serial
     * @since JDK 1.1.6
     */
<span class="pc" id="L877">    private int serialVersionOnStream = currentSerialVersion;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>