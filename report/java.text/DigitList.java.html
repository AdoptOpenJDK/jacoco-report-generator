<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DigitList.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">DigitList.java</span></div><h1>DigitList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import sun.misc.FloatingDecimal;

/**
 * Digit List. Private to DecimalFormat.
 * Handles the transcoding
 * between numeric values and strings of characters.  Only handles
 * non-negative numbers.  The division of labor between DigitList and
 * DecimalFormat is that DigitList handles the radix 10 representation
 * issues; DecimalFormat handles the locale-specific issues such as
 * positive/negative, grouping, decimal point, currency, and so on.
 *
 * A DigitList is really a representation of a floating point value.
 * It may be an integer value; we assume that a double has sufficient
 * precision to represent all digits of a long.
 *
 * The DigitList representation consists of a string of characters,
 * which are the digits radix 10, from '0' to '9'.  It also has a radix
 * 10 exponent associated with it.  The value represented by a DigitList
 * object can be computed by mulitplying the fraction f, where 0 &lt;= f &lt; 1,
 * derived by placing all the digits of the list to the right of the
 * decimal point, by 10^exponent.
 *
 * @see  Locale
 * @see  Format
 * @see  NumberFormat
 * @see  DecimalFormat
 * @see  ChoiceFormat
 * @see  MessageFormat
 * @author       Mark Davis, Alan Liu
 */
<span class="fc bfc" id="L74" title="All 2 branches covered.">final class DigitList implements Cloneable {</span>
    /**
     * The maximum number of significant digits in an IEEE 754 double, that
     * is, in a Java double.  This must not be increased, or garbage digits
     * will be generated, and should not be decreased, or accuracy will be lost.
     */
    public static final int MAX_COUNT = 19; // == Long.toString(Long.MAX_VALUE).length()

    /**
     * These data members are intentionally public and can be set directly.
     *
     * The value represented is given by placing the decimal point before
     * digits[decimalAt].  If decimalAt is &lt; 0, then leading zeros between
     * the decimal point and the first nonzero digit are implied.  If decimalAt
     * is &gt; count, then trailing zeros between the digits[count-1] and the
     * decimal point are implied.
     *
     * Equivalently, the represented value is given by f * 10^decimalAt.  Here
     * f is a value 0.1 &lt;= f &lt; 1 arrived at by placing the digits in Digits to
     * the right of the decimal.
     *
     * DigitList is normalized, so if it is non-zero, figits[0] is non-zero.  We
     * don't allow denormalized numbers because our exponent is effectively of
     * unlimited magnitude.  The count value contains the number of significant
     * digits present in digits[].
     *
     * Zero is represented by any DigitList with count == 0 or with each digits[i]
     * for all i &lt;= count == '0'.
     */
<span class="fc" id="L103">    public int decimalAt = 0;</span>
<span class="fc" id="L104">    public int count = 0;</span>
<span class="fc" id="L105">    public char[] digits = new char[MAX_COUNT];</span>

    private char[] data;
<span class="fc" id="L108">    private RoundingMode roundingMode = RoundingMode.HALF_EVEN;</span>
<span class="fc" id="L109">    private boolean isNegative = false;</span>

    /**
     * Return true if the represented number is zero.
     */
    boolean isZero() {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        for (int i=0; i &lt; count; ++i) {</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">            if (digits[i] != '0') {</span>
<span class="fc" id="L117">                return false;</span>
            }
        }
<span class="nc" id="L120">        return true;</span>
    }

    /**
     * Set the rounding mode
     */
    void setRoundingMode(RoundingMode r) {
<span class="nc" id="L127">        roundingMode = r;</span>
<span class="nc" id="L128">    }</span>

    /**
     * Clears out the digits.
     * Use before appending them.
     * Typically, you set a series of digits with append, then at the point
     * you hit the decimal point, you set myDigitList.decimalAt = myDigitList.count;
     * then go on appending digits.
     */
    public void clear () {
<span class="nc" id="L138">        decimalAt = 0;</span>
<span class="nc" id="L139">        count = 0;</span>
<span class="nc" id="L140">    }</span>

    /**
     * Appends a digit to the list, extending the list when necessary.
     */
    public void append(char digit) {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (count == digits.length) {</span>
<span class="nc" id="L147">            char[] data = new char[count + 100];</span>
<span class="nc" id="L148">            System.arraycopy(digits, 0, data, 0, count);</span>
<span class="nc" id="L149">            digits = data;</span>
        }
<span class="fc" id="L151">        digits[count++] = digit;</span>
<span class="fc" id="L152">    }</span>

    /**
     * Utility routine to get the value of the digit list
     * If (count == 0) this throws a NumberFormatException, which
     * mimics Long.parseLong().
     */
    public final double getDouble() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc" id="L161">            return 0.0;</span>
        }

<span class="nc" id="L164">        StringBuffer temp = getStringBuffer();</span>
<span class="nc" id="L165">        temp.append('.');</span>
<span class="nc" id="L166">        temp.append(digits, 0, count);</span>
<span class="nc" id="L167">        temp.append('E');</span>
<span class="nc" id="L168">        temp.append(decimalAt);</span>
<span class="nc" id="L169">        return Double.parseDouble(temp.toString());</span>
    }

    /**
     * Utility routine to get the value of the digit list.
     * If (count == 0) this returns 0, unlike Long.parseLong().
     */
    public final long getLong() {
        // for now, simple implementation; later, do proper IEEE native stuff

<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L180">            return 0;</span>
        }

        // We have to check for this, because this is the one NEGATIVE value
        // we represent.  If we tried to just pass the digits off to parseLong,
        // we'd get a parse failure.
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (isLongMIN_VALUE()) {</span>
<span class="nc" id="L187">            return Long.MIN_VALUE;</span>
        }

<span class="fc" id="L190">        StringBuffer temp = getStringBuffer();</span>
<span class="fc" id="L191">        temp.append(digits, 0, count);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        for (int i = count; i &lt; decimalAt; ++i) {</span>
<span class="fc" id="L193">            temp.append('0');</span>
        }
<span class="fc" id="L195">        return Long.parseLong(temp.toString());</span>
    }

    public final BigDecimal getBigDecimal() {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (count == 0) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (decimalAt == 0) {</span>
<span class="nc" id="L201">                return BigDecimal.ZERO;</span>
            } else {
<span class="nc" id="L203">                return new BigDecimal(&quot;0E&quot; + decimalAt);</span>
            }
        }

<span class="nc bnc" id="L207" title="All 2 branches missed.">       if (decimalAt == count) {</span>
<span class="nc" id="L208">           return new BigDecimal(digits, 0, count);</span>
       } else {
<span class="nc" id="L210">           return new BigDecimal(digits, 0, count).scaleByPowerOfTen(decimalAt - count);</span>
       }
    }

    /**
     * Return true if the number represented by this object can fit into
     * a long.
     * @param isPositive true if this number should be regarded as positive
     * @param ignoreNegativeZero true if -0 should be regarded as identical to
     * +0; otherwise they are considered distinct
     * @return true if this number fits into a Java long
     */
    boolean fitsIntoLong(boolean isPositive, boolean ignoreNegativeZero) {
        // Figure out if the result will fit in a long.  We have to
        // first look for nonzero digits after the decimal point;
        // then check the size.  If the digit count is 18 or less, then
        // the value can definitely be represented as a long.  If it is 19
        // then it may be too large.

        // Trim trailing zeros.  This does not change the represented value.
<span class="fc bfc" id="L230" title="All 4 branches covered.">        while (count &gt; 0 &amp;&amp; digits[count - 1] == '0') {</span>
<span class="fc" id="L231">            --count;</span>
        }

<span class="fc bfc" id="L234" title="All 2 branches covered.">        if (count == 0) {</span>
            // Positive zero fits into a long, but negative zero can only
            // be represented as a double. - bug 4162852
<span class="pc bpc" id="L237" title="3 of 4 branches missed.">            return isPositive || ignoreNegativeZero;</span>
        }

<span class="pc bpc" id="L240" title="2 of 4 branches missed.">        if (decimalAt &lt; count || decimalAt &gt; MAX_COUNT) {</span>
<span class="nc" id="L241">            return false;</span>
        }

<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (decimalAt &lt; MAX_COUNT) return true;</span>

        // At this point we have decimalAt == count, and count == MAX_COUNT.
        // The number will overflow if it is larger than 9223372036854775807
        // or smaller than -9223372036854775808.
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for (int i=0; i&lt;count; ++i) {</span>
<span class="nc" id="L250">            char dig = digits[i], max = LONG_MIN_REP[i];</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (dig &gt; max) return false;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            if (dig &lt; max) return true;</span>
        }

        // At this point the first count digits match.  If decimalAt is less
        // than count, then the remaining digits are zero, and we return true.
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (count &lt; decimalAt) return true;</span>

        // Now we have a representation of Long.MIN_VALUE, without the leading
        // negative sign.  If this represents a positive value, then it does
        // not fit; otherwise it fits.
<span class="nc bnc" id="L262" title="All 2 branches missed.">        return !isPositive;</span>
    }

    /**
     * Set the digit list to a representation of the given double value.
     * This method supports fixed-point notation.
     * @param isNegative Boolean value indicating whether the number is negative.
     * @param source Value to be converted; must not be Inf, -Inf, Nan,
     * or a value &lt;= 0.
     * @param maximumFractionDigits The most fractional digits which should
     * be converted.
     */
    final void set(boolean isNegative, double source, int maximumFractionDigits) {
<span class="nc" id="L275">        set(isNegative, source, maximumFractionDigits, true);</span>
<span class="nc" id="L276">    }</span>

    /**
     * Set the digit list to a representation of the given double value.
     * This method supports both fixed-point and exponential notation.
     * @param isNegative Boolean value indicating whether the number is negative.
     * @param source Value to be converted; must not be Inf, -Inf, Nan,
     * or a value &lt;= 0.
     * @param maximumDigits The most fractional or total digits which should
     * be converted.
     * @param fixedPoint If true, then maximumDigits is the maximum
     * fractional digits to be converted.  If false, total digits.
     */
    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {

<span class="nc" id="L291">        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);</span>
<span class="nc" id="L292">        boolean hasBeenRoundedUp = fdConverter.digitsRoundedUp();</span>
<span class="nc" id="L293">        boolean allDecimalDigits = fdConverter.decimalDigitsExact();</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">        assert !fdConverter.isExceptional();</span>
<span class="nc" id="L295">        String digitsString = fdConverter.toJavaFormatString();</span>

<span class="nc" id="L297">        set(isNegative, digitsString,</span>
            hasBeenRoundedUp, allDecimalDigits,
            maximumDigits, fixedPoint);
<span class="nc" id="L300">    }</span>

    /**
     * Generate a representation of the form DDDDD, DDDDD.DDDDD, or
     * DDDDDE+/-DDDDD.
     * @param roundedUp Boolean value indicating if the s digits were rounded-up.
     * @param allDecimalDigits Boolean value indicating if the digits in s are
     * an exact decimal representation of the double that was passed.
     */
    private void set(boolean isNegative, String s,
                     boolean roundedUp, boolean allDecimalDigits,
                     int maximumDigits, boolean fixedPoint) {
<span class="nc" id="L312">        this.isNegative = isNegative;</span>
<span class="nc" id="L313">        int len = s.length();</span>
<span class="nc" id="L314">        char[] source = getDataChars(len);</span>
<span class="nc" id="L315">        s.getChars(0, len, source, 0);</span>

<span class="nc" id="L317">        decimalAt = -1;</span>
<span class="nc" id="L318">        count = 0;</span>
<span class="nc" id="L319">        int exponent = 0;</span>
        // Number of zeros between decimal point and first non-zero digit after
        // decimal point, for numbers &lt; 1.
<span class="nc" id="L322">        int leadingZerosAfterDecimal = 0;</span>
<span class="nc" id="L323">        boolean nonZeroDigitSeen = false;</span>

<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (int i = 0; i &lt; len; ) {</span>
<span class="nc" id="L326">            char c = source[i++];</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (c == '.') {</span>
<span class="nc" id="L328">                decimalAt = count;</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">            } else if (c == 'e' || c == 'E') {</span>
<span class="nc" id="L330">                exponent = parseInt(source, i, len);</span>
<span class="nc" id="L331">                break;</span>
            } else {
<span class="nc bnc" id="L333" title="All 2 branches missed.">                if (!nonZeroDigitSeen) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                    nonZeroDigitSeen = (c != '0');</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">                    if (!nonZeroDigitSeen &amp;&amp; decimalAt != -1)</span>
<span class="nc" id="L336">                        ++leadingZerosAfterDecimal;</span>
                }
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (nonZeroDigitSeen) {</span>
<span class="nc" id="L339">                    digits[count++] = c;</span>
                }
            }
<span class="nc" id="L342">        }</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (decimalAt == -1) {</span>
<span class="nc" id="L344">            decimalAt = count;</span>
        }
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (nonZeroDigitSeen) {</span>
<span class="nc" id="L347">            decimalAt += exponent - leadingZerosAfterDecimal;</span>
        }

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (fixedPoint) {</span>
            // The negative of the exponent represents the number of leading
            // zeros between the decimal and the first non-zero digit, for
            // a value &lt; 0.1 (e.g., for 0.00123, -decimalAt == 2).  If this
            // is more than the maximum fraction digits, then we have an underflow
            // for the printed representation.
<span class="nc bnc" id="L356" title="All 2 branches missed.">            if (-decimalAt &gt; maximumDigits) {</span>
                // Handle an underflow to zero when we round something like
                // 0.0009 to 2 fractional digits.
<span class="nc" id="L359">                count = 0;</span>
<span class="nc" id="L360">                return;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">            } else if (-decimalAt == maximumDigits) {</span>
                // If we round 0.0009 to 3 fractional digits, then we have to
                // create a new one digit in the least significant location.
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (shouldRoundUp(0, roundedUp, allDecimalDigits)) {</span>
<span class="nc" id="L365">                    count = 1;</span>
<span class="nc" id="L366">                    ++decimalAt;</span>
<span class="nc" id="L367">                    digits[0] = '1';</span>
                } else {
<span class="nc" id="L369">                    count = 0;</span>
                }
<span class="nc" id="L371">                return;</span>
            }
            // else fall through
        }

        // Eliminate trailing zeros.
<span class="nc bnc" id="L377" title="All 4 branches missed.">        while (count &gt; 1 &amp;&amp; digits[count - 1] == '0') {</span>
<span class="nc" id="L378">            --count;</span>
        }

        // Eliminate digits beyond maximum digits to be displayed.
        // Round up if appropriate.
<span class="nc bnc" id="L383" title="All 2 branches missed.">        round(fixedPoint ? (maximumDigits + decimalAt) : maximumDigits,</span>
              roundedUp, allDecimalDigits);
<span class="nc" id="L385">    }</span>

    /**
     * Round the representation to the given number of digits.
     * @param maximumDigits The maximum number of digits to be shown.
     * @param alreadyRounded Boolean indicating if rounding up already happened.
     * @param allDecimalDigits Boolean indicating if the digits provide an exact
     * representation of the value.
     *
     * Upon return, count will be less than or equal to maximumDigits.
     */
    private final void round(int maximumDigits,
                             boolean alreadyRounded,
                             boolean allDecimalDigits) {
        // Eliminate digits beyond maximum digits to be displayed.
        // Round up if appropriate.
<span class="nc bnc" id="L401" title="All 4 branches missed.">        if (maximumDigits &gt;= 0 &amp;&amp; maximumDigits &lt; count) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if (shouldRoundUp(maximumDigits, alreadyRounded, allDecimalDigits)) {</span>
                // Rounding up involved incrementing digits from LSD to MSD.
                // In most cases this is simple, but in a worst case situation
                // (9999..99) we have to adjust the decimalAt value.
                for (;;) {
<span class="nc" id="L407">                    --maximumDigits;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                    if (maximumDigits &lt; 0) {</span>
                        // We have all 9's, so we increment to a single digit
                        // of one and adjust the exponent.
<span class="nc" id="L411">                        digits[0] = '1';</span>
<span class="nc" id="L412">                        ++decimalAt;</span>
<span class="nc" id="L413">                        maximumDigits = 0; // Adjust the count</span>
<span class="nc" id="L414">                        break;</span>
                    }

<span class="nc" id="L417">                    ++digits[maximumDigits];</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                    if (digits[maximumDigits] &lt;= '9') break;</span>
                    // digits[maximumDigits] = '0'; // Unnecessary since we'll truncate this
                }
<span class="nc" id="L421">                ++maximumDigits; // Increment for use as count</span>
            }
<span class="nc" id="L423">            count = maximumDigits;</span>

            // Eliminate trailing zeros.
<span class="nc bnc" id="L426" title="All 4 branches missed.">            while (count &gt; 1 &amp;&amp; digits[count-1] == '0') {</span>
<span class="nc" id="L427">                --count;</span>
            }
        }
<span class="nc" id="L430">    }</span>


    /**
     * Return true if truncating the representation to the given number
     * of digits will result in an increment to the last digit.  This
     * method implements the rounding modes defined in the
     * java.math.RoundingMode class.
     * [bnf]
     * @param maximumDigits the number of digits to keep, from 0 to
     * &lt;code&gt;count-1&lt;/code&gt;.  If 0, then all digits are rounded away, and
     * this method returns true if a one should be generated (e.g., formatting
     * 0.09 with &quot;#.#&quot;).
     * @exception ArithmeticException if rounding is needed with rounding
     *            mode being set to RoundingMode.UNNECESSARY
     * @return true if digit &lt;code&gt;maximumDigits-1&lt;/code&gt; should be
     * incremented
     */
    private boolean shouldRoundUp(int maximumDigits,
                                  boolean alreadyRounded,
                                  boolean allDecimalDigits) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (maximumDigits &lt; count) {</span>
            /*
             * To avoid erroneous double-rounding or truncation when converting
             * a binary double value to text, information about the exactness
             * of the conversion result in FloatingDecimal, as well as any
             * rounding done, is needed in this class.
             *
             * - For the  HALF_DOWN, HALF_EVEN, HALF_UP rounding rules below:
             *   In the case of formating float or double, We must take into
             *   account what FloatingDecimal has done in the binary to decimal
             *   conversion.
             *
             *   Considering the tie cases, FloatingDecimal may round-up the
             *   value (returning decimal digits equal to tie when it is below),
             *   or &quot;truncate&quot; the value to the tie while value is above it,
             *   or provide the exact decimal digits when the binary value can be
             *   converted exactly to its decimal representation given formating
             *   rules of FloatingDecimal ( we have thus an exact decimal
             *   representation of the binary value).
             *
             *   - If the double binary value was converted exactly as a decimal
             *     value, then DigitList code must apply the expected rounding
             *     rule.
             *
             *   - If FloatingDecimal already rounded up the decimal value,
             *     DigitList should neither round up the value again in any of
             *     the three rounding modes above.
             *
             *   - If FloatingDecimal has truncated the decimal value to
             *     an ending '5' digit, DigitList should round up the value in
             *     all of the three rounding modes above.
             *
             *
             *   This has to be considered only if digit at maximumDigits index
             *   is exactly the last one in the set of digits, otherwise there are
             *   remaining digits after that position and we don't have to consider
             *   what FloatingDecimal did.
             *
             * - Other rounding modes are not impacted by these tie cases.
             *
             * - For other numbers that are always converted to exact digits
             *   (like BigInteger, Long, ...), the passed alreadyRounded boolean
             *   have to be  set to false, and allDecimalDigits has to be set to
             *   true in the upper DigitList call stack, providing the right state
             *   for those situations..
             */

<span class="nc bnc" id="L498" title="All 9 branches missed.">            switch(roundingMode) {</span>
            case UP:
<span class="nc bnc" id="L500" title="All 2 branches missed.">                for (int i=maximumDigits; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">                    if (digits[i] != '0') {</span>
<span class="nc" id="L502">                        return true;</span>
                    }
                }
<span class="nc" id="L505">                break;</span>
            case DOWN:
<span class="nc" id="L507">                break;</span>
            case CEILING:
<span class="nc bnc" id="L509" title="All 2 branches missed.">                for (int i=maximumDigits; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                    if (digits[i] != '0') {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                        return !isNegative;</span>
                    }
                }
<span class="nc" id="L514">                break;</span>
            case FLOOR:
<span class="nc bnc" id="L516" title="All 2 branches missed.">                for (int i=maximumDigits; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    if (digits[i] != '0') {</span>
<span class="nc" id="L518">                        return isNegative;</span>
                    }
                }
<span class="nc" id="L521">                break;</span>
            case HALF_UP:
<span class="nc bnc" id="L523" title="All 2 branches missed.">                if (digits[maximumDigits] &gt;= '5') {</span>
                    // We should not round up if the rounding digits position is
                    // exactly the last index and if digits were already rounded.
<span class="nc bnc" id="L526" title="All 4 branches missed.">                    if ((maximumDigits == (count - 1)) &amp;&amp;</span>
                        (alreadyRounded))
<span class="nc" id="L528">                        return false;</span>

                    // Value was exactly at or was above tie. We must round up.
<span class="nc" id="L531">                    return true;</span>
                }
                break;
            case HALF_DOWN:
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (digits[maximumDigits] &gt; '5') {</span>
<span class="nc" id="L536">                    return true;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                } else if (digits[maximumDigits] == '5' ) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                    if (maximumDigits == (count - 1)) {</span>
                        // The rounding position is exactly the last index.
<span class="nc bnc" id="L540" title="All 4 branches missed.">                        if (allDecimalDigits || alreadyRounded)</span>
                            /* FloatingDecimal rounded up (value was below tie),
                             * or provided the exact list of digits (value was
                             * an exact tie). We should not round up, following
                             * the HALF_DOWN rounding rule.
                             */
<span class="nc" id="L546">                            return false;</span>
                        else
                            // Value was above the tie, we must round up.
<span class="nc" id="L549">                            return true;</span>
                    }

                    // We must round up if it gives a non null digit after '5'.
<span class="nc bnc" id="L553" title="All 2 branches missed.">                    for (int i=maximumDigits+1; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                        if (digits[i] != '0') {</span>
<span class="nc" id="L555">                            return true;</span>
                        }
                    }
                }
                break;
            case HALF_EVEN:
                // Implement IEEE half-even rounding
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if (digits[maximumDigits] &gt; '5') {</span>
<span class="nc" id="L563">                    return true;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                } else if (digits[maximumDigits] == '5' ) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                    if (maximumDigits == (count - 1)) {</span>
                        // the rounding position is exactly the last index :
<span class="nc bnc" id="L567" title="All 2 branches missed.">                        if (alreadyRounded)</span>
                            // If FloatingDecimal rounded up (value was below tie),
                            // then we should not round up again.
<span class="nc" id="L570">                            return false;</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">                        if (!allDecimalDigits)</span>
                            // Otherwise if the digits don't represent exact value,
                            // value was above tie and FloatingDecimal truncated
                            // digits to tie. We must round up.
<span class="nc" id="L576">                            return true;</span>
                        else {
                            // This is an exact tie value, and FloatingDecimal
                            // provided all of the exact digits. We thus apply
                            // HALF_EVEN rounding rule.
<span class="nc bnc" id="L581" title="All 4 branches missed.">                            return ((maximumDigits &gt; 0) &amp;&amp;</span>
                                    (digits[maximumDigits-1] % 2 != 0));
                        }
                    } else {
                        // Rounds up if it gives a non null digit after '5'
<span class="nc bnc" id="L586" title="All 2 branches missed.">                        for (int i=maximumDigits+1; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                            if (digits[i] != '0')</span>
<span class="nc" id="L588">                                return true;</span>
                        }
                    }
                }
                break;
            case UNNECESSARY:
<span class="nc bnc" id="L594" title="All 2 branches missed.">                for (int i=maximumDigits; i&lt;count; ++i) {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                    if (digits[i] != '0') {</span>
<span class="nc" id="L596">                        throw new ArithmeticException(</span>
                            &quot;Rounding needed with the rounding mode being set to RoundingMode.UNNECESSARY&quot;);
                    }
                }
<span class="nc" id="L600">                break;</span>
            default:
<span class="nc bnc" id="L602" title="All 2 branches missed.">                assert false;</span>
            }
        }
<span class="nc" id="L605">        return false;</span>
    }

    /**
     * Utility routine to set the value of the digit list from a long
     */
    final void set(boolean isNegative, long source) {
<span class="nc" id="L612">        set(isNegative, source, 0);</span>
<span class="nc" id="L613">    }</span>

    /**
     * Set the digit list to a representation of the given long value.
     * @param isNegative Boolean value indicating whether the number is negative.
     * @param source Value to be converted; must be &gt;= 0 or ==
     * Long.MIN_VALUE.
     * @param maximumDigits The most digits which should be converted.
     * If maximumDigits is lower than the number of significant digits
     * in source, the representation will be rounded.  Ignored if &lt;= 0.
     */
    final void set(boolean isNegative, long source, int maximumDigits) {
<span class="fc" id="L625">        this.isNegative = isNegative;</span>

        // This method does not expect a negative number. However,
        // &quot;source&quot; can be a Long.MIN_VALUE (-9223372036854775808),
        // if the number being formatted is a Long.MIN_VALUE.  In that
        // case, it will be formatted as -Long.MIN_VALUE, a number
        // which is outside the legal range of a long, but which can
        // be represented by DigitList.
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (source &lt;= 0) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (source == Long.MIN_VALUE) {</span>
<span class="nc" id="L635">                decimalAt = count = MAX_COUNT;</span>
<span class="nc" id="L636">                System.arraycopy(LONG_MIN_REP, 0, digits, 0, count);</span>
            } else {
<span class="nc" id="L638">                decimalAt = count = 0; // Values &lt;= 0 format as zero</span>
            }
        } else {
            // Rewritten to improve performance.  I used to call
            // Long.toString(), which was about 4x slower than this code.
<span class="fc" id="L643">            int left = MAX_COUNT;</span>
            int right;
<span class="fc bfc" id="L645" title="All 2 branches covered.">            while (source &gt; 0) {</span>
<span class="fc" id="L646">                digits[--left] = (char)('0' + (source % 10));</span>
<span class="fc" id="L647">                source /= 10;</span>
            }
<span class="fc" id="L649">            decimalAt = MAX_COUNT - left;</span>
            // Don't copy trailing zeros.  We are guaranteed that there is at
            // least one non-zero digit, so we don't have to check lower bounds.
<span class="fc bfc" id="L652" title="All 2 branches covered.">            for (right = MAX_COUNT - 1; digits[right] == '0'; --right)</span>
                ;
<span class="fc" id="L654">            count = right - left + 1;</span>
<span class="fc" id="L655">            System.arraycopy(digits, left, digits, 0, count);</span>
        }
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (maximumDigits &gt; 0) round(maximumDigits, false, true);</span>
<span class="fc" id="L658">    }</span>

    /**
     * Set the digit list to a representation of the given BigDecimal value.
     * This method supports both fixed-point and exponential notation.
     * @param isNegative Boolean value indicating whether the number is negative.
     * @param source Value to be converted; must not be a value &lt;= 0.
     * @param maximumDigits The most fractional or total digits which should
     * be converted.
     * @param fixedPoint If true, then maximumDigits is the maximum
     * fractional digits to be converted.  If false, total digits.
     */
    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {
<span class="nc" id="L671">        String s = source.toString();</span>
<span class="nc" id="L672">        extendDigits(s.length());</span>

<span class="nc" id="L674">        set(isNegative, s,</span>
            false, true,
            maximumDigits, fixedPoint);
<span class="nc" id="L677">    }</span>

    /**
     * Set the digit list to a representation of the given BigInteger value.
     * @param isNegative Boolean value indicating whether the number is negative.
     * @param source Value to be converted; must be &gt;= 0.
     * @param maximumDigits The most digits which should be converted.
     * If maximumDigits is lower than the number of significant digits
     * in source, the representation will be rounded.  Ignored if &lt;= 0.
     */
    final void set(boolean isNegative, BigInteger source, int maximumDigits) {
<span class="nc" id="L688">        this.isNegative = isNegative;</span>
<span class="nc" id="L689">        String s = source.toString();</span>
<span class="nc" id="L690">        int len = s.length();</span>
<span class="nc" id="L691">        extendDigits(len);</span>
<span class="nc" id="L692">        s.getChars(0, len, digits, 0);</span>

<span class="nc" id="L694">        decimalAt = len;</span>
        int right;
<span class="nc bnc" id="L696" title="All 4 branches missed.">        for (right = len - 1; right &gt;= 0 &amp;&amp; digits[right] == '0'; --right)</span>
            ;
<span class="nc" id="L698">        count = right + 1;</span>

<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (maximumDigits &gt; 0) {</span>
<span class="nc" id="L701">            round(maximumDigits, false, true);</span>
        }
<span class="nc" id="L703">    }</span>

    /**
     * equality test between two digit lists.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (this == obj)                      // quick check</span>
<span class="nc" id="L710">            return true;</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (!(obj instanceof DigitList))         // (1) same object?</span>
<span class="nc" id="L712">            return false;</span>
<span class="nc" id="L713">        DigitList other = (DigitList) obj;</span>
<span class="nc bnc" id="L714" title="All 4 branches missed.">        if (count != other.count ||</span>
        decimalAt != other.decimalAt)
<span class="nc" id="L716">            return false;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (digits[i] != other.digits[i])</span>
<span class="nc" id="L719">                return false;</span>
<span class="nc" id="L720">        return true;</span>
    }

    /**
     * Generates the hash code for the digit list.
     */
    public int hashCode() {
<span class="nc" id="L727">        int hashcode = decimalAt;</span>

<span class="nc bnc" id="L729" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L730">            hashcode = hashcode * 37 + digits[i];</span>
        }

<span class="nc" id="L733">        return hashcode;</span>
    }

    /**
     * Creates a copy of this object.
     * @return a clone of this instance.
     */
    public Object clone() {
        try {
<span class="fc" id="L742">            DigitList other = (DigitList) super.clone();</span>
<span class="fc" id="L743">            char[] newDigits = new char[digits.length];</span>
<span class="fc" id="L744">            System.arraycopy(digits, 0, newDigits, 0, digits.length);</span>
<span class="fc" id="L745">            other.digits = newDigits;</span>
<span class="fc" id="L746">            other.tempBuffer = null;</span>
<span class="fc" id="L747">            return other;</span>
<span class="nc" id="L748">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L749">            throw new InternalError(e);</span>
        }
    }

    /**
     * Returns true if this DigitList represents Long.MIN_VALUE;
     * false, otherwise.  This is required so that getLong() works.
     */
    private boolean isLongMIN_VALUE() {
<span class="pc bpc" id="L758" title="1 of 4 branches missed.">        if (decimalAt != count || count != MAX_COUNT) {</span>
<span class="fc" id="L759">            return false;</span>
        }

<span class="nc bnc" id="L762" title="All 2 branches missed.">        for (int i = 0; i &lt; count; ++i) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (digits[i] != LONG_MIN_REP[i]) return false;</span>
        }

<span class="nc" id="L766">        return true;</span>
    }

    private static final int parseInt(char[] str, int offset, int strLen) {
        char c;
<span class="nc" id="L771">        boolean positive = true;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if ((c = str[offset]) == '-') {</span>
<span class="nc" id="L773">            positive = false;</span>
<span class="nc" id="L774">            offset++;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">        } else if (c == '+') {</span>
<span class="nc" id="L776">            offset++;</span>
        }

<span class="nc" id="L779">        int value = 0;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        while (offset &lt; strLen) {</span>
<span class="nc" id="L781">            c = str[offset++];</span>
<span class="nc bnc" id="L782" title="All 4 branches missed.">            if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="nc" id="L783">                value = value * 10 + (c - '0');</span>
            } else {
                break;
            }
        }
<span class="nc bnc" id="L788" title="All 2 branches missed.">        return positive ? value : -value;</span>
    }

    // The digit part of -9223372036854775808L
<span class="fc" id="L792">    private static final char[] LONG_MIN_REP = &quot;9223372036854775808&quot;.toCharArray();</span>

    public String toString() {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (isZero()) {</span>
<span class="nc" id="L796">            return &quot;0&quot;;</span>
        }
<span class="nc" id="L798">        StringBuffer buf = getStringBuffer();</span>
<span class="nc" id="L799">        buf.append(&quot;0.&quot;);</span>
<span class="nc" id="L800">        buf.append(digits, 0, count);</span>
<span class="nc" id="L801">        buf.append(&quot;x10^&quot;);</span>
<span class="nc" id="L802">        buf.append(decimalAt);</span>
<span class="nc" id="L803">        return buf.toString();</span>
    }

    private StringBuffer tempBuffer;

    private StringBuffer getStringBuffer() {
<span class="fc bfc" id="L809" title="All 2 branches covered.">        if (tempBuffer == null) {</span>
<span class="fc" id="L810">            tempBuffer = new StringBuffer(MAX_COUNT);</span>
        } else {
<span class="fc" id="L812">            tempBuffer.setLength(0);</span>
        }
<span class="fc" id="L814">        return tempBuffer;</span>
    }

    private void extendDigits(int len) {
<span class="nc bnc" id="L818" title="All 2 branches missed.">        if (len &gt; digits.length) {</span>
<span class="nc" id="L819">            digits = new char[len];</span>
        }
<span class="nc" id="L821">    }</span>

    private final char[] getDataChars(int length) {
<span class="nc bnc" id="L824" title="All 4 branches missed.">        if (data == null || data.length &lt; length) {</span>
<span class="nc" id="L825">            data = new char[length];</span>
        }
<span class="nc" id="L827">        return data;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>