<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MessageFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">MessageFormat.java</span></div><h1>MessageFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.InvalidObjectException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;


/**
 * &lt;code&gt;MessageFormat&lt;/code&gt; provides a means to produce concatenated
 * messages in a language-neutral way. Use this to construct messages
 * displayed for end users.
 *
 * &lt;p&gt;
 * &lt;code&gt;MessageFormat&lt;/code&gt; takes a set of objects, formats them, then
 * inserts the formatted strings into the pattern at the appropriate places.
 *
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt;
 * &lt;code&gt;MessageFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
 * classes in that you create a &lt;code&gt;MessageFormat&lt;/code&gt; object with one
 * of its constructors (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
 * method). The factory methods aren't necessary because &lt;code&gt;MessageFormat&lt;/code&gt;
 * itself doesn't implement locale specific behavior. Any locale specific
 * behavior is defined by the pattern that you provide as well as the
 * subformats used for inserted arguments.
 *
 * &lt;h3&gt;&lt;a name=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;code&gt;MessageFormat&lt;/code&gt; uses patterns of the following form:
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
 *         &lt;i&gt;String&lt;/i&gt;
 *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
 *
 * &lt;i&gt;FormatElement:&lt;/i&gt;
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
 *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
 *
 * &lt;i&gt;FormatType: one of &lt;/i&gt;
 *         number date time choice
 *
 * &lt;i&gt;FormatStyle:&lt;/i&gt;
 *         short
 *         medium
 *         long
 *         full
 *         integer
 *         currency
 *         percent
 *         &lt;i&gt;SubformatPattern&lt;/i&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
 * quote any arbitrary characters except single quotes. For example,
 * pattern string &lt;code&gt;&quot;'{0}'&quot;&lt;/code&gt; represents string
 * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
 * must be represented by doubled single quotes {@code ''} throughout a
 * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;'{''}'&quot;&lt;/code&gt; is
 * interpreted as a sequence of &lt;code&gt;'{&lt;/code&gt; (start of quoting and a
 * left curly brace), &lt;code&gt;''&lt;/code&gt; (a single quote), and
 * &lt;code&gt;}'&lt;/code&gt; (a right curly brace and end of quoting),
 * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;'{'&lt;/code&gt; and &lt;code&gt;'}'&lt;/code&gt; (quoted left and
 * right curly braces): representing string &lt;code&gt;&quot;{'}&quot;&lt;/code&gt;,
 * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 *
 * &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
 * subformat, and subformat-dependent pattern rules apply. For example,
 * pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$'#',##&lt;/u&gt;}&quot;&lt;/code&gt;
 * (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
 * with the pound-sign quoted, with a result such as: {@code
 * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
 * details.
 *
 * &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
 * pattern. For example, pattern string {@code &quot;'{0}&quot;} is treated as
 * pattern {@code &quot;'{0}'&quot;}.
 *
 * &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
 * example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab '}' de&quot;&lt;/code&gt; are
 * valid patterns, but &lt;code&gt;&quot;ab {0'}' de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
 * and &lt;code&gt;&quot;''{''&quot;&lt;/code&gt; are not.
 *
 * &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
 * format patterns unfortunately have shown to be somewhat confusing.
 * In particular, it isn't always obvious to localizers whether single
 * quotes need to be doubled or not. Make sure to inform localizers about
 * the rules, and tell them (for example, by using comments in resource
 * bundle source files) which strings will be processed by {@code MessageFormat}.
 * Note that localizers may need to use single quotes in translated
 * strings where the original version doesn't have them.
 * &lt;/dl&gt;
 * &lt;p&gt;
 * The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
 * using the digits {@code '0'} through {@code '9'}, and represents an index into the
 * {@code arguments} array passed to the {@code format} methods
 * or the result array returned by the {@code parse} methods.
 * &lt;p&gt;
 * The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
 * a {@code Format} instance for the format element. The following
 * table shows how the values map to {@code Format} instances. Combinations not
 * shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
 * be a valid pattern string for the {@code Format} subclass used.
 *
 * &lt;table border=1 summary=&quot;Shows how FormatType and FormatStyle values map to Format instances&quot;&gt;
 *    &lt;tr&gt;
 *       &lt;th id=&quot;ft&quot; class=&quot;TableHeadingColor&quot;&gt;FormatType
 *       &lt;th id=&quot;fs&quot; class=&quot;TableHeadingColor&quot;&gt;FormatStyle
 *       &lt;th id=&quot;sc&quot; class=&quot;TableHeadingColor&quot;&gt;Subformat Created
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;ft&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;&lt;code&gt;null&lt;/code&gt;
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;ft&quot; rowspan=5&gt;&lt;code&gt;number&lt;/code&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;integer&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;currency&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;percent&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;date&lt;/code&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;ft&quot; rowspan=6&gt;&lt;code&gt;time&lt;/code&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;short&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;medium&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;long&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;code&gt;full&lt;/code&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 *    &lt;tr&gt;
 *       &lt;td headers=&quot;ft&quot;&gt;&lt;code&gt;choice&lt;/code&gt;
 *       &lt;td headers=&quot;fs&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 *       &lt;td headers=&quot;sc&quot;&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 * &lt;/table&gt;
 *
 * &lt;h4&gt;Usage Information&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Here are some examples of usage.
 * In real internationalized programs, the message format pattern and other
 * static strings will, of course, be obtained from resource bundles.
 * Other parameters will be dynamically determined at runtime.
 * &lt;p&gt;
 * The first example uses the static method &lt;code&gt;MessageFormat.format&lt;/code&gt;,
 * which internally creates a &lt;code&gt;MessageFormat&lt;/code&gt; for one-time use:
 * &lt;blockquote&gt;&lt;pre&gt;
 * int planet = 7;
 * String event = &quot;a disturbance in the Force&quot;;
 *
 * String result = MessageFormat.format(
 *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 *     planet, new Date(), event);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output is:
 * &lt;blockquote&gt;&lt;pre&gt;
 * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * The following example creates a &lt;code&gt;MessageFormat&lt;/code&gt; instance that
 * can be used repeatedly:
 * &lt;blockquote&gt;&lt;pre&gt;
 * int fileCount = 1273;
 * String diskName = &quot;MyDisk&quot;;
 * Object[] testArgs = {new Long(fileCount), diskName};
 *
 * MessageFormat form = new MessageFormat(
 *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 *
 * System.out.println(form.format(testArgs));
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 * &lt;blockquote&gt;&lt;pre&gt;
 * The disk &quot;MyDisk&quot; contains 0 file(s).
 * The disk &quot;MyDisk&quot; contains 1 file(s).
 * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * For more sophisticated patterns, you can use a &lt;code&gt;ChoiceFormat&lt;/code&gt;
 * to produce correct forms for singular and plural:
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 * double[] filelimits = {0,1,2};
 * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 * form.setFormatByArgumentIndex(0, fileform);
 *
 * int fileCount = 1273;
 * String diskName = &quot;MyDisk&quot;;
 * Object[] testArgs = {new Long(fileCount), diskName};
 *
 * System.out.println(form.format(testArgs));
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The output with different values for &lt;code&gt;fileCount&lt;/code&gt;:
 * &lt;blockquote&gt;&lt;pre&gt;
 * The disk &quot;MyDisk&quot; contains no files.
 * The disk &quot;MyDisk&quot; contains one file.
 * The disk &quot;MyDisk&quot; contains 1,273 files.
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * You can create the &lt;code&gt;ChoiceFormat&lt;/code&gt; programmatically, as in the
 * above example, or by using a pattern. See {@link ChoiceFormat}
 * for more information.
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * form.applyPattern(
 *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
 * by a &lt;code&gt;ChoiceFormat&lt;/code&gt; in &lt;code&gt;MessageFormat&lt;/code&gt; is treated as special;
 * occurrences of '{' are used to indicate subformats, and cause recursion.
 * If you create both a &lt;code&gt;MessageFormat&lt;/code&gt; and &lt;code&gt;ChoiceFormat&lt;/code&gt;
 * programmatically (instead of using the string patterns), then be careful not to
 * produce a format that recurses on itself, which will cause an infinite loop.
 * &lt;p&gt;
 * When a single argument is parsed more than once in the string, the last match
 * will be the final result of the parsing.  For example,
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 * Object[] objs = {new Double(3.1415)};
 * String result = mf.format( objs );
 * // result now equals &quot;3.14, 3.1&quot;
 * objs = null;
 * objs = mf.parse(result, new ParsePosition(0));
 * // objs now equals {new Double(3.1)}
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * Likewise, parsing with a {@code MessageFormat} object using patterns containing
 * multiple occurrences of the same argument would return the last match.  For
 * example,
 * &lt;blockquote&gt;&lt;pre&gt;
 * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 * String forParsing = &quot;x, y, z&quot;;
 * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 * // result now equals {new String(&quot;z&quot;)}
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Message formats are not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 * @see          java.util.Locale
 * @see          Format
 * @see          NumberFormat
 * @see          DecimalFormat
 * @see          DecimalFormatSymbols
 * @see          ChoiceFormat
 * @see          DateFormat
 * @see          SimpleDateFormat
 *
 * @author       Mark Davis
 */

public class MessageFormat extends Format {

    private static final long serialVersionUID = 6479157306784022952L;

    /**
     * Constructs a MessageFormat for the default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
     * specified pattern.
     * The constructor first sets the locale, then parses the pattern and
     * creates a list of subformats for the format elements contained in it.
     * Patterns and their interpretation are specified in the
     * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
     *
     * @param pattern the pattern for this message format
     * @exception IllegalArgumentException if the pattern is invalid
     */
<span class="fc" id="L360">    public MessageFormat(String pattern) {</span>
<span class="fc" id="L361">        this.locale = Locale.getDefault(Locale.Category.FORMAT);</span>
<span class="fc" id="L362">        applyPattern(pattern);</span>
<span class="fc" id="L363">    }</span>

    /**
     * Constructs a MessageFormat for the specified locale and
     * pattern.
     * The constructor first sets the locale, then parses the pattern and
     * creates a list of subformats for the format elements contained in it.
     * Patterns and their interpretation are specified in the
     * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
     *
     * @param pattern the pattern for this message format
     * @param locale the locale for this message format
     * @exception IllegalArgumentException if the pattern is invalid
     * @since 1.4
     */
<span class="fc" id="L378">    public MessageFormat(String pattern, Locale locale) {</span>
<span class="fc" id="L379">        this.locale = locale;</span>
<span class="fc" id="L380">        applyPattern(pattern);</span>
<span class="fc" id="L381">    }</span>

    /**
     * Sets the locale to be used when creating or comparing subformats.
     * This affects subsequent calls
     * &lt;ul&gt;
     * &lt;li&gt;to the {@link #applyPattern applyPattern}
     *     and {@link #toPattern toPattern} methods if format elements specify
     *     a format type and therefore have the subformats created in the
     *     &lt;code&gt;applyPattern&lt;/code&gt; method, as well as
     * &lt;li&gt;to the &lt;code&gt;format&lt;/code&gt; and
     *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
     *     if format elements do not specify a format type and therefore have
     *     the subformats created in the formatting methods.
     * &lt;/ul&gt;
     * Subformats that have already been created are not affected.
     *
     * @param locale the locale to be used when creating or comparing subformats
     */
    public void setLocale(Locale locale) {
<span class="nc" id="L401">        this.locale = locale;</span>
<span class="nc" id="L402">    }</span>

    /**
     * Gets the locale that's used when creating or comparing subformats.
     *
     * @return the locale used when creating or comparing subformats
     */
    public Locale getLocale() {
<span class="nc" id="L410">        return locale;</span>
    }


    /**
     * Sets the pattern used by this message format.
     * The method parses the pattern and creates a list of subformats
     * for the format elements contained in it.
     * Patterns and their interpretation are specified in the
     * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
     *
     * @param pattern the pattern for this message format
     * @exception IllegalArgumentException if the pattern is invalid
     */
    @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
    public void applyPattern(String pattern) {
<span class="fc" id="L426">            StringBuilder[] segments = new StringBuilder[4];</span>
            // Allocate only segments[SEG_RAW] here. The rest are
            // allocated on demand.
<span class="fc" id="L429">            segments[SEG_RAW] = new StringBuilder();</span>

<span class="fc" id="L431">            int part = SEG_RAW;</span>
<span class="fc" id="L432">            int formatNumber = 0;</span>
<span class="fc" id="L433">            boolean inQuote = false;</span>
<span class="fc" id="L434">            int braceStack = 0;</span>
<span class="fc" id="L435">            maxOffset = -1;</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">            for (int i = 0; i &lt; pattern.length(); ++i) {</span>
<span class="fc" id="L437">                char ch = pattern.charAt(i);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">                if (part == SEG_RAW) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">                    if (ch == '\'') {</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">                        if (i + 1 &lt; pattern.length()</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                            &amp;&amp; pattern.charAt(i+1) == '\'') {</span>
<span class="fc" id="L442">                            segments[part].append(ch);  // handle doubles</span>
<span class="fc" id="L443">                            ++i;</span>
                        } else {
<span class="nc bnc" id="L445" title="All 2 branches missed.">                            inQuote = !inQuote;</span>
                        }
<span class="pc bpc" id="L447" title="1 of 4 branches missed.">                    } else if (ch == '{' &amp;&amp; !inQuote) {</span>
<span class="fc" id="L448">                        part = SEG_INDEX;</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">                        if (segments[SEG_INDEX] == null) {</span>
<span class="fc" id="L450">                            segments[SEG_INDEX] = new StringBuilder();</span>
                        }
                    } else {
<span class="fc" id="L453">                        segments[part].append(ch);</span>
                    }
                } else  {
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                    if (inQuote) {              // just copy quotes in parts</span>
<span class="nc" id="L457">                        segments[part].append(ch);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                        if (ch == '\'') {</span>
<span class="nc" id="L459">                            inQuote = false;</span>
                        }
                    } else {
<span class="pc bpc" id="L462" title="1 of 6 branches missed.">                        switch (ch) {</span>
                        case ',':
<span class="fc bfc" id="L464" title="All 2 branches covered.">                            if (part &lt; SEG_MODIFIER) {</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                                if (segments[++part] == null) {</span>
<span class="fc" id="L466">                                    segments[part] = new StringBuilder();</span>
                                }
                            } else {
<span class="fc" id="L469">                                segments[part].append(ch);</span>
                            }
<span class="fc" id="L471">                            break;</span>
                        case '{':
<span class="fc" id="L473">                            ++braceStack;</span>
<span class="fc" id="L474">                            segments[part].append(ch);</span>
<span class="fc" id="L475">                            break;</span>
                        case '}':
<span class="fc bfc" id="L477" title="All 2 branches covered.">                            if (braceStack == 0) {</span>
<span class="fc" id="L478">                                part = SEG_RAW;</span>
<span class="fc" id="L479">                                makeFormat(i, formatNumber, segments);</span>
<span class="fc" id="L480">                                formatNumber++;</span>
                                // throw away other segments
<span class="fc" id="L482">                                segments[SEG_INDEX] = null;</span>
<span class="fc" id="L483">                                segments[SEG_TYPE] = null;</span>
<span class="fc" id="L484">                                segments[SEG_MODIFIER] = null;</span>
                            } else {
<span class="fc" id="L486">                                --braceStack;</span>
<span class="fc" id="L487">                                segments[part].append(ch);</span>
                            }
<span class="fc" id="L489">                            break;</span>
                        case ' ':
                            // Skip any leading space chars for SEG_TYPE.
<span class="pc bpc" id="L492" title="3 of 4 branches missed.">                            if (part != SEG_TYPE || segments[SEG_TYPE].length() &gt; 0) {</span>
<span class="fc" id="L493">                                segments[part].append(ch);</span>
                            }
                            break;
                        case '\'':
<span class="nc" id="L497">                            inQuote = true;</span>
                            // fall through, so we keep quotes in other parts
                        default:
<span class="fc" id="L500">                            segments[part].append(ch);</span>
                            break;
                        }
                    }
                }
            }
<span class="pc bpc" id="L506" title="2 of 4 branches missed.">            if (braceStack == 0 &amp;&amp; part != 0) {</span>
<span class="nc" id="L507">                maxOffset = -1;</span>
<span class="nc" id="L508">                throw new IllegalArgumentException(&quot;Unmatched braces in the pattern.&quot;);</span>
            }
<span class="fc" id="L510">            this.pattern = segments[0].toString();</span>
<span class="fc" id="L511">    }</span>


    /**
     * Returns a pattern representing the current state of the message format.
     * The string is constructed from internal information and therefore
     * does not necessarily equal the previously applied pattern.
     *
     * @return a pattern representing the current state of the message format
     */
    public String toPattern() {
        // later, make this more extensible
<span class="fc" id="L523">        int lastOffset = 0;</span>
<span class="fc" id="L524">        StringBuilder result = new StringBuilder();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        for (int i = 0; i &lt;= maxOffset; ++i) {</span>
<span class="fc" id="L526">            copyAndFixQuotes(pattern, lastOffset, offsets[i], result);</span>
<span class="fc" id="L527">            lastOffset = offsets[i];</span>
<span class="fc" id="L528">            result.append('{').append(argumentNumbers[i]);</span>
<span class="fc" id="L529">            Format fmt = formats[i];</span>
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">            if (fmt == null) {</span>
                // do nothing, string format
<span class="fc bfc" id="L532" title="All 2 branches covered.">            } else if (fmt instanceof NumberFormat) {</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                if (fmt.equals(NumberFormat.getInstance(locale))) {</span>
<span class="fc" id="L534">                    result.append(&quot;,number&quot;);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">                } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {</span>
<span class="fc" id="L536">                    result.append(&quot;,number,currency&quot;);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {</span>
<span class="fc" id="L538">                    result.append(&quot;,number,percent&quot;);</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {</span>
<span class="fc" id="L540">                    result.append(&quot;,number,integer&quot;);</span>
                } else {
<span class="nc bnc" id="L542" title="All 2 branches missed.">                    if (fmt instanceof DecimalFormat) {</span>
<span class="nc" id="L543">                        result.append(&quot;,number,&quot;).append(((DecimalFormat)fmt).toPattern());</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    } else if (fmt instanceof ChoiceFormat) {</span>
<span class="nc" id="L545">                        result.append(&quot;,choice,&quot;).append(((ChoiceFormat)fmt).toPattern());</span>
                    } else {
                        // UNKNOWN
                    }
                }
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">            } else if (fmt instanceof DateFormat) {</span>
                int index;
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">                for (index = MODIFIER_DEFAULT; index &lt; DATE_TIME_MODIFIERS.length; index++) {</span>
<span class="fc" id="L553">                    DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index],</span>
                                                               locale);
<span class="fc bfc" id="L555" title="All 2 branches covered.">                    if (fmt.equals(df)) {</span>
<span class="fc" id="L556">                        result.append(&quot;,date&quot;);</span>
<span class="fc" id="L557">                        break;</span>
                    }
<span class="fc" id="L559">                    df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index],</span>
                                                    locale);
<span class="fc bfc" id="L561" title="All 2 branches covered.">                    if (fmt.equals(df)) {</span>
<span class="fc" id="L562">                        result.append(&quot;,time&quot;);</span>
<span class="fc" id="L563">                        break;</span>
                    }
                }
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">                if (index &gt;= DATE_TIME_MODIFIERS.length) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    if (fmt instanceof SimpleDateFormat) {</span>
<span class="nc" id="L568">                        result.append(&quot;,date,&quot;).append(((SimpleDateFormat)fmt).toPattern());</span>
                    } else {
                        // UNKNOWN
                    }
<span class="fc bfc" id="L572" title="All 2 branches covered.">                } else if (index != MODIFIER_DEFAULT) {</span>
<span class="fc" id="L573">                    result.append(',').append(DATE_TIME_MODIFIER_KEYWORDS[index]);</span>
                }
            } else {
                //result.append(&quot;, unknown&quot;);
            }
<span class="fc" id="L578">            result.append('}');</span>
        }
<span class="fc" id="L580">        copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);</span>
<span class="fc" id="L581">        return result.toString();</span>
    }

    /**
     * Sets the formats to use for the values passed into
     * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
     * methods. The indices of elements in &lt;code&gt;newFormats&lt;/code&gt;
     * correspond to the argument indices used in the previously set
     * pattern string.
     * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; thus corresponds to
     * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
     * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
     * by the &lt;code&gt;parse&lt;/code&gt; methods.
     * &lt;p&gt;
     * If an argument index is used for more than one format element
     * in the pattern string, then the corresponding new format is used
     * for all such format elements. If an argument index is not used
     * for any format element in the pattern string, then the
     * corresponding new format is ignored. If fewer formats are provided
     * than needed, then only the formats for argument indices less
     * than &lt;code&gt;newFormats.length&lt;/code&gt; are replaced.
     *
     * @param newFormats the new formats to use
     * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null
     * @since 1.4
     */
    public void setFormatsByArgumentIndex(Format[] newFormats) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc" id="L609">            int j = argumentNumbers[i];</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (j &lt; newFormats.length) {</span>
<span class="nc" id="L611">                formats[i] = newFormats[j];</span>
            }
        }
<span class="nc" id="L614">    }</span>

    /**
     * Sets the formats to use for the format elements in the
     * previously set pattern string.
     * The order of formats in &lt;code&gt;newFormats&lt;/code&gt; corresponds to
     * the order of format elements in the pattern string.
     * &lt;p&gt;
     * If more formats are provided than needed by the pattern string,
     * the remaining ones are ignored. If fewer formats are provided
     * than needed, then only the first &lt;code&gt;newFormats.length&lt;/code&gt;
     * formats are replaced.
     * &lt;p&gt;
     * Since the order of format elements in a pattern string often
     * changes during localization, it is generally better to use the
     * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
     * method, which assumes an order of formats corresponding to the
     * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
     * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
     * the &lt;code&gt;parse&lt;/code&gt; methods.
     *
     * @param newFormats the new formats to use
     * @exception NullPointerException if &lt;code&gt;newFormats&lt;/code&gt; is null
     */
    public void setFormats(Format[] newFormats) {
<span class="nc" id="L639">        int runsToCopy = newFormats.length;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (runsToCopy &gt; maxOffset + 1) {</span>
<span class="nc" id="L641">            runsToCopy = maxOffset + 1;</span>
        }
<span class="nc bnc" id="L643" title="All 2 branches missed.">        for (int i = 0; i &lt; runsToCopy; i++) {</span>
<span class="nc" id="L644">            formats[i] = newFormats[i];</span>
        }
<span class="nc" id="L646">    }</span>

    /**
     * Sets the format to use for the format elements within the
     * previously set pattern string that use the given argument
     * index.
     * The argument index is part of the format element definition and
     * represents an index into the &lt;code&gt;arguments&lt;/code&gt; array passed
     * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
     * by the &lt;code&gt;parse&lt;/code&gt; methods.
     * &lt;p&gt;
     * If the argument index is used for more than one format element
     * in the pattern string, then the new format is used for all such
     * format elements. If the argument index is not used for any format
     * element in the pattern string, then the new format is ignored.
     *
     * @param argumentIndex the argument index for which to use the new format
     * @param newFormat the new format to use
     * @since 1.4
     */
    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
<span class="nc bnc" id="L667" title="All 2 branches missed.">        for (int j = 0; j &lt;= maxOffset; j++) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            if (argumentNumbers[j] == argumentIndex) {</span>
<span class="nc" id="L669">                formats[j] = newFormat;</span>
            }
        }
<span class="nc" id="L672">    }</span>

    /**
     * Sets the format to use for the format element with the given
     * format element index within the previously set pattern string.
     * The format element index is the zero-based number of the format
     * element counting from the start of the pattern string.
     * &lt;p&gt;
     * Since the order of format elements in a pattern string often
     * changes during localization, it is generally better to use the
     * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
     * method, which accesses format elements based on the argument
     * index they specify.
     *
     * @param formatElementIndex the index of a format element within the pattern
     * @param newFormat the format to use for the specified format element
     * @exception ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or
     *            larger than the number of format elements in the pattern string
     */
    public void setFormat(int formatElementIndex, Format newFormat) {
<span class="nc" id="L692">        formats[formatElementIndex] = newFormat;</span>
<span class="nc" id="L693">    }</span>

    /**
     * Gets the formats used for the values passed into
     * &lt;code&gt;format&lt;/code&gt; methods or returned from &lt;code&gt;parse&lt;/code&gt;
     * methods. The indices of elements in the returned array
     * correspond to the argument indices used in the previously set
     * pattern string.
     * The order of formats in the returned array thus corresponds to
     * the order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed
     * to the &lt;code&gt;format&lt;/code&gt; methods or the result array returned
     * by the &lt;code&gt;parse&lt;/code&gt; methods.
     * &lt;p&gt;
     * If an argument index is used for more than one format element
     * in the pattern string, then the format used for the last such
     * format element is returned in the array. If an argument index
     * is not used for any format element in the pattern string, then
     * null is returned in the array.
     *
     * @return the formats used for the arguments within the pattern
     * @since 1.4
     */
    public Format[] getFormatsByArgumentIndex() {
<span class="nc" id="L716">        int maximumArgumentNumber = -1;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (argumentNumbers[i] &gt; maximumArgumentNumber) {</span>
<span class="nc" id="L719">                maximumArgumentNumber = argumentNumbers[i];</span>
            }
        }
<span class="nc" id="L722">        Format[] resultArray = new Format[maximumArgumentNumber + 1];</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc" id="L724">            resultArray[argumentNumbers[i]] = formats[i];</span>
        }
<span class="nc" id="L726">        return resultArray;</span>
    }

    /**
     * Gets the formats used for the format elements in the
     * previously set pattern string.
     * The order of formats in the returned array corresponds to
     * the order of format elements in the pattern string.
     * &lt;p&gt;
     * Since the order of format elements in a pattern string often
     * changes during localization, it's generally better to use the
     * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
     * method, which assumes an order of formats corresponding to the
     * order of elements in the &lt;code&gt;arguments&lt;/code&gt; array passed to
     * the &lt;code&gt;format&lt;/code&gt; methods or the result array returned by
     * the &lt;code&gt;parse&lt;/code&gt; methods.
     *
     * @return the formats used for the format elements in the pattern
     */
    public Format[] getFormats() {
<span class="fc" id="L746">        Format[] resultArray = new Format[maxOffset + 1];</span>
<span class="fc" id="L747">        System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);</span>
<span class="fc" id="L748">        return resultArray;</span>
    }

    /**
     * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;'s
     * pattern, with format elements replaced by the formatted objects, to the
     * provided &lt;code&gt;StringBuffer&lt;/code&gt;.
     * &lt;p&gt;
     * The text substituted for the individual format elements is derived from
     * the current subformat of the format element and the
     * &lt;code&gt;arguments&lt;/code&gt; element at the format element's argument index
     * as indicated by the first matching line of the following table. An
     * argument is &lt;i&gt;unavailable&lt;/i&gt; if &lt;code&gt;arguments&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt; or has fewer than argumentIndex+1 elements.
     *
     * &lt;table border=1 summary=&quot;Examples of subformat,argument,and formatted text&quot;&gt;
     *    &lt;tr&gt;
     *       &lt;th&gt;Subformat
     *       &lt;th&gt;Argument
     *       &lt;th&gt;Formatted Text
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
     *       &lt;td&gt;&lt;i&gt;unavailable&lt;/i&gt;
     *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
     *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;&quot;null&quot;&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;instanceof ChoiceFormat&lt;/code&gt;
     *       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
     *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf('{') &amp;gt;= 0 ?&lt;br&gt;
     *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
     *           subformat.format(argument)&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;!= null&lt;/code&gt;
     *       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
     *       &lt;td&gt;&lt;code&gt;subformat.format(argument)&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;instanceof Number&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;NumberFormat.getInstance(getLocale()).format(argument)&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;instanceof Date&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;instanceof String&lt;/code&gt;
     *       &lt;td&gt;&lt;code&gt;argument&lt;/code&gt;
     *    &lt;tr&gt;
     *       &lt;td&gt;&lt;code&gt;null&lt;/code&gt;
     *       &lt;td&gt;&lt;i&gt;any&lt;/i&gt;
     *       &lt;td&gt;&lt;code&gt;argument.toString()&lt;/code&gt;
     * &lt;/table&gt;
     * &lt;p&gt;
     * If &lt;code&gt;pos&lt;/code&gt; is non-null, and refers to
     * &lt;code&gt;Field.ARGUMENT&lt;/code&gt;, the location of the first formatted
     * string will be returned.
     *
     * @param arguments an array of objects to be formatted and substituted.
     * @param result where text is appended.
     * @param pos On input: an alignment field, if desired.
     *            On output: the offsets of the alignment field.
     * @return the string buffer passed in as {@code result}, with formatted
     * text appended
     * @exception IllegalArgumentException if an argument in the
     *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
     *            expected by the format element(s) that use it.
     */
    public final StringBuffer format(Object[] arguments, StringBuffer result,
                                     FieldPosition pos)
    {
<span class="nc" id="L821">        return subformat(arguments, result, pos, null);</span>
    }

    /**
     * Creates a MessageFormat with the given pattern and uses it
     * to format the given arguments. This is equivalent to
     * &lt;blockquote&gt;
     *     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
     * &lt;/blockquote&gt;
     *
     * @param pattern   the pattern string
     * @param arguments object(s) to format
     * @return the formatted string
     * @exception IllegalArgumentException if the pattern is invalid,
     *            or if an argument in the &lt;code&gt;arguments&lt;/code&gt; array
     *            is not of the type expected by the format element(s)
     *            that use it.
     */
    public static String format(String pattern, Object ... arguments) {
<span class="fc" id="L840">        MessageFormat temp = new MessageFormat(pattern);</span>
<span class="fc" id="L841">        return temp.format(arguments);</span>
    }

    // Overrides
    /**
     * Formats an array of objects and appends the &lt;code&gt;MessageFormat&lt;/code&gt;'s
     * pattern, with format elements replaced by the formatted objects, to the
     * provided &lt;code&gt;StringBuffer&lt;/code&gt;.
     * This is equivalent to
     * &lt;blockquote&gt;
     *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
     * &lt;/blockquote&gt;
     *
     * @param arguments an array of objects to be formatted and substituted.
     * @param result where text is appended.
     * @param pos On input: an alignment field, if desired.
     *            On output: the offsets of the alignment field.
     * @exception IllegalArgumentException if an argument in the
     *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
     *            expected by the format element(s) that use it.
     */
    public final StringBuffer format(Object arguments, StringBuffer result,
                                     FieldPosition pos)
    {
<span class="fc" id="L865">        return subformat((Object[]) arguments, result, pos, null);</span>
    }

    /**
     * Formats an array of objects and inserts them into the
     * &lt;code&gt;MessageFormat&lt;/code&gt;'s pattern, producing an
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
     * to build the resulting String, as well as to determine information
     * about the resulting String.
     * &lt;p&gt;
     * The text of the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; is
     * the same that would be returned by
     * &lt;blockquote&gt;
     *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * In addition, the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; contains at
     * least attributes indicating where text was generated from an
     * argument in the &lt;code&gt;arguments&lt;/code&gt; array. The keys of these attributes are of
     * type &lt;code&gt;MessageFormat.Field&lt;/code&gt;, their values are
     * &lt;code&gt;Integer&lt;/code&gt; objects indicating the index in the &lt;code&gt;arguments&lt;/code&gt;
     * array of the argument from which the text was generated.
     * &lt;p&gt;
     * The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt;
     * instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be
     * placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * This allows you to not only find where an argument is placed in the
     * resulting String, but also which fields it contains in turn.
     *
     * @param arguments an array of objects to be formatted and substituted.
     * @return AttributedCharacterIterator describing the formatted value.
     * @exception NullPointerException if &lt;code&gt;arguments&lt;/code&gt; is null.
     * @exception IllegalArgumentException if an argument in the
     *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
     *            expected by the format element(s) that use it.
     * @since 1.4
     */
    public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
<span class="nc" id="L904">        StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L905">        ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (arguments == null) {</span>
<span class="nc" id="L908">            throw new NullPointerException(</span>
                   &quot;formatToCharacterIterator must be passed non-null object&quot;);
        }
<span class="nc" id="L911">        subformat((Object[]) arguments, result, null, iterators);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (iterators.size() == 0) {</span>
<span class="nc" id="L913">            return createAttributedCharacterIterator(&quot;&quot;);</span>
        }
<span class="nc" id="L915">        return createAttributedCharacterIterator(</span>
<span class="nc" id="L916">                     iterators.toArray(</span>
<span class="nc" id="L917">                     new AttributedCharacterIterator[iterators.size()]));</span>
    }

    /**
     * Parses the string.
     *
     * &lt;p&gt;Caveats: The parse may fail in a number of circumstances.
     * For example:
     * &lt;ul&gt;
     * &lt;li&gt;If one of the arguments does not occur in the pattern.
     * &lt;li&gt;If the format of an argument loses information, such as
     *     with a choice format where a large number formats to &quot;many&quot;.
     * &lt;li&gt;Does not yet handle recursion (where
     *     the substituted strings contain {n} references.)
     * &lt;li&gt;Will not always find a match (or the correct match)
     *     if some part of the parse is ambiguous.
     *     For example, if the pattern &quot;{1},{2}&quot; is used with the
     *     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
     *     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
     * &lt;li&gt;If a single argument is parsed more than once in the string,
     *     then the later parse wins.
     * &lt;/ul&gt;
     * When the parse fails, use ParsePosition.getErrorIndex() to find out
     * where in the string the parsing failed.  The returned error
     * index is the starting offset of the sub-patterns that the string
     * is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
     * is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
     * 0. When an error occurs, the call to this method will return null.
     * If the source is null, return an empty array.
     *
     * @param source the string to parse
     * @param pos    the parse position
     * @return an array of parsed objects
     */
    public Object[] parse(String source, ParsePosition pos) {
<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (source == null) {</span>
<span class="nc" id="L953">            Object[] empty = {};</span>
<span class="nc" id="L954">            return empty;</span>
        }

<span class="nc" id="L957">        int maximumArgumentNumber = -1;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxOffset; i++) {</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (argumentNumbers[i] &gt; maximumArgumentNumber) {</span>
<span class="nc" id="L960">                maximumArgumentNumber = argumentNumbers[i];</span>
            }
        }
<span class="nc" id="L963">        Object[] resultArray = new Object[maximumArgumentNumber + 1];</span>

<span class="nc" id="L965">        int patternOffset = 0;</span>
<span class="nc" id="L966">        int sourceOffset = pos.index;</span>
<span class="nc" id="L967">        ParsePosition tempStatus = new ParsePosition(0);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">        for (int i = 0; i &lt;= maxOffset; ++i) {</span>
            // match up to format
<span class="nc" id="L970">            int len = offsets[i] - patternOffset;</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">            if (len == 0 || pattern.regionMatches(patternOffset,</span>
                                                  source, sourceOffset, len)) {
<span class="nc" id="L973">                sourceOffset += len;</span>
<span class="nc" id="L974">                patternOffset += len;</span>
            } else {
<span class="nc" id="L976">                pos.errorIndex = sourceOffset;</span>
<span class="nc" id="L977">                return null; // leave index as is to signal error</span>
            }

            // now use format
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (formats[i] == null) {   // string format</span>
                // if at end, use longest possible match
                // otherwise uses first match to intervening string
                // does NOT recursively try all possibilities
<span class="nc bnc" id="L985" title="All 2 branches missed.">                int tempLength = (i != maxOffset) ? offsets[i+1] : pattern.length();</span>

                int next;
<span class="nc bnc" id="L988" title="All 2 branches missed.">                if (patternOffset &gt;= tempLength) {</span>
<span class="nc" id="L989">                    next = source.length();</span>
                }else{
<span class="nc" id="L991">                    next = source.indexOf(pattern.substring(patternOffset, tempLength),</span>
                                          sourceOffset);
                }

<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (next &lt; 0) {</span>
<span class="nc" id="L996">                    pos.errorIndex = sourceOffset;</span>
<span class="nc" id="L997">                    return null; // leave index as is to signal error</span>
                } else {
<span class="nc" id="L999">                    String strValue= source.substring(sourceOffset,next);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">                    if (!strValue.equals(&quot;{&quot;+argumentNumbers[i]+&quot;}&quot;))</span>
<span class="nc" id="L1001">                        resultArray[argumentNumbers[i]]</span>
<span class="nc" id="L1002">                            = source.substring(sourceOffset,next);</span>
<span class="nc" id="L1003">                    sourceOffset = next;</span>
                }
<span class="nc" id="L1005">            } else {</span>
<span class="nc" id="L1006">                tempStatus.index = sourceOffset;</span>
<span class="nc" id="L1007">                resultArray[argumentNumbers[i]]</span>
<span class="nc" id="L1008">                    = formats[i].parseObject(source,tempStatus);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (tempStatus.index == sourceOffset) {</span>
<span class="nc" id="L1010">                    pos.errorIndex = sourceOffset;</span>
<span class="nc" id="L1011">                    return null; // leave index as is to signal error</span>
                }
<span class="nc" id="L1013">                sourceOffset = tempStatus.index; // update</span>
            }
        }
<span class="nc" id="L1016">        int len = pattern.length() - patternOffset;</span>
<span class="nc bnc" id="L1017" title="All 4 branches missed.">        if (len == 0 || pattern.regionMatches(patternOffset,</span>
                                              source, sourceOffset, len)) {
<span class="nc" id="L1019">            pos.index = sourceOffset + len;</span>
        } else {
<span class="nc" id="L1021">            pos.errorIndex = sourceOffset;</span>
<span class="nc" id="L1022">            return null; // leave index as is to signal error</span>
        }
<span class="nc" id="L1024">        return resultArray;</span>
    }

    /**
     * Parses text from the beginning of the given string to produce an object
     * array.
     * The method may not use the entire text of the given string.
     * &lt;p&gt;
     * See the {@link #parse(String, ParsePosition)} method for more information
     * on message parsing.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
     * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string.
     * @exception ParseException if the beginning of the specified string
     *            cannot be parsed.
     */
    public Object[] parse(String source) throws ParseException {
<span class="nc" id="L1041">        ParsePosition pos  = new ParsePosition(0);</span>
<span class="nc" id="L1042">        Object[] result = parse(source, pos);</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (pos.index == 0)  // unchanged, returned object is null</span>
<span class="nc" id="L1044">            throw new ParseException(&quot;MessageFormat parse error!&quot;, pos.errorIndex);</span>

<span class="nc" id="L1046">        return result;</span>
    }

    /**
     * Parses text from a string to produce an object array.
     * &lt;p&gt;
     * The method attempts to parse text starting at the index given by
     * &lt;code&gt;pos&lt;/code&gt;.
     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
     * to the index after the last character used (parsing does not necessarily
     * use all characters up to the end of the string), and the parsed
     * object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
     * indicate the starting point for the next call to this method.
     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
     * the character where the error occurred, and null is returned.
     * &lt;p&gt;
     * See the {@link #parse(String, ParsePosition)} method for more information
     * on message parsing.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
     * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
     *            index information as described above.
     * @return An &lt;code&gt;Object&lt;/code&gt; array parsed from the string. In case of
     *         error, returns null.
     * @exception NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.
     */
    public Object parseObject(String source, ParsePosition pos) {
<span class="nc" id="L1074">        return parse(source, pos);</span>
    }

    /**
     * Creates and returns a copy of this object.
     *
     * @return a clone of this instance.
     */
    public Object clone() {
<span class="nc" id="L1083">        MessageFormat other = (MessageFormat) super.clone();</span>

        // clone arrays. Can't do with utility because of bug in Cloneable
<span class="nc" id="L1086">        other.formats = formats.clone(); // shallow clone</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        for (int i = 0; i &lt; formats.length; ++i) {</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (formats[i] != null)</span>
<span class="nc" id="L1089">                other.formats[i] = (Format)formats[i].clone();</span>
        }
        // for primitives or immutables, shallow clone is enough
<span class="nc" id="L1092">        other.offsets = offsets.clone();</span>
<span class="nc" id="L1093">        other.argumentNumbers = argumentNumbers.clone();</span>

<span class="nc" id="L1095">        return other;</span>
    }

    /**
     * Equality comparison between two message format objects
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (this == obj)                      // quick check</span>
<span class="nc" id="L1103">            return true;</span>
<span class="nc bnc" id="L1104" title="All 4 branches missed.">        if (obj == null || getClass() != obj.getClass())</span>
<span class="nc" id="L1105">            return false;</span>
<span class="nc" id="L1106">        MessageFormat other = (MessageFormat) obj;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">        return (maxOffset == other.maxOffset</span>
<span class="nc bnc" id="L1108" title="All 4 branches missed.">                &amp;&amp; pattern.equals(other.pattern)</span>
<span class="nc bnc" id="L1109" title="All 6 branches missed.">                &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))</span>
                 || (locale == null &amp;&amp; other.locale == null))
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(offsets,other.offsets)</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(argumentNumbers,other.argumentNumbers)</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                &amp;&amp; Arrays.equals(formats,other.formats));</span>
    }

    /**
     * Generates a hash code for the message format object.
     */
    public int hashCode() {
<span class="nc" id="L1120">        return pattern.hashCode(); // enough for reasonable distribution</span>
    }


    /**
     * Defines constants that are used as attribute keys in the
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
     * from &lt;code&gt;MessageFormat.formatToCharacterIterator&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static class Field extends Format.Field {

        // Proclaim serial compatibility with 1.4 FCS
        private static final long serialVersionUID = 7899943957617360810L;

        /**
         * Creates a Field with the specified name.
         *
         * @param name Name of the attribute
         */
        protected Field(String name) {
<span class="fc" id="L1142">            super(name);</span>
<span class="fc" id="L1143">        }</span>

        /**
         * Resolves instances being deserialized to the predefined constants.
         *
         * @throws InvalidObjectException if the constant could not be
         *         resolved.
         * @return resolved MessageFormat.Field constant
         */
        protected Object readResolve() throws InvalidObjectException {
<span class="nc bnc" id="L1153" title="All 2 branches missed.">            if (this.getClass() != MessageFormat.Field.class) {</span>
<span class="nc" id="L1154">                throw new InvalidObjectException(&quot;subclass didn't correctly implement readResolve&quot;);</span>
            }

<span class="nc" id="L1157">            return ARGUMENT;</span>
        }

        //
        // The constants
        //

        /**
         * Constant identifying a portion of a message that was generated
         * from an argument passed into &lt;code&gt;formatToCharacterIterator&lt;/code&gt;.
         * The value associated with the key will be an &lt;code&gt;Integer&lt;/code&gt;
         * indicating the index in the &lt;code&gt;arguments&lt;/code&gt; array of the
         * argument from which the text was generated.
         */
<span class="fc" id="L1171">        public final static Field ARGUMENT =</span>
                           new Field(&quot;message argument field&quot;);
    }

    // ===========================privates============================

    /**
     * The locale to use for formatting numbers and dates.
     * @serial
     */
    private Locale locale;

    /**
     * The string that the formatted values are to be plugged into.  In other words, this
     * is the pattern supplied on construction with all of the {} expressions taken out.
     * @serial
     */
<span class="fc" id="L1188">    private String pattern = &quot;&quot;;</span>

    /** The initially expected number of subformats in the format */
    private static final int INITIAL_FORMATS = 10;

    /**
     * An array of formatters, which are used to format the arguments.
     * @serial
     */
<span class="fc" id="L1197">    private Format[] formats = new Format[INITIAL_FORMATS];</span>

    /**
     * The positions where the results of formatting each argument are to be inserted
     * into the pattern.
     * @serial
     */
<span class="fc" id="L1204">    private int[] offsets = new int[INITIAL_FORMATS];</span>

    /**
     * The argument numbers corresponding to each formatter.  (The formatters are stored
     * in the order they occur in the pattern, not in the order in which the arguments
     * are specified.)
     * @serial
     */
<span class="fc" id="L1212">    private int[] argumentNumbers = new int[INITIAL_FORMATS];</span>

    /**
     * One less than the number of entries in &lt;code&gt;offsets&lt;/code&gt;.  Can also be thought of
     * as the index of the highest-numbered element in &lt;code&gt;offsets&lt;/code&gt; that is being used.
     * All of these arrays should have the same number of elements being used as &lt;code&gt;offsets&lt;/code&gt;
     * does, and so this variable suffices to tell us how many entries are in all of them.
     * @serial
     */
<span class="fc" id="L1221">    private int maxOffset = -1;</span>

    /**
     * Internal routine used by format. If &lt;code&gt;characterIterators&lt;/code&gt; is
     * non-null, AttributedCharacterIterator will be created from the
     * subformats as necessary. If &lt;code&gt;characterIterators&lt;/code&gt; is null
     * and &lt;code&gt;fp&lt;/code&gt; is non-null and identifies
     * &lt;code&gt;Field.MESSAGE_ARGUMENT&lt;/code&gt;, the location of
     * the first replaced argument will be set in it.
     *
     * @exception IllegalArgumentException if an argument in the
     *            &lt;code&gt;arguments&lt;/code&gt; array is not of the type
     *            expected by the format element(s) that use it.
     */
    private StringBuffer subformat(Object[] arguments, StringBuffer result,
                                   FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
        // note: this implementation assumes a fast substring &amp; index.
        // if this is not true, would be better to append chars one by one.
<span class="fc" id="L1239">        int lastOffset = 0;</span>
<span class="fc" id="L1240">        int last = result.length();</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        for (int i = 0; i &lt;= maxOffset; ++i) {</span>
<span class="fc" id="L1242">            result.append(pattern.substring(lastOffset, offsets[i]));</span>
<span class="fc" id="L1243">            lastOffset = offsets[i];</span>
<span class="fc" id="L1244">            int argumentNumber = argumentNumbers[i];</span>
<span class="pc bpc" id="L1245" title="2 of 4 branches missed.">            if (arguments == null || argumentNumber &gt;= arguments.length) {</span>
<span class="nc" id="L1246">                result.append('{').append(argumentNumber).append('}');</span>
<span class="nc" id="L1247">                continue;</span>
            }
            // int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);
            if (false) { // if (argRecursion == 3){
                // prevent loop!!!
                result.append('\uFFFD');
            } else {
<span class="fc" id="L1254">                Object obj = arguments[argumentNumber];</span>
<span class="fc" id="L1255">                String arg = null;</span>
<span class="fc" id="L1256">                Format subFormatter = null;</span>
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">                if (obj == null) {</span>
<span class="nc" id="L1258">                    arg = &quot;null&quot;;</span>
<span class="fc bfc" id="L1259" title="All 2 branches covered.">                } else if (formats[i] != null) {</span>
<span class="fc" id="L1260">                    subFormatter = formats[i];</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">                    if (subFormatter instanceof ChoiceFormat) {</span>
<span class="fc" id="L1262">                        arg = formats[i].format(obj);</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">                        if (arg.indexOf('{') &gt;= 0) {</span>
<span class="fc" id="L1264">                            subFormatter = new MessageFormat(arg, locale);</span>
<span class="fc" id="L1265">                            obj = arguments;</span>
<span class="fc" id="L1266">                            arg = null;</span>
                        }
                    }
<span class="fc bfc" id="L1269" title="All 2 branches covered.">                } else if (obj instanceof Number) {</span>
                    // format number if can
<span class="fc" id="L1271">                    subFormatter = NumberFormat.getInstance(locale);</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">                } else if (obj instanceof Date) {</span>
                    // format a Date if can
<span class="nc" id="L1274">                    subFormatter = DateFormat.getDateTimeInstance(</span>
                             DateFormat.SHORT, DateFormat.SHORT, locale);//fix
<span class="fc bfc" id="L1276" title="All 2 branches covered.">                } else if (obj instanceof String) {</span>
<span class="fc" id="L1277">                    arg = (String) obj;</span>

                } else {
<span class="fc" id="L1280">                    arg = obj.toString();</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">                    if (arg == null) arg = &quot;null&quot;;</span>
                }

                // At this point we are in two states, either subFormatter
                // is non-null indicating we should format obj using it,
                // or arg is non-null and we should use it as the value.

<span class="pc bpc" id="L1288" title="1 of 2 branches missed.">                if (characterIterators != null) {</span>
                    // If characterIterators is non-null, it indicates we need
                    // to get the CharacterIterator from the child formatter.
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                    if (last != result.length()) {</span>
<span class="nc" id="L1292">                        characterIterators.add(</span>
<span class="nc" id="L1293">                            createAttributedCharacterIterator(result.substring</span>
<span class="nc" id="L1294">                                                              (last)));</span>
<span class="nc" id="L1295">                        last = result.length();</span>
                    }
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                    if (subFormatter != null) {</span>
<span class="nc" id="L1298">                        AttributedCharacterIterator subIterator =</span>
<span class="nc" id="L1299">                                   subFormatter.formatToCharacterIterator(obj);</span>

<span class="nc" id="L1301">                        append(result, subIterator);</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                        if (last != result.length()) {</span>
<span class="nc" id="L1303">                            characterIterators.add(</span>
<span class="nc" id="L1304">                                         createAttributedCharacterIterator(</span>
                                         subIterator, Field.ARGUMENT,
<span class="nc" id="L1306">                                         Integer.valueOf(argumentNumber)));</span>
<span class="nc" id="L1307">                            last = result.length();</span>
                        }
<span class="nc" id="L1309">                        arg = null;</span>
                    }
<span class="nc bnc" id="L1311" title="All 4 branches missed.">                    if (arg != null &amp;&amp; arg.length() &gt; 0) {</span>
<span class="nc" id="L1312">                        result.append(arg);</span>
<span class="nc" id="L1313">                        characterIterators.add(</span>
<span class="nc" id="L1314">                                 createAttributedCharacterIterator(</span>
                                 arg, Field.ARGUMENT,
<span class="nc" id="L1316">                                 Integer.valueOf(argumentNumber)));</span>
<span class="nc" id="L1317">                        last = result.length();</span>
                    }
                }
                else {
<span class="fc bfc" id="L1321" title="All 2 branches covered.">                    if (subFormatter != null) {</span>
<span class="fc" id="L1322">                        arg = subFormatter.format(obj);</span>
                    }
<span class="fc" id="L1324">                    last = result.length();</span>
<span class="fc" id="L1325">                    result.append(arg);</span>
<span class="pc bpc" id="L1326" title="2 of 6 branches missed.">                    if (i == 0 &amp;&amp; fp != null &amp;&amp; Field.ARGUMENT.equals(</span>
<span class="fc" id="L1327">                                  fp.getFieldAttribute())) {</span>
<span class="nc" id="L1328">                        fp.setBeginIndex(last);</span>
<span class="nc" id="L1329">                        fp.setEndIndex(result.length());</span>
                    }
<span class="fc" id="L1331">                    last = result.length();</span>
                }
            }
        }
<span class="fc" id="L1335">        result.append(pattern.substring(lastOffset, pattern.length()));</span>
<span class="pc bpc" id="L1336" title="3 of 4 branches missed.">        if (characterIterators != null &amp;&amp; last != result.length()) {</span>
<span class="nc" id="L1337">            characterIterators.add(createAttributedCharacterIterator(</span>
<span class="nc" id="L1338">                                   result.substring(last)));</span>
        }
<span class="fc" id="L1340">        return result;</span>
    }

    /**
     * Convenience method to append all the characters in
     * &lt;code&gt;iterator&lt;/code&gt; to the StringBuffer &lt;code&gt;result&lt;/code&gt;.
     */
    private void append(StringBuffer result, CharacterIterator iterator) {
<span class="nc bnc" id="L1348" title="All 2 branches missed.">        if (iterator.first() != CharacterIterator.DONE) {</span>
            char aChar;

<span class="nc" id="L1351">            result.append(iterator.first());</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            while ((aChar = iterator.next()) != CharacterIterator.DONE) {</span>
<span class="nc" id="L1353">                result.append(aChar);</span>
            }
        }
<span class="nc" id="L1356">    }</span>

    // Indices for segments
    private static final int SEG_RAW      = 0;
    private static final int SEG_INDEX    = 1;
    private static final int SEG_TYPE     = 2;
    private static final int SEG_MODIFIER = 3; // modifier or subformat

    // Indices for type keywords
    private static final int TYPE_NULL    = 0;
    private static final int TYPE_NUMBER  = 1;
    private static final int TYPE_DATE    = 2;
    private static final int TYPE_TIME    = 3;
    private static final int TYPE_CHOICE  = 4;

<span class="fc" id="L1371">    private static final String[] TYPE_KEYWORDS = {</span>
        &quot;&quot;,
        &quot;number&quot;,
        &quot;date&quot;,
        &quot;time&quot;,
        &quot;choice&quot;
    };

    // Indices for number modifiers
    private static final int MODIFIER_DEFAULT  = 0; // common in number and date-time
    private static final int MODIFIER_CURRENCY = 1;
    private static final int MODIFIER_PERCENT  = 2;
    private static final int MODIFIER_INTEGER  = 3;

<span class="fc" id="L1385">    private static final String[] NUMBER_MODIFIER_KEYWORDS = {</span>
        &quot;&quot;,
        &quot;currency&quot;,
        &quot;percent&quot;,
        &quot;integer&quot;
    };

    // Indices for date-time modifiers
    private static final int MODIFIER_SHORT   = 1;
    private static final int MODIFIER_MEDIUM  = 2;
    private static final int MODIFIER_LONG    = 3;
    private static final int MODIFIER_FULL    = 4;

<span class="fc" id="L1398">    private static final String[] DATE_TIME_MODIFIER_KEYWORDS = {</span>
        &quot;&quot;,
        &quot;short&quot;,
        &quot;medium&quot;,
        &quot;long&quot;,
        &quot;full&quot;
    };

    // Date-time style values corresponding to the date-time modifiers.
<span class="fc" id="L1407">    private static final int[] DATE_TIME_MODIFIERS = {</span>
        DateFormat.DEFAULT,
        DateFormat.SHORT,
        DateFormat.MEDIUM,
        DateFormat.LONG,
        DateFormat.FULL,
    };

    private void makeFormat(int position, int offsetNumber,
                            StringBuilder[] textSegments)
    {
<span class="fc" id="L1418">        String[] segments = new String[textSegments.length];</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">        for (int i = 0; i &lt; textSegments.length; i++) {</span>
<span class="fc" id="L1420">            StringBuilder oneseg = textSegments[i];</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">            segments[i] = (oneseg != null) ? oneseg.toString() : &quot;&quot;;</span>
        }

        // get the argument number
        int argumentNumber;
        try {
<span class="fc" id="L1427">            argumentNumber = Integer.parseInt(segments[SEG_INDEX]); // always unlocalized!</span>
<span class="nc" id="L1428">        } catch (NumberFormatException e) {</span>
<span class="nc" id="L1429">            throw new IllegalArgumentException(&quot;can't parse argument number: &quot;</span>
                                               + segments[SEG_INDEX], e);
<span class="fc" id="L1431">        }</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">        if (argumentNumber &lt; 0) {</span>
<span class="nc" id="L1433">            throw new IllegalArgumentException(&quot;negative argument number: &quot;</span>
                                               + argumentNumber);
        }

        // resize format information arrays if necessary
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        if (offsetNumber &gt;= formats.length) {</span>
<span class="nc" id="L1439">            int newLength = formats.length * 2;</span>
<span class="nc" id="L1440">            Format[] newFormats = new Format[newLength];</span>
<span class="nc" id="L1441">            int[] newOffsets = new int[newLength];</span>
<span class="nc" id="L1442">            int[] newArgumentNumbers = new int[newLength];</span>
<span class="nc" id="L1443">            System.arraycopy(formats, 0, newFormats, 0, maxOffset + 1);</span>
<span class="nc" id="L1444">            System.arraycopy(offsets, 0, newOffsets, 0, maxOffset + 1);</span>
<span class="nc" id="L1445">            System.arraycopy(argumentNumbers, 0, newArgumentNumbers, 0, maxOffset + 1);</span>
<span class="nc" id="L1446">            formats = newFormats;</span>
<span class="nc" id="L1447">            offsets = newOffsets;</span>
<span class="nc" id="L1448">            argumentNumbers = newArgumentNumbers;</span>
        }
<span class="fc" id="L1450">        int oldMaxOffset = maxOffset;</span>
<span class="fc" id="L1451">        maxOffset = offsetNumber;</span>
<span class="fc" id="L1452">        offsets[offsetNumber] = segments[SEG_RAW].length();</span>
<span class="fc" id="L1453">        argumentNumbers[offsetNumber] = argumentNumber;</span>

        // now get the format
<span class="fc" id="L1456">        Format newFormat = null;</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">        if (segments[SEG_TYPE].length() != 0) {</span>
<span class="fc" id="L1458">            int type = findKeyword(segments[SEG_TYPE], TYPE_KEYWORDS);</span>
<span class="pc bpc" id="L1459" title="2 of 5 branches missed.">            switch (type) {</span>
            case TYPE_NULL:
                // Type &quot;&quot; is allowed. e.g., &quot;{0,}&quot;, &quot;{0,,}&quot;, and &quot;{0,,#}&quot;
                // are treated as &quot;{0}&quot;.
<span class="nc" id="L1463">                break;</span>

            case TYPE_NUMBER:
<span class="pc bpc" id="L1466" title="1 of 5 branches missed.">                switch (findKeyword(segments[SEG_MODIFIER], NUMBER_MODIFIER_KEYWORDS)) {</span>
                case MODIFIER_DEFAULT:
<span class="fc" id="L1468">                    newFormat = NumberFormat.getInstance(locale);</span>
<span class="fc" id="L1469">                    break;</span>
                case MODIFIER_CURRENCY:
<span class="fc" id="L1471">                    newFormat = NumberFormat.getCurrencyInstance(locale);</span>
<span class="fc" id="L1472">                    break;</span>
                case MODIFIER_PERCENT:
<span class="fc" id="L1474">                    newFormat = NumberFormat.getPercentInstance(locale);</span>
<span class="fc" id="L1475">                    break;</span>
                case MODIFIER_INTEGER:
<span class="fc" id="L1477">                    newFormat = NumberFormat.getIntegerInstance(locale);</span>
<span class="fc" id="L1478">                    break;</span>
                default: // DecimalFormat pattern
                    try {
<span class="nc" id="L1481">                        newFormat = new DecimalFormat(segments[SEG_MODIFIER],</span>
<span class="nc" id="L1482">                                                      DecimalFormatSymbols.getInstance(locale));</span>
<span class="nc" id="L1483">                    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1484">                        maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1485">                        throw e;</span>
<span class="nc" id="L1486">                    }</span>
                    break;
                }
                break;

            case TYPE_DATE:
            case TYPE_TIME:
<span class="fc" id="L1493">                int mod = findKeyword(segments[SEG_MODIFIER], DATE_TIME_MODIFIER_KEYWORDS);</span>
<span class="pc bpc" id="L1494" title="2 of 4 branches missed.">                if (mod &gt;= 0 &amp;&amp; mod &lt; DATE_TIME_MODIFIER_KEYWORDS.length) {</span>
<span class="fc bfc" id="L1495" title="All 2 branches covered.">                    if (type == TYPE_DATE) {</span>
<span class="fc" id="L1496">                        newFormat = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[mod],</span>
                                                               locale);
                    } else {
<span class="fc" id="L1499">                        newFormat = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[mod],</span>
                                                               locale);
                    }
                } else {
                    // SimpleDateFormat pattern
                    try {
<span class="nc" id="L1505">                        newFormat = new SimpleDateFormat(segments[SEG_MODIFIER], locale);</span>
<span class="nc" id="L1506">                    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1507">                        maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1508">                        throw e;</span>
<span class="nc" id="L1509">                    }</span>
                }
                break;

            case TYPE_CHOICE:
                try {
                    // ChoiceFormat pattern
<span class="fc" id="L1516">                    newFormat = new ChoiceFormat(segments[SEG_MODIFIER]);</span>
<span class="nc" id="L1517">                } catch (Exception e) {</span>
<span class="nc" id="L1518">                    maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1519">                    throw new IllegalArgumentException(&quot;Choice Pattern incorrect: &quot;</span>
                                                       + segments[SEG_MODIFIER], e);
<span class="fc" id="L1521">                }</span>
                break;

            default:
<span class="nc" id="L1525">                maxOffset = oldMaxOffset;</span>
<span class="nc" id="L1526">                throw new IllegalArgumentException(&quot;unknown format type: &quot; +</span>
                                                   segments[SEG_TYPE]);
            }
        }
<span class="fc" id="L1530">        formats[offsetNumber] = newFormat;</span>
<span class="fc" id="L1531">    }</span>

    private static final int findKeyword(String s, String[] list) {
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">        for (int i = 0; i &lt; list.length; ++i) {</span>
<span class="fc bfc" id="L1535" title="All 2 branches covered.">            if (s.equals(list[i]))</span>
<span class="fc" id="L1536">                return i;</span>
        }

        // Try trimmed lowercase.
<span class="nc" id="L1540">        String ls = s.trim().toLowerCase(Locale.ROOT);</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">        if (ls != s) {</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">            for (int i = 0; i &lt; list.length; ++i) {</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                if (ls.equals(list[i]))</span>
<span class="nc" id="L1544">                    return i;</span>
            }
        }
<span class="nc" id="L1547">        return -1;</span>
    }

    private static final void copyAndFixQuotes(String source, int start, int end,
                                               StringBuilder target) {
<span class="fc" id="L1552">        boolean quoted = false;</span>

<span class="fc bfc" id="L1554" title="All 2 branches covered.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="fc" id="L1555">            char ch = source.charAt(i);</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">            if (ch == '{') {</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">                if (!quoted) {</span>
<span class="nc" id="L1558">                    target.append('\'');</span>
<span class="nc" id="L1559">                    quoted = true;</span>
                }
<span class="nc" id="L1561">                target.append(ch);</span>
<span class="pc bpc" id="L1562" title="1 of 2 branches missed.">            } else if (ch == '\'') {</span>
<span class="nc" id="L1563">                target.append(&quot;''&quot;);</span>
            } else {
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">                if (quoted) {</span>
<span class="nc" id="L1566">                    target.append('\'');</span>
<span class="nc" id="L1567">                    quoted = false;</span>
                }
<span class="fc" id="L1569">                target.append(ch);</span>
            }
        }
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">        if (quoted) {</span>
<span class="nc" id="L1573">            target.append('\'');</span>
        }
<span class="fc" id="L1575">    }</span>

    /**
     * After reading an object from the input stream, do a simple verification
     * to maintain class invariants.
     * @throws InvalidObjectException if the objects read from the stream is invalid.
     */
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L1583">        in.defaultReadObject();</span>
<span class="nc bnc" id="L1584" title="All 8 branches missed.">        boolean isValid = maxOffset &gt;= -1</span>
                &amp;&amp; formats.length &gt; maxOffset
                &amp;&amp; offsets.length &gt; maxOffset
                &amp;&amp; argumentNumbers.length &gt; maxOffset;
<span class="nc bnc" id="L1588" title="All 2 branches missed.">        if (isValid) {</span>
<span class="nc" id="L1589">            int lastOffset = pattern.length() + 1;</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">            for (int i = maxOffset; i &gt;= 0; --i) {</span>
<span class="nc bnc" id="L1591" title="All 4 branches missed.">                if ((offsets[i] &lt; 0) || (offsets[i] &gt; lastOffset)) {</span>
<span class="nc" id="L1592">                    isValid = false;</span>
<span class="nc" id="L1593">                    break;</span>
                } else {
<span class="nc" id="L1595">                    lastOffset = offsets[i];</span>
                }
            }
        }
<span class="nc bnc" id="L1599" title="All 2 branches missed.">        if (!isValid) {</span>
<span class="nc" id="L1600">            throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream.&quot;);</span>
        }
<span class="nc" id="L1602">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>