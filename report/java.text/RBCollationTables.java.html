<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RBCollationTables.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">RBCollationTables.java</span></div><h1>RBCollationTables.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.util.Vector;
import sun.text.UCompactIntArray;
import sun.text.IntHashtable;

/**
 * This class contains the static state of a RuleBasedCollator: The various
 * tables that are used by the collation routines.  Several RuleBasedCollators
 * can share a single RBCollationTables object, easing memory requirements and
 * improving performance.
 */
final class RBCollationTables {
    //===========================================================================================
    //  The following diagram shows the data structure of the RBCollationTables object.
    //  Suppose we have the rule, where 'o-umlaut' is the unicode char 0x00F6.
    //  &quot;a, A &lt; b, B &lt; c, C, ch, cH, Ch, CH &lt; d, D ... &lt; o, O; 'o-umlaut'/E, 'O-umlaut'/E ...&quot;.
    //  What the rule says is, sorts 'ch'ligatures and 'c' only with tertiary difference and
    //  sorts 'o-umlaut' as if it's always expanded with 'e'.
    //
    // mapping table                     contracting list           expanding list
    // (contains all unicode char
    //  entries)                   ___    ____________       _________________________
    //  ________                +&gt;|_*_|-&gt;|'c' |v('c') |  +&gt;|v('o')|v('umlaut')|v('e')|
    // |_\u0001_|-&gt; v('\u0001') | |_:_|  |------------|  | |-------------------------|
    // |_\u0002_|-&gt; v('\u0002') | |_:_|  |'ch'|v('ch')|  | |             :           |
    // |____:___|               | |_:_|  |------------|  | |-------------------------|
    // |____:___|               |        |'cH'|v('cH')|  | |             :           |
    // |__'a'___|-&gt; v('a')      |        |------------|  | |-------------------------|
    // |__'b'___|-&gt; v('b')      |        |'Ch'|v('Ch')|  | |             :           |
    // |____:___|               |        |------------|  | |-------------------------|
    // |____:___|               |        |'CH'|v('CH')|  | |             :           |
    // |___'c'__|----------------         ------------   | |-------------------------|
    // |____:___|                                        | |             :           |
    // |o-umlaut|----------------------------------------  |_________________________|
    // |____:___|
    //
    // Noted by Helena Shih on 6/23/97
    //============================================================================================

<span class="nc" id="L79">    public RBCollationTables(String rules, int decmp) throws ParseException {</span>
<span class="nc" id="L80">        this.rules = rules;</span>

<span class="nc" id="L82">        RBTableBuilder builder = new RBTableBuilder(new BuildAPI());</span>
<span class="nc" id="L83">        builder.build(rules, decmp); // this object is filled in through</span>
                                            // the BuildAPI object
<span class="nc" id="L85">    }</span>

    final class BuildAPI {
        /**
         * Private constructor.  Prevents anyone else besides RBTableBuilder
         * from gaining direct access to the internals of this class.
         */
<span class="fc" id="L92">        private BuildAPI() {</span>
<span class="fc" id="L93">        }</span>

        /**
         * This function is used by RBTableBuilder to fill in all the members of this
         * object.  (Effectively, the builder class functions as a &quot;friend&quot; of this
         * class, but to avoid changing too much of the logic, it carries around &quot;shadow&quot;
         * copies of all these variables until the end of the build process and then
         * copies them en masse into the actual tables object once all the construction
         * logic is complete.  This function does that &quot;copying en masse&quot;.
         * @param f2ary The value for frenchSec (the French-secondary flag)
         * @param swap The value for SE Asian swapping rule
         * @param map The collator's character-mapping table (the value for mapping)
         * @param cTbl The collator's contracting-character table (the value for contractTable)
         * @param eTbl The collator's expanding-character table (the value for expandTable)
         * @param cFlgs The hash table of characters that participate in contracting-
         *              character sequences (the value for contractFlags)
         * @param mso The value for maxSecOrder
         * @param mto The value for maxTerOrder
         */
        void fillInTables(boolean f2ary,
                          boolean swap,
                          UCompactIntArray map,
                          Vector&lt;Vector&lt;EntryPair&gt;&gt; cTbl,
                          Vector&lt;int[]&gt; eTbl,
                          IntHashtable cFlgs,
                          short mso,
                          short mto) {
<span class="nc" id="L120">            frenchSec = f2ary;</span>
<span class="nc" id="L121">            seAsianSwapping = swap;</span>
<span class="nc" id="L122">            mapping = map;</span>
<span class="nc" id="L123">            contractTable = cTbl;</span>
<span class="nc" id="L124">            expandTable = eTbl;</span>
<span class="nc" id="L125">            contractFlags = cFlgs;</span>
<span class="nc" id="L126">            maxSecOrder = mso;</span>
<span class="nc" id="L127">            maxTerOrder = mto;</span>
<span class="nc" id="L128">        }</span>
    }

    /**
     * Gets the table-based rules for the collation object.
     * @return returns the collation rules that the table collation object
     * was created from.
     */
    public String getRules()
    {
<span class="nc" id="L138">        return rules;</span>
    }

    public boolean isFrenchSec() {
<span class="nc" id="L142">        return frenchSec;</span>
    }

    public boolean isSEAsianSwapping() {
<span class="nc" id="L146">        return seAsianSwapping;</span>
    }

    // ==============================================================
    // internal (for use by CollationElementIterator)
    // ==============================================================

    /**
     *  Get the entry of hash table of the contracting string in the collation
     *  table.
     *  @param ch the starting character of the contracting string
     */
    Vector&lt;EntryPair&gt; getContractValues(int ch)
    {
<span class="nc" id="L160">        int index = mapping.elementAt(ch);</span>
<span class="nc" id="L161">        return getContractValuesImpl(index - CONTRACTCHARINDEX);</span>
    }

    //get contract values from contractTable by index
    private Vector&lt;EntryPair&gt; getContractValuesImpl(int index)
    {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (index &gt;= 0)</span>
        {
<span class="nc" id="L169">            return contractTable.elementAt(index);</span>
        }
        else // not found
        {
<span class="nc" id="L173">            return null;</span>
        }
    }

    /**
     * Returns true if this character appears anywhere in a contracting
     * character sequence.  (Used by CollationElementIterator.setOffset().)
     */
    boolean usedInContractSeq(int c) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        return contractFlags.get(c) == 1;</span>
    }

    /**
      * Return the maximum length of any expansion sequences that end
      * with the specified comparison order.
      *
      * @param order a collation order returned by previous or next.
      * @return the maximum length of any expansion seuences ending
      *         with the specified order.
      *
      * @see CollationElementIterator#getMaxExpansion
      */
    int getMaxExpansion(int order) {
<span class="nc" id="L196">        int result = 1;</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (expandTable != null) {</span>
            // Right now this does a linear search through the entire
            // expansion table.  If a collator had a large number of expansions,
            // this could cause a performance problem, but in practise that
            // rarely happens
<span class="nc bnc" id="L203" title="All 2 branches missed.">            for (int i = 0; i &lt; expandTable.size(); i++) {</span>
<span class="nc" id="L204">                int[] valueList = expandTable.elementAt(i);</span>
<span class="nc" id="L205">                int length = valueList.length;</span>

<span class="nc bnc" id="L207" title="All 4 branches missed.">                if (length &gt; result &amp;&amp; valueList[length-1] == order) {</span>
<span class="nc" id="L208">                    result = length;</span>
                }
            }
        }

<span class="nc" id="L213">        return result;</span>
    }

    /**
     * Get the entry of hash table of the expanding string in the collation
     * table.
     * @param idx the index of the expanding string value list
     */
    final int[] getExpandValueList(int idx) {
<span class="nc" id="L222">        return expandTable.elementAt(idx - EXPANDCHARINDEX);</span>
    }

    /**
     * Get the comarison order of a character from the collation table.
     * @return the comparison order of a character.
     */
    int getUnicodeOrder(int ch) {
<span class="nc" id="L230">        return mapping.elementAt(ch);</span>
    }

    short getMaxSecOrder() {
<span class="nc" id="L234">        return maxSecOrder;</span>
    }

    short getMaxTerOrder() {
<span class="nc" id="L238">        return maxTerOrder;</span>
    }

    /**
     * Reverse a string.
     */
    //shemran/Note: this is used for secondary order value reverse, no
    //              need to consider supplementary pair.
    static void reverse (StringBuffer result, int from, int to)
    {
<span class="nc" id="L248">        int i = from;</span>
        char swap;

<span class="nc" id="L251">        int j = to - 1;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        while (i &lt; j) {</span>
<span class="nc" id="L253">            swap =  result.charAt(i);</span>
<span class="nc" id="L254">            result.setCharAt(i, result.charAt(j));</span>
<span class="nc" id="L255">            result.setCharAt(j, swap);</span>
<span class="nc" id="L256">            i++;</span>
<span class="nc" id="L257">            j--;</span>
        }
<span class="nc" id="L259">    }</span>

    final static int getEntry(Vector&lt;EntryPair&gt; list, String name, boolean fwd) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        for (int i = 0; i &lt; list.size(); i++) {</span>
<span class="nc" id="L263">            EntryPair pair = list.elementAt(i);</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">            if (pair.fwd == fwd &amp;&amp; pair.entryName.equals(name)) {</span>
<span class="nc" id="L265">                return i;</span>
            }
        }
<span class="nc" id="L268">        return UNMAPPED;</span>
    }

    // ==============================================================
    // constants
    // ==============================================================
    //sherman/Todo: is the value big enough?????
    final static int EXPANDCHARINDEX = 0x7E000000; // Expand index follows
    final static int CONTRACTCHARINDEX = 0x7F000000;  // contract indexes follow
    final static int UNMAPPED = 0xFFFFFFFF;

    final static int PRIMARYORDERMASK = 0xffff0000;
    final static int SECONDARYORDERMASK = 0x0000ff00;
    final static int TERTIARYORDERMASK = 0x000000ff;
    final static int PRIMARYDIFFERENCEONLY = 0xffff0000;
    final static int SECONDARYDIFFERENCEONLY = 0xffffff00;
    final static int PRIMARYORDERSHIFT = 16;
    final static int SECONDARYORDERSHIFT = 8;

    // ==============================================================
    // instance variables
    // ==============================================================
<span class="nc" id="L290">    private String rules = null;</span>
<span class="nc" id="L291">    private boolean frenchSec = false;</span>
<span class="nc" id="L292">    private boolean seAsianSwapping = false;</span>

<span class="nc" id="L294">    private UCompactIntArray mapping = null;</span>
<span class="nc" id="L295">    private Vector&lt;Vector&lt;EntryPair&gt;&gt; contractTable = null;</span>
<span class="nc" id="L296">    private Vector&lt;int[]&gt; expandTable = null;</span>
<span class="nc" id="L297">    private IntHashtable contractFlags = null;</span>

<span class="nc" id="L299">    private short maxSecOrder = 0;</span>
<span class="nc" id="L300">    private short maxTerOrder = 0;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>