<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ChoiceFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">ChoiceFormat.java</span></div><h1>ChoiceFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.InvalidObjectException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.Arrays;

/**
 * A &lt;code&gt;ChoiceFormat&lt;/code&gt; allows you to attach a format to a range of numbers.
 * It is generally used in a &lt;code&gt;MessageFormat&lt;/code&gt; for handling plurals.
 * The choice is specified with an ascending list of doubles, where each item
 * specifies a half-open interval up to the next item:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * X matches j if and only if limit[j] &amp;le; X &amp;lt; limit[j+1]
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * If there is no match, then either the first or last index is used, depending
 * on whether the number (X) is too low or too high.  If the limit array is not
 * in ascending order, the results of formatting will be incorrect.  ChoiceFormat
 * also accepts &lt;code&gt;&amp;#92;u221E&lt;/code&gt; as equivalent to infinity(INF).
 *
 * &lt;p&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt;
 * &lt;code&gt;ChoiceFormat&lt;/code&gt; differs from the other &lt;code&gt;Format&lt;/code&gt;
 * classes in that you create a &lt;code&gt;ChoiceFormat&lt;/code&gt; object with a
 * constructor (not with a &lt;code&gt;getInstance&lt;/code&gt; style factory
 * method). The factory methods aren't necessary because &lt;code&gt;ChoiceFormat&lt;/code&gt;
 * doesn't require any complex setup for a given locale. In fact,
 * &lt;code&gt;ChoiceFormat&lt;/code&gt; doesn't implement any locale specific behavior.
 *
 * &lt;p&gt;
 * When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats
 * and an array of limits. The length of these arrays must be the same.
 * For example,
 * &lt;ul&gt;
 * &lt;li&gt;
 *     &lt;em&gt;limits&lt;/em&gt; = {1,2,3,4,5,6,7}&lt;br&gt;
 *     &lt;em&gt;formats&lt;/em&gt; = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;}
 * &lt;li&gt;
 *     &lt;em&gt;limits&lt;/em&gt; = {0, 1, ChoiceFormat.nextDouble(1)}&lt;br&gt;
 *     &lt;em&gt;formats&lt;/em&gt; = {&quot;no files&quot;, &quot;one file&quot;, &quot;many files&quot;}&lt;br&gt;
 *     (&lt;code&gt;nextDouble&lt;/code&gt; can be used to get the next higher double, to
 *     make the half-open interval.)
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Here is a simple example that shows formatting and parsing:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * double[] limits = {1,2,3,4,5,6,7};
 * String[] dayOfWeekNames = {&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thur&quot;,&quot;Fri&quot;,&quot;Sat&quot;};
 * ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);
 * ParsePosition status = new ParsePosition(0);
 * for (double i = 0.0; i &lt;= 8.0; ++i) {
 *     status.setIndex(0);
 *     System.out.println(i + &quot; -&gt; &quot; + form.format(i) + &quot; -&gt; &quot;
 *                              + form.parse(form.format(i),status));
 * }
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * Here is a more complex example, with a pattern format:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * double[] filelimits = {0,1,2};
 * String[] filepart = {&quot;are no files&quot;,&quot;is one file&quot;,&quot;are {2} files&quot;};
 * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 * Format[] testFormats = {fileform, null, NumberFormat.getInstance()};
 * MessageFormat pattform = new MessageFormat(&quot;There {0} on {1}&quot;);
 * pattform.setFormats(testFormats);
 * Object[] testArgs = {null, &quot;ADisk&quot;, null};
 * for (int i = 0; i &lt; 4; ++i) {
 *     testArgs[0] = new Integer(i);
 *     testArgs[2] = testArgs[0];
 *     System.out.println(pattform.format(testArgs));
 * }
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * &lt;p&gt;
 * Specifying a pattern for ChoiceFormat objects is fairly straightforward.
 * For example:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * ChoiceFormat fmt = new ChoiceFormat(
 *      &quot;-1#is negative| 0#is zero or fraction | 1#is one |1.0&lt;is 1+ |2#is two |2&lt;is more than 2.&quot;);
 * System.out.println(&quot;Formatter Pattern : &quot; + fmt.toPattern());
 *
 * System.out.println(&quot;Format with -INF : &quot; + fmt.format(Double.NEGATIVE_INFINITY));
 * System.out.println(&quot;Format with -1.0 : &quot; + fmt.format(-1.0));
 * System.out.println(&quot;Format with 0 : &quot; + fmt.format(0));
 * System.out.println(&quot;Format with 0.9 : &quot; + fmt.format(0.9));
 * System.out.println(&quot;Format with 1.0 : &quot; + fmt.format(1));
 * System.out.println(&quot;Format with 1.5 : &quot; + fmt.format(1.5));
 * System.out.println(&quot;Format with 2 : &quot; + fmt.format(2));
 * System.out.println(&quot;Format with 2.1 : &quot; + fmt.format(2.1));
 * System.out.println(&quot;Format with NaN : &quot; + fmt.format(Double.NaN));
 * System.out.println(&quot;Format with +INF : &quot; + fmt.format(Double.POSITIVE_INFINITY));
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * And the output result would be like the following:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * Format with -INF : is negative
 * Format with -1.0 : is negative
 * Format with 0 : is zero or fraction
 * Format with 0.9 : is zero or fraction
 * Format with 1.0 : is one
 * Format with 1.5 : is 1+
 * Format with 2 : is two
 * Format with 2.1 : is more than 2.
 * Format with NaN : is negative
 * Format with +INF : is more than 2.
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;h3&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Choice formats are not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 *
 * @see          DecimalFormat
 * @see          MessageFormat
 * @author       Mark Davis
 */
public class ChoiceFormat extends NumberFormat {

    // Proclaim serial compatibility with 1.1 FCS
    private static final long serialVersionUID = 1795184449645032964L;

    /**
     * Sets the pattern.
     * @param newPattern See the class description.
     */
    public void applyPattern(String newPattern) {
<span class="fc" id="L177">        StringBuffer[] segments = new StringBuffer[2];</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L179">            segments[i] = new StringBuffer();</span>
        }
<span class="fc" id="L181">        double[] newChoiceLimits = new double[30];</span>
<span class="fc" id="L182">        String[] newChoiceFormats = new String[30];</span>
<span class="fc" id="L183">        int count = 0;</span>
<span class="fc" id="L184">        int part = 0;</span>
<span class="fc" id="L185">        double startValue = 0;</span>
<span class="fc" id="L186">        double oldStartValue = Double.NaN;</span>
<span class="fc" id="L187">        boolean inQuote = false;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        for (int i = 0; i &lt; newPattern.length(); ++i) {</span>
<span class="fc" id="L189">            char ch = newPattern.charAt(i);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            if (ch=='\'') {</span>
                // Check for &quot;''&quot; indicating a literal quote
<span class="nc bnc" id="L192" title="All 4 branches missed.">                if ((i+1)&lt;newPattern.length() &amp;&amp; newPattern.charAt(i+1)==ch) {</span>
<span class="nc" id="L193">                    segments[part].append(ch);</span>
<span class="nc" id="L194">                    ++i;</span>
                } else {
<span class="nc bnc" id="L196" title="All 2 branches missed.">                    inQuote = !inQuote;</span>
                }
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            } else if (inQuote) {</span>
<span class="nc" id="L199">                segments[part].append(ch);</span>
<span class="pc bpc" id="L200" title="2 of 6 branches missed.">            } else if (ch == '&lt;' || ch == '#' || ch == '\u2264') {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                if (segments[0].length() == 0) {</span>
<span class="nc" id="L202">                    throw new IllegalArgumentException();</span>
                }
                try {
<span class="fc" id="L205">                    String tempBuffer = segments[0].toString();</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                    if (tempBuffer.equals(&quot;\u221E&quot;)) {</span>
<span class="nc" id="L207">                        startValue = Double.POSITIVE_INFINITY;</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">                    } else if (tempBuffer.equals(&quot;-\u221E&quot;)) {</span>
<span class="nc" id="L209">                        startValue = Double.NEGATIVE_INFINITY;</span>
                    } else {
<span class="fc" id="L211">                        startValue = Double.valueOf(segments[0].toString()).doubleValue();</span>
                    }
<span class="nc" id="L213">                } catch (Exception e) {</span>
<span class="nc" id="L214">                    throw new IllegalArgumentException();</span>
<span class="fc" id="L215">                }</span>
<span class="pc bpc" id="L216" title="5 of 6 branches missed.">                if (ch == '&lt;' &amp;&amp; startValue != Double.POSITIVE_INFINITY &amp;&amp;</span>
                        startValue != Double.NEGATIVE_INFINITY) {
<span class="nc" id="L218">                    startValue = nextDouble(startValue);</span>
                }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">                if (startValue &lt;= oldStartValue) {</span>
<span class="nc" id="L221">                    throw new IllegalArgumentException();</span>
                }
<span class="fc" id="L223">                segments[0].setLength(0);</span>
<span class="fc" id="L224">                part = 1;</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            } else if (ch == '|') {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">                if (count == newChoiceLimits.length) {</span>
<span class="nc" id="L227">                    newChoiceLimits = doubleArraySize(newChoiceLimits);</span>
<span class="nc" id="L228">                    newChoiceFormats = doubleArraySize(newChoiceFormats);</span>
                }
<span class="fc" id="L230">                newChoiceLimits[count] = startValue;</span>
<span class="fc" id="L231">                newChoiceFormats[count] = segments[1].toString();</span>
<span class="fc" id="L232">                ++count;</span>
<span class="fc" id="L233">                oldStartValue = startValue;</span>
<span class="fc" id="L234">                segments[1].setLength(0);</span>
<span class="fc" id="L235">                part = 0;</span>
            } else {
<span class="fc" id="L237">                segments[part].append(ch);</span>
            }
        }
        // clean up last one
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (part == 1) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">            if (count == newChoiceLimits.length) {</span>
<span class="nc" id="L243">                newChoiceLimits = doubleArraySize(newChoiceLimits);</span>
<span class="nc" id="L244">                newChoiceFormats = doubleArraySize(newChoiceFormats);</span>
            }
<span class="fc" id="L246">            newChoiceLimits[count] = startValue;</span>
<span class="fc" id="L247">            newChoiceFormats[count] = segments[1].toString();</span>
<span class="fc" id="L248">            ++count;</span>
        }
<span class="fc" id="L250">        choiceLimits = new double[count];</span>
<span class="fc" id="L251">        System.arraycopy(newChoiceLimits, 0, choiceLimits, 0, count);</span>
<span class="fc" id="L252">        choiceFormats = new String[count];</span>
<span class="fc" id="L253">        System.arraycopy(newChoiceFormats, 0, choiceFormats, 0, count);</span>
<span class="fc" id="L254">    }</span>

    /**
     * Gets the pattern.
     *
     * @return the pattern string
     */
    public String toPattern() {
<span class="nc" id="L262">        StringBuffer result = new StringBuffer();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (int i = 0; i &lt; choiceLimits.length; ++i) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (i != 0) {</span>
<span class="nc" id="L265">                result.append('|');</span>
            }
            // choose based upon which has less precision
            // approximate that by choosing the closest one to an integer.
            // could do better, but it's not worth it.
<span class="nc" id="L270">            double less = previousDouble(choiceLimits[i]);</span>
<span class="nc" id="L271">            double tryLessOrEqual = Math.abs(Math.IEEEremainder(choiceLimits[i], 1.0d));</span>
<span class="nc" id="L272">            double tryLess = Math.abs(Math.IEEEremainder(less, 1.0d));</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (tryLessOrEqual &lt; tryLess) {</span>
<span class="nc" id="L275">                result.append(&quot;&quot;+choiceLimits[i]);</span>
<span class="nc" id="L276">                result.append('#');</span>
            } else {
<span class="nc bnc" id="L278" title="All 2 branches missed.">                if (choiceLimits[i] == Double.POSITIVE_INFINITY) {</span>
<span class="nc" id="L279">                    result.append(&quot;\u221E&quot;);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">                } else if (choiceLimits[i] == Double.NEGATIVE_INFINITY) {</span>
<span class="nc" id="L281">                    result.append(&quot;-\u221E&quot;);</span>
                } else {
<span class="nc" id="L283">                    result.append(&quot;&quot;+less);</span>
                }
<span class="nc" id="L285">                result.append('&lt;');</span>
            }
            // Append choiceFormats[i], using quotes if there are special characters.
            // Single quotes themselves must be escaped in either case.
<span class="nc" id="L289">            String text = choiceFormats[i];</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            boolean needQuote = text.indexOf('&lt;') &gt;= 0</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                || text.indexOf('#') &gt;= 0</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                || text.indexOf('\u2264') &gt;= 0</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                || text.indexOf('|') &gt;= 0;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (needQuote) result.append('\'');</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (text.indexOf('\'') &lt; 0) result.append(text);</span>
            else {
<span class="nc bnc" id="L297" title="All 2 branches missed.">                for (int j=0; j&lt;text.length(); ++j) {</span>
<span class="nc" id="L298">                    char c = text.charAt(j);</span>
<span class="nc" id="L299">                    result.append(c);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    if (c == '\'') result.append(c);</span>
                }
            }
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (needQuote) result.append('\'');</span>
        }
<span class="nc" id="L305">        return result.toString();</span>
    }

    /**
     * Constructs with limits and corresponding formats based on the pattern.
     *
     * @param newPattern the new pattern string
     * @see #applyPattern
     */
<span class="fc" id="L314">    public ChoiceFormat(String newPattern)  {</span>
<span class="fc" id="L315">        applyPattern(newPattern);</span>
<span class="fc" id="L316">    }</span>

    /**
     * Constructs with the limits and the corresponding formats.
     *
     * @param limits limits in ascending order
     * @param formats corresponding format strings
     * @see #setChoices
     */
<span class="nc" id="L325">    public ChoiceFormat(double[] limits, String[] formats) {</span>
<span class="nc" id="L326">        setChoices(limits, formats);</span>
<span class="nc" id="L327">    }</span>

    /**
     * Set the choices to be used in formatting.
     * @param limits contains the top value that you want
     * parsed with that format, and should be in ascending sorted order. When
     * formatting X, the choice will be the i, where
     * limit[i] &amp;le; X {@literal &lt;} limit[i+1].
     * If the limit array is not in ascending order, the results of formatting
     * will be incorrect.
     * @param formats are the formats you want to use for each limit.
     * They can be either Format objects or Strings.
     * When formatting with object Y,
     * if the object is a NumberFormat, then ((NumberFormat) Y).format(X)
     * is called. Otherwise Y.toString() is called.
     */
    public void setChoices(double[] limits, String formats[]) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (limits.length != formats.length) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(</span>
                &quot;Array and limit arrays must be of the same length.&quot;);
        }
<span class="nc" id="L348">        choiceLimits = Arrays.copyOf(limits, limits.length);</span>
<span class="nc" id="L349">        choiceFormats = Arrays.copyOf(formats, formats.length);</span>
<span class="nc" id="L350">    }</span>

    /**
     * Get the limits passed in the constructor.
     * @return the limits.
     */
    public double[] getLimits() {
<span class="nc" id="L357">        double[] newLimits = Arrays.copyOf(choiceLimits, choiceLimits.length);</span>
<span class="nc" id="L358">        return newLimits;</span>
    }

    /**
     * Get the formats passed in the constructor.
     * @return the formats.
     */
    public Object[] getFormats() {
<span class="nc" id="L366">        Object[] newFormats = Arrays.copyOf(choiceFormats, choiceFormats.length);</span>
<span class="nc" id="L367">        return newFormats;</span>
    }

    // Overrides

    /**
     * Specialization of format. This method really calls
     * &lt;code&gt;format(double, StringBuffer, FieldPosition)&lt;/code&gt;
     * thus the range of longs that are supported is only equal to
     * the range that can be stored by double. This will never be
     * a practical limitation.
     */
    public StringBuffer format(long number, StringBuffer toAppendTo,
                               FieldPosition status) {
<span class="fc" id="L381">        return format((double)number, toAppendTo, status);</span>
    }

    /**
     * Returns pattern with formatted double.
     * @param number number to be formatted and substituted.
     * @param toAppendTo where text is appended.
     * @param status ignore no useful status is returned.
     */
   public StringBuffer format(double number, StringBuffer toAppendTo,
                               FieldPosition status) {
        // find the number
        int i;
<span class="fc bfc" id="L394" title="All 2 branches covered.">        for (i = 0; i &lt; choiceLimits.length; ++i) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            if (!(number &gt;= choiceLimits[i])) {</span>
                // same as number &lt; choiceLimits, except catchs NaN
<span class="fc" id="L397">                break;</span>
            }
        }
<span class="fc" id="L400">        --i;</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (i &lt; 0) i = 0;</span>
        // return either a formatted number, or a string
<span class="fc" id="L403">        return toAppendTo.append(choiceFormats[i]);</span>
    }

    /**
     * Parses a Number from the input text.
     * @param text the source text.
     * @param status an input-output parameter.  On input, the
     * status.index field indicates the first character of the
     * source text that should be parsed.  On exit, if no error
     * occurred, status.index is set to the first unparsed character
     * in the source text.  On exit, if an error did occur,
     * status.index is unchanged and status.errorIndex is set to the
     * first index of the character that caused the parse to fail.
     * @return A Number representing the value of the number parsed.
     */
    public Number parse(String text, ParsePosition status) {
        // find the best number (defined as the one with the longest parse)
<span class="nc" id="L420">        int start = status.index;</span>
<span class="nc" id="L421">        int furthest = start;</span>
<span class="nc" id="L422">        double bestNumber = Double.NaN;</span>
<span class="nc" id="L423">        double tempNumber = 0.0;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        for (int i = 0; i &lt; choiceFormats.length; ++i) {</span>
<span class="nc" id="L425">            String tempString = choiceFormats[i];</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (text.regionMatches(start, tempString, 0, tempString.length())) {</span>
<span class="nc" id="L427">                status.index = start + tempString.length();</span>
<span class="nc" id="L428">                tempNumber = choiceLimits[i];</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (status.index &gt; furthest) {</span>
<span class="nc" id="L430">                    furthest = status.index;</span>
<span class="nc" id="L431">                    bestNumber = tempNumber;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (furthest == text.length()) break;</span>
                }
            }
        }
<span class="nc" id="L436">        status.index = furthest;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (status.index == start) {</span>
<span class="nc" id="L438">            status.errorIndex = furthest;</span>
        }
<span class="nc" id="L440">        return new Double(bestNumber);</span>
    }

    /**
     * Finds the least double greater than {@code d}.
     * If {@code NaN}, returns same value.
     * &lt;p&gt;Used to make half-open intervals.
     *
     * @param d the reference value
     * @return the least double value greather than {@code d}
     * @see #previousDouble
     */
    public static final double nextDouble (double d) {
<span class="nc" id="L453">        return nextDouble(d,true);</span>
    }

    /**
     * Finds the greatest double less than {@code d}.
     * If {@code NaN}, returns same value.
     *
     * @param d the reference value
     * @return the greatest double value less than {@code d}
     * @see #nextDouble
     */
    public static final double previousDouble (double d) {
<span class="nc" id="L465">        return nextDouble(d,false);</span>
    }

    /**
     * Overrides Cloneable
     */
    public Object clone()
    {
<span class="nc" id="L473">        ChoiceFormat other = (ChoiceFormat) super.clone();</span>
        // for primitives or immutables, shallow clone is enough
<span class="nc" id="L475">        other.choiceLimits = choiceLimits.clone();</span>
<span class="nc" id="L476">        other.choiceFormats = choiceFormats.clone();</span>
<span class="nc" id="L477">        return other;</span>
    }

    /**
     * Generates a hash code for the message format object.
     */
    public int hashCode() {
<span class="nc" id="L484">        int result = choiceLimits.length;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (choiceFormats.length &gt; 0) {</span>
            // enough for reasonable distribution
<span class="nc" id="L487">            result ^= choiceFormats[choiceFormats.length-1].hashCode();</span>
        }
<span class="nc" id="L489">        return result;</span>
    }

    /**
     * Equality comparision between two
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (obj == null) return false;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (this == obj)                      // quick check</span>
<span class="nc" id="L498">            return true;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (getClass() != obj.getClass())</span>
<span class="nc" id="L500">            return false;</span>
<span class="nc" id="L501">        ChoiceFormat other = (ChoiceFormat) obj;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        return (Arrays.equals(choiceLimits, other.choiceLimits)</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">             &amp;&amp; Arrays.equals(choiceFormats, other.choiceFormats));</span>
    }

    /**
     * After reading an object from the input stream, do a simple verification
     * to maintain class invariants.
     * @throws InvalidObjectException if the objects read from the stream is invalid.
     */
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L512">        in.defaultReadObject();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (choiceLimits.length != choiceFormats.length) {</span>
<span class="nc" id="L514">            throw new InvalidObjectException(</span>
                    &quot;limits and format arrays of different length.&quot;);
        }
<span class="nc" id="L517">    }</span>

    // ===============privates===========================

    /**
     * A list of lower bounds for the choices.  The formatter will return
     * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
     * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.
     * @serial
     */
    private double[] choiceLimits;

    /**
     * A list of choice strings.  The formatter will return
     * &lt;code&gt;choiceFormats[i]&lt;/code&gt; if the number being formatted is greater than or equal to
     * &lt;code&gt;choiceLimits[i]&lt;/code&gt; and less than &lt;code&gt;choiceLimits[i+1]&lt;/code&gt;.
     * @serial
     */
    private String[] choiceFormats;

    /*
    static final long SIGN          = 0x8000000000000000L;
    static final long EXPONENT      = 0x7FF0000000000000L;
    static final long SIGNIFICAND   = 0x000FFFFFFFFFFFFFL;

    private static double nextDouble (double d, boolean positive) {
        if (Double.isNaN(d) || Double.isInfinite(d)) {
                return d;
            }
        long bits = Double.doubleToLongBits(d);
        long significand = bits &amp; SIGNIFICAND;
        if (bits &lt; 0) {
            significand |= (SIGN | EXPONENT);
        }
        long exponent = bits &amp; EXPONENT;
        if (positive) {
            significand += 1;
            // FIXME fix overflow &amp; underflow
        } else {
            significand -= 1;
            // FIXME fix overflow &amp; underflow
        }
        bits = exponent | (significand &amp; ~EXPONENT);
        return Double.longBitsToDouble(bits);
    }
    */

    static final long SIGN                = 0x8000000000000000L;
    static final long EXPONENT            = 0x7FF0000000000000L;
    static final long POSITIVEINFINITY    = 0x7FF0000000000000L;

    /**
     * Finds the least double greater than {@code d} (if {@code positive} is
     * {@code true}), or the greatest double less than {@code d} (if
     * {@code positive} is {@code false}).
     * If {@code NaN}, returns same value.
     *
     * Does not affect floating-point flags,
     * provided these member functions do not:
     *          Double.longBitsToDouble(long)
     *          Double.doubleToLongBits(double)
     *          Double.isNaN(double)
     *
     * @param d        the reference value
     * @param positive {@code true} if the least double is desired;
     *                 {@code false} otherwise
     * @return the least or greater double value
     */
    public static double nextDouble (double d, boolean positive) {

        /* filter out NaN's */
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (Double.isNaN(d)) {</span>
<span class="nc" id="L589">            return d;</span>
        }

        /* zero's are also a special case */
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (d == 0.0) {</span>
<span class="nc" id="L594">            double smallestPositiveDouble = Double.longBitsToDouble(1L);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (positive) {</span>
<span class="nc" id="L596">                return smallestPositiveDouble;</span>
            } else {
<span class="nc" id="L598">                return -smallestPositiveDouble;</span>
            }
        }

        /* if entering here, d is a nonzero value */

        /* hold all bits in a long for later use */
<span class="nc" id="L605">        long bits = Double.doubleToLongBits(d);</span>

        /* strip off the sign bit */
<span class="nc" id="L608">        long magnitude = bits &amp; ~SIGN;</span>

        /* if next double away from zero, increase magnitude */
<span class="nc bnc" id="L611" title="All 4 branches missed.">        if ((bits &gt; 0) == positive) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (magnitude != POSITIVEINFINITY) {</span>
<span class="nc" id="L613">                magnitude += 1;</span>
            }
        }
        /* else decrease magnitude */
        else {
<span class="nc" id="L618">            magnitude -= 1;</span>
        }

        /* restore sign bit and return */
<span class="nc" id="L622">        long signbit = bits &amp; SIGN;</span>
<span class="nc" id="L623">        return Double.longBitsToDouble (magnitude | signbit);</span>
    }

    private static double[] doubleArraySize(double[] array) {
<span class="nc" id="L627">        int oldSize = array.length;</span>
<span class="nc" id="L628">        double[] newArray = new double[oldSize * 2];</span>
<span class="nc" id="L629">        System.arraycopy(array, 0, newArray, 0, oldSize);</span>
<span class="nc" id="L630">        return newArray;</span>
    }

    private String[] doubleArraySize(String[] array) {
<span class="nc" id="L634">        int oldSize = array.length;</span>
<span class="nc" id="L635">        String[] newArray = new String[oldSize * 2];</span>
<span class="nc" id="L636">        System.arraycopy(array, 0, newArray, 0, oldSize);</span>
<span class="nc" id="L637">        return newArray;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>