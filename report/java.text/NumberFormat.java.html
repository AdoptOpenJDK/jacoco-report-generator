<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NumberFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">NumberFormat.java</span></div><h1>NumberFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.InvalidObjectException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.text.spi.NumberFormatProvider;
import java.util.Currency;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.spi.LocaleServiceProvider;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleServiceProviderPool;

/**
 * &lt;code&gt;NumberFormat&lt;/code&gt; is the abstract base class for all number
 * formats. This class provides the interface for formatting and parsing
 * numbers. &lt;code&gt;NumberFormat&lt;/code&gt; also provides methods for determining
 * which locales have number formats, and what their names are.
 *
 * &lt;p&gt;
 * &lt;code&gt;NumberFormat&lt;/code&gt; helps you to format and parse numbers for any locale.
 * Your code can be completely independent of the locale conventions for
 * decimal points, thousands-separators, or even the particular decimal
 * digits used, or whether the number format is even decimal.
 *
 * &lt;p&gt;
 * To format a number for the current Locale, use one of the factory
 * class methods:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * myString = NumberFormat.getInstance().format(myNumber);
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * If you are formatting multiple numbers, it is
 * more efficient to get the format and use it multiple times so that
 * the system doesn't have to fetch the information about the local
 * language and country conventions multiple times.
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * NumberFormat nf = NumberFormat.getInstance();
 * for (int i = 0; i &lt; myNumber.length; ++i) {
 *     output.println(nf.format(myNumber[i]) + &quot;; &quot;);
 * }
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * To format a number for a different Locale, specify it in the
 * call to &lt;code&gt;getInstance&lt;/code&gt;.
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * You can also use a &lt;code&gt;NumberFormat&lt;/code&gt; to parse numbers:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * myNumber = nf.parse(myString);
 * }&lt;/pre&gt;
 * &lt;/blockquote&gt;
 * Use &lt;code&gt;getInstance&lt;/code&gt; or &lt;code&gt;getNumberInstance&lt;/code&gt; to get the
 * normal number format. Use &lt;code&gt;getIntegerInstance&lt;/code&gt; to get an
 * integer number format. Use &lt;code&gt;getCurrencyInstance&lt;/code&gt; to get the
 * currency number format. And use &lt;code&gt;getPercentInstance&lt;/code&gt; to get a
 * format for displaying percentages. With this format, a fraction like
 * 0.53 is displayed as 53%.
 *
 * &lt;p&gt;
 * You can also control the display of numbers with such methods as
 * &lt;code&gt;setMinimumFractionDigits&lt;/code&gt;.
 * If you want even more control over the format or parsing,
 * or want to give your users more control,
 * you can try casting the &lt;code&gt;NumberFormat&lt;/code&gt; you get from the factory methods
 * to a &lt;code&gt;DecimalFormat&lt;/code&gt;. This will work for the vast majority
 * of locales; just remember to put it in a &lt;code&gt;try&lt;/code&gt; block in case you
 * encounter an unusual one.
 *
 * &lt;p&gt;
 * NumberFormat and DecimalFormat are designed such that some controls
 * work for formatting and others work for parsing.  The following is
 * the detailed description for each these control methods,
 * &lt;p&gt;
 * setParseIntegerOnly : only affects parsing, e.g.
 * if true,  &quot;3456.78&quot; &amp;rarr; 3456 (and leaves the parse position just after index 6)
 * if false, &quot;3456.78&quot; &amp;rarr; 3456.78 (and leaves the parse position just after index 8)
 * This is independent of formatting.  If you want to not show a decimal point
 * where there might be no digits after the decimal point, use
 * setDecimalSeparatorAlwaysShown.
 * &lt;p&gt;
 * setDecimalSeparatorAlwaysShown : only affects formatting, and only where
 * there might be no digits after the decimal point, such as with a pattern
 * like &quot;#,##0.##&quot;, e.g.,
 * if true,  3456.00 &amp;rarr; &quot;3,456.&quot;
 * if false, 3456.00 &amp;rarr; &quot;3456&quot;
 * This is independent of parsing.  If you want parsing to stop at the decimal
 * point, use setParseIntegerOnly.
 *
 * &lt;p&gt;
 * You can also use forms of the &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt;
 * methods with &lt;code&gt;ParsePosition&lt;/code&gt; and &lt;code&gt;FieldPosition&lt;/code&gt; to
 * allow you to:
 * &lt;ul&gt;
 * &lt;li&gt; progressively parse through pieces of a string
 * &lt;li&gt; align the decimal point and other areas
 * &lt;/ul&gt;
 * For example, you can align numbers in two ways:
 * &lt;ol&gt;
 * &lt;li&gt; If you are using a monospaced font with spacing for alignment,
 *      you can pass the &lt;code&gt;FieldPosition&lt;/code&gt; in your format call, with
 *      &lt;code&gt;field&lt;/code&gt; = &lt;code&gt;INTEGER_FIELD&lt;/code&gt;. On output,
 *      &lt;code&gt;getEndIndex&lt;/code&gt; will be set to the offset between the
 *      last character of the integer and the decimal. Add
 *      (desiredSpaceCount - getEndIndex) spaces at the front of the string.
 *
 * &lt;li&gt; If you are using proportional fonts,
 *      instead of padding with spaces, measure the width
 *      of the string in pixels from the start to &lt;code&gt;getEndIndex&lt;/code&gt;.
 *      Then move the pen by
 *      (desiredPixelWidth - widthToAlignmentPoint) before drawing the text.
 *      It also works where there is no decimal, but possibly additional
 *      characters at the end, e.g., with parentheses in negative
 *      numbers: &quot;(12)&quot; for -12.
 * &lt;/ol&gt;
 *
 * &lt;h3&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Number formats are generally not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 * @see          DecimalFormat
 * @see          ChoiceFormat
 * @author       Mark Davis
 * @author       Helena Shih
 */
public abstract class NumberFormat extends Format  {

    /**
     * Field constant used to construct a FieldPosition object. Signifies that
     * the position of the integer part of a formatted number should be returned.
     * @see java.text.FieldPosition
     */
    public static final int INTEGER_FIELD = 0;

    /**
     * Field constant used to construct a FieldPosition object. Signifies that
     * the position of the fraction part of a formatted number should be returned.
     * @see java.text.FieldPosition
     */
    public static final int FRACTION_FIELD = 1;

    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
<span class="fc" id="L202">    protected NumberFormat() {</span>
<span class="fc" id="L203">    }</span>

    /**
     * Formats a number and appends the resulting text to the given string
     * buffer.
     * The number can be of any subclass of {@link java.lang.Number}.
     * &lt;p&gt;
     * This implementation extracts the number's value using
     * {@link java.lang.Number#longValue()} for all integral type values that
     * can be converted to &lt;code&gt;long&lt;/code&gt; without loss of information,
     * including &lt;code&gt;BigInteger&lt;/code&gt; values with a
     * {@link java.math.BigInteger#bitLength() bit length} of less than 64,
     * and {@link java.lang.Number#doubleValue()} for all other types. It
     * then calls
     * {@link #format(long,java.lang.StringBuffer,java.text.FieldPosition)}
     * or {@link #format(double,java.lang.StringBuffer,java.text.FieldPosition)}.
     * This may result in loss of magnitude information and precision for
     * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; values.
     * @param number     the number to format
     * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
     *                   text is to be appended
     * @param pos        On input: an alignment field, if desired.
     *                   On output: the offsets of the alignment field.
     * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;
     * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is
     *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.
     * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
     *                   &lt;code&gt;pos&lt;/code&gt; is null
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see              java.text.FieldPosition
     */
    @Override
    public StringBuffer format(Object number,
                               StringBuffer toAppendTo,
                               FieldPosition pos) {
<span class="pc bpc" id="L239" title="12 of 14 branches missed.">        if (number instanceof Long || number instanceof Integer ||</span>
            number instanceof Short || number instanceof Byte ||
            number instanceof AtomicInteger || number instanceof AtomicLong ||
            (number instanceof BigInteger &amp;&amp;
<span class="nc bnc" id="L243" title="All 2 branches missed.">             ((BigInteger)number).bitLength() &lt; 64)) {</span>
<span class="fc" id="L244">            return format(((Number)number).longValue(), toAppendTo, pos);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        } else if (number instanceof Number) {</span>
<span class="nc" id="L246">            return format(((Number)number).doubleValue(), toAppendTo, pos);</span>
        } else {
<span class="nc" id="L248">            throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);</span>
        }
    }

    /**
     * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
     * &lt;p&gt;
     * The method attempts to parse text starting at the index given by
     * &lt;code&gt;pos&lt;/code&gt;.
     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
     * to the index after the last character used (parsing does not necessarily
     * use all characters up to the end of the string), and the parsed
     * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
     * indicate the starting point for the next call to this method.
     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
     * the character where the error occurred, and null is returned.
     * &lt;p&gt;
     * See the {@link #parse(String, ParsePosition)} method for more information
     * on number parsing.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
     * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
     *            index information as described above.
     * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string. In case of
     *         error, returns null.
     * @exception NullPointerException if &lt;code&gt;pos&lt;/code&gt; is null.
     */
    @Override
    public final Object parseObject(String source, ParsePosition pos) {
<span class="nc" id="L278">        return parse(source, pos);</span>
    }

   /**
     * Specialization of format.
     *
     * @param number the double number to format
     * @return the formatted String
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.Format#format
     */
    public final String format(double number) {
        // Use fast-path for double result if that works
<span class="nc" id="L292">        String result = fastFormat(number);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (result != null)</span>
<span class="nc" id="L294">            return result;</span>

<span class="nc" id="L296">        return format(number, new StringBuffer(),</span>
<span class="nc" id="L297">                      DontCareFieldPosition.INSTANCE).toString();</span>
    }

    /*
     * fastFormat() is supposed to be implemented in concrete subclasses only.
     * Default implem always returns null.
     */
<span class="nc" id="L304">    String fastFormat(double number) { return null; }</span>

   /**
     * Specialization of format.
     *
     * @param number the long number to format
     * @return the formatted String
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.Format#format
     */
    public final String format(long number) {
<span class="fc" id="L316">        return format(number, new StringBuffer(),</span>
<span class="fc" id="L317">                      DontCareFieldPosition.INSTANCE).toString();</span>
    }

   /**
     * Specialization of format.
     *
     * @param number     the double number to format
     * @param toAppendTo the StringBuffer to which the formatted text is to be
     *                   appended
     * @param pos        the field position
     * @return the formatted StringBuffer
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.Format#format
     */
    public abstract StringBuffer format(double number,
                                        StringBuffer toAppendTo,
                                        FieldPosition pos);

   /**
     * Specialization of format.
     *
     * @param number     the long number to format
     * @param toAppendTo the StringBuffer to which the formatted text is to be
     *                   appended
     * @param pos        the field position
     * @return the formatted StringBuffer
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.Format#format
     */
    public abstract StringBuffer format(long number,
                                        StringBuffer toAppendTo,
                                        FieldPosition pos);

   /**
     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
     * Long.MAX_VALUE] and with no decimals), otherwise a Double.
     * If IntegerOnly is set, will stop at a decimal
     * point (or equivalent; e.g., for rational numbers &quot;1 2/3&quot;, will stop
     * after the 1).
     * Does not throw an exception; if no object can be parsed, index is
     * unchanged!
     *
     * @param source the String to parse
     * @param parsePosition the parse position
     * @return the parsed value
     * @see java.text.NumberFormat#isParseIntegerOnly
     * @see java.text.Format#parseObject
     */
    public abstract Number parse(String source, ParsePosition parsePosition);

    /**
     * Parses text from the beginning of the given string to produce a number.
     * The method may not use the entire text of the given string.
     * &lt;p&gt;
     * See the {@link #parse(String, ParsePosition)} method for more information
     * on number parsing.
     *
     * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
     * @return A &lt;code&gt;Number&lt;/code&gt; parsed from the string.
     * @exception ParseException if the beginning of the specified string
     *            cannot be parsed.
     */
    public Number parse(String source) throws ParseException {
<span class="fc" id="L382">        ParsePosition parsePosition = new ParsePosition(0);</span>
<span class="fc" id="L383">        Number result = parse(source, parsePosition);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (parsePosition.index == 0) {</span>
<span class="fc" id="L385">            throw new ParseException(&quot;Unparseable number: \&quot;&quot; + source + &quot;\&quot;&quot;,</span>
                                     parsePosition.errorIndex);
        }
<span class="fc" id="L388">        return result;</span>
    }

    /**
     * Returns true if this format will parse numbers as integers only.
     * For example in the English locale, with ParseIntegerOnly true, the
     * string &quot;1234.&quot; would be parsed as the integer value 1234 and parsing
     * would stop at the &quot;.&quot; character.  Of course, the exact format accepted
     * by the parse operation is locale dependant and determined by sub-classes
     * of NumberFormat.
     *
     * @return {@code true} if numbers should be parsed as integers only;
     *         {@code false} otherwise
     */
    public boolean isParseIntegerOnly() {
<span class="fc" id="L403">        return parseIntegerOnly;</span>
    }

    /**
     * Sets whether or not numbers should be parsed as integers only.
     *
     * @param value {@code true} if numbers should be parsed as integers only;
     *              {@code false} otherwise
     * @see #isParseIntegerOnly
     */
    public void setParseIntegerOnly(boolean value) {
<span class="fc" id="L414">        parseIntegerOnly = value;</span>
<span class="fc" id="L415">    }</span>

    //============== Locale Stuff =====================

    /**
     * Returns a general-purpose number format for the current default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * This is the same as calling
     * {@link #getNumberInstance() getNumberInstance()}.
     *
     * @return the {@code NumberFormat} instance for general-purpose number
     * formatting
     */
    public final static NumberFormat getInstance() {
<span class="nc" id="L429">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), NUMBERSTYLE);</span>
    }

    /**
     * Returns a general-purpose number format for the specified locale.
     * This is the same as calling
     * {@link #getNumberInstance(java.util.Locale) getNumberInstance(inLocale)}.
     *
     * @param inLocale the desired locale
     * @return the {@code NumberFormat} instance for general-purpose number
     * formatting
     */
    public static NumberFormat getInstance(Locale inLocale) {
<span class="fc" id="L442">        return getInstance(inLocale, NUMBERSTYLE);</span>
    }

    /**
     * Returns a general-purpose number format for the current default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * &lt;p&gt;This is equivalent to calling
     * {@link #getNumberInstance(Locale)
     *     getNumberInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     *
     * @return the {@code NumberFormat} instance for general-purpose number
     * formatting
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     */
    public final static NumberFormat getNumberInstance() {
<span class="nc" id="L458">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), NUMBERSTYLE);</span>
    }

    /**
     * Returns a general-purpose number format for the specified locale.
     *
     * @param inLocale the desired locale
     * @return the {@code NumberFormat} instance for general-purpose number
     * formatting
     */
    public static NumberFormat getNumberInstance(Locale inLocale) {
<span class="fc" id="L469">        return getInstance(inLocale, NUMBERSTYLE);</span>
    }

    /**
     * Returns an integer number format for the current default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale. The
     * returned number format is configured to round floating point numbers
     * to the nearest integer using half-even rounding (see {@link
     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
     * and to parse only the integer part of an input string (see {@link
     * #isParseIntegerOnly isParseIntegerOnly}).
     * &lt;p&gt;This is equivalent to calling
     * {@link #getIntegerInstance(Locale)
     *     getIntegerInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     *
     * @see #getRoundingMode()
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     * @return a number format for integer values
     * @since 1.4
     */
    public final static NumberFormat getIntegerInstance() {
<span class="nc" id="L491">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), INTEGERSTYLE);</span>
    }

    /**
     * Returns an integer number format for the specified locale. The
     * returned number format is configured to round floating point numbers
     * to the nearest integer using half-even rounding (see {@link
     * java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}) for formatting,
     * and to parse only the integer part of an input string (see {@link
     * #isParseIntegerOnly isParseIntegerOnly}).
     *
     * @param inLocale the desired locale
     * @see #getRoundingMode()
     * @return a number format for integer values
     * @since 1.4
     */
    public static NumberFormat getIntegerInstance(Locale inLocale) {
<span class="fc" id="L508">        return getInstance(inLocale, INTEGERSTYLE);</span>
    }

    /**
     * Returns a currency format for the current default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * &lt;p&gt;This is equivalent to calling
     * {@link #getCurrencyInstance(Locale)
     *     getCurrencyInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     *
     * @return the {@code NumberFormat} instance for currency formatting
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     */
    public final static NumberFormat getCurrencyInstance() {
<span class="nc" id="L523">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), CURRENCYSTYLE);</span>
    }

    /**
     * Returns a currency format for the specified locale.
     *
     * @param inLocale the desired locale
     * @return the {@code NumberFormat} instance for currency formatting
     */
    public static NumberFormat getCurrencyInstance(Locale inLocale) {
<span class="fc" id="L533">        return getInstance(inLocale, CURRENCYSTYLE);</span>
    }

    /**
     * Returns a percentage format for the current default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * &lt;p&gt;This is equivalent to calling
     * {@link #getPercentInstance(Locale)
     *     getPercentInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     *
     * @return the {@code NumberFormat} instance for percentage formatting
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     */
    public final static NumberFormat getPercentInstance() {
<span class="nc" id="L548">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), PERCENTSTYLE);</span>
    }

    /**
     * Returns a percentage format for the specified locale.
     *
     * @param inLocale the desired locale
     * @return the {@code NumberFormat} instance for percentage formatting
     */
    public static NumberFormat getPercentInstance(Locale inLocale) {
<span class="fc" id="L558">        return getInstance(inLocale, PERCENTSTYLE);</span>
    }

    /**
     * Returns a scientific format for the current default locale.
     */
    /*public*/ final static NumberFormat getScientificInstance() {
<span class="nc" id="L565">        return getInstance(Locale.getDefault(Locale.Category.FORMAT), SCIENTIFICSTYLE);</span>
    }

    /**
     * Returns a scientific format for the specified locale.
     *
     * @param inLocale the desired locale
     */
    /*public*/ static NumberFormat getScientificInstance(Locale inLocale) {
<span class="nc" id="L574">        return getInstance(inLocale, SCIENTIFICSTYLE);</span>
    }

    /**
     * Returns an array of all locales for which the
     * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
     * localized instances.
     * The returned array represents the union of locales supported by the Java
     * runtime and by installed
     * {@link java.text.spi.NumberFormatProvider NumberFormatProvider} implementations.
     * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to
     * {@link java.util.Locale#US Locale.US}.
     *
     * @return An array of locales for which localized
     *         &lt;code&gt;NumberFormat&lt;/code&gt; instances are available.
     */
    public static Locale[] getAvailableLocales() {
<span class="fc" id="L591">        LocaleServiceProviderPool pool =</span>
<span class="fc" id="L592">            LocaleServiceProviderPool.getPool(NumberFormatProvider.class);</span>
<span class="fc" id="L593">        return pool.getAvailableLocales();</span>
    }

    /**
     * Overrides hashCode.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L601">        return maximumIntegerDigits * 37 + maxFractionDigits;</span>
        // just enough fields for a reasonable distribution
    }

    /**
     * Overrides equals.
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L611">            return false;</span>
        }
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L614">            return true;</span>
        }
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L617">            return false;</span>
        }
<span class="fc" id="L619">        NumberFormat other = (NumberFormat) obj;</span>
<span class="pc bpc" id="L620" title="3 of 12 branches missed.">        return (maximumIntegerDigits == other.maximumIntegerDigits</span>
            &amp;&amp; minimumIntegerDigits == other.minimumIntegerDigits
            &amp;&amp; maximumFractionDigits == other.maximumFractionDigits
            &amp;&amp; minimumFractionDigits == other.minimumFractionDigits
            &amp;&amp; groupingUsed == other.groupingUsed
            &amp;&amp; parseIntegerOnly == other.parseIntegerOnly);
    }

    /**
     * Overrides Cloneable.
     */
    @Override
    public Object clone() {
<span class="fc" id="L633">        NumberFormat other = (NumberFormat) super.clone();</span>
<span class="fc" id="L634">        return other;</span>
    }

    /**
     * Returns true if grouping is used in this format. For example, in the
     * English locale, with grouping on, the number 1234567 might be formatted
     * as &quot;1,234,567&quot;. The grouping separator as well as the size of each group
     * is locale dependant and is determined by sub-classes of NumberFormat.
     *
     * @return {@code true} if grouping is used;
     *         {@code false} otherwise
     * @see #setGroupingUsed
     */
    public boolean isGroupingUsed() {
<span class="fc" id="L648">        return groupingUsed;</span>
    }

    /**
     * Set whether or not grouping will be used in this format.
     *
     * @param newValue {@code true} if grouping is used;
     *                 {@code false} otherwise
     * @see #isGroupingUsed
     */
    public void setGroupingUsed(boolean newValue) {
<span class="fc" id="L659">        groupingUsed = newValue;</span>
<span class="fc" id="L660">    }</span>

    /**
     * Returns the maximum number of digits allowed in the integer portion of a
     * number.
     *
     * @return the maximum number of digits
     * @see #setMaximumIntegerDigits
     */
    public int getMaximumIntegerDigits() {
<span class="fc" id="L670">        return maximumIntegerDigits;</span>
    }

    /**
     * Sets the maximum number of digits allowed in the integer portion of a
     * number. maximumIntegerDigits must be &amp;ge; minimumIntegerDigits.  If the
     * new value for maximumIntegerDigits is less than the current value
     * of minimumIntegerDigits, then minimumIntegerDigits will also be set to
     * the new value.
     *
     * @param newValue the maximum number of integer digits to be shown; if
     * less than zero, then zero is used. The concrete subclass may enforce an
     * upper limit to this value appropriate to the numeric type being formatted.
     * @see #getMaximumIntegerDigits
     */
    public void setMaximumIntegerDigits(int newValue) {
<span class="fc" id="L686">        maximumIntegerDigits = Math.max(0,newValue);</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (minimumIntegerDigits &gt; maximumIntegerDigits) {</span>
<span class="nc" id="L688">            minimumIntegerDigits = maximumIntegerDigits;</span>
        }
<span class="fc" id="L690">    }</span>

    /**
     * Returns the minimum number of digits allowed in the integer portion of a
     * number.
     *
     * @return the minimum number of digits
     * @see #setMinimumIntegerDigits
     */
    public int getMinimumIntegerDigits() {
<span class="fc" id="L700">        return minimumIntegerDigits;</span>
    }

    /**
     * Sets the minimum number of digits allowed in the integer portion of a
     * number. minimumIntegerDigits must be &amp;le; maximumIntegerDigits.  If the
     * new value for minimumIntegerDigits exceeds the current value
     * of maximumIntegerDigits, then maximumIntegerDigits will also be set to
     * the new value
     *
     * @param newValue the minimum number of integer digits to be shown; if
     * less than zero, then zero is used. The concrete subclass may enforce an
     * upper limit to this value appropriate to the numeric type being formatted.
     * @see #getMinimumIntegerDigits
     */
    public void setMinimumIntegerDigits(int newValue) {
<span class="fc" id="L716">        minimumIntegerDigits = Math.max(0,newValue);</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        if (minimumIntegerDigits &gt; maximumIntegerDigits) {</span>
<span class="fc" id="L718">            maximumIntegerDigits = minimumIntegerDigits;</span>
        }
<span class="fc" id="L720">    }</span>

    /**
     * Returns the maximum number of digits allowed in the fraction portion of a
     * number.
     *
     * @return the maximum number of digits.
     * @see #setMaximumFractionDigits
     */
    public int getMaximumFractionDigits() {
<span class="fc" id="L730">        return maximumFractionDigits;</span>
    }

    /**
     * Sets the maximum number of digits allowed in the fraction portion of a
     * number. maximumFractionDigits must be &amp;ge; minimumFractionDigits.  If the
     * new value for maximumFractionDigits is less than the current value
     * of minimumFractionDigits, then minimumFractionDigits will also be set to
     * the new value.
     *
     * @param newValue the maximum number of fraction digits to be shown; if
     * less than zero, then zero is used. The concrete subclass may enforce an
     * upper limit to this value appropriate to the numeric type being formatted.
     * @see #getMaximumFractionDigits
     */
    public void setMaximumFractionDigits(int newValue) {
<span class="fc" id="L746">        maximumFractionDigits = Math.max(0,newValue);</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (maximumFractionDigits &lt; minimumFractionDigits) {</span>
<span class="nc" id="L748">            minimumFractionDigits = maximumFractionDigits;</span>
        }
<span class="fc" id="L750">    }</span>

    /**
     * Returns the minimum number of digits allowed in the fraction portion of a
     * number.
     *
     * @return the minimum number of digits
     * @see #setMinimumFractionDigits
     */
    public int getMinimumFractionDigits() {
<span class="fc" id="L760">        return minimumFractionDigits;</span>
    }

    /**
     * Sets the minimum number of digits allowed in the fraction portion of a
     * number. minimumFractionDigits must be &amp;le; maximumFractionDigits.  If the
     * new value for minimumFractionDigits exceeds the current value
     * of maximumFractionDigits, then maximumIntegerDigits will also be set to
     * the new value
     *
     * @param newValue the minimum number of fraction digits to be shown; if
     * less than zero, then zero is used. The concrete subclass may enforce an
     * upper limit to this value appropriate to the numeric type being formatted.
     * @see #getMinimumFractionDigits
     */
    public void setMinimumFractionDigits(int newValue) {
<span class="fc" id="L776">        minimumFractionDigits = Math.max(0,newValue);</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        if (maximumFractionDigits &lt; minimumFractionDigits) {</span>
<span class="fc" id="L778">            maximumFractionDigits = minimumFractionDigits;</span>
        }
<span class="fc" id="L780">    }</span>

    /**
     * Gets the currency used by this number format when formatting
     * currency values. The initial value is derived in a locale dependent
     * way. The returned value may be null if no valid
     * currency could be determined and no currency has been set using
     * {@link #setCurrency(java.util.Currency) setCurrency}.
     * &lt;p&gt;
     * The default implementation throws
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return the currency used by this number format, or &lt;code&gt;null&lt;/code&gt;
     * @exception UnsupportedOperationException if the number format class
     * doesn't implement currency formatting
     * @since 1.4
     */
    public Currency getCurrency() {
<span class="nc" id="L798">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Sets the currency used by this number format when formatting
     * currency values. This does not update the minimum or maximum
     * number of fraction digits used by the number format.
     * &lt;p&gt;
     * The default implementation throws
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @param currency the new currency to be used by this number format
     * @exception UnsupportedOperationException if the number format class
     * doesn't implement currency formatting
     * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null
     * @since 1.4
     */
    public void setCurrency(Currency currency) {
<span class="nc" id="L816">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Gets the {@link java.math.RoundingMode} used in this NumberFormat.
     * The default implementation of this method in NumberFormat
     * always throws {@link java.lang.UnsupportedOperationException}.
     * Subclasses which handle different rounding modes should override
     * this method.
     *
     * @exception UnsupportedOperationException The default implementation
     *     always throws this exception
     * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this NumberFormat.
     * @see #setRoundingMode(RoundingMode)
     * @since 1.6
     */
    public RoundingMode getRoundingMode() {
<span class="nc" id="L833">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Sets the {@link java.math.RoundingMode} used in this NumberFormat.
     * The default implementation of this method in NumberFormat always
     * throws {@link java.lang.UnsupportedOperationException}.
     * Subclasses which handle different rounding modes should override
     * this method.
     *
     * @exception UnsupportedOperationException The default implementation
     *     always throws this exception
     * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null
     * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used
     * @see #getRoundingMode()
     * @since 1.6
     */
    public void setRoundingMode(RoundingMode roundingMode) {
<span class="nc" id="L851">        throw new UnsupportedOperationException();</span>
    }

    // =======================privates===============================

    private static NumberFormat getInstance(Locale desiredLocale,
                                           int choice) {
        LocaleProviderAdapter adapter;
<span class="fc" id="L859">        adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class,</span>
                                                   desiredLocale);
<span class="fc" id="L861">        NumberFormat numberFormat = getInstance(adapter, desiredLocale, choice);</span>
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">        if (numberFormat == null) {</span>
<span class="nc" id="L863">            numberFormat = getInstance(LocaleProviderAdapter.forJRE(),</span>
                                       desiredLocale, choice);
        }
<span class="fc" id="L866">        return numberFormat;</span>
    }

    private static NumberFormat getInstance(LocaleProviderAdapter adapter,
                                            Locale locale, int choice) {
<span class="fc" id="L871">        NumberFormatProvider provider = adapter.getNumberFormatProvider();</span>
<span class="fc" id="L872">        NumberFormat numberFormat = null;</span>
<span class="pc bpc" id="L873" title="1 of 5 branches missed.">        switch (choice) {</span>
        case NUMBERSTYLE:
<span class="fc" id="L875">            numberFormat = provider.getNumberInstance(locale);</span>
<span class="fc" id="L876">            break;</span>
        case PERCENTSTYLE:
<span class="fc" id="L878">            numberFormat = provider.getPercentInstance(locale);</span>
<span class="fc" id="L879">            break;</span>
        case CURRENCYSTYLE:
<span class="fc" id="L881">            numberFormat = provider.getCurrencyInstance(locale);</span>
<span class="fc" id="L882">            break;</span>
        case INTEGERSTYLE:
<span class="fc" id="L884">            numberFormat = provider.getIntegerInstance(locale);</span>
            break;
        }
<span class="fc" id="L887">        return numberFormat;</span>
    }

    /**
     * First, read in the default serializable data.
     *
     * Then, if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
     * the stream was written by JDK 1.1,
     * set the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
     * to be equal to the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt;,
     * since the &lt;code&gt;int&lt;/code&gt; fields were not present in JDK 1.1.
     * Finally, set serialVersionOnStream back to the maximum allowed value so that
     * default serialization will work properly if this object is streamed out again.
     *
     * &lt;p&gt;If &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is greater than
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;minimumFractionDigits&lt;/code&gt;
     * is greater than &lt;code&gt;maximumFractionDigits&lt;/code&gt;, then the stream data
     * is invalid and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
     * In addition, if any of these values is negative, then this method throws
     * an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
     *
     * @since 1.2
     */
    private void readObject(ObjectInputStream stream)
         throws IOException, ClassNotFoundException
    {
<span class="nc" id="L913">        stream.defaultReadObject();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // Didn't have additional int fields, reassign to use them.
<span class="nc" id="L916">            maximumIntegerDigits = maxIntegerDigits;</span>
<span class="nc" id="L917">            minimumIntegerDigits = minIntegerDigits;</span>
<span class="nc" id="L918">            maximumFractionDigits = maxFractionDigits;</span>
<span class="nc" id="L919">            minimumFractionDigits = minFractionDigits;</span>
        }
<span class="nc bnc" id="L921" title="All 8 branches missed.">        if (minimumIntegerDigits &gt; maximumIntegerDigits ||</span>
            minimumFractionDigits &gt; maximumFractionDigits ||
            minimumIntegerDigits &lt; 0 || minimumFractionDigits &lt; 0) {
<span class="nc" id="L924">            throw new InvalidObjectException(&quot;Digit count range invalid&quot;);</span>
        }
<span class="nc" id="L926">        serialVersionOnStream = currentSerialVersion;</span>
<span class="nc" id="L927">    }</span>

    /**
     * Write out the default serializable data, after first setting
     * the &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; to be
     * equal to the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
     * (or to &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;, whichever is smaller), for compatibility
     * with the JDK 1.1 version of the stream format.
     *
     * @since 1.2
     */
    private void writeObject(ObjectOutputStream stream)
         throws IOException
    {
<span class="nc bnc" id="L941" title="All 2 branches missed.">        maxIntegerDigits = (maximumIntegerDigits &gt; Byte.MAX_VALUE) ?</span>
                           Byte.MAX_VALUE : (byte)maximumIntegerDigits;
<span class="nc bnc" id="L943" title="All 2 branches missed.">        minIntegerDigits = (minimumIntegerDigits &gt; Byte.MAX_VALUE) ?</span>
                           Byte.MAX_VALUE : (byte)minimumIntegerDigits;
<span class="nc bnc" id="L945" title="All 2 branches missed.">        maxFractionDigits = (maximumFractionDigits &gt; Byte.MAX_VALUE) ?</span>
                            Byte.MAX_VALUE : (byte)maximumFractionDigits;
<span class="nc bnc" id="L947" title="All 2 branches missed.">        minFractionDigits = (minimumFractionDigits &gt; Byte.MAX_VALUE) ?</span>
                            Byte.MAX_VALUE : (byte)minimumFractionDigits;
<span class="nc" id="L949">        stream.defaultWriteObject();</span>
<span class="nc" id="L950">    }</span>

    // Constants used by factory methods to specify a style of format.
    private static final int NUMBERSTYLE = 0;
    private static final int CURRENCYSTYLE = 1;
    private static final int PERCENTSTYLE = 2;
    private static final int SCIENTIFICSTYLE = 3;
    private static final int INTEGERSTYLE = 4;

    /**
     * True if the grouping (i.e. thousands) separator is used when
     * formatting and parsing numbers.
     *
     * @serial
     * @see #isGroupingUsed
     */
<span class="fc" id="L966">    private boolean groupingUsed = true;</span>

    /**
     * The maximum number of digits allowed in the integer portion of a
     * number.  &lt;code&gt;maxIntegerDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minIntegerDigits&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
     * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumIntegerDigits&lt;/code&gt; is used instead.
     * When writing to a stream, &lt;code&gt;maxIntegerDigits&lt;/code&gt; is set to
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
     * whichever is smaller.  When reading from a stream, this field is used
     * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.
     *
     * @serial
     * @see #getMaximumIntegerDigits
     */
<span class="fc" id="L984">    private byte    maxIntegerDigits = 40;</span>

    /**
     * The minimum number of digits allowed in the integer portion of a
     * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
     * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumIntegerDigits&lt;/code&gt; is used instead.
     * When writing to a stream, &lt;code&gt;minIntegerDigits&lt;/code&gt; is set to
     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
     * whichever is smaller.  When reading from a stream, this field is used
     * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.
     *
     * @serial
     * @see #getMinimumIntegerDigits
     */
<span class="fc" id="L1002">    private byte    minIntegerDigits = 1;</span>

    /**
     * The maximum number of digits allowed in the fractional portion of a
     * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
     * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;maximumFractionDigits&lt;/code&gt; is used instead.
     * When writing to a stream, &lt;code&gt;maxFractionDigits&lt;/code&gt; is set to
     * &lt;code&gt;maximumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
     * whichever is smaller.  When reading from a stream, this field is used
     * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.
     *
     * @serial
     * @see #getMaximumFractionDigits
     */
<span class="fc" id="L1020">    private byte    maxFractionDigits = 3;    // invariant, &gt;= minFractionDigits</span>

    /**
     * The minimum number of digits allowed in the fractional portion of a
     * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This field exists only for serialization
     * compatibility with JDK 1.1.  In Java platform 2 v1.2 and higher, the new
     * &lt;code&gt;int&lt;/code&gt; field &lt;code&gt;minimumFractionDigits&lt;/code&gt; is used instead.
     * When writing to a stream, &lt;code&gt;minFractionDigits&lt;/code&gt; is set to
     * &lt;code&gt;minimumFractionDigits&lt;/code&gt; or &lt;code&gt;Byte.MAX_VALUE&lt;/code&gt;,
     * whichever is smaller.  When reading from a stream, this field is used
     * only if &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1.
     *
     * @serial
     * @see #getMinimumFractionDigits
     */
<span class="fc" id="L1038">    private byte    minFractionDigits = 0;</span>

    /**
     * True if this format will parse numbers as integers only.
     *
     * @serial
     * @see #isParseIntegerOnly
     */
<span class="fc" id="L1046">    private boolean parseIntegerOnly = false;</span>

    // new fields for 1.2.  byte is too small for integer digits.

    /**
     * The maximum number of digits allowed in the integer portion of a
     * number.  &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.
     *
     * @serial
     * @since 1.2
     * @see #getMaximumIntegerDigits
     */
<span class="fc" id="L1059">    private int    maximumIntegerDigits = 40;</span>

    /**
     * The minimum number of digits allowed in the integer portion of a
     * number.  &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.
     *
     * @serial
     * @since 1.2
     * @see #getMinimumIntegerDigits
     */
<span class="fc" id="L1070">    private int    minimumIntegerDigits = 1;</span>

    /**
     * The maximum number of digits allowed in the fractional portion of a
     * number.  &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.
     *
     * @serial
     * @since 1.2
     * @see #getMaximumFractionDigits
     */
<span class="fc" id="L1081">    private int    maximumFractionDigits = 3;    // invariant, &gt;= minFractionDigits</span>

    /**
     * The minimum number of digits allowed in the fractional portion of a
     * number.  &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.
     *
     * @serial
     * @since 1.2
     * @see #getMinimumFractionDigits
     */
<span class="fc" id="L1092">    private int    minimumFractionDigits = 0;</span>

    static final int currentSerialVersion = 1;

    /**
     * Describes the version of &lt;code&gt;NumberFormat&lt;/code&gt; present on the stream.
     * Possible values are:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (or uninitialized): the JDK 1.1 version of the stream format.
     *     In this version, the &lt;code&gt;int&lt;/code&gt; fields such as
     *     &lt;code&gt;maximumIntegerDigits&lt;/code&gt; were not present, and the &lt;code&gt;byte&lt;/code&gt;
     *     fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are used instead.
     *
     * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: the 1.2 version of the stream format.  The values of the
     *     &lt;code&gt;byte&lt;/code&gt; fields such as &lt;code&gt;maxIntegerDigits&lt;/code&gt; are ignored,
     *     and the &lt;code&gt;int&lt;/code&gt; fields such as &lt;code&gt;maximumIntegerDigits&lt;/code&gt;
     *     are used instead.
     * &lt;/ul&gt;
     * When streaming out a &lt;code&gt;NumberFormat&lt;/code&gt;, the most recent format
     * (corresponding to the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;)
     * is always written.
     *
     * @serial
     * @since 1.2
     */
<span class="fc" id="L1117">    private int serialVersionOnStream = currentSerialVersion;</span>

    // Removed &quot;implements Cloneable&quot; clause.  Needs to update serialization
    // ID for backward compatibility.
    static final long serialVersionUID = -2308460125733713944L;


    //
    // class for AttributedCharacterIterator attributes
    //
    /**
     * Defines constants that are used as attribute keys in the
     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
     * from &lt;code&gt;NumberFormat.formatToCharacterIterator&lt;/code&gt; and as
     * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
     *
     * @since 1.4
     */
    public static class Field extends Format.Field {

        // Proclaim serial compatibility with 1.4 FCS
        private static final long serialVersionUID = 7494728892700160890L;

        // table of all instances in this class, used by readResolve
<span class="fc" id="L1141">        private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(11);</span>

        /**
         * Creates a Field instance with the specified
         * name.
         *
         * @param name Name of the attribute
         */
        protected Field(String name) {
<span class="fc" id="L1150">            super(name);</span>
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">            if (this.getClass() == NumberFormat.Field.class) {</span>
<span class="fc" id="L1152">                instanceMap.put(name, this);</span>
            }
<span class="fc" id="L1154">        }</span>

        /**
         * Resolves instances being deserialized to the predefined constants.
         *
         * @throws InvalidObjectException if the constant could not be resolved.
         * @return resolved NumberFormat.Field constant
         */
        @Override
        protected Object readResolve() throws InvalidObjectException {
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            if (this.getClass() != NumberFormat.Field.class) {</span>
<span class="nc" id="L1165">                throw new InvalidObjectException(&quot;subclass didn't correctly implement readResolve&quot;);</span>
            }

<span class="nc" id="L1168">            Object instance = instanceMap.get(getName());</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            if (instance != null) {</span>
<span class="nc" id="L1170">                return instance;</span>
            } else {
<span class="nc" id="L1172">                throw new InvalidObjectException(&quot;unknown attribute name&quot;);</span>
            }
        }

        /**
         * Constant identifying the integer field.
         */
<span class="fc" id="L1179">        public static final Field INTEGER = new Field(&quot;integer&quot;);</span>

        /**
         * Constant identifying the fraction field.
         */
<span class="fc" id="L1184">        public static final Field FRACTION = new Field(&quot;fraction&quot;);</span>

        /**
         * Constant identifying the exponent field.
         */
<span class="fc" id="L1189">        public static final Field EXPONENT = new Field(&quot;exponent&quot;);</span>

        /**
         * Constant identifying the decimal separator field.
         */
<span class="fc" id="L1194">        public static final Field DECIMAL_SEPARATOR =</span>
                            new Field(&quot;decimal separator&quot;);

        /**
         * Constant identifying the sign field.
         */
<span class="fc" id="L1200">        public static final Field SIGN = new Field(&quot;sign&quot;);</span>

        /**
         * Constant identifying the grouping separator field.
         */
<span class="fc" id="L1205">        public static final Field GROUPING_SEPARATOR =</span>
                            new Field(&quot;grouping separator&quot;);

        /**
         * Constant identifying the exponent symbol field.
         */
<span class="fc" id="L1211">        public static final Field EXPONENT_SYMBOL = new</span>
                            Field(&quot;exponent symbol&quot;);

        /**
         * Constant identifying the percent field.
         */
<span class="fc" id="L1217">        public static final Field PERCENT = new Field(&quot;percent&quot;);</span>

        /**
         * Constant identifying the permille field.
         */
<span class="fc" id="L1222">        public static final Field PERMILLE = new Field(&quot;per mille&quot;);</span>

        /**
         * Constant identifying the currency field.
         */
<span class="fc" id="L1227">        public static final Field CURRENCY = new Field(&quot;currency&quot;);</span>

        /**
         * Constant identifying the exponent sign field.
         */
<span class="fc" id="L1232">        public static final Field EXPONENT_SIGN = new Field(&quot;exponent sign&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>