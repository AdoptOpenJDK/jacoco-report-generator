<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DecimalFormat.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">DecimalFormat.java</span></div><h1>DecimalFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.text.spi.NumberFormatProvider;
import java.util.ArrayList;
import java.util.Currency;
import java.util.Locale;
import java.util.ResourceBundle;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.ResourceBundleBasedAdapter;

/**
 * &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
 * &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
 * features designed to make it possible to parse and format numbers in any
 * locale, including support for Western, Arabic, and Indic digits.  It also
 * supports different kinds of numbers, including integers (123), fixed-point
 * numbers (123.4), scientific notation (1.23E4), percentages (12%), and
 * currency amounts ($123).  All of these can be localized.
 *
 * &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
 * default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;'s factory methods, such
 * as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
 * &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
 * &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
 * &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
 * something like this:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * NumberFormat f = NumberFormat.getInstance(loc);
 * if (f instanceof DecimalFormat) {
 *     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
 * }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
 * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
 * &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
 * symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
 * the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
 * read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.
 *
 * &lt;h3&gt;Patterns&lt;/h3&gt;
 *
 * &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
 * &lt;blockquote&gt;&lt;pre&gt;
 * &lt;i&gt;Pattern:&lt;/i&gt;
 *         &lt;i&gt;PositivePattern&lt;/i&gt;
 *         &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
 * &lt;i&gt;PositivePattern:&lt;/i&gt;
 *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;NegativePattern:&lt;/i&gt;
 *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;Prefix:&lt;/i&gt;
 *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 * &lt;i&gt;Suffix:&lt;/i&gt;
 *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
 * &lt;i&gt;Number:&lt;/i&gt;
 *         &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 *         &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;Integer:&lt;/i&gt;
 *         &lt;i&gt;MinimumInteger&lt;/i&gt;
 *         #
 *         # &lt;i&gt;Integer&lt;/i&gt;
 *         # , &lt;i&gt;Integer&lt;/i&gt;
 * &lt;i&gt;MinimumInteger:&lt;/i&gt;
 *         0
 *         0 &lt;i&gt;MinimumInteger&lt;/i&gt;
 *         0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
 * &lt;i&gt;Fraction:&lt;/i&gt;
 *         &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;MinimumFraction:&lt;/i&gt;
 *         0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;OptionalFraction:&lt;/i&gt;
 *         # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;i&gt;Exponent:&lt;/i&gt;
 *         E &lt;i&gt;MinimumExponent&lt;/i&gt;
 * &lt;i&gt;MinimumExponent:&lt;/i&gt;
 *         0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
 * subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each
 * subpattern has a prefix, numeric part, and suffix. The negative subpattern
 * is optional; if absent, then the positive subpattern prefixed with the
 * localized minus sign (&lt;code&gt;'-'&lt;/code&gt; in most locales) is used as the
 * negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to
 * &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it
 * serves only to specify the negative prefix and suffix; the number of digits,
 * minimal digits, and other characteristics are all the same as the positive
 * pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely
 * the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.
 *
 * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
 * thousands separators, decimal separators, etc. may be set to arbitrary
 * values, and they will appear properly during formatting.  However, care must
 * be taken that the symbols and strings do not conflict, or parsing will be
 * unreliable.  For example, either the positive and negative prefixes or the
 * suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
 * to distinguish positive from negative values.  (If they are identical, then
 * &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
 * specified.)  Another example is that the decimal separator and thousands
 * separator should be distinct characters, or parsing will be impossible.
 *
 * &lt;p&gt;The grouping separator is commonly used for thousands, but in some
 * countries it separates ten-thousands. The grouping size is a constant number
 * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
 * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the
 * interval between the last one and the end of the integer is the one that is
 * used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==
 * &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.
 *
 * &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;
 *
 * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
 * parsing and output unchanged during formatting.  Special characters, on the
 * other hand, stand for other characters, strings, or classes of characters.
 * They must be quoted, unless noted otherwise, if they are to appear in the
 * prefix or suffix as literals.
 *
 * &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
 * patterns use the corresponding characters taken from this formatter's
 * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
 * their special status.  Two exceptions are the currency sign and quote, which
 * are not localized.
 *
 * &lt;blockquote&gt;
 * &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart showing symbol,
 *  location, localized, and meaning.&quot;&gt;
 *     &lt;tr style=&quot;background-color: rgb(204, 204, 255);&quot;&gt;
 *          &lt;th align=left&gt;Symbol
 *          &lt;th align=left&gt;Location
 *          &lt;th align=left&gt;Localized?
 *          &lt;th align=left&gt;Meaning
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Digit
 *     &lt;tr style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *          &lt;td&gt;&lt;code&gt;#&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Digit, zero shows as absent
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;.&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Decimal separator or monetary decimal separator
 *     &lt;tr style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *          &lt;td&gt;&lt;code&gt;-&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Minus sign
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;,&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Grouping separator
 *     &lt;tr style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *          &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
 *          &lt;td&gt;Number
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Separates mantissa and exponent in scientific notation.
 *              &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;;&lt;/code&gt;
 *          &lt;td&gt;Subpattern boundary
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Separates positive and negative subpatterns
 *     &lt;tr style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *          &lt;td&gt;&lt;code&gt;%&lt;/code&gt;
 *          &lt;td&gt;Prefix or suffix
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Multiply by 100 and show as percentage
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
 *          &lt;td&gt;Prefix or suffix
 *          &lt;td&gt;Yes
 *          &lt;td&gt;Multiply by 1000 and show as per mille value
 *     &lt;tr style=&quot;vertical-align: top; background-color: rgb(238, 238, 255);&quot;&gt;
 *          &lt;td&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
 *          &lt;td&gt;Prefix or suffix
 *          &lt;td&gt;No
 *          &lt;td&gt;Currency sign, replaced by currency symbol.  If
 *              doubled, replaced by international currency symbol.
 *              If present in a pattern, the monetary decimal separator
 *              is used instead of the decimal separator.
 *     &lt;tr valign=top&gt;
 *          &lt;td&gt;&lt;code&gt;'&lt;/code&gt;
 *          &lt;td&gt;Prefix or suffix
 *          &lt;td&gt;No
 *          &lt;td&gt;Used to quote special characters in a prefix or suffix,
 *              for example, &lt;code&gt;&quot;'#'#&quot;&lt;/code&gt; formats 123 to
 *              &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
 *              itself, use two in a row: &lt;code&gt;&quot;# o''clock&quot;&lt;/code&gt;.
 * &lt;/table&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;h4&gt;Scientific Notation&lt;/h4&gt;
 *
 * &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
 * and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
 * mantissa is often in the range 1.0 &amp;le; x {@literal &lt;} 10.0, but it need not
 * be.
 * &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
 * notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
 * that creates a scientific notation format.  In a pattern, the exponent
 * character immediately followed by one or more digit characters indicates
 * scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number
 * 1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.
 *
 * &lt;ul&gt;
 * &lt;li&gt;The number of digit characters after the exponent character gives the
 * minimum exponent digit count.  There is no maximum.  Negative exponents are
 * formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
 * from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.
 *
 * &lt;li&gt;The minimum and maximum number of integer digits are interpreted
 * together:
 *
 * &lt;ul&gt;
 * &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
 * and greater than 1, it forces the exponent to be a multiple of the maximum
 * number of integer digits, and the minimum number of integer digits to be
 * interpreted as 1.  The most common use of this is to generate
 * &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
 * e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345
 * formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to
 * &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.
 *
 * &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
 * exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields
 * &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.
 * &lt;/ul&gt;
 *
 * &lt;li&gt;The number of significant digits in the mantissa is the sum of the
 * &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
 * unaffected by the maximum integer digits.  For example, 12345 formatted with
 * &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set
 * the significant digits count to zero.  The number of significant digits
 * does not affect parsing.
 *
 * &lt;li&gt;Exponential patterns may not contain grouping separators.
 * &lt;/ul&gt;
 *
 * &lt;h4&gt;Rounding&lt;/h4&gt;
 *
 * &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in
 * {@link java.math.RoundingMode} for formatting.  By default, it uses
 * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
 *
 * &lt;h4&gt;Digits&lt;/h4&gt;
 *
 * For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
 * characters starting with the localized zero digit defined in the
 * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
 * digits as well as all Unicode decimal digits, as defined by
 * {@link Character#digit Character.digit}, are recognized.
 *
 * &lt;h4&gt;Special Values&lt;/h4&gt;
 *
 * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
 * &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
 * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
 * the prefixes and suffixes are not used.
 *
 * &lt;p&gt;Infinity is formatted as a string, which typically has a single character
 * &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
 * applied.  The infinity string is determined by the
 * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
 *
 * &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
 * true,
 * &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
 *     and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
 * &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
 * and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
 * &lt;/ul&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Decimal formats are generally not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 *
 * &lt;blockquote&gt;&lt;pre&gt;{@code
 * &lt;strong&gt;// Print out a number using the localized number, integer, currency,
 * // and percent format for each locale&lt;/strong&gt;
 * Locale[] locales = NumberFormat.getAvailableLocales();
 * double myNumber = -1234.56;
 * NumberFormat form;
 * for (int j = 0; j &lt; 4; ++j) {
 *     System.out.println(&quot;FORMAT&quot;);
 *     for (int i = 0; i &lt; locales.length; ++i) {
 *         if (locales[i].getCountry().length() == 0) {
 *            continue; // Skip language-only locales
 *         }
 *         System.out.print(locales[i].getDisplayName());
 *         switch (j) {
 *         case 0:
 *             form = NumberFormat.getInstance(locales[i]); break;
 *         case 1:
 *             form = NumberFormat.getIntegerInstance(locales[i]); break;
 *         case 2:
 *             form = NumberFormat.getCurrencyInstance(locales[i]); break;
 *         default:
 *             form = NumberFormat.getPercentInstance(locales[i]); break;
 *         }
 *         if (form instanceof DecimalFormat) {
 *             System.out.print(&quot;: &quot; + ((DecimalFormat) form).toPattern());
 *         }
 *         System.out.print(&quot; -&gt; &quot; + form.format(myNumber));
 *         try {
 *             System.out.println(&quot; -&gt; &quot; + form.parse(form.format(myNumber)));
 *         } catch (ParseException e) {}
 *     }
 * }
 * }&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @see          &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;
 * @see          NumberFormat
 * @see          DecimalFormatSymbols
 * @see          ParsePosition
 * @author       Mark Davis
 * @author       Alan Liu
 */
<span class="fc bfc" id="L381" title="All 2 branches covered.">public class DecimalFormat extends NumberFormat {</span>

    /**
     * Creates a DecimalFormat using the default pattern and symbols
     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * This is a convenient way to obtain a
     * DecimalFormat when internationalization is not the main concern.
     * &lt;p&gt;
     * To obtain standard formats for a given locale, use the factory methods
     * on NumberFormat such as getNumberInstance. These factories will
     * return the most appropriate sub-class of NumberFormat for a given
     * locale.
     *
     * @see java.text.NumberFormat#getInstance
     * @see java.text.NumberFormat#getNumberInstance
     * @see java.text.NumberFormat#getCurrencyInstance
     * @see java.text.NumberFormat#getPercentInstance
     */
<span class="nc" id="L399">    public DecimalFormat() {</span>
        // Get the pattern for the default locale.
<span class="nc" id="L401">        Locale def = Locale.getDefault(Locale.Category.FORMAT);</span>
<span class="nc" id="L402">        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class, def);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (!(adapter instanceof ResourceBundleBasedAdapter)) {</span>
<span class="nc" id="L404">            adapter = LocaleProviderAdapter.getResourceBundleBased();</span>
        }
<span class="nc" id="L406">        String[] all = adapter.getLocaleResources(def).getNumberPatterns();</span>

        // Always applyPattern after the symbols are set
<span class="nc" id="L409">        this.symbols = DecimalFormatSymbols.getInstance(def);</span>
<span class="nc" id="L410">        applyPattern(all[0], false);</span>
<span class="nc" id="L411">    }</span>


    /**
     * Creates a DecimalFormat using the given pattern and the symbols
     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * This is a convenient way to obtain a
     * DecimalFormat when internationalization is not the main concern.
     * &lt;p&gt;
     * To obtain standard formats for a given locale, use the factory methods
     * on NumberFormat such as getNumberInstance. These factories will
     * return the most appropriate sub-class of NumberFormat for a given
     * locale.
     *
     * @param pattern a non-localized pattern string.
     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null
     * @exception IllegalArgumentException if the given pattern is invalid.
     * @see java.text.NumberFormat#getInstance
     * @see java.text.NumberFormat#getNumberInstance
     * @see java.text.NumberFormat#getCurrencyInstance
     * @see java.text.NumberFormat#getPercentInstance
     */
<span class="nc" id="L433">    public DecimalFormat(String pattern) {</span>
        // Always applyPattern after the symbols are set
<span class="nc" id="L435">        this.symbols = DecimalFormatSymbols.getInstance(Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="nc" id="L436">        applyPattern(pattern, false);</span>
<span class="nc" id="L437">    }</span>


    /**
     * Creates a DecimalFormat using the given pattern and symbols.
     * Use this constructor when you need to completely customize the
     * behavior of the format.
     * &lt;p&gt;
     * To obtain standard formats for a given
     * locale, use the factory methods on NumberFormat such as
     * getInstance or getCurrencyInstance. If you need only minor adjustments
     * to a standard format, you can modify the format returned by
     * a NumberFormat factory method.
     *
     * @param pattern a non-localized pattern string
     * @param symbols the set of symbols to be used
     * @exception NullPointerException if any of the given arguments is null
     * @exception IllegalArgumentException if the given pattern is invalid
     * @see java.text.NumberFormat#getInstance
     * @see java.text.NumberFormat#getNumberInstance
     * @see java.text.NumberFormat#getCurrencyInstance
     * @see java.text.NumberFormat#getPercentInstance
     * @see java.text.DecimalFormatSymbols
     */
<span class="fc" id="L461">    public DecimalFormat (String pattern, DecimalFormatSymbols symbols) {</span>
        // Always applyPattern after the symbols are set
<span class="fc" id="L463">        this.symbols = (DecimalFormatSymbols)symbols.clone();</span>
<span class="fc" id="L464">        applyPattern(pattern, false);</span>
<span class="fc" id="L465">    }</span>


    // Overrides
    /**
     * Formats a number and appends the resulting text to the given string
     * buffer.
     * The number can be of any subclass of {@link java.lang.Number}.
     * &lt;p&gt;
     * This implementation uses the maximum precision permitted.
     * @param number     the number to format
     * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
     *                   text is to be appended
     * @param pos        On input: an alignment field, if desired.
     *                   On output: the offsets of the alignment field.
     * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;
     * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is
     *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.
     * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
     *                   &lt;code&gt;pos&lt;/code&gt; is null
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see              java.text.FieldPosition
     */
    @Override
    public final StringBuffer format(Object number,
                                     StringBuffer toAppendTo,
                                     FieldPosition pos) {
<span class="pc bpc" id="L493" title="11 of 14 branches missed.">        if (number instanceof Long || number instanceof Integer ||</span>
                   number instanceof Short || number instanceof Byte ||
                   number instanceof AtomicInteger ||
                   number instanceof AtomicLong ||
                   (number instanceof BigInteger &amp;&amp;
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    ((BigInteger)number).bitLength () &lt; 64)) {</span>
<span class="fc" id="L499">            return format(((Number)number).longValue(), toAppendTo, pos);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        } else if (number instanceof BigDecimal) {</span>
<span class="nc" id="L501">            return format((BigDecimal)number, toAppendTo, pos);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        } else if (number instanceof BigInteger) {</span>
<span class="nc" id="L503">            return format((BigInteger)number, toAppendTo, pos);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">        } else if (number instanceof Number) {</span>
<span class="nc" id="L505">            return format(((Number)number).doubleValue(), toAppendTo, pos);</span>
        } else {
<span class="nc" id="L507">            throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);</span>
        }
    }

    /**
     * Formats a double to produce a string.
     * @param number    The double to format
     * @param result    where the text is to be appended
     * @param fieldPosition    On input: an alignment field, if desired.
     * On output: the offsets of the alignment field.
     * @exception ArithmeticException if rounding is needed with rounding
     *            mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     * @see java.text.FieldPosition
     */
    @Override
    public StringBuffer format(double number, StringBuffer result,
                               FieldPosition fieldPosition) {
        // If fieldPosition is a DontCareFieldPosition instance we can
        // try to go to fast-path code.
<span class="nc" id="L527">        boolean tryFastPath = false;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (fieldPosition == DontCareFieldPosition.INSTANCE)</span>
<span class="nc" id="L529">            tryFastPath = true;</span>
        else {
<span class="nc" id="L531">            fieldPosition.setBeginIndex(0);</span>
<span class="nc" id="L532">            fieldPosition.setEndIndex(0);</span>
        }

<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (tryFastPath) {</span>
<span class="nc" id="L536">            String tempResult = fastFormat(number);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (tempResult != null) {</span>
<span class="nc" id="L538">                result.append(tempResult);</span>
<span class="nc" id="L539">                return result;</span>
            }
        }

        // if fast-path could not work, we fallback to standard code.
<span class="nc" id="L544">        return format(number, result, fieldPosition.getFieldDelegate());</span>
    }

    /**
     * Formats a double to produce a string.
     * @param number    The double to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception       ArithmeticException if rounding is needed with rounding
     *                  mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     */
    private StringBuffer format(double number, StringBuffer result,
                                FieldDelegate delegate) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">        if (Double.isNaN(number) ||</span>
<span class="nc bnc" id="L559" title="All 4 branches missed.">           (Double.isInfinite(number) &amp;&amp; multiplier == 0)) {</span>
<span class="nc" id="L560">            int iFieldStart = result.length();</span>
<span class="nc" id="L561">            result.append(symbols.getNaN());</span>
<span class="nc" id="L562">            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,</span>
<span class="nc" id="L563">                               iFieldStart, result.length(), result);</span>
<span class="nc" id="L564">            return result;</span>
        }

        /* Detecting whether a double is negative is easy with the exception of
         * the value -0.0.  This is a double which has a zero mantissa (and
         * exponent), but a negative sign bit.  It is semantically distinct from
         * a zero with a positive sign bit, and this distinction is important
         * to certain kinds of computations.  However, it's a little tricky to
         * detect, since (-0.0 == 0.0) and !(-0.0 &lt; 0.0).  How then, you may
         * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==
         * -Infinity.  Proper detection of -0.0 is needed to deal with the
         * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.
         */
<span class="nc bnc" id="L577" title="All 8 branches missed.">        boolean isNegative = ((number &lt; 0.0) || (number == 0.0 &amp;&amp; 1/number &lt; 0.0)) ^ (multiplier &lt; 0);</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (multiplier != 1) {</span>
<span class="nc" id="L580">            number *= multiplier;</span>
        }

<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (Double.isInfinite(number)) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (isNegative) {</span>
<span class="nc" id="L585">                append(result, negativePrefix, delegate,</span>
<span class="nc" id="L586">                       getNegativePrefixFieldPositions(), Field.SIGN);</span>
            } else {
<span class="nc" id="L588">                append(result, positivePrefix, delegate,</span>
<span class="nc" id="L589">                       getPositivePrefixFieldPositions(), Field.SIGN);</span>
            }

<span class="nc" id="L592">            int iFieldStart = result.length();</span>
<span class="nc" id="L593">            result.append(symbols.getInfinity());</span>
<span class="nc" id="L594">            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,</span>
<span class="nc" id="L595">                               iFieldStart, result.length(), result);</span>

<span class="nc bnc" id="L597" title="All 2 branches missed.">            if (isNegative) {</span>
<span class="nc" id="L598">                append(result, negativeSuffix, delegate,</span>
<span class="nc" id="L599">                       getNegativeSuffixFieldPositions(), Field.SIGN);</span>
            } else {
<span class="nc" id="L601">                append(result, positiveSuffix, delegate,</span>
<span class="nc" id="L602">                       getPositiveSuffixFieldPositions(), Field.SIGN);</span>
            }

<span class="nc" id="L605">            return result;</span>
        }

<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L609">            number = -number;</span>
        }

        // at this point we are guaranteed a nonnegative finite number.
<span class="nc bnc" id="L613" title="All 6 branches missed.">        assert(number &gt;= 0 &amp;&amp; !Double.isInfinite(number));</span>

<span class="nc" id="L615">        synchronized(digitList) {</span>
<span class="nc" id="L616">            int maxIntDigits = super.getMaximumIntegerDigits();</span>
<span class="nc" id="L617">            int minIntDigits = super.getMinimumIntegerDigits();</span>
<span class="nc" id="L618">            int maxFraDigits = super.getMaximumFractionDigits();</span>
<span class="nc" id="L619">            int minFraDigits = super.getMinimumFractionDigits();</span>

<span class="nc bnc" id="L621" title="All 4 branches missed.">            digitList.set(isNegative, number, useExponentialNotation ?</span>
                          maxIntDigits + maxFraDigits : maxFraDigits,
                          !useExponentialNotation);
<span class="nc" id="L624">            return subformat(result, delegate, isNegative, false,</span>
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<span class="nc" id="L626">        }</span>
    }

    /**
     * Format a long to produce a string.
     * @param number    The long to format
     * @param result    where the text is to be appended
     * @param fieldPosition    On input: an alignment field, if desired.
     * On output: the offsets of the alignment field.
     * @exception       ArithmeticException if rounding is needed with rounding
     *                  mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     * @see java.text.FieldPosition
     */
    @Override
    public StringBuffer format(long number, StringBuffer result,
                               FieldPosition fieldPosition) {
<span class="fc" id="L643">        fieldPosition.setBeginIndex(0);</span>
<span class="fc" id="L644">        fieldPosition.setEndIndex(0);</span>

<span class="fc" id="L646">        return format(number, result, fieldPosition.getFieldDelegate());</span>
    }

    /**
     * Format a long to produce a string.
     * @param number    The long to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     */
    private StringBuffer format(long number, StringBuffer result,
                               FieldDelegate delegate) {
<span class="fc bfc" id="L661" title="All 2 branches covered.">        boolean isNegative = (number &lt; 0);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L663">            number = -number;</span>
        }

        // In general, long values always represent real finite numbers, so
        // we don't have to check for +/- Infinity or NaN.  However, there
        // is one case we have to be careful of:  The multiplier can push
        // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
        // check for this before multiplying, and if it happens we use
        // BigInteger instead.
<span class="fc" id="L672">        boolean useBigInteger = false;</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (number &lt; 0) { // This can only happen if number == Long.MIN_VALUE.</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            if (multiplier != 0) {</span>
<span class="nc" id="L675">                useBigInteger = true;</span>
            }
<span class="pc bpc" id="L677" title="3 of 4 branches missed.">        } else if (multiplier != 1 &amp;&amp; multiplier != 0) {</span>
<span class="nc" id="L678">            long cutoff = Long.MAX_VALUE / multiplier;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (cutoff &lt; 0) {</span>
<span class="nc" id="L680">                cutoff = -cutoff;</span>
            }
<span class="nc bnc" id="L682" title="All 2 branches missed.">            useBigInteger = (number &gt; cutoff);</span>
        }

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (useBigInteger) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            if (isNegative) {</span>
<span class="nc" id="L687">                number = -number;</span>
            }
<span class="nc" id="L689">            BigInteger bigIntegerValue = BigInteger.valueOf(number);</span>
<span class="nc" id="L690">            return format(bigIntegerValue, result, delegate, true);</span>
        }

<span class="fc" id="L693">        number *= multiplier;</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (number == 0) {</span>
<span class="nc" id="L695">            isNegative = false;</span>
        } else {
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if (multiplier &lt; 0) {</span>
<span class="nc" id="L698">                number = -number;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                isNegative = !isNegative;</span>
            }
        }

<span class="fc" id="L703">        synchronized(digitList) {</span>
<span class="fc" id="L704">            int maxIntDigits = super.getMaximumIntegerDigits();</span>
<span class="fc" id="L705">            int minIntDigits = super.getMinimumIntegerDigits();</span>
<span class="fc" id="L706">            int maxFraDigits = super.getMaximumFractionDigits();</span>
<span class="fc" id="L707">            int minFraDigits = super.getMinimumFractionDigits();</span>

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            digitList.set(isNegative, number,</span>
                     useExponentialNotation ? maxIntDigits + maxFraDigits : 0);

<span class="fc" id="L712">            return subformat(result, delegate, isNegative, true,</span>
                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<span class="nc" id="L714">        }</span>
    }

    /**
     * Formats a BigDecimal to produce a string.
     * @param number    The BigDecimal to format
     * @param result    where the text is to be appended
     * @param fieldPosition    On input: an alignment field, if desired.
     * On output: the offsets of the alignment field.
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     */
    private StringBuffer format(BigDecimal number, StringBuffer result,
                                FieldPosition fieldPosition) {
<span class="nc" id="L730">        fieldPosition.setBeginIndex(0);</span>
<span class="nc" id="L731">        fieldPosition.setEndIndex(0);</span>
<span class="nc" id="L732">        return format(number, result, fieldPosition.getFieldDelegate());</span>
    }

    /**
     * Formats a BigDecimal to produce a string.
     * @param number    The BigDecimal to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @return The formatted number string
     */
    private StringBuffer format(BigDecimal number, StringBuffer result,
                                FieldDelegate delegate) {
<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (multiplier != 1) {</span>
<span class="nc" id="L747">            number = number.multiply(getBigDecimalMultiplier());</span>
        }
<span class="nc bnc" id="L749" title="All 2 branches missed.">        boolean isNegative = number.signum() == -1;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L751">            number = number.negate();</span>
        }

<span class="nc" id="L754">        synchronized(digitList) {</span>
<span class="nc" id="L755">            int maxIntDigits = getMaximumIntegerDigits();</span>
<span class="nc" id="L756">            int minIntDigits = getMinimumIntegerDigits();</span>
<span class="nc" id="L757">            int maxFraDigits = getMaximumFractionDigits();</span>
<span class="nc" id="L758">            int minFraDigits = getMinimumFractionDigits();</span>
<span class="nc" id="L759">            int maximumDigits = maxIntDigits + maxFraDigits;</span>

<span class="nc bnc" id="L761" title="All 6 branches missed.">            digitList.set(isNegative, number, useExponentialNotation ?</span>
                ((maximumDigits &lt; 0) ? Integer.MAX_VALUE : maximumDigits) :
                maxFraDigits, !useExponentialNotation);

<span class="nc" id="L765">            return subformat(result, delegate, isNegative, false,</span>
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<span class="nc" id="L767">        }</span>
    }

    /**
     * Format a BigInteger to produce a string.
     * @param number    The BigInteger to format
     * @param result    where the text is to be appended
     * @param fieldPosition    On input: an alignment field, if desired.
     * On output: the offsets of the alignment field.
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     */
    private StringBuffer format(BigInteger number, StringBuffer result,
                               FieldPosition fieldPosition) {
<span class="nc" id="L783">        fieldPosition.setBeginIndex(0);</span>
<span class="nc" id="L784">        fieldPosition.setEndIndex(0);</span>

<span class="nc" id="L786">        return format(number, result, fieldPosition.getFieldDelegate(), false);</span>
    }

    /**
     * Format a BigInteger to produce a string.
     * @param number    The BigInteger to format
     * @param result    where the text is to be appended
     * @param delegate notified of locations of sub fields
     * @return The formatted number string
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @see java.text.FieldPosition
     */
    private StringBuffer format(BigInteger number, StringBuffer result,
                               FieldDelegate delegate, boolean formatLong) {
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (multiplier != 1) {</span>
<span class="nc" id="L802">            number = number.multiply(getBigIntegerMultiplier());</span>
        }
<span class="nc bnc" id="L804" title="All 2 branches missed.">        boolean isNegative = number.signum() == -1;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (isNegative) {</span>
<span class="nc" id="L806">            number = number.negate();</span>
        }

<span class="nc" id="L809">        synchronized(digitList) {</span>
            int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (formatLong) {</span>
<span class="nc" id="L812">                maxIntDigits = super.getMaximumIntegerDigits();</span>
<span class="nc" id="L813">                minIntDigits = super.getMinimumIntegerDigits();</span>
<span class="nc" id="L814">                maxFraDigits = super.getMaximumFractionDigits();</span>
<span class="nc" id="L815">                minFraDigits = super.getMinimumFractionDigits();</span>
<span class="nc" id="L816">                maximumDigits = maxIntDigits + maxFraDigits;</span>
            } else {
<span class="nc" id="L818">                maxIntDigits = getMaximumIntegerDigits();</span>
<span class="nc" id="L819">                minIntDigits = getMinimumIntegerDigits();</span>
<span class="nc" id="L820">                maxFraDigits = getMaximumFractionDigits();</span>
<span class="nc" id="L821">                minFraDigits = getMinimumFractionDigits();</span>
<span class="nc" id="L822">                maximumDigits = maxIntDigits + maxFraDigits;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">                if (maximumDigits &lt; 0) {</span>
<span class="nc" id="L824">                    maximumDigits = Integer.MAX_VALUE;</span>
                }
            }

<span class="nc bnc" id="L828" title="All 2 branches missed.">            digitList.set(isNegative, number,</span>
                          useExponentialNotation ? maximumDigits : 0);

<span class="nc" id="L831">            return subformat(result, delegate, isNegative, true,</span>
                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<span class="nc" id="L833">        }</span>
    }

    /**
     * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
     * to build the resulting String, as well as to determine information
     * about the resulting String.
     * &lt;p&gt;
     * Each attribute key of the AttributedCharacterIterator will be of type
     * &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the
     * same as the attribute key.
     *
     * @exception NullPointerException if obj is null.
     * @exception IllegalArgumentException when the Format cannot format the
     *            given object.
     * @exception        ArithmeticException if rounding is needed with rounding
     *                   mode being set to RoundingMode.UNNECESSARY
     * @param obj The object to format
     * @return AttributedCharacterIterator describing the formatted value.
     * @since 1.4
     */
    @Override
    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
<span class="nc" id="L857">        CharacterIteratorFieldDelegate delegate =</span>
                         new CharacterIteratorFieldDelegate();
<span class="nc" id="L859">        StringBuffer sb = new StringBuffer();</span>

<span class="nc bnc" id="L861" title="All 4 branches missed.">        if (obj instanceof Double || obj instanceof Float) {</span>
<span class="nc" id="L862">            format(((Number)obj).doubleValue(), sb, delegate);</span>
<span class="nc bnc" id="L863" title="All 12 branches missed.">        } else if (obj instanceof Long || obj instanceof Integer ||</span>
                   obj instanceof Short || obj instanceof Byte ||
                   obj instanceof AtomicInteger || obj instanceof AtomicLong) {
<span class="nc" id="L866">            format(((Number)obj).longValue(), sb, delegate);</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">        } else if (obj instanceof BigDecimal) {</span>
<span class="nc" id="L868">            format((BigDecimal)obj, sb, delegate);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        } else if (obj instanceof BigInteger) {</span>
<span class="nc" id="L870">            format((BigInteger)obj, sb, delegate, false);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">        } else if (obj == null) {</span>
<span class="nc" id="L872">            throw new NullPointerException(</span>
                &quot;formatToCharacterIterator must be passed non-null object&quot;);
        } else {
<span class="nc" id="L875">            throw new IllegalArgumentException(</span>
                &quot;Cannot format given Object as a Number&quot;);
        }
<span class="nc" id="L878">        return delegate.getIterator(sb.toString());</span>
    }

    // ==== Begin fast-path formating logic for double =========================

    /* Fast-path formatting will be used for format(double ...) methods iff a
     * number of conditions are met (see checkAndSetFastPathStatus()):
     * - Only if instance properties meet the right predefined conditions.
     * - The abs value of the double to format is &lt;= Integer.MAX_VALUE.
     *
     * The basic approach is to split the binary to decimal conversion of a
     * double value into two phases:
     * * The conversion of the integer portion of the double.
     * * The conversion of the fractional portion of the double
     *   (limited to two or three digits).
     *
     * The isolation and conversion of the integer portion of the double is
     * straightforward. The conversion of the fraction is more subtle and relies
     * on some rounding properties of double to the decimal precisions in
     * question.  Using the terminology of BigDecimal, this fast-path algorithm
     * is applied when a double value has a magnitude less than Integer.MAX_VALUE
     * and rounding is to nearest even and the destination format has two or
     * three digits of *scale* (digits after the decimal point).
     *
     * Under a rounding to nearest even policy, the returned result is a digit
     * string of a number in the (in this case decimal) destination format
     * closest to the exact numerical value of the (in this case binary) input
     * value.  If two destination format numbers are equally distant, the one
     * with the last digit even is returned.  To compute such a correctly rounded
     * value, some information about digits beyond the smallest returned digit
     * position needs to be consulted.
     *
     * In general, a guard digit, a round digit, and a sticky *bit* are needed
     * beyond the returned digit position.  If the discarded portion of the input
     * is sufficiently large, the returned digit string is incremented.  In round
     * to nearest even, this threshold to increment occurs near the half-way
     * point between digits.  The sticky bit records if there are any remaining
     * trailing digits of the exact input value in the new format; the sticky bit
     * is consulted only in close to half-way rounding cases.
     *
     * Given the computation of the digit and bit values, rounding is then
     * reduced to a table lookup problem.  For decimal, the even/odd cases look
     * like this:
     *
     * Last   Round   Sticky
     * 6      5       0      =&gt; 6   // exactly halfway, return even digit.
     * 6      5       1      =&gt; 7   // a little bit more than halfway, round up.
     * 7      5       0      =&gt; 8   // exactly halfway, round up to even.
     * 7      5       1      =&gt; 8   // a little bit more than halfway, round up.
     * With analogous entries for other even and odd last-returned digits.
     *
     * However, decimal negative powers of 5 smaller than 0.5 are *not* exactly
     * representable as binary fraction.  In particular, 0.005 (the round limit
     * for a two-digit scale) and 0.0005 (the round limit for a three-digit
     * scale) are not representable. Therefore, for input values near these cases
     * the sticky bit is known to be set which reduces the rounding logic to:
     *
     * Last   Round   Sticky
     * 6      5       1      =&gt; 7   // a little bit more than halfway, round up.
     * 7      5       1      =&gt; 8   // a little bit more than halfway, round up.
     *
     * In other words, if the round digit is 5, the sticky bit is known to be
     * set.  If the round digit is something other than 5, the sticky bit is not
     * relevant.  Therefore, some of the logic about whether or not to increment
     * the destination *decimal* value can occur based on tests of *binary*
     * computations of the binary input number.
     */

    /**
     * Check validity of using fast-path for this instance. If fast-path is valid
     * for this instance, sets fast-path state as true and initializes fast-path
     * utility fields as needed.
     *
     * This method is supposed to be called rarely, otherwise that will break the
     * fast-path performance. That means avoiding frequent changes of the
     * properties of the instance, since for most properties, each time a change
     * happens, a call to this method is needed at the next format call.
     *
     * FAST-PATH RULES:
     *  Similar to the default DecimalFormat instantiation case.
     *  More precisely:
     *  - HALF_EVEN rounding mode,
     *  - isGroupingUsed() is true,
     *  - groupingSize of 3,
     *  - multiplier is 1,
     *  - Decimal separator not mandatory,
     *  - No use of exponential notation,
     *  - minimumIntegerDigits is exactly 1 and maximumIntegerDigits at least 10
     *  - For number of fractional digits, the exact values found in the default case:
     *     Currency : min = max = 2.
     *     Decimal  : min = 0. max = 3.
     *
     */
    private void checkAndSetFastPathStatus() {

<span class="nc" id="L973">        boolean fastPathWasOn = isFastPath;</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">        if ((roundingMode == RoundingMode.HALF_EVEN) &amp;&amp;</span>
<span class="nc bnc" id="L976" title="All 10 branches missed.">            (isGroupingUsed()) &amp;&amp;</span>
            (groupingSize == 3) &amp;&amp;
            (multiplier == 1) &amp;&amp;
            (!decimalSeparatorAlwaysShown) &amp;&amp;
            (!useExponentialNotation)) {

            // The fast-path algorithm is semi-hardcoded against
            //  minimumIntegerDigits and maximumIntegerDigits.
<span class="nc bnc" id="L984" title="All 4 branches missed.">            isFastPath = ((minimumIntegerDigits == 1) &amp;&amp;</span>
                          (maximumIntegerDigits &gt;= 10));

            // The fast-path algorithm is hardcoded against
            //  minimumFractionDigits and maximumFractionDigits.
<span class="nc bnc" id="L989" title="All 2 branches missed.">            if (isFastPath) {</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if (isCurrencyFormat) {</span>
<span class="nc bnc" id="L991" title="All 4 branches missed.">                    if ((minimumFractionDigits != 2) ||</span>
                        (maximumFractionDigits != 2))
<span class="nc" id="L993">                        isFastPath = false;</span>
<span class="nc bnc" id="L994" title="All 4 branches missed.">                } else if ((minimumFractionDigits != 0) ||</span>
                           (maximumFractionDigits != 3))
<span class="nc" id="L996">                    isFastPath = false;</span>
            }
        } else
<span class="nc" id="L999">            isFastPath = false;</span>

        // Since some instance properties may have changed while still falling
        // in the fast-path case, we need to reinitialize fastPathData anyway.
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (isFastPath) {</span>
            // We need to instantiate fastPathData if not already done.
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (fastPathData == null)</span>
<span class="nc" id="L1006">                fastPathData = new FastPathData();</span>

            // Sets up the locale specific constants used when formatting.
            // '0' is our default representation of zero.
<span class="nc" id="L1010">            fastPathData.zeroDelta = symbols.getZeroDigit() - '0';</span>
<span class="nc" id="L1011">            fastPathData.groupingChar = symbols.getGroupingSeparator();</span>

            // Sets up fractional constants related to currency/decimal pattern.
<span class="nc bnc" id="L1014" title="All 2 branches missed.">            fastPathData.fractionalMaxIntBound = (isCurrencyFormat) ? 99 : 999;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">            fastPathData.fractionalScaleFactor = (isCurrencyFormat) ? 100.0d : 1000.0d;</span>

            // Records the need for adding prefix or suffix
<span class="nc" id="L1018">            fastPathData.positiveAffixesRequired =</span>
<span class="nc bnc" id="L1019" title="All 4 branches missed.">                (positivePrefix.length() != 0) || (positiveSuffix.length() != 0);</span>
<span class="nc" id="L1020">            fastPathData.negativeAffixesRequired =</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">                (negativePrefix.length() != 0) || (negativeSuffix.length() != 0);</span>

            // Creates a cached char container for result, with max possible size.
<span class="nc" id="L1024">            int maxNbIntegralDigits = 10;</span>
<span class="nc" id="L1025">            int maxNbGroups = 3;</span>
<span class="nc" id="L1026">            int containerSize =</span>
<span class="nc" id="L1027">                Math.max(positivePrefix.length(), negativePrefix.length()) +</span>
                maxNbIntegralDigits + maxNbGroups + 1 + maximumFractionDigits +
<span class="nc" id="L1029">                Math.max(positiveSuffix.length(), negativeSuffix.length());</span>

<span class="nc" id="L1031">            fastPathData.fastPathContainer = new char[containerSize];</span>

            // Sets up prefix and suffix char arrays constants.
<span class="nc" id="L1034">            fastPathData.charsPositiveSuffix = positiveSuffix.toCharArray();</span>
<span class="nc" id="L1035">            fastPathData.charsNegativeSuffix = negativeSuffix.toCharArray();</span>
<span class="nc" id="L1036">            fastPathData.charsPositivePrefix = positivePrefix.toCharArray();</span>
<span class="nc" id="L1037">            fastPathData.charsNegativePrefix = negativePrefix.toCharArray();</span>

            // Sets up fixed index positions for integral and fractional digits.
            // Sets up decimal point in cached result container.
<span class="nc" id="L1041">            int longestPrefixLength =</span>
<span class="nc" id="L1042">                Math.max(positivePrefix.length(), negativePrefix.length());</span>
<span class="nc" id="L1043">            int decimalPointIndex =</span>
                maxNbIntegralDigits + maxNbGroups + longestPrefixLength;

<span class="nc" id="L1046">            fastPathData.integralLastIndex    = decimalPointIndex - 1;</span>
<span class="nc" id="L1047">            fastPathData.fractionalFirstIndex = decimalPointIndex + 1;</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">            fastPathData.fastPathContainer[decimalPointIndex] =</span>
                isCurrencyFormat ?
<span class="nc" id="L1050">                symbols.getMonetaryDecimalSeparator() :</span>
<span class="nc" id="L1051">                symbols.getDecimalSeparator();</span>

<span class="nc bnc" id="L1053" title="All 2 branches missed.">        } else if (fastPathWasOn) {</span>
            // Previous state was fast-path and is no more.
            // Resets cached array constants.
<span class="nc" id="L1056">            fastPathData.fastPathContainer = null;</span>
<span class="nc" id="L1057">            fastPathData.charsPositiveSuffix = null;</span>
<span class="nc" id="L1058">            fastPathData.charsNegativeSuffix = null;</span>
<span class="nc" id="L1059">            fastPathData.charsPositivePrefix = null;</span>
<span class="nc" id="L1060">            fastPathData.charsNegativePrefix = null;</span>
        }

<span class="nc" id="L1063">        fastPathCheckNeeded = false;</span>
<span class="nc" id="L1064">    }</span>

    /**
     * Returns true if rounding-up must be done on {@code scaledFractionalPartAsInt},
     * false otherwise.
     *
     * This is a utility method that takes correct half-even rounding decision on
     * passed fractional value at the scaled decimal point (2 digits for currency
     * case and 3 for decimal case), when the approximated fractional part after
     * scaled decimal point is exactly 0.5d.  This is done by means of exact
     * calculations on the {@code fractionalPart} floating-point value.
     *
     * This method is supposed to be called by private {@code fastDoubleFormat}
     * method only.
     *
     * The algorithms used for the exact calculations are :
     *
     * The &lt;b&gt;&lt;i&gt;FastTwoSum&lt;/i&gt;&lt;/b&gt; algorithm, from T.J.Dekker, described in the
     * papers  &quot;&lt;i&gt;A  Floating-Point   Technique  for  Extending  the  Available
     * Precision&lt;/i&gt;&quot;  by Dekker, and  in &quot;&lt;i&gt;Adaptive  Precision Floating-Point
     * Arithmetic and Fast Robust Geometric Predicates&lt;/i&gt;&quot; from J.Shewchuk.
     *
     * A modified version of &lt;b&gt;&lt;i&gt;Sum2S&lt;/i&gt;&lt;/b&gt; cascaded summation described in
     * &quot;&lt;i&gt;Accurate Sum and Dot Product&lt;/i&gt;&quot; from Takeshi Ogita and All.  As
     * Ogita says in this paper this is an equivalent of the Kahan-Babuska's
     * summation algorithm because we order the terms by magnitude before summing
     * them. For this reason we can use the &lt;i&gt;FastTwoSum&lt;/i&gt; algorithm rather
     * than the more expensive Knuth's &lt;i&gt;TwoSum&lt;/i&gt;.
     *
     * We do this to avoid a more expensive exact &quot;&lt;i&gt;TwoProduct&lt;/i&gt;&quot; algorithm,
     * like those described in Shewchuk's paper above. See comments in the code
     * below.
     *
     * @param  fractionalPart The  fractional value  on which  we  take rounding
     * decision.
     * @param scaledFractionalPartAsInt The integral part of the scaled
     * fractional value.
     *
     * @return the decision that must be taken regarding half-even rounding.
     */
    private boolean exactRoundUp(double fractionalPart,
                                 int scaledFractionalPartAsInt) {

        /* exactRoundUp() method is called by fastDoubleFormat() only.
         * The precondition expected to be verified by the passed parameters is :
         * scaledFractionalPartAsInt ==
         *     (int) (fractionalPart * fastPathData.fractionalScaleFactor).
         * This is ensured by fastDoubleFormat() code.
         */

        /* We first calculate roundoff error made by fastDoubleFormat() on
         * the scaled fractional part. We do this with exact calculation on the
         * passed fractionalPart. Rounding decision will then be taken from roundoff.
         */

        /* ---- TwoProduct(fractionalPart, scale factor (i.e. 1000.0d or 100.0d)).
         *
         * The below is an optimized exact &quot;TwoProduct&quot; calculation of passed
         * fractional part with scale factor, using Ogita's Sum2S cascaded
         * summation adapted as Kahan-Babuska equivalent by using FastTwoSum
         * (much faster) rather than Knuth's TwoSum.
         *
         * We can do this because we order the summation from smallest to
         * greatest, so that FastTwoSum can be used without any additional error.
         *
         * The &quot;TwoProduct&quot; exact calculation needs 17 flops. We replace this by
         * a cascaded summation of FastTwoSum calculations, each involving an
         * exact multiply by a power of 2.
         *
         * Doing so saves overall 4 multiplications and 1 addition compared to
         * using traditional &quot;TwoProduct&quot;.
         *
         * The scale factor is either 100 (currency case) or 1000 (decimal case).
         * - when 1000, we replace it by (1024 - 16 - 8) = 1000.
         * - when 100,  we replace it by (128  - 32 + 4) =  100.
         * Every multiplication by a power of 2 (1024, 128, 32, 16, 8, 4) is exact.
         *
         */
        double approxMax;    // Will always be positive.
        double approxMedium; // Will always be negative.
        double approxMin;

<span class="nc" id="L1146">        double fastTwoSumApproximation = 0.0d;</span>
<span class="nc" id="L1147">        double fastTwoSumRoundOff = 0.0d;</span>
<span class="nc" id="L1148">        double bVirtual = 0.0d;</span>

<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (isCurrencyFormat) {</span>
            // Scale is 100 = 128 - 32 + 4.
            // Multiply by 2**n is a shift. No roundoff. No error.
<span class="nc" id="L1153">            approxMax    = fractionalPart * 128.00d;</span>
<span class="nc" id="L1154">            approxMedium = - (fractionalPart * 32.00d);</span>
<span class="nc" id="L1155">            approxMin    = fractionalPart * 4.00d;</span>
        } else {
            // Scale is 1000 = 1024 - 16 - 8.
            // Multiply by 2**n is a shift. No roundoff. No error.
<span class="nc" id="L1159">            approxMax    = fractionalPart * 1024.00d;</span>
<span class="nc" id="L1160">            approxMedium = - (fractionalPart * 16.00d);</span>
<span class="nc" id="L1161">            approxMin    = - (fractionalPart * 8.00d);</span>
        }

        // Shewchuk/Dekker's FastTwoSum(approxMedium, approxMin).
<span class="nc bnc" id="L1165" title="All 4 branches missed.">        assert(-approxMedium &gt;= Math.abs(approxMin));</span>
<span class="nc" id="L1166">        fastTwoSumApproximation = approxMedium + approxMin;</span>
<span class="nc" id="L1167">        bVirtual = fastTwoSumApproximation - approxMedium;</span>
<span class="nc" id="L1168">        fastTwoSumRoundOff = approxMin - bVirtual;</span>
<span class="nc" id="L1169">        double approxS1 = fastTwoSumApproximation;</span>
<span class="nc" id="L1170">        double roundoffS1 = fastTwoSumRoundOff;</span>

        // Shewchuk/Dekker's FastTwoSum(approxMax, approxS1);
<span class="nc bnc" id="L1173" title="All 4 branches missed.">        assert(approxMax &gt;= Math.abs(approxS1));</span>
<span class="nc" id="L1174">        fastTwoSumApproximation = approxMax + approxS1;</span>
<span class="nc" id="L1175">        bVirtual = fastTwoSumApproximation - approxMax;</span>
<span class="nc" id="L1176">        fastTwoSumRoundOff = approxS1 - bVirtual;</span>
<span class="nc" id="L1177">        double roundoff1000 = fastTwoSumRoundOff;</span>
<span class="nc" id="L1178">        double approx1000 = fastTwoSumApproximation;</span>
<span class="nc" id="L1179">        double roundoffTotal = roundoffS1 + roundoff1000;</span>

        // Shewchuk/Dekker's FastTwoSum(approx1000, roundoffTotal);
<span class="nc bnc" id="L1182" title="All 4 branches missed.">        assert(approx1000 &gt;= Math.abs(roundoffTotal));</span>
<span class="nc" id="L1183">        fastTwoSumApproximation = approx1000 + roundoffTotal;</span>
<span class="nc" id="L1184">        bVirtual = fastTwoSumApproximation - approx1000;</span>

        // Now we have got the roundoff for the scaled fractional
<span class="nc" id="L1187">        double scaledFractionalRoundoff = roundoffTotal - bVirtual;</span>

        // ---- TwoProduct(fractionalPart, scale (i.e. 1000.0d or 100.0d)) end.

        /* ---- Taking the rounding decision
         *
         * We take rounding decision based on roundoff and half-even rounding
         * rule.
         *
         * The above TwoProduct gives us the exact roundoff on the approximated
         * scaled fractional, and we know that this approximation is exactly
         * 0.5d, since that has already been tested by the caller
         * (fastDoubleFormat).
         *
         * Decision comes first from the sign of the calculated exact roundoff.
         * - Since being exact roundoff, it cannot be positive with a scaled
         *   fractional less than 0.5d, as well as negative with a scaled
         *   fractional greater than 0.5d. That leaves us with following 3 cases.
         * - positive, thus scaled fractional == 0.500....0fff ==&gt; round-up.
         * - negative, thus scaled fractional == 0.499....9fff ==&gt; don't round-up.
         * - is zero,  thus scaled fractioanl == 0.5 ==&gt; half-even rounding applies :
         *    we round-up only if the integral part of the scaled fractional is odd.
         *
         */
<span class="nc bnc" id="L1211" title="All 2 branches missed.">        if (scaledFractionalRoundoff &gt; 0.0) {</span>
<span class="nc" id="L1212">            return true;</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        } else if (scaledFractionalRoundoff &lt; 0.0) {</span>
<span class="nc" id="L1214">            return false;</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        } else if ((scaledFractionalPartAsInt &amp; 1) != 0) {</span>
<span class="nc" id="L1216">            return true;</span>
        }

<span class="nc" id="L1219">        return false;</span>

        // ---- Taking the rounding decision end
    }

    /**
     * Collects integral digits from passed {@code number}, while setting
     * grouping chars as needed. Updates {@code firstUsedIndex} accordingly.
     *
     * Loops downward starting from {@code backwardIndex} position (inclusive).
     *
     * @param number  The int value from which we collect digits.
     * @param digitsBuffer The char array container where digits and grouping chars
     *  are stored.
     * @param backwardIndex the position from which we start storing digits in
     *  digitsBuffer.
     *
     */
    private void collectIntegralDigits(int number,
                                       char[] digitsBuffer,
                                       int backwardIndex) {
<span class="nc" id="L1240">        int index = backwardIndex;</span>
        int q;
        int r;
<span class="nc bnc" id="L1243" title="All 2 branches missed.">        while (number &gt; 999) {</span>
            // Generates 3 digits per iteration.
<span class="nc" id="L1245">            q = number / 1000;</span>
<span class="nc" id="L1246">            r = number - (q &lt;&lt; 10) + (q &lt;&lt; 4) + (q &lt;&lt; 3); // -1024 +16 +8 = 1000.</span>
<span class="nc" id="L1247">            number = q;</span>

<span class="nc" id="L1249">            digitsBuffer[index--] = DigitArrays.DigitOnes1000[r];</span>
<span class="nc" id="L1250">            digitsBuffer[index--] = DigitArrays.DigitTens1000[r];</span>
<span class="nc" id="L1251">            digitsBuffer[index--] = DigitArrays.DigitHundreds1000[r];</span>
<span class="nc" id="L1252">            digitsBuffer[index--] = fastPathData.groupingChar;</span>
        }

        // Collects last 3 or less digits.
<span class="nc" id="L1256">        digitsBuffer[index] = DigitArrays.DigitOnes1000[number];</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">        if (number &gt; 9) {</span>
<span class="nc" id="L1258">            digitsBuffer[--index]  = DigitArrays.DigitTens1000[number];</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">            if (number &gt; 99)</span>
<span class="nc" id="L1260">                digitsBuffer[--index]   = DigitArrays.DigitHundreds1000[number];</span>
        }

<span class="nc" id="L1263">        fastPathData.firstUsedIndex = index;</span>
<span class="nc" id="L1264">    }</span>

    /**
     * Collects the 2 (currency) or 3 (decimal) fractional digits from passed
     * {@code number}, starting at {@code startIndex} position
     * inclusive.  There is no punctuation to set here (no grouping chars).
     * Updates {@code fastPathData.lastFreeIndex} accordingly.
     *
     *
     * @param number  The int value from which we collect digits.
     * @param digitsBuffer The char array container where digits are stored.
     * @param startIndex the position from which we start storing digits in
     *  digitsBuffer.
     *
     */
    private void collectFractionalDigits(int number,
                                         char[] digitsBuffer,
                                         int startIndex) {
<span class="nc" id="L1282">        int index = startIndex;</span>

<span class="nc" id="L1284">        char digitOnes = DigitArrays.DigitOnes1000[number];</span>
<span class="nc" id="L1285">        char digitTens = DigitArrays.DigitTens1000[number];</span>

<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (isCurrencyFormat) {</span>
            // Currency case. Always collects fractional digits.
<span class="nc" id="L1289">            digitsBuffer[index++] = digitTens;</span>
<span class="nc" id="L1290">            digitsBuffer[index++] = digitOnes;</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        } else if (number != 0) {</span>
            // Decimal case. Hundreds will always be collected
<span class="nc" id="L1293">            digitsBuffer[index++] = DigitArrays.DigitHundreds1000[number];</span>

            // Ending zeros won't be collected.
<span class="nc bnc" id="L1296" title="All 2 branches missed.">            if (digitOnes != '0') {</span>
<span class="nc" id="L1297">                digitsBuffer[index++] = digitTens;</span>
<span class="nc" id="L1298">                digitsBuffer[index++] = digitOnes;</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            } else if (digitTens != '0')</span>
<span class="nc" id="L1300">                digitsBuffer[index++] = digitTens;</span>

        } else
            // This is decimal pattern and fractional part is zero.
            // We must remove decimal point from result.
<span class="nc" id="L1305">            index--;</span>

<span class="nc" id="L1307">        fastPathData.lastFreeIndex = index;</span>
<span class="nc" id="L1308">    }</span>

    /**
     * Internal utility.
     * Adds the passed {@code prefix} and {@code suffix} to {@code container}.
     *
     * @param container  Char array container which to prepend/append the
     *  prefix/suffix.
     * @param prefix     Char sequence to prepend as a prefix.
     * @param suffix     Char sequence to append as a suffix.
     *
     */
    //    private void addAffixes(boolean isNegative, char[] container) {
    private void addAffixes(char[] container, char[] prefix, char[] suffix) {

        // We add affixes only if needed (affix length &gt; 0).
<span class="nc" id="L1324">        int pl = prefix.length;</span>
<span class="nc" id="L1325">        int sl = suffix.length;</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (pl != 0) prependPrefix(prefix, pl, container);</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">        if (sl != 0) appendSuffix(suffix, sl, container);</span>

<span class="nc" id="L1329">    }</span>

    /**
     * Prepends the passed {@code prefix} chars to given result
     * {@code container}.  Updates {@code fastPathData.firstUsedIndex}
     * accordingly.
     *
     * @param prefix The prefix characters to prepend to result.
     * @param len The number of chars to prepend.
     * @param container Char array container which to prepend the prefix
     */
    private void prependPrefix(char[] prefix,
                               int len,
                               char[] container) {

<span class="nc" id="L1344">        fastPathData.firstUsedIndex -= len;</span>
<span class="nc" id="L1345">        int startIndex = fastPathData.firstUsedIndex;</span>

        // If prefix to prepend is only 1 char long, just assigns this char.
        // If prefix is less or equal 4, we use a dedicated algorithm that
        //  has shown to run faster than System.arraycopy.
        // If more than 4, we use System.arraycopy.
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        if (len == 1)</span>
<span class="nc" id="L1352">            container[startIndex] = prefix[0];</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">        else if (len &lt;= 4) {</span>
<span class="nc" id="L1354">            int dstLower = startIndex;</span>
<span class="nc" id="L1355">            int dstUpper = dstLower + len - 1;</span>
<span class="nc" id="L1356">            int srcUpper = len - 1;</span>
<span class="nc" id="L1357">            container[dstLower] = prefix[0];</span>
<span class="nc" id="L1358">            container[dstUpper] = prefix[srcUpper];</span>

<span class="nc bnc" id="L1360" title="All 2 branches missed.">            if (len &gt; 2)</span>
<span class="nc" id="L1361">                container[++dstLower] = prefix[1];</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (len == 4)</span>
<span class="nc" id="L1363">                container[--dstUpper] = prefix[2];</span>
<span class="nc" id="L1364">        } else</span>
<span class="nc" id="L1365">            System.arraycopy(prefix, 0, container, startIndex, len);</span>
<span class="nc" id="L1366">    }</span>

    /**
     * Appends the passed {@code suffix} chars to given result
     * {@code container}.  Updates {@code fastPathData.lastFreeIndex}
     * accordingly.
     *
     * @param suffix The suffix characters to append to result.
     * @param len The number of chars to append.
     * @param container Char array container which to append the suffix
     */
    private void appendSuffix(char[] suffix,
                              int len,
                              char[] container) {

<span class="nc" id="L1381">        int startIndex = fastPathData.lastFreeIndex;</span>

        // If suffix to append is only 1 char long, just assigns this char.
        // If suffix is less or equal 4, we use a dedicated algorithm that
        //  has shown to run faster than System.arraycopy.
        // If more than 4, we use System.arraycopy.
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (len == 1)</span>
<span class="nc" id="L1388">            container[startIndex] = suffix[0];</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">        else if (len &lt;= 4) {</span>
<span class="nc" id="L1390">            int dstLower = startIndex;</span>
<span class="nc" id="L1391">            int dstUpper = dstLower + len - 1;</span>
<span class="nc" id="L1392">            int srcUpper = len - 1;</span>
<span class="nc" id="L1393">            container[dstLower] = suffix[0];</span>
<span class="nc" id="L1394">            container[dstUpper] = suffix[srcUpper];</span>

<span class="nc bnc" id="L1396" title="All 2 branches missed.">            if (len &gt; 2)</span>
<span class="nc" id="L1397">                container[++dstLower] = suffix[1];</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">            if (len == 4)</span>
<span class="nc" id="L1399">                container[--dstUpper] = suffix[2];</span>
<span class="nc" id="L1400">        } else</span>
<span class="nc" id="L1401">            System.arraycopy(suffix, 0, container, startIndex, len);</span>

<span class="nc" id="L1403">        fastPathData.lastFreeIndex += len;</span>
<span class="nc" id="L1404">    }</span>

    /**
     * Converts digit chars from {@code digitsBuffer} to current locale.
     *
     * Must be called before adding affixes since we refer to
     * {@code fastPathData.firstUsedIndex} and {@code fastPathData.lastFreeIndex},
     * and do not support affixes (for speed reason).
     *
     * We loop backward starting from last used index in {@code fastPathData}.
     *
     * @param digitsBuffer The char array container where the digits are stored.
     */
    private void localizeDigits(char[] digitsBuffer) {

        // We will localize only the digits, using the groupingSize,
        // and taking into account fractional part.

        // First take into account fractional part.
<span class="nc" id="L1423">        int digitsCounter =</span>
            fastPathData.lastFreeIndex - fastPathData.fractionalFirstIndex;

        // The case when there is no fractional digits.
<span class="nc bnc" id="L1427" title="All 2 branches missed.">        if (digitsCounter &lt; 0)</span>
<span class="nc" id="L1428">            digitsCounter = groupingSize;</span>

        // Only the digits remains to localize.
<span class="nc" id="L1431">        for (int cursor = fastPathData.lastFreeIndex - 1;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">             cursor &gt;= fastPathData.firstUsedIndex;</span>
<span class="nc" id="L1433">             cursor--) {</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">            if (digitsCounter != 0) {</span>
                // This is a digit char, we must localize it.
<span class="nc" id="L1436">                digitsBuffer[cursor] += fastPathData.zeroDelta;</span>
<span class="nc" id="L1437">                digitsCounter--;</span>
            } else {
                // Decimal separator or grouping char. Reinit counter only.
<span class="nc" id="L1440">                digitsCounter = groupingSize;</span>
            }
        }
<span class="nc" id="L1443">    }</span>

    /**
     * This is the main entry point for the fast-path format algorithm.
     *
     * At this point we are sure to be in the expected conditions to run it.
     * This algorithm builds the formatted result and puts it in the dedicated
     * {@code fastPathData.fastPathContainer}.
     *
     * @param d the double value to be formatted.
     * @param negative Flag precising if {@code d} is negative.
     */
    private void fastDoubleFormat(double d,
                                  boolean negative) {

<span class="nc" id="L1458">        char[] container = fastPathData.fastPathContainer;</span>

        /*
         * The principle of the algorithm is to :
         * - Break the passed double into its integral and fractional parts
         *    converted into integers.
         * - Then decide if rounding up must be applied or not by following
         *    the half-even rounding rule, first using approximated scaled
         *    fractional part.
         * - For the difficult cases (approximated scaled fractional part
         *    being exactly 0.5d), we refine the rounding decision by calling
         *    exactRoundUp utility method that both calculates the exact roundoff
         *    on the approximation and takes correct rounding decision.
         * - We round-up the fractional part if needed, possibly propagating the
         *    rounding to integral part if we meet a &quot;all-nine&quot; case for the
         *    scaled fractional part.
         * - We then collect digits from the resulting integral and fractional
         *   parts, also setting the required grouping chars on the fly.
         * - Then we localize the collected digits if needed, and
         * - Finally prepend/append prefix/suffix if any is needed.
         */

        // Exact integral part of d.
<span class="nc" id="L1481">        int integralPartAsInt = (int) d;</span>

        // Exact fractional part of d (since we subtract it's integral part).
<span class="nc" id="L1484">        double exactFractionalPart = d - (double) integralPartAsInt;</span>

        // Approximated scaled fractional part of d (due to multiplication).
<span class="nc" id="L1487">        double scaledFractional =</span>
            exactFractionalPart * fastPathData.fractionalScaleFactor;

        // Exact integral part of scaled fractional above.
<span class="nc" id="L1491">        int fractionalPartAsInt = (int) scaledFractional;</span>

        // Exact fractional part of scaled fractional above.
<span class="nc" id="L1494">        scaledFractional = scaledFractional - (double) fractionalPartAsInt;</span>

        // Only when scaledFractional is exactly 0.5d do we have to do exact
        // calculations and take fine-grained rounding decision, since
        // approximated results above may lead to incorrect decision.
        // Otherwise comparing against 0.5d (strictly greater or less) is ok.
<span class="nc" id="L1500">        boolean roundItUp = false;</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">        if (scaledFractional &gt;= 0.5d) {</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">            if (scaledFractional == 0.5d)</span>
                // Rounding need fine-grained decision.
<span class="nc" id="L1504">                roundItUp = exactRoundUp(exactFractionalPart, fractionalPartAsInt);</span>
            else
<span class="nc" id="L1506">                roundItUp = true;</span>

<span class="nc bnc" id="L1508" title="All 2 branches missed.">            if (roundItUp) {</span>
                // Rounds up both fractional part (and also integral if needed).
<span class="nc bnc" id="L1510" title="All 2 branches missed.">                if (fractionalPartAsInt &lt; fastPathData.fractionalMaxIntBound) {</span>
<span class="nc" id="L1511">                    fractionalPartAsInt++;</span>
                } else {
                    // Propagates rounding to integral part since &quot;all nines&quot; case.
<span class="nc" id="L1514">                    fractionalPartAsInt = 0;</span>
<span class="nc" id="L1515">                    integralPartAsInt++;</span>
                }
            }
        }

        // Collecting digits.
<span class="nc" id="L1521">        collectFractionalDigits(fractionalPartAsInt, container,</span>
                                fastPathData.fractionalFirstIndex);
<span class="nc" id="L1523">        collectIntegralDigits(integralPartAsInt, container,</span>
                              fastPathData.integralLastIndex);

        // Localizing digits.
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if (fastPathData.zeroDelta != 0)</span>
<span class="nc" id="L1528">            localizeDigits(container);</span>

        // Adding prefix and suffix.
<span class="nc bnc" id="L1531" title="All 2 branches missed.">        if (negative) {</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (fastPathData.negativeAffixesRequired)</span>
<span class="nc" id="L1533">                addAffixes(container,</span>
                           fastPathData.charsNegativePrefix,
                           fastPathData.charsNegativeSuffix);
<span class="nc bnc" id="L1536" title="All 2 branches missed.">        } else if (fastPathData.positiveAffixesRequired)</span>
<span class="nc" id="L1537">            addAffixes(container,</span>
                       fastPathData.charsPositivePrefix,
                       fastPathData.charsPositiveSuffix);
<span class="nc" id="L1540">    }</span>

    /**
     * A fast-path shortcut of format(double) to be called by NumberFormat, or by
     * format(double, ...) public methods.
     *
     * If instance can be applied fast-path and passed double is not NaN or
     * Infinity, is in the integer range, we call {@code fastDoubleFormat}
     * after changing {@code d} to its positive value if necessary.
     *
     * Otherwise returns null by convention since fast-path can't be exercized.
     *
     * @param d The double value to be formatted
     *
     * @return the formatted result for {@code d} as a string.
     */
    String fastFormat(double d) {
        // (Re-)Evaluates fast-path status if needed.
<span class="nc bnc" id="L1558" title="All 2 branches missed.">        if (fastPathCheckNeeded)</span>
<span class="nc" id="L1559">            checkAndSetFastPathStatus();</span>

<span class="nc bnc" id="L1561" title="All 2 branches missed.">        if (!isFastPath )</span>
            // DecimalFormat instance is not in a fast-path state.
<span class="nc" id="L1563">            return null;</span>

<span class="nc bnc" id="L1565" title="All 2 branches missed.">        if (!Double.isFinite(d))</span>
            // Should not use fast-path for Infinity and NaN.
<span class="nc" id="L1567">            return null;</span>

        // Extracts and records sign of double value, possibly changing it
        // to a positive one, before calling fastDoubleFormat().
<span class="nc" id="L1571">        boolean negative = false;</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">        if (d &lt; 0.0d) {</span>
<span class="nc" id="L1573">            negative = true;</span>
<span class="nc" id="L1574">            d = -d;</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        } else if (d == 0.0d) {</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">            negative = (Math.copySign(1.0d, d) == -1.0d);</span>
<span class="nc" id="L1577">            d = +0.0d;</span>
        }

<span class="nc bnc" id="L1580" title="All 2 branches missed.">        if (d &gt; MAX_INT_AS_DOUBLE)</span>
            // Filters out values that are outside expected fast-path range
<span class="nc" id="L1582">            return null;</span>
        else
<span class="nc" id="L1584">            fastDoubleFormat(d, negative);</span>

        // Returns a new string from updated fastPathContainer.
<span class="nc" id="L1587">        return new String(fastPathData.fastPathContainer,</span>
                          fastPathData.firstUsedIndex,
                          fastPathData.lastFreeIndex - fastPathData.firstUsedIndex);

    }

    // ======== End fast-path formating logic for double =========================

    /**
     * Complete the formatting of a finite number.  On entry, the digitList must
     * be filled in with the correct digits.
     */
    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,
                                   boolean isNegative, boolean isInteger,
                                   int maxIntDigits, int minIntDigits,
                                   int maxFraDigits, int minFraDigits) {
        // NOTE: This isn't required anymore because DigitList takes care of this.
        //
        //  // The negative of the exponent represents the number of leading
        //  // zeros between the decimal and the first non-zero digit, for
        //  // a value &lt; 0.1 (e.g., for 0.00123, -fExponent == 2).  If this
        //  // is more than the maximum fraction digits, then we have an underflow
        //  // for the printed representation.  We recognize this here and set
        //  // the DigitList representation to zero in this situation.
        //
        //  if (-digitList.decimalAt &gt;= getMaximumFractionDigits())
        //  {
        //      digitList.count = 0;
        //  }

<span class="fc" id="L1617">        char zero = symbols.getZeroDigit();</span>
<span class="fc" id="L1618">        int zeroDelta = zero - '0'; // '0' is the DigitList representation of zero</span>
<span class="fc" id="L1619">        char grouping = symbols.getGroupingSeparator();</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">        char decimal = isCurrencyFormat ?</span>
<span class="fc" id="L1621">            symbols.getMonetaryDecimalSeparator() :</span>
<span class="fc" id="L1622">            symbols.getDecimalSeparator();</span>

        /* Per bug 4147706, DecimalFormat must respect the sign of numbers which
         * format as zero.  This allows sensible computations and preserves
         * relations such as signum(1/x) = signum(x), where x is +Infinity or
         * -Infinity.  Prior to this fix, we always formatted zero values as if
         * they were positive.  Liu 7/6/98.
         */
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">        if (digitList.isZero()) {</span>
<span class="nc" id="L1631">            digitList.decimalAt = 0; // Normalize</span>
        }

<span class="fc bfc" id="L1634" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L1635">            append(result, negativePrefix, delegate,</span>
<span class="fc" id="L1636">                   getNegativePrefixFieldPositions(), Field.SIGN);</span>
        } else {
<span class="fc" id="L1638">            append(result, positivePrefix, delegate,</span>
<span class="fc" id="L1639">                   getPositivePrefixFieldPositions(), Field.SIGN);</span>
        }

<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">        if (useExponentialNotation) {</span>
<span class="nc" id="L1643">            int iFieldStart = result.length();</span>
<span class="nc" id="L1644">            int iFieldEnd = -1;</span>
<span class="nc" id="L1645">            int fFieldStart = -1;</span>

            // Minimum integer digits are handled in exponential format by
            // adjusting the exponent.  For example, 0.01234 with 3 minimum
            // integer digits is &quot;123.4E-4&quot;.

            // Maximum integer digits are interpreted as indicating the
            // repeating range.  This is useful for engineering notation, in
            // which the exponent is restricted to a multiple of 3.  For
            // example, 0.01234 with 3 maximum integer digits is &quot;12.34e-3&quot;.
            // If maximum integer digits are &gt; 1 and are larger than
            // minimum integer digits, then minimum integer digits are
            // ignored.
<span class="nc" id="L1658">            int exponent = digitList.decimalAt;</span>
<span class="nc" id="L1659">            int repeat = maxIntDigits;</span>
<span class="nc" id="L1660">            int minimumIntegerDigits = minIntDigits;</span>
<span class="nc bnc" id="L1661" title="All 4 branches missed.">            if (repeat &gt; 1 &amp;&amp; repeat &gt; minIntDigits) {</span>
                // A repeating range is defined; adjust to it as follows.
                // If repeat == 3, we have 6,5,4=&gt;3; 3,2,1=&gt;0; 0,-1,-2=&gt;-3;
                // -3,-4,-5=&gt;-6, etc. This takes into account that the
                // exponent we have here is off by one from what we expect;
                // it is for the format 0.MMMMMx10^n.
<span class="nc bnc" id="L1667" title="All 2 branches missed.">                if (exponent &gt;= 1) {</span>
<span class="nc" id="L1668">                    exponent = ((exponent - 1) / repeat) * repeat;</span>
                } else {
                    // integer division rounds towards 0
<span class="nc" id="L1671">                    exponent = ((exponent - repeat) / repeat) * repeat;</span>
                }
<span class="nc" id="L1673">                minimumIntegerDigits = 1;</span>
            } else {
                // No repeating range is defined; use minimum integer digits.
<span class="nc" id="L1676">                exponent -= minimumIntegerDigits;</span>
            }

            // We now output a minimum number of digits, and more if there
            // are more digits, up to the maximum number of digits.  We
            // place the decimal point after the &quot;integer&quot; digits, which
            // are the first (decimalAt - exponent) digits.
<span class="nc" id="L1683">            int minimumDigits = minIntDigits + minFraDigits;</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            if (minimumDigits &lt; 0) {    // overflow?</span>
<span class="nc" id="L1685">                minimumDigits = Integer.MAX_VALUE;</span>
            }

            // The number of integer digits is handled specially if the number
            // is zero, since then there may be no digits.
<span class="nc bnc" id="L1690" title="All 2 branches missed.">            int integerDigits = digitList.isZero() ? minimumIntegerDigits :</span>
                    digitList.decimalAt - exponent;
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            if (minimumDigits &lt; integerDigits) {</span>
<span class="nc" id="L1693">                minimumDigits = integerDigits;</span>
            }
<span class="nc" id="L1695">            int totalDigits = digitList.count;</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">            if (minimumDigits &gt; totalDigits) {</span>
<span class="nc" id="L1697">                totalDigits = minimumDigits;</span>
            }
<span class="nc" id="L1699">            boolean addedDecimalSeparator = false;</span>

<span class="nc bnc" id="L1701" title="All 2 branches missed.">            for (int i=0; i&lt;totalDigits; ++i) {</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">                if (i == integerDigits) {</span>
                    // Record field information for caller.
<span class="nc" id="L1704">                    iFieldEnd = result.length();</span>

<span class="nc" id="L1706">                    result.append(decimal);</span>
<span class="nc" id="L1707">                    addedDecimalSeparator = true;</span>

                    // Record field information for caller.
<span class="nc" id="L1710">                    fFieldStart = result.length();</span>
                }
<span class="nc bnc" id="L1712" title="All 2 branches missed.">                result.append((i &lt; digitList.count) ?</span>
                              (char)(digitList.digits[i] + zeroDelta) :
                              zero);
            }

<span class="nc bnc" id="L1717" title="All 4 branches missed.">            if (decimalSeparatorAlwaysShown &amp;&amp; totalDigits == integerDigits) {</span>
                // Record field information for caller.
<span class="nc" id="L1719">                iFieldEnd = result.length();</span>

<span class="nc" id="L1721">                result.append(decimal);</span>
<span class="nc" id="L1722">                addedDecimalSeparator = true;</span>

                // Record field information for caller.
<span class="nc" id="L1725">                fFieldStart = result.length();</span>
            }

            // Record field information
<span class="nc bnc" id="L1729" title="All 2 branches missed.">            if (iFieldEnd == -1) {</span>
<span class="nc" id="L1730">                iFieldEnd = result.length();</span>
            }
<span class="nc" id="L1732">            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,</span>
                               iFieldStart, iFieldEnd, result);
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            if (addedDecimalSeparator) {</span>
<span class="nc" id="L1735">                delegate.formatted(Field.DECIMAL_SEPARATOR,</span>
                                   Field.DECIMAL_SEPARATOR,
                                   iFieldEnd, fFieldStart, result);
            }
<span class="nc bnc" id="L1739" title="All 2 branches missed.">            if (fFieldStart == -1) {</span>
<span class="nc" id="L1740">                fFieldStart = result.length();</span>
            }
<span class="nc" id="L1742">            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,</span>
<span class="nc" id="L1743">                               fFieldStart, result.length(), result);</span>

            // The exponent is output using the pattern-specified minimum
            // exponent digits.  There is no maximum limit to the exponent
            // digits, since truncating the exponent would result in an
            // unacceptable inaccuracy.
<span class="nc" id="L1749">            int fieldStart = result.length();</span>

<span class="nc" id="L1751">            result.append(symbols.getExponentSeparator());</span>

<span class="nc" id="L1753">            delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL,</span>
<span class="nc" id="L1754">                               fieldStart, result.length(), result);</span>

            // For zero values, we force the exponent to zero.  We
            // must do this here, and not earlier, because the value
            // is used to determine integer digit count above.
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (digitList.isZero()) {</span>
<span class="nc" id="L1760">                exponent = 0;</span>
            }

<span class="nc bnc" id="L1763" title="All 2 branches missed.">            boolean negativeExponent = exponent &lt; 0;</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">            if (negativeExponent) {</span>
<span class="nc" id="L1765">                exponent = -exponent;</span>
<span class="nc" id="L1766">                fieldStart = result.length();</span>
<span class="nc" id="L1767">                result.append(symbols.getMinusSign());</span>
<span class="nc" id="L1768">                delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN,</span>
<span class="nc" id="L1769">                                   fieldStart, result.length(), result);</span>
            }
<span class="nc" id="L1771">            digitList.set(negativeExponent, exponent);</span>

<span class="nc" id="L1773">            int eFieldStart = result.length();</span>

<span class="nc bnc" id="L1775" title="All 2 branches missed.">            for (int i=digitList.decimalAt; i&lt;minExponentDigits; ++i) {</span>
<span class="nc" id="L1776">                result.append(zero);</span>
            }
<span class="nc bnc" id="L1778" title="All 2 branches missed.">            for (int i=0; i&lt;digitList.decimalAt; ++i) {</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">                result.append((i &lt; digitList.count) ?</span>
                          (char)(digitList.digits[i] + zeroDelta) : zero);
            }
<span class="nc" id="L1782">            delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart,</span>
<span class="nc" id="L1783">                               result.length(), result);</span>
<span class="nc" id="L1784">        } else {</span>
<span class="fc" id="L1785">            int iFieldStart = result.length();</span>

            // Output the integer portion.  Here 'count' is the total
            // number of integer digits we will display, including both
            // leading zeros required to satisfy getMinimumIntegerDigits,
            // and actual digits present in the number.
<span class="fc" id="L1791">            int count = minIntDigits;</span>
<span class="fc" id="L1792">            int digitIndex = 0; // Index into digitList.fDigits[]</span>
<span class="pc bpc" id="L1793" title="1 of 4 branches missed.">            if (digitList.decimalAt &gt; 0 &amp;&amp; count &lt; digitList.decimalAt) {</span>
<span class="fc" id="L1794">                count = digitList.decimalAt;</span>
            }

            // Handle the case where getMaximumIntegerDigits() is smaller
            // than the real number of integer digits.  If this is so, we
            // output the least significant max integer digits.  For example,
            // the value 1997 printed with 2 max integer digits is just &quot;97&quot;.
<span class="fc bfc" id="L1801" title="All 2 branches covered.">            if (count &gt; maxIntDigits) {</span>
<span class="fc" id="L1802">                count = maxIntDigits;</span>
<span class="fc" id="L1803">                digitIndex = digitList.decimalAt - count;</span>
            }

<span class="fc" id="L1806">            int sizeBeforeIntegerPart = result.length();</span>
<span class="fc bfc" id="L1807" title="All 2 branches covered.">            for (int i=count-1; i&gt;=0; --i) {</span>
<span class="fc bfc" id="L1808" title="All 4 branches covered.">                if (i &lt; digitList.decimalAt &amp;&amp; digitIndex &lt; digitList.count) {</span>
                    // Output a real digit
<span class="fc" id="L1810">                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));</span>
                } else {
                    // Output a leading zero
<span class="fc" id="L1813">                    result.append(zero);</span>
                }

                // Output grouping separator if necessary.  Don't output a
                // grouping separator if i==0 though; that's at the end of
                // the integer part.
<span class="pc bpc" id="L1819" title="1 of 8 branches missed.">                if (isGroupingUsed() &amp;&amp; i&gt;0 &amp;&amp; (groupingSize != 0) &amp;&amp;</span>
                    (i % groupingSize == 0)) {
<span class="fc" id="L1821">                    int gStart = result.length();</span>
<span class="fc" id="L1822">                    result.append(grouping);</span>
<span class="fc" id="L1823">                    delegate.formatted(Field.GROUPING_SEPARATOR,</span>
                                       Field.GROUPING_SEPARATOR, gStart,
<span class="fc" id="L1825">                                       result.length(), result);</span>
                }
            }

            // Determine whether or not there are any printable fractional
            // digits.  If we've used up the digits we know there aren't.
<span class="pc bpc" id="L1831" title="4 of 6 branches missed.">            boolean fractionPresent = (minFraDigits &gt; 0) ||</span>
                (!isInteger &amp;&amp; digitIndex &lt; digitList.count);

            // If there is no fraction present, and we haven't printed any
            // integer digits, then print a zero.  Otherwise we won't print
            // _any_ digits, and we won't be able to parse this string.
<span class="pc bpc" id="L1837" title="2 of 4 branches missed.">            if (!fractionPresent &amp;&amp; result.length() == sizeBeforeIntegerPart) {</span>
<span class="nc" id="L1838">                result.append(zero);</span>
            }

<span class="fc" id="L1841">            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,</span>
<span class="fc" id="L1842">                               iFieldStart, result.length(), result);</span>

            // Output the decimal separator if we always do so.
<span class="fc" id="L1845">            int sStart = result.length();</span>
<span class="pc bpc" id="L1846" title="2 of 4 branches missed.">            if (decimalSeparatorAlwaysShown || fractionPresent) {</span>
<span class="nc" id="L1847">                result.append(decimal);</span>
            }

<span class="pc bpc" id="L1850" title="1 of 2 branches missed.">            if (sStart != result.length()) {</span>
<span class="nc" id="L1851">                delegate.formatted(Field.DECIMAL_SEPARATOR,</span>
                                   Field.DECIMAL_SEPARATOR,
<span class="nc" id="L1853">                                   sStart, result.length(), result);</span>
            }
<span class="fc" id="L1855">            int fFieldStart = result.length();</span>

<span class="pc bfc" id="L1857" title="All 2 branches covered.">            for (int i=0; i &lt; maxFraDigits; ++i) {</span>
                // Here is where we escape from the loop.  We escape if we've
                // output the maximum fraction digits (specified in the for
                // expression above).
                // We also stop when we've output the minimum digits and either:
                // we have an integer, so there is no fractional stuff to
                // display, or we're out of significant digits.
<span class="pc bpc" id="L1864" title="4 of 6 branches missed.">                if (i &gt;= minFraDigits &amp;&amp;</span>
                    (isInteger || digitIndex &gt;= digitList.count)) {
<span class="nc" id="L1866">                    break;</span>
                }

                // Output leading fractional zeros. These are zeros that come
                // after the decimal but before any significant digits. These
                // are only output if abs(number being formatted) &lt; 1.0.
<span class="nc bnc" id="L1872" title="All 2 branches missed.">                if (-1-i &gt; (digitList.decimalAt-1)) {</span>
<span class="nc" id="L1873">                    result.append(zero);</span>
<span class="nc" id="L1874">                    continue;</span>
                }

                // Output a digit, if we have any precision left, or a
                // zero if we don't.  We don't want to output noise digits.
<span class="nc bnc" id="L1879" title="All 4 branches missed.">                if (!isInteger &amp;&amp; digitIndex &lt; digitList.count) {</span>
<span class="nc" id="L1880">                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));</span>
                } else {
<span class="nc" id="L1882">                    result.append(zero);</span>
                }
            }

            // Record field information for caller.
<span class="fc" id="L1887">            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,</span>
<span class="fc" id="L1888">                               fFieldStart, result.length(), result);</span>
        }

<span class="fc bfc" id="L1891" title="All 2 branches covered.">        if (isNegative) {</span>
<span class="fc" id="L1892">            append(result, negativeSuffix, delegate,</span>
<span class="fc" id="L1893">                   getNegativeSuffixFieldPositions(), Field.SIGN);</span>
        } else {
<span class="fc" id="L1895">            append(result, positiveSuffix, delegate,</span>
<span class="fc" id="L1896">                   getPositiveSuffixFieldPositions(), Field.SIGN);</span>
        }

<span class="fc" id="L1899">        return result;</span>
    }

    /**
     * Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.
     * &lt;code&gt;delegate&lt;/code&gt; is notified of all  the
     * &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.
     * &lt;p&gt;
     * If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;
     * identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to
     * &lt;code&gt;signAttribute&lt;/code&gt;. This is used
     * to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;
     * attribute as necessary.
     * &lt;p&gt;
     * This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.
     */
    private void append(StringBuffer result, String string,
                        FieldDelegate delegate,
                        FieldPosition[] positions,
                        Format.Field signAttribute) {
<span class="fc" id="L1919">        int start = result.length();</span>

<span class="fc bfc" id="L1921" title="All 2 branches covered.">        if (string.length() &gt; 0) {</span>
<span class="fc" id="L1922">            result.append(string);</span>
<span class="fc bfc" id="L1923" title="All 2 branches covered.">            for (int counter = 0, max = positions.length; counter &lt; max;</span>
<span class="fc" id="L1924">                 counter++) {</span>
<span class="fc" id="L1925">                FieldPosition fp = positions[counter];</span>
<span class="fc" id="L1926">                Format.Field attribute = fp.getFieldAttribute();</span>

<span class="fc bfc" id="L1928" title="All 2 branches covered.">                if (attribute == Field.SIGN) {</span>
<span class="fc" id="L1929">                    attribute = signAttribute;</span>
                }
<span class="fc" id="L1931">                delegate.formatted(attribute, attribute,</span>
<span class="fc" id="L1932">                                   start + fp.getBeginIndex(),</span>
<span class="fc" id="L1933">                                   start + fp.getEndIndex(), result);</span>
            }
        }
<span class="fc" id="L1936">    }</span>

    /**
     * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
     * &lt;p&gt;
     * The method attempts to parse text starting at the index given by
     * &lt;code&gt;pos&lt;/code&gt;.
     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
     * to the index after the last character used (parsing does not necessarily
     * use all characters up to the end of the string), and the parsed
     * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
     * indicate the starting point for the next call to this method.
     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
     * the character where the error occurred, and null is returned.
     * &lt;p&gt;
     * The subclass returned depends on the value of {@link #isParseBigDecimal}
     * as well as on the string being parsed.
     * &lt;ul&gt;
     *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),
     *       most integer values are returned as &lt;code&gt;Long&lt;/code&gt;
     *       objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and
     *       &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.
     *       Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as
     *       &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,
     *       infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.
     *       &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to
     *       return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the
     *       presence of a decimal separator in the source string. Doing so
     *       would prevent integers that overflow the mantissa of a double,
     *       such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being
     *       parsed accurately.
     *       &lt;p&gt;
     *       Callers may use the &lt;code&gt;Number&lt;/code&gt; methods
     *       &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain
     *       the type they want.
     *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned
     *       as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones
     *       constructed by {@link java.math.BigDecimal#BigDecimal(String)}
     *       for corresponding strings in locale-independent format. The
     *       special cases negative and positive infinity and NaN are returned
     *       as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the
     *       corresponding &lt;code&gt;Double&lt;/code&gt; constants.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent
     * decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In
     * addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten
     * consecutive characters starting with the localized zero digit defined in
     * the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
     *
     * @param text the string to be parsed
     * @param pos  A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
     *             index information as described above.
     * @return     the parsed value, or &lt;code&gt;null&lt;/code&gt; if the parse fails
     * @exception  NullPointerException if &lt;code&gt;text&lt;/code&gt; or
     *             &lt;code&gt;pos&lt;/code&gt; is null.
     */
    @Override
    public Number parse(String text, ParsePosition pos) {
        // special case NaN
<span class="pc bpc" id="L1997" title="1 of 2 branches missed.">        if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {</span>
<span class="nc" id="L1998">            pos.index = pos.index + symbols.getNaN().length();</span>
<span class="nc" id="L1999">            return new Double(Double.NaN);</span>
        }

<span class="fc" id="L2002">        boolean[] status = new boolean[STATUS_LENGTH];</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">        if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {</span>
<span class="fc" id="L2004">            return null;</span>
        }

        // special case INFINITY
<span class="pc bpc" id="L2008" title="1 of 2 branches missed.">        if (status[STATUS_INFINITE]) {</span>
<span class="nc bnc" id="L2009" title="All 4 branches missed.">            if (status[STATUS_POSITIVE] == (multiplier &gt;= 0)) {</span>
<span class="nc" id="L2010">                return new Double(Double.POSITIVE_INFINITY);</span>
            } else {
<span class="nc" id="L2012">                return new Double(Double.NEGATIVE_INFINITY);</span>
            }
        }

<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">        if (multiplier == 0) {</span>
<span class="nc bnc" id="L2017" title="All 2 branches missed.">            if (digitList.isZero()) {</span>
<span class="nc" id="L2018">                return new Double(Double.NaN);</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">            } else if (status[STATUS_POSITIVE]) {</span>
<span class="nc" id="L2020">                return new Double(Double.POSITIVE_INFINITY);</span>
            } else {
<span class="nc" id="L2022">                return new Double(Double.NEGATIVE_INFINITY);</span>
            }
        }

<span class="pc bpc" id="L2026" title="1 of 2 branches missed.">        if (isParseBigDecimal()) {</span>
<span class="nc" id="L2027">            BigDecimal bigDecimalResult = digitList.getBigDecimal();</span>

<span class="nc bnc" id="L2029" title="All 2 branches missed.">            if (multiplier != 1) {</span>
                try {
<span class="nc" id="L2031">                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier());</span>
                }
<span class="nc" id="L2033">                catch (ArithmeticException e) {  // non-terminating decimal expansion</span>
<span class="nc" id="L2034">                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier(), roundingMode);</span>
<span class="nc" id="L2035">                }</span>
            }

<span class="nc bnc" id="L2038" title="All 2 branches missed.">            if (!status[STATUS_POSITIVE]) {</span>
<span class="nc" id="L2039">                bigDecimalResult = bigDecimalResult.negate();</span>
            }
<span class="nc" id="L2041">            return bigDecimalResult;</span>
        } else {
<span class="fc" id="L2043">            boolean gotDouble = true;</span>
<span class="fc" id="L2044">            boolean gotLongMinimum = false;</span>
<span class="fc" id="L2045">            double  doubleResult = 0.0;</span>
<span class="fc" id="L2046">            long    longResult = 0;</span>

            // Finally, have DigitList parse the digits into a value.
<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">            if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {</span>
<span class="fc" id="L2050">                gotDouble = false;</span>
<span class="fc" id="L2051">                longResult = digitList.getLong();</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">                if (longResult &lt; 0) {  // got Long.MIN_VALUE</span>
<span class="nc" id="L2053">                    gotLongMinimum = true;</span>
                }
            } else {
<span class="nc" id="L2056">                doubleResult = digitList.getDouble();</span>
            }

            // Divide by multiplier. We have to be careful here not to do
            // unneeded conversions between double and long.
<span class="pc bpc" id="L2061" title="1 of 2 branches missed.">            if (multiplier != 1) {</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                if (gotDouble) {</span>
<span class="nc" id="L2063">                    doubleResult /= multiplier;</span>
                } else {
                    // Avoid converting to double if we can
<span class="nc bnc" id="L2066" title="All 2 branches missed.">                    if (longResult % multiplier == 0) {</span>
<span class="nc" id="L2067">                        longResult /= multiplier;</span>
                    } else {
<span class="nc" id="L2069">                        doubleResult = ((double)longResult) / multiplier;</span>
<span class="nc" id="L2070">                        gotDouble = true;</span>
                    }
                }
            }

<span class="pc bpc" id="L2075" title="1 of 4 branches missed.">            if (!status[STATUS_POSITIVE] &amp;&amp; !gotLongMinimum) {</span>
<span class="fc" id="L2076">                doubleResult = -doubleResult;</span>
<span class="fc" id="L2077">                longResult = -longResult;</span>
            }

            // At this point, if we divided the result by the multiplier, the
            // result may fit into a long.  We check for this case and return
            // a long if possible.
            // We must do this AFTER applying the negative (if appropriate)
            // in order to handle the case of LONG_MIN; otherwise, if we do
            // this with a positive value -LONG_MIN, the double is &gt; 0, but
            // the long is &lt; 0. We also must retain a double in the case of
            // -0.0, which will compare as == to a long 0 cast to a double
            // (bug 4162852).
<span class="pc bpc" id="L2089" title="3 of 4 branches missed.">            if (multiplier != 1 &amp;&amp; gotDouble) {</span>
<span class="nc" id="L2090">                longResult = (long)doubleResult;</span>
<span class="nc bnc" id="L2091" title="All 6 branches missed.">                gotDouble = ((doubleResult != (double)longResult) ||</span>
                            (doubleResult == 0.0 &amp;&amp; 1/doubleResult &lt; 0.0)) &amp;&amp;
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                            !isParseIntegerOnly();</span>
            }

<span class="pc bpc" id="L2096" title="1 of 2 branches missed.">            return gotDouble ?</span>
                (Number)new Double(doubleResult) : (Number)new Long(longResult);
        }
    }

    /**
     * Return a BigInteger multiplier.
     */
    private BigInteger getBigIntegerMultiplier() {
<span class="nc bnc" id="L2105" title="All 2 branches missed.">        if (bigIntegerMultiplier == null) {</span>
<span class="nc" id="L2106">            bigIntegerMultiplier = BigInteger.valueOf(multiplier);</span>
        }
<span class="nc" id="L2108">        return bigIntegerMultiplier;</span>
    }
    private transient BigInteger bigIntegerMultiplier;

    /**
     * Return a BigDecimal multiplier.
     */
    private BigDecimal getBigDecimalMultiplier() {
<span class="nc bnc" id="L2116" title="All 2 branches missed.">        if (bigDecimalMultiplier == null) {</span>
<span class="nc" id="L2117">            bigDecimalMultiplier = new BigDecimal(multiplier);</span>
        }
<span class="nc" id="L2119">        return bigDecimalMultiplier;</span>
    }
    private transient BigDecimal bigDecimalMultiplier;

    private static final int STATUS_INFINITE = 0;
    private static final int STATUS_POSITIVE = 1;
    private static final int STATUS_LENGTH   = 2;

    /**
     * Parse the given text into a number.  The text is parsed beginning at
     * parsePosition, until an unparseable character is seen.
     * @param text The string to parse.
     * @param parsePosition The position at which to being parsing.  Upon
     * return, the first unparseable character.
     * @param digits The DigitList to set to the parsed value.
     * @param isExponent If true, parse an exponent.  This means no
     * infinite values and integer only.
     * @param status Upon return contains boolean status flags indicating
     * whether the value was infinite and whether it was positive.
     */
    private final boolean subparse(String text, ParsePosition parsePosition,
                   String positivePrefix, String negativePrefix,
                   DigitList digits, boolean isExponent,
                   boolean status[]) {
<span class="fc" id="L2143">        int position = parsePosition.index;</span>
<span class="fc" id="L2144">        int oldStart = parsePosition.index;</span>
        int backup;
        boolean gotPositive, gotNegative;

        // check for positivePrefix; take longest
<span class="fc" id="L2149">        gotPositive = text.regionMatches(position, positivePrefix, 0,</span>
<span class="fc" id="L2150">                                         positivePrefix.length());</span>
<span class="fc" id="L2151">        gotNegative = text.regionMatches(position, negativePrefix, 0,</span>
<span class="fc" id="L2152">                                         negativePrefix.length());</span>

<span class="pc bpc" id="L2154" title="1 of 4 branches missed.">        if (gotPositive &amp;&amp; gotNegative) {</span>
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">            if (positivePrefix.length() &gt; negativePrefix.length()) {</span>
<span class="nc" id="L2156">                gotNegative = false;</span>
<span class="fc bfc" id="L2157" title="All 2 branches covered.">            } else if (positivePrefix.length() &lt; negativePrefix.length()) {</span>
<span class="fc" id="L2158">                gotPositive = false;</span>
            }
        }

<span class="fc bfc" id="L2162" title="All 2 branches covered.">        if (gotPositive) {</span>
<span class="fc" id="L2163">            position += positivePrefix.length();</span>
<span class="pc bpc" id="L2164" title="1 of 2 branches missed.">        } else if (gotNegative) {</span>
<span class="fc" id="L2165">            position += negativePrefix.length();</span>
        } else {
<span class="nc" id="L2167">            parsePosition.errorIndex = position;</span>
<span class="nc" id="L2168">            return false;</span>
        }

        // process digits or Inf, find decimal position
<span class="fc" id="L2172">        status[STATUS_INFINITE] = false;</span>
<span class="pc bpc" id="L2173" title="2 of 4 branches missed.">        if (!isExponent &amp;&amp; text.regionMatches(position,symbols.getInfinity(),0,</span>
<span class="fc" id="L2174">                          symbols.getInfinity().length())) {</span>
<span class="nc" id="L2175">            position += symbols.getInfinity().length();</span>
<span class="nc" id="L2176">            status[STATUS_INFINITE] = true;</span>
        } else {
            // We now have a string of digits, possibly with grouping symbols,
            // and decimal points.  We want to process these into a DigitList.
            // We don't want to put a bunch of leading zeros into the DigitList
            // though, so we keep track of the location of the decimal point,
            // put only significant digits into the DigitList, and adjust the
            // exponent as needed.

<span class="fc" id="L2185">            digits.decimalAt = digits.count = 0;</span>
<span class="fc" id="L2186">            char zero = symbols.getZeroDigit();</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">            char decimal = isCurrencyFormat ?</span>
<span class="fc" id="L2188">                symbols.getMonetaryDecimalSeparator() :</span>
<span class="fc" id="L2189">                symbols.getDecimalSeparator();</span>
<span class="fc" id="L2190">            char grouping = symbols.getGroupingSeparator();</span>
<span class="fc" id="L2191">            String exponentString = symbols.getExponentSeparator();</span>
<span class="fc" id="L2192">            boolean sawDecimal = false;</span>
<span class="fc" id="L2193">            boolean sawExponent = false;</span>
<span class="fc" id="L2194">            boolean sawDigit = false;</span>
<span class="fc" id="L2195">            int exponent = 0; // Set to the exponent value, if any</span>

            // We have to track digitCount ourselves, because digits.count will
            // pin when the maximum allowable digits is reached.
<span class="fc" id="L2199">            int digitCount = 0;</span>

<span class="fc" id="L2201">            backup = -1;</span>
<span class="fc bfc" id="L2202" title="All 2 branches covered.">            for (; position &lt; text.length(); ++position) {</span>
<span class="fc" id="L2203">                char ch = text.charAt(position);</span>

                /* We recognize all digit ranges, not only the Latin digit range
                 * '0'..'9'.  We do so by using the Character.digit() method,
                 * which converts a valid Unicode digit to the range 0..9.
                 *
                 * The character 'ch' may be a digit.  If so, place its value
                 * from 0 to 9 in 'digit'.  First try using the locale digit,
                 * which may or MAY NOT be a standard Unicode digit range.  If
                 * this fails, try using the standard Unicode digit ranges by
                 * calling Character.digit().  If this also fails, digit will
                 * have a value outside the range 0..9.
                 */
<span class="fc" id="L2216">                int digit = ch - zero;</span>
<span class="fc bfc" id="L2217" title="All 4 branches covered.">                if (digit &lt; 0 || digit &gt; 9) {</span>
<span class="fc" id="L2218">                    digit = Character.digit(ch, 10);</span>
                }

<span class="fc bfc" id="L2221" title="All 2 branches covered.">                if (digit == 0) {</span>
                    // Cancel out backup setting (see grouping handler below)
<span class="fc" id="L2223">                    backup = -1; // Do this BEFORE continue statement below!!!</span>
<span class="fc" id="L2224">                    sawDigit = true;</span>

                    // Handle leading zeros
<span class="fc bfc" id="L2227" title="All 2 branches covered.">                    if (digits.count == 0) {</span>
                        // Ignore leading zeros in integer part of number.
<span class="pc bpc" id="L2229" title="1 of 2 branches missed.">                        if (!sawDecimal) {</span>
<span class="fc" id="L2230">                            continue;</span>
                        }

                        // If we have seen the decimal, but no significant
                        // digits yet, then we account for leading zeros by
                        // decrementing the digits.decimalAt into negative
                        // values.
<span class="nc" id="L2237">                        --digits.decimalAt;</span>
                    } else {
<span class="fc" id="L2239">                        ++digitCount;</span>
<span class="fc" id="L2240">                        digits.append((char)(digit + '0'));</span>
                    }
<span class="pc bpc" id="L2242" title="1 of 4 branches missed.">                } else if (digit &gt; 0 &amp;&amp; digit &lt;= 9) { // [sic] digit==0 handled above</span>
<span class="fc" id="L2243">                    sawDigit = true;</span>
<span class="fc" id="L2244">                    ++digitCount;</span>
<span class="fc" id="L2245">                    digits.append((char)(digit + '0'));</span>

                    // Cancel out backup setting (see grouping handler below)
<span class="fc" id="L2248">                    backup = -1;</span>
<span class="pc bpc" id="L2249" title="2 of 4 branches missed.">                } else if (!isExponent &amp;&amp; ch == decimal) {</span>
                    // If we're only parsing integers, or if we ALREADY saw the
                    // decimal, then don't parse this one.
<span class="nc bnc" id="L2252" title="All 4 branches missed.">                    if (isParseIntegerOnly() || sawDecimal) {</span>
<span class="nc" id="L2253">                        break;</span>
                    }
<span class="nc" id="L2255">                    digits.decimalAt = digitCount; // Not digits.count!</span>
<span class="nc" id="L2256">                    sawDecimal = true;</span>
<span class="pc bpc" id="L2257" title="2 of 6 branches missed.">                } else if (!isExponent &amp;&amp; ch == grouping &amp;&amp; isGroupingUsed()) {</span>
<span class="pc bpc" id="L2258" title="1 of 2 branches missed.">                    if (sawDecimal) {</span>
<span class="nc" id="L2259">                        break;</span>
                    }
                    // Ignore grouping characters, if we are using them, but
                    // require that they be followed by a digit.  Otherwise
                    // we backup and reprocess them.
<span class="fc" id="L2264">                    backup = position;</span>
<span class="pc bpc" id="L2265" title="4 of 6 branches missed.">                } else if (!isExponent &amp;&amp; text.regionMatches(position, exponentString, 0, exponentString.length())</span>
                             &amp;&amp; !sawExponent) {
                    // Process the exponent by recursively calling this method.
<span class="nc" id="L2268">                     ParsePosition pos = new ParsePosition(position + exponentString.length());</span>
<span class="nc" id="L2269">                    boolean[] stat = new boolean[STATUS_LENGTH];</span>
<span class="nc" id="L2270">                    DigitList exponentDigits = new DigitList();</span>

<span class="nc bnc" id="L2272" title="All 2 branches missed.">                    if (subparse(text, pos, &quot;&quot;, Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) &amp;&amp;</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">                        exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {</span>
<span class="nc" id="L2274">                        position = pos.index; // Advance past the exponent</span>
<span class="nc" id="L2275">                        exponent = (int)exponentDigits.getLong();</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">                        if (!stat[STATUS_POSITIVE]) {</span>
<span class="nc" id="L2277">                            exponent = -exponent;</span>
                        }
<span class="nc" id="L2279">                        sawExponent = true;</span>
                    }
                    break; // Whether we fail or succeed, we exit this loop
                } else {
                    break;
                }
            }

<span class="pc bpc" id="L2287" title="1 of 2 branches missed.">            if (backup != -1) {</span>
<span class="nc" id="L2288">                position = backup;</span>
            }

            // If there was no decimal point we have an integer
<span class="pc bpc" id="L2292" title="1 of 2 branches missed.">            if (!sawDecimal) {</span>
<span class="fc" id="L2293">                digits.decimalAt = digitCount; // Not digits.count!</span>
            }

            // Adjust for exponent, if any
<span class="fc" id="L2297">            digits.decimalAt += exponent;</span>

            // If none of the text string was recognized.  For example, parse
            // &quot;x&quot; with pattern &quot;#0.00&quot; (return index and error index both 0)
            // parse &quot;$&quot; with pattern &quot;$#0.00&quot;. (return index 0 and error
            // index 1).
<span class="pc bpc" id="L2303" title="1 of 4 branches missed.">            if (!sawDigit &amp;&amp; digitCount == 0) {</span>
<span class="fc" id="L2304">                parsePosition.index = oldStart;</span>
<span class="fc" id="L2305">                parsePosition.errorIndex = oldStart;</span>
<span class="fc" id="L2306">                return false;</span>
            }
        }

        // check for suffix
<span class="pc bpc" id="L2311" title="1 of 2 branches missed.">        if (!isExponent) {</span>
<span class="fc bfc" id="L2312" title="All 2 branches covered.">            if (gotPositive) {</span>
<span class="fc" id="L2313">                gotPositive = text.regionMatches(position,positiveSuffix,0,</span>
<span class="fc" id="L2314">                                                 positiveSuffix.length());</span>
            }
<span class="fc bfc" id="L2316" title="All 2 branches covered.">            if (gotNegative) {</span>
<span class="fc" id="L2317">                gotNegative = text.regionMatches(position,negativeSuffix,0,</span>
<span class="fc" id="L2318">                                                 negativeSuffix.length());</span>
            }

        // if both match, take longest
<span class="fc bfc" id="L2322" title="All 4 branches covered.">        if (gotPositive &amp;&amp; gotNegative) {</span>
<span class="pc bpc" id="L2323" title="1 of 2 branches missed.">            if (positiveSuffix.length() &gt; negativeSuffix.length()) {</span>
<span class="nc" id="L2324">                gotNegative = false;</span>
<span class="pc bpc" id="L2325" title="1 of 2 branches missed.">            } else if (positiveSuffix.length() &lt; negativeSuffix.length()) {</span>
<span class="fc" id="L2326">                gotPositive = false;</span>
            }
        }

        // fail if neither or both
<span class="pc bpc" id="L2331" title="1 of 2 branches missed.">        if (gotPositive == gotNegative) {</span>
<span class="nc" id="L2332">            parsePosition.errorIndex = position;</span>
<span class="nc" id="L2333">            return false;</span>
        }

<span class="fc bfc" id="L2336" title="All 2 branches covered.">        parsePosition.index = position +</span>
<span class="fc" id="L2337">            (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); // mark success!</span>
        } else {
<span class="nc" id="L2339">            parsePosition.index = position;</span>
        }

<span class="fc" id="L2342">        status[STATUS_POSITIVE] = gotPositive;</span>
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">        if (parsePosition.index == oldStart) {</span>
<span class="nc" id="L2344">            parsePosition.errorIndex = position;</span>
<span class="nc" id="L2345">            return false;</span>
        }
<span class="fc" id="L2347">        return true;</span>
    }

    /**
     * Returns a copy of the decimal format symbols, which is generally not
     * changed by the programmer or user.
     * @return a copy of the desired DecimalFormatSymbols
     * @see java.text.DecimalFormatSymbols
     */
    public DecimalFormatSymbols getDecimalFormatSymbols() {
        try {
            // don't allow multiple references
<span class="fc" id="L2359">            return (DecimalFormatSymbols) symbols.clone();</span>
<span class="nc" id="L2360">        } catch (Exception foo) {</span>
<span class="nc" id="L2361">            return null; // should never happen</span>
        }
    }


    /**
     * Sets the decimal format symbols, which is generally not changed
     * by the programmer or user.
     * @param newSymbols desired DecimalFormatSymbols
     * @see java.text.DecimalFormatSymbols
     */
    public void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols) {
        try {
            // don't allow multiple references
<span class="fc" id="L2375">            symbols = (DecimalFormatSymbols) newSymbols.clone();</span>
<span class="fc" id="L2376">            expandAffixes();</span>
<span class="fc" id="L2377">            fastPathCheckNeeded = true;</span>
<span class="nc" id="L2378">        } catch (Exception foo) {</span>
            // should never happen
<span class="fc" id="L2380">        }</span>
<span class="fc" id="L2381">    }</span>

    /**
     * Get the positive prefix.
     * &lt;P&gt;Examples: +123, $123, sFr123
     *
     * @return the positive prefix
     */
    public String getPositivePrefix () {
<span class="fc" id="L2390">        return positivePrefix;</span>
    }

    /**
     * Set the positive prefix.
     * &lt;P&gt;Examples: +123, $123, sFr123
     *
     * @param newValue the new positive prefix
     */
    public void setPositivePrefix (String newValue) {
<span class="nc" id="L2400">        positivePrefix = newValue;</span>
<span class="nc" id="L2401">        posPrefixPattern = null;</span>
<span class="nc" id="L2402">        positivePrefixFieldPositions = null;</span>
<span class="nc" id="L2403">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2404">    }</span>

    /**
     * Returns the FieldPositions of the fields in the prefix used for
     * positive numbers. This is not used if the user has explicitly set
     * a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is
     * lazily created.
     *
     * @return FieldPositions in positive prefix
     */
    private FieldPosition[] getPositivePrefixFieldPositions() {
<span class="fc bfc" id="L2415" title="All 2 branches covered.">        if (positivePrefixFieldPositions == null) {</span>
<span class="pc bpc" id="L2416" title="1 of 2 branches missed.">            if (posPrefixPattern != null) {</span>
<span class="fc" id="L2417">                positivePrefixFieldPositions = expandAffix(posPrefixPattern);</span>
            } else {
<span class="nc" id="L2419">                positivePrefixFieldPositions = EmptyFieldPositionArray;</span>
            }
        }
<span class="fc" id="L2422">        return positivePrefixFieldPositions;</span>
    }

    /**
     * Get the negative prefix.
     * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
     *
     * @return the negative prefix
     */
    public String getNegativePrefix () {
<span class="fc" id="L2432">        return negativePrefix;</span>
    }

    /**
     * Set the negative prefix.
     * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
     *
     * @param newValue the new negative prefix
     */
    public void setNegativePrefix (String newValue) {
<span class="nc" id="L2442">        negativePrefix = newValue;</span>
<span class="nc" id="L2443">        negPrefixPattern = null;</span>
<span class="nc" id="L2444">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2445">    }</span>

    /**
     * Returns the FieldPositions of the fields in the prefix used for
     * negative numbers. This is not used if the user has explicitly set
     * a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is
     * lazily created.
     *
     * @return FieldPositions in positive prefix
     */
    private FieldPosition[] getNegativePrefixFieldPositions() {
<span class="fc bfc" id="L2456" title="All 2 branches covered.">        if (negativePrefixFieldPositions == null) {</span>
<span class="pc bpc" id="L2457" title="1 of 2 branches missed.">            if (negPrefixPattern != null) {</span>
<span class="fc" id="L2458">                negativePrefixFieldPositions = expandAffix(negPrefixPattern);</span>
            } else {
<span class="nc" id="L2460">                negativePrefixFieldPositions = EmptyFieldPositionArray;</span>
            }
        }
<span class="fc" id="L2463">        return negativePrefixFieldPositions;</span>
    }

    /**
     * Get the positive suffix.
     * &lt;P&gt;Example: 123%
     *
     * @return the positive suffix
     */
    public String getPositiveSuffix () {
<span class="fc" id="L2473">        return positiveSuffix;</span>
    }

    /**
     * Set the positive suffix.
     * &lt;P&gt;Example: 123%
     *
     * @param newValue the new positive suffix
     */
    public void setPositiveSuffix (String newValue) {
<span class="nc" id="L2483">        positiveSuffix = newValue;</span>
<span class="nc" id="L2484">        posSuffixPattern = null;</span>
<span class="nc" id="L2485">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2486">    }</span>

    /**
     * Returns the FieldPositions of the fields in the suffix used for
     * positive numbers. This is not used if the user has explicitly set
     * a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is
     * lazily created.
     *
     * @return FieldPositions in positive prefix
     */
    private FieldPosition[] getPositiveSuffixFieldPositions() {
<span class="fc bfc" id="L2497" title="All 2 branches covered.">        if (positiveSuffixFieldPositions == null) {</span>
<span class="pc bpc" id="L2498" title="1 of 2 branches missed.">            if (posSuffixPattern != null) {</span>
<span class="fc" id="L2499">                positiveSuffixFieldPositions = expandAffix(posSuffixPattern);</span>
            } else {
<span class="nc" id="L2501">                positiveSuffixFieldPositions = EmptyFieldPositionArray;</span>
            }
        }
<span class="fc" id="L2504">        return positiveSuffixFieldPositions;</span>
    }

    /**
     * Get the negative suffix.
     * &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)
     *
     * @return the negative suffix
     */
    public String getNegativeSuffix () {
<span class="fc" id="L2514">        return negativeSuffix;</span>
    }

    /**
     * Set the negative suffix.
     * &lt;P&gt;Examples: 123%
     *
     * @param newValue the new negative suffix
     */
    public void setNegativeSuffix (String newValue) {
<span class="nc" id="L2524">        negativeSuffix = newValue;</span>
<span class="nc" id="L2525">        negSuffixPattern = null;</span>
<span class="nc" id="L2526">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2527">    }</span>

    /**
     * Returns the FieldPositions of the fields in the suffix used for
     * negative numbers. This is not used if the user has explicitly set
     * a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is
     * lazily created.
     *
     * @return FieldPositions in positive prefix
     */
    private FieldPosition[] getNegativeSuffixFieldPositions() {
<span class="fc bfc" id="L2538" title="All 2 branches covered.">        if (negativeSuffixFieldPositions == null) {</span>
<span class="pc bpc" id="L2539" title="1 of 2 branches missed.">            if (negSuffixPattern != null) {</span>
<span class="fc" id="L2540">                negativeSuffixFieldPositions = expandAffix(negSuffixPattern);</span>
            } else {
<span class="nc" id="L2542">                negativeSuffixFieldPositions = EmptyFieldPositionArray;</span>
            }
        }
<span class="fc" id="L2545">        return negativeSuffixFieldPositions;</span>
    }

    /**
     * Gets the multiplier for use in percent, per mille, and similar
     * formats.
     *
     * @return the multiplier
     * @see #setMultiplier(int)
     */
    public int getMultiplier () {
<span class="nc" id="L2556">        return multiplier;</span>
    }

    /**
     * Sets the multiplier for use in percent, per mille, and similar
     * formats.
     * For a percent format, set the multiplier to 100 and the suffixes to
     * have '%' (for Arabic, use the Arabic percent sign).
     * For a per mille format, set the multiplier to 1000 and the suffixes to
     * have '&amp;#92;u2030'.
     *
     * &lt;P&gt;Example: with multiplier 100, 1.23 is formatted as &quot;123&quot;, and
     * &quot;123&quot; is parsed into 1.23.
     *
     * @param newValue the new multiplier
     * @see #getMultiplier
     */
    public void setMultiplier (int newValue) {
<span class="nc" id="L2574">        multiplier = newValue;</span>
<span class="nc" id="L2575">        bigDecimalMultiplier = null;</span>
<span class="nc" id="L2576">        bigIntegerMultiplier = null;</span>
<span class="nc" id="L2577">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2578">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void setGroupingUsed(boolean newValue) {
<span class="fc" id="L2585">        super.setGroupingUsed(newValue);</span>
<span class="fc" id="L2586">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L2587">    }</span>

    /**
     * Return the grouping size. Grouping size is the number of digits between
     * grouping separators in the integer portion of a number.  For example,
     * in the number &quot;123,456.78&quot;, the grouping size is 3.
     *
     * @return the grouping size
     * @see #setGroupingSize
     * @see java.text.NumberFormat#isGroupingUsed
     * @see java.text.DecimalFormatSymbols#getGroupingSeparator
     */
    public int getGroupingSize () {
<span class="fc" id="L2600">        return groupingSize;</span>
    }

    /**
     * Set the grouping size. Grouping size is the number of digits between
     * grouping separators in the integer portion of a number.  For example,
     * in the number &quot;123,456.78&quot;, the grouping size is 3.
     * &lt;br&gt;
     * The value passed in is converted to a byte, which may lose information.
     *
     * @param newValue the new grouping size
     * @see #getGroupingSize
     * @see java.text.NumberFormat#setGroupingUsed
     * @see java.text.DecimalFormatSymbols#setGroupingSeparator
     */
    public void setGroupingSize (int newValue) {
<span class="nc" id="L2616">        groupingSize = (byte)newValue;</span>
<span class="nc" id="L2617">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L2618">    }</span>

    /**
     * Allows you to get the behavior of the decimal separator with integers.
     * (The decimal separator will always appear with decimals.)
     * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
     *
     * @return {@code true} if the decimal separator is always shown;
     *         {@code false} otherwise
     */
    public boolean isDecimalSeparatorAlwaysShown() {
<span class="nc" id="L2629">        return decimalSeparatorAlwaysShown;</span>
    }

    /**
     * Allows you to set the behavior of the decimal separator with integers.
     * (The decimal separator will always appear with decimals.)
     * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
     *
     * @param newValue {@code true} if the decimal separator is always shown;
     *                 {@code false} otherwise
     */
    public void setDecimalSeparatorAlwaysShown(boolean newValue) {
<span class="fc" id="L2641">        decimalSeparatorAlwaysShown = newValue;</span>
<span class="fc" id="L2642">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L2643">    }</span>

    /**
     * Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
     * method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.
     *
     * @return {@code true} if the parse method returns BigDecimal;
     *         {@code false} otherwise
     * @see #setParseBigDecimal
     * @since 1.5
     */
    public boolean isParseBigDecimal() {
<span class="fc" id="L2655">        return parseBigDecimal;</span>
    }

    /**
     * Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
     * method returns &lt;code&gt;BigDecimal&lt;/code&gt;.
     *
     * @param newValue {@code true} if the parse method returns BigDecimal;
     *                 {@code false} otherwise
     * @see #isParseBigDecimal
     * @since 1.5
     */
    public void setParseBigDecimal(boolean newValue) {
<span class="nc" id="L2668">        parseBigDecimal = newValue;</span>
<span class="nc" id="L2669">    }</span>

    /**
     * Standard override; no change in semantics.
     */
    @Override
    public Object clone() {
<span class="fc" id="L2676">        DecimalFormat other = (DecimalFormat) super.clone();</span>
<span class="fc" id="L2677">        other.symbols = (DecimalFormatSymbols) symbols.clone();</span>
<span class="fc" id="L2678">        other.digitList = (DigitList) digitList.clone();</span>

        // Fast-path is almost stateless algorithm. The only logical state is the
        // isFastPath flag. In addition fastPathCheckNeeded is a sentinel flag
        // that forces recalculation of all fast-path fields when set to true.
        //
        // There is thus no need to clone all the fast-path fields.
        // We just only need to set fastPathCheckNeeded to true when cloning,
        // and init fastPathData to null as if it were a truly new instance.
        // Every fast-path field will be recalculated (only once) at next usage of
        // fast-path algorithm.
<span class="fc" id="L2689">        other.fastPathCheckNeeded = true;</span>
<span class="fc" id="L2690">        other.isFastPath = false;</span>
<span class="fc" id="L2691">        other.fastPathData = null;</span>

<span class="fc" id="L2693">        return other;</span>
    }

    /**
     * Overrides equals
     */
    @Override
    public boolean equals(Object obj)
    {
<span class="fc bfc" id="L2702" title="All 2 branches covered.">        if (obj == null)</span>
<span class="fc" id="L2703">            return false;</span>
<span class="fc bfc" id="L2704" title="All 2 branches covered.">        if (!super.equals(obj))</span>
<span class="fc" id="L2705">            return false; // super does class check</span>
<span class="fc" id="L2706">        DecimalFormat other = (DecimalFormat) obj;</span>
<span class="fc bfc" id="L2707" title="All 2 branches covered.">        return ((posPrefixPattern == other.posPrefixPattern &amp;&amp;</span>
<span class="pc bpc" id="L2708" title="2 of 4 branches missed.">                 positivePrefix.equals(other.positivePrefix))</span>
                || (posPrefixPattern != null &amp;&amp;
<span class="fc bfc" id="L2710" title="All 4 branches covered.">                    posPrefixPattern.equals(other.posPrefixPattern)))</span>
            &amp;&amp; ((posSuffixPattern == other.posSuffixPattern &amp;&amp;
<span class="pc bpc" id="L2712" title="2 of 4 branches missed.">                 positiveSuffix.equals(other.positiveSuffix))</span>
                || (posSuffixPattern != null &amp;&amp;
<span class="pc bpc" id="L2714" title="1 of 4 branches missed.">                    posSuffixPattern.equals(other.posSuffixPattern)))</span>
            &amp;&amp; ((negPrefixPattern == other.negPrefixPattern &amp;&amp;
<span class="pc bpc" id="L2716" title="2 of 4 branches missed.">                 negativePrefix.equals(other.negativePrefix))</span>
                || (negPrefixPattern != null &amp;&amp;
<span class="pc bpc" id="L2718" title="1 of 4 branches missed.">                    negPrefixPattern.equals(other.negPrefixPattern)))</span>
            &amp;&amp; ((negSuffixPattern == other.negSuffixPattern &amp;&amp;
<span class="pc bpc" id="L2720" title="2 of 4 branches missed.">                 negativeSuffix.equals(other.negativeSuffix))</span>
                || (negSuffixPattern != null &amp;&amp;
<span class="pc bpc" id="L2722" title="14 of 26 branches missed.">                    negSuffixPattern.equals(other.negSuffixPattern)))</span>
            &amp;&amp; multiplier == other.multiplier
            &amp;&amp; groupingSize == other.groupingSize
            &amp;&amp; decimalSeparatorAlwaysShown == other.decimalSeparatorAlwaysShown
            &amp;&amp; parseBigDecimal == other.parseBigDecimal
            &amp;&amp; useExponentialNotation == other.useExponentialNotation
            &amp;&amp; (!useExponentialNotation ||
                minExponentDigits == other.minExponentDigits)
            &amp;&amp; maximumIntegerDigits == other.maximumIntegerDigits
            &amp;&amp; minimumIntegerDigits == other.minimumIntegerDigits
            &amp;&amp; maximumFractionDigits == other.maximumFractionDigits
            &amp;&amp; minimumFractionDigits == other.minimumFractionDigits
            &amp;&amp; roundingMode == other.roundingMode
<span class="pc bpc" id="L2735" title="1 of 2 branches missed.">            &amp;&amp; symbols.equals(other.symbols);</span>
    }

    /**
     * Overrides hashCode
     */
    @Override
    public int hashCode() {
<span class="nc" id="L2743">        return super.hashCode() * 37 + positivePrefix.hashCode();</span>
        // just enough fields for a reasonable distribution
    }

    /**
     * Synthesizes a pattern string that represents the current state
     * of this Format object.
     *
     * @return a pattern string
     * @see #applyPattern
     */
    public String toPattern() {
<span class="fc" id="L2755">        return toPattern( false );</span>
    }

    /**
     * Synthesizes a localized pattern string that represents the current
     * state of this Format object.
     *
     * @return a localized pattern string
     * @see #applyPattern
     */
    public String toLocalizedPattern() {
<span class="nc" id="L2766">        return toPattern( true );</span>
    }

    /**
     * Expand the affix pattern strings into the expanded affix strings.  If any
     * affix pattern string is null, do not expand it.  This method should be
     * called any time the symbols or the affix patterns change in order to keep
     * the expanded affix strings up to date.
     */
    private void expandAffixes() {
        // Reuse one StringBuffer for better performance
<span class="fc" id="L2777">        StringBuffer buffer = new StringBuffer();</span>
<span class="pc bpc" id="L2778" title="1 of 2 branches missed.">        if (posPrefixPattern != null) {</span>
<span class="fc" id="L2779">            positivePrefix = expandAffix(posPrefixPattern, buffer);</span>
<span class="fc" id="L2780">            positivePrefixFieldPositions = null;</span>
        }
<span class="pc bpc" id="L2782" title="1 of 2 branches missed.">        if (posSuffixPattern != null) {</span>
<span class="fc" id="L2783">            positiveSuffix = expandAffix(posSuffixPattern, buffer);</span>
<span class="fc" id="L2784">            positiveSuffixFieldPositions = null;</span>
        }
<span class="pc bpc" id="L2786" title="1 of 2 branches missed.">        if (negPrefixPattern != null) {</span>
<span class="fc" id="L2787">            negativePrefix = expandAffix(negPrefixPattern, buffer);</span>
<span class="fc" id="L2788">            negativePrefixFieldPositions = null;</span>
        }
<span class="pc bpc" id="L2790" title="1 of 2 branches missed.">        if (negSuffixPattern != null) {</span>
<span class="fc" id="L2791">            negativeSuffix = expandAffix(negSuffixPattern, buffer);</span>
<span class="fc" id="L2792">            negativeSuffixFieldPositions = null;</span>
        }
<span class="fc" id="L2794">    }</span>

    /**
     * Expand an affix pattern into an affix string.  All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @param buffer a scratch StringBuffer; its contents will be lost
     * @return the expanded equivalent of pattern
     */
    private String expandAffix(String pattern, StringBuffer buffer) {
<span class="fc" id="L2811">        buffer.setLength(0);</span>
<span class="fc bfc" id="L2812" title="All 2 branches covered.">        for (int i=0; i&lt;pattern.length(); ) {</span>
<span class="fc" id="L2813">            char c = pattern.charAt(i++);</span>
<span class="fc bfc" id="L2814" title="All 2 branches covered.">            if (c == QUOTE) {</span>
<span class="fc" id="L2815">                c = pattern.charAt(i++);</span>
<span class="pc bpc" id="L2816" title="2 of 5 branches missed.">                switch (c) {</span>
                case CURRENCY_SIGN:
<span class="fc bfc" id="L2818" title="All 2 branches covered.">                    if (i&lt;pattern.length() &amp;&amp;</span>
<span class="pc bpc" id="L2819" title="1 of 2 branches missed.">                        pattern.charAt(i) == CURRENCY_SIGN) {</span>
<span class="nc" id="L2820">                        ++i;</span>
<span class="nc" id="L2821">                        buffer.append(symbols.getInternationalCurrencySymbol());</span>
                    } else {
<span class="fc" id="L2823">                        buffer.append(symbols.getCurrencySymbol());</span>
                    }
<span class="fc" id="L2825">                    continue;</span>
                case PATTERN_PERCENT:
<span class="fc" id="L2827">                    c = symbols.getPercent();</span>
<span class="fc" id="L2828">                    break;</span>
                case PATTERN_PER_MILLE:
<span class="nc" id="L2830">                    c = symbols.getPerMill();</span>
<span class="nc" id="L2831">                    break;</span>
                case PATTERN_MINUS:
<span class="fc" id="L2833">                    c = symbols.getMinusSign();</span>
                    break;
                }
            }
<span class="fc" id="L2837">            buffer.append(c);</span>
<span class="fc" id="L2838">        }</span>
<span class="fc" id="L2839">        return buffer.toString();</span>
    }

    /**
     * Expand an affix pattern into an array of FieldPositions describing
     * how the pattern would be expanded.
     * All characters in the
     * pattern are literal unless prefixed by QUOTE.  The following characters
     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
     * currency code.  Any other character after a QUOTE represents itself.
     * QUOTE must be followed by another character; QUOTE may not occur by
     * itself at the end of the pattern.
     *
     * @param pattern the non-null, possibly empty pattern
     * @return FieldPosition array of the resulting fields.
     */
    private FieldPosition[] expandAffix(String pattern) {
<span class="fc" id="L2858">        ArrayList&lt;FieldPosition&gt; positions = null;</span>
<span class="fc" id="L2859">        int stringIndex = 0;</span>
<span class="fc bfc" id="L2860" title="All 2 branches covered.">        for (int i=0; i&lt;pattern.length(); ) {</span>
<span class="fc" id="L2861">            char c = pattern.charAt(i++);</span>
<span class="pc bpc" id="L2862" title="1 of 2 branches missed.">            if (c == QUOTE) {</span>
<span class="fc" id="L2863">                int field = -1;</span>
<span class="fc" id="L2864">                Format.Field fieldID = null;</span>
<span class="fc" id="L2865">                c = pattern.charAt(i++);</span>
<span class="pc bpc" id="L2866" title="3 of 5 branches missed.">                switch (c) {</span>
                case CURRENCY_SIGN:
                    String string;
<span class="pc bpc" id="L2869" title="1 of 2 branches missed.">                    if (i&lt;pattern.length() &amp;&amp;</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">                        pattern.charAt(i) == CURRENCY_SIGN) {</span>
<span class="nc" id="L2871">                        ++i;</span>
<span class="nc" id="L2872">                        string = symbols.getInternationalCurrencySymbol();</span>
                    } else {
<span class="fc" id="L2874">                        string = symbols.getCurrencySymbol();</span>
                    }
<span class="pc bpc" id="L2876" title="1 of 2 branches missed.">                    if (string.length() &gt; 0) {</span>
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">                        if (positions == null) {</span>
<span class="fc" id="L2878">                            positions = new ArrayList&lt;&gt;(2);</span>
                        }
<span class="fc" id="L2880">                        FieldPosition fp = new FieldPosition(Field.CURRENCY);</span>
<span class="fc" id="L2881">                        fp.setBeginIndex(stringIndex);</span>
<span class="fc" id="L2882">                        fp.setEndIndex(stringIndex + string.length());</span>
<span class="fc" id="L2883">                        positions.add(fp);</span>
<span class="fc" id="L2884">                        stringIndex += string.length();</span>
<span class="fc" id="L2885">                    }</span>
                    continue;
                case PATTERN_PERCENT:
<span class="nc" id="L2888">                    c = symbols.getPercent();</span>
<span class="nc" id="L2889">                    field = -1;</span>
<span class="nc" id="L2890">                    fieldID = Field.PERCENT;</span>
<span class="nc" id="L2891">                    break;</span>
                case PATTERN_PER_MILLE:
<span class="nc" id="L2893">                    c = symbols.getPerMill();</span>
<span class="nc" id="L2894">                    field = -1;</span>
<span class="nc" id="L2895">                    fieldID = Field.PERMILLE;</span>
<span class="nc" id="L2896">                    break;</span>
                case PATTERN_MINUS:
<span class="fc" id="L2898">                    c = symbols.getMinusSign();</span>
<span class="fc" id="L2899">                    field = -1;</span>
<span class="fc" id="L2900">                    fieldID = Field.SIGN;</span>
                    break;
                }
<span class="pc bpc" id="L2903" title="1 of 2 branches missed.">                if (fieldID != null) {</span>
<span class="pc bpc" id="L2904" title="1 of 2 branches missed.">                    if (positions == null) {</span>
<span class="fc" id="L2905">                        positions = new ArrayList&lt;&gt;(2);</span>
                    }
<span class="fc" id="L2907">                    FieldPosition fp = new FieldPosition(fieldID, field);</span>
<span class="fc" id="L2908">                    fp.setBeginIndex(stringIndex);</span>
<span class="fc" id="L2909">                    fp.setEndIndex(stringIndex + 1);</span>
<span class="fc" id="L2910">                    positions.add(fp);</span>
                }
            }
<span class="fc" id="L2913">            stringIndex++;</span>
<span class="fc" id="L2914">        }</span>
<span class="fc bfc" id="L2915" title="All 2 branches covered.">        if (positions != null) {</span>
<span class="fc" id="L2916">            return positions.toArray(EmptyFieldPositionArray);</span>
        }
<span class="fc" id="L2918">        return EmptyFieldPositionArray;</span>
    }

    /**
     * Appends an affix pattern to the given StringBuffer, quoting special
     * characters as needed.  Uses the internal affix pattern, if that exists,
     * or the literal affix, if the internal affix pattern is null.  The
     * appended string will generate the same affix pattern (or literal affix)
     * when passed to toPattern().
     *
     * @param buffer the affix string is appended to this
     * @param affixPattern a pattern such as posPrefixPattern; may be null
     * @param expAffix a corresponding expanded affix, such as positivePrefix.
     * Ignored unless affixPattern is null.  If affixPattern is null, then
     * expAffix is appended as a literal affix.
     * @param localized true if the appended pattern should contain localized
     * pattern characters; otherwise, non-localized pattern chars are appended
     */
    private void appendAffix(StringBuffer buffer, String affixPattern,
                             String expAffix, boolean localized) {
<span class="pc bpc" id="L2938" title="1 of 2 branches missed.">        if (affixPattern == null) {</span>
<span class="nc" id="L2939">            appendAffix(buffer, expAffix, localized);</span>
        } else {
            int i;
<span class="fc bfc" id="L2942" title="All 2 branches covered.">            for (int pos=0; pos&lt;affixPattern.length(); pos=i) {</span>
<span class="fc" id="L2943">                i = affixPattern.indexOf(QUOTE, pos);</span>
<span class="fc bfc" id="L2944" title="All 2 branches covered.">                if (i &lt; 0) {</span>
<span class="fc" id="L2945">                    appendAffix(buffer, affixPattern.substring(pos), localized);</span>
<span class="fc" id="L2946">                    break;</span>
                }
<span class="fc bfc" id="L2948" title="All 2 branches covered.">                if (i &gt; pos) {</span>
<span class="fc" id="L2949">                    appendAffix(buffer, affixPattern.substring(pos, i), localized);</span>
                }
<span class="fc" id="L2951">                char c = affixPattern.charAt(++i);</span>
<span class="fc" id="L2952">                ++i;</span>
<span class="pc bpc" id="L2953" title="1 of 2 branches missed.">                if (c == QUOTE) {</span>
<span class="nc" id="L2954">                    buffer.append(c);</span>
                    // Fall through and append another QUOTE below
<span class="fc bfc" id="L2956" title="All 2 branches covered.">                } else if (c == CURRENCY_SIGN &amp;&amp;</span>
<span class="fc bfc" id="L2957" title="All 2 branches covered.">                           i&lt;affixPattern.length() &amp;&amp;</span>
<span class="pc bpc" id="L2958" title="1 of 2 branches missed.">                           affixPattern.charAt(i) == CURRENCY_SIGN) {</span>
<span class="nc" id="L2959">                    ++i;</span>
<span class="nc" id="L2960">                    buffer.append(c);</span>
                    // Fall through and append another CURRENCY_SIGN below
<span class="pc bpc" id="L2962" title="1 of 2 branches missed.">                } else if (localized) {</span>
<span class="nc bnc" id="L2963" title="All 4 branches missed.">                    switch (c) {</span>
                    case PATTERN_PERCENT:
<span class="nc" id="L2965">                        c = symbols.getPercent();</span>
<span class="nc" id="L2966">                        break;</span>
                    case PATTERN_PER_MILLE:
<span class="nc" id="L2968">                        c = symbols.getPerMill();</span>
<span class="nc" id="L2969">                        break;</span>
                    case PATTERN_MINUS:
<span class="nc" id="L2971">                        c = symbols.getMinusSign();</span>
                        break;
                    }
                }
<span class="fc" id="L2975">                buffer.append(c);</span>
            }
        }
<span class="fc" id="L2978">    }</span>

    /**
     * Append an affix to the given StringBuffer, using quotes if
     * there are special characters.  Single quotes themselves must be
     * escaped in either case.
     */
    private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
        boolean needQuote;
<span class="pc bpc" id="L2987" title="1 of 2 branches missed.">        if (localized) {</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">            needQuote = affix.indexOf(symbols.getZeroDigit()) &gt;= 0</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">                || affix.indexOf(symbols.getGroupingSeparator()) &gt;= 0</span>
<span class="nc bnc" id="L2990" title="All 2 branches missed.">                || affix.indexOf(symbols.getDecimalSeparator()) &gt;= 0</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">                || affix.indexOf(symbols.getPercent()) &gt;= 0</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">                || affix.indexOf(symbols.getPerMill()) &gt;= 0</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">                || affix.indexOf(symbols.getDigit()) &gt;= 0</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">                || affix.indexOf(symbols.getPatternSeparator()) &gt;= 0</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">                || affix.indexOf(symbols.getMinusSign()) &gt;= 0</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">                || affix.indexOf(CURRENCY_SIGN) &gt;= 0;</span>
        } else {
<span class="pc bpc" id="L2998" title="1 of 2 branches missed.">            needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) &gt;= 0</span>
<span class="pc bpc" id="L2999" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_GROUPING_SEPARATOR) &gt;= 0</span>
<span class="pc bpc" id="L3000" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) &gt;= 0</span>
<span class="pc bpc" id="L3001" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_PERCENT) &gt;= 0</span>
<span class="pc bpc" id="L3002" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_PER_MILLE) &gt;= 0</span>
<span class="pc bpc" id="L3003" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_DIGIT) &gt;= 0</span>
<span class="pc bpc" id="L3004" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_SEPARATOR) &gt;= 0</span>
<span class="pc bpc" id="L3005" title="1 of 2 branches missed.">                || affix.indexOf(PATTERN_MINUS) &gt;= 0</span>
<span class="pc bpc" id="L3006" title="1 of 2 branches missed.">                || affix.indexOf(CURRENCY_SIGN) &gt;= 0;</span>
        }
<span class="pc bpc" id="L3008" title="1 of 2 branches missed.">        if (needQuote) buffer.append('\'');</span>
<span class="pc bpc" id="L3009" title="1 of 2 branches missed.">        if (affix.indexOf('\'') &lt; 0) buffer.append(affix);</span>
        else {
<span class="nc bnc" id="L3011" title="All 2 branches missed.">            for (int j=0; j&lt;affix.length(); ++j) {</span>
<span class="nc" id="L3012">                char c = affix.charAt(j);</span>
<span class="nc" id="L3013">                buffer.append(c);</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">                if (c == '\'') buffer.append(c);</span>
            }
        }
<span class="pc bpc" id="L3017" title="1 of 2 branches missed.">        if (needQuote) buffer.append('\'');</span>
<span class="fc" id="L3018">    }</span>

    /**
     * Does the real work of generating a pattern.  */
    private String toPattern(boolean localized) {
<span class="fc" id="L3023">        StringBuffer result = new StringBuffer();</span>
<span class="fc bfc" id="L3024" title="All 2 branches covered.">        for (int j = 1; j &gt;= 0; --j) {</span>
<span class="fc bfc" id="L3025" title="All 2 branches covered.">            if (j == 1)</span>
<span class="fc" id="L3026">                appendAffix(result, posPrefixPattern, positivePrefix, localized);</span>
<span class="fc" id="L3027">            else appendAffix(result, negPrefixPattern, negativePrefix, localized);</span>
            int i;
<span class="pc bpc" id="L3029" title="1 of 2 branches missed.">            int digitCount = useExponentialNotation</span>
<span class="pc" id="L3030">                        ? getMaximumIntegerDigits()</span>
<span class="fc" id="L3031">                        : Math.max(groupingSize, getMinimumIntegerDigits())+1;</span>
<span class="fc bfc" id="L3032" title="All 2 branches covered.">            for (i = digitCount; i &gt; 0; --i) {</span>
<span class="pc bpc" id="L3033" title="1 of 8 branches missed.">                if (i != digitCount &amp;&amp; isGroupingUsed() &amp;&amp; groupingSize != 0 &amp;&amp;</span>
                    i % groupingSize == 0) {
<span class="pc bpc" id="L3035" title="1 of 2 branches missed.">                    result.append(localized ? symbols.getGroupingSeparator() :</span>
                                  PATTERN_GROUPING_SEPARATOR);
                }
<span class="pc bpc" id="L3038" title="1 of 4 branches missed.">                result.append(i &lt;= getMinimumIntegerDigits()</span>
<span class="pc bpc" id="L3039" title="1 of 2 branches missed.">                    ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT)</span>
<span class="pc" id="L3040">                    : (localized ? symbols.getDigit() : PATTERN_DIGIT));</span>
            }
<span class="fc bfc" id="L3042" title="All 4 branches covered.">            if (getMaximumFractionDigits() &gt; 0 || decimalSeparatorAlwaysShown)</span>
<span class="pc bpc" id="L3043" title="1 of 2 branches missed.">                result.append(localized ? symbols.getDecimalSeparator() :</span>
                              PATTERN_DECIMAL_SEPARATOR);
<span class="fc bfc" id="L3045" title="All 2 branches covered.">            for (i = 0; i &lt; getMaximumFractionDigits(); ++i) {</span>
<span class="fc bfc" id="L3046" title="All 2 branches covered.">                if (i &lt; getMinimumFractionDigits()) {</span>
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">                    result.append(localized ? symbols.getZeroDigit() :</span>
                                  PATTERN_ZERO_DIGIT);
                } else {
<span class="pc bpc" id="L3050" title="1 of 2 branches missed.">                    result.append(localized ? symbols.getDigit() :</span>
                                  PATTERN_DIGIT);
                }
            }
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">        if (useExponentialNotation)</span>
        {
<span class="nc bnc" id="L3056" title="All 2 branches missed.">            result.append(localized ? symbols.getExponentSeparator() :</span>
                  PATTERN_EXPONENT);
<span class="nc bnc" id="L3058" title="All 2 branches missed.">        for (i=0; i&lt;minExponentDigits; ++i)</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">                    result.append(localized ? symbols.getZeroDigit() :</span>
                                  PATTERN_ZERO_DIGIT);
        }
<span class="fc bfc" id="L3062" title="All 2 branches covered.">            if (j == 1) {</span>
<span class="fc" id="L3063">                appendAffix(result, posSuffixPattern, positiveSuffix, localized);</span>
<span class="fc bfc" id="L3064" title="All 2 branches covered.">                if ((negSuffixPattern == posSuffixPattern &amp;&amp; // n == p == null</span>
<span class="pc bpc" id="L3065" title="2 of 4 branches missed.">                     negativeSuffix.equals(positiveSuffix))</span>
                    || (negSuffixPattern != null &amp;&amp;
<span class="fc bfc" id="L3067" title="All 2 branches covered.">                        negSuffixPattern.equals(posSuffixPattern))) {</span>
<span class="pc bpc" id="L3068" title="2 of 4 branches missed.">                    if ((negPrefixPattern != null &amp;&amp; posPrefixPattern != null &amp;&amp;</span>
<span class="pc bpc" id="L3069" title="1 of 4 branches missed.">                         negPrefixPattern.equals(&quot;'-&quot; + posPrefixPattern)) ||</span>
                        (negPrefixPattern == posPrefixPattern &amp;&amp; // n == p == null
<span class="nc bnc" id="L3071" title="All 2 branches missed.">                         negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))</span>
<span class="nc" id="L3072">                        break;</span>
                }
<span class="pc bpc" id="L3074" title="1 of 2 branches missed.">                result.append(localized ? symbols.getPatternSeparator() :</span>
                              PATTERN_SEPARATOR);
<span class="fc" id="L3076">            } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);</span>
        }
<span class="fc" id="L3078">        return result.toString();</span>
    }

    /**
     * Apply the given pattern to this Format object.  A pattern is a
     * short-hand specification for the various formatting properties.
     * These properties can also be changed individually through the
     * various setter methods.
     * &lt;p&gt;
     * There is no limit to integer digits set
     * by this routine, since that is the typical end-user desire;
     * use setMaximumInteger if you want to set a real value.
     * For negative numbers, use a second pattern, separated by a semicolon
     * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56
     * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
     * a maximum of 2 fraction digits.
     * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
     * parentheses.
     * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
     * these are presumed to be set in the positive pattern.
     *
     * @param pattern a new pattern
     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null
     * @exception IllegalArgumentException if the given pattern is invalid.
     */
    public void applyPattern(String pattern) {
<span class="fc" id="L3104">        applyPattern(pattern, false);</span>
<span class="fc" id="L3105">    }</span>

    /**
     * Apply the given pattern to this Format object.  The pattern
     * is assumed to be in a localized notation. A pattern is a
     * short-hand specification for the various formatting properties.
     * These properties can also be changed individually through the
     * various setter methods.
     * &lt;p&gt;
     * There is no limit to integer digits set
     * by this routine, since that is the typical end-user desire;
     * use setMaximumInteger if you want to set a real value.
     * For negative numbers, use a second pattern, separated by a semicolon
     * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56
     * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
     * a maximum of 2 fraction digits.
     * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
     * parentheses.
     * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
     * these are presumed to be set in the positive pattern.
     *
     * @param pattern a new pattern
     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null
     * @exception IllegalArgumentException if the given pattern is invalid.
     */
    public void applyLocalizedPattern(String pattern) {
<span class="nc" id="L3131">        applyPattern(pattern, true);</span>
<span class="nc" id="L3132">    }</span>

    /**
     * Does the real work of applying a pattern.
     */
    private void applyPattern(String pattern, boolean localized) {
<span class="fc" id="L3138">        char zeroDigit         = PATTERN_ZERO_DIGIT;</span>
<span class="fc" id="L3139">        char groupingSeparator = PATTERN_GROUPING_SEPARATOR;</span>
<span class="fc" id="L3140">        char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;</span>
<span class="fc" id="L3141">        char percent           = PATTERN_PERCENT;</span>
<span class="fc" id="L3142">        char perMill           = PATTERN_PER_MILLE;</span>
<span class="fc" id="L3143">        char digit             = PATTERN_DIGIT;</span>
<span class="fc" id="L3144">        char separator         = PATTERN_SEPARATOR;</span>
<span class="fc" id="L3145">        String exponent          = PATTERN_EXPONENT;</span>
<span class="fc" id="L3146">        char minus             = PATTERN_MINUS;</span>
<span class="pc bpc" id="L3147" title="1 of 2 branches missed.">        if (localized) {</span>
<span class="nc" id="L3148">            zeroDigit         = symbols.getZeroDigit();</span>
<span class="nc" id="L3149">            groupingSeparator = symbols.getGroupingSeparator();</span>
<span class="nc" id="L3150">            decimalSeparator  = symbols.getDecimalSeparator();</span>
<span class="nc" id="L3151">            percent           = symbols.getPercent();</span>
<span class="nc" id="L3152">            perMill           = symbols.getPerMill();</span>
<span class="nc" id="L3153">            digit             = symbols.getDigit();</span>
<span class="nc" id="L3154">            separator         = symbols.getPatternSeparator();</span>
<span class="nc" id="L3155">            exponent          = symbols.getExponentSeparator();</span>
<span class="nc" id="L3156">            minus             = symbols.getMinusSign();</span>
        }
<span class="fc" id="L3158">        boolean gotNegative = false;</span>
<span class="fc" id="L3159">        decimalSeparatorAlwaysShown = false;</span>
<span class="fc" id="L3160">        isCurrencyFormat = false;</span>
<span class="fc" id="L3161">        useExponentialNotation = false;</span>

        // Two variables are used to record the subrange of the pattern
        // occupied by phase 1.  This is used during the processing of the
        // second pattern (the one representing negative numbers) to ensure
        // that no deviation exists in phase 1 between the two patterns.
<span class="fc" id="L3167">        int phaseOneStart = 0;</span>
<span class="fc" id="L3168">        int phaseOneLength = 0;</span>

<span class="fc" id="L3170">        int start = 0;</span>
<span class="pc bpc" id="L3171" title="1 of 4 branches missed.">        for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {</span>
<span class="fc" id="L3172">            boolean inQuote = false;</span>
<span class="fc" id="L3173">            StringBuffer prefix = new StringBuffer();</span>
<span class="fc" id="L3174">            StringBuffer suffix = new StringBuffer();</span>
<span class="fc" id="L3175">            int decimalPos = -1;</span>
<span class="fc" id="L3176">            int multiplier = 1;</span>
<span class="fc" id="L3177">            int digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0;</span>
<span class="fc" id="L3178">            byte groupingCount = -1;</span>

            // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is
            // the section of the pattern with digits, decimal separator,
            // grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,
            // percent, per mille, and currency symbols are recognized and
            // translated.  The separation of the characters into phases is
            // strictly enforced; if phase 1 characters are to appear in the
            // suffix, for example, they must be quoted.
<span class="fc" id="L3187">            int phase = 0;</span>

            // The affix is either the prefix or the suffix.
<span class="fc" id="L3190">            StringBuffer affix = prefix;</span>

<span class="fc bfc" id="L3192" title="All 2 branches covered.">            for (int pos = start; pos &lt; pattern.length(); ++pos) {</span>
<span class="fc" id="L3193">                char ch = pattern.charAt(pos);</span>
<span class="pc bpc" id="L3194" title="1 of 3 branches missed.">                switch (phase) {</span>
                case 0:
                case 2:
                    // Process the prefix / suffix characters
<span class="pc bpc" id="L3198" title="1 of 2 branches missed.">                    if (inQuote) {</span>
                        // A quote within quotes indicates either the closing
                        // quote or two quotes, which is a quote literal. That
                        // is, we have the second quote in 'do' or 'don''t'.
<span class="nc bnc" id="L3202" title="All 2 branches missed.">                        if (ch == QUOTE) {</span>
<span class="nc bnc" id="L3203" title="All 2 branches missed.">                            if ((pos+1) &lt; pattern.length() &amp;&amp;</span>
<span class="nc bnc" id="L3204" title="All 2 branches missed.">                                pattern.charAt(pos+1) == QUOTE) {</span>
<span class="nc" id="L3205">                                ++pos;</span>
<span class="nc" id="L3206">                                affix.append(&quot;''&quot;); // 'don''t'</span>
                            } else {
<span class="nc" id="L3208">                                inQuote = false; // 'do'</span>
                            }
<span class="nc" id="L3210">                            continue;</span>
                        }
                    } else {
                        // Process unquoted characters seen in prefix or suffix
                        // phase.
<span class="pc bpc" id="L3215" title="3 of 8 branches missed.">                        if (ch == digit ||</span>
                            ch == zeroDigit ||
                            ch == groupingSeparator ||
                            ch == decimalSeparator) {
<span class="fc" id="L3219">                            phase = 1;</span>
<span class="fc bfc" id="L3220" title="All 2 branches covered.">                            if (j == 1) {</span>
<span class="fc" id="L3221">                                phaseOneStart = pos;</span>
                            }
<span class="fc" id="L3223">                            --pos; // Reprocess this character</span>
<span class="fc" id="L3224">                            continue;</span>
<span class="fc bfc" id="L3225" title="All 2 branches covered.">                        } else if (ch == CURRENCY_SIGN) {</span>
                            // Use lookahead to determine if the currency sign
                            // is doubled or not.
<span class="fc bfc" id="L3228" title="All 2 branches covered.">                            boolean doubled = (pos + 1) &lt; pattern.length() &amp;&amp;</span>
<span class="pc bpc" id="L3229" title="1 of 2 branches missed.">                                pattern.charAt(pos + 1) == CURRENCY_SIGN;</span>
<span class="pc bpc" id="L3230" title="1 of 2 branches missed.">                            if (doubled) { // Skip over the doubled character</span>
<span class="nc" id="L3231">                             ++pos;</span>
                            }
<span class="fc" id="L3233">                            isCurrencyFormat = true;</span>
<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">                            affix.append(doubled ? &quot;'\u00A4\u00A4&quot; : &quot;'\u00A4&quot;);</span>
<span class="fc" id="L3235">                            continue;</span>
<span class="pc bpc" id="L3236" title="1 of 2 branches missed.">                        } else if (ch == QUOTE) {</span>
                            // A quote outside quotes indicates either the
                            // opening quote or two quotes, which is a quote
                            // literal. That is, we have the first quote in 'do'
                            // or o''clock.
<span class="nc bnc" id="L3241" title="All 2 branches missed.">                            if (ch == QUOTE) {</span>
<span class="nc bnc" id="L3242" title="All 2 branches missed.">                                if ((pos+1) &lt; pattern.length() &amp;&amp;</span>
<span class="nc bnc" id="L3243" title="All 2 branches missed.">                                    pattern.charAt(pos+1) == QUOTE) {</span>
<span class="nc" id="L3244">                                    ++pos;</span>
<span class="nc" id="L3245">                                    affix.append(&quot;''&quot;); // o''clock</span>
                                } else {
<span class="nc" id="L3247">                                    inQuote = true; // 'do'</span>
                                }
<span class="nc" id="L3249">                                continue;</span>
                            }
<span class="fc bfc" id="L3251" title="All 2 branches covered.">                        } else if (ch == separator) {</span>
                            // Don't allow separators before we see digit
                            // characters of phase 1, and don't allow separators
                            // in the second pattern (j == 0).
<span class="pc bpc" id="L3255" title="2 of 4 branches missed.">                            if (phase == 0 || j == 0) {</span>
<span class="nc" id="L3256">                                throw new IllegalArgumentException(&quot;Unquoted special character '&quot; +</span>
                                    ch + &quot;' in pattern \&quot;&quot; + pattern + '&quot;');
                            }
<span class="fc" id="L3259">                            start = pos + 1;</span>
<span class="fc" id="L3260">                            pos = pattern.length();</span>
<span class="fc" id="L3261">                            continue;</span>
                        }

                        // Next handle characters which are appended directly.
<span class="fc bfc" id="L3265" title="All 2 branches covered.">                        else if (ch == percent) {</span>
<span class="pc bpc" id="L3266" title="1 of 2 branches missed.">                            if (multiplier != 1) {</span>
<span class="nc" id="L3267">                                throw new IllegalArgumentException(&quot;Too many percent/per mille characters in pattern \&quot;&quot; +</span>
                                    pattern + '&quot;');
                            }
<span class="fc" id="L3270">                            multiplier = 100;</span>
<span class="fc" id="L3271">                            affix.append(&quot;'%&quot;);</span>
<span class="fc" id="L3272">                            continue;</span>
<span class="pc bpc" id="L3273" title="1 of 2 branches missed.">                        } else if (ch == perMill) {</span>
<span class="nc bnc" id="L3274" title="All 2 branches missed.">                            if (multiplier != 1) {</span>
<span class="nc" id="L3275">                                throw new IllegalArgumentException(&quot;Too many percent/per mille characters in pattern \&quot;&quot; +</span>
                                    pattern + '&quot;');
                            }
<span class="nc" id="L3278">                            multiplier = 1000;</span>
<span class="nc" id="L3279">                            affix.append(&quot;'\u2030&quot;);</span>
<span class="nc" id="L3280">                            continue;</span>
<span class="fc bfc" id="L3281" title="All 2 branches covered.">                        } else if (ch == minus) {</span>
<span class="fc" id="L3282">                            affix.append(&quot;'-&quot;);</span>
<span class="fc" id="L3283">                            continue;</span>
                        }
                    }
                    // Note that if we are within quotes, or if this is an
                    // unquoted, non-special character, then we usually fall
                    // through to here.
<span class="fc" id="L3289">                    affix.append(ch);</span>
<span class="fc" id="L3290">                    break;</span>

                case 1:
                    // Phase one must be identical in the two sub-patterns. We
                    // enforce this by doing a direct comparison. While
                    // processing the first sub-pattern, we just record its
                    // length. While processing the second, we compare
                    // characters.
<span class="fc bfc" id="L3298" title="All 2 branches covered.">                    if (j == 1) {</span>
<span class="fc" id="L3299">                        ++phaseOneLength;</span>
                    } else {
<span class="fc bfc" id="L3301" title="All 2 branches covered.">                        if (--phaseOneLength == 0) {</span>
<span class="fc" id="L3302">                            phase = 2;</span>
<span class="fc" id="L3303">                            affix = suffix;</span>
                        }
                        continue;
                    }

                    // Process the digits, decimal, and grouping characters. We
                    // record five pieces of information. We expect the digits
                    // to occur in the pattern ####0000.####, and we record the
                    // number of left digits, zero (central) digits, and right
                    // digits. The position of the last grouping character is
                    // recorded (should be somewhere within the first two blocks
                    // of characters), as is the position of the decimal point,
                    // if any (should be in the zero digits). If there is no
                    // decimal point, then there should be no right digits.
<span class="fc bfc" id="L3317" title="All 2 branches covered.">                    if (ch == digit) {</span>
<span class="fc bfc" id="L3318" title="All 2 branches covered.">                        if (zeroDigitCount &gt; 0) {</span>
<span class="fc" id="L3319">                            ++digitRightCount;</span>
                        } else {
<span class="fc" id="L3321">                            ++digitLeftCount;</span>
                        }
<span class="fc bfc" id="L3323" title="All 4 branches covered.">                        if (groupingCount &gt;= 0 &amp;&amp; decimalPos &lt; 0) {</span>
<span class="fc" id="L3324">                            ++groupingCount;</span>
                        }
<span class="fc bfc" id="L3326" title="All 2 branches covered.">                    } else if (ch == zeroDigit) {</span>
<span class="pc bpc" id="L3327" title="1 of 2 branches missed.">                        if (digitRightCount &gt; 0) {</span>
<span class="nc" id="L3328">                            throw new IllegalArgumentException(&quot;Unexpected '0' in pattern \&quot;&quot; +</span>
                                pattern + '&quot;');
                        }
<span class="fc" id="L3331">                        ++zeroDigitCount;</span>
<span class="pc bpc" id="L3332" title="1 of 4 branches missed.">                        if (groupingCount &gt;= 0 &amp;&amp; decimalPos &lt; 0) {</span>
<span class="fc" id="L3333">                            ++groupingCount;</span>
                        }
<span class="fc bfc" id="L3335" title="All 2 branches covered.">                    } else if (ch == groupingSeparator) {</span>
<span class="fc" id="L3336">                        groupingCount = 0;</span>
<span class="fc bfc" id="L3337" title="All 2 branches covered.">                    } else if (ch == decimalSeparator) {</span>
<span class="pc bpc" id="L3338" title="1 of 2 branches missed.">                        if (decimalPos &gt;= 0) {</span>
<span class="nc" id="L3339">                            throw new IllegalArgumentException(&quot;Multiple decimal separators in pattern \&quot;&quot; +</span>
                                pattern + '&quot;');
                        }
<span class="fc" id="L3342">                        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;</span>
<span class="pc bpc" id="L3343" title="1 of 2 branches missed.">                    } else if (pattern.regionMatches(pos, exponent, 0, exponent.length())){</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                        if (useExponentialNotation) {</span>
<span class="nc" id="L3345">                            throw new IllegalArgumentException(&quot;Multiple exponential &quot; +</span>
                                &quot;symbols in pattern \&quot;&quot; + pattern + '&quot;');
                        }
<span class="nc" id="L3348">                        useExponentialNotation = true;</span>
<span class="nc" id="L3349">                        minExponentDigits = 0;</span>

                        // Use lookahead to parse out the exponential part
                        // of the pattern, then jump into phase 2.
<span class="nc" id="L3353">                        pos = pos+exponent.length();</span>
<span class="nc bnc" id="L3354" title="All 2 branches missed.">                         while (pos &lt; pattern.length() &amp;&amp;</span>
<span class="nc bnc" id="L3355" title="All 2 branches missed.">                               pattern.charAt(pos) == zeroDigit) {</span>
<span class="nc" id="L3356">                            ++minExponentDigits;</span>
<span class="nc" id="L3357">                            ++phaseOneLength;</span>
<span class="nc" id="L3358">                            ++pos;</span>
                        }

<span class="nc bnc" id="L3361" title="All 4 branches missed.">                        if ((digitLeftCount + zeroDigitCount) &lt; 1 ||</span>
                            minExponentDigits &lt; 1) {
<span class="nc" id="L3363">                            throw new IllegalArgumentException(&quot;Malformed exponential &quot; +</span>
                                &quot;pattern \&quot;&quot; + pattern + '&quot;');
                        }

                        // Transition to phase 2
<span class="nc" id="L3368">                        phase = 2;</span>
<span class="nc" id="L3369">                        affix = suffix;</span>
<span class="nc" id="L3370">                        --pos;</span>
<span class="nc" id="L3371">                        continue;</span>
                    } else {
<span class="fc" id="L3373">                        phase = 2;</span>
<span class="fc" id="L3374">                        affix = suffix;</span>
<span class="fc" id="L3375">                        --pos;</span>
<span class="fc" id="L3376">                        --phaseOneLength;</span>
<span class="fc" id="L3377">                        continue;</span>
                    }
                    break;
                }
            }

            // Handle patterns with no '0' pattern character. These patterns
            // are legal, but must be interpreted.  &quot;##.###&quot; -&gt; &quot;#0.###&quot;.
            // &quot;.###&quot; -&gt; &quot;.0##&quot;.
            /* We allow patterns of the form &quot;####&quot; to produce a zeroDigitCount
             * of zero (got that?); although this seems like it might make it
             * possible for format() to produce empty strings, format() checks
             * for this condition and outputs a zero digit in this situation.
             * Having a zeroDigitCount of zero yields a minimum integer digits
             * of zero, which allows proper round-trip patterns.  That is, we
             * don't want &quot;#&quot; to become &quot;#0&quot; when toPattern() is called (even
             * though that's what it really is, semantically).
             */
<span class="pc bpc" id="L3395" title="1 of 6 branches missed.">            if (zeroDigitCount == 0 &amp;&amp; digitLeftCount &gt; 0 &amp;&amp; decimalPos &gt;= 0) {</span>
                // Handle &quot;###.###&quot; and &quot;###.&quot; and &quot;.###&quot;
<span class="nc" id="L3397">                int n = decimalPos;</span>
<span class="nc bnc" id="L3398" title="All 2 branches missed.">                if (n == 0) { // Handle &quot;.###&quot;</span>
<span class="nc" id="L3399">                    ++n;</span>
                }
<span class="nc" id="L3401">                digitRightCount = digitLeftCount - n;</span>
<span class="nc" id="L3402">                digitLeftCount = n - 1;</span>
<span class="nc" id="L3403">                zeroDigitCount = 1;</span>
            }

            // Do syntax checking on the digits.
<span class="pc bpc" id="L3407" title="5 of 14 branches missed.">            if ((decimalPos &lt; 0 &amp;&amp; digitRightCount &gt; 0) ||</span>
                (decimalPos &gt;= 0 &amp;&amp; (decimalPos &lt; digitLeftCount ||
                 decimalPos &gt; (digitLeftCount + zeroDigitCount))) ||
                 groupingCount == 0 || inQuote) {
<span class="nc" id="L3411">                throw new IllegalArgumentException(&quot;Malformed pattern \&quot;&quot; +</span>
                    pattern + '&quot;');
            }

<span class="fc bfc" id="L3415" title="All 2 branches covered.">            if (j == 1) {</span>
<span class="fc" id="L3416">                posPrefixPattern = prefix.toString();</span>
<span class="fc" id="L3417">                posSuffixPattern = suffix.toString();</span>
<span class="fc" id="L3418">                negPrefixPattern = posPrefixPattern;   // assume these for now</span>
<span class="fc" id="L3419">                negSuffixPattern = posSuffixPattern;</span>
<span class="fc" id="L3420">                int digitTotalCount = digitLeftCount + zeroDigitCount + digitRightCount;</span>
                /* The effectiveDecimalPos is the position the decimal is at or
                 * would be at if there is no decimal. Note that if decimalPos&lt;0,
                 * then digitTotalCount == digitLeftCount + zeroDigitCount.
                 */
<span class="fc bfc" id="L3425" title="All 2 branches covered.">                int effectiveDecimalPos = decimalPos &gt;= 0 ?</span>
                    decimalPos : digitTotalCount;
<span class="fc" id="L3427">                setMinimumIntegerDigits(effectiveDecimalPos - digitLeftCount);</span>
<span class="pc bpc" id="L3428" title="1 of 2 branches missed.">                setMaximumIntegerDigits(useExponentialNotation ?</span>
<span class="pc" id="L3429">                    digitLeftCount + getMinimumIntegerDigits() :</span>
                    MAXIMUM_INTEGER_DIGITS);
<span class="fc bfc" id="L3431" title="All 2 branches covered.">                setMaximumFractionDigits(decimalPos &gt;= 0 ?</span>
                    (digitTotalCount - decimalPos) : 0);
<span class="fc bfc" id="L3433" title="All 2 branches covered.">                setMinimumFractionDigits(decimalPos &gt;= 0 ?</span>
                    (digitLeftCount + zeroDigitCount - decimalPos) : 0);
<span class="fc bfc" id="L3435" title="All 2 branches covered.">                setGroupingUsed(groupingCount &gt; 0);</span>
<span class="fc bfc" id="L3436" title="All 2 branches covered.">                this.groupingSize = (groupingCount &gt; 0) ? groupingCount : 0;</span>
<span class="fc" id="L3437">                this.multiplier = multiplier;</span>
<span class="pc bpc" id="L3438" title="1 of 4 branches missed.">                setDecimalSeparatorAlwaysShown(decimalPos == 0 ||</span>
                    decimalPos == digitTotalCount);
<span class="fc" id="L3440">            } else {</span>
<span class="fc" id="L3441">                negPrefixPattern = prefix.toString();</span>
<span class="fc" id="L3442">                negSuffixPattern = suffix.toString();</span>
<span class="fc" id="L3443">                gotNegative = true;</span>
            }
        }

<span class="pc bpc" id="L3447" title="1 of 2 branches missed.">        if (pattern.length() == 0) {</span>
<span class="nc" id="L3448">            posPrefixPattern = posSuffixPattern = &quot;&quot;;</span>
<span class="nc" id="L3449">            setMinimumIntegerDigits(0);</span>
<span class="nc" id="L3450">            setMaximumIntegerDigits(MAXIMUM_INTEGER_DIGITS);</span>
<span class="nc" id="L3451">            setMinimumFractionDigits(0);</span>
<span class="nc" id="L3452">            setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);</span>
        }

        // If there was no negative pattern, or if the negative pattern is
        // identical to the positive pattern, then prepend the minus sign to
        // the positive pattern to form the negative pattern.
<span class="pc bpc" id="L3458" title="1 of 2 branches missed.">        if (!gotNegative ||</span>
<span class="fc bfc" id="L3459" title="All 2 branches covered.">            (negPrefixPattern.equals(posPrefixPattern)</span>
<span class="fc bfc" id="L3460" title="All 2 branches covered.">             &amp;&amp; negSuffixPattern.equals(posSuffixPattern))) {</span>
<span class="fc" id="L3461">            negSuffixPattern = posSuffixPattern;</span>
<span class="fc" id="L3462">            negPrefixPattern = &quot;'-&quot; + posPrefixPattern;</span>
        }

<span class="fc" id="L3465">        expandAffixes();</span>
<span class="fc" id="L3466">    }</span>

    /**
     * Sets the maximum number of digits allowed in the integer portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
     * 309 is used. Negative input values are replaced with 0.
     * @see NumberFormat#setMaximumIntegerDigits
     */
    @Override
    public void setMaximumIntegerDigits(int newValue) {
<span class="fc" id="L3478">        maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);</span>
<span class="fc bfc" id="L3479" title="All 2 branches covered.">        super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?</span>
            DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
<span class="pc bpc" id="L3481" title="1 of 2 branches missed.">        if (minimumIntegerDigits &gt; maximumIntegerDigits) {</span>
<span class="nc" id="L3482">            minimumIntegerDigits = maximumIntegerDigits;</span>
<span class="nc bnc" id="L3483" title="All 2 branches missed.">            super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?</span>
                DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
        }
<span class="fc" id="L3486">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L3487">    }</span>

    /**
     * Sets the minimum number of digits allowed in the integer portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
     * 309 is used. Negative input values are replaced with 0.
     * @see NumberFormat#setMinimumIntegerDigits
     */
    @Override
    public void setMinimumIntegerDigits(int newValue) {
<span class="fc" id="L3499">        minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);</span>
<span class="pc bpc" id="L3500" title="1 of 2 branches missed.">        super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?</span>
            DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
<span class="fc bfc" id="L3502" title="All 2 branches covered.">        if (minimumIntegerDigits &gt; maximumIntegerDigits) {</span>
<span class="fc" id="L3503">            maximumIntegerDigits = minimumIntegerDigits;</span>
<span class="pc bpc" id="L3504" title="1 of 2 branches missed.">            super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?</span>
                DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
        }
<span class="fc" id="L3507">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L3508">    }</span>

    /**
     * Sets the maximum number of digits allowed in the fraction portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
     * 340 is used. Negative input values are replaced with 0.
     * @see NumberFormat#setMaximumFractionDigits
     */
    @Override
    public void setMaximumFractionDigits(int newValue) {
<span class="fc" id="L3520">        maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);</span>
<span class="pc bpc" id="L3521" title="1 of 2 branches missed.">        super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?</span>
            DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
<span class="pc bpc" id="L3523" title="1 of 2 branches missed.">        if (minimumFractionDigits &gt; maximumFractionDigits) {</span>
<span class="nc" id="L3524">            minimumFractionDigits = maximumFractionDigits;</span>
<span class="nc bnc" id="L3525" title="All 2 branches missed.">            super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?</span>
                DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
        }
<span class="fc" id="L3528">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L3529">    }</span>

    /**
     * Sets the minimum number of digits allowed in the fraction portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
     * 340 is used. Negative input values are replaced with 0.
     * @see NumberFormat#setMinimumFractionDigits
     */
    @Override
    public void setMinimumFractionDigits(int newValue) {
<span class="fc" id="L3541">        minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);</span>
<span class="pc bpc" id="L3542" title="1 of 2 branches missed.">        super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?</span>
            DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
<span class="fc bfc" id="L3544" title="All 2 branches covered.">        if (minimumFractionDigits &gt; maximumFractionDigits) {</span>
<span class="fc" id="L3545">            maximumFractionDigits = minimumFractionDigits;</span>
<span class="pc bpc" id="L3546" title="1 of 2 branches missed.">            super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?</span>
                DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
        }
<span class="fc" id="L3549">        fastPathCheckNeeded = true;</span>
<span class="fc" id="L3550">    }</span>

    /**
     * Gets the maximum number of digits allowed in the integer portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
     * 309 is used.
     * @see #setMaximumIntegerDigits
     */
    @Override
    public int getMaximumIntegerDigits() {
<span class="nc" id="L3562">        return maximumIntegerDigits;</span>
    }

    /**
     * Gets the minimum number of digits allowed in the integer portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
     * 309 is used.
     * @see #setMinimumIntegerDigits
     */
    @Override
    public int getMinimumIntegerDigits() {
<span class="fc" id="L3575">        return minimumIntegerDigits;</span>
    }

    /**
     * Gets the maximum number of digits allowed in the fraction portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
     * 340 is used.
     * @see #setMaximumFractionDigits
     */
    @Override
    public int getMaximumFractionDigits() {
<span class="fc" id="L3588">        return maximumFractionDigits;</span>
    }

    /**
     * Gets the minimum number of digits allowed in the fraction portion of a
     * number.
     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
     * 340 is used.
     * @see #setMinimumFractionDigits
     */
    @Override
    public int getMinimumFractionDigits() {
<span class="fc" id="L3601">        return minimumFractionDigits;</span>
    }

    /**
     * Gets the currency used by this decimal format when formatting
     * currency values.
     * The currency is obtained by calling
     * {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}
     * on this number format's symbols.
     *
     * @return the currency used by this decimal format, or &lt;code&gt;null&lt;/code&gt;
     * @since 1.4
     */
    @Override
    public Currency getCurrency() {
<span class="nc" id="L3616">        return symbols.getCurrency();</span>
    }

    /**
     * Sets the currency used by this number format when formatting
     * currency values. This does not update the minimum or maximum
     * number of fraction digits used by the number format.
     * The currency is set by calling
     * {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}
     * on this number format's symbols.
     *
     * @param currency the new currency to be used by this decimal format
     * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null
     * @since 1.4
     */
    @Override
    public void setCurrency(Currency currency) {
<span class="nc bnc" id="L3633" title="All 2 branches missed.">        if (currency != symbols.getCurrency()) {</span>
<span class="nc" id="L3634">            symbols.setCurrency(currency);</span>
<span class="nc bnc" id="L3635" title="All 2 branches missed.">            if (isCurrencyFormat) {</span>
<span class="nc" id="L3636">                expandAffixes();</span>
            }
        }
<span class="nc" id="L3639">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L3640">    }</span>

    /**
     * Gets the {@link java.math.RoundingMode} used in this DecimalFormat.
     *
     * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this DecimalFormat.
     * @see #setRoundingMode(RoundingMode)
     * @since 1.6
     */
    @Override
    public RoundingMode getRoundingMode() {
<span class="nc" id="L3651">        return roundingMode;</span>
    }

    /**
     * Sets the {@link java.math.RoundingMode} used in this DecimalFormat.
     *
     * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used
     * @see #getRoundingMode()
     * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null.
     * @since 1.6
     */
    @Override
    public void setRoundingMode(RoundingMode roundingMode) {
<span class="nc bnc" id="L3664" title="All 2 branches missed.">        if (roundingMode == null) {</span>
<span class="nc" id="L3665">            throw new NullPointerException();</span>
        }

<span class="nc" id="L3668">        this.roundingMode = roundingMode;</span>
<span class="nc" id="L3669">        digitList.setRoundingMode(roundingMode);</span>
<span class="nc" id="L3670">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L3671">    }</span>

    /**
     * Reads the default serializable fields from the stream and performs
     * validations and adjustments for older serialized versions. The
     * validations and adjustments are:
     * &lt;ol&gt;
     * &lt;li&gt;
     * Verify that the superclass's digit count fields correctly reflect
     * the limits imposed on formatting numbers other than
     * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These
     * limits are stored in the superclass for serialization compatibility
     * with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and
     * &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.
     * If, in the superclass, the minimum or maximum integer digit count is
     * larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or
     * maximum fraction digit count is larger than
     * &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid
     * and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
     * &lt;li&gt;
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize
     * &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVEN
     * RoundingMode.HALF_EVEN}.  This field is new with version 4.
     * &lt;li&gt;
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call
     * the setters for the minimum and maximum integer and fraction digits with
     * the values of the corresponding superclass getters to initialize the
     * fields in this class. The fields in this class are new with version 3.
     * &lt;li&gt;
     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
     * the stream was written by JDK 1.1, initialize
     * &lt;code&gt;useExponentialNotation&lt;/code&gt;
     * to false, since it was not present in JDK 1.1.
     * &lt;li&gt;
     * Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so
     * that default serialization will work properly if this object is streamed
     * out again.
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
     * &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized
     * to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as
     * literal values.  This is exactly what we want, since that corresponds to
     * the pre-version-2 behavior.
     */
    private void readObject(ObjectInputStream stream)
         throws IOException, ClassNotFoundException
    {
<span class="nc" id="L3719">        stream.defaultReadObject();</span>
<span class="nc" id="L3720">        digitList = new DigitList();</span>

        // We force complete fast-path reinitialization when the instance is
        // deserialized. See clone() comment on fastPathCheckNeeded.
<span class="nc" id="L3724">        fastPathCheckNeeded = true;</span>
<span class="nc" id="L3725">        isFastPath = false;</span>
<span class="nc" id="L3726">        fastPathData = null;</span>

<span class="nc bnc" id="L3728" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 4) {</span>
<span class="nc" id="L3729">            setRoundingMode(RoundingMode.HALF_EVEN);</span>
        } else {
<span class="nc" id="L3731">            setRoundingMode(getRoundingMode());</span>
        }

        // We only need to check the maximum counts because NumberFormat
        // .readObject has already ensured that the maximum is greater than the
        // minimum count.
<span class="nc bnc" id="L3737" title="All 2 branches missed.">        if (super.getMaximumIntegerDigits() &gt; DOUBLE_INTEGER_DIGITS ||</span>
<span class="nc bnc" id="L3738" title="All 2 branches missed.">            super.getMaximumFractionDigits() &gt; DOUBLE_FRACTION_DIGITS) {</span>
<span class="nc" id="L3739">            throw new InvalidObjectException(&quot;Digit count out of range&quot;);</span>
        }
<span class="nc bnc" id="L3741" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 3) {</span>
<span class="nc" id="L3742">            setMaximumIntegerDigits(super.getMaximumIntegerDigits());</span>
<span class="nc" id="L3743">            setMinimumIntegerDigits(super.getMinimumIntegerDigits());</span>
<span class="nc" id="L3744">            setMaximumFractionDigits(super.getMaximumFractionDigits());</span>
<span class="nc" id="L3745">            setMinimumFractionDigits(super.getMinimumFractionDigits());</span>
        }
<span class="nc bnc" id="L3747" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // Didn't have exponential fields
<span class="nc" id="L3749">            useExponentialNotation = false;</span>
        }
<span class="nc" id="L3751">        serialVersionOnStream = currentSerialVersion;</span>
<span class="nc" id="L3752">    }</span>

    //----------------------------------------------------------------------
    // INSTANCE VARIABLES
    //----------------------------------------------------------------------

<span class="pc" id="L3758">    private transient DigitList digitList = new DigitList();</span>

    /**
     * The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.
     *
     * @serial
     * @see #getPositivePrefix
     */
<span class="pc" id="L3766">    private String  positivePrefix = &quot;&quot;;</span>

    /**
     * The symbol used as a suffix when formatting positive numbers.
     * This is often an empty string.
     *
     * @serial
     * @see #getPositiveSuffix
     */
<span class="pc" id="L3775">    private String  positiveSuffix = &quot;&quot;;</span>

    /**
     * The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.
     *
     * @serial
     * @see #getNegativePrefix
     */
<span class="pc" id="L3783">    private String  negativePrefix = &quot;-&quot;;</span>

    /**
     * The symbol used as a suffix when formatting negative numbers.
     * This is often an empty string.
     *
     * @serial
     * @see #getNegativeSuffix
     */
<span class="pc" id="L3792">    private String  negativeSuffix = &quot;&quot;;</span>

    /**
     * The prefix pattern for non-negative numbers.  This variable corresponds
     * to &lt;code&gt;positivePrefix&lt;/code&gt;.
     *
     * &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to
     * &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in
     * &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then
     * &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not
     * change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always
     * &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than
     * stream version 2 restored from stream.
     *
     * @serial
     * @since 1.3
     */
    private String posPrefixPattern;

    /**
     * The suffix pattern for non-negative numbers.  This variable corresponds
     * to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to
     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
     * documentation.
     *
     * @serial
     * @since 1.3
     */
    private String posSuffixPattern;

    /**
     * The prefix pattern for negative numbers.  This variable corresponds
     * to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to
     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
     * documentation.
     *
     * @serial
     * @since 1.3
     */
    private String negPrefixPattern;

    /**
     * The suffix pattern for negative numbers.  This variable corresponds
     * to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to
     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
     * documentation.
     *
     * @serial
     * @since 1.3
     */
    private String negSuffixPattern;

    /**
     * The multiplier for use in percent, per mille, etc.
     *
     * @serial
     * @see #getMultiplier
     */
<span class="pc" id="L3850">    private int     multiplier = 1;</span>

    /**
     * The number of digits between grouping separators in the integer
     * portion of a number.  Must be greater than 0 if
     * &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.
     *
     * @serial
     * @see #getGroupingSize
     * @see java.text.NumberFormat#isGroupingUsed
     */
<span class="pc" id="L3861">    private byte    groupingSize = 3;  // invariant, &gt; 0 if useThousands</span>

    /**
     * If true, forces the decimal separator to always appear in a formatted
     * number, even if the fractional part of the number is zero.
     *
     * @serial
     * @see #isDecimalSeparatorAlwaysShown
     */
<span class="pc" id="L3870">    private boolean decimalSeparatorAlwaysShown = false;</span>

    /**
     * If true, parse returns BigDecimal wherever possible.
     *
     * @serial
     * @see #isParseBigDecimal
     * @since 1.5
     */
<span class="pc" id="L3879">    private boolean parseBigDecimal = false;</span>


    /**
     * True if this object represents a currency format.  This determines
     * whether the monetary decimal separator is used instead of the normal one.
     */
<span class="pc" id="L3886">    private transient boolean isCurrencyFormat = false;</span>

    /**
     * The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.
     * It contains the symbols used to format numbers, e.g. the grouping separator,
     * decimal separator, and so on.
     *
     * @serial
     * @see #setDecimalFormatSymbols
     * @see java.text.DecimalFormatSymbols
     */
<span class="pc" id="L3897">    private DecimalFormatSymbols symbols = null; // LIU new DecimalFormatSymbols();</span>

    /**
     * True to force the use of exponential (i.e. scientific) notation when formatting
     * numbers.
     *
     * @serial
     * @since 1.2
     */
    private boolean useExponentialNotation;  // Newly persistent in the Java 2 platform v.1.2

    /**
     * FieldPositions describing the positive prefix String. This is
     * lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;
     * when needed.
     */
    private transient FieldPosition[] positivePrefixFieldPositions;

    /**
     * FieldPositions describing the positive suffix String. This is
     * lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;
     * when needed.
     */
    private transient FieldPosition[] positiveSuffixFieldPositions;

    /**
     * FieldPositions describing the negative prefix String. This is
     * lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;
     * when needed.
     */
    private transient FieldPosition[] negativePrefixFieldPositions;

    /**
     * FieldPositions describing the negative suffix String. This is
     * lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;
     * when needed.
     */
    private transient FieldPosition[] negativeSuffixFieldPositions;

    /**
     * The minimum number of digits used to display the exponent when a number is
     * formatted in exponential notation.  This field is ignored if
     * &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.
     *
     * @serial
     * @since 1.2
     */
    private byte    minExponentDigits;       // Newly persistent in the Java 2 platform v.1.2

    /**
     * The maximum number of digits allowed in the integer portion of a
     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.
     *
     * @serial
     * @see #getMaximumIntegerDigits
     * @since 1.5
     */
<span class="pc" id="L3956">    private int    maximumIntegerDigits = super.getMaximumIntegerDigits();</span>

    /**
     * The minimum number of digits allowed in the integer portion of a
     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.
     *
     * @serial
     * @see #getMinimumIntegerDigits
     * @since 1.5
     */
<span class="pc" id="L3968">    private int    minimumIntegerDigits = super.getMinimumIntegerDigits();</span>

    /**
     * The maximum number of digits allowed in the fractional portion of a
     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
     * &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
     * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.
     *
     * @serial
     * @see #getMaximumFractionDigits
     * @since 1.5
     */
<span class="pc" id="L3980">    private int    maximumFractionDigits = super.getMaximumFractionDigits();</span>

    /**
     * The minimum number of digits allowed in the fractional portion of a
     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
     * &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
     * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.
     *
     * @serial
     * @see #getMinimumFractionDigits
     * @since 1.5
     */
<span class="pc" id="L3992">    private int    minimumFractionDigits = super.getMinimumFractionDigits();</span>

    /**
     * The {@link java.math.RoundingMode} used in this DecimalFormat.
     *
     * @serial
     * @since 1.6
     */
<span class="pc" id="L4000">    private RoundingMode roundingMode = RoundingMode.HALF_EVEN;</span>

    // ------ DecimalFormat fields for fast-path for double algorithm  ------

    /**
     * Helper inner utility class for storing the data used in the fast-path
     * algorithm. Almost all fields related to fast-path are encapsulated in
     * this class.
     *
     * Any {@code DecimalFormat} instance has a {@code fastPathData}
     * reference field that is null unless both the properties of the instance
     * are such that the instance is in the &quot;fast-path&quot; state, and a format call
     * has been done at least once while in this state.
     *
     * Almost all fields are related to the &quot;fast-path&quot; state only and don't
     * change until one of the instance properties is changed.
     *
     * {@code firstUsedIndex} and {@code lastFreeIndex} are the only
     * two fields that are used and modified while inside a call to
     * {@code fastDoubleFormat}.
     *
     */
<span class="nc" id="L4022">    private static class FastPathData {</span>
        // --- Temporary fields used in fast-path, shared by several methods.

        /** The first unused index at the end of the formatted result. */
        int lastFreeIndex;

        /** The first used index at the beginning of the formatted result */
        int firstUsedIndex;

        // --- State fields related to fast-path status. Changes due to a
        //     property change only. Set by checkAndSetFastPathStatus() only.

        /** Difference between locale zero and default zero representation. */
        int  zeroDelta;

        /** Locale char for grouping separator. */
        char groupingChar;

        /**  Fixed index position of last integral digit of formatted result */
        int integralLastIndex;

        /**  Fixed index position of first fractional digit of formatted result */
        int fractionalFirstIndex;

        /** Fractional constants depending on decimal|currency state */
        double fractionalScaleFactor;
        int fractionalMaxIntBound;


        /** The char array buffer that will contain the formatted result */
        char[] fastPathContainer;

        /** Suffixes recorded as char array for efficiency. */
        char[] charsPositivePrefix;
        char[] charsNegativePrefix;
        char[] charsPositiveSuffix;
        char[] charsNegativeSuffix;
<span class="nc" id="L4059">        boolean positiveAffixesRequired = true;</span>
<span class="nc" id="L4060">        boolean negativeAffixesRequired = true;</span>
    }

    /** The format fast-path status of the instance. Logical state. */
<span class="pc" id="L4064">    private transient boolean isFastPath = false;</span>

    /** Flag stating need of check and reinit fast-path status on next format call. */
<span class="pc" id="L4067">    private transient boolean fastPathCheckNeeded = true;</span>

    /** DecimalFormat reference to its FastPathData */
    private transient FastPathData fastPathData;


    //----------------------------------------------------------------------

    static final int currentSerialVersion = 4;

    /**
     * The internal serial version which says which version was written.
     * Possible values are:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
     * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
     *      &lt;code&gt;useExponentialNotation&lt;/code&gt; and
     *      &lt;code&gt;minExponentDigits&lt;/code&gt;.
     * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
     *      &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,
     *      &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.
     * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
     *      &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,
     *      &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,
     *      &lt;code&gt;maximumFractionDigits&lt;/code&gt;,
     *      &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and
     *      &lt;code&gt;parseBigDecimal&lt;/code&gt;.
     * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
     *      &lt;code&gt;roundingMode&lt;/code&gt;.
     * &lt;/ul&gt;
     * @since 1.2
     * @serial
     */
<span class="pc" id="L4100">    private int serialVersionOnStream = currentSerialVersion;</span>

    //----------------------------------------------------------------------
    // CONSTANTS
    //----------------------------------------------------------------------

    // ------ Fast-Path for double Constants ------

    /** Maximum valid integer value for applying fast-path algorithm */
    private static final double MAX_INT_AS_DOUBLE = (double) Integer.MAX_VALUE;

    /**
     * The digit arrays used in the fast-path methods for collecting digits.
     * Using 3 constants arrays of chars ensures a very fast collection of digits
     */
<span class="nc" id="L4115">    private static class DigitArrays {</span>
<span class="nc" id="L4116">        static final char[] DigitOnes1000 = new char[1000];</span>
<span class="nc" id="L4117">        static final char[] DigitTens1000 = new char[1000];</span>
<span class="nc" id="L4118">        static final char[] DigitHundreds1000 = new char[1000];</span>

        // initialize on demand holder class idiom for arrays of digits
        static {
<span class="nc" id="L4122">            int tenIndex = 0;</span>
<span class="nc" id="L4123">            int hundredIndex = 0;</span>
<span class="nc" id="L4124">            char digitOne = '0';</span>
<span class="nc" id="L4125">            char digitTen = '0';</span>
<span class="nc" id="L4126">            char digitHundred = '0';</span>
<span class="nc bnc" id="L4127" title="All 2 branches missed.">            for (int i = 0;  i &lt; 1000; i++ ) {</span>

<span class="nc" id="L4129">                DigitOnes1000[i] = digitOne;</span>
<span class="nc bnc" id="L4130" title="All 2 branches missed.">                if (digitOne == '9')</span>
<span class="nc" id="L4131">                    digitOne = '0';</span>
                else
<span class="nc" id="L4133">                    digitOne++;</span>

<span class="nc" id="L4135">                DigitTens1000[i] = digitTen;</span>
<span class="nc bnc" id="L4136" title="All 2 branches missed.">                if (i == (tenIndex + 9)) {</span>
<span class="nc" id="L4137">                    tenIndex += 10;</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">                    if (digitTen == '9')</span>
<span class="nc" id="L4139">                        digitTen = '0';</span>
                    else
<span class="nc" id="L4141">                        digitTen++;</span>
                }

<span class="nc" id="L4144">                DigitHundreds1000[i] = digitHundred;</span>
<span class="nc bnc" id="L4145" title="All 2 branches missed.">                if (i == (hundredIndex + 99)) {</span>
<span class="nc" id="L4146">                    digitHundred++;</span>
<span class="nc" id="L4147">                    hundredIndex += 100;</span>
                }
            }
<span class="nc" id="L4150">        }</span>
    }
    // ------ Fast-Path for double Constants end ------

    // Constants for characters used in programmatic (unlocalized) patterns.
    private static final char       PATTERN_ZERO_DIGIT         = '0';
    private static final char       PATTERN_GROUPING_SEPARATOR = ',';
    private static final char       PATTERN_DECIMAL_SEPARATOR  = '.';
    private static final char       PATTERN_PER_MILLE          = '\u2030';
    private static final char       PATTERN_PERCENT            = '%';
    private static final char       PATTERN_DIGIT              = '#';
    private static final char       PATTERN_SEPARATOR          = ';';
    private static final String     PATTERN_EXPONENT           = &quot;E&quot;;
    private static final char       PATTERN_MINUS              = '-';

    /**
     * The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
     * is used in patterns and substituted with either the currency symbol,
     * or if it is doubled, with the international currency symbol.  If the
     * CURRENCY_SIGN is seen in a pattern, then the decimal separator is
     * replaced with the monetary decimal separator.
     *
     * The CURRENCY_SIGN is not localized.
     */
    private static final char       CURRENCY_SIGN = '\u00A4';

    private static final char       QUOTE = '\'';

<span class="fc" id="L4178">    private static FieldPosition[] EmptyFieldPositionArray = new FieldPosition[0];</span>

    // Upper limit on integer and fraction digits for a Java double
    static final int DOUBLE_INTEGER_DIGITS  = 309;
    static final int DOUBLE_FRACTION_DIGITS = 340;

    // Upper limit on integer and fraction digits for BigDecimal and BigInteger
    static final int MAXIMUM_INTEGER_DIGITS  = Integer.MAX_VALUE;
    static final int MAXIMUM_FRACTION_DIGITS = Integer.MAX_VALUE;

    // Proclaim JDK 1.1 serial compatibility.
    static final long serialVersionUID = 864413376551465018L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>