<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BreakIterator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">BreakIterator.java</span></div><h1>BreakIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
 *
 * The original version of this source code and documentation
 * is copyrighted and owned by Taligent, Inc., a wholly-owned
 * subsidiary of IBM. These materials are provided under terms
 * of a License Agreement between Taligent and Sun. This technology
 * is protected by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.lang.ref.SoftReference;
import java.text.spi.BreakIteratorProvider;
import java.util.Locale;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleServiceProviderPool;


/**
 * The &lt;code&gt;BreakIterator&lt;/code&gt; class implements methods for finding
 * the location of boundaries in text. Instances of &lt;code&gt;BreakIterator&lt;/code&gt;
 * maintain a current position and scan over text
 * returning the index of characters where boundaries occur.
 * Internally, &lt;code&gt;BreakIterator&lt;/code&gt; scans text using a
 * &lt;code&gt;CharacterIterator&lt;/code&gt;, and is thus able to scan text held
 * by any object implementing that protocol. A &lt;code&gt;StringCharacterIterator&lt;/code&gt;
 * is used to scan &lt;code&gt;String&lt;/code&gt; objects passed to &lt;code&gt;setText&lt;/code&gt;.
 *
 * &lt;p&gt;
 * You use the factory methods provided by this class to create
 * instances of various types of break iterators. In particular,
 * use &lt;code&gt;getWordInstance&lt;/code&gt;, &lt;code&gt;getLineInstance&lt;/code&gt;,
 * &lt;code&gt;getSentenceInstance&lt;/code&gt;, and &lt;code&gt;getCharacterInstance&lt;/code&gt;
 * to create &lt;code&gt;BreakIterator&lt;/code&gt;s that perform
 * word, line, sentence, and character boundary analysis respectively.
 * A single &lt;code&gt;BreakIterator&lt;/code&gt; can work only on one unit
 * (word, line, sentence, and so on). You must use a different iterator
 * for each unit boundary analysis you wish to perform.
 *
 * &lt;p&gt;&lt;a name=&quot;line&quot;&gt;&lt;/a&gt;
 * Line boundary analysis determines where a text string can be
 * broken when line-wrapping. The mechanism correctly handles
 * punctuation and hyphenated words. Actual line breaking needs
 * to also consider the available line width and is handled by
 * higher-level software.
 *
 * &lt;p&gt;&lt;a name=&quot;sentence&quot;&gt;&lt;/a&gt;
 * Sentence boundary analysis allows selection with correct interpretation
 * of periods within numbers and abbreviations, and trailing punctuation
 * marks such as quotation marks and parentheses.
 *
 * &lt;p&gt;&lt;a name=&quot;word&quot;&gt;&lt;/a&gt;
 * Word boundary analysis is used by search and replace functions, as
 * well as within text editing applications that allow the user to
 * select words with a double click. Word selection provides correct
 * interpretation of punctuation marks within and following
 * words. Characters that are not part of a word, such as symbols
 * or punctuation marks, have word-breaks on both sides.
 *
 * &lt;p&gt;&lt;a name=&quot;character&quot;&gt;&lt;/a&gt;
 * Character boundary analysis allows users to interact with characters
 * as they expect to, for example, when moving the cursor through a text
 * string. Character boundary analysis provides correct navigation
 * through character strings, regardless of how the character is stored.
 * The boundaries returned may be those of supplementary characters,
 * combining character sequences, or ligature clusters.
 * For example, an accented character might be stored as a base character
 * and a diacritical mark. What users consider to be a character can
 * differ between languages.
 *
 * &lt;p&gt;
 * The &lt;code&gt;BreakIterator&lt;/code&gt; instances returned by the factory methods
 * of this class are intended for use with natural languages only, not for
 * programming language text. It is however possible to define subclasses
 * that tokenize a programming language.
 *
 * &lt;P&gt;
 * &lt;strong&gt;Examples&lt;/strong&gt;:&lt;P&gt;
 * Creating and using text boundaries:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void main(String args[]) {
 *      if (args.length == 1) {
 *          String stringToExamine = args[0];
 *          //print each word in order
 *          BreakIterator boundary = BreakIterator.getWordInstance();
 *          boundary.setText(stringToExamine);
 *          printEachForward(boundary, stringToExamine);
 *          //print each sentence in reverse order
 *          boundary = BreakIterator.getSentenceInstance(Locale.US);
 *          boundary.setText(stringToExamine);
 *          printEachBackward(boundary, stringToExamine);
 *          printFirst(boundary, stringToExamine);
 *          printLast(boundary, stringToExamine);
 *      }
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Print each element in order:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void printEachForward(BreakIterator boundary, String source) {
 *     int start = boundary.first();
 *     for (int end = boundary.next();
 *          end != BreakIterator.DONE;
 *          start = end, end = boundary.next()) {
 *          System.out.println(source.substring(start,end));
 *     }
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Print each element in reverse order:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void printEachBackward(BreakIterator boundary, String source) {
 *     int end = boundary.last();
 *     for (int start = boundary.previous();
 *          start != BreakIterator.DONE;
 *          end = start, start = boundary.previous()) {
 *         System.out.println(source.substring(start,end));
 *     }
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Print first element:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void printFirst(BreakIterator boundary, String source) {
 *     int start = boundary.first();
 *     int end = boundary.next();
 *     System.out.println(source.substring(start,end));
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Print last element:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void printLast(BreakIterator boundary, String source) {
 *     int end = boundary.last();
 *     int start = boundary.previous();
 *     System.out.println(source.substring(start,end));
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Print the element at a specified position:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * public static void printAt(BreakIterator boundary, int pos, String source) {
 *     int end = boundary.following(pos);
 *     int start = boundary.previous();
 *     System.out.println(source.substring(start,end));
 * }
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * Find the next word:
 * &lt;blockquote&gt;
 * &lt;pre&gt;{@code
 * public static int nextWordStartAfter(int pos, String text) {
 *     BreakIterator wb = BreakIterator.getWordInstance();
 *     wb.setText(text);
 *     int last = wb.following(pos);
 *     int current = wb.next();
 *     while (current != BreakIterator.DONE) {
 *         for (int p = last; p &lt; current; p++) {
 *             if (Character.isLetter(text.codePointAt(p)))
 *                 return last;
 *         }
 *         last = current;
 *         current = wb.next();
 *     }
 *     return BreakIterator.DONE;
 * }
 * }&lt;/pre&gt;
 * (The iterator returned by BreakIterator.getWordInstance() is unique in that
 * the break positions it returns don't represent both the start and end of the
 * thing being iterated over.  That is, a sentence-break iterator returns breaks
 * that each represent the end of one sentence and the beginning of the next.
 * With the word-break iterator, the characters between two boundaries might be a
 * word, or they might be the punctuation or whitespace between two words.  The
 * above code uses a simple heuristic to determine which boundary is the beginning
 * of a word: If the characters between this boundary and the next boundary
 * include at least one letter (this can be an alphabetical letter, a CJK ideograph,
 * a Hangul syllable, a Kana character, etc.), then the text between this boundary
 * and the next is a word; otherwise, it's the material between words.)
 * &lt;/blockquote&gt;
 *
 * @see CharacterIterator
 *
 */

public abstract class BreakIterator implements Cloneable
{
    /**
     * Constructor. BreakIterator is stateless and has no default behavior.
     */
    protected BreakIterator()
<span class="fc" id="L234">    {</span>
<span class="fc" id="L235">    }</span>

    /**
     * Create a copy of this iterator
     * @return A copy of this
     */
    @Override
    public Object clone()
    {
        try {
<span class="nc" id="L245">            return super.clone();</span>
        }
<span class="nc" id="L247">        catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L248">            throw new InternalError(e);</span>
        }
    }

    /**
     * DONE is returned by previous(), next(), next(int), preceding(int)
     * and following(int) when either the first or last text boundary has been
     * reached.
     */
    public static final int DONE = -1;

    /**
     * Returns the first boundary. The iterator's current position is set
     * to the first text boundary.
     * @return The character index of the first text boundary.
     */
    public abstract int first();

    /**
     * Returns the last boundary. The iterator's current position is set
     * to the last text boundary.
     * @return The character index of the last text boundary.
     */
    public abstract int last();

    /**
     * Returns the nth boundary from the current boundary. If either
     * the first or last text boundary has been reached, it returns
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the current position is set to either
     * the first or last text boundary depending on which one is reached. Otherwise,
     * the iterator's current position is set to the new boundary.
     * For example, if the iterator's current position is the mth text boundary
     * and three more boundaries exist from the current boundary to the last text
     * boundary, the next(2) call will return m + 2. The new text position is set
     * to the (m + 2)th text boundary. A next(4) call would return
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the last text boundary would become the
     * new text position.
     * @param n which boundary to return.  A value of 0
     * does nothing.  Negative values move to previous boundaries
     * and positive values move to later boundaries.
     * @return The character index of the nth boundary from the current position
     * or &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if either first or last text boundary
     * has been reached.
     */
    public abstract int next(int n);

    /**
     * Returns the boundary following the current boundary. If the current boundary
     * is the last text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and
     * the iterator's current position is unchanged. Otherwise, the iterator's
     * current position is set to the boundary following the current boundary.
     * @return The character index of the next text boundary or
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the last text
     * boundary.
     * Equivalent to next(1).
     * @see #next(int)
     */
    public abstract int next();

    /**
     * Returns the boundary preceding the current boundary. If the current boundary
     * is the first text boundary, it returns &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and
     * the iterator's current position is unchanged. Otherwise, the iterator's
     * current position is set to the boundary preceding the current boundary.
     * @return The character index of the previous text boundary or
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the current boundary is the first text
     * boundary.
     */
    public abstract int previous();

    /**
     * Returns the first boundary following the specified character offset. If the
     * specified offset equals to the last text boundary, it returns
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator's current position is unchanged.
     * Otherwise, the iterator's current position is set to the returned boundary.
     * The value returned is always greater than the offset or the value
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.
     * @param offset the character offset to begin scanning.
     * @return The first boundary after the specified offset or
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the last text boundary is passed in
     * as the offset.
     * @exception  IllegalArgumentException if the specified offset is less than
     * the first text boundary or greater than the last text boundary.
     */
    public abstract int following(int offset);

    /**
     * Returns the last boundary preceding the specified character offset. If the
     * specified offset equals to the first text boundary, it returns
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; and the iterator's current position is unchanged.
     * Otherwise, the iterator's current position is set to the returned boundary.
     * The value returned is always less than the offset or the value
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt;.
     * @param offset the character offset to begin scanning.
     * @return The last boundary before the specified offset or
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; if the first text boundary is passed in
     * as the offset.
     * @exception   IllegalArgumentException if the specified offset is less than
     * the first text boundary or greater than the last text boundary.
     * @since 1.2
     */
    public int preceding(int offset) {
        // NOTE:  This implementation is here solely because we can't add new
        // abstract methods to an existing class.  There is almost ALWAYS a
        // better, faster way to do this.
<span class="nc" id="L353">        int pos = following(offset);</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">        while (pos &gt;= offset &amp;&amp; pos != DONE) {</span>
<span class="nc" id="L355">            pos = previous();</span>
        }
<span class="nc" id="L357">        return pos;</span>
    }

    /**
     * Returns true if the specified character offset is a text boundary.
     * @param offset the character offset to check.
     * @return &lt;code&gt;true&lt;/code&gt; if &quot;offset&quot; is a boundary position,
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     * @exception   IllegalArgumentException if the specified offset is less than
     * the first text boundary or greater than the last text boundary.
     * @since 1.2
     */
    public boolean isBoundary(int offset) {
        // NOTE: This implementation probably is wrong for most situations
        // because it fails to take into account the possibility that a
        // CharacterIterator passed to setText() may not have a begin offset
        // of 0.  But since the abstract BreakIterator doesn't have that
        // knowledge, it assumes the begin offset is 0.  If you subclass
        // BreakIterator, copy the SimpleTextBoundary implementation of this
        // function into your subclass.  [This should have been abstract at
        // this level, but it's too late to fix that now.]
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (offset == 0) {</span>
<span class="nc" id="L379">            return true;</span>
        }
<span class="nc" id="L381">        int boundary = following(offset - 1);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (boundary == DONE) {</span>
<span class="nc" id="L383">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L385" title="All 2 branches missed.">        return boundary == offset;</span>
    }

    /**
     * Returns character index of the text boundary that was most
     * recently returned by next(), next(int), previous(), first(), last(),
     * following(int) or preceding(int). If any of these methods returns
     * &lt;code&gt;BreakIterator.DONE&lt;/code&gt; because either first or last text boundary
     * has been reached, it returns the first or last text boundary depending on
     * which one is reached.
     * @return The text boundary returned from the above methods, first or last
     * text boundary.
     * @see #next()
     * @see #next(int)
     * @see #previous()
     * @see #first()
     * @see #last()
     * @see #following(int)
     * @see #preceding(int)
     */
    public abstract int current();

    /**
     * Get the text being scanned
     * @return the text being scanned
     */
    public abstract CharacterIterator getText();

    /**
     * Set a new text string to be scanned.  The current scan
     * position is reset to first().
     * @param newText new text to scan.
     */
    public void setText(String newText)
    {
<span class="nc" id="L420">        setText(new StringCharacterIterator(newText));</span>
<span class="nc" id="L421">    }</span>

    /**
     * Set a new text for scanning.  The current scan
     * position is reset to first().
     * @param newText new text to scan.
     */
    public abstract void setText(CharacterIterator newText);

    private static final int CHARACTER_INDEX = 0;
    private static final int WORD_INDEX = 1;
    private static final int LINE_INDEX = 2;
    private static final int SENTENCE_INDEX = 3;

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L436">    private static final SoftReference&lt;BreakIteratorCache&gt;[] iterCache = (SoftReference&lt;BreakIteratorCache&gt;[]) new SoftReference&lt;?&gt;[4];</span>

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
     * for the {@linkplain Locale#getDefault() default locale}.
     * @return A break iterator for word breaks
     */
    public static BreakIterator getWordInstance()
    {
<span class="nc" id="L446">        return getWordInstance(Locale.getDefault());</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#word&quot;&gt;word breaks&lt;/a&gt;
     * for the given locale.
     * @param locale the desired locale
     * @return A break iterator for word breaks
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     */
    public static BreakIterator getWordInstance(Locale locale)
    {
<span class="nc" id="L459">        return getBreakInstance(locale, WORD_INDEX);</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
     * for the {@linkplain Locale#getDefault() default locale}.
     * @return A break iterator for line breaks
     */
    public static BreakIterator getLineInstance()
    {
<span class="nc" id="L470">        return getLineInstance(Locale.getDefault());</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#line&quot;&gt;line breaks&lt;/a&gt;
     * for the given locale.
     * @param locale the desired locale
     * @return A break iterator for line breaks
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     */
    public static BreakIterator getLineInstance(Locale locale)
    {
<span class="nc" id="L483">        return getBreakInstance(locale, LINE_INDEX);</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
     * for the {@linkplain Locale#getDefault() default locale}.
     * @return A break iterator for character breaks
     */
    public static BreakIterator getCharacterInstance()
    {
<span class="nc" id="L494">        return getCharacterInstance(Locale.getDefault());</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#character&quot;&gt;character breaks&lt;/a&gt;
     * for the given locale.
     * @param locale the desired locale
     * @return A break iterator for character breaks
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     */
    public static BreakIterator getCharacterInstance(Locale locale)
    {
<span class="nc" id="L507">        return getBreakInstance(locale, CHARACTER_INDEX);</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
     * for the {@linkplain Locale#getDefault() default locale}.
     * @return A break iterator for sentence breaks
     */
    public static BreakIterator getSentenceInstance()
    {
<span class="nc" id="L518">        return getSentenceInstance(Locale.getDefault());</span>
    }

    /**
     * Returns a new &lt;code&gt;BreakIterator&lt;/code&gt; instance
     * for &lt;a href=&quot;BreakIterator.html#sentence&quot;&gt;sentence breaks&lt;/a&gt;
     * for the given locale.
     * @param locale the desired locale
     * @return A break iterator for sentence breaks
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     */
    public static BreakIterator getSentenceInstance(Locale locale)
    {
<span class="nc" id="L531">        return getBreakInstance(locale, SENTENCE_INDEX);</span>
    }

    private static BreakIterator getBreakInstance(Locale locale, int type) {
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">        if (iterCache[type] != null) {</span>
<span class="nc" id="L536">            BreakIteratorCache cache = iterCache[type].get();</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (cache != null) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (cache.getLocale().equals(locale)) {</span>
<span class="nc" id="L539">                    return cache.createBreakInstance();</span>
                }
            }
        }

<span class="nc" id="L544">        BreakIterator result = createBreakInstance(locale, type);</span>
<span class="nc" id="L545">        BreakIteratorCache cache = new BreakIteratorCache(locale, result);</span>
<span class="nc" id="L546">        iterCache[type] = new SoftReference&lt;&gt;(cache);</span>
<span class="nc" id="L547">        return result;</span>
    }

    private static BreakIterator createBreakInstance(Locale locale,
                                                     int type) {
<span class="nc" id="L552">        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(BreakIteratorProvider.class, locale);</span>
<span class="nc" id="L553">        BreakIterator iterator = createBreakInstance(adapter, locale, type);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L555">            iterator = createBreakInstance(LocaleProviderAdapter.forJRE(), locale, type);</span>
        }
<span class="nc" id="L557">        return iterator;</span>
    }

    private static BreakIterator createBreakInstance(LocaleProviderAdapter adapter, Locale locale, int type) {
<span class="nc" id="L561">        BreakIteratorProvider breakIteratorProvider = adapter.getBreakIteratorProvider();</span>
<span class="nc" id="L562">        BreakIterator iterator = null;</span>
<span class="nc bnc" id="L563" title="All 5 branches missed.">        switch (type) {</span>
        case CHARACTER_INDEX:
<span class="nc" id="L565">            iterator = breakIteratorProvider.getCharacterInstance(locale);</span>
<span class="nc" id="L566">            break;</span>
        case WORD_INDEX:
<span class="nc" id="L568">            iterator = breakIteratorProvider.getWordInstance(locale);</span>
<span class="nc" id="L569">            break;</span>
        case LINE_INDEX:
<span class="nc" id="L571">            iterator = breakIteratorProvider.getLineInstance(locale);</span>
<span class="nc" id="L572">            break;</span>
        case SENTENCE_INDEX:
<span class="nc" id="L574">            iterator = breakIteratorProvider.getSentenceInstance(locale);</span>
            break;
        }
<span class="nc" id="L577">        return iterator;</span>
    }

    /**
     * Returns an array of all locales for which the
     * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
     * localized instances.
     * The returned array represents the union of locales supported by the Java
     * runtime and by installed
     * {@link java.text.spi.BreakIteratorProvider BreakIteratorProvider} implementations.
     * It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
     * instance equal to {@link java.util.Locale#US Locale.US}.
     *
     * @return An array of locales for which localized
     *         &lt;code&gt;BreakIterator&lt;/code&gt; instances are available.
     */
    public static synchronized Locale[] getAvailableLocales()
    {
<span class="fc" id="L595">        LocaleServiceProviderPool pool =</span>
<span class="fc" id="L596">            LocaleServiceProviderPool.getPool(BreakIteratorProvider.class);</span>
<span class="fc" id="L597">        return pool.getAvailableLocales();</span>
    }

    private static final class BreakIteratorCache {

        private BreakIterator iter;
        private Locale locale;

<span class="nc" id="L605">        BreakIteratorCache(Locale locale, BreakIterator iter) {</span>
<span class="nc" id="L606">            this.locale = locale;</span>
<span class="nc" id="L607">            this.iter = (BreakIterator) iter.clone();</span>
<span class="nc" id="L608">        }</span>

        Locale getLocale() {
<span class="nc" id="L611">            return locale;</span>
        }

        BreakIterator createBreakInstance() {
<span class="nc" id="L615">            return (BreakIterator) iter.clone();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>