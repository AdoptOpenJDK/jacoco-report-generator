<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SimpleDateFormat.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">SimpleDateFormat.java</span></div><h1>SimpleDateFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import static java.text.DateFormatSymbols.*;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.Map;
import java.util.SimpleTimeZone;
import java.util.SortedMap;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import sun.util.calendar.CalendarUtils;
import sun.util.calendar.ZoneInfoFile;
import sun.util.locale.provider.LocaleProviderAdapter;

/**
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; is a concrete class for formatting and
 * parsing dates in a locale-sensitive manner. It allows for formatting
 * (date &amp;rarr; text), parsing (text &amp;rarr; date), and normalization.
 *
 * &lt;p&gt;
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; allows you to start by choosing
 * any user-defined patterns for date-time formatting. However, you
 * are encouraged to create a date-time formatter with either
 * &lt;code&gt;getTimeInstance&lt;/code&gt;, &lt;code&gt;getDateInstance&lt;/code&gt;, or
 * &lt;code&gt;getDateTimeInstance&lt;/code&gt; in &lt;code&gt;DateFormat&lt;/code&gt;. Each
 * of these class methods can return a date/time formatter initialized
 * with a default format pattern. You may modify the format pattern
 * using the &lt;code&gt;applyPattern&lt;/code&gt; methods as desired.
 * For more information on using these methods, see
 * {@link DateFormat}.
 *
 * &lt;h3&gt;Date and Time Patterns&lt;/h3&gt;
 * &lt;p&gt;
 * Date and time formats are specified by &lt;em&gt;date and time pattern&lt;/em&gt;
 * strings.
 * Within date and time pattern strings, unquoted letters from
 * &lt;code&gt;'A'&lt;/code&gt; to &lt;code&gt;'Z'&lt;/code&gt; and from &lt;code&gt;'a'&lt;/code&gt; to
 * &lt;code&gt;'z'&lt;/code&gt; are interpreted as pattern letters representing the
 * components of a date or time string.
 * Text can be quoted using single quotes (&lt;code&gt;'&lt;/code&gt;) to avoid
 * interpretation.
 * &lt;code&gt;&quot;''&quot;&lt;/code&gt; represents a single quote.
 * All other characters are not interpreted; they're simply copied into the
 * output string during formatting or matched against the input string
 * during parsing.
 * &lt;p&gt;
 * The following pattern letters are defined (all other characters from
 * &lt;code&gt;'A'&lt;/code&gt; to &lt;code&gt;'Z'&lt;/code&gt; and from &lt;code&gt;'a'&lt;/code&gt; to
 * &lt;code&gt;'z'&lt;/code&gt; are reserved):
 * &lt;blockquote&gt;
 * &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Chart shows pattern letters, date/time component, presentation, and examples.&quot;&gt;
 *     &lt;tr style=&quot;background-color: rgb(204, 204, 255);&quot;&gt;
 *         &lt;th align=left&gt;Letter
 *         &lt;th align=left&gt;Date or Time Component
 *         &lt;th align=left&gt;Presentation
 *         &lt;th align=left&gt;Examples
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;G&lt;/code&gt;
 *         &lt;td&gt;Era designator
 *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;AD&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;y&lt;/code&gt;
 *         &lt;td&gt;Year
 *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;1996&lt;/code&gt;; &lt;code&gt;96&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;Y&lt;/code&gt;
 *         &lt;td&gt;Week year
 *         &lt;td&gt;&lt;a href=&quot;#year&quot;&gt;Year&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;2009&lt;/code&gt;; &lt;code&gt;09&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;M&lt;/code&gt;
 *         &lt;td&gt;Month in year (context sensitive)
 *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;L&lt;/code&gt;
 *         &lt;td&gt;Month in year (standalone form)
 *         &lt;td&gt;&lt;a href=&quot;#month&quot;&gt;Month&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;July&lt;/code&gt;; &lt;code&gt;Jul&lt;/code&gt;; &lt;code&gt;07&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;w&lt;/code&gt;
 *         &lt;td&gt;Week in year
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;27&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;W&lt;/code&gt;
 *         &lt;td&gt;Week in month
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;D&lt;/code&gt;
 *         &lt;td&gt;Day in year
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;189&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;d&lt;/code&gt;
 *         &lt;td&gt;Day in month
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;10&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;F&lt;/code&gt;
 *         &lt;td&gt;Day of week in month
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;2&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;E&lt;/code&gt;
 *         &lt;td&gt;Day name in week
 *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;Tuesday&lt;/code&gt;; &lt;code&gt;Tue&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;u&lt;/code&gt;
 *         &lt;td&gt;Day number of week (1 = Monday, ..., 7 = Sunday)
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;1&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;a&lt;/code&gt;
 *         &lt;td&gt;Am/pm marker
 *         &lt;td&gt;&lt;a href=&quot;#text&quot;&gt;Text&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;PM&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;H&lt;/code&gt;
 *         &lt;td&gt;Hour in day (0-23)
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;k&lt;/code&gt;
 *         &lt;td&gt;Hour in day (1-24)
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;24&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;K&lt;/code&gt;
 *         &lt;td&gt;Hour in am/pm (0-11)
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;0&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;h&lt;/code&gt;
 *         &lt;td&gt;Hour in am/pm (1-12)
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;12&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;m&lt;/code&gt;
 *         &lt;td&gt;Minute in hour
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;30&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;s&lt;/code&gt;
 *         &lt;td&gt;Second in minute
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;55&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;S&lt;/code&gt;
 *         &lt;td&gt;Millisecond
 *         &lt;td&gt;&lt;a href=&quot;#number&quot;&gt;Number&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;978&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;z&lt;/code&gt;
 *         &lt;td&gt;Time zone
 *         &lt;td&gt;&lt;a href=&quot;#timezone&quot;&gt;General time zone&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;Pacific Standard Time&lt;/code&gt;; &lt;code&gt;PST&lt;/code&gt;; &lt;code&gt;GMT-08:00&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;Z&lt;/code&gt;
 *         &lt;td&gt;Time zone
 *         &lt;td&gt;&lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zone&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;-0800&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;X&lt;/code&gt;
 *         &lt;td&gt;Time zone
 *         &lt;td&gt;&lt;a href=&quot;#iso8601timezone&quot;&gt;ISO 8601 time zone&lt;/a&gt;
 *         &lt;td&gt;&lt;code&gt;-08&lt;/code&gt;; &lt;code&gt;-0800&lt;/code&gt;;  &lt;code&gt;-08:00&lt;/code&gt;
 * &lt;/table&gt;
 * &lt;/blockquote&gt;
 * Pattern letters are usually repeated, as their number determines the
 * exact presentation:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;text&quot;&gt;Text:&lt;/a&gt;&lt;/strong&gt;
 *     For formatting, if the number of pattern letters is 4 or more,
 *     the full form is used; otherwise a short or abbreviated form
 *     is used if available.
 *     For parsing, both forms are accepted, independent of the number
 *     of pattern letters.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;number&quot;&gt;Number:&lt;/a&gt;&lt;/strong&gt;
 *     For formatting, the number of pattern letters is the minimum
 *     number of digits, and shorter numbers are zero-padded to this amount.
 *     For parsing, the number of pattern letters is ignored unless
 *     it's needed to separate two adjacent fields.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;year&quot;&gt;Year:&lt;/a&gt;&lt;/strong&gt;
 *     If the formatter's {@link #getCalendar() Calendar} is the Gregorian
 *     calendar, the following rules are applied.&lt;br&gt;
 *     &lt;ul&gt;
 *     &lt;li&gt;For formatting, if the number of pattern letters is 2, the year
 *         is truncated to 2 digits; otherwise it is interpreted as a
 *         &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.
 *     &lt;li&gt;For parsing, if the number of pattern letters is more than 2,
 *         the year is interpreted literally, regardless of the number of
 *         digits. So using the pattern &quot;MM/dd/yyyy&quot;, &quot;01/11/12&quot; parses to
 *         Jan 11, 12 A.D.
 *     &lt;li&gt;For parsing with the abbreviated year pattern (&quot;y&quot; or &quot;yy&quot;),
 *         &lt;code&gt;SimpleDateFormat&lt;/code&gt; must interpret the abbreviated year
 *         relative to some century.  It does this by adjusting dates to be
 *         within 80 years before and 20 years after the time the &lt;code&gt;SimpleDateFormat&lt;/code&gt;
 *         instance is created. For example, using a pattern of &quot;MM/dd/yy&quot; and a
 *         &lt;code&gt;SimpleDateFormat&lt;/code&gt; instance created on Jan 1, 1997,  the string
 *         &quot;01/11/12&quot; would be interpreted as Jan 11, 2012 while the string &quot;05/04/64&quot;
 *         would be interpreted as May 4, 1964.
 *         During parsing, only strings consisting of exactly two digits, as defined by
 *         {@link Character#isDigit(char)}, will be parsed into the default century.
 *         Any other numeric string, such as a one digit string, a three or more digit
 *         string, or a two digit string that isn't all digits (for example, &quot;-1&quot;), is
 *         interpreted literally.  So &quot;01/02/3&quot; or &quot;01/02/003&quot; are parsed, using the
 *         same pattern, as Jan 2, 3 AD.  Likewise, &quot;01/02/-3&quot; is parsed as Jan 2, 4 BC.
 *     &lt;/ul&gt;
 *     Otherwise, calendar system specific forms are applied.
 *     For both formatting and parsing, if the number of pattern
 *     letters is 4 or more, a calendar specific {@linkplain
 *     Calendar#LONG long form} is used. Otherwise, a calendar
 *     specific {@linkplain Calendar#SHORT short or abbreviated form}
 *     is used.&lt;br&gt;
 *     &lt;br&gt;
 *     If week year {@code 'Y'} is specified and the {@linkplain
 *     #getCalendar() calendar} doesn't support any &lt;a
 *     href=&quot;../util/GregorianCalendar.html#week_year&quot;&gt; week
 *     years&lt;/a&gt;, the calendar year ({@code 'y'}) is used instead. The
 *     support of week years can be tested with a call to {@link
 *     DateFormat#getCalendar() getCalendar()}.{@link
 *     java.util.Calendar#isWeekDateSupported()
 *     isWeekDateSupported()}.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;month&quot;&gt;Month:&lt;/a&gt;&lt;/strong&gt;
 *     If the number of pattern letters is 3 or more, the month is
 *     interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;; otherwise,
 *     it is interpreted as a &lt;a href=&quot;#number&quot;&gt;number&lt;/a&gt;.&lt;br&gt;
 *     &lt;ul&gt;
 *     &lt;li&gt;Letter &lt;em&gt;M&lt;/em&gt; produces context-sensitive month names, such as the
 *         embedded form of names. If a {@code DateFormatSymbols} has been set
 *         explicitly with constructor {@link #SimpleDateFormat(String,
 *         DateFormatSymbols)} or method {@link
 *         #setDateFormatSymbols(DateFormatSymbols)}, the month names given by
 *         the {@code DateFormatSymbols} are used.&lt;/li&gt;
 *     &lt;li&gt;Letter &lt;em&gt;L&lt;/em&gt; produces the standalone form of month names.&lt;/li&gt;
 *     &lt;/ul&gt;
 *     &lt;br&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;timezone&quot;&gt;General time zone:&lt;/a&gt;&lt;/strong&gt;
 *     Time zones are interpreted as &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; if they have
 *     names. For time zones representing a GMT offset value, the
 *     following syntax is used:
 *     &lt;pre&gt;
 *     &lt;a name=&quot;GMTOffsetTimeZone&quot;&gt;&lt;i&gt;GMTOffsetTimeZone:&lt;/i&gt;&lt;/a&gt;
 *             &lt;code&gt;GMT&lt;/code&gt; &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;Hours&lt;/i&gt; &lt;code&gt;:&lt;/code&gt; &lt;i&gt;Minutes&lt;/i&gt;
 *     &lt;i&gt;Sign:&lt;/i&gt; one of
 *             &lt;code&gt;+ -&lt;/code&gt;
 *     &lt;i&gt;Hours:&lt;/i&gt;
 *             &lt;i&gt;Digit&lt;/i&gt;
 *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 *     &lt;i&gt;Minutes:&lt;/i&gt;
 *             &lt;i&gt;Digit&lt;/i&gt; &lt;i&gt;Digit&lt;/i&gt;
 *     &lt;i&gt;Digit:&lt;/i&gt; one of
 *             &lt;code&gt;0 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
 *     &lt;i&gt;Hours&lt;/i&gt; must be between 0 and 23, and &lt;i&gt;Minutes&lt;/i&gt; must be between
 *     00 and 59. The format is locale independent and digits must be taken
 *     from the Basic Latin block of the Unicode standard.
 *     &lt;p&gt;For parsing, &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt; are also
 *     accepted.&lt;br&gt;&lt;br&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;rfc822timezone&quot;&gt;RFC 822 time zone:&lt;/a&gt;&lt;/strong&gt;
 *     For formatting, the RFC 822 4-digit time zone format is used:
 *
 *     &lt;pre&gt;
 *     &lt;i&gt;RFC822TimeZone:&lt;/i&gt;
 *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
 *     &lt;i&gt;TwoDigitHours:&lt;/i&gt;
 *             &lt;i&gt;Digit Digit&lt;/i&gt;&lt;/pre&gt;
 *     &lt;i&gt;TwoDigitHours&lt;/i&gt; must be between 00 and 23. Other definitions
 *     are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt;.
 *
 *     &lt;p&gt;For parsing, &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; are also
 *     accepted.
 * &lt;li&gt;&lt;strong&gt;&lt;a name=&quot;iso8601timezone&quot;&gt;ISO 8601 Time zone:&lt;/a&gt;&lt;/strong&gt;
 *     The number of pattern letters designates the format for both formatting
 *     and parsing as follows:
 *     &lt;pre&gt;
 *     &lt;i&gt;ISO8601TimeZone:&lt;/i&gt;
 *             &lt;i&gt;OneLetterISO8601TimeZone&lt;/i&gt;
 *             &lt;i&gt;TwoLetterISO8601TimeZone&lt;/i&gt;
 *             &lt;i&gt;ThreeLetterISO8601TimeZone&lt;/i&gt;
 *     &lt;i&gt;OneLetterISO8601TimeZone:&lt;/i&gt;
 *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt;
 *             {@code Z}
 *     &lt;i&gt;TwoLetterISO8601TimeZone:&lt;/i&gt;
 *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; &lt;i&gt;Minutes&lt;/i&gt;
 *             {@code Z}
 *     &lt;i&gt;ThreeLetterISO8601TimeZone:&lt;/i&gt;
 *             &lt;i&gt;Sign&lt;/i&gt; &lt;i&gt;TwoDigitHours&lt;/i&gt; {@code :} &lt;i&gt;Minutes&lt;/i&gt;
 *             {@code Z}&lt;/pre&gt;
 *     Other definitions are as for &lt;a href=&quot;#timezone&quot;&gt;general time zones&lt;/a&gt; or
 *     &lt;a href=&quot;#rfc822timezone&quot;&gt;RFC 822 time zones&lt;/a&gt;.
 *
 *     &lt;p&gt;For formatting, if the offset value from GMT is 0, {@code &quot;Z&quot;} is
 *     produced. If the number of pattern letters is 1, any fraction of an hour
 *     is ignored. For example, if the pattern is {@code &quot;X&quot;} and the time zone is
 *     {@code &quot;GMT+05:30&quot;}, {@code &quot;+05&quot;} is produced.
 *
 *     &lt;p&gt;For parsing, {@code &quot;Z&quot;} is parsed as the UTC time zone designator.
 *     &lt;a href=&quot;#timezone&quot;&gt;General time zones&lt;/a&gt; are &lt;em&gt;not&lt;/em&gt; accepted.
 *
 *     &lt;p&gt;If the number of pattern letters is 4 or more, {@link
 *     IllegalArgumentException} is thrown when constructing a {@code
 *     SimpleDateFormat} or {@linkplain #applyPattern(String) applying a
 *     pattern}.
 * &lt;/ul&gt;
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; also supports &lt;em&gt;localized date and time
 * pattern&lt;/em&gt; strings. In these strings, the pattern letters described above
 * may be replaced with other, locale dependent, pattern letters.
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; does not deal with the localization of text
 * other than the pattern letters; that's up to the client of the class.
 *
 * &lt;h4&gt;Examples&lt;/h4&gt;
 *
 * The following examples show how date and time patterns are interpreted in
 * the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
 * in the U.S. Pacific Time time zone.
 * &lt;blockquote&gt;
 * &lt;table border=0 cellspacing=3 cellpadding=0 summary=&quot;Examples of date and time patterns interpreted in the U.S. locale&quot;&gt;
 *     &lt;tr style=&quot;background-color: rgb(204, 204, 255);&quot;&gt;
 *         &lt;th align=left&gt;Date and Time Pattern
 *         &lt;th align=left&gt;Result
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;yyyy.MM.dd G 'at' HH:mm:ss z&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;2001.07.04 AD at 12:08:56 PDT&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;EEE, MMM d, ''yy&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;Wed, Jul 4, '01&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;h:mm a&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;12:08 PM&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;hh 'o''clock' a, zzzz&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;12 o'clock PM, Pacific Daylight Time&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;K:mm a, z&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;0:08 PM, PDT&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;02001.July.04 AD 12:08 PM&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;Wed, 4 Jul 2001 12:08:56 -0700&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;yyMMddHHmmssZ&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;010704120856-0700&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-0700&lt;/code&gt;
 *     &lt;tr style=&quot;background-color: rgb(238, 238, 255);&quot;&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;2001-07-04T12:08:56.235-07:00&lt;/code&gt;
 *     &lt;tr&gt;
 *         &lt;td&gt;&lt;code&gt;&quot;YYYY-'W'ww-u&quot;&lt;/code&gt;
 *         &lt;td&gt;&lt;code&gt;2001-W27-3&lt;/code&gt;
 * &lt;/table&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;h4&gt;&lt;a name=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
 *
 * &lt;p&gt;
 * Date formats are not synchronized.
 * It is recommended to create separate format instances for each thread.
 * If multiple threads access a format concurrently, it must be synchronized
 * externally.
 *
 * @see          &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;
 * @see          java.util.Calendar
 * @see          java.util.TimeZone
 * @see          DateFormat
 * @see          DateFormatSymbols
 * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
 */
<span class="fc bfc" id="L421" title="All 2 branches covered.">public class SimpleDateFormat extends DateFormat {</span>

    // the official serial version ID which says cryptically
    // which version we're compatible with
    static final long serialVersionUID = 4774881970558875024L;

    // the internal serial version which says which version was written
    // - 0 (default) for version up to JDK 1.1.3
    // - 1 for version from JDK 1.1.4, which includes a new field
    static final int currentSerialVersion = 1;

    /**
     * The version of the serialized data on the stream.  Possible values:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream: JDK 1.1.3.  This version
     * has no &lt;code&gt;defaultCenturyStart&lt;/code&gt; on stream.
     * &lt;li&gt;&lt;b&gt;1&lt;/b&gt; JDK 1.1.4 or later.  This version adds
     * &lt;code&gt;defaultCenturyStart&lt;/code&gt;.
     * &lt;/ul&gt;
     * When streaming out this class, the most recent format
     * and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
     * is written.
     * @serial
     * @since JDK1.1.4
     */
<span class="fc" id="L446">    private int serialVersionOnStream = currentSerialVersion;</span>

    /**
     * The pattern string of this formatter.  This is always a non-localized
     * pattern.  May not be null.  See class documentation for details.
     * @serial
     */
    private String pattern;

    /**
     * Saved numberFormat and pattern.
     * @see SimpleDateFormat#checkNegativeNumberExpression
     */
    transient private NumberFormat originalNumberFormat;
    transient private String originalNumberPattern;

    /**
     * The minus sign to be used with format and parse.
     */
<span class="fc" id="L465">    transient private char minusSign = '-';</span>

    /**
     * True when a negative sign follows a number.
     * (True as default in Arabic.)
     */
<span class="fc" id="L471">    transient private boolean hasFollowingMinusSign = false;</span>

    /**
     * True if standalone form needs to be used.
     */
<span class="fc" id="L476">    transient private boolean forceStandaloneForm = false;</span>

    /**
     * The compiled pattern.
     */
    transient private char[] compiledPattern;

    /**
     * Tags for the compiled pattern.
     */
    private final static int TAG_QUOTE_ASCII_CHAR       = 100;
    private final static int TAG_QUOTE_CHARS            = 101;

    /**
     * Locale dependent digit zero.
     * @see #zeroPaddingNumber
     * @see java.text.DecimalFormatSymbols#getZeroDigit
     */
    transient private char zeroDigit;

    /**
     * The symbols used by this formatter for week names, month names,
     * etc.  May not be null.
     * @serial
     * @see java.text.DateFormatSymbols
     */
    private DateFormatSymbols formatData;

    /**
     * We map dates with two-digit years into the century starting at
     * &lt;code&gt;defaultCenturyStart&lt;/code&gt;, which may be any date.  May
     * not be null.
     * @serial
     * @since JDK1.1.4
     */
    private Date defaultCenturyStart;

    transient private int defaultCenturyStartYear;

    private static final int MILLIS_PER_MINUTE = 60 * 1000;

    // For time zones that have no names, use strings GMT+minutes and
    // GMT-minutes. For instance, in France the time zone is GMT+60.
    private static final String GMT = &quot;GMT&quot;;

    /**
     * Cache NumberFormat instances with Locale key.
     */
<span class="fc" id="L524">    private static final ConcurrentMap&lt;Locale, NumberFormat&gt; cachedNumberFormatData</span>
        = new ConcurrentHashMap&lt;&gt;(3);

    /**
     * The Locale used to instantiate this
     * &lt;code&gt;SimpleDateFormat&lt;/code&gt;. The value may be null if this object
     * has been created by an older &lt;code&gt;SimpleDateFormat&lt;/code&gt; and
     * deserialized.
     *
     * @serial
     * @since 1.6
     */
    private Locale locale;

    /**
     * Indicates whether this &lt;code&gt;SimpleDateFormat&lt;/code&gt; should use
     * the DateFormatSymbols. If true, the format and parse methods
     * use the DateFormatSymbols values. If false, the format and
     * parse methods call Calendar.getDisplayName or
     * Calendar.getDisplayNames.
     */
    transient boolean useDateFormatSymbols;

    /**
     * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the default pattern and
     * date format symbols for the default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
     * For full coverage, use the factory methods in the {@link DateFormat}
     * class.
     */
    public SimpleDateFormat() {
<span class="fc" id="L556">        this(&quot;&quot;, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L557">        applyPatternImpl(LocaleProviderAdapter.getResourceBundleBased().getLocaleResources(locale)</span>
<span class="fc" id="L558">                         .getDateTimePattern(SHORT, SHORT, calendar));</span>
<span class="fc" id="L559">    }</span>

    /**
     * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
     * the default date format symbols for the default
     * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
     * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
     * For full coverage, use the factory methods in the {@link DateFormat}
     * class.
     * &lt;p&gt;This is equivalent to calling
     * {@link #SimpleDateFormat(String, Locale)
     *     SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))}.
     *
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     * @param pattern the pattern describing the date and time format
     * @exception NullPointerException if the given pattern is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    public SimpleDateFormat(String pattern)
    {
<span class="fc" id="L580">        this(pattern, Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="fc" id="L581">    }</span>

    /**
     * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
     * the default date format symbols for the given locale.
     * &lt;b&gt;Note:&lt;/b&gt; This constructor may not support all locales.
     * For full coverage, use the factory methods in the {@link DateFormat}
     * class.
     *
     * @param pattern the pattern describing the date and time format
     * @param locale the locale whose date format symbols should be used
     * @exception NullPointerException if the given pattern or locale is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    public SimpleDateFormat(String pattern, Locale locale)
<span class="fc" id="L596">    {</span>
<span class="pc bpc" id="L597" title="2 of 4 branches missed.">        if (pattern == null || locale == null) {</span>
<span class="nc" id="L598">            throw new NullPointerException();</span>
        }

<span class="fc" id="L601">        initializeCalendar(locale);</span>
<span class="fc" id="L602">        this.pattern = pattern;</span>
<span class="fc" id="L603">        this.formatData = DateFormatSymbols.getInstanceRef(locale);</span>
<span class="fc" id="L604">        this.locale = locale;</span>
<span class="fc" id="L605">        initialize(locale);</span>
<span class="fc" id="L606">    }</span>

    /**
     * Constructs a &lt;code&gt;SimpleDateFormat&lt;/code&gt; using the given pattern and
     * date format symbols.
     *
     * @param pattern the pattern describing the date and time format
     * @param formatSymbols the date format symbols to be used for formatting
     * @exception NullPointerException if the given pattern or formatSymbols is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols)
<span class="fc" id="L618">    {</span>
<span class="pc bpc" id="L619" title="2 of 4 branches missed.">        if (pattern == null || formatSymbols == null) {</span>
<span class="nc" id="L620">            throw new NullPointerException();</span>
        }

<span class="fc" id="L623">        this.pattern = pattern;</span>
<span class="fc" id="L624">        this.formatData = (DateFormatSymbols) formatSymbols.clone();</span>
<span class="fc" id="L625">        this.locale = Locale.getDefault(Locale.Category.FORMAT);</span>
<span class="fc" id="L626">        initializeCalendar(this.locale);</span>
<span class="fc" id="L627">        initialize(this.locale);</span>
<span class="fc" id="L628">        useDateFormatSymbols = true;</span>
<span class="fc" id="L629">    }</span>

    /* Initialize compiledPattern and numberFormat fields */
    private void initialize(Locale loc) {
        // Verify and compile the given pattern.
<span class="fc" id="L634">        compiledPattern = compile(pattern);</span>

        /* try the cache first */
<span class="fc" id="L637">        numberFormat = cachedNumberFormatData.get(loc);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (numberFormat == null) { /* cache miss */</span>
<span class="fc" id="L639">            numberFormat = NumberFormat.getIntegerInstance(loc);</span>
<span class="fc" id="L640">            numberFormat.setGroupingUsed(false);</span>

            /* update cache */
<span class="fc" id="L643">            cachedNumberFormatData.putIfAbsent(loc, numberFormat);</span>
        }
<span class="fc" id="L645">        numberFormat = (NumberFormat) numberFormat.clone();</span>

<span class="fc" id="L647">        initializeDefaultCentury();</span>
<span class="fc" id="L648">    }</span>

    private void initializeCalendar(Locale loc) {
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">        if (calendar == null) {</span>
<span class="pc bpc" id="L652" title="1 of 4 branches missed.">            assert loc != null;</span>
            // The format object must be constructed using the symbols for this zone.
            // However, the calendar should use the current default TimeZone.
            // If this is not contained in the locale zone strings, then the zone
            // will be formatted using generic GMT+/-H:MM nomenclature.
<span class="fc" id="L657">            calendar = Calendar.getInstance(TimeZone.getDefault(), loc);</span>
        }
<span class="fc" id="L659">    }</span>

    /**
     * Returns the compiled form of the given pattern. The syntax of
     * the compiled pattern is:
     * &lt;blockquote&gt;
     * CompiledPattern:
     *     EntryList
     * EntryList:
     *     Entry
     *     EntryList Entry
     * Entry:
     *     TagField
     *     TagField data
     * TagField:
     *     Tag Length
     *     TaggedData
     * Tag:
     *     pattern_char_index
     *     TAG_QUOTE_CHARS
     * Length:
     *     short_length
     *     long_length
     * TaggedData:
     *     TAG_QUOTE_ASCII_CHAR ascii_char
     *
     * &lt;/blockquote&gt;
     *
     * where `short_length' is an 8-bit unsigned integer between 0 and
     * 254.  `long_length' is a sequence of an 8-bit integer 255 and a
     * 32-bit signed integer value which is split into upper and lower
     * 16-bit fields in two char's. `pattern_char_index' is an 8-bit
     * integer between 0 and 18. `ascii_char' is an 7-bit ASCII
     * character value. `data' depends on its Tag value.
     * &lt;p&gt;
     * If Length is short_length, Tag and short_length are packed in a
     * single char, as illustrated below.
     * &lt;blockquote&gt;
     *     char[0] = (Tag &lt;&lt; 8) | short_length;
     * &lt;/blockquote&gt;
     *
     * If Length is long_length, Tag and 255 are packed in the first
     * char and a 32-bit integer, as illustrated below.
     * &lt;blockquote&gt;
     *     char[0] = (Tag &lt;&lt; 8) | 255;
     *     char[1] = (char) (long_length &gt;&gt;&gt; 16);
     *     char[2] = (char) (long_length &amp; 0xffff);
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * If Tag is a pattern_char_index, its Length is the number of
     * pattern characters. For example, if the given pattern is
     * &quot;yyyy&quot;, Tag is 1 and Length is 4, followed by no data.
     * &lt;p&gt;
     * If Tag is TAG_QUOTE_CHARS, its Length is the number of char's
     * following the TagField. For example, if the given pattern is
     * &quot;'o''clock'&quot;, Length is 7 followed by a char sequence of
     * &lt;code&gt;o&amp;nbs;'&amp;nbs;c&amp;nbs;l&amp;nbs;o&amp;nbs;c&amp;nbs;k&lt;/code&gt;.
     * &lt;p&gt;
     * TAG_QUOTE_ASCII_CHAR is a special tag and has an ASCII
     * character in place of Length. For example, if the given pattern
     * is &quot;'o'&quot;, the TaggedData entry is
     * &lt;code&gt;((TAG_QUOTE_ASCII_CHAR&amp;nbs;&lt;&lt;&amp;nbs;8)&amp;nbs;|&amp;nbs;'o')&lt;/code&gt;.
     *
     * @exception NullPointerException if the given pattern is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    private char[] compile(String pattern) {
<span class="fc" id="L726">        int length = pattern.length();</span>
<span class="fc" id="L727">        boolean inQuote = false;</span>
<span class="fc" id="L728">        StringBuilder compiledCode = new StringBuilder(length * 2);</span>
<span class="fc" id="L729">        StringBuilder tmpBuffer = null;</span>
<span class="fc" id="L730">        int count = 0, tagcount = 0;</span>
<span class="fc" id="L731">        int lastTag = -1, prevTag = -1;</span>

<span class="fc bfc" id="L733" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L734">            char c = pattern.charAt(i);</span>

<span class="fc bfc" id="L736" title="All 2 branches covered.">            if (c == '\'') {</span>
                // '' is treated as a single quote regardless of being
                // in a quoted section.
<span class="fc bfc" id="L739" title="All 2 branches covered.">                if ((i + 1) &lt; length) {</span>
<span class="fc" id="L740">                    c = pattern.charAt(i + 1);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">                    if (c == '\'') {</span>
<span class="fc" id="L742">                        i++;</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">                        if (count != 0) {</span>
<span class="fc" id="L744">                            encode(lastTag, count, compiledCode);</span>
<span class="fc" id="L745">                            tagcount++;</span>
<span class="fc" id="L746">                            prevTag = lastTag;</span>
<span class="fc" id="L747">                            lastTag = -1;</span>
<span class="fc" id="L748">                            count = 0;</span>
                        }
<span class="fc bfc" id="L750" title="All 2 branches covered.">                        if (inQuote) {</span>
<span class="fc" id="L751">                            tmpBuffer.append(c);</span>
                        } else {
<span class="fc" id="L753">                            compiledCode.append((char)(TAG_QUOTE_ASCII_CHAR &lt;&lt; 8 | c));</span>
                        }
<span class="fc" id="L755">                        continue;</span>
                    }
                }
<span class="fc bfc" id="L758" title="All 2 branches covered.">                if (!inQuote) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">                    if (count != 0) {</span>
<span class="fc" id="L760">                        encode(lastTag, count, compiledCode);</span>
<span class="fc" id="L761">                        tagcount++;</span>
<span class="fc" id="L762">                        prevTag = lastTag;</span>
<span class="fc" id="L763">                        lastTag = -1;</span>
<span class="fc" id="L764">                        count = 0;</span>
                    }
<span class="fc bfc" id="L766" title="All 2 branches covered.">                    if (tmpBuffer == null) {</span>
<span class="fc" id="L767">                        tmpBuffer = new StringBuilder(length);</span>
                    } else {
<span class="fc" id="L769">                        tmpBuffer.setLength(0);</span>
                    }
<span class="fc" id="L771">                    inQuote = true;</span>
                } else {
<span class="fc" id="L773">                    int len = tmpBuffer.length();</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">                    if (len == 1) {</span>
<span class="fc" id="L775">                        char ch = tmpBuffer.charAt(0);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">                        if (ch &lt; 128) {</span>
<span class="fc" id="L777">                            compiledCode.append((char)(TAG_QUOTE_ASCII_CHAR &lt;&lt; 8 | ch));</span>
                        } else {
<span class="fc" id="L779">                            compiledCode.append((char)(TAG_QUOTE_CHARS &lt;&lt; 8 | 1));</span>
<span class="fc" id="L780">                            compiledCode.append(ch);</span>
                        }
<span class="fc" id="L782">                    } else {</span>
<span class="fc" id="L783">                        encode(TAG_QUOTE_CHARS, len, compiledCode);</span>
<span class="fc" id="L784">                        compiledCode.append(tmpBuffer);</span>
                    }
<span class="fc" id="L786">                    inQuote = false;</span>
                }
<span class="fc" id="L788">                continue;</span>
            }
<span class="fc bfc" id="L790" title="All 2 branches covered.">            if (inQuote) {</span>
<span class="fc" id="L791">                tmpBuffer.append(c);</span>
<span class="fc" id="L792">                continue;</span>
            }
<span class="fc bfc" id="L794" title="All 8 branches covered.">            if (!(c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z')) {</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                if (count != 0) {</span>
<span class="fc" id="L796">                    encode(lastTag, count, compiledCode);</span>
<span class="fc" id="L797">                    tagcount++;</span>
<span class="fc" id="L798">                    prevTag = lastTag;</span>
<span class="fc" id="L799">                    lastTag = -1;</span>
<span class="fc" id="L800">                    count = 0;</span>
                }
<span class="fc bfc" id="L802" title="All 2 branches covered.">                if (c &lt; 128) {</span>
                    // In most cases, c would be a delimiter, such as ':'.
<span class="fc" id="L804">                    compiledCode.append((char)(TAG_QUOTE_ASCII_CHAR &lt;&lt; 8 | c));</span>
                } else {
                    // Take any contiguous non-ASCII alphabet characters and
                    // put them in a single TAG_QUOTE_CHARS.
                    int j;
<span class="fc bfc" id="L809" title="All 2 branches covered.">                    for (j = i + 1; j &lt; length; j++) {</span>
<span class="fc" id="L810">                        char d = pattern.charAt(j);</span>
<span class="pc bpc" id="L811" title="1 of 10 branches missed.">                        if (d == '\'' || (d &gt;= 'a' &amp;&amp; d &lt;= 'z' || d &gt;= 'A' &amp;&amp; d &lt;= 'Z')) {</span>
<span class="fc" id="L812">                            break;</span>
                        }
                    }
<span class="fc" id="L815">                    compiledCode.append((char)(TAG_QUOTE_CHARS &lt;&lt; 8 | (j - i)));</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">                    for (; i &lt; j; i++) {</span>
<span class="fc" id="L817">                        compiledCode.append(pattern.charAt(i));</span>
                    }
<span class="fc" id="L819">                    i--;</span>
                }
<span class="fc" id="L821">                continue;</span>
            }

            int tag;
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">            if ((tag = DateFormatSymbols.patternChars.indexOf(c)) == -1) {</span>
<span class="nc" id="L826">                throw new IllegalArgumentException(&quot;Illegal pattern character &quot; +</span>
                                                   &quot;'&quot; + c + &quot;'&quot;);
            }
<span class="fc bfc" id="L829" title="All 4 branches covered.">            if (lastTag == -1 || lastTag == tag) {</span>
<span class="fc" id="L830">                lastTag = tag;</span>
<span class="fc" id="L831">                count++;</span>
<span class="fc" id="L832">                continue;</span>
            }
<span class="fc" id="L834">            encode(lastTag, count, compiledCode);</span>
<span class="fc" id="L835">            tagcount++;</span>
<span class="fc" id="L836">            prevTag = lastTag;</span>
<span class="fc" id="L837">            lastTag = tag;</span>
<span class="fc" id="L838">            count = 1;</span>
        }

<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if (inQuote) {</span>
<span class="nc" id="L842">            throw new IllegalArgumentException(&quot;Unterminated quote&quot;);</span>
        }

<span class="fc bfc" id="L845" title="All 2 branches covered.">        if (count != 0) {</span>
<span class="fc" id="L846">            encode(lastTag, count, compiledCode);</span>
<span class="fc" id="L847">            tagcount++;</span>
<span class="fc" id="L848">            prevTag = lastTag;</span>
        }

<span class="fc bfc" id="L851" title="All 4 branches covered.">        forceStandaloneForm = (tagcount == 1 &amp;&amp; prevTag == PATTERN_MONTH);</span>

        // Copy the compiled pattern to a char array
<span class="fc" id="L854">        int len = compiledCode.length();</span>
<span class="fc" id="L855">        char[] r = new char[len];</span>
<span class="fc" id="L856">        compiledCode.getChars(0, len, r, 0);</span>
<span class="fc" id="L857">        return r;</span>
    }

    /**
     * Encodes the given tag and length and puts encoded char(s) into buffer.
     */
    private static void encode(int tag, int length, StringBuilder buffer) {
<span class="pc bpc" id="L864" title="3 of 4 branches missed.">        if (tag == PATTERN_ISO_ZONE &amp;&amp; length &gt;= 4) {</span>
<span class="nc" id="L865">            throw new IllegalArgumentException(&quot;invalid ISO 8601 format: length=&quot; + length);</span>
        }
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">        if (length &lt; 255) {</span>
<span class="fc" id="L868">            buffer.append((char)(tag &lt;&lt; 8 | length));</span>
        } else {
<span class="nc" id="L870">            buffer.append((char)((tag &lt;&lt; 8) | 0xff));</span>
<span class="nc" id="L871">            buffer.append((char)(length &gt;&gt;&gt; 16));</span>
<span class="nc" id="L872">            buffer.append((char)(length &amp; 0xffff));</span>
        }
<span class="fc" id="L874">    }</span>

    /* Initialize the fields we use to disambiguate ambiguous years. Separate
     * so we can call it from readObject().
     */
    private void initializeDefaultCentury() {
<span class="fc" id="L880">        calendar.setTimeInMillis(System.currentTimeMillis());</span>
<span class="fc" id="L881">        calendar.add( Calendar.YEAR, -80 );</span>
<span class="fc" id="L882">        parseAmbiguousDatesAsAfter(calendar.getTime());</span>
<span class="fc" id="L883">    }</span>

    /* Define one-century window into which to disambiguate dates using
     * two-digit years.
     */
    private void parseAmbiguousDatesAsAfter(Date startDate) {
<span class="fc" id="L889">        defaultCenturyStart = startDate;</span>
<span class="fc" id="L890">        calendar.setTime(startDate);</span>
<span class="fc" id="L891">        defaultCenturyStartYear = calendar.get(Calendar.YEAR);</span>
<span class="fc" id="L892">    }</span>

    /**
     * Sets the 100-year period 2-digit years will be interpreted as being in
     * to begin on the date the user specifies.
     *
     * @param startDate During parsing, two digit years will be placed in the range
     * &lt;code&gt;startDate&lt;/code&gt; to &lt;code&gt;startDate + 100 years&lt;/code&gt;.
     * @see #get2DigitYearStart
     * @since 1.2
     */
    public void set2DigitYearStart(Date startDate) {
<span class="fc" id="L904">        parseAmbiguousDatesAsAfter(new Date(startDate.getTime()));</span>
<span class="fc" id="L905">    }</span>

    /**
     * Returns the beginning date of the 100-year period 2-digit years are interpreted
     * as being within.
     *
     * @return the start of the 100-year period into which two digit years are
     * parsed
     * @see #set2DigitYearStart
     * @since 1.2
     */
    public Date get2DigitYearStart() {
<span class="nc" id="L917">        return (Date) defaultCenturyStart.clone();</span>
    }

    /**
     * Formats the given &lt;code&gt;Date&lt;/code&gt; into a date/time string and appends
     * the result to the given &lt;code&gt;StringBuffer&lt;/code&gt;.
     *
     * @param date the date-time value to be formatted into a date-time string.
     * @param toAppendTo where the new date-time text is to be appended.
     * @param pos the formatting position. On input: an alignment field,
     * if desired. On output: the offsets of the alignment field.
     * @return the formatted date-time string.
     * @exception NullPointerException if the given {@code date} is {@code null}.
     */
    @Override
    public StringBuffer format(Date date, StringBuffer toAppendTo,
                               FieldPosition pos)
    {
<span class="fc" id="L935">        pos.beginIndex = pos.endIndex = 0;</span>
<span class="fc" id="L936">        return format(date, toAppendTo, pos.getFieldDelegate());</span>
    }

    // Called from Format after creating a FieldDelegate
    private StringBuffer format(Date date, StringBuffer toAppendTo,
                                FieldDelegate delegate) {
        // Convert input date to time field list
<span class="fc" id="L943">        calendar.setTime(date);</span>

<span class="fc" id="L945">        boolean useDateFormatSymbols = useDateFormatSymbols();</span>

<span class="fc bfc" id="L947" title="All 2 branches covered.">        for (int i = 0; i &lt; compiledPattern.length; ) {</span>
<span class="fc" id="L948">            int tag = compiledPattern[i] &gt;&gt;&gt; 8;</span>
<span class="fc" id="L949">            int count = compiledPattern[i++] &amp; 0xff;</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">            if (count == 255) {</span>
<span class="nc" id="L951">                count = compiledPattern[i++] &lt;&lt; 16;</span>
<span class="nc" id="L952">                count |= compiledPattern[i++];</span>
            }

<span class="fc bfc" id="L955" title="All 3 branches covered.">            switch (tag) {</span>
            case TAG_QUOTE_ASCII_CHAR:
<span class="fc" id="L957">                toAppendTo.append((char)count);</span>
<span class="fc" id="L958">                break;</span>

            case TAG_QUOTE_CHARS:
<span class="fc" id="L961">                toAppendTo.append(compiledPattern, i, count);</span>
<span class="fc" id="L962">                i += count;</span>
<span class="fc" id="L963">                break;</span>

            default:
<span class="fc" id="L966">                subFormat(tag, count, delegate, toAppendTo, useDateFormatSymbols);</span>
                break;
            }
<span class="fc" id="L969">        }</span>
<span class="fc" id="L970">        return toAppendTo;</span>
    }

    /**
     * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
     * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
     * to build the resulting String, as well as to determine information
     * about the resulting String.
     * &lt;p&gt;
     * Each attribute key of the AttributedCharacterIterator will be of type
     * &lt;code&gt;DateFormat.Field&lt;/code&gt;, with the corresponding attribute value
     * being the same as the attribute key.
     *
     * @exception NullPointerException if obj is null.
     * @exception IllegalArgumentException if the Format cannot format the
     *            given object, or if the Format's pattern string is invalid.
     * @param obj The object to format
     * @return AttributedCharacterIterator describing the formatted value.
     * @since 1.4
     */
    @Override
    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
<span class="nc" id="L992">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L993">        CharacterIteratorFieldDelegate delegate = new</span>
                         CharacterIteratorFieldDelegate();

<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (obj instanceof Date) {</span>
<span class="nc" id="L997">            format((Date)obj, sb, delegate);</span>
        }
<span class="nc bnc" id="L999" title="All 2 branches missed.">        else if (obj instanceof Number) {</span>
<span class="nc" id="L1000">            format(new Date(((Number)obj).longValue()), sb, delegate);</span>
        }
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        else if (obj == null) {</span>
<span class="nc" id="L1003">            throw new NullPointerException(</span>
                   &quot;formatToCharacterIterator must be passed non-null object&quot;);
        }
        else {
<span class="nc" id="L1007">            throw new IllegalArgumentException(</span>
                             &quot;Cannot format given Object as a Date&quot;);
        }
<span class="nc" id="L1010">        return delegate.getIterator(sb.toString());</span>
    }

    // Map index into pattern character string to Calendar field number
<span class="fc" id="L1014">    private static final int[] PATTERN_INDEX_TO_CALENDAR_FIELD = {</span>
        Calendar.ERA,
        Calendar.YEAR,
        Calendar.MONTH,
        Calendar.DATE,
        Calendar.HOUR_OF_DAY,
        Calendar.HOUR_OF_DAY,
        Calendar.MINUTE,
        Calendar.SECOND,
        Calendar.MILLISECOND,
        Calendar.DAY_OF_WEEK,
        Calendar.DAY_OF_YEAR,
        Calendar.DAY_OF_WEEK_IN_MONTH,
        Calendar.WEEK_OF_YEAR,
        Calendar.WEEK_OF_MONTH,
        Calendar.AM_PM,
        Calendar.HOUR,
        Calendar.HOUR,
        Calendar.ZONE_OFFSET,
        Calendar.ZONE_OFFSET,
        CalendarBuilder.WEEK_YEAR,         // Pseudo Calendar field
        CalendarBuilder.ISO_DAY_OF_WEEK,   // Pseudo Calendar field
        Calendar.ZONE_OFFSET,
        Calendar.MONTH
    };

    // Map index into pattern character string to DateFormat field number
<span class="fc" id="L1041">    private static final int[] PATTERN_INDEX_TO_DATE_FORMAT_FIELD = {</span>
        DateFormat.ERA_FIELD,
        DateFormat.YEAR_FIELD,
        DateFormat.MONTH_FIELD,
        DateFormat.DATE_FIELD,
        DateFormat.HOUR_OF_DAY1_FIELD,
        DateFormat.HOUR_OF_DAY0_FIELD,
        DateFormat.MINUTE_FIELD,
        DateFormat.SECOND_FIELD,
        DateFormat.MILLISECOND_FIELD,
        DateFormat.DAY_OF_WEEK_FIELD,
        DateFormat.DAY_OF_YEAR_FIELD,
        DateFormat.DAY_OF_WEEK_IN_MONTH_FIELD,
        DateFormat.WEEK_OF_YEAR_FIELD,
        DateFormat.WEEK_OF_MONTH_FIELD,
        DateFormat.AM_PM_FIELD,
        DateFormat.HOUR1_FIELD,
        DateFormat.HOUR0_FIELD,
        DateFormat.TIMEZONE_FIELD,
        DateFormat.TIMEZONE_FIELD,
        DateFormat.YEAR_FIELD,
        DateFormat.DAY_OF_WEEK_FIELD,
        DateFormat.TIMEZONE_FIELD,
        DateFormat.MONTH_FIELD
    };

    // Maps from DecimalFormatSymbols index to Field constant
<span class="fc" id="L1068">    private static final Field[] PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID = {</span>
        Field.ERA,
        Field.YEAR,
        Field.MONTH,
        Field.DAY_OF_MONTH,
        Field.HOUR_OF_DAY1,
        Field.HOUR_OF_DAY0,
        Field.MINUTE,
        Field.SECOND,
        Field.MILLISECOND,
        Field.DAY_OF_WEEK,
        Field.DAY_OF_YEAR,
        Field.DAY_OF_WEEK_IN_MONTH,
        Field.WEEK_OF_YEAR,
        Field.WEEK_OF_MONTH,
        Field.AM_PM,
        Field.HOUR1,
        Field.HOUR0,
        Field.TIME_ZONE,
        Field.TIME_ZONE,
        Field.YEAR,
        Field.DAY_OF_WEEK,
        Field.TIME_ZONE,
        Field.MONTH
    };

    /**
     * Private member function that does the real date/time formatting.
     */
    private void subFormat(int patternCharIndex, int count,
                           FieldDelegate delegate, StringBuffer buffer,
                           boolean useDateFormatSymbols)
    {
<span class="fc" id="L1101">        int     maxIntCount = Integer.MAX_VALUE;</span>
<span class="fc" id="L1102">        String  current = null;</span>
<span class="fc" id="L1103">        int     beginOffset = buffer.length();</span>

<span class="fc" id="L1105">        int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];</span>
        int value;
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (field == CalendarBuilder.WEEK_YEAR) {</span>
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">            if (calendar.isWeekDateSupported()) {</span>
<span class="fc" id="L1109">                value = calendar.getWeekYear();</span>
            } else {
                // use calendar year 'y' instead
<span class="nc" id="L1112">                patternCharIndex = PATTERN_YEAR;</span>
<span class="nc" id="L1113">                field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];</span>
<span class="nc" id="L1114">                value = calendar.get(field);</span>
            }
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        } else if (field == CalendarBuilder.ISO_DAY_OF_WEEK) {</span>
<span class="fc" id="L1117">            value = CalendarBuilder.toISODayOfWeek(calendar.get(Calendar.DAY_OF_WEEK));</span>
        } else {
<span class="fc" id="L1119">            value = calendar.get(field);</span>
        }

<span class="fc bfc" id="L1122" title="All 2 branches covered.">        int style = (count &gt;= 4) ? Calendar.LONG : Calendar.SHORT;</span>
<span class="fc bfc" id="L1123" title="All 6 branches covered.">        if (!useDateFormatSymbols &amp;&amp; field &lt; Calendar.ZONE_OFFSET</span>
            &amp;&amp; patternCharIndex != PATTERN_MONTH_STANDALONE) {
<span class="fc" id="L1125">            current = calendar.getDisplayName(field, style, locale);</span>
        }

        // Note: zeroPaddingNumber() assumes that maxDigits is either
        // 2 or maxIntCount. If we make any changes to this,
        // zeroPaddingNumber() must be fixed.

<span class="pc bpc" id="L1132" title="3 of 12 branches missed.">        switch (patternCharIndex) {</span>
        case PATTERN_ERA: // 'G'
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">            if (useDateFormatSymbols) {</span>
<span class="nc" id="L1135">                String[] eras = formatData.getEras();</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                if (value &lt; eras.length) {</span>
<span class="nc" id="L1137">                    current = eras[value];</span>
                }
            }
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1141">                current = &quot;&quot;;</span>
            }
            break;

        case PATTERN_WEEK_YEAR: // 'Y'
        case PATTERN_YEAR:      // 'y'
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">            if (calendar instanceof GregorianCalendar) {</span>
<span class="fc bfc" id="L1148" title="All 2 branches covered.">                if (count != 2) {</span>
<span class="fc" id="L1149">                    zeroPaddingNumber(value, count, maxIntCount, buffer);</span>
                } else {
<span class="fc" id="L1151">                    zeroPaddingNumber(value, 2, 2, buffer);</span>
                } // clip 1996 to 96
            } else {
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                if (current == null) {</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                    zeroPaddingNumber(value, style == Calendar.LONG ? 1 : count,</span>
                                      maxIntCount, buffer);
                }
            }
            break;

        case PATTERN_MONTH:            // 'M' (context seinsive)
<span class="pc bpc" id="L1162" title="1 of 2 branches missed.">            if (useDateFormatSymbols) {</span>
                String[] months;
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                if (count &gt;= 4) {</span>
<span class="nc" id="L1165">                    months = formatData.getMonths();</span>
<span class="nc" id="L1166">                    current = months[value];</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                } else if (count == 3) {</span>
<span class="nc" id="L1168">                    months = formatData.getShortMonths();</span>
<span class="nc" id="L1169">                    current = months[value];</span>
                }
<span class="nc" id="L1171">            } else {</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">                if (count &lt; 3) {</span>
<span class="fc" id="L1173">                    current = null;</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">                } else if (forceStandaloneForm) {</span>
<span class="fc" id="L1175">                    current = calendar.getDisplayName(field, style | 0x8000, locale);</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">                    if (current == null) {</span>
<span class="nc" id="L1177">                        current = calendar.getDisplayName(field, style, locale);</span>
                    }
                }
            }
<span class="fc bfc" id="L1181" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L1182">                zeroPaddingNumber(value+1, count, maxIntCount, buffer);</span>
            }
            break;

        case PATTERN_MONTH_STANDALONE: // 'L'
<span class="pc bpc" id="L1187" title="2 of 4 branches missed.">            assert current == null;</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">            if (locale == null) {</span>
                String[] months;
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                if (count &gt;= 4) {</span>
<span class="nc" id="L1191">                    months = formatData.getMonths();</span>
<span class="nc" id="L1192">                    current = months[value];</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                } else if (count == 3) {</span>
<span class="nc" id="L1194">                    months = formatData.getShortMonths();</span>
<span class="nc" id="L1195">                    current = months[value];</span>
                }
<span class="nc" id="L1197">            } else {</span>
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">                if (count &gt;= 3) {</span>
<span class="fc" id="L1199">                    current = calendar.getDisplayName(field, style | 0x8000, locale);</span>
                }
            }
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1203">                zeroPaddingNumber(value+1, count, maxIntCount, buffer);</span>
            }
            break;

        case PATTERN_HOUR_OF_DAY1: // 'k' 1-based.  eg, 23:59 + 1 hour =&gt;&gt; 24:59
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                if (value == 0) {</span>
<span class="nc" id="L1210">                    zeroPaddingNumber(calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1,</span>
                                      count, maxIntCount, buffer);
                } else {
<span class="nc" id="L1213">                    zeroPaddingNumber(value, count, maxIntCount, buffer);</span>
                }
            }
            break;

        case PATTERN_DAY_OF_WEEK: // 'E'
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">            if (useDateFormatSymbols) {</span>
                String[] weekdays;
<span class="nc bnc" id="L1221" title="All 2 branches missed.">                if (count &gt;= 4) {</span>
<span class="nc" id="L1222">                    weekdays = formatData.getWeekdays();</span>
<span class="nc" id="L1223">                    current = weekdays[value];</span>
                } else { // count &lt; 4, use abbreviated form if exists
<span class="nc" id="L1225">                    weekdays = formatData.getShortWeekdays();</span>
<span class="nc" id="L1226">                    current = weekdays[value];</span>
                }
<span class="nc" id="L1228">            }</span>
            break;

        case PATTERN_AM_PM:    // 'a'
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">            if (useDateFormatSymbols) {</span>
<span class="nc" id="L1233">                String[] ampm = formatData.getAmPmStrings();</span>
<span class="nc" id="L1234">                current = ampm[value];</span>
<span class="nc" id="L1235">            }</span>
            break;

        case PATTERN_HOUR1:    // 'h' 1-based.  eg, 11PM + 1 hour =&gt;&gt; 12 AM
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">                if (value == 0) {</span>
<span class="nc" id="L1241">                    zeroPaddingNumber(calendar.getLeastMaximum(Calendar.HOUR) + 1,</span>
                                      count, maxIntCount, buffer);
                } else {
<span class="fc" id="L1244">                    zeroPaddingNumber(value, count, maxIntCount, buffer);</span>
                }
            }
            break;

        case PATTERN_ZONE_NAME: // 'z'
<span class="pc bpc" id="L1250" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="pc bpc" id="L1251" title="2 of 4 branches missed.">                if (formatData.locale == null || formatData.isZoneStringsSet) {</span>
<span class="nc" id="L1252">                    int zoneIndex =</span>
<span class="nc" id="L1253">                        formatData.getZoneIndex(calendar.getTimeZone().getID());</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                    if (zoneIndex == -1) {</span>
<span class="nc" id="L1255">                        value = calendar.get(Calendar.ZONE_OFFSET) +</span>
<span class="nc" id="L1256">                            calendar.get(Calendar.DST_OFFSET);</span>
<span class="nc" id="L1257">                        buffer.append(ZoneInfoFile.toCustomID(value));</span>
                    } else {
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                        int index = (calendar.get(Calendar.DST_OFFSET) == 0) ? 1: 3;</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                        if (count &lt; 4) {</span>
                            // Use the short name
<span class="nc" id="L1262">                            index++;</span>
                        }
<span class="nc" id="L1264">                        String[][] zoneStrings = formatData.getZoneStringsWrapper();</span>
<span class="nc" id="L1265">                        buffer.append(zoneStrings[zoneIndex][index]);</span>
                    }
<span class="nc" id="L1267">                } else {</span>
<span class="fc" id="L1268">                    TimeZone tz = calendar.getTimeZone();</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">                    boolean daylight = (calendar.get(Calendar.DST_OFFSET) != 0);</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">                    int tzstyle = (count &lt; 4 ? TimeZone.SHORT : TimeZone.LONG);</span>
<span class="fc" id="L1271">                    buffer.append(tz.getDisplayName(daylight, tzstyle, formatData.locale));</span>
<span class="fc" id="L1272">                }</span>
            }
            break;

        case PATTERN_ZONE_VALUE: // 'Z' (&quot;-/+hhmm&quot; form)
<span class="nc" id="L1277">            value = (calendar.get(Calendar.ZONE_OFFSET) +</span>
<span class="nc" id="L1278">                     calendar.get(Calendar.DST_OFFSET)) / 60000;</span>

<span class="nc" id="L1280">            int width = 4;</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">            if (value &gt;= 0) {</span>
<span class="nc" id="L1282">                buffer.append('+');</span>
            } else {
<span class="nc" id="L1284">                width++;</span>
            }

<span class="nc" id="L1287">            int num = (value / 60) * 100 + (value % 60);</span>
<span class="nc" id="L1288">            CalendarUtils.sprintf0d(buffer, num, width);</span>
<span class="nc" id="L1289">            break;</span>

        case PATTERN_ISO_ZONE:   // 'X'
<span class="nc" id="L1292">            value = calendar.get(Calendar.ZONE_OFFSET)</span>
<span class="nc" id="L1293">                    + calendar.get(Calendar.DST_OFFSET);</span>

<span class="nc bnc" id="L1295" title="All 2 branches missed.">            if (value == 0) {</span>
<span class="nc" id="L1296">                buffer.append('Z');</span>
<span class="nc" id="L1297">                break;</span>
            }

<span class="nc" id="L1300">            value /=  60000;</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">            if (value &gt;= 0) {</span>
<span class="nc" id="L1302">                buffer.append('+');</span>
            } else {
<span class="nc" id="L1304">                buffer.append('-');</span>
<span class="nc" id="L1305">                value = -value;</span>
            }

<span class="nc" id="L1308">            CalendarUtils.sprintf0d(buffer, value / 60, 2);</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">            if (count == 1) {</span>
<span class="nc" id="L1310">                break;</span>
            }

<span class="nc bnc" id="L1313" title="All 2 branches missed.">            if (count == 3) {</span>
<span class="nc" id="L1314">                buffer.append(':');</span>
            }
<span class="nc" id="L1316">            CalendarUtils.sprintf0d(buffer, value % 60, 2);</span>
<span class="nc" id="L1317">            break;</span>

        default:
     // case PATTERN_DAY_OF_MONTH:         // 'd'
     // case PATTERN_HOUR_OF_DAY0:         // 'H' 0-based.  eg, 23:59 + 1 hour =&gt;&gt; 00:59
     // case PATTERN_MINUTE:               // 'm'
     // case PATTERN_SECOND:               // 's'
     // case PATTERN_MILLISECOND:          // 'S'
     // case PATTERN_DAY_OF_YEAR:          // 'D'
     // case PATTERN_DAY_OF_WEEK_IN_MONTH: // 'F'
     // case PATTERN_WEEK_OF_YEAR:         // 'w'
     // case PATTERN_WEEK_OF_MONTH:        // 'W'
     // case PATTERN_HOUR0:                // 'K' eg, 11PM + 1 hour =&gt;&gt; 0 AM
     // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' pseudo field, Monday = 1, ..., Sunday = 7
<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">            if (current == null) {</span>
<span class="fc" id="L1332">                zeroPaddingNumber(value, count, maxIntCount, buffer);</span>
            }
            break;
        } // switch (patternCharIndex)

<span class="fc bfc" id="L1337" title="All 2 branches covered.">        if (current != null) {</span>
<span class="fc" id="L1338">            buffer.append(current);</span>
        }

<span class="fc" id="L1341">        int fieldID = PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex];</span>
<span class="fc" id="L1342">        Field f = PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID[patternCharIndex];</span>

<span class="fc" id="L1344">        delegate.formatted(fieldID, f, f, beginOffset, buffer.length(), buffer);</span>
<span class="fc" id="L1345">    }</span>

    /**
     * Formats a number with the specified minimum and maximum number of digits.
     */
    private void zeroPaddingNumber(int value, int minDigits, int maxDigits, StringBuffer buffer)
    {
        // Optimization for 1, 2 and 4 digit numbers. This should
        // cover most cases of formatting date/time related items.
        // Note: This optimization code assumes that maxDigits is
        // either 2 or Integer.MAX_VALUE (maxIntCount in format()).
        try {
<span class="fc bfc" id="L1357" title="All 2 branches covered.">            if (zeroDigit == 0) {</span>
<span class="fc" id="L1358">                zeroDigit = ((DecimalFormat)numberFormat).getDecimalFormatSymbols().getZeroDigit();</span>
            }
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">            if (value &gt;= 0) {</span>
<span class="pc bpc" id="L1361" title="1 of 6 branches missed.">                if (value &lt; 100 &amp;&amp; minDigits &gt;= 1 &amp;&amp; minDigits &lt;= 2) {</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">                    if (value &lt; 10) {</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">                        if (minDigits == 2) {</span>
<span class="fc" id="L1364">                            buffer.append(zeroDigit);</span>
                        }
<span class="fc" id="L1366">                        buffer.append((char)(zeroDigit + value));</span>
                    } else {
<span class="fc" id="L1368">                        buffer.append((char)(zeroDigit + value / 10));</span>
<span class="fc" id="L1369">                        buffer.append((char)(zeroDigit + value % 10));</span>
                    }
<span class="fc" id="L1371">                    return;</span>
<span class="fc bfc" id="L1372" title="All 4 branches covered.">                } else if (value &gt;= 1000 &amp;&amp; value &lt; 10000) {</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                    if (minDigits == 4) {</span>
<span class="fc" id="L1374">                        buffer.append((char)(zeroDigit + value / 1000));</span>
<span class="fc" id="L1375">                        value %= 1000;</span>
<span class="fc" id="L1376">                        buffer.append((char)(zeroDigit + value / 100));</span>
<span class="fc" id="L1377">                        value %= 100;</span>
<span class="fc" id="L1378">                        buffer.append((char)(zeroDigit + value / 10));</span>
<span class="fc" id="L1379">                        buffer.append((char)(zeroDigit + value % 10));</span>
<span class="fc" id="L1380">                        return;</span>
                    }
<span class="pc bpc" id="L1382" title="1 of 4 branches missed.">                    if (minDigits == 2 &amp;&amp; maxDigits == 2) {</span>
<span class="fc" id="L1383">                        zeroPaddingNumber(value % 100, 2, 2, buffer);</span>
<span class="fc" id="L1384">                        return;</span>
                    }
                }
            }
<span class="nc" id="L1388">        } catch (Exception e) {</span>
<span class="fc" id="L1389">        }</span>

<span class="fc" id="L1391">        numberFormat.setMinimumIntegerDigits(minDigits);</span>
<span class="fc" id="L1392">        numberFormat.setMaximumIntegerDigits(maxDigits);</span>
<span class="fc" id="L1393">        numberFormat.format((long)value, buffer, DontCareFieldPosition.INSTANCE);</span>
<span class="fc" id="L1394">    }</span>


    /**
     * Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
     * &lt;p&gt;
     * The method attempts to parse text starting at the index given by
     * &lt;code&gt;pos&lt;/code&gt;.
     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
     * to the index after the last character used (parsing does not necessarily
     * use all characters up to the end of the string), and the parsed
     * date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
     * indicate the starting point for the next call to this method.
     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
     * the character where the error occurred, and null is returned.
     *
     * &lt;p&gt;This parsing operation uses the {@link DateFormat#calendar
     * calendar} to produce a {@code Date}. All of the {@code
     * calendar}'s date-time fields are {@linkplain Calendar#clear()
     * cleared} before parsing, and the {@code calendar}'s default
     * values of the date-time fields are used for any missing
     * date-time information. For example, the year value of the
     * parsed {@code Date} is 1970 with {@link GregorianCalendar} if
     * no year value is given from the parsing operation.  The {@code
     * TimeZone} value may be overwritten, depending on the given
     * pattern and the time zone value in {@code text}. Any {@code
     * TimeZone} value that has previously been set by a call to
     * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
     * to be restored for further operations.
     *
     * @param text  A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
     * @param pos   A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
     *              index information as described above.
     * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
     *         error, returns null.
     * @exception NullPointerException if &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;pos&lt;/code&gt; is null.
     */
    @Override
    public Date parse(String text, ParsePosition pos)
    {
<span class="fc" id="L1435">        checkNegativeNumberExpression();</span>

<span class="fc" id="L1437">        int start = pos.index;</span>
<span class="fc" id="L1438">        int oldStart = start;</span>
<span class="fc" id="L1439">        int textLength = text.length();</span>

<span class="fc" id="L1441">        boolean[] ambiguousYear = {false};</span>

<span class="fc" id="L1443">        CalendarBuilder calb = new CalendarBuilder();</span>

<span class="fc bfc" id="L1445" title="All 2 branches covered.">        for (int i = 0; i &lt; compiledPattern.length; ) {</span>
<span class="fc" id="L1446">            int tag = compiledPattern[i] &gt;&gt;&gt; 8;</span>
<span class="fc" id="L1447">            int count = compiledPattern[i++] &amp; 0xff;</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">            if (count == 255) {</span>
<span class="nc" id="L1449">                count = compiledPattern[i++] &lt;&lt; 16;</span>
<span class="nc" id="L1450">                count |= compiledPattern[i++];</span>
            }

<span class="fc bfc" id="L1453" title="All 3 branches covered.">            switch (tag) {</span>
            case TAG_QUOTE_ASCII_CHAR:
<span class="fc bfc" id="L1455" title="All 4 branches covered.">                if (start &gt;= textLength || text.charAt(start) != (char)count) {</span>
<span class="fc" id="L1456">                    pos.index = oldStart;</span>
<span class="fc" id="L1457">                    pos.errorIndex = start;</span>
<span class="fc" id="L1458">                    return null;</span>
                }
<span class="fc" id="L1460">                start++;</span>
<span class="fc" id="L1461">                break;</span>

            case TAG_QUOTE_CHARS:
<span class="fc bfc" id="L1464" title="All 2 branches covered.">                while (count-- &gt; 0) {</span>
<span class="fc bfc" id="L1465" title="All 4 branches covered.">                    if (start &gt;= textLength || text.charAt(start) != compiledPattern[i++]) {</span>
<span class="fc" id="L1466">                        pos.index = oldStart;</span>
<span class="fc" id="L1467">                        pos.errorIndex = start;</span>
<span class="fc" id="L1468">                        return null;</span>
                    }
<span class="fc" id="L1470">                    start++;</span>
                }
                break;

            default:
                // Peek the next pattern to determine if we need to
                // obey the number of pattern letters for
                // parsing. It's required when parsing contiguous
                // digit text (e.g., &quot;20010704&quot;) with a pattern which
                // has no delimiters between fields, like &quot;yyyyMMdd&quot;.
<span class="fc" id="L1480">                boolean obeyCount = false;</span>

                // In Arabic, a minus sign for a negative number is put after
                // the number. Even in another locale, a minus sign can be
                // put after a number using DateFormat.setNumberFormat().
                // If both the minus sign and the field-delimiter are '-',
                // subParse() needs to determine whether a '-' after a number
                // in the given text is a delimiter or is a minus sign for the
                // preceding number. We give subParse() a clue based on the
                // information in compiledPattern.
<span class="fc" id="L1490">                boolean useFollowingMinusSignAsDelimiter = false;</span>

<span class="fc bfc" id="L1492" title="All 2 branches covered.">                if (i &lt; compiledPattern.length) {</span>
<span class="fc" id="L1493">                    int nextTag = compiledPattern[i] &gt;&gt;&gt; 8;</span>
<span class="pc bpc" id="L1494" title="1 of 4 branches missed.">                    if (!(nextTag == TAG_QUOTE_ASCII_CHAR ||</span>
                          nextTag == TAG_QUOTE_CHARS)) {
<span class="nc" id="L1496">                        obeyCount = true;</span>
                    }

<span class="pc bpc" id="L1499" title="1 of 6 branches missed.">                    if (hasFollowingMinusSign &amp;&amp;</span>
                        (nextTag == TAG_QUOTE_ASCII_CHAR ||
                         nextTag == TAG_QUOTE_CHARS)) {
                        int c;
<span class="fc bfc" id="L1503" title="All 2 branches covered.">                        if (nextTag == TAG_QUOTE_ASCII_CHAR) {</span>
<span class="fc" id="L1504">                            c = compiledPattern[i] &amp; 0xff;</span>
                        } else {
<span class="fc" id="L1506">                            c = compiledPattern[i+1];</span>
                        }

<span class="fc bfc" id="L1509" title="All 2 branches covered.">                        if (c == minusSign) {</span>
<span class="fc" id="L1510">                            useFollowingMinusSignAsDelimiter = true;</span>
                        }
                    }
                }
<span class="fc" id="L1514">                start = subParse(text, start, tag, count, obeyCount,</span>
                                 ambiguousYear, pos,
                                 useFollowingMinusSignAsDelimiter, calb);
<span class="fc bfc" id="L1517" title="All 2 branches covered.">                if (start &lt; 0) {</span>
<span class="fc" id="L1518">                    pos.index = oldStart;</span>
<span class="fc" id="L1519">                    return null;</span>
                }
            }
<span class="fc" id="L1522">        }</span>

        // At this point the fields of Calendar have been set.  Calendar
        // will fill in default values for missing fields when the time
        // is computed.

<span class="fc" id="L1528">        pos.index = start;</span>

        Date parsedDate;
        try {
<span class="fc" id="L1532">            parsedDate = calb.establish(calendar).getTime();</span>
            // If the year value is ambiguous,
            // then the two-digit year == the default start year
<span class="pc bpc" id="L1535" title="1 of 2 branches missed.">            if (ambiguousYear[0]) {</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (parsedDate.before(defaultCenturyStart)) {</span>
<span class="nc" id="L1537">                    parsedDate = calb.addYear(100).establish(calendar).getTime();</span>
                }
            }
        }
        // An IllegalArgumentException will be thrown by Calendar.getTime()
        // if any fields are out of range, e.g., MONTH == 17.
<span class="fc" id="L1543">        catch (IllegalArgumentException e) {</span>
<span class="fc" id="L1544">            pos.errorIndex = start;</span>
<span class="fc" id="L1545">            pos.index = oldStart;</span>
<span class="fc" id="L1546">            return null;</span>
<span class="fc" id="L1547">        }</span>

<span class="fc" id="L1549">        return parsedDate;</span>
    }

    /**
     * Private code-size reduction function used by subParse.
     * @param text the time text being parsed.
     * @param start where to start parsing.
     * @param field the date field being parsed.
     * @param data the string array to parsed.
     * @return the new start position if matching succeeded; a negative number
     * indicating matching failure, otherwise.
     */
    private int matchString(String text, int start, int field, String[] data, CalendarBuilder calb)
    {
<span class="nc" id="L1563">        int i = 0;</span>
<span class="nc" id="L1564">        int count = data.length;</span>

<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (field == Calendar.DAY_OF_WEEK) {</span>
<span class="nc" id="L1567">            i = 1;</span>
        }

        // There may be multiple strings in the data[] array which begin with
        // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
        // We keep track of the longest match, and return that.  Note that this
        // unfortunately requires us to test all array elements.
<span class="nc" id="L1574">        int bestMatchLength = 0, bestMatch = -1;</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        for (; i&lt;count; ++i)</span>
        {
<span class="nc" id="L1577">            int length = data[i].length();</span>
            // Always compare if we have no match yet; otherwise only compare
            // against potentially better matches (longer strings).
<span class="nc bnc" id="L1580" title="All 2 branches missed.">            if (length &gt; bestMatchLength &amp;&amp;</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">                text.regionMatches(true, start, data[i], 0, length))</span>
            {
<span class="nc" id="L1583">                bestMatch = i;</span>
<span class="nc" id="L1584">                bestMatchLength = length;</span>
            }
        }
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        if (bestMatch &gt;= 0)</span>
        {
<span class="nc" id="L1589">            calb.set(field, bestMatch);</span>
<span class="nc" id="L1590">            return start + bestMatchLength;</span>
        }
<span class="nc" id="L1592">        return -start;</span>
    }

    /**
     * Performs the same thing as matchString(String, int, int,
     * String[]). This method takes a Map&lt;String, Integer&gt; instead of
     * String[].
     */
    private int matchString(String text, int start, int field,
                            Map&lt;String,Integer&gt; data, CalendarBuilder calb) {
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">        if (data != null) {</span>
            // TODO: make this default when it's in the spec.
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">            if (data instanceof SortedMap) {</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                for (String name : data.keySet()) {</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (text.regionMatches(true, start, name, 0, name.length())) {</span>
<span class="nc" id="L1607">                        calb.set(field, data.get(name));</span>
<span class="nc" id="L1608">                        return start + name.length();</span>
                    }
<span class="nc" id="L1610">                }</span>
<span class="nc" id="L1611">                return -start;</span>
            }

<span class="fc" id="L1614">            String bestMatch = null;</span>

<span class="fc bfc" id="L1616" title="All 2 branches covered.">            for (String name : data.keySet()) {</span>
<span class="fc" id="L1617">                int length = name.length();</span>
<span class="fc bfc" id="L1618" title="All 4 branches covered.">                if (bestMatch == null || length &gt; bestMatch.length()) {</span>
<span class="fc bfc" id="L1619" title="All 2 branches covered.">                    if (text.regionMatches(true, start, name, 0, length)) {</span>
<span class="fc" id="L1620">                        bestMatch = name;</span>
                    }
                }
<span class="fc" id="L1623">            }</span>

<span class="fc bfc" id="L1625" title="All 2 branches covered.">            if (bestMatch != null) {</span>
<span class="fc" id="L1626">                calb.set(field, data.get(bestMatch));</span>
<span class="fc" id="L1627">                return start + bestMatch.length();</span>
            }
        }
<span class="fc" id="L1630">        return -start;</span>
    }

    private int matchZoneString(String text, int start, String[] zoneNames) {
<span class="fc bfc" id="L1634" title="All 2 branches covered.">        for (int i = 1; i &lt;= 4; ++i) {</span>
            // Checking long and short zones [1 &amp; 2],
            // and long and short daylight [3 &amp; 4].
<span class="fc" id="L1637">            String zoneName = zoneNames[i];</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">            if (text.regionMatches(true, start,</span>
<span class="fc" id="L1639">                                   zoneName, 0, zoneName.length())) {</span>
<span class="fc" id="L1640">                return i;</span>
            }
        }
<span class="fc" id="L1643">        return -1;</span>
    }

    private boolean matchDSTString(String text, int start, int zoneIndex, int standardIndex,
                                   String[][] zoneStrings) {
<span class="nc" id="L1648">        int index = standardIndex + 2;</span>
<span class="nc" id="L1649">        String zoneName  = zoneStrings[zoneIndex][index];</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">        if (text.regionMatches(true, start,</span>
<span class="nc" id="L1651">                               zoneName, 0, zoneName.length())) {</span>
<span class="nc" id="L1652">            return true;</span>
        }
<span class="nc" id="L1654">        return false;</span>
    }

    /**
     * find time zone 'text' matched zoneStrings and set to internal
     * calendar.
     */
    private int subParseZoneString(String text, int start, CalendarBuilder calb) {
<span class="fc" id="L1662">        boolean useSameName = false; // true if standard and daylight time use the same abbreviation.</span>
<span class="fc" id="L1663">        TimeZone currentTimeZone = getTimeZone();</span>

        // At this point, check for named time zones by looking through
        // the locale data from the TimeZoneNames strings.
        // Want to be able to parse both short and long forms.
<span class="fc" id="L1668">        int zoneIndex = formatData.getZoneIndex(currentTimeZone.getID());</span>
<span class="fc" id="L1669">        TimeZone tz = null;</span>
<span class="fc" id="L1670">        String[][] zoneStrings = formatData.getZoneStringsWrapper();</span>
<span class="fc" id="L1671">        String[] zoneNames = null;</span>
<span class="fc" id="L1672">        int nameIndex = 0;</span>
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">        if (zoneIndex != -1) {</span>
<span class="fc" id="L1674">            zoneNames = zoneStrings[zoneIndex];</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">            if ((nameIndex = matchZoneString(text, start, zoneNames)) &gt; 0) {</span>
<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">                if (nameIndex &lt;= 2) {</span>
                    // Check if the standard name (abbr) and the daylight name are the same.
<span class="fc" id="L1678">                    useSameName = zoneNames[nameIndex].equalsIgnoreCase(zoneNames[nameIndex + 2]);</span>
                }
<span class="fc" id="L1680">                tz = TimeZone.getTimeZone(zoneNames[0]);</span>
            }
        }
<span class="fc bfc" id="L1683" title="All 2 branches covered.">        if (tz == null) {</span>
<span class="fc" id="L1684">            zoneIndex = formatData.getZoneIndex(TimeZone.getDefault().getID());</span>
<span class="pc bpc" id="L1685" title="1 of 2 branches missed.">            if (zoneIndex != -1) {</span>
<span class="fc" id="L1686">                zoneNames = zoneStrings[zoneIndex];</span>
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">                if ((nameIndex = matchZoneString(text, start, zoneNames)) &gt; 0) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                    if (nameIndex &lt;= 2) {</span>
<span class="nc" id="L1689">                        useSameName = zoneNames[nameIndex].equalsIgnoreCase(zoneNames[nameIndex + 2]);</span>
                    }
<span class="nc" id="L1691">                    tz = TimeZone.getTimeZone(zoneNames[0]);</span>
                }
            }
        }

<span class="fc bfc" id="L1696" title="All 2 branches covered.">        if (tz == null) {</span>
<span class="fc" id="L1697">            int len = zoneStrings.length;</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L1699">                zoneNames = zoneStrings[i];</span>
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">                if ((nameIndex = matchZoneString(text, start, zoneNames)) &gt; 0) {</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                    if (nameIndex &lt;= 2) {</span>
<span class="nc" id="L1702">                        useSameName = zoneNames[nameIndex].equalsIgnoreCase(zoneNames[nameIndex + 2]);</span>
                    }
<span class="nc" id="L1704">                    tz = TimeZone.getTimeZone(zoneNames[0]);</span>
<span class="nc" id="L1705">                    break;</span>
                }
            }
        }
<span class="fc bfc" id="L1709" title="All 2 branches covered.">        if (tz != null) { // Matched any ?</span>
<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">            if (!tz.equals(currentTimeZone)) {</span>
<span class="nc" id="L1711">                setTimeZone(tz);</span>
            }
            // If the time zone matched uses the same name
            // (abbreviation) for both standard and daylight time,
            // let the time zone in the Calendar decide which one.
            //
            // Also if tz.getDSTSaving() returns 0 for DST, use tz to
            // determine the local time. (6645292)
<span class="pc bpc" id="L1719" title="1 of 2 branches missed.">            int dstAmount = (nameIndex &gt;= 3) ? tz.getDSTSavings() : 0;</span>
<span class="pc bpc" id="L1720" title="3 of 6 branches missed.">            if (!(useSameName || (nameIndex &gt;= 3 &amp;&amp; dstAmount == 0))) {</span>
<span class="fc" id="L1721">                calb.clear(Calendar.ZONE_OFFSET).set(Calendar.DST_OFFSET, dstAmount);</span>
            }
<span class="fc" id="L1723">            return (start + zoneNames[nameIndex].length());</span>
        }
<span class="fc" id="L1725">        return 0;</span>
    }

    /**
     * Parses numeric forms of time zone offset, such as &quot;hh:mm&quot;, and
     * sets calb to the parsed value.
     *
     * @param text  the text to be parsed
     * @param start the character position to start parsing
     * @param sign  1: positive; -1: negative
     * @param count 0: 'Z' or &quot;GMT+hh:mm&quot; parsing; 1 - 3: the number of 'X's
     * @param colon true - colon required between hh and mm; false - no colon required
     * @param calb  a CalendarBuilder in which the parsed value is stored
     * @return updated parsed position, or its negative value to indicate a parsing error
     */
    private int subParseNumericZone(String text, int start, int sign, int count,
                                    boolean colon, CalendarBuilder calb) {
<span class="fc" id="L1742">        int index = start;</span>

      parse:
        try {
<span class="fc" id="L1746">            char c = text.charAt(index++);</span>
            // Parse hh
            int hours;
<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">            if (!isDigit(c)) {</span>
<span class="nc" id="L1750">                break parse;</span>
            }
<span class="fc" id="L1752">            hours = c - '0';</span>
<span class="fc" id="L1753">            c = text.charAt(index++);</span>
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">            if (isDigit(c)) {</span>
<span class="fc" id="L1755">                hours = hours * 10 + (c - '0');</span>
            } else {
                // If no colon in RFC 822 or 'X' (ISO), two digits are
                // required.
<span class="nc bnc" id="L1759" title="All 4 branches missed.">                if (count &gt; 0 || !colon) {</span>
<span class="nc" id="L1760">                    break parse;</span>
                }
<span class="nc" id="L1762">                --index;</span>
            }
<span class="pc bpc" id="L1764" title="1 of 2 branches missed.">            if (hours &gt; 23) {</span>
<span class="nc" id="L1765">                break parse;</span>
            }
<span class="fc" id="L1767">            int minutes = 0;</span>
<span class="pc bpc" id="L1768" title="1 of 2 branches missed.">            if (count != 1) {</span>
                // Proceed with parsing mm
<span class="fc" id="L1770">                c = text.charAt(index++);</span>
<span class="pc bpc" id="L1771" title="1 of 2 branches missed.">                if (colon) {</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                    if (c != ':') {</span>
<span class="nc" id="L1773">                        break parse;</span>
                    }
<span class="nc" id="L1775">                    c = text.charAt(index++);</span>
                }
<span class="pc bpc" id="L1777" title="1 of 2 branches missed.">                if (!isDigit(c)) {</span>
<span class="nc" id="L1778">                    break parse;</span>
                }
<span class="fc" id="L1780">                minutes = c - '0';</span>
<span class="fc" id="L1781">                c = text.charAt(index++);</span>
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">                if (!isDigit(c)) {</span>
<span class="nc" id="L1783">                    break parse;</span>
                }
<span class="fc" id="L1785">                minutes = minutes * 10 + (c - '0');</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">                if (minutes &gt; 59) {</span>
<span class="nc" id="L1787">                    break parse;</span>
                }
            }
<span class="fc" id="L1790">            minutes += hours * 60;</span>
<span class="fc" id="L1791">            calb.set(Calendar.ZONE_OFFSET, minutes * MILLIS_PER_MINUTE * sign)</span>
<span class="fc" id="L1792">                .set(Calendar.DST_OFFSET, 0);</span>
<span class="fc" id="L1793">            return index;</span>
<span class="nc" id="L1794">        } catch (IndexOutOfBoundsException e) {</span>
        }
<span class="nc" id="L1796">        return  1 - index; // -(index - 1)</span>
    }

    private boolean isDigit(char c) {
<span class="pc bpc" id="L1800" title="2 of 4 branches missed.">        return c &gt;= '0' &amp;&amp; c &lt;= '9';</span>
    }

    /**
     * Private member function that converts the parsed date strings into
     * timeFields. Returns -start (for ParsePosition) if failed.
     * @param text the time text to be parsed.
     * @param start where to start parsing.
     * @param patternCharIndex the index of the pattern character.
     * @param count the count of a pattern character.
     * @param obeyCount if true, then the next field directly abuts this one,
     * and we should use the count to know when to stop parsing.
     * @param ambiguousYear return parameter; upon return, if ambiguousYear[0]
     * is true, then a two-digit year was parsed and may need to be readjusted.
     * @param origPos origPos.errorIndex is used to return an error index
     * at which a parse error occurred, if matching failure occurs.
     * @return the new start position if matching succeeded; -1 indicating
     * matching failure, otherwise. In case matching failure occurred,
     * an error index is set to origPos.errorIndex.
     */
    private int subParse(String text, int start, int patternCharIndex, int count,
                         boolean obeyCount, boolean[] ambiguousYear,
                         ParsePosition origPos,
                         boolean useFollowingMinusSignAsDelimiter, CalendarBuilder calb) {
        Number number;
<span class="fc" id="L1825">        int value = 0;</span>
<span class="fc" id="L1826">        ParsePosition pos = new ParsePosition(0);</span>
<span class="fc" id="L1827">        pos.index = start;</span>
<span class="fc bfc" id="L1828" title="All 4 branches covered.">        if (patternCharIndex == PATTERN_WEEK_YEAR &amp;&amp; !calendar.isWeekDateSupported()) {</span>
            // use calendar year 'y' instead
<span class="fc" id="L1830">            patternCharIndex = PATTERN_YEAR;</span>
        }
<span class="fc" id="L1832">        int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];</span>

        // If there are any spaces here, skip over them.  If we hit the end
        // of the string, then fail.
        for (;;) {
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">            if (pos.index &gt;= text.length()) {</span>
<span class="nc" id="L1838">                origPos.errorIndex = start;</span>
<span class="nc" id="L1839">                return -1;</span>
            }
<span class="fc" id="L1841">            char c = text.charAt(pos.index);</span>
<span class="pc bpc" id="L1842" title="2 of 4 branches missed.">            if (c != ' ' &amp;&amp; c != '\t') {</span>
<span class="fc" id="L1843">                break;</span>
            }
<span class="nc" id="L1845">            ++pos.index;</span>
<span class="nc" id="L1846">        }</span>
        // Remember the actual start index
<span class="fc" id="L1848">        int actualStart = pos.index;</span>

      parsing:
        {
            // We handle a few special cases here where we need to parse
            // a number value.  We handle further, more generic cases below.  We need
            // to handle some of them here because some fields require extra processing on
            // the parsed value.
<span class="pc bpc" id="L1856" title="1 of 12 branches missed.">            if (patternCharIndex == PATTERN_HOUR_OF_DAY1 ||</span>
                patternCharIndex == PATTERN_HOUR1 ||
                (patternCharIndex == PATTERN_MONTH &amp;&amp; count &lt;= 2) ||
                patternCharIndex == PATTERN_YEAR ||
                patternCharIndex == PATTERN_WEEK_YEAR) {
                // It would be good to unify this with the obeyCount logic below,
                // but that's going to be difficult.
<span class="pc bpc" id="L1863" title="1 of 2 branches missed.">                if (obeyCount) {</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">                    if ((start+count) &gt; text.length()) {</span>
<span class="nc" id="L1865">                        break parsing;</span>
                    }
<span class="nc" id="L1867">                    number = numberFormat.parse(text.substring(0, start+count), pos);</span>
                } else {
<span class="fc" id="L1869">                    number = numberFormat.parse(text, pos);</span>
                }
<span class="fc bfc" id="L1871" title="All 2 branches covered.">                if (number == null) {</span>
<span class="pc bpc" id="L1872" title="2 of 4 branches missed.">                    if (patternCharIndex != PATTERN_YEAR || calendar instanceof GregorianCalendar) {</span>
<span class="fc" id="L1873">                        break parsing;</span>
                    }
                } else {
<span class="fc" id="L1876">                    value = number.intValue();</span>

<span class="fc bfc" id="L1878" title="All 4 branches covered.">                    if (useFollowingMinusSignAsDelimiter &amp;&amp; (value &lt; 0) &amp;&amp;</span>
<span class="fc bfc" id="L1879" title="All 2 branches covered.">                        (((pos.index &lt; text.length()) &amp;&amp;</span>
<span class="fc bfc" id="L1880" title="All 2 branches covered.">                         (text.charAt(pos.index) != minusSign)) ||</span>
<span class="fc bfc" id="L1881" title="All 2 branches covered.">                         ((pos.index == text.length()) &amp;&amp;</span>
<span class="pc bpc" id="L1882" title="1 of 2 branches missed.">                          (text.charAt(pos.index-1) == minusSign)))) {</span>
<span class="fc" id="L1883">                        value = -value;</span>
<span class="fc" id="L1884">                        pos.index--;</span>
                    }
                }
            }

<span class="fc" id="L1889">            boolean useDateFormatSymbols = useDateFormatSymbols();</span>

            int index;
<span class="pc bpc" id="L1892" title="4 of 10 branches missed.">            switch (patternCharIndex) {</span>
            case PATTERN_ERA: // 'G'
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                if (useDateFormatSymbols) {</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">                    if ((index = matchString(text, start, Calendar.ERA, formatData.getEras(), calb)) &gt; 0) {</span>
<span class="nc" id="L1896">                        return index;</span>
                    }
                } else {
<span class="nc" id="L1899">                    Map&lt;String, Integer&gt; map = getDisplayNamesMap(field, locale);</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                    if ((index = matchString(text, start, field, map, calb)) &gt; 0) {</span>
<span class="nc" id="L1901">                        return index;</span>
                    }
                }
<span class="nc" id="L1904">                break parsing;</span>

            case PATTERN_WEEK_YEAR: // 'Y'
            case PATTERN_YEAR:      // 'y'
<span class="fc bfc" id="L1908" title="All 2 branches covered.">                if (!(calendar instanceof GregorianCalendar)) {</span>
                    // calendar might have text representations for year values,
                    // such as &quot;\u5143&quot; in JapaneseImperialCalendar.
<span class="pc bpc" id="L1911" title="1 of 2 branches missed.">                    int style = (count &gt;= 4) ? Calendar.LONG : Calendar.SHORT;</span>
<span class="fc" id="L1912">                    Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field, style, locale);</span>
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">                    if (map != null) {</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">                        if ((index = matchString(text, start, field, map, calb)) &gt; 0) {</span>
<span class="nc" id="L1915">                            return index;</span>
                        }
                    }
<span class="fc" id="L1918">                    calb.set(field, value);</span>
<span class="fc" id="L1919">                    return pos.index;</span>
                }

                // If there are 3 or more YEAR pattern characters, this indicates
                // that the year value is to be treated literally, without any
                // two-digit year adjustments (e.g., from &quot;01&quot; to 2001).  Otherwise
                // we made adjustments to place the 2-digit year in the proper
                // century, for parsed strings from &quot;00&quot; to &quot;99&quot;.  Any other string
                // is treated literally:  &quot;2250&quot;, &quot;-1&quot;, &quot;1&quot;, &quot;002&quot;.
<span class="pc bpc" id="L1928" title="3 of 4 branches missed.">                if (count &lt;= 2 &amp;&amp; (pos.index - actualStart) == 2</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">                    &amp;&amp; Character.isDigit(text.charAt(actualStart))</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                    &amp;&amp; Character.isDigit(text.charAt(actualStart + 1))) {</span>
                    // Assume for example that the defaultCenturyStart is 6/18/1903.
                    // This means that two-digit years will be forced into the range
                    // 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02
                    // correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond
                    // to 1904, 1905, etc.  If the year is 03, then it is 2003 if the
                    // other fields specify a date before 6/18, or 1903 if they specify a
                    // date afterwards.  As a result, 03 is an ambiguous year.  All other
                    // two-digit years are unambiguous.
<span class="nc" id="L1939">                    int ambiguousTwoDigitYear = defaultCenturyStartYear % 100;</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                    ambiguousYear[0] = value == ambiguousTwoDigitYear;</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                    value += (defaultCenturyStartYear/100)*100 +</span>
                        (value &lt; ambiguousTwoDigitYear ? 100 : 0);
                }
<span class="fc" id="L1944">                calb.set(field, value);</span>
<span class="fc" id="L1945">                return pos.index;</span>

            case PATTERN_MONTH: // 'M'
<span class="fc bfc" id="L1948" title="All 2 branches covered.">                if (count &lt;= 2) // i.e., M or MM.</span>
                {
                    // Don't want to parse the month if it is a string
                    // while pattern uses numeric style: M or MM.
                    // [We computed 'value' above.]
<span class="fc" id="L1953">                    calb.set(Calendar.MONTH, value - 1);</span>
<span class="fc" id="L1954">                    return pos.index;</span>
                }

<span class="pc bpc" id="L1957" title="1 of 2 branches missed.">                if (useDateFormatSymbols) {</span>
                    // count &gt;= 3 // i.e., MMM or MMMM
                    // Want to be able to parse both short and long forms.
                    // Try count == 4 first:
                    int newStart;
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                    if ((newStart = matchString(text, start, Calendar.MONTH,</span>
<span class="nc" id="L1963">                                                formatData.getMonths(), calb)) &gt; 0) {</span>
<span class="nc" id="L1964">                        return newStart;</span>
                    }
                    // count == 4 failed, now try count == 3
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                    if ((index = matchString(text, start, Calendar.MONTH,</span>
<span class="nc" id="L1968">                                             formatData.getShortMonths(), calb)) &gt; 0) {</span>
<span class="nc" id="L1969">                        return index;</span>
                    }
<span class="nc" id="L1971">                } else {</span>
<span class="fc" id="L1972">                    Map&lt;String, Integer&gt; map = getDisplayNamesMap(field, locale);</span>
<span class="fc bfc" id="L1973" title="All 2 branches covered.">                    if ((index = matchString(text, start, field, map, calb)) &gt; 0) {</span>
<span class="fc" id="L1974">                        return index;</span>
                    }
                }
<span class="fc" id="L1977">                break parsing;</span>

            case PATTERN_HOUR_OF_DAY1: // 'k' 1-based.  eg, 23:59 + 1 hour =&gt;&gt; 24:59
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                if (!isLenient()) {</span>
                    // Validate the hour value in non-lenient
<span class="nc bnc" id="L1982" title="All 4 branches missed.">                    if (value &lt; 1 || value &gt; 24) {</span>
<span class="nc" id="L1983">                        break parsing;</span>
                    }
                }
                // [We computed 'value' above.]
<span class="nc bnc" id="L1987" title="All 2 branches missed.">                if (value == calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1) {</span>
<span class="nc" id="L1988">                    value = 0;</span>
                }
<span class="nc" id="L1990">                calb.set(Calendar.HOUR_OF_DAY, value);</span>
<span class="nc" id="L1991">                return pos.index;</span>

            case PATTERN_DAY_OF_WEEK:  // 'E'
                {
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">                    if (useDateFormatSymbols) {</span>
                        // Want to be able to parse both short and long forms.
                        // Try count == 4 (DDDD) first:
                        int newStart;
<span class="nc bnc" id="L1999" title="All 2 branches missed.">                        if ((newStart=matchString(text, start, Calendar.DAY_OF_WEEK,</span>
<span class="nc" id="L2000">                                                  formatData.getWeekdays(), calb)) &gt; 0) {</span>
<span class="nc" id="L2001">                            return newStart;</span>
                        }
                        // DDDD failed, now try DDD
<span class="nc bnc" id="L2004" title="All 2 branches missed.">                        if ((index = matchString(text, start, Calendar.DAY_OF_WEEK,</span>
<span class="nc" id="L2005">                                                 formatData.getShortWeekdays(), calb)) &gt; 0) {</span>
<span class="nc" id="L2006">                            return index;</span>
                        }
<span class="nc" id="L2008">                    } else {</span>
<span class="fc" id="L2009">                        int[] styles = { Calendar.LONG, Calendar.SHORT };</span>
<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">                        for (int style : styles) {</span>
<span class="fc" id="L2011">                            Map&lt;String,Integer&gt; map = calendar.getDisplayNames(field, style, locale);</span>
<span class="fc bfc" id="L2012" title="All 2 branches covered.">                            if ((index = matchString(text, start, field, map, calb)) &gt; 0) {</span>
<span class="fc" id="L2013">                                return index;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2018">                break parsing;</span>

            case PATTERN_AM_PM:    // 'a'
<span class="nc bnc" id="L2021" title="All 2 branches missed.">                if (useDateFormatSymbols) {</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">                    if ((index = matchString(text, start, Calendar.AM_PM,</span>
<span class="nc" id="L2023">                                             formatData.getAmPmStrings(), calb)) &gt; 0) {</span>
<span class="nc" id="L2024">                        return index;</span>
                    }
                } else {
<span class="nc" id="L2027">                    Map&lt;String,Integer&gt; map = getDisplayNamesMap(field, locale);</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">                    if ((index = matchString(text, start, field, map, calb)) &gt; 0) {</span>
<span class="nc" id="L2029">                        return index;</span>
                    }
                }
<span class="nc" id="L2032">                break parsing;</span>

            case PATTERN_HOUR1: // 'h' 1-based.  eg, 11PM + 1 hour =&gt;&gt; 12 AM
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">                if (!isLenient()) {</span>
                    // Validate the hour value in non-lenient
<span class="nc bnc" id="L2037" title="All 4 branches missed.">                    if (value &lt; 1 || value &gt; 12) {</span>
<span class="nc" id="L2038">                        break parsing;</span>
                    }
                }
                // [We computed 'value' above.]
<span class="pc bpc" id="L2042" title="1 of 2 branches missed.">                if (value == calendar.getLeastMaximum(Calendar.HOUR) + 1) {</span>
<span class="nc" id="L2043">                    value = 0;</span>
                }
<span class="fc" id="L2045">                calb.set(Calendar.HOUR, value);</span>
<span class="fc" id="L2046">                return pos.index;</span>

            case PATTERN_ZONE_NAME:  // 'z'
            case PATTERN_ZONE_VALUE: // 'Z'
                {
<span class="fc" id="L2051">                    int sign = 0;</span>
                    try {
<span class="fc" id="L2053">                        char c = text.charAt(pos.index);</span>
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">                        if (c == '+') {</span>
<span class="nc" id="L2055">                            sign = 1;</span>
<span class="fc bfc" id="L2056" title="All 2 branches covered.">                        } else if (c == '-') {</span>
<span class="fc" id="L2057">                            sign = -1;</span>
                        }
<span class="fc bfc" id="L2059" title="All 2 branches covered.">                        if (sign == 0) {</span>
                            // Try parsing a custom time zone &quot;GMT+hh:mm&quot; or &quot;GMT&quot;.
<span class="pc bpc" id="L2061" title="1 of 4 branches missed.">                            if ((c == 'G' || c == 'g')</span>
<span class="pc bpc" id="L2062" title="1 of 2 branches missed.">                                &amp;&amp; (text.length() - start) &gt;= GMT.length()</span>
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">                                &amp;&amp; text.regionMatches(true, start, GMT, 0, GMT.length())) {</span>
<span class="nc" id="L2064">                                pos.index = start + GMT.length();</span>

<span class="nc bnc" id="L2066" title="All 2 branches missed.">                                if ((text.length() - pos.index) &gt; 0) {</span>
<span class="nc" id="L2067">                                    c = text.charAt(pos.index);</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                                    if (c == '+') {</span>
<span class="nc" id="L2069">                                        sign = 1;</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                                    } else if (c == '-') {</span>
<span class="nc" id="L2071">                                        sign = -1;</span>
                                    }
                                }

<span class="nc bnc" id="L2075" title="All 2 branches missed.">                                if (sign == 0) {    /* &quot;GMT&quot; without offset */</span>
<span class="nc" id="L2076">                                    calb.set(Calendar.ZONE_OFFSET, 0)</span>
<span class="nc" id="L2077">                                        .set(Calendar.DST_OFFSET, 0);</span>
<span class="nc" id="L2078">                                    return pos.index;</span>
                                }

                                // Parse the rest as &quot;hh:mm&quot;
<span class="nc" id="L2082">                                int i = subParseNumericZone(text, ++pos.index,</span>
                                                            sign, 0, true, calb);
<span class="nc bnc" id="L2084" title="All 2 branches missed.">                                if (i &gt; 0) {</span>
<span class="nc" id="L2085">                                    return i;</span>
                                }
<span class="nc" id="L2087">                                pos.index = -i;</span>
<span class="nc" id="L2088">                            } else {</span>
                                // Try parsing the text as a time zone
                                // name or abbreviation.
<span class="fc" id="L2091">                                int i = subParseZoneString(text, pos.index, calb);</span>
<span class="fc bfc" id="L2092" title="All 2 branches covered.">                                if (i &gt; 0) {</span>
<span class="fc" id="L2093">                                    return i;</span>
                                }
<span class="fc" id="L2095">                                pos.index = -i;</span>
<span class="fc" id="L2096">                            }</span>
                        } else {
                            // Parse the rest as &quot;hhmm&quot; (RFC 822)
<span class="fc" id="L2099">                            int i = subParseNumericZone(text, ++pos.index,</span>
                                                        sign, 0, false, calb);
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">                            if (i &gt; 0) {</span>
<span class="fc" id="L2102">                                return i;</span>
                            }
<span class="nc" id="L2104">                            pos.index = -i;</span>
                        }
<span class="nc" id="L2106">                    } catch (IndexOutOfBoundsException e) {</span>
<span class="fc" id="L2107">                    }</span>
                }
<span class="fc" id="L2109">                break parsing;</span>

            case PATTERN_ISO_ZONE:   // 'X'
                {
<span class="nc bnc" id="L2113" title="All 2 branches missed.">                    if ((text.length() - pos.index) &lt;= 0) {</span>
<span class="nc" id="L2114">                        break parsing;</span>
                    }

                    int sign;
<span class="nc" id="L2118">                    char c = text.charAt(pos.index);</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                    if (c == 'Z') {</span>
<span class="nc" id="L2120">                        calb.set(Calendar.ZONE_OFFSET, 0).set(Calendar.DST_OFFSET, 0);</span>
<span class="nc" id="L2121">                        return ++pos.index;</span>
                    }

                    // parse text as &quot;+/-hh[[:]mm]&quot; based on count
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                    if (c == '+') {</span>
<span class="nc" id="L2126">                        sign = 1;</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">                    } else if (c == '-') {</span>
<span class="nc" id="L2128">                        sign = -1;</span>
                    } else {
<span class="nc" id="L2130">                        ++pos.index;</span>
<span class="nc" id="L2131">                        break parsing;</span>
                    }
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                    int i = subParseNumericZone(text, ++pos.index, sign, count,</span>
                                                count == 3, calb);
<span class="nc bnc" id="L2135" title="All 2 branches missed.">                    if (i &gt; 0) {</span>
<span class="nc" id="L2136">                        return i;</span>
                    }
<span class="nc" id="L2138">                    pos.index = -i;</span>
                }
<span class="nc" id="L2140">                break parsing;</span>

            default:
         // case PATTERN_DAY_OF_MONTH:         // 'd'
         // case PATTERN_HOUR_OF_DAY0:         // 'H' 0-based.  eg, 23:59 + 1 hour =&gt;&gt; 00:59
         // case PATTERN_MINUTE:               // 'm'
         // case PATTERN_SECOND:               // 's'
         // case PATTERN_MILLISECOND:          // 'S'
         // case PATTERN_DAY_OF_YEAR:          // 'D'
         // case PATTERN_DAY_OF_WEEK_IN_MONTH: // 'F'
         // case PATTERN_WEEK_OF_YEAR:         // 'w'
         // case PATTERN_WEEK_OF_MONTH:        // 'W'
         // case PATTERN_HOUR0:                // 'K' 0-based.  eg, 11PM + 1 hour =&gt;&gt; 0 AM
         // case PATTERN_ISO_DAY_OF_WEEK:      // 'u' (pseudo field);

                // Handle &quot;generic&quot; fields
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">                if (obeyCount) {</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">                    if ((start+count) &gt; text.length()) {</span>
<span class="nc" id="L2158">                        break parsing;</span>
                    }
<span class="nc" id="L2160">                    number = numberFormat.parse(text.substring(0, start+count), pos);</span>
                } else {
<span class="fc" id="L2162">                    number = numberFormat.parse(text, pos);</span>
                }
<span class="fc bfc" id="L2164" title="All 2 branches covered.">                if (number != null) {</span>
<span class="fc" id="L2165">                    value = number.intValue();</span>

<span class="fc bfc" id="L2167" title="All 4 branches covered.">                    if (useFollowingMinusSignAsDelimiter &amp;&amp; (value &lt; 0) &amp;&amp;</span>
<span class="fc bfc" id="L2168" title="All 2 branches covered.">                        (((pos.index &lt; text.length()) &amp;&amp;</span>
<span class="fc bfc" id="L2169" title="All 2 branches covered.">                         (text.charAt(pos.index) != minusSign)) ||</span>
<span class="fc bfc" id="L2170" title="All 2 branches covered.">                         ((pos.index == text.length()) &amp;&amp;</span>
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">                          (text.charAt(pos.index-1) == minusSign)))) {</span>
<span class="fc" id="L2172">                        value = -value;</span>
<span class="fc" id="L2173">                        pos.index--;</span>
                    }

<span class="fc" id="L2176">                    calb.set(field, value);</span>
<span class="fc" id="L2177">                    return pos.index;</span>
                }
                break parsing;
            }
        }

        // Parsing failed.
<span class="fc" id="L2184">        origPos.errorIndex = pos.index;</span>
<span class="fc" id="L2185">        return -1;</span>
    }

    /**
     * Returns true if the DateFormatSymbols has been set explicitly or locale
     * is null.
     */
    private boolean useDateFormatSymbols() {
<span class="pc bpc" id="L2193" title="1 of 4 branches missed.">        return useDateFormatSymbols || locale == null;</span>
    }

    /**
     * Translates a pattern, mapping each character in the from string to the
     * corresponding character in the to string.
     *
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    private String translatePattern(String pattern, String from, String to) {
<span class="nc" id="L2203">        StringBuilder result = new StringBuilder();</span>
<span class="nc" id="L2204">        boolean inQuote = false;</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">        for (int i = 0; i &lt; pattern.length(); ++i) {</span>
<span class="nc" id="L2206">            char c = pattern.charAt(i);</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">            if (inQuote) {</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                if (c == '\'') {</span>
<span class="nc" id="L2209">                    inQuote = false;</span>
                }
            }
            else {
<span class="nc bnc" id="L2213" title="All 2 branches missed.">                if (c == '\'') {</span>
<span class="nc" id="L2214">                    inQuote = true;</span>
<span class="nc bnc" id="L2215" title="All 8 branches missed.">                } else if ((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')) {</span>
<span class="nc" id="L2216">                    int ci = from.indexOf(c);</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">                    if (ci &gt;= 0) {</span>
                        // patternChars is longer than localPatternChars due
                        // to serialization compatibility. The pattern letters
                        // unsupported by localPatternChars pass through.
<span class="nc bnc" id="L2221" title="All 2 branches missed.">                        if (ci &lt; to.length()) {</span>
<span class="nc" id="L2222">                            c = to.charAt(ci);</span>
                        }
                    } else {
<span class="nc" id="L2225">                        throw new IllegalArgumentException(&quot;Illegal pattern &quot; +</span>
                                                           &quot; character '&quot; +
                                                           c + &quot;'&quot;);
                    }
                }
            }
<span class="nc" id="L2231">            result.append(c);</span>
        }
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (inQuote) {</span>
<span class="nc" id="L2234">            throw new IllegalArgumentException(&quot;Unfinished quote in pattern&quot;);</span>
        }
<span class="nc" id="L2236">        return result.toString();</span>
    }

    /**
     * Returns a pattern string describing this date format.
     *
     * @return a pattern string describing this date format.
     */
    public String toPattern() {
<span class="fc" id="L2245">        return pattern;</span>
    }

    /**
     * Returns a localized pattern string describing this date format.
     *
     * @return a localized pattern string describing this date format.
     */
    public String toLocalizedPattern() {
<span class="nc" id="L2254">        return translatePattern(pattern,</span>
                                DateFormatSymbols.patternChars,
<span class="nc" id="L2256">                                formatData.getLocalPatternChars());</span>
    }

    /**
     * Applies the given pattern string to this date format.
     *
     * @param pattern the new date and time pattern for this date format
     * @exception NullPointerException if the given pattern is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    public void applyPattern(String pattern)
    {
<span class="fc" id="L2268">        applyPatternImpl(pattern);</span>
<span class="fc" id="L2269">    }</span>

    private void applyPatternImpl(String pattern) {
<span class="fc" id="L2272">        compiledPattern = compile(pattern);</span>
<span class="fc" id="L2273">        this.pattern = pattern;</span>
<span class="fc" id="L2274">    }</span>

    /**
     * Applies the given localized pattern string to this date format.
     *
     * @param pattern a String to be mapped to the new date and time format
     *        pattern for this format
     * @exception NullPointerException if the given pattern is null
     * @exception IllegalArgumentException if the given pattern is invalid
     */
    public void applyLocalizedPattern(String pattern) {
<span class="nc" id="L2285">         String p = translatePattern(pattern,</span>
<span class="nc" id="L2286">                                     formatData.getLocalPatternChars(),</span>
                                     DateFormatSymbols.patternChars);
<span class="nc" id="L2288">         compiledPattern = compile(p);</span>
<span class="nc" id="L2289">         this.pattern = p;</span>
<span class="nc" id="L2290">    }</span>

    /**
     * Gets a copy of the date and time format symbols of this date format.
     *
     * @return the date and time format symbols of this date format
     * @see #setDateFormatSymbols
     */
    public DateFormatSymbols getDateFormatSymbols()
    {
<span class="nc" id="L2300">        return (DateFormatSymbols)formatData.clone();</span>
    }

    /**
     * Sets the date and time format symbols of this date format.
     *
     * @param newFormatSymbols the new date and time format symbols
     * @exception NullPointerException if the given newFormatSymbols is null
     * @see #getDateFormatSymbols
     */
    public void setDateFormatSymbols(DateFormatSymbols newFormatSymbols)
    {
<span class="nc" id="L2312">        this.formatData = (DateFormatSymbols)newFormatSymbols.clone();</span>
<span class="nc" id="L2313">        useDateFormatSymbols = true;</span>
<span class="nc" id="L2314">    }</span>

    /**
     * Creates a copy of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;. This also
     * clones the format's date format symbols.
     *
     * @return a clone of this &lt;code&gt;SimpleDateFormat&lt;/code&gt;
     */
    @Override
    public Object clone() {
<span class="nc" id="L2324">        SimpleDateFormat other = (SimpleDateFormat) super.clone();</span>
<span class="nc" id="L2325">        other.formatData = (DateFormatSymbols) formatData.clone();</span>
<span class="nc" id="L2326">        return other;</span>
    }

    /**
     * Returns the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.
     *
     * @return the hash code value for this &lt;code&gt;SimpleDateFormat&lt;/code&gt; object.
     */
    @Override
    public int hashCode()
    {
<span class="fc" id="L2337">        return pattern.hashCode();</span>
        // just enough fields for a reasonable distribution
    }

    /**
     * Compares the given object with this &lt;code&gt;SimpleDateFormat&lt;/code&gt; for
     * equality.
     *
     * @return true if the given object is equal to this
     * &lt;code&gt;SimpleDateFormat&lt;/code&gt;
     */
    @Override
    public boolean equals(Object obj)
    {
<span class="pc bpc" id="L2351" title="1 of 2 branches missed.">        if (!super.equals(obj)) {</span>
<span class="nc" id="L2352">            return false; // super does class check</span>
        }
<span class="fc" id="L2354">        SimpleDateFormat that = (SimpleDateFormat) obj;</span>
<span class="fc bfc" id="L2355" title="All 2 branches covered.">        return (pattern.equals(that.pattern)</span>
<span class="pc bpc" id="L2356" title="1 of 2 branches missed.">                &amp;&amp; formatData.equals(that.formatData));</span>
    }

<span class="fc" id="L2359">    private static final int[] REST_OF_STYLES = {</span>
        Calendar.SHORT_STANDALONE, Calendar.LONG_FORMAT, Calendar.LONG_STANDALONE,
    };
    private Map&lt;String, Integer&gt; getDisplayNamesMap(int field, Locale locale) {
<span class="fc" id="L2363">        Map&lt;String, Integer&gt; map = calendar.getDisplayNames(field, Calendar.SHORT_FORMAT, locale);</span>
        // Get all SHORT and LONG styles (avoid NARROW styles).
<span class="fc bfc" id="L2365" title="All 2 branches covered.">        for (int style : REST_OF_STYLES) {</span>
<span class="fc" id="L2366">            Map&lt;String, Integer&gt; m = calendar.getDisplayNames(field, style, locale);</span>
<span class="fc bfc" id="L2367" title="All 2 branches covered.">            if (m != null) {</span>
<span class="fc" id="L2368">                map.putAll(m);</span>
            }
        }
<span class="fc" id="L2371">        return map;</span>
    }

    /**
     * After reading an object from the input stream, the format
     * pattern in the object is verified.
     * &lt;p&gt;
     * @exception InvalidObjectException if the pattern is invalid
     */
    private void readObject(ObjectInputStream stream)
                         throws IOException, ClassNotFoundException {
<span class="nc" id="L2382">        stream.defaultReadObject();</span>

        try {
<span class="nc" id="L2385">            compiledPattern = compile(pattern);</span>
<span class="nc" id="L2386">        } catch (Exception e) {</span>
<span class="nc" id="L2387">            throw new InvalidObjectException(&quot;invalid pattern&quot;);</span>
<span class="nc" id="L2388">        }</span>

<span class="nc bnc" id="L2390" title="All 2 branches missed.">        if (serialVersionOnStream &lt; 1) {</span>
            // didn't have defaultCenturyStart field
<span class="nc" id="L2392">            initializeDefaultCentury();</span>
        }
        else {
            // fill in dependent transient field
<span class="nc" id="L2396">            parseAmbiguousDatesAsAfter(defaultCenturyStart);</span>
        }
<span class="nc" id="L2398">        serialVersionOnStream = currentSerialVersion;</span>

        // If the deserialized object has a SimpleTimeZone, try
        // to replace it with a ZoneInfo equivalent in order to
        // be compatible with the SimpleTimeZone-based
        // implementation as much as possible.
<span class="nc" id="L2404">        TimeZone tz = getTimeZone();</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (tz instanceof SimpleTimeZone) {</span>
<span class="nc" id="L2406">            String id = tz.getID();</span>
<span class="nc" id="L2407">            TimeZone zi = TimeZone.getTimeZone(id);</span>
<span class="nc bnc" id="L2408" title="All 6 branches missed.">            if (zi != null &amp;&amp; zi.hasSameRules(tz) &amp;&amp; zi.getID().equals(id)) {</span>
<span class="nc" id="L2409">                setTimeZone(zi);</span>
            }
        }
<span class="nc" id="L2412">    }</span>

    /**
     * Analyze the negative subpattern of DecimalFormat and set/update values
     * as necessary.
     */
    private void checkNegativeNumberExpression() {
<span class="pc bpc" id="L2419" title="1 of 2 branches missed.">        if ((numberFormat instanceof DecimalFormat) &amp;&amp;</span>
<span class="fc bfc" id="L2420" title="All 2 branches covered.">            !numberFormat.equals(originalNumberFormat)) {</span>
<span class="fc" id="L2421">            String numberPattern = ((DecimalFormat)numberFormat).toPattern();</span>
<span class="pc bpc" id="L2422" title="1 of 2 branches missed.">            if (!numberPattern.equals(originalNumberPattern)) {</span>
<span class="fc" id="L2423">                hasFollowingMinusSign = false;</span>

<span class="fc" id="L2425">                int separatorIndex = numberPattern.indexOf(';');</span>
                // If the negative subpattern is not absent, we have to analayze
                // it in order to check if it has a following minus sign.
<span class="fc bfc" id="L2428" title="All 2 branches covered.">                if (separatorIndex &gt; -1) {</span>
<span class="fc" id="L2429">                    int minusIndex = numberPattern.indexOf('-', separatorIndex);</span>
<span class="pc bpc" id="L2430" title="1 of 2 branches missed.">                    if ((minusIndex &gt; numberPattern.lastIndexOf('0')) &amp;&amp;</span>
<span class="pc bpc" id="L2431" title="1 of 2 branches missed.">                        (minusIndex &gt; numberPattern.lastIndexOf('#'))) {</span>
<span class="fc" id="L2432">                        hasFollowingMinusSign = true;</span>
<span class="fc" id="L2433">                        minusSign = ((DecimalFormat)numberFormat).getDecimalFormatSymbols().getMinusSign();</span>
                    }
                }
<span class="fc" id="L2436">                originalNumberPattern = numberPattern;</span>
            }
<span class="fc" id="L2438">            originalNumberFormat = numberFormat;</span>
        }
<span class="fc" id="L2440">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>