<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DateFormatSymbols.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.text</a> &gt; <span class="el_source">DateFormatSymbols.java</span></div><h1>DateFormatSymbols.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 *
 *   The original version of this source code and documentation is copyrighted
 * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 * materials are provided under terms of a License Agreement between Taligent
 * and Sun. This technology is protected by multiple US and International
 * patents. This notice and attribution to Taligent may not be removed.
 *   Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.text;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.ref.SoftReference;
import java.text.spi.DateFormatSymbolsProvider;
import java.util.Arrays;
import java.util.Locale;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import sun.util.locale.provider.LocaleProviderAdapter;
import sun.util.locale.provider.LocaleServiceProviderPool;
import sun.util.locale.provider.ResourceBundleBasedAdapter;
import sun.util.locale.provider.TimeZoneNameUtility;

/**
 * &lt;code&gt;DateFormatSymbols&lt;/code&gt; is a public class for encapsulating
 * localizable date-time formatting data, such as the names of the
 * months, the names of the days of the week, and the time zone data.
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; uses
 * &lt;code&gt;DateFormatSymbols&lt;/code&gt; to encapsulate this information.
 *
 * &lt;p&gt;
 * Typically you shouldn't use &lt;code&gt;DateFormatSymbols&lt;/code&gt; directly.
 * Rather, you are encouraged to create a date-time formatter with the
 * &lt;code&gt;DateFormat&lt;/code&gt; class's factory methods: &lt;code&gt;getTimeInstance&lt;/code&gt;,
 * &lt;code&gt;getDateInstance&lt;/code&gt;, or &lt;code&gt;getDateTimeInstance&lt;/code&gt;.
 * These methods automatically create a &lt;code&gt;DateFormatSymbols&lt;/code&gt; for
 * the formatter so that you don't have to. After the
 * formatter is created, you may modify its format pattern using the
 * &lt;code&gt;setPattern&lt;/code&gt; method. For more information about
 * creating formatters using &lt;code&gt;DateFormat&lt;/code&gt;'s factory methods,
 * see {@link DateFormat}.
 *
 * &lt;p&gt;
 * If you decide to create a date-time formatter with a specific
 * format pattern for a specific locale, you can do so with:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;
 * &lt;code&gt;DateFormatSymbols&lt;/code&gt; objects are cloneable. When you obtain
 * a &lt;code&gt;DateFormatSymbols&lt;/code&gt; object, feel free to modify the
 * date-time formatting data. For instance, you can replace the localized
 * date-time format pattern characters with the ones that you feel easy
 * to remember. Or you can change the representative cities
 * to your favorite ones.
 *
 * &lt;p&gt;
 * New &lt;code&gt;DateFormatSymbols&lt;/code&gt; subclasses may be added to support
 * &lt;code&gt;SimpleDateFormat&lt;/code&gt; for date-time formatting for additional locales.

 * @see          DateFormat
 * @see          SimpleDateFormat
 * @see          java.util.SimpleTimeZone
 * @author       Chen-Lieh Huang
 */
public class DateFormatSymbols implements Serializable, Cloneable {

    /**
     * Construct a DateFormatSymbols object by loading format data from
     * resources for the default {@link java.util.Locale.Category#FORMAT FORMAT}
     * locale. This constructor can only
     * construct instances for the locales supported by the Java
     * runtime environment, not for those supported by installed
     * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
     * implementations. For full locale coverage, use the
     * {@link #getInstance(Locale) getInstance} method.
     * &lt;p&gt;This is equivalent to calling
     * {@link #DateFormatSymbols(Locale)
     *     DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
     * @see #getInstance()
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     * @exception  java.util.MissingResourceException
     *             if the resources for the default locale cannot be
     *             found or cannot be loaded.
     */
    public DateFormatSymbols()
<span class="nc" id="L125">    {</span>
<span class="nc" id="L126">        initializeData(Locale.getDefault(Locale.Category.FORMAT));</span>
<span class="nc" id="L127">    }</span>

    /**
     * Construct a DateFormatSymbols object by loading format data from
     * resources for the given locale. This constructor can only
     * construct instances for the locales supported by the Java
     * runtime environment, not for those supported by installed
     * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
     * implementations. For full locale coverage, use the
     * {@link #getInstance(Locale) getInstance} method.
     *
     * @param locale the desired locale
     * @see #getInstance(Locale)
     * @exception  java.util.MissingResourceException
     *             if the resources for the specified locale cannot be
     *             found or cannot be loaded.
     */
    public DateFormatSymbols(Locale locale)
<span class="fc" id="L145">    {</span>
<span class="fc" id="L146">        initializeData(locale);</span>
<span class="fc" id="L147">    }</span>

    /**
     * Era strings. For example: &quot;AD&quot; and &quot;BC&quot;.  An array of 2 strings,
     * indexed by &lt;code&gt;Calendar.BC&lt;/code&gt; and &lt;code&gt;Calendar.AD&lt;/code&gt;.
     * @serial
     */
<span class="pc" id="L154">    String eras[] = null;</span>

    /**
     * Month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.  An array
     * of 13 strings (some calendars have 13 months), indexed by
     * &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.
     * @serial
     */
<span class="pc" id="L162">    String months[] = null;</span>

    /**
     * Short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.  An array of
     * 13 strings (some calendars have 13 months), indexed by
     * &lt;code&gt;Calendar.JANUARY&lt;/code&gt;, &lt;code&gt;Calendar.FEBRUARY&lt;/code&gt;, etc.

     * @serial
     */
<span class="pc" id="L171">    String shortMonths[] = null;</span>

    /**
     * Weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.  An array
     * of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
     * The element &lt;code&gt;weekdays[0]&lt;/code&gt; is ignored.
     * @serial
     */
<span class="pc" id="L180">    String weekdays[] = null;</span>

    /**
     * Short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.  An array
     * of 8 strings, indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
     * The element &lt;code&gt;shortWeekdays[0]&lt;/code&gt; is ignored.
     * @serial
     */
<span class="pc" id="L189">    String shortWeekdays[] = null;</span>

    /**
     * AM and PM strings. For example: &quot;AM&quot; and &quot;PM&quot;.  An array of
     * 2 strings, indexed by &lt;code&gt;Calendar.AM&lt;/code&gt; and
     * &lt;code&gt;Calendar.PM&lt;/code&gt;.
     * @serial
     */
<span class="pc" id="L197">    String ampms[] = null;</span>

    /**
     * Localized names of time zones in this locale.  This is a
     * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
     * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
     * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
     * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
     * 0..&lt;em&gt;n&lt;/em&gt;-1):
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
     * time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
     * standard time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;/ul&gt;
     * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of
     * the {@link java.util.TimeZone TimeZone} class that are not
     * &lt;a href=&quot;../java/util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
     * All other entries are localized names.
     * @see java.util.TimeZone
     * @serial
     */
<span class="pc" id="L224">    String zoneStrings[][] = null;</span>

    /**
     * Indicates that zoneStrings is set externally with setZoneStrings() method.
     */
<span class="pc" id="L229">    transient boolean isZoneStringsSet = false;</span>

    /**
     * Unlocalized date-time pattern characters. For example: 'y', 'd', etc.
     * All locales use the same these unlocalized pattern characters.
     */
    static final String  patternChars = &quot;GyMdkHmsSEDFwWahKzZYuXL&quot;;

    static final int PATTERN_ERA                  =  0; // G
    static final int PATTERN_YEAR                 =  1; // y
    static final int PATTERN_MONTH                =  2; // M
    static final int PATTERN_DAY_OF_MONTH         =  3; // d
    static final int PATTERN_HOUR_OF_DAY1         =  4; // k
    static final int PATTERN_HOUR_OF_DAY0         =  5; // H
    static final int PATTERN_MINUTE               =  6; // m
    static final int PATTERN_SECOND               =  7; // s
    static final int PATTERN_MILLISECOND          =  8; // S
    static final int PATTERN_DAY_OF_WEEK          =  9; // E
    static final int PATTERN_DAY_OF_YEAR          = 10; // D
    static final int PATTERN_DAY_OF_WEEK_IN_MONTH = 11; // F
    static final int PATTERN_WEEK_OF_YEAR         = 12; // w
    static final int PATTERN_WEEK_OF_MONTH        = 13; // W
    static final int PATTERN_AM_PM                = 14; // a
    static final int PATTERN_HOUR1                = 15; // h
    static final int PATTERN_HOUR0                = 16; // K
    static final int PATTERN_ZONE_NAME            = 17; // z
    static final int PATTERN_ZONE_VALUE           = 18; // Z
    static final int PATTERN_WEEK_YEAR            = 19; // Y
    static final int PATTERN_ISO_DAY_OF_WEEK      = 20; // u
    static final int PATTERN_ISO_ZONE             = 21; // X
    static final int PATTERN_MONTH_STANDALONE     = 22; // L

    /**
     * Localized date-time pattern characters. For example, a locale may
     * wish to use 'u' rather than 'y' to represent years in its date format
     * pattern strings.
     * This string must be exactly 18 characters long, with the index of
     * the characters described by &lt;code&gt;DateFormat.ERA_FIELD&lt;/code&gt;,
     * &lt;code&gt;DateFormat.YEAR_FIELD&lt;/code&gt;, etc.  Thus, if the string were
     * &quot;Xz...&quot;, then localized patterns would use 'X' for era and 'z' for year.
     * @serial
     */
<span class="pc" id="L271">    String  localPatternChars = null;</span>

    /**
     * The locale which is used for initializing this DateFormatSymbols object.
     *
     * @since 1.6
     * @serial
     */
<span class="pc" id="L279">    Locale locale = null;</span>

    /* use serialVersionUID from JDK 1.1.4 for interoperability */
    static final long serialVersionUID = -5987973545549424702L;

    /**
     * Returns an array of all locales for which the
     * &lt;code&gt;getInstance&lt;/code&gt; methods of this class can return
     * localized instances.
     * The returned array represents the union of locales supported by the
     * Java runtime and by installed
     * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
     * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
     * instance equal to {@link java.util.Locale#US Locale.US}.
     *
     * @return An array of locales for which localized
     *         &lt;code&gt;DateFormatSymbols&lt;/code&gt; instances are available.
     * @since 1.6
     */
    public static Locale[] getAvailableLocales() {
<span class="fc" id="L299">        LocaleServiceProviderPool pool=</span>
<span class="fc" id="L300">            LocaleServiceProviderPool.getPool(DateFormatSymbolsProvider.class);</span>
<span class="fc" id="L301">        return pool.getAvailableLocales();</span>
    }

    /**
     * Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the default
     * locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;
     * instances for locales supported by the Java runtime itself as well
     * as for those supported by installed
     * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
     * implementations.
     * &lt;p&gt;This is equivalent to calling {@link #getInstance(Locale)
     *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
     * @see java.util.Locale#getDefault(java.util.Locale.Category)
     * @see java.util.Locale.Category#FORMAT
     * @return a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.
     * @since 1.6
     */
    public static final DateFormatSymbols getInstance() {
<span class="fc" id="L319">        return getInstance(Locale.getDefault(Locale.Category.FORMAT));</span>
    }

    /**
     * Gets the &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance for the specified
     * locale.  This method provides access to &lt;code&gt;DateFormatSymbols&lt;/code&gt;
     * instances for locales supported by the Java runtime itself as well
     * as for those supported by installed
     * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
     * implementations.
     * @param locale the given locale.
     * @return a &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance.
     * @exception NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null
     * @since 1.6
     */
    public static final DateFormatSymbols getInstance(Locale locale) {
<span class="fc" id="L335">        DateFormatSymbols dfs = getProviderInstance(locale);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (dfs != null) {</span>
<span class="fc" id="L337">            return dfs;</span>
        }
<span class="nc" id="L339">        throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);</span>
    }

    /**
     * Returns a DateFormatSymbols provided by a provider or found in
     * the cache. Note that this method returns a cached instance,
     * not its clone. Therefore, the instance should never be given to
     * an application.
     */
    static final DateFormatSymbols getInstanceRef(Locale locale) {
<span class="fc" id="L349">        DateFormatSymbols dfs = getProviderInstance(locale);</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (dfs != null) {</span>
<span class="fc" id="L351">            return dfs;</span>
        }
<span class="nc" id="L353">        throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);</span>
    }

    private static DateFormatSymbols getProviderInstance(Locale locale) {
<span class="fc" id="L357">        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DateFormatSymbolsProvider.class, locale);</span>
<span class="fc" id="L358">        DateFormatSymbolsProvider provider = adapter.getDateFormatSymbolsProvider();</span>
<span class="fc" id="L359">        DateFormatSymbols dfsyms = provider.getInstance(locale);</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">        if (dfsyms == null) {</span>
<span class="nc" id="L361">            provider = LocaleProviderAdapter.forJRE().getDateFormatSymbolsProvider();</span>
<span class="nc" id="L362">            dfsyms = provider.getInstance(locale);</span>
        }
<span class="fc" id="L364">        return dfsyms;</span>
    }

    /**
     * Gets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.
     * @return the era strings.
     */
    public String[] getEras() {
<span class="fc" id="L372">        return Arrays.copyOf(eras, eras.length);</span>
    }

    /**
     * Sets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.
     * @param newEras the new era strings.
     */
    public void setEras(String[] newEras) {
<span class="nc" id="L380">        eras = Arrays.copyOf(newEras, newEras.length);</span>
<span class="nc" id="L381">        cachedHashCode = 0;</span>
<span class="nc" id="L382">    }</span>

    /**
     * Gets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.
     *
     * &lt;p&gt;If the language requires different forms for formatting and
     * stand-alone usages, this method returns month names in the
     * formatting form. For example, the preferred month name for
     * January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the
     * formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone
     * form. This method returns {@code &quot;ledna&quot;} in this case. Refer
     * to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;
     * Calendar Elements in the Unicode Locale Data Markup Language
     * (LDML) specification&lt;/a&gt; for more details.
     *
     * @return the month strings.
     */
    public String[] getMonths() {
<span class="fc" id="L400">        return Arrays.copyOf(months, months.length);</span>
    }

    /**
     * Sets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.
     * @param newMonths the new month strings.
     */
    public void setMonths(String[] newMonths) {
<span class="nc" id="L408">        months = Arrays.copyOf(newMonths, newMonths.length);</span>
<span class="nc" id="L409">        cachedHashCode = 0;</span>
<span class="nc" id="L410">    }</span>

    /**
     * Gets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.
     *
     * &lt;p&gt;If the language requires different forms for formatting and
     * stand-alone usages, This method returns short month names in
     * the formatting form. For example, the preferred abbreviation
     * for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the
     * formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone
     * form. This method returns {@code &quot;de gen.&quot;} in this case. Refer
     * to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;
     * Calendar Elements in the Unicode Locale Data Markup Language
     * (LDML) specification&lt;/a&gt; for more details.
     *
     * @return the short month strings.
     */
    public String[] getShortMonths() {
<span class="fc" id="L428">        return Arrays.copyOf(shortMonths, shortMonths.length);</span>
    }

    /**
     * Sets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.
     * @param newShortMonths the new short month strings.
     */
    public void setShortMonths(String[] newShortMonths) {
<span class="nc" id="L436">        shortMonths = Arrays.copyOf(newShortMonths, newShortMonths.length);</span>
<span class="nc" id="L437">        cachedHashCode = 0;</span>
<span class="nc" id="L438">    }</span>

    /**
     * Gets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.
     * @return the weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array.
     */
    public String[] getWeekdays() {
<span class="fc" id="L446">        return Arrays.copyOf(weekdays, weekdays.length);</span>
    }

    /**
     * Sets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.
     * @param newWeekdays the new weekday strings. The array should
     * be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
     */
    public void setWeekdays(String[] newWeekdays) {
<span class="nc" id="L456">        weekdays = Arrays.copyOf(newWeekdays, newWeekdays.length);</span>
<span class="nc" id="L457">        cachedHashCode = 0;</span>
<span class="nc" id="L458">    }</span>

    /**
     * Gets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.
     * @return the short weekday strings. Use &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc. to index the result array.
     */
    public String[] getShortWeekdays() {
<span class="fc" id="L466">        return Arrays.copyOf(shortWeekdays, shortWeekdays.length);</span>
    }

    /**
     * Sets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.
     * @param newShortWeekdays the new short weekday strings. The array should
     * be indexed by &lt;code&gt;Calendar.SUNDAY&lt;/code&gt;,
     * &lt;code&gt;Calendar.MONDAY&lt;/code&gt;, etc.
     */
    public void setShortWeekdays(String[] newShortWeekdays) {
<span class="nc" id="L476">        shortWeekdays = Arrays.copyOf(newShortWeekdays, newShortWeekdays.length);</span>
<span class="nc" id="L477">        cachedHashCode = 0;</span>
<span class="nc" id="L478">    }</span>

    /**
     * Gets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
     * @return the ampm strings.
     */
    public String[] getAmPmStrings() {
<span class="fc" id="L485">        return Arrays.copyOf(ampms, ampms.length);</span>
    }

    /**
     * Sets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
     * @param newAmpms the new ampm strings.
     */
    public void setAmPmStrings(String[] newAmpms) {
<span class="nc" id="L493">        ampms = Arrays.copyOf(newAmpms, newAmpms.length);</span>
<span class="nc" id="L494">        cachedHashCode = 0;</span>
<span class="nc" id="L495">    }</span>

    /**
     * Gets time zone strings.  Use of this method is discouraged; use
     * {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()}
     * instead.
     * &lt;p&gt;
     * The value returned is a
     * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
     * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
     * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
     * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
     * 0..&lt;em&gt;n&lt;/em&gt;-1):
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
     * time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
     * standard time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;/ul&gt;
     * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of
     * the {@link java.util.TimeZone TimeZone} class that are not
     * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
     * All other entries are localized names.  If a zone does not implement
     * daylight saving time, the daylight saving time names should not be used.
     * &lt;p&gt;
     * If {@link #setZoneStrings(String[][]) setZoneStrings} has been called
     * on this &lt;code&gt;DateFormatSymbols&lt;/code&gt; instance, then the strings
     * provided by that call are returned. Otherwise, the returned array
     * contains names provided by the Java runtime and by installed
     * {@link java.util.spi.TimeZoneNameProvider TimeZoneNameProvider}
     * implementations.
     *
     * @return the time zone strings.
     * @see #setZoneStrings(String[][])
     */
    public String[][] getZoneStrings() {
<span class="nc" id="L536">        return getZoneStringsImpl(true);</span>
    }

    /**
     * Sets time zone strings.  The argument must be a
     * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
     * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
     * entry containing the localized names for a single &lt;code&gt;TimeZone&lt;/code&gt;.
     * Each such row contains (with &lt;code&gt;i&lt;/code&gt; ranging from
     * 0..&lt;em&gt;n&lt;/em&gt;-1):
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][0]&lt;/code&gt; - time zone ID&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][1]&lt;/code&gt; - long name of zone in standard
     * time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][2]&lt;/code&gt; - short name of zone in
     * standard time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][3]&lt;/code&gt; - long name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;zoneStrings[i][4]&lt;/code&gt; - short name of zone in daylight
     * saving time&lt;/li&gt;
     * &lt;/ul&gt;
     * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it's one of the valid IDs of
     * the {@link java.util.TimeZone TimeZone} class that are not
     * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
     * All other entries are localized names.
     *
     * @param newZoneStrings the new time zone strings.
     * @exception IllegalArgumentException if the length of any row in
     *    &lt;code&gt;newZoneStrings&lt;/code&gt; is less than 5
     * @exception NullPointerException if &lt;code&gt;newZoneStrings&lt;/code&gt; is null
     * @see #getZoneStrings()
     */
    public void setZoneStrings(String[][] newZoneStrings) {
<span class="nc" id="L569">        String[][] aCopy = new String[newZoneStrings.length][];</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (int i = 0; i &lt; newZoneStrings.length; ++i) {</span>
<span class="nc" id="L571">            int len = newZoneStrings[i].length;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (len &lt; 5) {</span>
<span class="nc" id="L573">                throw new IllegalArgumentException();</span>
            }
<span class="nc" id="L575">            aCopy[i] = Arrays.copyOf(newZoneStrings[i], len);</span>
        }
<span class="nc" id="L577">        zoneStrings = aCopy;</span>
<span class="nc" id="L578">        isZoneStringsSet = true;</span>
<span class="nc" id="L579">        cachedHashCode = 0;</span>
<span class="nc" id="L580">    }</span>

    /**
     * Gets localized date-time pattern characters. For example: 'u', 't', etc.
     * @return the localized date-time pattern characters.
     */
    public String getLocalPatternChars() {
<span class="nc" id="L587">        return localPatternChars;</span>
    }

    /**
     * Sets localized date-time pattern characters. For example: 'u', 't', etc.
     * @param newLocalPatternChars the new localized date-time
     * pattern characters.
     */
    public void setLocalPatternChars(String newLocalPatternChars) {
        // Call toString() to throw an NPE in case the argument is null
<span class="nc" id="L597">        localPatternChars = newLocalPatternChars.toString();</span>
<span class="nc" id="L598">        cachedHashCode = 0;</span>
<span class="nc" id="L599">    }</span>

    /**
     * Overrides Cloneable
     */
    public Object clone()
    {
        try
        {
<span class="fc" id="L608">            DateFormatSymbols other = (DateFormatSymbols)super.clone();</span>
<span class="fc" id="L609">            copyMembers(this, other);</span>
<span class="fc" id="L610">            return other;</span>
<span class="nc" id="L611">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L612">            throw new InternalError(e);</span>
        }
    }

    /**
     * Override hashCode.
     * Generates a hash code for the DateFormatSymbols object.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L622">        int hashCode = cachedHashCode;</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (hashCode == 0) {</span>
<span class="fc" id="L624">            hashCode = 5;</span>
<span class="fc" id="L625">            hashCode = 11 * hashCode + Arrays.hashCode(eras);</span>
<span class="fc" id="L626">            hashCode = 11 * hashCode + Arrays.hashCode(months);</span>
<span class="fc" id="L627">            hashCode = 11 * hashCode + Arrays.hashCode(shortMonths);</span>
<span class="fc" id="L628">            hashCode = 11 * hashCode + Arrays.hashCode(weekdays);</span>
<span class="fc" id="L629">            hashCode = 11 * hashCode + Arrays.hashCode(shortWeekdays);</span>
<span class="fc" id="L630">            hashCode = 11 * hashCode + Arrays.hashCode(ampms);</span>
<span class="fc" id="L631">            hashCode = 11 * hashCode + Arrays.deepHashCode(getZoneStringsWrapper());</span>
<span class="fc" id="L632">            hashCode = 11 * hashCode + Objects.hashCode(localPatternChars);</span>
<span class="fc" id="L633">            cachedHashCode = hashCode;</span>
        }

<span class="fc" id="L636">        return hashCode;</span>
    }

    /**
     * Override equals
     */
    public boolean equals(Object obj)
    {
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (this == obj) return true;</span>
<span class="pc bpc" id="L645" title="2 of 4 branches missed.">        if (obj == null || getClass() != obj.getClass()) return false;</span>
<span class="fc" id="L646">        DateFormatSymbols that = (DateFormatSymbols) obj;</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">        return (Arrays.equals(eras, that.eras)</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(months, that.months)</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(shortMonths, that.shortMonths)</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(weekdays, that.weekdays)</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(shortWeekdays, that.shortWeekdays)</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">                &amp;&amp; Arrays.equals(ampms, that.ampms)</span>
<span class="pc bpc" id="L653" title="2 of 4 branches missed.">                &amp;&amp; Arrays.deepEquals(getZoneStringsWrapper(), that.getZoneStringsWrapper())</span>
                &amp;&amp; ((localPatternChars != null
<span class="pc bpc" id="L655" title="5 of 6 branches missed.">                  &amp;&amp; localPatternChars.equals(that.localPatternChars))</span>
                 || (localPatternChars == null
                  &amp;&amp; that.localPatternChars == null)));
    }

    // =======================privates===============================

    /**
     * Useful constant for defining time zone offsets.
     */
    static final int millisPerHour = 60*60*1000;

    /**
     * Cache to hold DateFormatSymbols instances per Locale.
     */
<span class="fc" id="L670">    private static final ConcurrentMap&lt;Locale, SoftReference&lt;DateFormatSymbols&gt;&gt; cachedInstances</span>
        = new ConcurrentHashMap&lt;&gt;(3);

<span class="pc" id="L673">    private transient int lastZoneIndex = 0;</span>

    /**
     * Cached hash code
     */
<span class="pc" id="L678">    transient volatile int cachedHashCode = 0;</span>

    private void initializeData(Locale desiredLocale) {
<span class="fc" id="L681">        locale = desiredLocale;</span>

        // Copy values of a cached instance if any.
<span class="fc" id="L684">        SoftReference&lt;DateFormatSymbols&gt; ref = cachedInstances.get(locale);</span>
        DateFormatSymbols dfs;
<span class="pc bpc" id="L686" title="1 of 4 branches missed.">        if (ref != null &amp;&amp; (dfs = ref.get()) != null) {</span>
<span class="fc" id="L687">            copyMembers(dfs, this);</span>
<span class="fc" id="L688">            return;</span>
        }

        // Initialize the fields from the ResourceBundle for locale.
<span class="fc" id="L692">        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DateFormatSymbolsProvider.class, locale);</span>
        // Avoid any potential recursions
<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (!(adapter instanceof ResourceBundleBasedAdapter)) {</span>
<span class="fc" id="L695">            adapter = LocaleProviderAdapter.getResourceBundleBased();</span>
        }
<span class="fc" id="L697">        ResourceBundle resource = ((ResourceBundleBasedAdapter)adapter).getLocaleData().getDateFormatData(locale);</span>

        // JRE and CLDR use different keys
        // JRE: Eras, short.Eras and narrow.Eras
        // CLDR: long.Eras, Eras and narrow.Eras
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">        if (resource.containsKey(&quot;Eras&quot;)) {</span>
<span class="fc" id="L703">            eras = resource.getStringArray(&quot;Eras&quot;);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        } else if (resource.containsKey(&quot;long.Eras&quot;)) {</span>
<span class="nc" id="L705">            eras = resource.getStringArray(&quot;long.Eras&quot;);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">        } else if (resource.containsKey(&quot;short.Eras&quot;)) {</span>
<span class="nc" id="L707">            eras = resource.getStringArray(&quot;short.Eras&quot;);</span>
        }
<span class="fc" id="L709">        months = resource.getStringArray(&quot;MonthNames&quot;);</span>
<span class="fc" id="L710">        shortMonths = resource.getStringArray(&quot;MonthAbbreviations&quot;);</span>
<span class="fc" id="L711">        ampms = resource.getStringArray(&quot;AmPmMarkers&quot;);</span>
<span class="fc" id="L712">        localPatternChars = resource.getString(&quot;DateTimePatternChars&quot;);</span>

        // Day of week names are stored in a 1-based array.
<span class="fc" id="L715">        weekdays = toOneBasedArray(resource.getStringArray(&quot;DayNames&quot;));</span>
<span class="fc" id="L716">        shortWeekdays = toOneBasedArray(resource.getStringArray(&quot;DayAbbreviations&quot;));</span>

        // Put a clone in the cache
<span class="fc" id="L719">        ref = new SoftReference&lt;&gt;((DateFormatSymbols)this.clone());</span>
<span class="fc" id="L720">        SoftReference&lt;DateFormatSymbols&gt; x = cachedInstances.putIfAbsent(locale, ref);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        if (x != null) {</span>
<span class="fc" id="L722">            DateFormatSymbols y = x.get();</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">            if (y == null) {</span>
                // Replace the empty SoftReference with ref.
<span class="nc" id="L725">                cachedInstances.put(locale, ref);</span>
            }
        }
<span class="fc" id="L728">    }</span>

    private static String[] toOneBasedArray(String[] src) {
<span class="fc" id="L731">        int len = src.length;</span>
<span class="fc" id="L732">        String[] dst = new String[len + 1];</span>
<span class="fc" id="L733">        dst[0] = &quot;&quot;;</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L735">            dst[i + 1] = src[i];</span>
        }
<span class="fc" id="L737">        return dst;</span>
    }

    /**
     * Package private: used by SimpleDateFormat
     * Gets the index for the given time zone ID to obtain the time zone
     * strings for formatting. The time zone ID is just for programmatic
     * lookup. NOT LOCALIZED!!!
     * @param ID the given time zone ID.
     * @return the index of the given time zone ID.  Returns -1 if
     * the given time zone ID can't be located in the DateFormatSymbols object.
     * @see java.util.SimpleTimeZone
     */
    final int getZoneIndex(String ID) {
<span class="fc" id="L751">        String[][] zoneStrings = getZoneStringsWrapper();</span>

        /*
         * getZoneIndex has been re-written for performance reasons. instead of
         * traversing the zoneStrings array every time, we cache the last used zone
         * index
         */
<span class="pc bpc" id="L758" title="1 of 4 branches missed.">        if (lastZoneIndex &lt; zoneStrings.length &amp;&amp; ID.equals(zoneStrings[lastZoneIndex][0])) {</span>
<span class="fc" id="L759">            return lastZoneIndex;</span>
        }

        /* slow path, search entire list */
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">        for (int index = 0; index &lt; zoneStrings.length; index++) {</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            if (ID.equals(zoneStrings[index][0])) {</span>
<span class="fc" id="L765">                lastZoneIndex = index;</span>
<span class="fc" id="L766">                return index;</span>
            }
        }

<span class="nc" id="L770">        return -1;</span>
    }

    /**
     * Wrapper method to the getZoneStrings(), which is called from inside
     * the java.text package and not to mutate the returned arrays, so that
     * it does not need to create a defensive copy.
     */
    final String[][] getZoneStringsWrapper() {
<span class="fc bfc" id="L779" title="All 2 branches covered.">        if (isSubclassObject()) {</span>
<span class="fc" id="L780">            return getZoneStrings();</span>
        } else {
<span class="fc" id="L782">            return getZoneStringsImpl(false);</span>
        }
    }

    private String[][] getZoneStringsImpl(boolean needsCopy) {
<span class="fc bfc" id="L787" title="All 2 branches covered.">        if (zoneStrings == null) {</span>
<span class="fc" id="L788">            zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);</span>
        }

<span class="pc bpc" id="L791" title="1 of 2 branches missed.">        if (!needsCopy) {</span>
<span class="fc" id="L792">            return zoneStrings;</span>
        }

<span class="nc" id="L795">        int len = zoneStrings.length;</span>
<span class="nc" id="L796">        String[][] aCopy = new String[len][];</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L798">            aCopy[i] = Arrays.copyOf(zoneStrings[i], zoneStrings[i].length);</span>
        }
<span class="nc" id="L800">        return aCopy;</span>
    }

    private boolean isSubclassObject() {
<span class="fc bfc" id="L804" title="All 2 branches covered.">        return !getClass().getName().equals(&quot;java.text.DateFormatSymbols&quot;);</span>
    }

    /**
     * Clones all the data members from the source DateFormatSymbols to
     * the target DateFormatSymbols. This is only for subclasses.
     * @param src the source DateFormatSymbols.
     * @param dst the target DateFormatSymbols.
     */
    private void copyMembers(DateFormatSymbols src, DateFormatSymbols dst)
    {
<span class="fc" id="L815">        dst.eras = Arrays.copyOf(src.eras, src.eras.length);</span>
<span class="fc" id="L816">        dst.months = Arrays.copyOf(src.months, src.months.length);</span>
<span class="fc" id="L817">        dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);</span>
<span class="fc" id="L818">        dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);</span>
<span class="fc" id="L819">        dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);</span>
<span class="fc" id="L820">        dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        if (src.zoneStrings != null) {</span>
<span class="nc" id="L822">            dst.zoneStrings = src.getZoneStringsImpl(true);</span>
        } else {
<span class="fc" id="L824">            dst.zoneStrings = null;</span>
        }
<span class="fc" id="L826">        dst.localPatternChars = src.localPatternChars;</span>
<span class="fc" id="L827">        dst.cachedHashCode = 0;</span>
<span class="fc" id="L828">    }</span>

    /**
     * Write out the default serializable data, after ensuring the
     * &lt;code&gt;zoneStrings&lt;/code&gt; field is initialized in order to make
     * sure the backward compatibility.
     *
     * @since 1.6
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (zoneStrings == null) {</span>
<span class="nc" id="L839">            zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);</span>
        }
<span class="nc" id="L841">        stream.defaultWriteObject();</span>
<span class="nc" id="L842">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>