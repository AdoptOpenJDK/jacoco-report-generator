<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NegotiateAuthentication.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www.protocol.http</a> &gt; <span class="el_source">NegotiateAuthentication.java</span></div><h1>NegotiateAuthentication.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www.protocol.http;

import java.net.URL;
import java.io.IOException;
import java.net.Authenticator.RequestorType;
import java.util.Base64;
import java.util.HashMap;
import sun.net.www.HeaderParser;
import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
import static sun.net.www.protocol.http.AuthScheme.KERBEROS;

/**
 * NegotiateAuthentication:
 *
 * @author weijun.wang@sun.com
 * @since 1.6
 */

class NegotiateAuthentication extends AuthenticationInfo {

    private static final long serialVersionUID = 100L;

    final private HttpCallerInfo hci;

    // These maps are used to manage the GSS availability for diffrent
    // hosts. The key for both maps is the host name.
    // &lt;code&gt;supported&lt;/code&gt; is set when isSupported is checked,
    // if it's true, a cached Negotiator is put into &lt;code&gt;cache&lt;/code&gt;.
    // the cache can be used only once, so after the first use, it's cleaned.
<span class="nc" id="L55">    static HashMap &lt;String, Boolean&gt; supported = null;</span>
<span class="nc" id="L56">    static HashMap &lt;String, Negotiator&gt; cache = null;</span>

    // The HTTP Negotiate Helper
<span class="nc" id="L59">    private Negotiator negotiator = null;</span>

   /**
    * Constructor used for both WWW and proxy entries.
    * @param hci a schemed object.
    */
    public NegotiateAuthentication(HttpCallerInfo hci) {
<span class="nc bnc" id="L66" title="All 2 branches missed.">        super(RequestorType.PROXY==hci.authType ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">              hci.scheme.equalsIgnoreCase(&quot;Negotiate&quot;) ? NEGOTIATE : KERBEROS,</span>
              hci.url,
              &quot;&quot;);
<span class="nc" id="L70">        this.hci = hci;</span>
<span class="nc" id="L71">    }</span>

    /**
     * @return true if this authentication supports preemptive authorization
     */
    @Override
    public boolean supportsPreemptiveAuthorization() {
<span class="nc" id="L78">        return false;</span>
    }

    /**
     * Find out if the HttpCallerInfo supports Negotiate protocol. In order to
     * find out yes or no, an initialization of a Negotiator object against it
     * is tried. The generated object will be cached under the name of ths
     * hostname at a success try.&lt;br&gt;
     *
     * If this method is called for the second time on an HttpCallerInfo with
     * the same hostname, the answer is retrieved from cache.
     *
     * @return true if supported
     */
    synchronized public static boolean isSupported(HttpCallerInfo hci) {
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (supported == null) {</span>
<span class="nc" id="L94">            supported = new HashMap &lt;String, Boolean&gt;();</span>
<span class="nc" id="L95">            cache = new HashMap &lt;String, Negotiator&gt;();</span>
        }
<span class="nc" id="L97">        String hostname = hci.host;</span>
<span class="nc" id="L98">        hostname = hostname.toLowerCase();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (supported.containsKey(hostname)) {</span>
<span class="nc" id="L100">            return supported.get(hostname);</span>
        }

<span class="nc" id="L103">        Negotiator neg = Negotiator.getNegotiator(hci);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (neg != null) {</span>
<span class="nc" id="L105">            supported.put(hostname, true);</span>
            // the only place cache.put is called. here we can make sure
            // the object is valid and the oneToken inside is not null
<span class="nc" id="L108">            cache.put(hostname, neg);</span>
<span class="nc" id="L109">            return true;</span>
        } else {
<span class="nc" id="L111">            supported.put(hostname, false);</span>
<span class="nc" id="L112">            return false;</span>
        }
    }

    /**
     * Not supported. Must use the setHeaders() method
     */
    @Override
    public String getHeaderValue(URL url, String method) {
<span class="nc" id="L121">        throw new RuntimeException (&quot;getHeaderValue not supported&quot;);</span>
    }

    /**
     * Check if the header indicates that the current auth. parameters are stale.
     * If so, then replace the relevant field with the new value
     * and return true. Otherwise return false.
     * returning true means the request can be retried with the same userid/password
     * returning false means we have to go back to the user to ask for a new
     * username password.
     */
    @Override
    public boolean isAuthorizationStale (String header) {
<span class="nc" id="L134">        return false; /* should not be called for Negotiate */</span>
    }

    /**
     * Set header(s) on the given connection.
     * @param conn The connection to apply the header(s) to
     * @param p A source of header values for this connection, not used because
     *          HeaderParser converts the fields to lower case, use raw instead
     * @param raw The raw header field.
     * @return true if all goes well, false if no headers were set.
     */
    @Override
    public synchronized boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {

        try {
            String response;
<span class="nc" id="L150">            byte[] incoming = null;</span>
<span class="nc" id="L151">            String[] parts = raw.split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (parts.length &gt; 1) {</span>
<span class="nc" id="L153">                incoming = Base64.getDecoder().decode(parts[1]);</span>
            }
<span class="nc bnc" id="L155" title="All 2 branches missed.">            response = hci.scheme + &quot; &quot; + Base64.getEncoder().encodeToString(</span>
<span class="nc" id="L156">                        incoming==null?firstToken():nextToken(incoming));</span>

<span class="nc" id="L158">            conn.setAuthenticationProperty(getHeaderName(), response);</span>
<span class="nc" id="L159">            return true;</span>
<span class="nc" id="L160">        } catch (IOException e) {</span>
<span class="nc" id="L161">            return false;</span>
        }
    }

    /**
     * return the first token.
     * @returns the token
     * @throws IOException if &lt;code&gt;Negotiator.getNegotiator()&lt;/code&gt; or
     *                     &lt;code&gt;Negotiator.firstToken()&lt;/code&gt; failed.
     */
    private byte[] firstToken() throws IOException {
<span class="nc" id="L172">        negotiator = null;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (cache != null) {</span>
<span class="nc" id="L174">            synchronized(cache) {</span>
<span class="nc" id="L175">                negotiator = cache.get(getHost());</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">                if (negotiator != null) {</span>
<span class="nc" id="L177">                    cache.remove(getHost()); // so that it is only used once</span>
                }
<span class="nc" id="L179">            }</span>
        }
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (negotiator == null) {</span>
<span class="nc" id="L182">            negotiator = Negotiator.getNegotiator(hci);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (negotiator == null) {</span>
<span class="nc" id="L184">                IOException ioe = new IOException(&quot;Cannot initialize Negotiator&quot;);</span>
<span class="nc" id="L185">                throw ioe;</span>
            }
        }

<span class="nc" id="L189">        return negotiator.firstToken();</span>
    }

    /**
     * return more tokens
     * @param token the token to be fed into &lt;code&gt;negotiator.nextToken()&lt;/code&gt;
     * @returns the token
     * @throws IOException if &lt;code&gt;negotiator.nextToken()&lt;/code&gt; throws Exception.
     *  May happen if the input token is invalid.
     */
    private byte[] nextToken(byte[] token) throws IOException {
<span class="nc" id="L200">        return negotiator.nextToken(token);</span>
    }

    // MS will send a final WWW-Authenticate even if the status is already
    // 200 OK. The token can be fed into initSecContext() again to determine
    // if the server can be trusted. This is not the same concept as Digest's
    // Authentication-Info header.
    //
    // Currently we ignore this header.

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>