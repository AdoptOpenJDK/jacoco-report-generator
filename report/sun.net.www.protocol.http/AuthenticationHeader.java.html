<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AuthenticationHeader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.net.www.protocol.http</a> &gt; <span class="el_source">AuthenticationHeader.java</span></div><h1>AuthenticationHeader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www.protocol.http;

import sun.net.www.*;
import java.util.Iterator;
import java.util.HashMap;

/**
 * This class is used to parse the information in WWW-Authenticate: and Proxy-Authenticate:
 * headers. It searches among multiple header lines and within each header line
 * for the best currently supported scheme. It can also return a HeaderParser
 * containing the challenge data for that particular scheme.
 *
 * Some examples:
 *
 * WWW-Authenticate: Basic realm=&quot;foo&quot; Digest realm=&quot;bar&quot; NTLM
 *  Note the realm parameter must be associated with the particular scheme.
 *
 * or
 *
 * WWW-Authenticate: Basic realm=&quot;foo&quot;
 * WWW-Authenticate: Digest realm=&quot;foo&quot;,qop=&quot;auth&quot;,nonce=&quot;thisisanunlikelynonce&quot;
 * WWW-Authenticate: NTLM
 *
 * or
 *
 * WWW-Authenticate: Basic realm=&quot;foo&quot;
 * WWW-Authenticate: NTLM ASKAJK9893289889QWQIOIONMNMN
 *
 * The last example shows how NTLM breaks the rules of rfc2617 for the structure of
 * the authentication header. This is the reason why the raw header field is used for ntlm.
 *
 * At present, the class chooses schemes in following order :
 *      1. Negotiate (if supported)
 *      2. Kerberos (if supported)
 *      3. Digest
 *      4. NTLM (if supported)
 *      5. Basic
 *
 * This choice can be modified by setting a system property:
 *
 *      -Dhttp.auth.preference=&quot;scheme&quot;
 *
 * which in this case, specifies that &quot;scheme&quot; should be used as the auth scheme when offered
 * disregarding the default prioritisation. If scheme is not offered then the default priority
 * is used.
 *
 * Attention: when http.auth.preference is set as SPNEGO or Kerberos, it's actually &quot;Negotiate
 * with SPNEGO&quot; or &quot;Negotiate with Kerberos&quot;, which means the user will prefer the Negotiate
 * scheme with GSS/SPNEGO or GSS/Kerberos mechanism.
 *
 * This also means that the real &quot;Kerberos&quot; scheme can never be set as a preference.
 */

public class AuthenticationHeader {

    MessageHeader rsp; // the response to be parsed
    HeaderParser preferred;
    String preferred_r; // raw Strings
    private final HttpCallerInfo hci;   // un-schemed, need check

    // When set true, do not use Negotiate even if the response
    // headers suggest so.
<span class="fc" id="L88">    boolean dontUseNegotiate = false;</span>
<span class="fc" id="L89">    static String authPref=null;</span>

    public String toString() {
<span class="nc" id="L92">        return &quot;AuthenticationHeader: prefer &quot; + preferred_r;</span>
    }

    static {
<span class="fc" id="L96">        authPref = java.security.AccessController.doPrivileged(</span>
            new sun.security.action.GetPropertyAction(&quot;http.auth.preference&quot;));

        // http.auth.preference can be set to SPNEGO or Kerberos.
        // In fact they means &quot;Negotiate with SPNEGO&quot; and &quot;Negotiate with
        // Kerberos&quot; separately, so here they are all translated into
        // Negotiate. Read NegotiateAuthentication.java to see how they
        // were used later.

<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (authPref != null) {</span>
<span class="fc" id="L106">            authPref = authPref.toLowerCase();</span>
<span class="pc bpc" id="L107" title="2 of 4 branches missed.">            if(authPref.equals(&quot;spnego&quot;) || authPref.equals(&quot;kerberos&quot;)) {</span>
<span class="nc" id="L108">                authPref = &quot;negotiate&quot;;</span>
            }
        }
<span class="fc" id="L111">    }</span>

    String hdrname; // Name of the header to look for

    /**
     * parse a set of authentication headers and choose the preferred scheme
     * that we support for a given host
     */
    public AuthenticationHeader (String hdrname, MessageHeader response,
<span class="fc" id="L120">            HttpCallerInfo hci, boolean dontUseNegotiate) {</span>
<span class="fc" id="L121">        this.hci = hci;</span>
<span class="fc" id="L122">        this.dontUseNegotiate = dontUseNegotiate;</span>
<span class="fc" id="L123">        rsp = response;</span>
<span class="fc" id="L124">        this.hdrname = hdrname;</span>
<span class="fc" id="L125">        schemes = new HashMap&lt;String,SchemeMapValue&gt;();</span>
<span class="fc" id="L126">        parse();</span>
<span class="fc" id="L127">    }</span>

    public HttpCallerInfo getHttpCallerInfo() {
<span class="nc" id="L130">        return hci;</span>
    }
    /* we build up a map of scheme names mapped to SchemeMapValue objects */
    static class SchemeMapValue {
<span class="fc" id="L134">        SchemeMapValue (HeaderParser h, String r) {raw=r; parser=h;}</span>
        String raw;
        HeaderParser parser;
    }

    HashMap&lt;String, SchemeMapValue&gt; schemes;

    /* Iterate through each header line, and then within each line.
     * If multiple entries exist for a particular scheme (unlikely)
     * then the last one will be used. The
     * preferred scheme that we support will be used.
     */
    private void parse () {
<span class="fc" id="L147">        Iterator&lt;String&gt; iter = rsp.multiValueIterator(hdrname);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L149">            String raw = iter.next();</span>
<span class="fc" id="L150">            HeaderParser hp = new HeaderParser(raw);</span>
<span class="fc" id="L151">            Iterator&lt;String&gt; keys = hp.keys();</span>
            int i, lastSchemeIndex;
<span class="fc bfc" id="L153" title="All 2 branches covered.">            for (i=0, lastSchemeIndex = -1; keys.hasNext(); i++) {</span>
<span class="fc" id="L154">                keys.next();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                if (hp.findValue(i) == null) { /* found a scheme name */</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                    if (lastSchemeIndex != -1) {</span>
<span class="fc" id="L157">                        HeaderParser hpn = hp.subsequence (lastSchemeIndex, i);</span>
<span class="fc" id="L158">                        String scheme = hpn.findKey(0);</span>
<span class="fc" id="L159">                        schemes.put (scheme, new SchemeMapValue (hpn, raw));</span>
                    }
<span class="fc" id="L161">                    lastSchemeIndex = i;</span>
                }
            }
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (i &gt; lastSchemeIndex) {</span>
<span class="fc" id="L165">                HeaderParser hpn = hp.subsequence (lastSchemeIndex, i);</span>
<span class="fc" id="L166">                String scheme = hpn.findKey(0);</span>
<span class="fc" id="L167">                schemes.put(scheme, new SchemeMapValue (hpn, raw));</span>
            }
<span class="fc" id="L169">        }</span>

        /* choose the best of them, the order is
         * negotiate -&gt; kerberos -&gt; digest -&gt; ntlm -&gt; basic
         */
<span class="fc" id="L174">        SchemeMapValue v = null;</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">        if (authPref == null || (v=schemes.get (authPref)) == null) {</span>

<span class="pc bpc" id="L177" title="2 of 4 branches missed.">            if(v == null &amp;&amp; !dontUseNegotiate) {</span>
<span class="fc" id="L178">                SchemeMapValue tmp = schemes.get(&quot;negotiate&quot;);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                if(tmp != null) {</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">                    if(hci == null || !NegotiateAuthentication.isSupported(new HttpCallerInfo(hci, &quot;Negotiate&quot;))) {</span>
<span class="nc" id="L181">                        tmp = null;</span>
                    }
<span class="nc" id="L183">                    v = tmp;</span>
                }
            }

<span class="pc bpc" id="L187" title="2 of 4 branches missed.">            if(v == null &amp;&amp; !dontUseNegotiate) {</span>
<span class="fc" id="L188">                SchemeMapValue tmp = schemes.get(&quot;kerberos&quot;);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                if(tmp != null) {</span>
                    // the Kerberos scheme is only observed in MS ISA Server. In
                    // fact i think it's a Kerberos-mechnism-only Negotiate.
                    // Since the Kerberos scheme is always accompanied with the
                    // Negotiate scheme, so it seems impossible to reach this
                    // line. Even if the user explicitly set http.auth.preference
                    // as Kerberos, it means Negotiate with Kerberos, and the code
                    // will still tried to use Negotiate at first.
                    //
                    // The only chance this line get executed is that the server
                    // only suggest the Kerberos scheme.
<span class="nc bnc" id="L200" title="All 4 branches missed.">                    if(hci == null || !NegotiateAuthentication.isSupported(new HttpCallerInfo(hci, &quot;Kerberos&quot;))) {</span>
<span class="nc" id="L201">                        tmp = null;</span>
                    }
<span class="nc" id="L203">                    v = tmp;</span>
                }
            }

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if(v == null) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">                if ((v=schemes.get (&quot;digest&quot;)) == null) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">                    if (!NTLMAuthenticationProxy.supported</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                        || ((v=schemes.get(&quot;ntlm&quot;))==null)) {</span>
<span class="fc" id="L211">                        v = schemes.get (&quot;basic&quot;);</span>
                    }
                }
            }
        } else {    // authPref != null &amp;&amp; it's found in reponses'
<span class="pc bpc" id="L216" title="3 of 4 branches missed.">            if (dontUseNegotiate &amp;&amp; authPref.equals(&quot;negotiate&quot;)) {</span>
<span class="nc" id="L217">                v = null;</span>
            }
        }

<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (v != null) {</span>
<span class="fc" id="L222">            preferred = v.parser;</span>
<span class="fc" id="L223">            preferred_r = v.raw;</span>
        }
<span class="fc" id="L225">    }</span>

    /**
     * return a header parser containing the preferred authentication scheme (only).
     * The preferred scheme is the strongest of the schemes proposed by the server.
     * The returned HeaderParser will contain the relevant parameters for that scheme
     */
    public HeaderParser headerParser() {
<span class="fc" id="L233">        return preferred;</span>
    }

    /**
     * return the name of the preferred scheme
     */
    public String scheme() {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (preferred != null) {</span>
<span class="fc" id="L241">            return preferred.findKey(0);</span>
        } else {
<span class="nc" id="L243">            return null;</span>
        }
    }

    /* return the raw header field for the preferred/chosen scheme */

    public String raw () {
<span class="fc" id="L250">        return preferred_r;</span>
    }

    /**
     * returns true is the header exists and contains a recognised scheme
     */
    public boolean isPresent () {
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">        return preferred != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>