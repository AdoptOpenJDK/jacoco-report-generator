<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DigestAuthentication.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www.protocol.http</a> &gt; <span class="el_source">DigestAuthentication.java</span></div><h1>DigestAuthentication.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www.protocol.http;

import java.io.*;
import java.net.URL;
import java.net.ProtocolException;
import java.net.PasswordAuthentication;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.util.Random;

import sun.net.www.HeaderParser;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import static sun.net.www.protocol.http.HttpURLConnection.HTTP_CONNECT;

/**
 * DigestAuthentication: Encapsulate an http server authentication using
 * the &quot;Digest&quot; scheme, as described in RFC2069 and updated in RFC2617
 *
 * @author Bill Foote
 */

<span class="pc bpc" id="L48" title="1 of 2 branches missed.">class DigestAuthentication extends AuthenticationInfo {</span>

    private static final long serialVersionUID = 100L;

    private String authMethod;

    // Authentication parameters defined in RFC2617.
    // One instance of these may be shared among several DigestAuthentication
    // instances as a result of a single authorization (for multiple domains)

    static class Parameters implements java.io.Serializable {
        private static final long serialVersionUID = -3584543755194526252L;

        private boolean serverQop; // server proposed qop=auth
        private String opaque;
        private String cnonce;
        private String nonce;
        private String algorithm;
<span class="fc" id="L66">        private int NCcount=0;</span>

        // The H(A1) string used for MD5-sess
        private String  cachedHA1;

        // Force the HA1 value to be recalculated because the nonce has changed
<span class="fc" id="L72">        private boolean redoCachedHA1 = true;</span>

        private static final int cnonceRepeat = 5;

        private static final int cnoncelen = 40; /* number of characters in cnonce */

        private static Random   random;

        static {
<span class="fc" id="L81">            random = new Random();</span>
<span class="fc" id="L82">        }</span>

<span class="fc" id="L84">        Parameters () {</span>
<span class="fc" id="L85">            serverQop = false;</span>
<span class="fc" id="L86">            opaque = null;</span>
<span class="fc" id="L87">            algorithm = null;</span>
<span class="fc" id="L88">            cachedHA1 = null;</span>
<span class="fc" id="L89">            nonce = null;</span>
<span class="fc" id="L90">            setNewCnonce();</span>
<span class="fc" id="L91">        }</span>

        boolean authQop () {
<span class="fc" id="L94">            return serverQop;</span>
        }
        synchronized void incrementNC() {
<span class="fc" id="L97">            NCcount ++;</span>
<span class="fc" id="L98">        }</span>
        synchronized int getNCCount () {
<span class="fc" id="L100">            return NCcount;</span>
        }

<span class="fc" id="L103">        int cnonce_count = 0;</span>

        /* each call increments the counter */
        synchronized String getCnonce () {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            if (cnonce_count &gt;= cnonceRepeat) {</span>
<span class="nc" id="L108">                setNewCnonce();</span>
            }
<span class="fc" id="L110">            cnonce_count++;</span>
<span class="fc" id="L111">            return cnonce;</span>
        }
        synchronized void setNewCnonce () {
<span class="fc" id="L114">            byte bb[] = new byte [cnoncelen/2];</span>
<span class="fc" id="L115">            char cc[] = new char [cnoncelen];</span>
<span class="fc" id="L116">            random.nextBytes (bb);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            for (int  i=0; i&lt;(cnoncelen/2); i++) {</span>
<span class="fc" id="L118">                int x = bb[i] + 128;</span>
<span class="fc" id="L119">                cc[i*2]= (char) ('A'+ x/16);</span>
<span class="fc" id="L120">                cc[i*2+1]= (char) ('A'+ x%16);</span>
            }
<span class="fc" id="L122">            cnonce = new String (cc, 0, cnoncelen);</span>
<span class="fc" id="L123">            cnonce_count = 0;</span>
<span class="fc" id="L124">            redoCachedHA1 = true;</span>
<span class="fc" id="L125">        }</span>

        synchronized void setQop (String qop) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (qop != null) {</span>
<span class="fc" id="L129">                StringTokenizer st = new StringTokenizer (qop, &quot; &quot;);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                while (st.hasMoreTokens()) {</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">                    if (st.nextToken().equalsIgnoreCase (&quot;auth&quot;)) {</span>
<span class="fc" id="L132">                        serverQop = true;</span>
<span class="fc" id="L133">                        return;</span>
                    }
                }
            }
<span class="fc" id="L137">            serverQop = false;</span>
<span class="fc" id="L138">        }</span>

<span class="fc" id="L140">        synchronized String getOpaque () { return opaque;}</span>
<span class="fc" id="L141">        synchronized void setOpaque (String s) { opaque=s;}</span>

<span class="fc" id="L143">        synchronized String getNonce () { return nonce;}</span>

        synchronized void setNonce (String s) {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">            if (!s.equals(nonce)) {</span>
<span class="fc" id="L147">                nonce=s;</span>
<span class="fc" id="L148">                NCcount = 0;</span>
<span class="fc" id="L149">                redoCachedHA1 = true;</span>
            }
<span class="fc" id="L151">        }</span>

        synchronized String getCachedHA1 () {
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (redoCachedHA1) {</span>
<span class="nc" id="L155">                return null;</span>
            } else {
<span class="nc" id="L157">                return cachedHA1;</span>
            }
        }

        synchronized void setCachedHA1 (String s) {
<span class="nc" id="L162">            cachedHA1=s;</span>
<span class="nc" id="L163">            redoCachedHA1=false;</span>
<span class="nc" id="L164">        }</span>

<span class="fc" id="L166">        synchronized String getAlgorithm () { return algorithm;}</span>
<span class="fc" id="L167">        synchronized void setAlgorithm (String s) { algorithm=s;}</span>
    }

    Parameters params;

    /**
     * Create a DigestAuthentication
     */
    public DigestAuthentication(boolean isProxy, URL url, String realm,
                                String authMethod, PasswordAuthentication pw,
                                Parameters params) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        super(isProxy ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,</span>
              AuthScheme.DIGEST,
              url,
              realm);
<span class="fc" id="L182">        this.authMethod = authMethod;</span>
<span class="fc" id="L183">        this.pw = pw;</span>
<span class="fc" id="L184">        this.params = params;</span>
<span class="fc" id="L185">    }</span>

    public DigestAuthentication(boolean isProxy, String host, int port, String realm,
                                String authMethod, PasswordAuthentication pw,
                                Parameters params) {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        super(isProxy ? PROXY_AUTHENTICATION : SERVER_AUTHENTICATION,</span>
              AuthScheme.DIGEST,
              host,
              port,
              realm);
<span class="fc" id="L195">        this.authMethod = authMethod;</span>
<span class="fc" id="L196">        this.pw = pw;</span>
<span class="fc" id="L197">        this.params = params;</span>
<span class="fc" id="L198">    }</span>

    /**
     * @return true if this authentication supports preemptive authorization
     */
    @Override
    public boolean supportsPreemptiveAuthorization() {
<span class="fc" id="L205">        return true;</span>
    }

    /**
     * Reclaculates the request-digest and returns it.
     *
     * &lt;P&gt; Used in the common case where the requestURI is simply the
     * abs_path.
     *
     * @param  url
     *         the URL
     *
     * @param  method
     *         the HTTP method
     *
     * @return the value of the HTTP header this authentication wants set
     */
    @Override
    public String getHeaderValue(URL url, String method) {
<span class="nc" id="L224">        return getHeaderValueImpl(url.getFile(), method);</span>
    }

    /**
     * Reclaculates the request-digest and returns it.
     *
     * &lt;P&gt; Used when the requestURI is not the abs_path. The exact
     * requestURI can be passed as a String.
     *
     * @param  requestURI
     *         the Request-URI from the HTTP request line
     *
     * @param  method
     *         the HTTP method
     *
     * @return the value of the HTTP header this authentication wants set
     */
    String getHeaderValue(String requestURI, String method) {
<span class="nc" id="L242">        return getHeaderValueImpl(requestURI, method);</span>
    }

    /**
     * Check if the header indicates that the current auth. parameters are stale.
     * If so, then replace the relevant field with the new value
     * and return true. Otherwise return false.
     * returning true means the request can be retried with the same userid/password
     * returning false means we have to go back to the user to ask for a new
     * username password.
     */
    @Override
    public boolean isAuthorizationStale (String header) {
<span class="nc" id="L255">        HeaderParser p = new HeaderParser (header);</span>
<span class="nc" id="L256">        String s = p.findValue (&quot;stale&quot;);</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">        if (s == null || !s.equals(&quot;true&quot;))</span>
<span class="nc" id="L258">            return false;</span>
<span class="nc" id="L259">        String newNonce = p.findValue (&quot;nonce&quot;);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">        if (newNonce == null || &quot;&quot;.equals(newNonce)) {</span>
<span class="nc" id="L261">            return false;</span>
        }
<span class="nc" id="L263">        params.setNonce (newNonce);</span>
<span class="nc" id="L264">        return true;</span>
    }

    /**
     * Set header(s) on the given connection.
     * @param conn The connection to apply the header(s) to
     * @param p A source of header values for this connection, if needed.
     * @param raw Raw header values for this connection, if needed.
     * @return true if all goes well, false if no headers were set.
     */
    @Override
    public boolean setHeaders(HttpURLConnection conn, HeaderParser p, String raw) {
<span class="fc" id="L276">        params.setNonce (p.findValue(&quot;nonce&quot;));</span>
<span class="fc" id="L277">        params.setOpaque (p.findValue(&quot;opaque&quot;));</span>
<span class="fc" id="L278">        params.setQop (p.findValue(&quot;qop&quot;));</span>

<span class="fc" id="L280">        String uri=&quot;&quot;;</span>
        String method;
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (type == PROXY_AUTHENTICATION &amp;&amp;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">                conn.tunnelState() == HttpURLConnection.TunnelState.SETUP) {</span>
<span class="nc" id="L284">            uri = HttpURLConnection.connectRequestURI(conn.getURL());</span>
<span class="nc" id="L285">            method = HTTP_CONNECT;</span>
        } else {
            try {
<span class="fc" id="L288">                uri = conn.getRequestURI();</span>
<span class="pc" id="L289">            } catch (IOException e) {}</span>
<span class="fc" id="L290">            method = conn.getMethod();</span>
        }

<span class="pc bpc" id="L293" title="4 of 8 branches missed.">        if (params.nonce == null || authMethod == null || pw == null || realm == null) {</span>
<span class="nc" id="L294">            return false;</span>
        }
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (authMethod.length() &gt;= 1) {</span>
            // Method seems to get converted to all lower case elsewhere.
            // It really does need to start with an upper case letter
            // here.
<span class="fc" id="L300">            authMethod = Character.toUpperCase(authMethod.charAt(0))</span>
<span class="fc" id="L301">                        + authMethod.substring(1).toLowerCase();</span>
        }
<span class="fc" id="L303">        String algorithm = p.findValue(&quot;algorithm&quot;);</span>
<span class="pc bpc" id="L304" title="3 of 4 branches missed.">        if (algorithm == null || &quot;&quot;.equals(algorithm)) {</span>
<span class="fc" id="L305">            algorithm = &quot;MD5&quot;;  // The default, accoriding to rfc2069</span>
        }
<span class="fc" id="L307">        params.setAlgorithm (algorithm);</span>

        // If authQop is true, then the server is doing RFC2617 and
        // has offered qop=auth. We do not support any other modes
        // and if auth is not offered we fallback to the RFC2069 behavior

<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (params.authQop()) {</span>
<span class="fc" id="L314">            params.setNewCnonce();</span>
        }

<span class="fc" id="L317">        String value = getHeaderValueImpl (uri, method);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L319">            conn.setAuthenticationProperty(getHeaderName(), value);</span>
<span class="fc" id="L320">            return true;</span>
        } else {
<span class="nc" id="L322">            return false;</span>
        }
    }

    /* Calculate the Authorization header field given the request URI
     * and based on the authorization information in params
     */
    private String getHeaderValueImpl (String uri, String method) {
        String response;
<span class="fc" id="L331">        char[] passwd = pw.getPassword();</span>
<span class="fc" id="L332">        boolean qop = params.authQop();</span>
<span class="fc" id="L333">        String opaque = params.getOpaque();</span>
<span class="fc" id="L334">        String cnonce = params.getCnonce ();</span>
<span class="fc" id="L335">        String nonce = params.getNonce ();</span>
<span class="fc" id="L336">        String algorithm = params.getAlgorithm ();</span>
<span class="fc" id="L337">        params.incrementNC ();</span>
<span class="fc" id="L338">        int  nccount = params.getNCCount ();</span>
<span class="fc" id="L339">        String ncstring=null;</span>

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (nccount != -1) {</span>
<span class="fc" id="L342">            ncstring = Integer.toHexString (nccount).toLowerCase();</span>
<span class="fc" id="L343">            int len = ncstring.length();</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (len &lt; 8)</span>
<span class="fc" id="L345">                ncstring = zeroPad [len] + ncstring;</span>
        }

        try {
<span class="fc" id="L349">            response = computeDigest(true, pw.getUserName(),passwd,realm,</span>
                                        method, uri, nonce, cnonce, ncstring);
<span class="nc" id="L351">        } catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L352">            return null;</span>
<span class="fc" id="L353">        }</span>

<span class="fc" id="L355">        String ncfield = &quot;\&quot;&quot;;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (qop) {</span>
<span class="fc" id="L357">            ncfield = &quot;\&quot;, nc=&quot; + ncstring;</span>
        }

<span class="fc" id="L360">        String value = authMethod</span>
<span class="fc" id="L361">                        + &quot; username=\&quot;&quot; + pw.getUserName()</span>
                        + &quot;\&quot;, realm=\&quot;&quot; + realm
                        + &quot;\&quot;, nonce=\&quot;&quot; + nonce
                        + ncfield
                        + &quot;, uri=\&quot;&quot; + uri
                        + &quot;\&quot;, response=\&quot;&quot; + response
                        + &quot;\&quot;, algorithm=&quot; + algorithm;
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (opaque != null) {</span>
<span class="nc" id="L369">            value = value + &quot;, opaque=\&quot;&quot; + opaque;</span>
<span class="nc" id="L370">            value = value + &quot;\&quot;&quot;;</span>
        }
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if (cnonce != null) {</span>
<span class="fc" id="L373">            value = value + &quot;, cnonce=\&quot;&quot; + cnonce;</span>
<span class="fc" id="L374">            value = value + &quot;\&quot;&quot;;</span>
        }
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (qop) {</span>
<span class="fc" id="L377">            value = value + &quot;, qop=auth&quot;;</span>
        }
<span class="fc" id="L379">        return value;</span>
    }

    public void checkResponse (String header, String method, URL url)
                                                        throws IOException {
<span class="nc" id="L384">        checkResponse (header, method, url.getFile());</span>
<span class="nc" id="L385">    }</span>

    public void checkResponse (String header, String method, String uri)
                                                        throws IOException {
<span class="fc" id="L389">        char[] passwd = pw.getPassword();</span>
<span class="fc" id="L390">        String username = pw.getUserName();</span>
<span class="fc" id="L391">        boolean qop = params.authQop();</span>
<span class="fc" id="L392">        String opaque = params.getOpaque();</span>
<span class="fc" id="L393">        String cnonce = params.cnonce;</span>
<span class="fc" id="L394">        String nonce = params.getNonce ();</span>
<span class="fc" id="L395">        String algorithm = params.getAlgorithm ();</span>
<span class="fc" id="L396">        int  nccount = params.getNCCount ();</span>
<span class="fc" id="L397">        String ncstring=null;</span>

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">        if (header == null) {</span>
<span class="nc" id="L400">            throw new ProtocolException (&quot;No authentication information in response&quot;);</span>
        }

<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (nccount != -1) {</span>
<span class="fc" id="L404">            ncstring = Integer.toHexString (nccount).toUpperCase();</span>
<span class="fc" id="L405">            int len = ncstring.length();</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">            if (len &lt; 8)</span>
<span class="fc" id="L407">                ncstring = zeroPad [len] + ncstring;</span>
        }
        try {
<span class="fc" id="L410">            String expected = computeDigest(false, username,passwd,realm,</span>
                                        method, uri, nonce, cnonce, ncstring);
<span class="fc" id="L412">            HeaderParser p = new HeaderParser (header);</span>
<span class="fc" id="L413">            String rspauth = p.findValue (&quot;rspauth&quot;);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (rspauth == null) {</span>
<span class="nc" id="L415">                throw new ProtocolException (&quot;No digest in response&quot;);</span>
            }
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (!rspauth.equals (expected)) {</span>
<span class="fc" id="L418">                throw new ProtocolException (&quot;Response digest invalid&quot;);</span>
            }
            /* Check if there is a nextnonce field */
<span class="fc" id="L421">            String nextnonce = p.findValue (&quot;nextnonce&quot;);</span>
<span class="pc bpc" id="L422" title="3 of 4 branches missed.">            if (nextnonce != null &amp;&amp; ! &quot;&quot;.equals(nextnonce)) {</span>
<span class="nc" id="L423">                params.setNonce (nextnonce);</span>
            }

<span class="nc" id="L426">        } catch (NoSuchAlgorithmException ex) {</span>
<span class="nc" id="L427">            throw new ProtocolException (&quot;Unsupported algorithm in response&quot;);</span>
<span class="fc" id="L428">        }</span>
<span class="fc" id="L429">    }</span>

    private String computeDigest(
                        boolean isRequest, String userName, char[] password,
                        String realm, String connMethod,
                        String requestURI, String nonceString,
                        String cnonce, String ncValue
                    ) throws NoSuchAlgorithmException
    {

        String A1, HashA1;
<span class="fc" id="L440">        String algorithm = params.getAlgorithm ();</span>
<span class="fc" id="L441">        boolean md5sess = algorithm.equalsIgnoreCase (&quot;MD5-sess&quot;);</span>

<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        MessageDigest md = MessageDigest.getInstance(md5sess?&quot;MD5&quot;:algorithm);</span>

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (md5sess) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if ((HashA1 = params.getCachedHA1 ()) == null) {</span>
<span class="nc" id="L447">                String s = userName + &quot;:&quot; + realm + &quot;:&quot;;</span>
<span class="nc" id="L448">                String s1 = encode (s, password, md);</span>
<span class="nc" id="L449">                A1 = s1 + &quot;:&quot; + nonceString + &quot;:&quot; + cnonce;</span>
<span class="nc" id="L450">                HashA1 = encode(A1, null, md);</span>
<span class="nc" id="L451">                params.setCachedHA1 (HashA1);</span>
<span class="nc" id="L452">            }</span>
        } else {
<span class="fc" id="L454">            A1 = userName + &quot;:&quot; + realm + &quot;:&quot;;</span>
<span class="fc" id="L455">            HashA1 = encode(A1, password, md);</span>
        }

        String A2;
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (isRequest) {</span>
<span class="fc" id="L460">            A2 = connMethod + &quot;:&quot; + requestURI;</span>
        } else {
<span class="fc" id="L462">            A2 = &quot;:&quot; + requestURI;</span>
        }
<span class="fc" id="L464">        String HashA2 = encode(A2, null, md);</span>
        String combo, finalHash;

<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (params.authQop()) { /* RRC2617 when qop=auth */</span>
<span class="fc" id="L468">            combo = HashA1+ &quot;:&quot; + nonceString + &quot;:&quot; + ncValue + &quot;:&quot; +</span>
                        cnonce + &quot;:auth:&quot; +HashA2;

        } else { /* for compatibility with RFC2069 */
<span class="fc" id="L472">            combo = HashA1 + &quot;:&quot; +</span>
                       nonceString + &quot;:&quot; +
                       HashA2;
        }
<span class="fc" id="L476">        finalHash = encode(combo, null, md);</span>
<span class="fc" id="L477">        return finalHash;</span>
    }

<span class="fc" id="L480">    private final static char charArray[] = {</span>
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };

<span class="fc" id="L485">    private final static String zeroPad[] = {</span>
        // 0         1          2         3        4       5      6     7
        &quot;00000000&quot;, &quot;0000000&quot;, &quot;000000&quot;, &quot;00000&quot;, &quot;0000&quot;, &quot;000&quot;, &quot;00&quot;, &quot;0&quot;
    };

    private String encode(String src, char[] passwd, MessageDigest md) {
        try {
<span class="fc" id="L492">            md.update(src.getBytes(&quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L493">        } catch (java.io.UnsupportedEncodingException uee) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            assert false;</span>
<span class="fc" id="L495">        }</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (passwd != null) {</span>
<span class="fc" id="L497">            byte[] passwdBytes = new byte[passwd.length];</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            for (int i=0; i&lt;passwd.length; i++)</span>
<span class="fc" id="L499">                passwdBytes[i] = (byte)passwd[i];</span>
<span class="fc" id="L500">            md.update(passwdBytes);</span>
<span class="fc" id="L501">            Arrays.fill(passwdBytes, (byte)0x00);</span>
        }
<span class="fc" id="L503">        byte[] digest = md.digest();</span>

<span class="fc" id="L505">        StringBuffer res = new StringBuffer(digest.length * 2);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        for (int i = 0; i &lt; digest.length; i++) {</span>
<span class="fc" id="L507">            int hashchar = ((digest[i] &gt;&gt;&gt; 4) &amp; 0xf);</span>
<span class="fc" id="L508">            res.append(charArray[hashchar]);</span>
<span class="fc" id="L509">            hashchar = (digest[i] &amp; 0xf);</span>
<span class="fc" id="L510">            res.append(charArray[hashchar]);</span>
        }
<span class="fc" id="L512">        return res.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>