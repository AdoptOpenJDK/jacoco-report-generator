<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HttpURLConnection.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www.protocol.http</a> &gt; <span class="el_source">HttpURLConnection.java</span></div><h1>HttpURLConnection.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www.protocol.http;

import java.util.Arrays;
import java.net.URL;
import java.net.URLConnection;
import java.net.ProtocolException;
import java.net.HttpRetryException;
import java.net.PasswordAuthentication;
import java.net.Authenticator;
import java.net.HttpCookie;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.net.SocketTimeoutException;
import java.net.SocketPermission;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.URI;
import java.net.InetSocketAddress;
import java.net.CookieHandler;
import java.net.ResponseCache;
import java.net.CacheResponse;
import java.net.SecureCacheResponse;
import java.net.CacheRequest;
import java.net.URLPermission;
import java.net.Authenticator.RequestorType;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.io.*;
import java.net.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.Map;
import java.util.List;
import java.util.Locale;
import java.util.StringTokenizer;
import java.util.Iterator;
import java.util.HashSet;
import java.util.HashMap;
import java.util.Set;
import sun.net.*;
import sun.net.www.*;
import sun.net.www.http.HttpClient;
import sun.net.www.http.PosterOutputStream;
import sun.net.www.http.ChunkedInputStream;
import sun.net.www.http.ChunkedOutputStream;
import sun.util.logging.PlatformLogger;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import java.net.MalformedURLException;
import java.nio.ByteBuffer;
import static sun.net.www.protocol.http.AuthScheme.BASIC;
import static sun.net.www.protocol.http.AuthScheme.DIGEST;
import static sun.net.www.protocol.http.AuthScheme.NTLM;
import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
import static sun.net.www.protocol.http.AuthScheme.UNKNOWN;

/**
 * A class to represent an HTTP connection to a remote object.
 */


public class HttpURLConnection extends java.net.HttpURLConnection {

<span class="fc" id="L92">    static String HTTP_CONNECT = &quot;CONNECT&quot;;</span>

    static final String version;
    public static final String userAgent;

    /* max # of allowed re-directs */
    static final int defaultmaxRedirects = 20;
    static final int maxRedirects;

    /* Not all servers support the (Proxy)-Authentication-Info headers.
     * By default, we don't require them to be sent
     */
    static final boolean validateProxy;
    static final boolean validateServer;

    private StreamingOutputStream strOutputStream;
    private final static String RETRY_MSG1 =
        &quot;cannot retry due to proxy authentication, in streaming mode&quot;;
    private final static String RETRY_MSG2 =
        &quot;cannot retry due to server authentication, in streaming mode&quot;;
    private final static String RETRY_MSG3 =
        &quot;cannot retry due to redirection, in streaming mode&quot;;

    /*
     * System properties related to error stream handling:
     *
     * sun.net.http.errorstream.enableBuffering = &lt;boolean&gt;
     *
     * With the above system property set to true (default is false),
     * when the response code is &gt;=400, the HTTP handler will try to
     * buffer the response body (up to a certain amount and within a
     * time limit). Thus freeing up the underlying socket connection
     * for reuse. The rationale behind this is that usually when the
     * server responds with a &gt;=400 error (client error or server
     * error, such as 404 file not found), the server will send a
     * small response body to explain who to contact and what to do to
     * recover. With this property set to true, even if the
     * application doesn't call getErrorStream(), read the response
     * body, and then call close(), the underlying socket connection
     * can still be kept-alive and reused. The following two system
     * properties provide further control to the error stream
     * buffering behaviour.
     *
     * sun.net.http.errorstream.timeout = &lt;int&gt;
     *     the timeout (in millisec) waiting the error stream
     *     to be buffered; default is 300 ms
     *
     * sun.net.http.errorstream.bufferSize = &lt;int&gt;
     *     the size (in bytes) to use for the buffering the error stream;
     *     default is 4k
     */


    /* Should we enable buffering of error streams? */
<span class="fc" id="L146">    private static boolean enableESBuffer = false;</span>

    /* timeout waiting for read for buffered error stream;
     */
<span class="fc" id="L150">    private static int timeout4ESBuffer = 0;</span>

    /* buffer size for buffered error stream;
    */
<span class="fc" id="L154">    private static int bufSize4ES = 0;</span>

    /*
     * Restrict setting of request headers through the public api
     * consistent with JavaScript XMLHttpRequest2 with a few
     * exceptions. Disallowed headers are silently ignored for
     * backwards compatibility reasons rather than throwing a
     * SecurityException. For example, some applets set the
     * Host header since old JREs did not implement HTTP 1.1.
     * Additionally, any header starting with Sec- is
     * disallowed.
     *
     * The following headers are allowed for historical reasons:
     *
     * Accept-Charset, Accept-Encoding, Cookie, Cookie2, Date,
     * Referer, TE, User-Agent, headers beginning with Proxy-.
     *
     * The following headers are allowed in a limited form:
     *
     * Connection: close
     *
     * See http://www.w3.org/TR/XMLHttpRequest2.
     */
    private static final boolean allowRestrictedHeaders;
    private static final Set&lt;String&gt; restrictedHeaderSet;
<span class="fc" id="L179">    private static final String[] restrictedHeaders = {</span>
        /* Restricted by XMLHttpRequest2 */
        //&quot;Accept-Charset&quot;,
        //&quot;Accept-Encoding&quot;,
        &quot;Access-Control-Request-Headers&quot;,
        &quot;Access-Control-Request-Method&quot;,
        &quot;Connection&quot;, /* close is allowed */
        &quot;Content-Length&quot;,
        //&quot;Cookie&quot;,
        //&quot;Cookie2&quot;,
        &quot;Content-Transfer-Encoding&quot;,
        //&quot;Date&quot;,
        //&quot;Expect&quot;,
        &quot;Host&quot;,
        &quot;Keep-Alive&quot;,
        &quot;Origin&quot;,
        // &quot;Referer&quot;,
        // &quot;TE&quot;,
        &quot;Trailer&quot;,
        &quot;Transfer-Encoding&quot;,
        &quot;Upgrade&quot;,
        //&quot;User-Agent&quot;,
        &quot;Via&quot;
    };

    static {
<span class="fc" id="L205">        maxRedirects = java.security.AccessController.doPrivileged(</span>
            new sun.security.action.GetIntegerAction(
<span class="fc" id="L207">                &quot;http.maxRedirects&quot;, defaultmaxRedirects)).intValue();</span>
<span class="fc" id="L208">        version = java.security.AccessController.doPrivileged(</span>
                    new sun.security.action.GetPropertyAction(&quot;java.version&quot;));
<span class="fc" id="L210">        String agent = java.security.AccessController.doPrivileged(</span>
                    new sun.security.action.GetPropertyAction(&quot;http.agent&quot;));
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (agent == null) {</span>
<span class="fc" id="L213">            agent = &quot;Java/&quot;+version;</span>
        } else {
<span class="fc" id="L215">            agent = agent + &quot; Java/&quot;+version;</span>
        }
<span class="fc" id="L217">        userAgent = agent;</span>
<span class="fc" id="L218">        validateProxy = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(
<span class="fc" id="L220">                    &quot;http.auth.digest.validateProxy&quot;)).booleanValue();</span>
<span class="fc" id="L221">        validateServer = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(
<span class="fc" id="L223">                    &quot;http.auth.digest.validateServer&quot;)).booleanValue();</span>

<span class="fc" id="L225">        enableESBuffer = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(
<span class="fc" id="L227">                    &quot;sun.net.http.errorstream.enableBuffering&quot;)).booleanValue();</span>
<span class="fc" id="L228">        timeout4ESBuffer = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetIntegerAction(
<span class="fc" id="L230">                    &quot;sun.net.http.errorstream.timeout&quot;, 300)).intValue();</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (timeout4ESBuffer &lt;= 0) {</span>
<span class="nc" id="L232">            timeout4ESBuffer = 300; // use the default</span>
        }

<span class="fc" id="L235">        bufSize4ES = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetIntegerAction(
<span class="fc" id="L237">                    &quot;sun.net.http.errorstream.bufferSize&quot;, 4096)).intValue();</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        if (bufSize4ES &lt;= 0) {</span>
<span class="nc" id="L239">            bufSize4ES = 4096; // use the default</span>
        }

<span class="fc" id="L242">        allowRestrictedHeaders = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetBooleanAction(
<span class="fc" id="L244">                    &quot;sun.net.http.allowRestrictedHeaders&quot;)).booleanValue();</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (!allowRestrictedHeaders) {</span>
<span class="fc" id="L246">            restrictedHeaderSet = new HashSet&lt;String&gt;(restrictedHeaders.length);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">            for (int i=0; i &lt; restrictedHeaders.length; i++) {</span>
<span class="fc" id="L248">                restrictedHeaderSet.add(restrictedHeaders[i].toLowerCase());</span>
            }
        } else {
<span class="nc" id="L251">            restrictedHeaderSet = null;</span>
        }
    }

    static final String httpVersion = &quot;HTTP/1.1&quot;;
    static final String acceptString =
        &quot;text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2&quot;;

    // the following http request headers should NOT have their values
    // returned for security reasons.
<span class="fc" id="L261">    private static final String[] EXCLUDE_HEADERS = {</span>
            &quot;Proxy-Authorization&quot;,
            &quot;Authorization&quot;
    };

    // also exclude system cookies when any might be set
<span class="fc" id="L267">    private static final String[] EXCLUDE_HEADERS2= {</span>
            &quot;Proxy-Authorization&quot;,
            &quot;Authorization&quot;,
            &quot;Cookie&quot;,
            &quot;Cookie2&quot;
    };

    protected HttpClient http;
    protected Handler handler;
    protected Proxy instProxy;

    private CookieHandler cookieHandler;
    private final ResponseCache cacheHandler;

    // the cached response, and cached response headers and body
    protected CacheResponse cachedResponse;
    private MessageHeader cachedHeaders;
    private InputStream cachedInputStream;

    /* output stream to server */
<span class="fc" id="L287">    protected PrintStream ps = null;</span>


    /* buffered error stream */
<span class="fc" id="L291">    private InputStream errorStream = null;</span>

    /* User set Cookies */
<span class="fc" id="L294">    private boolean setUserCookies = true;</span>
<span class="fc" id="L295">    private String userCookies = null;</span>
<span class="fc" id="L296">    private String userCookies2 = null;</span>

    /* We only have a single static authenticator for now.
     * REMIND:  backwards compatibility with JDK 1.1.  Should be
     * eliminated for JDK 2.0.
     */
    @Deprecated
    private static HttpAuthenticator defaultAuth;

    /* all the headers we send
     * NOTE: do *NOT* dump out the content of 'requests' in the
     * output or stacktrace since it may contain security-sensitive
     * headers such as those defined in EXCLUDE_HEADERS.
     */
    private MessageHeader requests;

    /* The headers actually set by the user are recorded here also
     */
    private MessageHeader userHeaders;

    /* Headers and request method cannot be changed
     * once this flag is set in :-
     *     - getOutputStream()
     *     - getInputStream())
     *     - connect()
     * Access synchronized on this.
     */
<span class="fc" id="L323">    private boolean connecting = false;</span>

    /* The following two fields are only used with Digest Authentication */
    String domain;      /* The list of authentication domains */
    DigestAuthentication.Parameters digestparams;

    /* Current credentials in use */
<span class="fc" id="L330">    AuthenticationInfo  currentProxyCredentials = null;</span>
<span class="fc" id="L331">    AuthenticationInfo  currentServerCredentials = null;</span>
<span class="fc" id="L332">    boolean             needToCheck = true;</span>
<span class="fc" id="L333">    private boolean doingNTLM2ndStage = false; /* doing the 2nd stage of an NTLM server authentication */</span>
<span class="fc" id="L334">    private boolean doingNTLMp2ndStage = false; /* doing the 2nd stage of an NTLM proxy authentication */</span>

    /* try auth without calling Authenticator. Used for transparent NTLM authentication */
<span class="fc" id="L337">    private boolean tryTransparentNTLMServer = true;</span>
<span class="fc" id="L338">    private boolean tryTransparentNTLMProxy = true;</span>

    /* Used by Windows specific code */
    private Object authObj;

    /* Set if the user is manually setting the Authorization or Proxy-Authorization headers */
    boolean isUserServerAuth;
    boolean isUserProxyAuth;

    String serverAuthKey, proxyAuthKey;

    /* Progress source */
    protected ProgressSource pi;

    /* all the response headers we get back */
    private MessageHeader responses;
    /* the stream _from_ the server */
<span class="fc" id="L355">    private InputStream inputStream = null;</span>
    /* post stream _to_ the server, if any */
<span class="fc" id="L357">    private PosterOutputStream poster = null;</span>

    /* Indicates if the std. request headers have been set in requests. */
<span class="fc" id="L360">    private boolean setRequests=false;</span>

    /* Indicates whether a request has already failed or not */
<span class="fc" id="L363">    private boolean failedOnce=false;</span>

    /* Remembered Exception, we will throw it again if somebody
       calls getInputStream after disconnect */
<span class="fc" id="L367">    private Exception rememberedException = null;</span>

    /* If we decide we want to reuse a client, we put it here */
<span class="fc" id="L370">    private HttpClient reuseClient = null;</span>

    /* Tunnel states */
<span class="pc" id="L373">    public enum TunnelState {</span>
        /* No tunnel */
<span class="fc" id="L375">        NONE,</span>

        /* Setting up a tunnel */
<span class="fc" id="L378">        SETUP,</span>

        /* Tunnel has been successfully setup */
<span class="fc" id="L381">        TUNNELING</span>
    }

<span class="fc" id="L384">    private TunnelState tunnelState = TunnelState.NONE;</span>

    /* Redefine timeouts from java.net.URLConnection as we need -1 to mean
     * not set. This is to ensure backward compatibility.
     */
<span class="fc" id="L389">    private int connectTimeout = NetworkClient.DEFAULT_CONNECT_TIMEOUT;</span>
<span class="fc" id="L390">    private int readTimeout = NetworkClient.DEFAULT_READ_TIMEOUT;</span>

    /* A permission converted from a URLPermission */
    private SocketPermission socketPermission;

    /* Logging support */
<span class="fc" id="L396">    private static final PlatformLogger logger =</span>
<span class="fc" id="L397">            PlatformLogger.getLogger(&quot;sun.net.www.protocol.http.HttpURLConnection&quot;);</span>

    /*
     * privileged request password authentication
     *
     */
    private static PasswordAuthentication
    privilegedRequestPasswordAuthentication(
                            final String host,
                            final InetAddress addr,
                            final int port,
                            final String protocol,
                            final String prompt,
                            final String scheme,
                            final URL url,
                            final RequestorType authType) {
<span class="fc" id="L413">        return java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L414">            new java.security.PrivilegedAction&lt;PasswordAuthentication&gt;() {</span>
                public PasswordAuthentication run() {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L417">                        logger.finest(&quot;Requesting Authentication: host =&quot; + host + &quot; url = &quot; + url);</span>
                    }
<span class="fc" id="L419">                    PasswordAuthentication pass = Authenticator.requestPasswordAuthentication(</span>
                        host, addr, port, protocol,
                        prompt, scheme, url, authType);
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                        logger.finest(&quot;Authentication returned: &quot; + (pass != null ? pass.toString() : &quot;null&quot;));</span>
                    }
<span class="fc" id="L425">                    return pass;</span>
                }
            });
    }

    private boolean isRestrictedHeader(String key, String value) {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (allowRestrictedHeaders) {</span>
<span class="nc" id="L432">            return false;</span>
        }

<span class="fc" id="L435">        key = key.toLowerCase();</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (restrictedHeaderSet.contains(key)) {</span>
            /*
             * Exceptions to restricted headers:
             *
             * Allow &quot;Connection: close&quot;.
             */
<span class="nc bnc" id="L442" title="All 4 branches missed.">            if (key.equals(&quot;connection&quot;) &amp;&amp; value.equalsIgnoreCase(&quot;close&quot;)) {</span>
<span class="nc" id="L443">                return false;</span>
            }
<span class="nc" id="L445">            return true;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        } else if (key.startsWith(&quot;sec-&quot;)) {</span>
<span class="nc" id="L447">            return true;</span>
        }
<span class="fc" id="L449">        return false;</span>
    }

    /*
     * Checks the validity of http message header and whether the header
     * is restricted and throws IllegalArgumentException if invalid or
     * restricted.
     */
    private boolean isExternalMessageHeaderAllowed(String key, String value) {
<span class="fc" id="L458">        checkMessageHeader(key, value);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (!isRestrictedHeader(key, value)) {</span>
<span class="fc" id="L460">            return true;</span>
        }
<span class="nc" id="L462">        return false;</span>
    }

    /* Logging support */
    public static PlatformLogger getHttpLogger() {
<span class="fc" id="L467">        return logger;</span>
    }

    /* Used for Windows NTLM implementation */
    public Object authObj() {
<span class="nc" id="L472">        return authObj;</span>
    }

    public void authObj(Object authObj) {
<span class="nc" id="L476">        this.authObj = authObj;</span>
<span class="nc" id="L477">    }</span>

    /*
     * checks the validity of http message header and throws
     * IllegalArgumentException if invalid.
     */
    private void checkMessageHeader(String key, String value) {
<span class="fc" id="L484">        char LF = '\n';</span>
<span class="fc" id="L485">        int index = key.indexOf(LF);</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (index != -1) {</span>
<span class="nc" id="L487">            throw new IllegalArgumentException(</span>
                &quot;Illegal character(s) in message header field: &quot; + key);
        }
        else {
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L492">                return;</span>
            }

<span class="fc" id="L495">            index = value.indexOf(LF);</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            while (index != -1) {</span>
<span class="nc" id="L497">                index++;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (index &lt; value.length()) {</span>
<span class="nc" id="L499">                    char c = value.charAt(index);</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">                    if ((c==' ') || (c=='\t')) {</span>
                        // ok, check the next occurrence
<span class="nc" id="L502">                        index = value.indexOf(LF, index);</span>
<span class="nc" id="L503">                        continue;</span>
                    }
                }
<span class="nc" id="L506">                throw new IllegalArgumentException(</span>
                    &quot;Illegal character(s) in message header value: &quot; + value);
            }
        }
<span class="fc" id="L510">    }</span>

    public synchronized void setRequestMethod(String method)
                        throws ProtocolException {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (connecting) {</span>
<span class="nc" id="L515">            throw new IllegalStateException(&quot;connect in progress&quot;);</span>
        }
<span class="fc" id="L517">        super.setRequestMethod(method);</span>
<span class="fc" id="L518">    }</span>

    /* adds the standard key/val pairs to reqests if necessary &amp; write to
     * given PrintStream
     */
    private void writeRequests() throws IOException {
        /* print all message headers in the MessageHeader
         * onto the wire - all the ones we've set and any
         * others that have been set
         */
        // send any pre-emptive authentication
<span class="fc bfc" id="L529" title="All 4 branches covered.">        if (http.usingProxy &amp;&amp; tunnelState() != TunnelState.TUNNELING) {</span>
<span class="fc" id="L530">            setPreemptiveProxyAuthentication(requests);</span>
        }
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (!setRequests) {</span>

            /* We're very particular about the order in which we
             * set the request headers here.  The order should not
             * matter, but some careless CGI programs have been
             * written to expect a very particular order of the
             * standard headers.  To name names, the order in which
             * Navigator3.0 sends them.  In particular, we make *sure*
             * to send Content-type: &lt;&gt; and Content-length:&lt;&gt; second
             * to last and last, respectively, in the case of a POST
             * request.
             */
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (!failedOnce)</span>
<span class="fc" id="L545">                requests.prepend(method + &quot; &quot; + getRequestURI()+&quot; &quot;  +</span>
                                 httpVersion, null);
<span class="fc bfc" id="L547" title="All 2 branches covered.">            if (!getUseCaches()) {</span>
<span class="fc" id="L548">                requests.setIfNotSet (&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span>
<span class="fc" id="L549">                requests.setIfNotSet (&quot;Pragma&quot;, &quot;no-cache&quot;);</span>
            }
<span class="fc" id="L551">            requests.setIfNotSet(&quot;User-Agent&quot;, userAgent);</span>
<span class="fc" id="L552">            int port = url.getPort();</span>
<span class="fc" id="L553">            String host = url.getHost();</span>
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">            if (port != -1 &amp;&amp; port != url.getDefaultPort()) {</span>
<span class="fc" id="L555">                host += &quot;:&quot; + String.valueOf(port);</span>
            }
<span class="fc" id="L557">            requests.setIfNotSet(&quot;Host&quot;, host);</span>
<span class="fc" id="L558">            requests.setIfNotSet(&quot;Accept&quot;, acceptString);</span>

            /*
             * For HTTP/1.1 the default behavior is to keep connections alive.
             * However, we may be talking to a 1.0 server so we should set
             * keep-alive just in case, except if we have encountered an error
             * or if keep alive is disabled via a system property
             */

            // Try keep-alive only on first attempt
<span class="fc bfc" id="L568" title="All 4 branches covered.">            if (!failedOnce &amp;&amp; http.getHttpKeepAliveSet()) {</span>
<span class="fc bfc" id="L569" title="All 4 branches covered.">                if (http.usingProxy &amp;&amp; tunnelState() != TunnelState.TUNNELING) {</span>
<span class="fc" id="L570">                    requests.setIfNotSet(&quot;Proxy-Connection&quot;, &quot;keep-alive&quot;);</span>
                } else {
<span class="fc" id="L572">                    requests.setIfNotSet(&quot;Connection&quot;, &quot;keep-alive&quot;);</span>
                }
            } else {
                /*
                 * RFC 2616 HTTP/1.1 section 14.10 says:
                 * HTTP/1.1 applications that do not support persistent
                 * connections MUST include the &quot;close&quot; connection option
                 * in every message
                 */
<span class="fc" id="L581">                requests.setIfNotSet(&quot;Connection&quot;, &quot;close&quot;);</span>
            }
            // Set modified since if necessary
<span class="fc" id="L584">            long modTime = getIfModifiedSince();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">            if (modTime != 0 ) {</span>
<span class="fc" id="L586">                Date date = new Date(modTime);</span>
                //use the preferred date format according to RFC 2068(HTTP1.1),
                // RFC 822 and RFC 1123
<span class="fc" id="L589">                SimpleDateFormat fo =</span>
                  new SimpleDateFormat (&quot;EEE, dd MMM yyyy HH:mm:ss 'GMT'&quot;, Locale.US);
<span class="fc" id="L591">                fo.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="fc" id="L592">                requests.setIfNotSet(&quot;If-Modified-Since&quot;, fo.format(date));</span>
            }
            // check for preemptive authorization
<span class="fc" id="L595">            AuthenticationInfo sauth = AuthenticationInfo.getServerAuth(url);</span>
<span class="pc bpc" id="L596" title="1 of 4 branches missed.">            if (sauth != null &amp;&amp; sauth.supportsPreemptiveAuthorization() ) {</span>
                // Sets &quot;Authorization&quot;
<span class="fc" id="L598">                requests.setIfNotSet(sauth.getHeaderName(), sauth.getHeaderValue(url,method));</span>
<span class="fc" id="L599">                currentServerCredentials = sauth;</span>
            }

<span class="pc bpc" id="L602" title="1 of 6 branches missed.">            if (!method.equals(&quot;PUT&quot;) &amp;&amp; (poster != null || streaming())) {</span>
<span class="fc" id="L603">                requests.setIfNotSet (&quot;Content-type&quot;,</span>
                        &quot;application/x-www-form-urlencoded&quot;);
            }

<span class="fc" id="L607">            boolean chunked = false;</span>

<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (streaming()) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">                if (chunkLength != -1) {</span>
<span class="fc" id="L611">                    requests.set (&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span>
<span class="fc" id="L612">                    chunked = true;</span>
                } else { /* fixed content length */
<span class="fc bfc" id="L614" title="All 2 branches covered.">                    if (fixedContentLengthLong != -1) {</span>
<span class="fc" id="L615">                        requests.set (&quot;Content-Length&quot;,</span>
<span class="fc" id="L616">                                      String.valueOf(fixedContentLengthLong));</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                    } else if (fixedContentLength != -1) {</span>
<span class="fc" id="L618">                        requests.set (&quot;Content-Length&quot;,</span>
<span class="fc" id="L619">                                      String.valueOf(fixedContentLength));</span>
                    }
                }
<span class="fc bfc" id="L622" title="All 2 branches covered.">            } else if (poster != null) {</span>
                /* add Content-Length &amp; POST/PUT data */
<span class="fc" id="L624">                synchronized (poster) {</span>
                    /* close it, so no more data can be added */
<span class="fc" id="L626">                    poster.close();</span>
<span class="fc" id="L627">                    requests.set(&quot;Content-Length&quot;,</span>
<span class="fc" id="L628">                                 String.valueOf(poster.size()));</span>
<span class="pc" id="L629">                }</span>
            }

<span class="fc bfc" id="L632" title="All 2 branches covered.">            if (!chunked) {</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                if (requests.findValue(&quot;Transfer-Encoding&quot;) != null) {</span>
<span class="nc" id="L634">                    requests.remove(&quot;Transfer-Encoding&quot;);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.WARNING)) {</span>
<span class="nc" id="L636">                        logger.warning(</span>
                            &quot;use streaming mode for chunked encoding&quot;);
                    }
                }
            }

            // get applicable cookies based on the uri and request headers
            // add them to the existing request headers
<span class="fc" id="L644">            setCookieHeader();</span>

<span class="fc" id="L646">            setRequests=true;</span>
        }
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">        if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L649">            logger.fine(requests.toString());</span>
        }
<span class="fc" id="L651">        http.writeRequests(requests, poster, streaming());</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (ps.checkError()) {</span>
<span class="fc" id="L653">            String proxyHost = http.getProxyHostUsed();</span>
<span class="fc" id="L654">            int proxyPort = http.getProxyPortUsed();</span>
<span class="fc" id="L655">            disconnectInternal();</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (failedOnce) {</span>
<span class="nc" id="L657">                throw new IOException(&quot;Error writing to server&quot;);</span>
            } else { // try once more
<span class="fc" id="L659">                failedOnce=true;</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">                if (proxyHost != null) {</span>
<span class="nc" id="L661">                    setProxiedClient(url, proxyHost, proxyPort);</span>
                } else {
<span class="fc" id="L663">                    setNewClient (url);</span>
                }
<span class="fc" id="L665">                ps = (PrintStream) http.getOutputStream();</span>
<span class="fc" id="L666">                connected=true;</span>
<span class="fc" id="L667">                responses = new MessageHeader();</span>
<span class="fc" id="L668">                setRequests=false;</span>
<span class="fc" id="L669">                writeRequests();</span>
            }
        }
<span class="fc" id="L672">    }</span>


    /**
     * Create a new HttpClient object, bypassing the cache of
     * HTTP client objects/connections.
     *
     * @param url       the URL being accessed
     */
    protected void setNewClient (URL url)
    throws IOException {
<span class="nc" id="L683">        setNewClient(url, false);</span>
<span class="nc" id="L684">    }</span>

    /**
     * Obtain a HttpsClient object. Use the cached copy if specified.
     *
     * @param url       the URL being accessed
     * @param useCache  whether the cached connection should be used
     *        if present
     */
    protected void setNewClient (URL url, boolean useCache)
        throws IOException {
<span class="nc" id="L695">        http = HttpClient.New(url, null, -1, useCache, connectTimeout, this);</span>
<span class="nc" id="L696">        http.setReadTimeout(readTimeout);</span>
<span class="nc" id="L697">    }</span>


    /**
     * Create a new HttpClient object, set up so that it uses
     * per-instance proxying to the given HTTP proxy.  This
     * bypasses the cache of HTTP client objects/connections.
     *
     * @param url       the URL being accessed
     * @param proxyHost the proxy host to use
     * @param proxyPort the proxy port to use
     */
    protected void setProxiedClient (URL url, String proxyHost, int proxyPort)
    throws IOException {
<span class="nc" id="L711">        setProxiedClient(url, proxyHost, proxyPort, false);</span>
<span class="nc" id="L712">    }</span>

    /**
     * Obtain a HttpClient object, set up so that it uses per-instance
     * proxying to the given HTTP proxy. Use the cached copy of HTTP
     * client objects/connections if specified.
     *
     * @param url       the URL being accessed
     * @param proxyHost the proxy host to use
     * @param proxyPort the proxy port to use
     * @param useCache  whether the cached connection should be used
     *        if present
     */
    protected void setProxiedClient (URL url,
                                           String proxyHost, int proxyPort,
                                           boolean useCache)
        throws IOException {
<span class="nc" id="L729">        proxiedConnect(url, proxyHost, proxyPort, useCache);</span>
<span class="nc" id="L730">    }</span>

    protected void proxiedConnect(URL url,
                                           String proxyHost, int proxyPort,
                                           boolean useCache)
        throws IOException {
<span class="nc" id="L736">        http = HttpClient.New (url, proxyHost, proxyPort, useCache,</span>
            connectTimeout, this);
<span class="nc" id="L738">        http.setReadTimeout(readTimeout);</span>
<span class="nc" id="L739">    }</span>

    protected HttpURLConnection(URL u, Handler handler)
    throws IOException {
        // we set proxy == null to distinguish this case with the case
        // when per connection proxy is set
<span class="nc" id="L745">        this(u, null, handler);</span>
<span class="nc" id="L746">    }</span>

    public HttpURLConnection(URL u, String host, int port) {
<span class="nc" id="L749">        this(u, new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port)));</span>
<span class="nc" id="L750">    }</span>

    /** this constructor is used by other protocol handlers such as ftp
        that want to use http to fetch urls on their behalf.*/
    public HttpURLConnection(URL u, Proxy p) {
<span class="nc" id="L755">        this(u, p, new Handler());</span>
<span class="nc" id="L756">    }</span>

    protected HttpURLConnection(URL u, Proxy p, Handler handler) {
<span class="fc" id="L759">        super(u);</span>
<span class="fc" id="L760">        requests = new MessageHeader();</span>
<span class="fc" id="L761">        responses = new MessageHeader();</span>
<span class="fc" id="L762">        userHeaders = new MessageHeader();</span>
<span class="fc" id="L763">        this.handler = handler;</span>
<span class="fc" id="L764">        instProxy = p;</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        if (instProxy instanceof sun.net.ApplicationProxy) {</span>
            /* Application set Proxies should not have access to cookies
             * in a secure environment unless explicitly allowed. */
            try {
<span class="fc" id="L769">                cookieHandler = CookieHandler.getDefault();</span>
<span class="pc" id="L770">            } catch (SecurityException se) { /* swallow exception */ }</span>
        } else {
<span class="fc" id="L772">            cookieHandler = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L773">                new java.security.PrivilegedAction&lt;CookieHandler&gt;() {</span>
                public CookieHandler run() {
<span class="fc" id="L775">                    return CookieHandler.getDefault();</span>
                }
            });
        }
<span class="fc" id="L779">        cacheHandler = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L780">            new java.security.PrivilegedAction&lt;ResponseCache&gt;() {</span>
                public ResponseCache run() {
<span class="fc" id="L782">                return ResponseCache.getDefault();</span>
            }
        });
<span class="fc" id="L785">    }</span>

    /**
     * @deprecated.  Use java.net.Authenticator.setDefault() instead.
     */
    @Deprecated
    public static void setDefaultAuthenticator(HttpAuthenticator a) {
<span class="nc" id="L792">        defaultAuth = a;</span>
<span class="nc" id="L793">    }</span>

    /**
     * opens a stream allowing redirects only to the same host.
     */
    public static InputStream openConnectionCheckRedirects(URLConnection c)
        throws IOException
    {
        boolean redir;
<span class="nc" id="L802">        int redirects = 0;</span>
        InputStream in;

        do {
<span class="nc bnc" id="L806" title="All 2 branches missed.">            if (c instanceof HttpURLConnection) {</span>
<span class="nc" id="L807">                ((HttpURLConnection) c).setInstanceFollowRedirects(false);</span>
            }

            // We want to open the input stream before
            // getting headers, because getHeaderField()
            // et al swallow IOExceptions.
<span class="nc" id="L813">            in = c.getInputStream();</span>
<span class="nc" id="L814">            redir = false;</span>

<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (c instanceof HttpURLConnection) {</span>
<span class="nc" id="L817">                HttpURLConnection http = (HttpURLConnection) c;</span>
<span class="nc" id="L818">                int stat = http.getResponseCode();</span>
<span class="nc bnc" id="L819" title="All 8 branches missed.">                if (stat &gt;= 300 &amp;&amp; stat &lt;= 307 &amp;&amp; stat != 306 &amp;&amp;</span>
                        stat != HttpURLConnection.HTTP_NOT_MODIFIED) {
<span class="nc" id="L821">                    URL base = http.getURL();</span>
<span class="nc" id="L822">                    String loc = http.getHeaderField(&quot;Location&quot;);</span>
<span class="nc" id="L823">                    URL target = null;</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                    if (loc != null) {</span>
<span class="nc" id="L825">                        target = new URL(base, loc);</span>
                    }
<span class="nc" id="L827">                    http.disconnect();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                    if (target == null</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                        || !base.getProtocol().equals(target.getProtocol())</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                        || base.getPort() != target.getPort()</span>
<span class="nc bnc" id="L831" title="All 4 branches missed.">                        || !hostsEqual(base, target)</span>
                        || redirects &gt;= 5)
                    {
<span class="nc" id="L834">                        throw new SecurityException(&quot;illegal URL redirect&quot;);</span>
                    }
<span class="nc" id="L836">                    redir = true;</span>
<span class="nc" id="L837">                    c = target.openConnection();</span>
<span class="nc" id="L838">                    redirects++;</span>
                }
            }
<span class="nc bnc" id="L841" title="All 2 branches missed.">        } while (redir);</span>
<span class="nc" id="L842">        return in;</span>
    }


    //
    // Same as java.net.URL.hostsEqual
    //
    private static boolean hostsEqual(URL u1, URL u2) {
<span class="nc" id="L850">        final String h1 = u1.getHost();</span>
<span class="nc" id="L851">        final String h2 = u2.getHost();</span>

<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (h1 == null) {</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            return h2 == null;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        } else if (h2 == null) {</span>
<span class="nc" id="L856">            return false;</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">        } else if (h1.equalsIgnoreCase(h2)) {</span>
<span class="nc" id="L858">            return true;</span>
        }
        // Have to resolve addresses before comparing, otherwise
        // names like tachyon and tachyon.eng would compare different
<span class="nc" id="L862">        final boolean result[] = {false};</span>

<span class="nc" id="L864">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L865">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                try {
<span class="nc" id="L868">                    InetAddress a1 = InetAddress.getByName(h1);</span>
<span class="nc" id="L869">                    InetAddress a2 = InetAddress.getByName(h2);</span>
<span class="nc" id="L870">                    result[0] = a1.equals(a2);</span>
<span class="nc" id="L871">                } catch(UnknownHostException | SecurityException e) {</span>
<span class="nc" id="L872">                }</span>
<span class="nc" id="L873">                return null;</span>
            }
        });

<span class="nc" id="L877">        return result[0];</span>
    }

    // overridden in HTTPS subclass

    public void connect() throws IOException {
<span class="fc" id="L883">        synchronized (this) {</span>
<span class="fc" id="L884">            connecting = true;</span>
<span class="pc" id="L885">        }</span>
<span class="fc" id="L886">        plainConnect();</span>
<span class="fc" id="L887">    }</span>

    private boolean checkReuseConnection () {
<span class="fc bfc" id="L890" title="All 2 branches covered.">        if (connected) {</span>
<span class="fc" id="L891">            return true;</span>
        }
<span class="pc bpc" id="L893" title="1 of 2 branches missed.">        if (reuseClient != null) {</span>
<span class="nc" id="L894">            http = reuseClient;</span>
<span class="nc" id="L895">            http.setReadTimeout(getReadTimeout());</span>
<span class="nc" id="L896">            http.reuse = false;</span>
<span class="nc" id="L897">            reuseClient = null;</span>
<span class="nc" id="L898">            connected = true;</span>
<span class="nc" id="L899">            return true;</span>
        }
<span class="fc" id="L901">        return false;</span>
    }

    private String getHostAndPort(URL url) {
<span class="fc" id="L905">        String host = url.getHost();</span>
<span class="fc" id="L906">        final String hostarg = host;</span>
        try {
            // lookup hostname and use IP address if available
<span class="fc" id="L909">            host = AccessController.doPrivileged(</span>
<span class="fc" id="L910">                new PrivilegedExceptionAction&lt;String&gt;() {</span>
                    public String run() throws IOException {
<span class="fc" id="L912">                            InetAddress addr = InetAddress.getByName(hostarg);</span>
<span class="fc" id="L913">                            return addr.getHostAddress();</span>
                    }
                }
            );
<span class="fc" id="L917">        } catch (PrivilegedActionException e) {}</span>
<span class="fc" id="L918">        int port = url.getPort();</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">        if (port == -1) {</span>
<span class="fc" id="L920">            String scheme = url.getProtocol();</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            if (&quot;http&quot;.equals(scheme)) {</span>
<span class="fc" id="L922">                return host + &quot;:80&quot;;</span>
            } else { // scheme must be https
<span class="nc" id="L924">                return host + &quot;:443&quot;;</span>
            }
        }
<span class="fc" id="L927">        return host + &quot;:&quot; + Integer.toString(port);</span>
    }

    protected void plainConnect()  throws IOException {
<span class="fc" id="L931">        synchronized (this) {</span>
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">            if (connected) {</span>
<span class="nc" id="L933">                return;</span>
            }
<span class="pc" id="L935">        }</span>
<span class="fc" id="L936">        SocketPermission p = URLtoSocketPermission(this.url);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        if (p != null) {</span>
            try {
<span class="fc" id="L939">                AccessController.doPrivileged(</span>
<span class="fc" id="L940">                    new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                        public Void run() throws IOException {
<span class="fc" id="L942">                            plainConnect0();</span>
<span class="fc" id="L943">                            return null;</span>
                        }
                    }, null, p
                );
<span class="fc" id="L947">            } catch (PrivilegedActionException e) {</span>
<span class="fc" id="L948">                    throw (IOException) e.getException();</span>
<span class="fc" id="L949">            }</span>
        } else {
            // run without additional permission
<span class="fc" id="L952">            plainConnect0();</span>
        }
<span class="fc" id="L954">    }</span>

    /**
     *  if the caller has a URLPermission for connecting to the
     *  given URL, then return a SocketPermission which permits
     *  access to that destination. Return null otherwise. The permission
     *  is cached in a field (which can only be changed by redirects)
     */
    SocketPermission URLtoSocketPermission(URL url) throws IOException {

<span class="fc bfc" id="L964" title="All 2 branches covered.">        if (socketPermission != null) {</span>
<span class="fc" id="L965">            return socketPermission;</span>
        }

<span class="fc" id="L968">        SecurityManager sm = System.getSecurityManager();</span>

<span class="fc bfc" id="L970" title="All 2 branches covered.">        if (sm == null) {</span>
<span class="fc" id="L971">            return null;</span>
        }

        // the permission, which we might grant

<span class="fc" id="L976">        SocketPermission newPerm = new SocketPermission(</span>
<span class="fc" id="L977">            getHostAndPort(url), &quot;connect&quot;</span>
        );

<span class="fc" id="L980">        String actions = getRequestMethod()+&quot;:&quot; +</span>
<span class="fc" id="L981">                getUserSetHeaders().getHeaderNamesInList();</span>

<span class="fc" id="L983">        String urlstring = url.getProtocol() + &quot;://&quot; + url.getAuthority()</span>
<span class="fc" id="L984">                + url.getPath();</span>

<span class="fc" id="L986">        URLPermission p = new URLPermission(urlstring, actions);</span>
        try {
<span class="fc" id="L988">            sm.checkPermission(p);</span>
<span class="fc" id="L989">            socketPermission = newPerm;</span>
<span class="fc" id="L990">            return socketPermission;</span>
<span class="fc" id="L991">        } catch (SecurityException e) {</span>
            // fall thru
        }
<span class="fc" id="L994">        return null;</span>
    }

    protected void plainConnect0()  throws IOException {
        // try to see if request can be served from local cache
<span class="pc bpc" id="L999" title="1 of 4 branches missed.">        if (cacheHandler != null &amp;&amp; getUseCaches()) {</span>
            try {
<span class="fc" id="L1001">                URI uri = ParseUtil.toURI(url);</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">                if (uri != null) {</span>
<span class="fc" id="L1003">                    cachedResponse = cacheHandler.get(uri, getRequestMethod(), requests.getHeaders(EXCLUDE_HEADERS));</span>
<span class="pc bpc" id="L1004" title="3 of 4 branches missed.">                    if (&quot;https&quot;.equalsIgnoreCase(uri.getScheme())</span>
                        &amp;&amp; !(cachedResponse instanceof SecureCacheResponse)) {
<span class="nc" id="L1006">                        cachedResponse = null;</span>
                    }
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L1009">                        logger.finest(&quot;Cache Request for &quot; + uri + &quot; / &quot; + getRequestMethod());</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                        logger.finest(&quot;From cache: &quot; + (cachedResponse != null ? cachedResponse.toString() : &quot;null&quot;));</span>
                    }
<span class="fc bfc" id="L1012" title="All 2 branches covered.">                    if (cachedResponse != null) {</span>
<span class="fc" id="L1013">                        cachedHeaders = mapToMessageHeader(cachedResponse.getHeaders());</span>
<span class="fc" id="L1014">                        cachedInputStream = cachedResponse.getBody();</span>
                    }
                }
<span class="nc" id="L1017">            } catch (IOException ioex) {</span>
                // ignore and commence normal connection
<span class="fc" id="L1019">            }</span>
<span class="pc bpc" id="L1020" title="1 of 4 branches missed.">            if (cachedHeaders != null &amp;&amp; cachedInputStream != null) {</span>
<span class="fc" id="L1021">                connected = true;</span>
<span class="fc" id="L1022">                return;</span>
            } else {
<span class="fc" id="L1024">                cachedResponse = null;</span>
            }
        }
        try {
            /* Try to open connections using the following scheme,
             * return on the first one that's successful:
             * 1) if (instProxy != null)
             *        connect to instProxy; raise exception if failed
             * 2) else use system default ProxySelector
             * 3) is 2) fails, make direct connection
             */

<span class="fc bfc" id="L1036" title="All 2 branches covered.">            if (instProxy == null) { // no instance Proxy is set</span>
                /**
                 * Do we have to use a proxy?
                 */
<span class="fc" id="L1040">                ProxySelector sel =</span>
<span class="fc" id="L1041">                    java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L1042">                        new java.security.PrivilegedAction&lt;ProxySelector&gt;() {</span>
                            public ProxySelector run() {
<span class="fc" id="L1044">                                     return ProxySelector.getDefault();</span>
                                 }
                             });
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">                if (sel != null) {</span>
<span class="fc" id="L1048">                    URI uri = sun.net.www.ParseUtil.toURI(url);</span>
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L1050">                        logger.finest(&quot;ProxySelector Request for &quot; + uri);</span>
                    }
<span class="fc" id="L1052">                    Iterator&lt;Proxy&gt; it = sel.select(uri).iterator();</span>
                    Proxy p;
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">                    while (it.hasNext()) {</span>
<span class="fc" id="L1055">                        p = it.next();</span>
                        try {
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">                            if (!failedOnce) {</span>
<span class="fc" id="L1058">                                http = getNewHttpClient(url, p, connectTimeout);</span>
<span class="fc" id="L1059">                                http.setReadTimeout(readTimeout);</span>
                            } else {
                                // make sure to construct new connection if first
                                // attempt failed
<span class="nc" id="L1063">                                http = getNewHttpClient(url, p, connectTimeout, false);</span>
<span class="nc" id="L1064">                                http.setReadTimeout(readTimeout);</span>
                            }
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">                            if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                                if (p != null) {</span>
<span class="nc" id="L1068">                                    logger.finest(&quot;Proxy used: &quot; + p.toString());</span>
                                }
                            }
<span class="fc" id="L1071">                            break;</span>
<span class="fc" id="L1072">                        } catch (IOException ioex) {</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">                            if (p != Proxy.NO_PROXY) {</span>
<span class="nc" id="L1074">                                sel.connectFailed(uri, p.address(), ioex);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                                if (!it.hasNext()) {</span>
                                    // fallback to direct connection
<span class="nc" id="L1077">                                    http = getNewHttpClient(url, null, connectTimeout, false);</span>
<span class="nc" id="L1078">                                    http.setReadTimeout(readTimeout);</span>
<span class="nc" id="L1079">                                    break;</span>
                                }
                            } else {
<span class="fc" id="L1082">                                throw ioex;</span>
                            }
<span class="nc" id="L1084">                            continue;</span>
                        }
                    }
<span class="fc" id="L1087">                } else {</span>
                    // No proxy selector, create http client with no proxy
<span class="nc bnc" id="L1089" title="All 2 branches missed.">                    if (!failedOnce) {</span>
<span class="nc" id="L1090">                        http = getNewHttpClient(url, null, connectTimeout);</span>
<span class="nc" id="L1091">                        http.setReadTimeout(readTimeout);</span>
                    } else {
                        // make sure to construct new connection if first
                        // attempt failed
<span class="nc" id="L1095">                        http = getNewHttpClient(url, null, connectTimeout, false);</span>
<span class="nc" id="L1096">                        http.setReadTimeout(readTimeout);</span>
                    }
                }
<span class="fc" id="L1099">            } else {</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">                if (!failedOnce) {</span>
<span class="fc" id="L1101">                    http = getNewHttpClient(url, instProxy, connectTimeout);</span>
<span class="fc" id="L1102">                    http.setReadTimeout(readTimeout);</span>
                } else {
                    // make sure to construct new connection if first
                    // attempt failed
<span class="nc" id="L1106">                    http = getNewHttpClient(url, instProxy, connectTimeout, false);</span>
<span class="nc" id="L1107">                    http.setReadTimeout(readTimeout);</span>
                }
            }

<span class="fc" id="L1111">            ps = (PrintStream)http.getOutputStream();</span>
<span class="fc" id="L1112">        } catch (IOException e) {</span>
<span class="fc" id="L1113">            throw e;</span>
<span class="fc" id="L1114">        }</span>
        // constructor to HTTP client calls openserver
<span class="fc" id="L1116">        connected = true;</span>
<span class="fc" id="L1117">    }</span>

    // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
    protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout)
        throws IOException {
<span class="fc" id="L1122">        return HttpClient.New(url, p, connectTimeout, this);</span>
    }

    // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
    protected HttpClient getNewHttpClient(URL url, Proxy p,
                                          int connectTimeout, boolean useCache)
        throws IOException {
<span class="nc" id="L1129">        return HttpClient.New(url, p, connectTimeout, useCache, this);</span>
    }

    private void expect100Continue() throws IOException {
            // Expect: 100-Continue was set, so check the return code for
            // Acceptance
<span class="nc" id="L1135">            int oldTimeout = http.getReadTimeout();</span>
<span class="nc" id="L1136">            boolean enforceTimeOut = false;</span>
<span class="nc" id="L1137">            boolean timedOut = false;</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">            if (oldTimeout &lt;= 0) {</span>
                // 5s read timeout in case the server doesn't understand
                // Expect: 100-Continue
<span class="nc" id="L1141">                http.setReadTimeout(5000);</span>
<span class="nc" id="L1142">                enforceTimeOut = true;</span>
            }

            try {
<span class="nc" id="L1146">                http.parseHTTP(responses, pi, this);</span>
<span class="nc" id="L1147">            } catch (SocketTimeoutException se) {</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">                if (!enforceTimeOut) {</span>
<span class="nc" id="L1149">                    throw se;</span>
                }
<span class="nc" id="L1151">                timedOut = true;</span>
<span class="nc" id="L1152">                http.setIgnoreContinue(true);</span>
<span class="nc" id="L1153">            }</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">            if (!timedOut) {</span>
                // Can't use getResponseCode() yet
<span class="nc" id="L1156">                String resp = responses.getValue(0);</span>
                // Parse the response which is of the form:
                // HTTP/1.1 417 Expectation Failed
                // HTTP/1.1 100 Continue
<span class="nc bnc" id="L1160" title="All 4 branches missed.">                if (resp != null &amp;&amp; resp.startsWith(&quot;HTTP/&quot;)) {</span>
<span class="nc" id="L1161">                    String[] sa = resp.split(&quot;\\s+&quot;);</span>
<span class="nc" id="L1162">                    responseCode = -1;</span>
                    try {
                        // Response code is 2nd token on the line
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                        if (sa.length &gt; 1)</span>
<span class="nc" id="L1166">                            responseCode = Integer.parseInt(sa[1]);</span>
<span class="nc" id="L1167">                    } catch (NumberFormatException numberFormatException) {</span>
<span class="nc" id="L1168">                    }</span>
                }
<span class="nc bnc" id="L1170" title="All 2 branches missed.">                if (responseCode != 100) {</span>
<span class="nc" id="L1171">                    throw new ProtocolException(&quot;Server rejected operation&quot;);</span>
                }
            }

<span class="nc" id="L1175">            http.setReadTimeout(oldTimeout);</span>

<span class="nc" id="L1177">            responseCode = -1;</span>
<span class="nc" id="L1178">            responses.reset();</span>
            // Proceed
<span class="nc" id="L1180">    }</span>

    /*
     * Allowable input/output sequences:
     * [interpreted as request entity]
     * - get output, [write output,] get input, [read input]
     * - get output, [write output]
     * [interpreted as GET]
     * - get input, [read input]
     * Disallowed:
     * - get input, [read input,] get output, [write output]
     */

    @Override
    public synchronized OutputStream getOutputStream() throws IOException {
<span class="fc" id="L1195">        connecting = true;</span>
<span class="fc" id="L1196">        SocketPermission p = URLtoSocketPermission(this.url);</span>

<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if (p != null) {</span>
            try {
<span class="fc" id="L1200">                return AccessController.doPrivileged(</span>
<span class="fc" id="L1201">                    new PrivilegedExceptionAction&lt;OutputStream&gt;() {</span>
                        public OutputStream run() throws IOException {
<span class="fc" id="L1203">                            return getOutputStream0();</span>
                        }
                    }, null, p
                );
<span class="nc" id="L1207">            } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L1208">                throw (IOException) e.getException();</span>
            }
        } else {
<span class="fc" id="L1211">            return getOutputStream0();</span>
        }
    }

    private synchronized OutputStream getOutputStream0() throws IOException {
        try {
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">            if (!doOutput) {</span>
<span class="nc" id="L1218">                throw new ProtocolException(&quot;cannot write to a URLConnection&quot;</span>
                               + &quot; if doOutput=false - call setDoOutput(true)&quot;);
            }

<span class="fc bfc" id="L1222" title="All 2 branches covered.">            if (method.equals(&quot;GET&quot;)) {</span>
<span class="fc" id="L1223">                method = &quot;POST&quot;; // Backward compatibility</span>
            }
<span class="pc bpc" id="L1225" title="3 of 4 branches missed.">            if (&quot;TRACE&quot;.equals(method) &amp;&amp; &quot;http&quot;.equals(url.getProtocol())) {</span>
<span class="nc" id="L1226">                throw new ProtocolException(&quot;HTTP method TRACE&quot; +</span>
                                            &quot; doesn't support output&quot;);
            }

            // if there's already an input stream open, throw an exception
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">            if (inputStream != null) {</span>
<span class="nc" id="L1232">                throw new ProtocolException(&quot;Cannot write output after reading input.&quot;);</span>
            }

<span class="fc bfc" id="L1235" title="All 2 branches covered.">            if (!checkReuseConnection())</span>
<span class="fc" id="L1236">                connect();</span>

<span class="fc" id="L1238">            boolean expectContinue = false;</span>
<span class="fc" id="L1239">            String expects = requests.findValue(&quot;Expect&quot;);</span>
<span class="pc bpc" id="L1240" title="1 of 4 branches missed.">            if (&quot;100-Continue&quot;.equalsIgnoreCase(expects) &amp;&amp; streaming()) {</span>
<span class="nc" id="L1241">                http.setIgnoreContinue(false);</span>
<span class="nc" id="L1242">                expectContinue = true;</span>
            }

<span class="pc bpc" id="L1245" title="1 of 4 branches missed.">            if (streaming() &amp;&amp; strOutputStream == null) {</span>
<span class="fc" id="L1246">                writeRequests();</span>
            }

<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">            if (expectContinue) {</span>
<span class="nc" id="L1250">                expect100Continue();</span>
            }
<span class="fc" id="L1252">            ps = (PrintStream)http.getOutputStream();</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">            if (streaming()) {</span>
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">                if (strOutputStream == null) {</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">                    if (chunkLength != -1) { /* chunked */</span>
<span class="fc" id="L1256">                         strOutputStream = new StreamingOutputStream(</span>
                               new ChunkedOutputStream(ps, chunkLength), -1L);
                    } else { /* must be fixed content length */
<span class="fc" id="L1259">                        long length = 0L;</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">                        if (fixedContentLengthLong != -1) {</span>
<span class="fc" id="L1261">                            length = fixedContentLengthLong;</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">                        } else if (fixedContentLength != -1) {</span>
<span class="fc" id="L1263">                            length = fixedContentLength;</span>
                        }
<span class="fc" id="L1265">                        strOutputStream = new StreamingOutputStream(ps, length);</span>
                    }
                }
<span class="fc" id="L1268">                return strOutputStream;</span>
            } else {
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">                if (poster == null) {</span>
<span class="fc" id="L1271">                    poster = new PosterOutputStream();</span>
                }
<span class="fc" id="L1273">                return poster;</span>
            }
<span class="nc" id="L1275">        } catch (RuntimeException e) {</span>
<span class="nc" id="L1276">            disconnectInternal();</span>
<span class="nc" id="L1277">            throw e;</span>
<span class="nc" id="L1278">        } catch (ProtocolException e) {</span>
            // Save the response code which may have been set while enforcing
            // the 100-continue. disconnectInternal() forces it to -1
<span class="nc" id="L1281">            int i = responseCode;</span>
<span class="nc" id="L1282">            disconnectInternal();</span>
<span class="nc" id="L1283">            responseCode = i;</span>
<span class="nc" id="L1284">            throw e;</span>
<span class="nc" id="L1285">        } catch (IOException e) {</span>
<span class="nc" id="L1286">            disconnectInternal();</span>
<span class="nc" id="L1287">            throw e;</span>
        }
    }

    public boolean streaming () {
<span class="fc bfc" id="L1292" title="All 6 branches covered.">        return (fixedContentLength != -1) || (fixedContentLengthLong != -1) ||</span>
               (chunkLength != -1);
    }

    /*
     * get applicable cookies based on the uri and request headers
     * add them to the existing request headers
     */
    private void setCookieHeader() throws IOException {
<span class="fc bfc" id="L1301" title="All 2 branches covered.">        if (cookieHandler != null) {</span>
            // we only want to capture the user defined Cookies once, as
            // they cannot be changed by user code after we are connected,
            // only internally.
<span class="fc" id="L1305">            synchronized (this) {</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">                if (setUserCookies) {</span>
<span class="fc" id="L1307">                    int k = requests.getKey(&quot;Cookie&quot;);</span>
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">                    if (k != -1)</span>
<span class="nc" id="L1309">                        userCookies = requests.getValue(k);</span>
<span class="fc" id="L1310">                    k = requests.getKey(&quot;Cookie2&quot;);</span>
<span class="pc bpc" id="L1311" title="1 of 2 branches missed.">                    if (k != -1)</span>
<span class="nc" id="L1312">                        userCookies2 = requests.getValue(k);</span>
<span class="fc" id="L1313">                    setUserCookies = false;</span>
                }
<span class="pc" id="L1315">            }</span>

            // remove old Cookie header before setting new one.
<span class="fc" id="L1318">            requests.remove(&quot;Cookie&quot;);</span>
<span class="fc" id="L1319">            requests.remove(&quot;Cookie2&quot;);</span>

<span class="fc" id="L1321">            URI uri = ParseUtil.toURI(url);</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">            if (uri != null) {</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">                if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L1324">                    logger.finest(&quot;CookieHandler request for &quot; + uri);</span>
                }
<span class="fc" id="L1326">                Map&lt;String, List&lt;String&gt;&gt; cookies</span>
<span class="fc" id="L1327">                    = cookieHandler.get(</span>
<span class="fc" id="L1328">                        uri, requests.getHeaders(EXCLUDE_HEADERS));</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">                if (!cookies.isEmpty()) {</span>
<span class="pc bpc" id="L1330" title="1 of 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L1331">                        logger.finest(&quot;Cookies retrieved: &quot; + cookies.toString());</span>
                    }
                    for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry :
<span class="fc bfc" id="L1334" title="All 2 branches covered.">                             cookies.entrySet()) {</span>
<span class="fc" id="L1335">                        String key = entry.getKey();</span>
                        // ignore all entries that don't have &quot;Cookie&quot;
                        // or &quot;Cookie2&quot; as keys
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">                        if (!&quot;Cookie&quot;.equalsIgnoreCase(key) &amp;&amp;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">                            !&quot;Cookie2&quot;.equalsIgnoreCase(key)) {</span>
<span class="nc" id="L1340">                            continue;</span>
                        }
<span class="fc" id="L1342">                        List&lt;String&gt; l = entry.getValue();</span>
<span class="pc bpc" id="L1343" title="1 of 4 branches missed.">                        if (l != null &amp;&amp; !l.isEmpty()) {</span>
<span class="fc" id="L1344">                            StringBuilder cookieValue = new StringBuilder();</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">                            for (String value : l) {</span>
<span class="fc" id="L1346">                                cookieValue.append(value).append(&quot;; &quot;);</span>
<span class="fc" id="L1347">                            }</span>
                            // strip off the trailing '; '
                            try {
<span class="fc" id="L1350">                                requests.add(key, cookieValue.substring(0, cookieValue.length() - 2));</span>
<span class="nc" id="L1351">                            } catch (StringIndexOutOfBoundsException ignored) {</span>
                                // no-op
<span class="fc" id="L1353">                            }</span>
                        }
<span class="fc" id="L1355">                    }</span>
                }
            }
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">            if (userCookies != null) {</span>
                int k;
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                if ((k = requests.getKey(&quot;Cookie&quot;)) != -1)</span>
<span class="nc" id="L1361">                    requests.set(&quot;Cookie&quot;, requests.getValue(k) + &quot;;&quot; + userCookies);</span>
                else
<span class="nc" id="L1363">                    requests.set(&quot;Cookie&quot;, userCookies);</span>
            }
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">            if (userCookies2 != null) {</span>
                int k;
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                if ((k = requests.getKey(&quot;Cookie2&quot;)) != -1)</span>
<span class="nc" id="L1368">                    requests.set(&quot;Cookie2&quot;, requests.getValue(k) + &quot;;&quot; + userCookies2);</span>
                else
<span class="nc" id="L1370">                    requests.set(&quot;Cookie2&quot;, userCookies2);</span>
            }

        } // end of getting cookies
<span class="fc" id="L1374">    }</span>

    @Override
    public synchronized InputStream getInputStream() throws IOException {
<span class="fc" id="L1378">        connecting = true;</span>
<span class="fc" id="L1379">        SocketPermission p = URLtoSocketPermission(this.url);</span>

<span class="fc bfc" id="L1381" title="All 2 branches covered.">        if (p != null) {</span>
            try {
<span class="fc" id="L1383">                return AccessController.doPrivileged(</span>
<span class="fc" id="L1384">                    new PrivilegedExceptionAction&lt;InputStream&gt;() {</span>
                        public InputStream run() throws IOException {
<span class="fc" id="L1386">                            return getInputStream0();</span>
                        }
                    }, null, p
                );
<span class="fc" id="L1390">            } catch (PrivilegedActionException e) {</span>
<span class="fc" id="L1391">                throw (IOException) e.getException();</span>
            }
        } else {
<span class="fc" id="L1394">            return getInputStream0();</span>
        }
    }

    @SuppressWarnings(&quot;empty-statement&quot;)
    private synchronized InputStream getInputStream0() throws IOException {

<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">        if (!doInput) {</span>
<span class="nc" id="L1402">            throw new ProtocolException(&quot;Cannot read from URLConnection&quot;</span>
                   + &quot; if doInput=false (call setDoInput(true))&quot;);
        }

<span class="fc bfc" id="L1406" title="All 2 branches covered.">        if (rememberedException != null) {</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">            if (rememberedException instanceof RuntimeException)</span>
<span class="fc" id="L1408">                throw new RuntimeException(rememberedException);</span>
            else {
<span class="fc" id="L1410">                throw getChainedException((IOException)rememberedException);</span>
            }
        }

<span class="fc bfc" id="L1414" title="All 2 branches covered.">        if (inputStream != null) {</span>
<span class="fc" id="L1415">            return inputStream;</span>
        }

<span class="fc bfc" id="L1418" title="All 2 branches covered.">        if (streaming() ) {</span>
<span class="fc bfc" id="L1419" title="All 2 branches covered.">            if (strOutputStream == null) {</span>
<span class="fc" id="L1420">                getOutputStream();</span>
            }
            /* make sure stream is closed */
<span class="fc" id="L1423">            strOutputStream.close ();</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">            if (!strOutputStream.writtenOK()) {</span>
<span class="nc" id="L1425">                throw new IOException (&quot;Incomplete output stream&quot;);</span>
            }
        }

<span class="fc" id="L1429">        int redirects = 0;</span>
<span class="fc" id="L1430">        int respCode = 0;</span>
<span class="fc" id="L1431">        long cl = -1;</span>
<span class="fc" id="L1432">        AuthenticationInfo serverAuthentication = null;</span>
<span class="fc" id="L1433">        AuthenticationInfo proxyAuthentication = null;</span>
<span class="fc" id="L1434">        AuthenticationHeader srvHdr = null;</span>

        /**
         * Failed Negotiate
         *
         * In some cases, the Negotiate auth is supported for the
         * remote host but the negotiate process still fails (For
         * example, if the web page is located on a backend server
         * and delegation is needed but fails). The authentication
         * process will start again, and we need to detect this
         * kind of failure and do proper fallback (say, to NTLM).
         *
         * In order to achieve this, the inNegotiate flag is set
         * when the first negotiate challenge is met (and reset
         * if authentication is finished). If a fresh new negotiate
         * challenge (no parameter) is found while inNegotiate is
         * set, we know there's a failed auth attempt recently.
         * Here we'll ignore the header line so that fallback
         * can be practiced.
         *
         * inNegotiateProxy is for proxy authentication.
         */
<span class="fc" id="L1456">        boolean inNegotiate = false;</span>
<span class="fc" id="L1457">        boolean inNegotiateProxy = false;</span>

        // If the user has set either of these headers then do not remove them
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">        isUserServerAuth = requests.getKey(&quot;Authorization&quot;) != -1;</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">        isUserProxyAuth = requests.getKey(&quot;Proxy-Authorization&quot;) != -1;</span>

        try {
            do {
<span class="fc bfc" id="L1465" title="All 2 branches covered.">                if (!checkReuseConnection())</span>
<span class="fc" id="L1466">                    connect();</span>

<span class="fc bfc" id="L1468" title="All 2 branches covered.">                if (cachedInputStream != null) {</span>
<span class="fc" id="L1469">                    return cachedInputStream;</span>
                }

                // Check if URL should be metered
<span class="fc" id="L1473">                boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, method);</span>

<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">                if (meteredInput)   {</span>
<span class="nc" id="L1476">                    pi = new ProgressSource(url, method);</span>
<span class="nc" id="L1477">                    pi.beginTracking();</span>
                }

                /* REMIND: This exists to fix the HttpsURLConnection subclass.
                 * Hotjava needs to run on JDK1.1FCS.  Do proper fix once a
                 * proper solution for SSL can be found.
                 */
<span class="fc" id="L1484">                ps = (PrintStream)http.getOutputStream();</span>

<span class="fc bfc" id="L1486" title="All 2 branches covered.">                if (!streaming()) {</span>
<span class="fc" id="L1487">                    writeRequests();</span>
                }
<span class="fc" id="L1489">                http.parseHTTP(responses, pi, this);</span>
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">                if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L1491">                    logger.fine(responses.toString());</span>
                }

<span class="fc" id="L1494">                boolean b1 = responses.filterNTLMResponses(&quot;WWW-Authenticate&quot;);</span>
<span class="fc" id="L1495">                boolean b2 = responses.filterNTLMResponses(&quot;Proxy-Authenticate&quot;);</span>
<span class="pc bpc" id="L1496" title="2 of 4 branches missed.">                if (b1 || b2) {</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L1498">                        logger.fine(&quot;&gt;&gt;&gt;&gt; Headers are filtered&quot;);</span>
<span class="nc" id="L1499">                        logger.fine(responses.toString());</span>
                    }
                }

<span class="fc" id="L1503">                inputStream = http.getInputStream();</span>

<span class="fc" id="L1505">                respCode = getResponseCode();</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">                if (respCode == -1) {</span>
<span class="fc" id="L1507">                    disconnectInternal();</span>
<span class="fc" id="L1508">                    throw new IOException (&quot;Invalid Http response&quot;);</span>
                }
<span class="fc bfc" id="L1510" title="All 2 branches covered.">                if (respCode == HTTP_PROXY_AUTH) {</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">                    if (streaming()) {</span>
<span class="nc" id="L1512">                        disconnectInternal();</span>
<span class="nc" id="L1513">                        throw new HttpRetryException (</span>
                            RETRY_MSG1, HTTP_PROXY_AUTH);
                    }

                    // Read comments labeled &quot;Failed Negotiate&quot; for details.
<span class="fc" id="L1518">                    boolean dontUseNegotiate = false;</span>
<span class="fc" id="L1519">                    Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;Proxy-Authenticate&quot;);</span>
<span class="fc bfc" id="L1520" title="All 2 branches covered.">                    while (iter.hasNext()) {</span>
<span class="fc" id="L1521">                        String value = iter.next().trim();</span>
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">                        if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||</span>
<span class="pc bpc" id="L1523" title="1 of 2 branches missed.">                                value.equalsIgnoreCase(&quot;Kerberos&quot;)) {</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                            if (!inNegotiateProxy) {</span>
<span class="nc" id="L1525">                                inNegotiateProxy = true;</span>
                            } else {
<span class="nc" id="L1527">                                dontUseNegotiate = true;</span>
<span class="nc" id="L1528">                                doingNTLMp2ndStage = false;</span>
<span class="nc" id="L1529">                                proxyAuthentication = null;</span>
                            }
<span class="nc" id="L1531">                            break;</span>
                        }
<span class="fc" id="L1533">                    }</span>

                    // changes: add a 3rd parameter to the constructor of
                    // AuthenticationHeader, so that NegotiateAuthentication.
                    // isSupported can be tested.
                    // The other 2 appearances of &quot;new AuthenticationHeader&quot; is
                    // altered in similar ways.

<span class="fc" id="L1541">                    AuthenticationHeader authhdr = new AuthenticationHeader (</span>
                            &quot;Proxy-Authenticate&quot;, responses,
<span class="fc" id="L1543">                            new HttpCallerInfo(url, http.getProxyHostUsed(),</span>
<span class="fc" id="L1544">                                http.getProxyPortUsed()),</span>
                            dontUseNegotiate
                    );

<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">                    if (!doingNTLMp2ndStage) {</span>
<span class="fc" id="L1549">                        proxyAuthentication =</span>
<span class="fc" id="L1550">                            resetProxyAuthentication(proxyAuthentication, authhdr);</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">                        if (proxyAuthentication != null) {</span>
<span class="fc" id="L1552">                            redirects++;</span>
<span class="fc" id="L1553">                            disconnectInternal();</span>
<span class="fc" id="L1554">                            continue;</span>
                        }
                    } else {
                        /* in this case, only one header field will be present */
<span class="nc" id="L1558">                        String raw = responses.findValue (&quot;Proxy-Authenticate&quot;);</span>
<span class="nc" id="L1559">                        reset ();</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                        if (!proxyAuthentication.setHeaders(this,</span>
<span class="nc" id="L1561">                                                        authhdr.headerParser(), raw)) {</span>
<span class="nc" id="L1562">                            disconnectInternal();</span>
<span class="nc" id="L1563">                            throw new IOException (&quot;Authentication failure&quot;);</span>
                        }
<span class="nc bnc" id="L1565" title="All 4 branches missed.">                        if (serverAuthentication != null &amp;&amp; srvHdr != null &amp;&amp;</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">                                !serverAuthentication.setHeaders(this,</span>
<span class="nc" id="L1567">                                                        srvHdr.headerParser(), raw)) {</span>
<span class="nc" id="L1568">                            disconnectInternal ();</span>
<span class="nc" id="L1569">                            throw new IOException (&quot;Authentication failure&quot;);</span>
                        }
<span class="nc" id="L1571">                        authObj = null;</span>
<span class="nc" id="L1572">                        doingNTLMp2ndStage = false;</span>
<span class="nc" id="L1573">                        continue;</span>
                    }
<span class="fc" id="L1575">                } else {</span>
<span class="fc" id="L1576">                    inNegotiateProxy = false;</span>
<span class="fc" id="L1577">                    doingNTLMp2ndStage = false;</span>
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">                    if (!isUserProxyAuth)</span>
<span class="fc" id="L1579">                        requests.remove(&quot;Proxy-Authorization&quot;);</span>
                }

                // cache proxy authentication info
<span class="fc bfc" id="L1583" title="All 2 branches covered.">                if (proxyAuthentication != null) {</span>
                    // cache auth info on success, domain header not relevant.
<span class="fc" id="L1585">                    proxyAuthentication.addToCache();</span>
                }

<span class="fc bfc" id="L1588" title="All 2 branches covered.">                if (respCode == HTTP_UNAUTHORIZED) {</span>
<span class="pc bpc" id="L1589" title="1 of 2 branches missed.">                    if (streaming()) {</span>
<span class="nc" id="L1590">                        disconnectInternal();</span>
<span class="nc" id="L1591">                        throw new HttpRetryException (</span>
                            RETRY_MSG2, HTTP_UNAUTHORIZED);
                    }

                    // Read comments labeled &quot;Failed Negotiate&quot; for details.
<span class="fc" id="L1596">                    boolean dontUseNegotiate = false;</span>
<span class="fc" id="L1597">                    Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;WWW-Authenticate&quot;);</span>
<span class="fc bfc" id="L1598" title="All 2 branches covered.">                    while (iter.hasNext()) {</span>
<span class="fc" id="L1599">                        String value = iter.next().trim();</span>
<span class="pc bpc" id="L1600" title="1 of 2 branches missed.">                        if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||</span>
<span class="pc bpc" id="L1601" title="1 of 2 branches missed.">                                value.equalsIgnoreCase(&quot;Kerberos&quot;)) {</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">                            if (!inNegotiate) {</span>
<span class="nc" id="L1603">                                inNegotiate = true;</span>
                            } else {
<span class="nc" id="L1605">                                dontUseNegotiate = true;</span>
<span class="nc" id="L1606">                                doingNTLM2ndStage = false;</span>
<span class="nc" id="L1607">                                serverAuthentication = null;</span>
                            }
<span class="nc" id="L1609">                            break;</span>
                        }
<span class="fc" id="L1611">                    }</span>

<span class="fc" id="L1613">                    srvHdr = new AuthenticationHeader (</span>
                            &quot;WWW-Authenticate&quot;, responses,
                            new HttpCallerInfo(url),
                            dontUseNegotiate
                    );

<span class="fc" id="L1619">                    String raw = srvHdr.raw();</span>
<span class="pc bpc" id="L1620" title="1 of 2 branches missed.">                    if (!doingNTLM2ndStage) {</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">                        if ((serverAuthentication != null)&amp;&amp;</span>
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">                            serverAuthentication.getAuthScheme() != NTLM) {</span>
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">                            if (serverAuthentication.isAuthorizationStale (raw)) {</span>
                                /* we can retry with the current credentials */
<span class="nc" id="L1625">                                disconnectWeb();</span>
<span class="nc" id="L1626">                                redirects++;</span>
<span class="nc" id="L1627">                                requests.set(serverAuthentication.getHeaderName(),</span>
<span class="nc" id="L1628">                                            serverAuthentication.getHeaderValue(url, method));</span>
<span class="nc" id="L1629">                                currentServerCredentials = serverAuthentication;</span>
<span class="nc" id="L1630">                                setCookieHeader();</span>
<span class="nc" id="L1631">                                continue;</span>
                            } else {
<span class="fc" id="L1633">                                serverAuthentication.removeFromCache();</span>
                            }
                        }
<span class="fc" id="L1636">                        serverAuthentication = getServerAuthentication(srvHdr);</span>
<span class="fc" id="L1637">                        currentServerCredentials = serverAuthentication;</span>

<span class="fc bfc" id="L1639" title="All 2 branches covered.">                        if (serverAuthentication != null) {</span>
<span class="fc" id="L1640">                            disconnectWeb();</span>
<span class="fc" id="L1641">                            redirects++; // don't let things loop ad nauseum</span>
<span class="fc" id="L1642">                            setCookieHeader();</span>
<span class="fc" id="L1643">                            continue;</span>
                        }
                    } else {
<span class="nc" id="L1646">                        reset ();</span>
                        /* header not used for ntlm */
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                        if (!serverAuthentication.setHeaders(this, null, raw)) {</span>
<span class="nc" id="L1649">                            disconnectWeb();</span>
<span class="nc" id="L1650">                            throw new IOException (&quot;Authentication failure&quot;);</span>
                        }
<span class="nc" id="L1652">                        doingNTLM2ndStage = false;</span>
<span class="nc" id="L1653">                        authObj = null;</span>
<span class="nc" id="L1654">                        setCookieHeader();</span>
<span class="nc" id="L1655">                        continue;</span>
                    }
                }
                // cache server authentication info
<span class="fc bfc" id="L1659" title="All 2 branches covered.">                if (serverAuthentication != null) {</span>
                    // cache auth info on success
<span class="pc bpc" id="L1661" title="1 of 4 branches missed.">                    if (!(serverAuthentication instanceof DigestAuthentication) ||</span>
                        (domain == null)) {
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">                        if (serverAuthentication instanceof BasicAuthentication) {</span>
                            // check if the path is shorter than the existing entry
<span class="fc" id="L1665">                            String npath = AuthenticationInfo.reducePath (url.getPath());</span>
<span class="fc" id="L1666">                            String opath = serverAuthentication.path;</span>
<span class="pc bpc" id="L1667" title="1 of 4 branches missed.">                            if (!opath.startsWith (npath) || npath.length() &gt;= opath.length()) {</span>
                                /* npath is longer, there must be a common root */
<span class="fc" id="L1669">                                npath = BasicAuthentication.getRootPath (opath, npath);</span>
                            }
                            // remove the entry and create a new one
<span class="fc" id="L1672">                            BasicAuthentication a =</span>
<span class="fc" id="L1673">                                (BasicAuthentication) serverAuthentication.clone();</span>
<span class="fc" id="L1674">                            serverAuthentication.removeFromCache();</span>
<span class="fc" id="L1675">                            a.path = npath;</span>
<span class="fc" id="L1676">                            serverAuthentication = a;</span>
                        }
<span class="fc" id="L1678">                        serverAuthentication.addToCache();</span>
                    } else {
                        // what we cache is based on the domain list in the request
<span class="fc" id="L1681">                        DigestAuthentication srv = (DigestAuthentication)</span>
                            serverAuthentication;
<span class="fc" id="L1683">                        StringTokenizer tok = new StringTokenizer (domain,&quot; &quot;);</span>
<span class="fc" id="L1684">                        String realm = srv.realm;</span>
<span class="fc" id="L1685">                        PasswordAuthentication pw = srv.pw;</span>
<span class="fc" id="L1686">                        digestparams = srv.params;</span>
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                        while (tok.hasMoreTokens()) {</span>
<span class="fc" id="L1688">                            String path = tok.nextToken();</span>
                            try {
                                /* path could be an abs_path or a complete URI */
<span class="fc" id="L1691">                                URL u = new URL (url, path);</span>
<span class="fc" id="L1692">                                DigestAuthentication d = new DigestAuthentication (</span>
                                                   false, u, realm, &quot;Digest&quot;, pw, digestparams);
<span class="fc" id="L1694">                                d.addToCache ();</span>
<span class="pc" id="L1695">                            } catch (Exception e) {}</span>
<span class="fc" id="L1696">                        }</span>
                    }
                }

                // some flags should be reset to its initialized form so that
                // even after a redirect the necessary checks can still be
                // preformed.
<span class="fc" id="L1703">                inNegotiate = false;</span>
<span class="fc" id="L1704">                inNegotiateProxy = false;</span>

                //serverAuthentication = null;
<span class="fc" id="L1707">                doingNTLMp2ndStage = false;</span>
<span class="fc" id="L1708">                doingNTLM2ndStage = false;</span>
<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">                if (!isUserServerAuth)</span>
<span class="fc" id="L1710">                    requests.remove(&quot;Authorization&quot;);</span>
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">                if (!isUserProxyAuth)</span>
<span class="fc" id="L1712">                    requests.remove(&quot;Proxy-Authorization&quot;);</span>

<span class="fc bfc" id="L1714" title="All 2 branches covered.">                if (respCode == HTTP_OK) {</span>
<span class="fc" id="L1715">                    checkResponseCredentials (false);</span>
                } else {
<span class="fc" id="L1717">                    needToCheck = false;</span>
                }

                // a flag need to clean
<span class="fc" id="L1721">                needToCheck = true;</span>

<span class="fc bfc" id="L1723" title="All 2 branches covered.">                if (followRedirect()) {</span>
                    /* if we should follow a redirect, then the followRedirects()
                     * method will disconnect() and re-connect us to the new
                     * location
                     */
<span class="fc" id="L1728">                    redirects++;</span>

                    // redirecting HTTP response may have set cookie, so
                    // need to re-generate request header
<span class="fc" id="L1732">                    setCookieHeader();</span>

<span class="fc" id="L1734">                    continue;</span>
                }

                try {
<span class="fc" id="L1738">                    cl = Long.parseLong(responses.findValue(&quot;content-length&quot;));</span>
<span class="fc" id="L1739">                } catch (Exception exc) { };</span>

<span class="pc bpc" id="L1741" title="1 of 8 branches missed.">                if (method.equals(&quot;HEAD&quot;) || cl == 0 ||</span>
                    respCode == HTTP_NOT_MODIFIED ||
                    respCode == HTTP_NO_CONTENT) {

<span class="pc bpc" id="L1745" title="1 of 2 branches missed.">                    if (pi != null) {</span>
<span class="nc" id="L1746">                        pi.finishTracking();</span>
<span class="nc" id="L1747">                        pi = null;</span>
                    }
<span class="fc" id="L1749">                    http.finished();</span>
<span class="fc" id="L1750">                    http = null;</span>
<span class="fc" id="L1751">                    inputStream = new EmptyInputStream();</span>
<span class="fc" id="L1752">                    connected = false;</span>
                }

<span class="pc bpc" id="L1755" title="5 of 12 branches missed.">                if (respCode == 200 || respCode == 203 || respCode == 206 ||</span>
                    respCode == 300 || respCode == 301 || respCode == 410) {
<span class="pc bpc" id="L1757" title="1 of 4 branches missed.">                    if (cacheHandler != null &amp;&amp; getUseCaches()) {</span>
                        // give cache a chance to save response in cache
<span class="fc" id="L1759">                        URI uri = ParseUtil.toURI(url);</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">                        if (uri != null) {</span>
<span class="fc" id="L1761">                            URLConnection uconn = this;</span>
<span class="pc bpc" id="L1762" title="1 of 2 branches missed.">                            if (&quot;https&quot;.equalsIgnoreCase(uri.getScheme())) {</span>
                                try {
                                // use reflection to get to the public
                                // HttpsURLConnection instance saved in
                                // DelegateHttpsURLConnection
<span class="nc" id="L1767">                                uconn = (URLConnection)this.getClass().getField(&quot;httpsURLConnection&quot;).get(this);</span>
<span class="nc" id="L1768">                                } catch (IllegalAccessException |</span>
                                         NoSuchFieldException e) {
                                    // ignored; use 'this'
<span class="nc" id="L1771">                                }</span>
                            }
<span class="fc" id="L1773">                            CacheRequest cacheRequest =</span>
<span class="fc" id="L1774">                                cacheHandler.put(uri, uconn);</span>
<span class="fc bfc" id="L1775" title="All 4 branches covered.">                            if (cacheRequest != null &amp;&amp; http != null) {</span>
<span class="fc" id="L1776">                                http.setCacheRequest(cacheRequest);</span>
<span class="fc" id="L1777">                                inputStream = new HttpInputStream(inputStream, cacheRequest);</span>
                            }
                        }
                    }
                }

<span class="fc bfc" id="L1783" title="All 2 branches covered.">                if (!(inputStream instanceof HttpInputStream)) {</span>
<span class="fc" id="L1784">                    inputStream = new HttpInputStream(inputStream);</span>
                }

<span class="fc bfc" id="L1787" title="All 2 branches covered.">                if (respCode &gt;= 400) {</span>
<span class="pc bpc" id="L1788" title="1 of 4 branches missed.">                    if (respCode == 404 || respCode == 410) {</span>
<span class="fc" id="L1789">                        throw new FileNotFoundException(url.toString());</span>
                    } else {
<span class="fc" id="L1791">                        throw new java.io.IOException(&quot;Server returned HTTP&quot; +</span>
                              &quot; response code: &quot; + respCode + &quot; for URL: &quot; +
<span class="fc" id="L1793">                              url.toString());</span>
                    }
                }
<span class="fc" id="L1796">                poster = null;</span>
<span class="fc" id="L1797">                strOutputStream = null;</span>
<span class="fc" id="L1798">                return inputStream;</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">            } while (redirects &lt; maxRedirects);</span>

<span class="fc" id="L1801">            throw new ProtocolException(&quot;Server redirected too many &quot; +</span>
                                        &quot; times (&quot;+ redirects + &quot;)&quot;);
<span class="fc" id="L1803">        } catch (RuntimeException e) {</span>
<span class="fc" id="L1804">            disconnectInternal();</span>
<span class="fc" id="L1805">            rememberedException = e;</span>
<span class="fc" id="L1806">            throw e;</span>
<span class="fc" id="L1807">        } catch (IOException e) {</span>
<span class="fc" id="L1808">            rememberedException = e;</span>

            // buffer the error stream if bytes &lt; 4k
            // and it can be buffered within 1 second
<span class="fc" id="L1812">            String te = responses.findValue(&quot;Transfer-Encoding&quot;);</span>
<span class="pc bpc" id="L1813" title="2 of 10 branches missed.">            if (http != null &amp;&amp; http.isKeepingAlive() &amp;&amp; enableESBuffer &amp;&amp;</span>
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">                (cl &gt; 0 || (te != null &amp;&amp; te.equalsIgnoreCase(&quot;chunked&quot;)))) {</span>
<span class="fc" id="L1815">                errorStream = ErrorStream.getErrorStream(inputStream, cl, http);</span>
            }
<span class="fc" id="L1817">            throw e;</span>
        } finally {
<span class="pc bpc" id="L1819" title="1 of 6 branches missed.">            if (proxyAuthKey != null) {</span>
<span class="pc" id="L1820">                AuthenticationInfo.endAuthRequest(proxyAuthKey);</span>
            }
<span class="pc bpc" id="L1822" title="1 of 6 branches missed.">            if (serverAuthKey != null) {</span>
<span class="pc" id="L1823">                AuthenticationInfo.endAuthRequest(serverAuthKey);</span>
            }
        }
    }

    /*
     * Creates a chained exception that has the same type as
     * original exception and with the same message. Right now,
     * there is no convenient APIs for doing so.
     */
    private IOException getChainedException(final IOException rememberedException) {
        try {
<span class="fc" id="L1835">            final Object[] args = { rememberedException.getMessage() };</span>
<span class="fc" id="L1836">            IOException chainedException =</span>
<span class="fc" id="L1837">                java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L1838">                    new java.security.PrivilegedExceptionAction&lt;IOException&gt;() {</span>
                        public IOException run() throws Exception {
<span class="fc" id="L1840">                            return (IOException)</span>
<span class="fc" id="L1841">                                rememberedException.getClass()</span>
<span class="fc" id="L1842">                                .getConstructor(new Class&lt;?&gt;[] { String.class })</span>
<span class="fc" id="L1843">                                .newInstance(args);</span>
                        }
                    });
<span class="fc" id="L1846">            chainedException.initCause(rememberedException);</span>
<span class="fc" id="L1847">            return chainedException;</span>
<span class="nc" id="L1848">        } catch (Exception ignored) {</span>
<span class="nc" id="L1849">            return rememberedException;</span>
        }
    }

    @Override
    public InputStream getErrorStream() {
<span class="pc bpc" id="L1855" title="2 of 4 branches missed.">        if (connected &amp;&amp; responseCode &gt;= 400) {</span>
            // Client Error 4xx and Server Error 5xx
<span class="fc bfc" id="L1857" title="All 2 branches covered.">            if (errorStream != null) {</span>
<span class="fc" id="L1858">                return errorStream;</span>
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">            } else if (inputStream != null) {</span>
<span class="fc" id="L1860">                return inputStream;</span>
            }
        }
<span class="nc" id="L1863">        return null;</span>
    }

    /**
     * set or reset proxy authentication info in request headers
     * after receiving a 407 error. In the case of NTLM however,
     * receiving a 407 is normal and we just skip the stale check
     * because ntlm does not support this feature.
     */
    private AuthenticationInfo
        resetProxyAuthentication(AuthenticationInfo proxyAuthentication, AuthenticationHeader auth) throws IOException {
<span class="pc bpc" id="L1874" title="1 of 2 branches missed.">        if ((proxyAuthentication != null )&amp;&amp;</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">             proxyAuthentication.getAuthScheme() != NTLM) {</span>
<span class="nc" id="L1876">            String raw = auth.raw();</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">            if (proxyAuthentication.isAuthorizationStale (raw)) {</span>
                /* we can retry with the current credentials */
                String value;
<span class="nc bnc" id="L1880" title="All 2 branches missed.">                if (proxyAuthentication instanceof DigestAuthentication) {</span>
<span class="nc" id="L1881">                    DigestAuthentication digestProxy = (DigestAuthentication)</span>
                        proxyAuthentication;
<span class="nc bnc" id="L1883" title="All 2 branches missed.">                    if (tunnelState() == TunnelState.SETUP) {</span>
<span class="nc" id="L1884">                        value = digestProxy.getHeaderValue(connectRequestURI(url), HTTP_CONNECT);</span>
                    } else {
<span class="nc" id="L1886">                        value = digestProxy.getHeaderValue(getRequestURI(), method);</span>
                    }
<span class="nc" id="L1888">                } else {</span>
<span class="nc" id="L1889">                    value = proxyAuthentication.getHeaderValue(url, method);</span>
                }
<span class="nc" id="L1891">                requests.set(proxyAuthentication.getHeaderName(), value);</span>
<span class="nc" id="L1892">                currentProxyCredentials = proxyAuthentication;</span>
<span class="nc" id="L1893">                return proxyAuthentication;</span>
            } else {
<span class="nc" id="L1895">                proxyAuthentication.removeFromCache();</span>
            }
        }
<span class="fc" id="L1898">        proxyAuthentication = getHttpProxyAuthentication(auth);</span>
<span class="fc" id="L1899">        currentProxyCredentials = proxyAuthentication;</span>
<span class="fc" id="L1900">        return  proxyAuthentication;</span>
    }

    /**
     * Returns the tunnel state.
     *
     * @return  the state
     */
    TunnelState tunnelState() {
<span class="fc" id="L1909">        return tunnelState;</span>
    }

    /**
     * Set the tunneling status.
     *
     * @param  the state
     */
    public void setTunnelState(TunnelState tunnelState) {
<span class="fc" id="L1918">        this.tunnelState = tunnelState;</span>
<span class="fc" id="L1919">    }</span>

    /**
     * establish a tunnel through proxy server
     */
    public synchronized void doTunneling() throws IOException {
<span class="fc" id="L1925">        int retryTunnel = 0;</span>
<span class="fc" id="L1926">        String statusLine = &quot;&quot;;</span>
<span class="fc" id="L1927">        int respCode = 0;</span>
<span class="fc" id="L1928">        AuthenticationInfo proxyAuthentication = null;</span>
<span class="fc" id="L1929">        String proxyHost = null;</span>
<span class="fc" id="L1930">        int proxyPort = -1;</span>

        // save current requests so that they can be restored after tunnel is setup.
<span class="fc" id="L1933">        MessageHeader savedRequests = requests;</span>
<span class="fc" id="L1934">        requests = new MessageHeader();</span>

        // Read comments labeled &quot;Failed Negotiate&quot; for details.
<span class="fc" id="L1937">        boolean inNegotiateProxy = false;</span>

        try {
            /* Actively setting up a tunnel */
<span class="fc" id="L1941">            setTunnelState(TunnelState.SETUP);</span>

            do {
<span class="fc bfc" id="L1944" title="All 2 branches covered.">                if (!checkReuseConnection()) {</span>
<span class="fc" id="L1945">                    proxiedConnect(url, proxyHost, proxyPort, false);</span>
                }
                // send the &quot;CONNECT&quot; request to establish a tunnel
                // through proxy server
<span class="fc" id="L1949">                sendCONNECTRequest();</span>
<span class="fc" id="L1950">                responses.reset();</span>

                // There is no need to track progress in HTTP Tunneling,
                // so ProgressSource is null.
<span class="fc" id="L1954">                http.parseHTTP(responses, null, this);</span>

                /* Log the response to the CONNECT */
<span class="pc bpc" id="L1957" title="1 of 2 branches missed.">                if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L1958">                    logger.fine(responses.toString());</span>
                }

<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">                if (responses.filterNTLMResponses(&quot;Proxy-Authenticate&quot;)) {</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L1963">                        logger.fine(&quot;&gt;&gt;&gt;&gt; Headers are filtered&quot;);</span>
<span class="nc" id="L1964">                        logger.fine(responses.toString());</span>
                    }
                }

<span class="fc" id="L1968">                statusLine = responses.getValue(0);</span>
<span class="fc" id="L1969">                StringTokenizer st = new StringTokenizer(statusLine);</span>
<span class="fc" id="L1970">                st.nextToken();</span>
<span class="fc" id="L1971">                respCode = Integer.parseInt(st.nextToken().trim());</span>
<span class="fc bfc" id="L1972" title="All 2 branches covered.">                if (respCode == HTTP_PROXY_AUTH) {</span>
                    // Read comments labeled &quot;Failed Negotiate&quot; for details.
<span class="fc" id="L1974">                    boolean dontUseNegotiate = false;</span>
<span class="fc" id="L1975">                    Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;Proxy-Authenticate&quot;);</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">                    while (iter.hasNext()) {</span>
<span class="fc" id="L1977">                        String value = iter.next().trim();</span>
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">                        if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||</span>
<span class="pc bpc" id="L1979" title="1 of 2 branches missed.">                                value.equalsIgnoreCase(&quot;Kerberos&quot;)) {</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                            if (!inNegotiateProxy) {</span>
<span class="nc" id="L1981">                                inNegotiateProxy = true;</span>
                            } else {
<span class="nc" id="L1983">                                dontUseNegotiate = true;</span>
<span class="nc" id="L1984">                                doingNTLMp2ndStage = false;</span>
<span class="nc" id="L1985">                                proxyAuthentication = null;</span>
                            }
<span class="nc" id="L1987">                            break;</span>
                        }
<span class="fc" id="L1989">                    }</span>

<span class="fc" id="L1991">                    AuthenticationHeader authhdr = new AuthenticationHeader (</span>
                            &quot;Proxy-Authenticate&quot;, responses,
<span class="fc" id="L1993">                            new HttpCallerInfo(url, http.getProxyHostUsed(),</span>
<span class="fc" id="L1994">                                http.getProxyPortUsed()),</span>
                            dontUseNegotiate
                    );
<span class="pc bpc" id="L1997" title="1 of 2 branches missed.">                    if (!doingNTLMp2ndStage) {</span>
<span class="fc" id="L1998">                        proxyAuthentication =</span>
<span class="fc" id="L1999">                            resetProxyAuthentication(proxyAuthentication, authhdr);</span>
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">                        if (proxyAuthentication != null) {</span>
<span class="fc" id="L2001">                            proxyHost = http.getProxyHostUsed();</span>
<span class="fc" id="L2002">                            proxyPort = http.getProxyPortUsed();</span>
<span class="fc" id="L2003">                            disconnectInternal();</span>
<span class="fc" id="L2004">                            retryTunnel++;</span>
<span class="fc" id="L2005">                            continue;</span>
                        }
                    } else {
<span class="nc" id="L2008">                        String raw = responses.findValue (&quot;Proxy-Authenticate&quot;);</span>
<span class="nc" id="L2009">                        reset ();</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">                        if (!proxyAuthentication.setHeaders(this,</span>
<span class="nc" id="L2011">                                                authhdr.headerParser(), raw)) {</span>
<span class="nc" id="L2012">                            disconnectInternal();</span>
<span class="nc" id="L2013">                            throw new IOException (&quot;Authentication failure&quot;);</span>
                        }
<span class="nc" id="L2015">                        authObj = null;</span>
<span class="nc" id="L2016">                        doingNTLMp2ndStage = false;</span>
<span class="nc" id="L2017">                        continue;</span>
                    }
                }
                // cache proxy authentication info
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">                if (proxyAuthentication != null) {</span>
                    // cache auth info on success, domain header not relevant.
<span class="nc" id="L2023">                    proxyAuthentication.addToCache();</span>
                }

<span class="fc bfc" id="L2026" title="All 2 branches covered.">                if (respCode == HTTP_OK) {</span>
<span class="fc" id="L2027">                    setTunnelState(TunnelState.TUNNELING);</span>
<span class="fc" id="L2028">                    break;</span>
                }
                // we don't know how to deal with other response code
                // so disconnect and report error
<span class="fc" id="L2032">                disconnectInternal();</span>
<span class="fc" id="L2033">                setTunnelState(TunnelState.NONE);</span>
<span class="fc" id="L2034">                break;</span>
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">            } while (retryTunnel &lt; maxRedirects);</span>

<span class="pc bpc" id="L2037" title="1 of 4 branches missed.">            if (retryTunnel &gt;= maxRedirects || (respCode != HTTP_OK)) {</span>
<span class="fc" id="L2038">                throw new IOException(&quot;Unable to tunnel through proxy.&quot;+</span>
                                      &quot; Proxy returns \&quot;&quot; +
                                      statusLine + &quot;\&quot;&quot;);
            }
        } finally  {
<span class="pc bpc" id="L2043" title="1 of 4 branches missed.">            if (proxyAuthKey != null) {</span>
<span class="pc" id="L2044">                AuthenticationInfo.endAuthRequest(proxyAuthKey);</span>
            }
        }

        // restore original request headers
<span class="fc" id="L2049">        requests = savedRequests;</span>

        // reset responses
<span class="fc" id="L2052">        responses.reset();</span>
<span class="fc" id="L2053">    }</span>

    static String connectRequestURI(URL url) {
<span class="fc" id="L2056">        String host = url.getHost();</span>
<span class="fc" id="L2057">        int port = url.getPort();</span>
<span class="fc bfc" id="L2058" title="All 2 branches covered.">        port = port != -1 ? port : url.getDefaultPort();</span>

<span class="fc" id="L2060">        return host + &quot;:&quot; + port;</span>
    }

    /**
     * send a CONNECT request for establishing a tunnel to proxy server
     */
    private void sendCONNECTRequest() throws IOException {
<span class="fc" id="L2067">        int port = url.getPort();</span>

<span class="fc" id="L2069">        requests.set(0, HTTP_CONNECT + &quot; &quot; + connectRequestURI(url)</span>
                         + &quot; &quot; + httpVersion, null);
<span class="fc" id="L2071">        requests.setIfNotSet(&quot;User-Agent&quot;, userAgent);</span>

<span class="fc" id="L2073">        String host = url.getHost();</span>
<span class="pc bpc" id="L2074" title="1 of 4 branches missed.">        if (port != -1 &amp;&amp; port != url.getDefaultPort()) {</span>
<span class="fc" id="L2075">            host += &quot;:&quot; + String.valueOf(port);</span>
        }
<span class="fc" id="L2077">        requests.setIfNotSet(&quot;Host&quot;, host);</span>

        // Not really necessary for a tunnel, but can't hurt
<span class="fc" id="L2080">        requests.setIfNotSet(&quot;Accept&quot;, acceptString);</span>

<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">        if (http.getHttpKeepAliveSet()) {</span>
<span class="fc" id="L2083">            requests.setIfNotSet(&quot;Proxy-Connection&quot;, &quot;keep-alive&quot;);</span>
        }

<span class="fc" id="L2086">        setPreemptiveProxyAuthentication(requests);</span>

         /* Log the CONNECT request */
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">        if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L2090">            logger.fine(requests.toString());</span>
        }

<span class="fc" id="L2093">        http.writeRequests(requests, null);</span>
<span class="fc" id="L2094">    }</span>

    /**
     * Sets pre-emptive proxy authentication in header
     */
    private void setPreemptiveProxyAuthentication(MessageHeader requests) throws IOException {
<span class="fc" id="L2100">        AuthenticationInfo pauth</span>
<span class="fc" id="L2101">            = AuthenticationInfo.getProxyAuth(http.getProxyHostUsed(),</span>
<span class="fc" id="L2102">                                              http.getProxyPortUsed());</span>
<span class="pc bpc" id="L2103" title="1 of 4 branches missed.">        if (pauth != null &amp;&amp; pauth.supportsPreemptiveAuthorization()) {</span>
            String value;
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">            if (pauth instanceof DigestAuthentication) {</span>
<span class="nc" id="L2106">                DigestAuthentication digestProxy = (DigestAuthentication) pauth;</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">                if (tunnelState() == TunnelState.SETUP) {</span>
<span class="nc" id="L2108">                    value = digestProxy</span>
<span class="nc" id="L2109">                        .getHeaderValue(connectRequestURI(url), HTTP_CONNECT);</span>
                } else {
<span class="nc" id="L2111">                    value = digestProxy.getHeaderValue(getRequestURI(), method);</span>
                }
<span class="nc" id="L2113">            } else {</span>
<span class="fc" id="L2114">                value = pauth.getHeaderValue(url, method);</span>
            }

            // Sets &quot;Proxy-authorization&quot;
<span class="fc" id="L2118">            requests.set(pauth.getHeaderName(), value);</span>
<span class="fc" id="L2119">            currentProxyCredentials = pauth;</span>
        }
<span class="fc" id="L2121">    }</span>

    /**
     * Gets the authentication for an HTTP proxy, and applies it to
     * the connection.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private AuthenticationInfo getHttpProxyAuthentication (AuthenticationHeader authhdr) {
        /* get authorization from authenticator */
<span class="fc" id="L2130">        AuthenticationInfo ret = null;</span>
<span class="fc" id="L2131">        String raw = authhdr.raw();</span>
<span class="fc" id="L2132">        String host = http.getProxyHostUsed();</span>
<span class="fc" id="L2133">        int port = http.getProxyPortUsed();</span>
<span class="pc bpc" id="L2134" title="2 of 4 branches missed.">        if (host != null &amp;&amp; authhdr.isPresent()) {</span>
<span class="fc" id="L2135">            HeaderParser p = authhdr.headerParser();</span>
<span class="fc" id="L2136">            String realm = p.findValue(&quot;realm&quot;);</span>
<span class="fc" id="L2137">            String scheme = authhdr.scheme();</span>
<span class="fc" id="L2138">            AuthScheme authScheme = UNKNOWN;</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">            if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2140">                authScheme = BASIC;</span>
<span class="fc bfc" id="L2141" title="All 2 branches covered.">            } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2142">                authScheme = DIGEST;</span>
<span class="pc bpc" id="L2143" title="1 of 2 branches missed.">            } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2144">                authScheme = NTLM;</span>
<span class="fc" id="L2145">                doingNTLMp2ndStage = true;</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="nc" id="L2147">                authScheme = KERBEROS;</span>
<span class="nc" id="L2148">                doingNTLMp2ndStage = true;</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="nc" id="L2150">                authScheme = NEGOTIATE;</span>
<span class="nc" id="L2151">                doingNTLMp2ndStage = true;</span>
            }

<span class="fc bfc" id="L2154" title="All 2 branches covered.">            if (realm == null)</span>
<span class="fc" id="L2155">                realm = &quot;&quot;;</span>
<span class="fc" id="L2156">            proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm, authScheme);</span>
<span class="fc" id="L2157">            ret = AuthenticationInfo.getProxyAuth(proxyAuthKey);</span>
<span class="fc bfc" id="L2158" title="All 2 branches covered.">            if (ret == null) {</span>
<span class="pc bpc" id="L2159" title="4 of 7 branches missed.">                switch (authScheme) {</span>
                case BASIC:
<span class="fc" id="L2161">                    InetAddress addr = null;</span>
                    try {
<span class="fc" id="L2163">                        final String finalHost = host;</span>
<span class="fc" id="L2164">                        addr = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L2165">                            new java.security.PrivilegedExceptionAction&lt;InetAddress&gt;() {</span>
                                public InetAddress run()
                                    throws java.net.UnknownHostException {
<span class="fc" id="L2168">                                    return InetAddress.getByName(finalHost);</span>
                                }
                            });
<span class="nc" id="L2171">                    } catch (java.security.PrivilegedActionException ignored) {</span>
                        // User will have an unknown host.
<span class="fc" id="L2173">                    }</span>
<span class="fc" id="L2174">                    PasswordAuthentication a =</span>
<span class="fc" id="L2175">                        privilegedRequestPasswordAuthentication(</span>
                                    host, addr, port, &quot;http&quot;,
                                    realm, scheme, url, RequestorType.PROXY);
<span class="pc bpc" id="L2178" title="1 of 2 branches missed.">                    if (a != null) {</span>
<span class="fc" id="L2179">                        ret = new BasicAuthentication(true, host, port, realm, a);</span>
                    }
                    break;
                case DIGEST:
<span class="fc" id="L2183">                    a = privilegedRequestPasswordAuthentication(</span>
<span class="fc" id="L2184">                                    host, null, port, url.getProtocol(),</span>
                                    realm, scheme, url, RequestorType.PROXY);
<span class="pc bpc" id="L2186" title="1 of 2 branches missed.">                    if (a != null) {</span>
<span class="fc" id="L2187">                        DigestAuthentication.Parameters params =</span>
                            new DigestAuthentication.Parameters();
<span class="fc" id="L2189">                        ret = new DigestAuthentication(true, host, port, realm,</span>
                                                            scheme, a, params);
<span class="fc" id="L2191">                    }</span>
                    break;
                case NTLM:
<span class="pc bpc" id="L2194" title="1 of 2 branches missed.">                    if (NTLMAuthenticationProxy.supported) {</span>
                        /* tryTransparentNTLMProxy will always be true the first
                         * time around, but verify that the platform supports it
                         * otherwise don't try. */
<span class="pc bpc" id="L2198" title="1 of 2 branches missed.">                        if (tryTransparentNTLMProxy) {</span>
<span class="fc" id="L2199">                            tryTransparentNTLMProxy =</span>
                                    NTLMAuthenticationProxy.supportsTransparentAuth;
                        }
<span class="fc" id="L2202">                        a = null;</span>
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">                        if (tryTransparentNTLMProxy) {</span>
<span class="nc" id="L2204">                            logger.finest(&quot;Trying Transparent NTLM authentication&quot;);</span>
                        } else {
<span class="fc" id="L2206">                            a = privilegedRequestPasswordAuthentication(</span>
<span class="fc" id="L2207">                                                host, null, port, url.getProtocol(),</span>
                                                &quot;&quot;, scheme, url, RequestorType.PROXY);
                        }
                        /* If we are not trying transparent authentication then
                         * we need to have a PasswordAuthentication instance. For
                         * transparent authentication (Windows only) the username
                         * and password will be picked up from the current logged
                         * on users credentials.
                        */
<span class="pc bpc" id="L2216" title="3 of 6 branches missed.">                        if (tryTransparentNTLMProxy ||</span>
                              (!tryTransparentNTLMProxy &amp;&amp; a != null)) {
<span class="nc" id="L2218">                            ret = NTLMAuthenticationProxy.proxy.create(true, host, port, a);</span>
                        }

                        /* set to false so that we do not try again */
<span class="fc" id="L2222">                        tryTransparentNTLMProxy = false;</span>
                    }
                    break;
                case NEGOTIATE:
<span class="nc" id="L2226">                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));</span>
<span class="nc" id="L2227">                    break;</span>
                case KERBEROS:
<span class="nc" id="L2229">                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));</span>
<span class="nc" id="L2230">                    break;</span>
                case UNKNOWN:
<span class="nc bnc" id="L2232" title="All 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2233">                        logger.finest(&quot;Unknown/Unsupported authentication scheme: &quot; + scheme);</span>
                    }
                /*fall through*/
                default:
<span class="nc" id="L2237">                    throw new AssertionError(&quot;should not reach here&quot;);</span>
                }
            }
            // For backwards compatibility, we also try defaultAuth
            // REMIND:  Get rid of this for JDK2.0.

<span class="pc bpc" id="L2243" title="1 of 4 branches missed.">            if (ret == null &amp;&amp; defaultAuth != null</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">                &amp;&amp; defaultAuth.schemeSupported(scheme)) {</span>
                try {
<span class="nc" id="L2246">                    URL u = new URL(&quot;http&quot;, host, port, &quot;/&quot;);</span>
<span class="nc" id="L2247">                    String a = defaultAuth.authString(u, scheme, realm);</span>
<span class="nc bnc" id="L2248" title="All 2 branches missed.">                    if (a != null) {</span>
<span class="nc" id="L2249">                        ret = new BasicAuthentication (true, host, port, realm, a);</span>
                        // not in cache by default - cache on success
                    }
<span class="nc" id="L2252">                } catch (java.net.MalformedURLException ignored) {</span>
<span class="nc" id="L2253">                }</span>
            }
<span class="fc bfc" id="L2255" title="All 2 branches covered.">            if (ret != null) {</span>
<span class="pc bpc" id="L2256" title="1 of 2 branches missed.">                if (!ret.setHeaders(this, p, raw)) {</span>
<span class="nc" id="L2257">                    ret = null;</span>
                }
            }
        }
<span class="pc bpc" id="L2261" title="1 of 2 branches missed.">        if (logger.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">            logger.finer(&quot;Proxy Authentication for &quot; + authhdr.toString() +&quot; returned &quot; + (ret != null ? ret.toString() : &quot;null&quot;));</span>
        }
<span class="fc" id="L2264">        return ret;</span>
    }

    /**
     * Gets the authentication for an HTTP server, and applies it to
     * the connection.
     * @param authHdr the AuthenticationHeader which tells what auth scheme is
     * preferred.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private AuthenticationInfo getServerAuthentication (AuthenticationHeader authhdr) {
        /* get authorization from authenticator */
<span class="fc" id="L2276">        AuthenticationInfo ret = null;</span>
<span class="fc" id="L2277">        String raw = authhdr.raw();</span>
        /* When we get an NTLM auth from cache, don't set any special headers */
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">        if (authhdr.isPresent()) {</span>
<span class="fc" id="L2280">            HeaderParser p = authhdr.headerParser();</span>
<span class="fc" id="L2281">            String realm = p.findValue(&quot;realm&quot;);</span>
<span class="fc" id="L2282">            String scheme = authhdr.scheme();</span>
<span class="fc" id="L2283">            AuthScheme authScheme = UNKNOWN;</span>
<span class="fc bfc" id="L2284" title="All 2 branches covered.">            if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2285">                authScheme = BASIC;</span>
<span class="fc bfc" id="L2286" title="All 2 branches covered.">            } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2287">                authScheme = DIGEST;</span>
<span class="pc bpc" id="L2288" title="1 of 2 branches missed.">            } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="fc" id="L2289">                authScheme = NTLM;</span>
<span class="fc" id="L2290">                doingNTLM2ndStage = true;</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">            } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="nc" id="L2292">                authScheme = KERBEROS;</span>
<span class="nc" id="L2293">                doingNTLM2ndStage = true;</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">            } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {</span>
<span class="nc" id="L2295">                authScheme = NEGOTIATE;</span>
<span class="nc" id="L2296">                doingNTLM2ndStage = true;</span>
            }

<span class="fc" id="L2299">            domain = p.findValue (&quot;domain&quot;);</span>
<span class="fc bfc" id="L2300" title="All 2 branches covered.">            if (realm == null)</span>
<span class="fc" id="L2301">                realm = &quot;&quot;;</span>
<span class="fc" id="L2302">            serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme);</span>
<span class="fc" id="L2303">            ret = AuthenticationInfo.getServerAuth(serverAuthKey);</span>
<span class="fc" id="L2304">            InetAddress addr = null;</span>
<span class="fc bfc" id="L2305" title="All 2 branches covered.">            if (ret == null) {</span>
                try {
<span class="fc" id="L2307">                    addr = InetAddress.getByName(url.getHost());</span>
<span class="nc" id="L2308">                } catch (java.net.UnknownHostException ignored) {</span>
                    // User will have addr = null
<span class="fc" id="L2310">                }</span>
            }
            // replacing -1 with default port for a protocol
<span class="fc" id="L2313">            int port = url.getPort();</span>
<span class="fc bfc" id="L2314" title="All 2 branches covered.">            if (port == -1) {</span>
<span class="fc" id="L2315">                port = url.getDefaultPort();</span>
            }
<span class="fc bfc" id="L2317" title="All 2 branches covered.">            if (ret == null) {</span>
<span class="pc bpc" id="L2318" title="4 of 7 branches missed.">                switch(authScheme) {</span>
                case KERBEROS:
<span class="nc" id="L2320">                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));</span>
<span class="nc" id="L2321">                    break;</span>
                case NEGOTIATE:
<span class="nc" id="L2323">                    ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));</span>
<span class="nc" id="L2324">                    break;</span>
                case BASIC:
<span class="fc" id="L2326">                    PasswordAuthentication a =</span>
<span class="fc" id="L2327">                        privilegedRequestPasswordAuthentication(</span>
<span class="fc" id="L2328">                            url.getHost(), addr, port, url.getProtocol(),</span>
                            realm, scheme, url, RequestorType.SERVER);
<span class="fc bfc" id="L2330" title="All 2 branches covered.">                    if (a != null) {</span>
<span class="fc" id="L2331">                        ret = new BasicAuthentication(false, url, realm, a);</span>
                    }
                    break;
                case DIGEST:
<span class="fc" id="L2335">                    a = privilegedRequestPasswordAuthentication(</span>
<span class="fc" id="L2336">                            url.getHost(), addr, port, url.getProtocol(),</span>
                            realm, scheme, url, RequestorType.SERVER);
<span class="pc bpc" id="L2338" title="1 of 2 branches missed.">                    if (a != null) {</span>
<span class="fc" id="L2339">                        digestparams = new DigestAuthentication.Parameters();</span>
<span class="fc" id="L2340">                        ret = new DigestAuthentication(false, url, realm, scheme, a, digestparams);</span>
                    }
                    break;
                case NTLM:
<span class="pc bpc" id="L2344" title="1 of 2 branches missed.">                    if (NTLMAuthenticationProxy.supported) {</span>
                        URL url1;
                        try {
<span class="fc" id="L2347">                            url1 = new URL (url, &quot;/&quot;); /* truncate the path */</span>
<span class="nc" id="L2348">                        } catch (Exception e) {</span>
<span class="nc" id="L2349">                            url1 = url;</span>
<span class="fc" id="L2350">                        }</span>

                        /* tryTransparentNTLMServer will always be true the first
                         * time around, but verify that the platform supports it
                         * otherwise don't try. */
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">                        if (tryTransparentNTLMServer) {</span>
<span class="fc" id="L2356">                            tryTransparentNTLMServer =</span>
                                    NTLMAuthenticationProxy.supportsTransparentAuth;
                            /* If the platform supports transparent authentication
                             * then check if we are in a secure environment
                             * whether, or not, we should try transparent authentication.*/
<span class="pc bpc" id="L2361" title="1 of 2 branches missed.">                            if (tryTransparentNTLMServer) {</span>
<span class="nc" id="L2362">                                tryTransparentNTLMServer =</span>
<span class="nc" id="L2363">                                        NTLMAuthenticationProxy.isTrustedSite(url);</span>
                            }
                        }
<span class="fc" id="L2366">                        a = null;</span>
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">                        if (tryTransparentNTLMServer) {</span>
<span class="nc" id="L2368">                            logger.finest(&quot;Trying Transparent NTLM authentication&quot;);</span>
                        } else {
<span class="fc" id="L2370">                            a = privilegedRequestPasswordAuthentication(</span>
<span class="fc" id="L2371">                                url.getHost(), addr, port, url.getProtocol(),</span>
                                &quot;&quot;, scheme, url, RequestorType.SERVER);
                        }

                        /* If we are not trying transparent authentication then
                         * we need to have a PasswordAuthentication instance. For
                         * transparent authentication (Windows only) the username
                         * and password will be picked up from the current logged
                         * on users credentials.
                         */
<span class="pc bpc" id="L2381" title="3 of 6 branches missed.">                        if (tryTransparentNTLMServer ||</span>
                              (!tryTransparentNTLMServer &amp;&amp; a != null)) {
<span class="nc" id="L2383">                            ret = NTLMAuthenticationProxy.proxy.create(false, url1, a);</span>
                        }

                        /* set to false so that we do not try again */
<span class="fc" id="L2387">                        tryTransparentNTLMServer = false;</span>
<span class="fc" id="L2388">                    }</span>
                    break;
                case UNKNOWN:
<span class="nc bnc" id="L2391" title="All 2 branches missed.">                    if (logger.isLoggable(PlatformLogger.Level.FINEST)) {</span>
<span class="nc" id="L2392">                        logger.finest(&quot;Unknown/Unsupported authentication scheme: &quot; + scheme);</span>
                    }
                /*fall through*/
                default:
<span class="nc" id="L2396">                    throw new AssertionError(&quot;should not reach here&quot;);</span>
                }
            }

            // For backwards compatibility, we also try defaultAuth
            // REMIND:  Get rid of this for JDK2.0.

<span class="pc bpc" id="L2403" title="1 of 4 branches missed.">            if (ret == null &amp;&amp; defaultAuth != null</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">                &amp;&amp; defaultAuth.schemeSupported(scheme)) {</span>
<span class="nc" id="L2405">                String a = defaultAuth.authString(url, scheme, realm);</span>
<span class="nc bnc" id="L2406" title="All 2 branches missed.">                if (a != null) {</span>
<span class="nc" id="L2407">                    ret = new BasicAuthentication (false, url, realm, a);</span>
                    // not in cache by default - cache on success
                }
            }

<span class="fc bfc" id="L2412" title="All 2 branches covered.">            if (ret != null ) {</span>
<span class="pc bpc" id="L2413" title="1 of 2 branches missed.">                if (!ret.setHeaders(this, p, raw)) {</span>
<span class="nc" id="L2414">                    ret = null;</span>
                }
            }
        }
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">        if (logger.isLoggable(PlatformLogger.Level.FINER)) {</span>
<span class="nc bnc" id="L2419" title="All 2 branches missed.">            logger.finer(&quot;Server Authentication for &quot; + authhdr.toString() +&quot; returned &quot; + (ret != null ? ret.toString() : &quot;null&quot;));</span>
        }
<span class="fc" id="L2421">        return ret;</span>
    }

    /* inclose will be true if called from close(), in which case we
     * force the call to check because this is the last chance to do so.
     * If not in close(), then the authentication info could arrive in a trailer
     * field, which we have not read yet.
     */
    private void checkResponseCredentials (boolean inClose) throws IOException {
        try {
<span class="pc bpc" id="L2431" title="1 of 2 branches missed.">            if (!needToCheck)</span>
<span class="nc" id="L2432">                return;</span>
<span class="pc bpc" id="L2433" title="2 of 6 branches missed.">            if ((validateProxy &amp;&amp; currentProxyCredentials != null) &amp;&amp;</span>
                (currentProxyCredentials instanceof DigestAuthentication)) {
<span class="fc" id="L2435">                String raw = responses.findValue (&quot;Proxy-Authentication-Info&quot;);</span>
<span class="pc bpc" id="L2436" title="1 of 4 branches missed.">                if (inClose || (raw != null)) {</span>
<span class="fc" id="L2437">                    DigestAuthentication da = (DigestAuthentication)</span>
                        currentProxyCredentials;
<span class="fc" id="L2439">                    da.checkResponse (raw, method, getRequestURI());</span>
<span class="fc" id="L2440">                    currentProxyCredentials = null;</span>
                }
            }
<span class="pc bpc" id="L2443" title="2 of 6 branches missed.">            if ((validateServer &amp;&amp; currentServerCredentials != null) &amp;&amp;</span>
                (currentServerCredentials instanceof DigestAuthentication)) {
<span class="fc" id="L2445">                String raw = responses.findValue (&quot;Authentication-Info&quot;);</span>
<span class="pc bpc" id="L2446" title="1 of 4 branches missed.">                if (inClose || (raw != null)) {</span>
<span class="nc" id="L2447">                    DigestAuthentication da = (DigestAuthentication)</span>
                        currentServerCredentials;
<span class="nc" id="L2449">                    da.checkResponse (raw, method, url);</span>
<span class="nc" id="L2450">                    currentServerCredentials = null;</span>
                }
            }
<span class="fc bfc" id="L2453" title="All 4 branches covered.">            if ((currentServerCredentials==null) &amp;&amp; (currentProxyCredentials == null)) {</span>
<span class="fc" id="L2454">                needToCheck = false;</span>
            }
<span class="fc" id="L2456">        } catch (IOException e) {</span>
<span class="fc" id="L2457">            disconnectInternal();</span>
<span class="fc" id="L2458">            connected = false;</span>
<span class="fc" id="L2459">            throw e;</span>
<span class="fc" id="L2460">        }</span>
<span class="fc" id="L2461">    }</span>

   /* The request URI used in the request line for this request.
    * Also, needed for digest authentication
    */

<span class="fc" id="L2467">    String requestURI = null;</span>

    String getRequestURI() throws IOException {
<span class="fc bfc" id="L2470" title="All 2 branches covered.">        if (requestURI == null) {</span>
<span class="fc" id="L2471">            requestURI = http.getURLFile();</span>
        }
<span class="fc" id="L2473">        return requestURI;</span>
    }

    /* Tells us whether to follow a redirect.  If so, it
     * closes the connection (break any keep-alive) and
     * resets the url, re-connects, and resets the request
     * property.
     */
    private boolean followRedirect() throws IOException {
<span class="pc bpc" id="L2482" title="1 of 2 branches missed.">        if (!getInstanceFollowRedirects()) {</span>
<span class="nc" id="L2483">            return false;</span>
        }

<span class="fc" id="L2486">        final int stat = getResponseCode();</span>
<span class="pc bpc" id="L2487" title="1 of 8 branches missed.">        if (stat &lt; 300 || stat &gt; 307 || stat == 306</span>
                                || stat == HTTP_NOT_MODIFIED) {
<span class="fc" id="L2489">            return false;</span>
        }
<span class="fc" id="L2491">        final String loc = getHeaderField(&quot;Location&quot;);</span>
<span class="pc bpc" id="L2492" title="1 of 2 branches missed.">        if (loc == null) {</span>
            /* this should be present - if not, we have no choice
             * but to go forward w/ the response we got
             */
<span class="nc" id="L2496">            return false;</span>
        }

        URL locUrl;
        try {
<span class="fc" id="L2501">            locUrl = new URL(loc);</span>
<span class="pc bpc" id="L2502" title="1 of 2 branches missed.">            if (!url.getProtocol().equalsIgnoreCase(locUrl.getProtocol())) {</span>
<span class="nc" id="L2503">                return false;</span>
            }

<span class="fc" id="L2506">        } catch (MalformedURLException mue) {</span>
          // treat loc as a relative URI to conform to popular browsers
<span class="fc" id="L2508">          locUrl = new URL(url, loc);</span>
<span class="fc" id="L2509">        }</span>

<span class="fc" id="L2511">        final URL locUrl0 = locUrl;</span>
<span class="fc" id="L2512">        socketPermission = null; // force recalculation</span>
<span class="fc" id="L2513">        SocketPermission p = URLtoSocketPermission(locUrl);</span>

<span class="fc bfc" id="L2515" title="All 2 branches covered.">        if (p != null) {</span>
            try {
<span class="fc" id="L2517">                return AccessController.doPrivileged(</span>
<span class="fc" id="L2518">                    new PrivilegedExceptionAction&lt;Boolean&gt;() {</span>
                        public Boolean run() throws IOException {
<span class="fc" id="L2520">                            return followRedirect0(loc, stat, locUrl0);</span>
                        }
                    }, null, p
                );
<span class="nc" id="L2524">            } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L2525">                throw (IOException) e.getException();</span>
            }
        } else {
            // run without additional permission
<span class="fc" id="L2529">            return followRedirect0(loc, stat, locUrl);</span>
        }
    }

    /* Tells us whether to follow a redirect.  If so, it
     * closes the connection (break any keep-alive) and
     * resets the url, re-connects, and resets the request
     * property.
     */
    private boolean followRedirect0(String loc, int stat, URL locUrl)
        throws IOException
    {
<span class="fc" id="L2541">        disconnectInternal();</span>
<span class="fc bfc" id="L2542" title="All 2 branches covered.">        if (streaming()) {</span>
<span class="fc" id="L2543">            throw new HttpRetryException (RETRY_MSG3, stat, loc);</span>
        }
<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">        if (logger.isLoggable(PlatformLogger.Level.FINE)) {</span>
<span class="nc" id="L2546">            logger.fine(&quot;Redirected from &quot; + url + &quot; to &quot; + locUrl);</span>
        }

        // clear out old response headers!!!!
<span class="fc" id="L2550">        responses = new MessageHeader();</span>
<span class="pc bpc" id="L2551" title="1 of 2 branches missed.">        if (stat == HTTP_USE_PROXY) {</span>
            /* This means we must re-request the resource through the
             * proxy denoted in the &quot;Location:&quot; field of the response.
             * Judging by the spec, the string in the Location header
             * _should_ denote a URL - let's hope for &quot;http://my.proxy.org&quot;
             * Make a new HttpClient to the proxy, using HttpClient's
             * Instance-specific proxy fields, but note we're still fetching
             * the same URL.
             */
<span class="nc" id="L2560">            String proxyHost = locUrl.getHost();</span>
<span class="nc" id="L2561">            int proxyPort = locUrl.getPort();</span>

<span class="nc" id="L2563">            SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">            if (security != null) {</span>
<span class="nc" id="L2565">                security.checkConnect(proxyHost, proxyPort);</span>
            }

<span class="nc" id="L2568">            setProxiedClient (url, proxyHost, proxyPort);</span>
<span class="nc" id="L2569">            requests.set(0, method + &quot; &quot; + getRequestURI()+&quot; &quot;  +</span>
                             httpVersion, null);
<span class="nc" id="L2571">            connected = true;</span>
<span class="nc" id="L2572">        } else {</span>
            // maintain previous headers, just change the name
            // of the file we're getting
<span class="fc" id="L2575">            url = locUrl;</span>
<span class="fc" id="L2576">            requestURI = null; // force it to be recalculated</span>
<span class="pc bpc" id="L2577" title="5 of 6 branches missed.">            if (method.equals(&quot;POST&quot;) &amp;&amp; !Boolean.getBoolean(&quot;http.strictPostRedirect&quot;) &amp;&amp; (stat!=307)) {</span>
                /* The HTTP/1.1 spec says that a redirect from a POST
                 * *should not* be immediately turned into a GET, and
                 * that some HTTP/1.0 clients incorrectly did this.
                 * Correct behavior redirects a POST to another POST.
                 * Unfortunately, since most browsers have this incorrect
                 * behavior, the web works this way now.  Typical usage
                 * seems to be:
                 *   POST a login code or passwd to a web page.
                 *   after validation, the server redirects to another
                 *     (welcome) page
                 *   The second request is (erroneously) expected to be GET
                 *
                 * We will do the incorrect thing (POST--&gt;GET) by default.
                 * We will provide the capability to do the &quot;right&quot; thing
                 * (POST--&gt;POST) by a system property, &quot;http.strictPostRedirect=true&quot;
                 */

<span class="nc" id="L2595">                requests = new MessageHeader();</span>
<span class="nc" id="L2596">                setRequests = false;</span>
<span class="nc" id="L2597">                setRequestMethod(&quot;GET&quot;);</span>
<span class="nc" id="L2598">                poster = null;</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">                if (!checkReuseConnection())</span>
<span class="nc" id="L2600">                    connect();</span>
            } else {
<span class="pc bpc" id="L2602" title="1 of 2 branches missed.">                if (!checkReuseConnection())</span>
<span class="fc" id="L2603">                    connect();</span>
                /* Even after a connect() call, http variable still can be
                 * null, if a ResponseCache has been installed and it returns
                 * a non-null CacheResponse instance. So check nullity before using it.
                 *
                 * And further, if http is null, there's no need to do anything
                 * about request headers because successive http session will use
                 * cachedInputStream/cachedHeaders anyway, which is returned by
                 * CacheResponse.
                 */
<span class="fc bfc" id="L2613" title="All 2 branches covered.">                if (http != null) {</span>
<span class="fc" id="L2614">                    requests.set(0, method + &quot; &quot; + getRequestURI()+&quot; &quot;  +</span>
                                 httpVersion, null);
<span class="fc" id="L2616">                    int port = url.getPort();</span>
<span class="fc" id="L2617">                    String host = url.getHost();</span>
<span class="pc bpc" id="L2618" title="2 of 4 branches missed.">                    if (port != -1 &amp;&amp; port != url.getDefaultPort()) {</span>
<span class="fc" id="L2619">                        host += &quot;:&quot; + String.valueOf(port);</span>
                    }
<span class="fc" id="L2621">                    requests.set(&quot;Host&quot;, host);</span>
                }
            }
        }
<span class="fc" id="L2625">        return true;</span>
    }

    /* dummy byte buffer for reading off socket prior to closing */
<span class="fc" id="L2629">    byte[] cdata = new byte [128];</span>

    /**
     * Reset (without disconnecting the TCP conn) in order to do another transaction with this instance
     */
    private void reset() throws IOException {
<span class="nc" id="L2635">        http.reuse = true;</span>
        /* must save before calling close */
<span class="nc" id="L2637">        reuseClient = http;</span>
<span class="nc" id="L2638">        InputStream is = http.getInputStream();</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">        if (!method.equals(&quot;HEAD&quot;)) {</span>
            try {
                /* we want to read the rest of the response without using the
                 * hurry mechanism, because that would close the connection
                 * if everything is not available immediately
                 */
<span class="nc bnc" id="L2645" title="All 4 branches missed.">                if ((is instanceof ChunkedInputStream) ||</span>
                    (is instanceof MeteredStream)) {
                    /* reading until eof will not block */
<span class="nc bnc" id="L2648" title="All 2 branches missed.">                    while (is.read (cdata) &gt; 0) {}</span>
                } else {
                    /* raw stream, which will block on read, so only read
                     * the expected number of bytes, probably 0
                     */
<span class="nc" id="L2653">                    long cl = 0;</span>
<span class="nc" id="L2654">                    int n = 0;</span>
<span class="nc" id="L2655">                    String cls = responses.findValue (&quot;Content-Length&quot;);</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">                    if (cls != null) {</span>
                        try {
<span class="nc" id="L2658">                            cl = Long.parseLong (cls);</span>
<span class="nc" id="L2659">                        } catch (NumberFormatException e) {</span>
<span class="nc" id="L2660">                            cl = 0;</span>
<span class="nc" id="L2661">                        }</span>
                    }
<span class="nc bnc" id="L2663" title="All 2 branches missed.">                    for (long i=0; i&lt;cl; ) {</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">                        if ((n = is.read (cdata)) == -1) {</span>
<span class="nc" id="L2665">                            break;</span>
                        } else {
<span class="nc" id="L2667">                            i+= n;</span>
                        }
                    }
                }
<span class="nc" id="L2671">            } catch (IOException e) {</span>
<span class="nc" id="L2672">                http.reuse = false;</span>
<span class="nc" id="L2673">                reuseClient = null;</span>
<span class="nc" id="L2674">                disconnectInternal();</span>
<span class="nc" id="L2675">                return;</span>
<span class="nc" id="L2676">            }</span>
            try {
<span class="nc bnc" id="L2678" title="All 2 branches missed.">                if (is instanceof MeteredStream) {</span>
<span class="nc" id="L2679">                    is.close();</span>
                }
<span class="nc" id="L2681">            } catch (IOException e) { }</span>
        }
<span class="nc" id="L2683">        responseCode = -1;</span>
<span class="nc" id="L2684">        responses = new MessageHeader();</span>
<span class="nc" id="L2685">        connected = false;</span>
<span class="nc" id="L2686">    }</span>

    /**
     * Disconnect from the web server at the first 401 error. Do not
     * disconnect when using a proxy, a good proxy should have already
     * closed the connection to the web server.
     */
    private void disconnectWeb() throws IOException {
<span class="pc bpc" id="L2694" title="1 of 4 branches missed.">        if (usingProxy() &amp;&amp; http.isKeepingAlive()) {</span>
<span class="nc" id="L2695">            responseCode = -1;</span>
            // clean up, particularly, skip the content part
            // of a 401 error response
<span class="nc" id="L2698">            reset();</span>
        } else {
<span class="fc" id="L2700">            disconnectInternal();</span>
        }
<span class="fc" id="L2702">    }</span>

    /**
     * Disconnect from the server (for internal use)
     */
    private void disconnectInternal() {
<span class="fc" id="L2708">        responseCode = -1;</span>
<span class="fc" id="L2709">        inputStream = null;</span>
<span class="pc bpc" id="L2710" title="1 of 2 branches missed.">        if (pi != null) {</span>
<span class="nc" id="L2711">            pi.finishTracking();</span>
<span class="nc" id="L2712">            pi = null;</span>
        }
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        if (http != null) {</span>
<span class="fc" id="L2715">            http.closeServer();</span>
<span class="fc" id="L2716">            http = null;</span>
<span class="fc" id="L2717">            connected = false;</span>
        }
<span class="fc" id="L2719">    }</span>

    /**
     * Disconnect from the server (public API)
     */
    public void disconnect() {

<span class="fc" id="L2726">        responseCode = -1;</span>
<span class="pc bpc" id="L2727" title="1 of 2 branches missed.">        if (pi != null) {</span>
<span class="nc" id="L2728">            pi.finishTracking();</span>
<span class="nc" id="L2729">            pi = null;</span>
        }

<span class="fc bfc" id="L2732" title="All 2 branches covered.">        if (http != null) {</span>
            /*
             * If we have an input stream this means we received a response
             * from the server. That stream may have been read to EOF and
             * dependening on the stream type may already be closed or the
             * the http client may be returned to the keep-alive cache.
             * If the http client has been returned to the keep-alive cache
             * it may be closed (idle timeout) or may be allocated to
             * another request.
             *
             * In other to avoid timing issues we close the input stream
             * which will either close the underlying connection or return
             * the client to the cache. If there's a possibility that the
             * client has been returned to the cache (ie: stream is a keep
             * alive stream or a chunked input stream) then we remove an
             * idle connection to the server. Note that this approach
             * can be considered an approximation in that we may close a
             * different idle connection to that used by the request.
             * Additionally it's possible that we close two connections
             * - the first becuase it wasn't an EOF (and couldn't be
             * hurried) - the second, another idle connection to the
             * same server. The is okay because &quot;disconnect&quot; is an
             * indication that the application doesn't intend to access
             * this http server for a while.
             */

<span class="fc bfc" id="L2758" title="All 2 branches covered.">            if (inputStream != null) {</span>
<span class="fc" id="L2759">                HttpClient hc = http;</span>

                // un-synchronized
<span class="fc" id="L2762">                boolean ka = hc.isKeepingAlive();</span>

                try {
<span class="fc" id="L2765">                    inputStream.close();</span>
<span class="pc" id="L2766">                } catch (IOException ioe) { }</span>

                // if the connection is persistent it may have been closed
                // or returned to the keep-alive cache. If it's been returned
                // to the keep-alive cache then we would like to close it
                // but it may have been allocated

<span class="fc bfc" id="L2773" title="All 2 branches covered.">                if (ka) {</span>
<span class="fc" id="L2774">                    hc.closeIdleConnection();</span>
                }


<span class="fc" id="L2778">            } else {</span>
                // We are deliberatly being disconnected so HttpClient
                // should not try to resend the request no matter what stage
                // of the connection we are in.
<span class="fc" id="L2782">                http.setDoNotRetry(true);</span>

<span class="fc" id="L2784">                http.closeServer();</span>
            }

            //      poster = null;
<span class="fc" id="L2788">            http = null;</span>
<span class="fc" id="L2789">            connected = false;</span>
        }
<span class="fc" id="L2791">        cachedInputStream = null;</span>
<span class="fc bfc" id="L2792" title="All 2 branches covered.">        if (cachedHeaders != null) {</span>
<span class="fc" id="L2793">            cachedHeaders.reset();</span>
        }
<span class="fc" id="L2795">    }</span>

    public boolean usingProxy() {
<span class="pc bpc" id="L2798" title="1 of 2 branches missed.">        if (http != null) {</span>
<span class="fc bfc" id="L2799" title="All 2 branches covered.">            return (http.getProxyHostUsed() != null);</span>
        }
<span class="nc" id="L2801">        return false;</span>
    }

    // constant strings represent set-cookie header names
    private final static String SET_COOKIE = &quot;set-cookie&quot;;
    private final static String SET_COOKIE2 = &quot;set-cookie2&quot;;

    /**
     * Returns a filtered version of the given headers value.
     *
     * Note: The implementation currently only filters out HttpOnly cookies
     *       from Set-Cookie and Set-Cookie2 headers.
     */
    private String filterHeaderField(String name, String value) {
<span class="fc bfc" id="L2815" title="All 2 branches covered.">        if (value == null)</span>
<span class="fc" id="L2816">            return null;</span>

<span class="pc bpc" id="L2818" title="1 of 2 branches missed.">        if (SET_COOKIE.equalsIgnoreCase(name) ||</span>
<span class="fc bfc" id="L2819" title="All 2 branches covered.">            SET_COOKIE2.equalsIgnoreCase(name)) {</span>

            // Filtering only if there is a cookie handler. [Assumption: the
            // cookie handler will store/retrieve the HttpOnly cookies]
<span class="pc bpc" id="L2823" title="3 of 4 branches missed.">            if (cookieHandler == null || value.length() == 0)</span>
<span class="fc" id="L2824">                return value;</span>

            sun.misc.JavaNetHttpCookieAccess access =
<span class="nc" id="L2827">                    sun.misc.SharedSecrets.getJavaNetHttpCookieAccess();</span>
<span class="nc" id="L2828">            StringBuilder retValue = new StringBuilder();</span>
<span class="nc" id="L2829">            List&lt;HttpCookie&gt; cookies = access.parse(value);</span>
<span class="nc" id="L2830">            boolean multipleCookies = false;</span>
<span class="nc bnc" id="L2831" title="All 2 branches missed.">            for (HttpCookie cookie : cookies) {</span>
                // skip HttpOnly cookies
<span class="nc bnc" id="L2833" title="All 2 branches missed.">                if (cookie.isHttpOnly())</span>
<span class="nc" id="L2834">                    continue;</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">                if (multipleCookies)</span>
<span class="nc" id="L2836">                    retValue.append(',');  // RFC 2965, comma separated</span>
<span class="nc" id="L2837">                retValue.append(access.header(cookie));</span>
<span class="nc" id="L2838">                multipleCookies = true;</span>
<span class="nc" id="L2839">            }</span>

<span class="nc bnc" id="L2841" title="All 2 branches missed.">            return retValue.length() == 0 ? &quot;&quot; : retValue.toString();</span>
        }

<span class="fc" id="L2844">        return value;</span>
    }

    // Cache the filtered response headers so that they don't need
    // to be generated for every getHeaderFields() call.
    private Map&lt;String, List&lt;String&gt;&gt; filteredHeaders;  // null

    private Map&lt;String, List&lt;String&gt;&gt; getFilteredHeaderFields() {
<span class="fc bfc" id="L2852" title="All 2 branches covered.">        if (filteredHeaders != null)</span>
<span class="fc" id="L2853">            return filteredHeaders;</span>

<span class="fc" id="L2855">        Map&lt;String, List&lt;String&gt;&gt; headers, tmpMap = new HashMap&lt;&gt;();</span>

<span class="pc bpc" id="L2857" title="1 of 2 branches missed.">        if (cachedHeaders != null)</span>
<span class="nc" id="L2858">            headers = cachedHeaders.getHeaders();</span>
        else
<span class="fc" id="L2860">            headers = responses.getHeaders();</span>

<span class="fc bfc" id="L2862" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; e: headers.entrySet()) {</span>
<span class="fc" id="L2863">            String key = e.getKey();</span>
<span class="fc" id="L2864">            List&lt;String&gt; values = e.getValue(), filteredVals = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2865" title="All 2 branches covered.">            for (String value : values) {</span>
<span class="fc" id="L2866">                String fVal = filterHeaderField(key, value);</span>
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">                if (fVal != null)</span>
<span class="fc" id="L2868">                    filteredVals.add(fVal);</span>
<span class="fc" id="L2869">            }</span>
<span class="pc bpc" id="L2870" title="1 of 2 branches missed.">            if (!filteredVals.isEmpty())</span>
<span class="fc" id="L2871">                tmpMap.put(key, Collections.unmodifiableList(filteredVals));</span>
<span class="fc" id="L2872">        }</span>

<span class="fc" id="L2874">        return filteredHeaders = Collections.unmodifiableMap(tmpMap);</span>
    }

    /**
     * Gets a header field by name. Returns null if not known.
     * @param name the name of the header field
     */
    @Override
    public String getHeaderField(String name) {
        try {
<span class="fc" id="L2884">            getInputStream();</span>
<span class="pc" id="L2885">        } catch (IOException e) {}</span>

<span class="fc bfc" id="L2887" title="All 2 branches covered.">        if (cachedHeaders != null) {</span>
<span class="fc" id="L2888">            return filterHeaderField(name, cachedHeaders.findValue(name));</span>
        }

<span class="fc" id="L2891">        return filterHeaderField(name, responses.findValue(name));</span>
    }

    /**
     * Returns an unmodifiable Map of the header fields.
     * The Map keys are Strings that represent the
     * response-header field names. Each Map value is an
     * unmodifiable List of Strings that represents
     * the corresponding field values.
     *
     * @return a Map of header fields
     * @since 1.4
     */
    @Override
    public Map&lt;String, List&lt;String&gt;&gt; getHeaderFields() {
        try {
<span class="fc" id="L2907">            getInputStream();</span>
<span class="pc" id="L2908">        } catch (IOException e) {}</span>

<span class="fc" id="L2910">        return getFilteredHeaderFields();</span>
    }

    /**
     * Gets a header field by index. Returns null if not known.
     * @param n the index of the header field
     */
    @Override
    public String getHeaderField(int n) {
        try {
<span class="fc" id="L2920">            getInputStream();</span>
<span class="fc" id="L2921">        } catch (IOException e) {}</span>

<span class="fc bfc" id="L2923" title="All 2 branches covered.">        if (cachedHeaders != null) {</span>
<span class="fc" id="L2924">           return filterHeaderField(cachedHeaders.getKey(n),</span>
<span class="fc" id="L2925">                                    cachedHeaders.getValue(n));</span>
        }
<span class="fc" id="L2927">        return filterHeaderField(responses.getKey(n), responses.getValue(n));</span>
    }

    /**
     * Gets a header field by index. Returns null if not known.
     * @param n the index of the header field
     */
    @Override
    public String getHeaderFieldKey(int n) {
        try {
<span class="nc" id="L2937">            getInputStream();</span>
<span class="nc" id="L2938">        } catch (IOException e) {}</span>

<span class="nc bnc" id="L2940" title="All 2 branches missed.">        if (cachedHeaders != null) {</span>
<span class="nc" id="L2941">            return cachedHeaders.getKey(n);</span>
        }

<span class="nc" id="L2944">        return responses.getKey(n);</span>
    }

    /**
     * Sets request property. If a property with the key already
     * exists, overwrite its value with the new value.
     * @param value the value to be set
     */
    @Override
    public synchronized void setRequestProperty(String key, String value) {
<span class="pc bpc" id="L2954" title="2 of 4 branches missed.">        if (connected || connecting)</span>
<span class="nc" id="L2955">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc bfc" id="L2956" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L2957">            throw new NullPointerException (&quot;key is null&quot;);</span>

<span class="pc bpc" id="L2959" title="1 of 2 branches missed.">        if (isExternalMessageHeaderAllowed(key, value)) {</span>
<span class="fc" id="L2960">            requests.set(key, value);</span>
<span class="fc bfc" id="L2961" title="All 2 branches covered.">            if (!key.equalsIgnoreCase(&quot;Content-Type&quot;)) {</span>
<span class="fc" id="L2962">                userHeaders.set(key, value);</span>
            }
        }
<span class="fc" id="L2965">    }</span>

    MessageHeader getUserSetHeaders() {
<span class="fc" id="L2968">        return userHeaders;</span>
    }

    /**
     * Adds a general request property specified by a
     * key-value pair.  This method will not overwrite
     * existing values associated with the same key.
     *
     * @param   key     the keyword by which the request is known
     *                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).
     * @param   value  the value associated with it.
     * @see #getRequestProperties(java.lang.String)
     * @since 1.4
     */
    @Override
    public synchronized void addRequestProperty(String key, String value) {
<span class="pc bpc" id="L2984" title="2 of 4 branches missed.">        if (connected || connecting)</span>
<span class="nc" id="L2985">            throw new IllegalStateException(&quot;Already connected&quot;);</span>
<span class="fc bfc" id="L2986" title="All 2 branches covered.">        if (key == null)</span>
<span class="fc" id="L2987">            throw new NullPointerException (&quot;key is null&quot;);</span>

<span class="pc bpc" id="L2989" title="1 of 2 branches missed.">        if (isExternalMessageHeaderAllowed(key, value)) {</span>
<span class="fc" id="L2990">            requests.add(key, value);</span>
<span class="pc bpc" id="L2991" title="1 of 2 branches missed.">            if (!key.equalsIgnoreCase(&quot;Content-Type&quot;)) {</span>
<span class="fc" id="L2992">                    userHeaders.add(key, value);</span>
            }
        }
<span class="fc" id="L2995">    }</span>

    //
    // Set a property for authentication.  This can safely disregard
    // the connected test.
    //
    public void setAuthenticationProperty(String key, String value) {
<span class="fc" id="L3002">        checkMessageHeader(key, value);</span>
<span class="fc" id="L3003">        requests.set(key, value);</span>
<span class="fc" id="L3004">    }</span>

    @Override
    public synchronized String getRequestProperty (String key) {
<span class="pc bpc" id="L3008" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="fc" id="L3009">            return null;</span>
        }

        // don't return headers containing security sensitive information
<span class="nc bnc" id="L3013" title="All 2 branches missed.">        for (int i=0; i &lt; EXCLUDE_HEADERS.length; i++) {</span>
<span class="nc bnc" id="L3014" title="All 2 branches missed.">            if (key.equalsIgnoreCase(EXCLUDE_HEADERS[i])) {</span>
<span class="nc" id="L3015">                return null;</span>
            }
        }
<span class="nc bnc" id="L3018" title="All 2 branches missed.">        if (!setUserCookies) {</span>
<span class="nc bnc" id="L3019" title="All 2 branches missed.">            if (key.equalsIgnoreCase(&quot;Cookie&quot;)) {</span>
<span class="nc" id="L3020">                return userCookies;</span>
            }
<span class="nc bnc" id="L3022" title="All 2 branches missed.">            if (key.equalsIgnoreCase(&quot;Cookie2&quot;)) {</span>
<span class="nc" id="L3023">                return userCookies2;</span>
            }
        }
<span class="nc" id="L3026">        return requests.findValue(key);</span>
    }

    /**
     * Returns an unmodifiable Map of general request
     * properties for this connection. The Map keys
     * are Strings that represent the request-header
     * field names. Each Map value is a unmodifiable List
     * of Strings that represents the corresponding
     * field values.
     *
     * @return  a Map of the general request properties for this connection.
     * @throws IllegalStateException if already connected
     * @since 1.4
     */
    @Override
    public synchronized Map&lt;String, List&lt;String&gt;&gt; getRequestProperties() {
<span class="pc bpc" id="L3043" title="1 of 2 branches missed.">        if (connected)</span>
<span class="nc" id="L3044">            throw new IllegalStateException(&quot;Already connected&quot;);</span>

        // exclude headers containing security-sensitive info
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">        if (setUserCookies) {</span>
<span class="fc" id="L3048">            return requests.getHeaders(EXCLUDE_HEADERS);</span>
        }
        /*
         * The cookies in the requests message headers may have
         * been modified. Use the saved user cookies instead.
         */
<span class="nc" id="L3054">        Map&lt;String, List&lt;String&gt;&gt; userCookiesMap = null;</span>
<span class="nc bnc" id="L3055" title="All 4 branches missed.">        if (userCookies != null || userCookies2 != null) {</span>
<span class="nc" id="L3056">            userCookiesMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">            if (userCookies != null) {</span>
<span class="nc" id="L3058">                userCookiesMap.put(&quot;Cookie&quot;, Arrays.asList(userCookies));</span>
            }
<span class="nc bnc" id="L3060" title="All 2 branches missed.">            if (userCookies2 != null) {</span>
<span class="nc" id="L3061">                userCookiesMap.put(&quot;Cookie2&quot;, Arrays.asList(userCookies2));</span>
            }
        }
<span class="nc" id="L3064">        return requests.filterAndAddHeaders(EXCLUDE_HEADERS2, userCookiesMap);</span>
    }

    @Override
    public void setConnectTimeout(int timeout) {
<span class="nc bnc" id="L3069" title="All 2 branches missed.">        if (timeout &lt; 0)</span>
<span class="nc" id="L3070">            throw new IllegalArgumentException(&quot;timeouts can't be negative&quot;);</span>
<span class="nc" id="L3071">        connectTimeout = timeout;</span>
<span class="nc" id="L3072">    }</span>


    /**
     * Returns setting for connect timeout.
     * &lt;p&gt;
     * 0 return implies that the option is disabled
     * (i.e., timeout of infinity).
     *
     * @return an &lt;code&gt;int&lt;/code&gt; that indicates the connect timeout
     *         value in milliseconds
     * @see java.net.URLConnection#setConnectTimeout(int)
     * @see java.net.URLConnection#connect()
     * @since 1.5
     */
    @Override
    public int getConnectTimeout() {
<span class="nc bnc" id="L3089" title="All 2 branches missed.">        return (connectTimeout &lt; 0 ? 0 : connectTimeout);</span>
    }

    /**
     * Sets the read timeout to a specified timeout, in
     * milliseconds. A non-zero value specifies the timeout when
     * reading from Input stream when a connection is established to a
     * resource. If the timeout expires before there is data available
     * for read, a java.net.SocketTimeoutException is raised. A
     * timeout of zero is interpreted as an infinite timeout.
     *
     * &lt;p&gt; Some non-standard implementation of this method ignores the
     * specified timeout. To see the read timeout set, please call
     * getReadTimeout().
     *
     * @param timeout an &lt;code&gt;int&lt;/code&gt; that specifies the timeout
     * value to be used in milliseconds
     * @throws IllegalArgumentException if the timeout parameter is negative
     *
     * @see java.net.URLConnectiongetReadTimeout()
     * @see java.io.InputStream#read()
     * @since 1.5
     */
    @Override
    public void setReadTimeout(int timeout) {
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">        if (timeout &lt; 0)</span>
<span class="nc" id="L3115">            throw new IllegalArgumentException(&quot;timeouts can't be negative&quot;);</span>
<span class="fc" id="L3116">        readTimeout = timeout;</span>
<span class="fc" id="L3117">    }</span>

    /**
     * Returns setting for read timeout. 0 return implies that the
     * option is disabled (i.e., timeout of infinity).
     *
     * @return an &lt;code&gt;int&lt;/code&gt; that indicates the read timeout
     *         value in milliseconds
     *
     * @see java.net.URLConnection#setReadTimeout(int)
     * @see java.io.InputStream#read()
     * @since 1.5
     */
    @Override
    public int getReadTimeout() {
<span class="nc bnc" id="L3132" title="All 2 branches missed.">        return readTimeout &lt; 0 ? 0 : readTimeout;</span>
    }

    public CookieHandler getCookieHandler() {
<span class="fc" id="L3136">        return cookieHandler;</span>
    }

    String getMethod() {
<span class="fc" id="L3140">        return method;</span>
    }

    private MessageHeader mapToMessageHeader(Map&lt;String, List&lt;String&gt;&gt; map) {
<span class="fc" id="L3144">        MessageHeader headers = new MessageHeader();</span>
<span class="pc bpc" id="L3145" title="2 of 4 branches missed.">        if (map == null || map.isEmpty()) {</span>
<span class="nc" id="L3146">            return headers;</span>
        }
<span class="fc bfc" id="L3148" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L3149">            String key = entry.getKey();</span>
<span class="fc" id="L3150">            List&lt;String&gt; values = entry.getValue();</span>
<span class="fc bfc" id="L3151" title="All 2 branches covered.">            for (String value : values) {</span>
<span class="fc bfc" id="L3152" title="All 2 branches covered.">                if (key == null) {</span>
<span class="fc" id="L3153">                    headers.prepend(key, value);</span>
                } else {
<span class="fc" id="L3155">                    headers.add(key, value);</span>
                }
<span class="fc" id="L3157">            }</span>
<span class="fc" id="L3158">        }</span>
<span class="fc" id="L3159">        return headers;</span>
    }

    /* The purpose of this wrapper is just to capture the close() call
     * so we can check authentication information that may have
     * arrived in a Trailer field
     */
    class HttpInputStream extends FilterInputStream {
        private CacheRequest cacheRequest;
        private OutputStream outputStream;
<span class="fc" id="L3169">        private boolean marked = false;</span>
<span class="fc" id="L3170">        private int inCache = 0;</span>
<span class="fc" id="L3171">        private int markCount = 0;</span>
        private boolean closed;  // false

<span class="fc" id="L3174">        public HttpInputStream (InputStream is) {</span>
<span class="fc" id="L3175">            super (is);</span>
<span class="fc" id="L3176">            this.cacheRequest = null;</span>
<span class="fc" id="L3177">            this.outputStream = null;</span>
<span class="fc" id="L3178">        }</span>

<span class="fc" id="L3180">        public HttpInputStream (InputStream is, CacheRequest cacheRequest) {</span>
<span class="fc" id="L3181">            super (is);</span>
<span class="fc" id="L3182">            this.cacheRequest = cacheRequest;</span>
            try {
<span class="fc" id="L3184">                this.outputStream = cacheRequest.getBody();</span>
<span class="nc" id="L3185">            } catch (IOException ioex) {</span>
<span class="nc" id="L3186">                this.cacheRequest.abort();</span>
<span class="nc" id="L3187">                this.cacheRequest = null;</span>
<span class="nc" id="L3188">                this.outputStream = null;</span>
<span class="fc" id="L3189">            }</span>
<span class="fc" id="L3190">        }</span>

        /**
         * Marks the current position in this input stream. A subsequent
         * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at
         * the last marked position so that subsequent reads re-read the same
         * bytes.
         * &lt;p&gt;
         * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to
         * allow that many bytes to be read before the mark position gets
         * invalidated.
         * &lt;p&gt;
         * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.
         *
         * @param   readlimit   the maximum limit of bytes that can be read before
         *                      the mark position becomes invalid.
         * @see     java.io.FilterInputStream#in
         * @see     java.io.FilterInputStream#reset()
         */
        @Override
        public synchronized void mark(int readlimit) {
<span class="fc" id="L3211">            super.mark(readlimit);</span>
<span class="pc bpc" id="L3212" title="1 of 2 branches missed.">            if (cacheRequest != null) {</span>
<span class="fc" id="L3213">                marked = true;</span>
<span class="fc" id="L3214">                markCount = 0;</span>
            }
<span class="fc" id="L3216">        }</span>

        /**
         * Repositions this stream to the position at the time the
         * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
         * &lt;p&gt;
         * This method
         * simply performs &lt;code&gt;in.reset()&lt;/code&gt;.
         * &lt;p&gt;
         * Stream marks are intended to be used in
         * situations where you need to read ahead a little to see what's in
         * the stream. Often this is most easily done by invoking some
         * general parser. If the stream is of the type handled by the
         * parse, it just chugs along happily. If the stream is not of
         * that type, the parser should toss an exception when it fails.
         * If this happens within readlimit bytes, it allows the outer
         * code to reset the stream and try another parser.
         *
         * @exception  IOException  if the stream has not been marked or if the
         *               mark has been invalidated.
         * @see        java.io.FilterInputStream#in
         * @see        java.io.FilterInputStream#mark(int)
         */
        @Override
        public synchronized void reset() throws IOException {
<span class="fc" id="L3241">            super.reset();</span>
<span class="pc bpc" id="L3242" title="1 of 2 branches missed.">            if (cacheRequest != null) {</span>
<span class="fc" id="L3243">                marked = false;</span>
<span class="fc" id="L3244">                inCache += markCount;</span>
            }
<span class="fc" id="L3246">        }</span>

        private void ensureOpen() throws IOException {
<span class="fc bfc" id="L3249" title="All 2 branches covered.">            if (closed)</span>
<span class="fc" id="L3250">                throw new IOException(&quot;stream is closed&quot;);</span>
<span class="fc" id="L3251">        }</span>

        @Override
        public int read() throws IOException {
<span class="fc" id="L3255">            ensureOpen();</span>
            try {
<span class="fc" id="L3257">                byte[] b = new byte[1];</span>
<span class="fc" id="L3258">                int ret = read(b);</span>
<span class="fc bfc" id="L3259" title="All 2 branches covered.">                return (ret == -1? ret : (b[0] &amp; 0x00FF));</span>
<span class="fc" id="L3260">            } catch (IOException ioex) {</span>
<span class="pc bpc" id="L3261" title="1 of 2 branches missed.">                if (cacheRequest != null) {</span>
<span class="nc" id="L3262">                    cacheRequest.abort();</span>
                }
<span class="fc" id="L3264">                throw ioex;</span>
            }
        }

        @Override
        public int read(byte[] b) throws IOException {
<span class="fc" id="L3270">            return read(b, 0, b.length);</span>
        }

        @Override
        public int read(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L3275">            ensureOpen();</span>
            try {
<span class="fc" id="L3277">                int newLen = super.read(b, off, len);</span>
                int nWrite;
                // write to cache
<span class="fc bfc" id="L3280" title="All 2 branches covered.">                if (inCache &gt; 0) {</span>
<span class="fc bfc" id="L3281" title="All 2 branches covered.">                    if (inCache &gt;= newLen) {</span>
<span class="fc" id="L3282">                        inCache -= newLen;</span>
<span class="fc" id="L3283">                        nWrite = 0;</span>
                    } else {
<span class="fc" id="L3285">                        nWrite = newLen - inCache;</span>
<span class="fc" id="L3286">                        inCache = 0;</span>
                    }
                } else {
<span class="fc" id="L3289">                    nWrite = newLen;</span>
                }
<span class="fc bfc" id="L3291" title="All 4 branches covered.">                if (nWrite &gt; 0 &amp;&amp; outputStream != null)</span>
<span class="fc" id="L3292">                    outputStream.write(b, off + (newLen-nWrite), nWrite);</span>
<span class="fc bfc" id="L3293" title="All 2 branches covered.">                if (marked) {</span>
<span class="fc" id="L3294">                    markCount += newLen;</span>
                }
<span class="fc" id="L3296">                return newLen;</span>
<span class="fc" id="L3297">            } catch (IOException ioex) {</span>
<span class="pc bpc" id="L3298" title="1 of 2 branches missed.">                if (cacheRequest != null) {</span>
<span class="nc" id="L3299">                    cacheRequest.abort();</span>
                }
<span class="fc" id="L3301">                throw ioex;</span>
            }
        }

        /* skip() calls read() in order to ensure that entire response gets
         * cached. same implementation as InputStream.skip */

        private byte[] skipBuffer;
        private static final int SKIP_BUFFER_SIZE = 8096;

        @Override
        public long skip (long n) throws IOException {
<span class="fc" id="L3313">            ensureOpen();</span>
<span class="fc" id="L3314">            long remaining = n;</span>
            int nr;
<span class="pc bpc" id="L3316" title="1 of 2 branches missed.">            if (skipBuffer == null)</span>
<span class="fc" id="L3317">                skipBuffer = new byte[SKIP_BUFFER_SIZE];</span>

<span class="fc" id="L3319">            byte[] localSkipBuffer = skipBuffer;</span>

<span class="pc bpc" id="L3321" title="1 of 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc" id="L3322">                return 0;</span>
            }

<span class="fc bfc" id="L3325" title="All 2 branches covered.">            while (remaining &gt; 0) {</span>
<span class="fc" id="L3326">                nr = read(localSkipBuffer, 0,</span>
<span class="fc" id="L3327">                          (int) Math.min(SKIP_BUFFER_SIZE, remaining));</span>
<span class="pc bpc" id="L3328" title="1 of 2 branches missed.">                if (nr &lt; 0) {</span>
<span class="nc" id="L3329">                    break;</span>
                }
<span class="fc" id="L3331">                remaining -= nr;</span>
            }

<span class="fc" id="L3334">            return n - remaining;</span>
        }

        @Override
        public void close () throws IOException {
<span class="pc bpc" id="L3339" title="1 of 2 branches missed.">            if (closed)</span>
<span class="nc" id="L3340">                return;</span>

            try {
<span class="fc bfc" id="L3343" title="All 2 branches covered.">                if (outputStream != null) {</span>
<span class="pc bpc" id="L3344" title="1 of 2 branches missed.">                    if (read() != -1) {</span>
<span class="nc" id="L3345">                        cacheRequest.abort();</span>
                    } else {
<span class="fc" id="L3347">                        outputStream.close();</span>
                    }
                }
<span class="fc" id="L3350">                super.close ();</span>
<span class="nc" id="L3351">            } catch (IOException ioex) {</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">                if (cacheRequest != null) {</span>
<span class="nc" id="L3353">                    cacheRequest.abort();</span>
                }
<span class="nc" id="L3355">                throw ioex;</span>
            } finally {
<span class="pc" id="L3357">                closed = true;</span>
<span class="pc" id="L3358">                HttpURLConnection.this.http = null;</span>
<span class="pc" id="L3359">                checkResponseCredentials (true);</span>
<span class="fc" id="L3360">            }</span>
<span class="fc" id="L3361">        }</span>
    }

    class StreamingOutputStream extends FilterOutputStream {

        long expected;
        long written;
        boolean closed;
        boolean error;
        IOException errorExcp;

        /**
         * expectedLength == -1 if the stream is chunked
         * expectedLength &gt; 0 if the stream is fixed content-length
         *    In the 2nd case, we make sure the expected number of
         *    of bytes are actually written
         */
<span class="fc" id="L3378">        StreamingOutputStream (OutputStream os, long expectedLength) {</span>
<span class="fc" id="L3379">            super (os);</span>
<span class="fc" id="L3380">            expected = expectedLength;</span>
<span class="fc" id="L3381">            written = 0L;</span>
<span class="fc" id="L3382">            closed = false;</span>
<span class="fc" id="L3383">            error = false;</span>
<span class="fc" id="L3384">        }</span>

        @Override
        public void write (int b) throws IOException {
<span class="fc" id="L3388">            checkError();</span>
<span class="fc" id="L3389">            written ++;</span>
<span class="pc bpc" id="L3390" title="3 of 4 branches missed.">            if (expected != -1L &amp;&amp; written &gt; expected) {</span>
<span class="nc" id="L3391">                throw new IOException (&quot;too many bytes written&quot;);</span>
            }
<span class="fc" id="L3393">            out.write (b);</span>
<span class="fc" id="L3394">        }</span>

        @Override
        public void write (byte[] b) throws IOException {
<span class="fc" id="L3398">            write (b, 0, b.length);</span>
<span class="fc" id="L3399">        }</span>

        @Override
        public void write (byte[] b, int off, int len) throws IOException {
<span class="fc" id="L3403">            checkError();</span>
<span class="fc" id="L3404">            written += len;</span>
<span class="fc bfc" id="L3405" title="All 4 branches covered.">            if (expected != -1L &amp;&amp; written &gt; expected) {</span>
<span class="fc" id="L3406">                out.close ();</span>
<span class="fc" id="L3407">                throw new IOException (&quot;too many bytes written&quot;);</span>
            }
<span class="fc" id="L3409">            out.write (b, off, len);</span>
<span class="fc" id="L3410">        }</span>

        void checkError () throws IOException {
<span class="pc bpc" id="L3413" title="1 of 2 branches missed.">            if (closed) {</span>
<span class="nc" id="L3414">                throw new IOException (&quot;Stream is closed&quot;);</span>
            }
<span class="pc bpc" id="L3416" title="1 of 2 branches missed.">            if (error) {</span>
<span class="nc" id="L3417">                throw errorExcp;</span>
            }
<span class="fc bfc" id="L3419" title="All 2 branches covered.">            if (((PrintStream)out).checkError()) {</span>
<span class="fc" id="L3420">                throw new IOException(&quot;Error writing request body to server&quot;);</span>
            }
<span class="fc" id="L3422">        }</span>

        /* this is called to check that all the bytes
         * that were supposed to be written were written
         * and that the stream is now closed().
         */
        boolean writtenOK () {
<span class="pc bpc" id="L3429" title="2 of 4 branches missed.">            return closed &amp;&amp; ! error;</span>
        }

        @Override
        public void close () throws IOException {
<span class="fc bfc" id="L3434" title="All 2 branches covered.">            if (closed) {</span>
<span class="fc" id="L3435">                return;</span>
            }
<span class="fc" id="L3437">            closed = true;</span>
<span class="fc bfc" id="L3438" title="All 2 branches covered.">            if (expected != -1L) {</span>
                /* not chunked */
<span class="fc bfc" id="L3440" title="All 2 branches covered.">                if (written != expected) {</span>
<span class="fc" id="L3441">                    error = true;</span>
<span class="fc" id="L3442">                    errorExcp = new IOException (&quot;insufficient data written&quot;);</span>
<span class="fc" id="L3443">                    out.close ();</span>
<span class="fc" id="L3444">                    throw errorExcp;</span>
                }
<span class="fc" id="L3446">                super.flush(); /* can't close the socket */</span>
            } else {
                /* chunked */
<span class="fc" id="L3449">                super.close (); /* force final chunk to be written */</span>
                /* trailing \r\n */
<span class="fc" id="L3451">                OutputStream o = http.getOutputStream();</span>
<span class="fc" id="L3452">                o.write ('\r');</span>
<span class="fc" id="L3453">                o.write ('\n');</span>
<span class="fc" id="L3454">                o.flush();</span>
            }
<span class="fc" id="L3456">        }</span>
    }


    static class ErrorStream extends InputStream {
        ByteBuffer buffer;
        InputStream is;

<span class="nc" id="L3464">        private ErrorStream(ByteBuffer buf) {</span>
<span class="nc" id="L3465">            buffer = buf;</span>
<span class="nc" id="L3466">            is = null;</span>
<span class="nc" id="L3467">        }</span>

<span class="fc" id="L3469">        private ErrorStream(ByteBuffer buf, InputStream is) {</span>
<span class="fc" id="L3470">            buffer = buf;</span>
<span class="fc" id="L3471">            this.is = is;</span>
<span class="fc" id="L3472">        }</span>

        // when this method is called, it's either the case that cl &gt; 0, or
        // if chunk-encoded, cl = -1; in other words, cl can't be 0
        public static InputStream getErrorStream(InputStream is, long cl, HttpClient http) {

            // cl can't be 0; this following is here for extra precaution
<span class="pc bpc" id="L3479" title="1 of 2 branches missed.">            if (cl == 0) {</span>
<span class="nc" id="L3480">                return null;</span>
            }

            try {
                // set SO_TIMEOUT to 1/5th of the total timeout
                // remember the old timeout value so that we can restore it
<span class="fc" id="L3486">                int oldTimeout = http.getReadTimeout();</span>
<span class="fc" id="L3487">                http.setReadTimeout(timeout4ESBuffer/5);</span>

<span class="fc" id="L3489">                long expected = 0;</span>
<span class="fc" id="L3490">                boolean isChunked = false;</span>
                // the chunked case
<span class="pc bpc" id="L3492" title="1 of 2 branches missed.">                if (cl &lt; 0) {</span>
<span class="fc" id="L3493">                    expected = bufSize4ES;</span>
<span class="fc" id="L3494">                    isChunked = true;</span>
                } else {
<span class="nc" id="L3496">                    expected = cl;</span>
                }
<span class="pc bpc" id="L3498" title="1 of 2 branches missed.">                if (expected &lt;= bufSize4ES) {</span>
<span class="fc" id="L3499">                    int exp = (int) expected;</span>
<span class="fc" id="L3500">                    byte[] buffer = new byte[exp];</span>
<span class="fc" id="L3501">                    int count = 0, time = 0, len = 0;</span>
                    do {
                        try {
<span class="fc" id="L3504">                            len = is.read(buffer, count,</span>
                                             buffer.length - count);
<span class="pc bpc" id="L3506" title="1 of 2 branches missed.">                            if (len &lt; 0) {</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">                                if (isChunked) {</span>
                                    // chunked ended
                                    // if chunked ended prematurely,
                                    // an IOException would be thrown
<span class="nc" id="L3511">                                    break;</span>
                                }
                                // the server sends less than cl bytes of data
<span class="nc" id="L3514">                                throw new IOException(&quot;the server closes&quot;+</span>
                                                      &quot; before sending &quot;+cl+
                                                      &quot; bytes of data&quot;);
                            }
<span class="fc" id="L3518">                            count += len;</span>
<span class="nc" id="L3519">                        } catch (SocketTimeoutException ex) {</span>
<span class="nc" id="L3520">                            time += timeout4ESBuffer/5;</span>
<span class="fc" id="L3521">                        }</span>
<span class="pc bpc" id="L3522" title="1 of 4 branches missed.">                    } while (count &lt; exp &amp;&amp; time &lt; timeout4ESBuffer);</span>

                    // reset SO_TIMEOUT to old value
<span class="fc" id="L3525">                    http.setReadTimeout(oldTimeout);</span>

                    // if count &lt; cl at this point, we will not try to reuse
                    // the connection
<span class="pc bpc" id="L3529" title="1 of 2 branches missed.">                    if (count == 0) {</span>
                        // since we haven't read anything,
                        // we will return the underlying
                        // inputstream back to the application
<span class="nc" id="L3533">                        return null;</span>
<span class="pc bpc" id="L3534" title="4 of 8 branches missed.">                    }  else if ((count == expected &amp;&amp; !(isChunked)) || (isChunked &amp;&amp; len &lt;0)) {</span>
                        // put the connection into keep-alive cache
                        // the inputstream will try to do the right thing
<span class="nc" id="L3537">                        is.close();</span>
<span class="nc" id="L3538">                        return new ErrorStream(ByteBuffer.wrap(buffer, 0, count));</span>
                    } else {
                        // we read part of the response body
<span class="fc" id="L3541">                        return new ErrorStream(</span>
<span class="fc" id="L3542">                                      ByteBuffer.wrap(buffer, 0, count), is);</span>
                    }
                }
<span class="nc" id="L3545">                return null;</span>
<span class="nc" id="L3546">            } catch (IOException ioex) {</span>
                // ioex.printStackTrace();
<span class="nc" id="L3548">                return null;</span>
            }
        }

        @Override
        public int available() throws IOException {
<span class="nc bnc" id="L3554" title="All 2 branches missed.">            if (is == null) {</span>
<span class="nc" id="L3555">                return buffer.remaining();</span>
            } else {
<span class="nc" id="L3557">                return buffer.remaining()+is.available();</span>
            }
        }

        public int read() throws IOException {
<span class="nc" id="L3562">            byte[] b = new byte[1];</span>
<span class="nc" id="L3563">            int ret = read(b);</span>
<span class="nc bnc" id="L3564" title="All 2 branches missed.">            return (ret == -1? ret : (b[0] &amp; 0x00FF));</span>
        }

        @Override
        public int read(byte[] b) throws IOException {
<span class="fc" id="L3569">            return read(b, 0, b.length);</span>
        }

        @Override
        public int read(byte[] b, int off, int len) throws IOException {
<span class="fc" id="L3574">            int rem = buffer.remaining();</span>
<span class="fc bfc" id="L3575" title="All 2 branches covered.">            if (rem &gt; 0) {</span>
<span class="pc bpc" id="L3576" title="1 of 2 branches missed.">                int ret = rem &lt; len? rem : len;</span>
<span class="fc" id="L3577">                buffer.get(b, off, ret);</span>
<span class="fc" id="L3578">                return ret;</span>
            } else {
<span class="pc bpc" id="L3580" title="1 of 2 branches missed.">                if (is == null) {</span>
<span class="nc" id="L3581">                    return -1;</span>
                } else {
<span class="fc" id="L3583">                    return is.read(b, off, len);</span>
                }
            }
        }

        @Override
        public void close() throws IOException {
<span class="fc" id="L3590">            buffer = null;</span>
<span class="pc bpc" id="L3591" title="1 of 2 branches missed.">            if (is != null) {</span>
<span class="fc" id="L3592">                is.close();</span>
            }
<span class="fc" id="L3594">        }</span>
    }
}

/** An input stream that just returns EOF.  This is for
 * HTTP URLConnections that are KeepAlive &amp;&amp; use the
 * HEAD method - i.e., stream not dead, but nothing to be read.
 */

<span class="fc" id="L3603">class EmptyInputStream extends InputStream {</span>

    @Override
    public int available() {
<span class="nc" id="L3607">        return 0;</span>
    }

    public int read() {
<span class="fc" id="L3611">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>