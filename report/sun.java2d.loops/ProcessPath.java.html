<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ProcessPath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.loops</a> &gt; <span class="el_source">ProcessPath.java</span></div><h1>ProcessPath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.loops;

import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.QuadCurve2D;
import sun.awt.SunHints;
import java.util.*;

/* This is the java implementation of the native code from
 * src/share/native/sun/java2d/loops/ProcessPath.[c,h]
 * This code is written to be as much similar to the native
 * as it possible. So, it sometimes does not follow java naming conventions.
 *
 * It's important to keep this code synchronized with native one.  See more
 * comments, description and high level scheme of the rendering process in the
 * ProcessPath.c
 */

<span class="nc" id="L44">public class ProcessPath {</span>

    /* Public interfaces and methods for drawing and filling general paths */

    public static abstract class DrawHandler {
        public int xMin;
        public int yMin;
        public int xMax;
        public int yMax;
        public float xMinf;
        public float yMinf;
        public float xMaxf;
        public float yMaxf;

        public int strokeControl;

        public DrawHandler(int xMin, int yMin, int xMax, int yMax,
                           int strokeControl)
<span class="nc" id="L62">        {</span>
<span class="nc" id="L63">            setBounds(xMin, yMin, xMax, yMax, strokeControl);</span>
<span class="nc" id="L64">        }</span>

        public void setBounds(int xMin, int yMin, int xMax, int yMax)
        {
<span class="nc" id="L68">            this.xMin = xMin;</span>
<span class="nc" id="L69">            this.yMin = yMin;</span>
<span class="nc" id="L70">            this.xMax = xMax;</span>
<span class="nc" id="L71">            this.yMax = yMax;</span>

            /*                Setting up fractional clipping box
             *
             * We are using following float -&gt; int mapping:
             *
             *      xi = floor(xf + 0.5)
             *
             * So, fractional values that hit the [xmin, xmax) integer interval
             * will be situated inside the [xmin-0.5, xmax - 0.5) fractional
             * interval. We are using EPSF constant to provide that upper
             * boundary is not included.
             */
<span class="nc" id="L84">            xMinf = xMin - 0.5f;</span>
<span class="nc" id="L85">            yMinf = yMin - 0.5f;</span>
<span class="nc" id="L86">            xMaxf = xMax - 0.5f - EPSF;</span>
<span class="nc" id="L87">            yMaxf = yMax - 0.5f - EPSF;</span>
<span class="nc" id="L88">        }</span>

        public void setBounds(int xMin, int yMin, int xMax, int yMax,
                              int strokeControl)
        {
<span class="nc" id="L93">            this.strokeControl = strokeControl;</span>
<span class="nc" id="L94">            setBounds(xMin, yMin, xMax, yMax);</span>
<span class="nc" id="L95">        }</span>

        public void adjustBounds(int bxMin, int byMin, int bxMax, int byMax)
        {
<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (xMin &gt; bxMin) bxMin = xMin;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (xMax &lt; bxMax) bxMax = xMax;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (yMin &gt; byMin) byMin = yMin;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (yMax &lt; byMax) byMax = yMax;</span>
<span class="nc" id="L103">            setBounds(bxMin, byMin, bxMax, byMax);</span>
<span class="nc" id="L104">        }</span>

        public DrawHandler(int xMin, int yMin, int xMax, int yMax) {
<span class="nc" id="L107">            this(xMin, yMin, xMax, yMax, SunHints.INTVAL_STROKE_DEFAULT);</span>
<span class="nc" id="L108">        }</span>

        public abstract void drawLine(int x0, int y0, int x1, int y1);

        public abstract void drawPixel(int x0, int y0);

        public abstract void drawScanline(int x0, int x1, int y0);
    }

    public interface EndSubPathHandler {
        public void processEndSubPath();
    }

    public static final int PH_MODE_DRAW_CLIP = 0;
    public static final int PH_MODE_FILL_CLIP = 1;

    public static abstract class ProcessHandler implements EndSubPathHandler {
        DrawHandler dhnd;
        int clipMode;

        public ProcessHandler(DrawHandler dhnd,
<span class="nc" id="L129">                              int clipMode) {</span>
<span class="nc" id="L130">            this.dhnd = dhnd;</span>
<span class="nc" id="L131">            this.clipMode = clipMode;</span>
<span class="nc" id="L132">        }</span>

        public abstract void processFixedLine(int x1, int y1,
                                              int x2, int y2, int [] pixelInfo,
                                              boolean checkBounds,
                                              boolean endSubPath);
    }

<span class="nc" id="L140">    public static EndSubPathHandler noopEndSubPathHandler =</span>
<span class="nc" id="L141">        new EndSubPathHandler() {</span>
<span class="nc" id="L142">            public void processEndSubPath() { }</span>
        };

    public static boolean fillPath(DrawHandler dhnd, Path2D.Float p2df,
                                   int transX, int transY)
    {
<span class="nc" id="L148">        FillProcessHandler fhnd = new FillProcessHandler(dhnd);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (!doProcessPath(fhnd, p2df, transX, transY)) {</span>
<span class="nc" id="L150">            return false;</span>
        }
<span class="nc" id="L152">        FillPolygon(fhnd, p2df.getWindingRule());</span>
<span class="nc" id="L153">        return true;</span>
    }

    public static boolean drawPath(DrawHandler dhnd,
                                   EndSubPathHandler endSubPath,
                                   Path2D.Float p2df,
                                   int transX, int transY)
    {
<span class="nc" id="L161">        return doProcessPath(new DrawProcessHandler(dhnd, endSubPath),</span>
                             p2df, transX, transY);
    }

    public static boolean drawPath(DrawHandler dhnd,
                                   Path2D.Float p2df,
                                   int transX, int transY)
    {
<span class="nc" id="L169">        return doProcessPath(new DrawProcessHandler(dhnd,</span>
                                                    noopEndSubPathHandler),
                             p2df, transX, transY);
    }

    /* Private implementation of the rendering process */

    /* Boundaries used for skipping huge path segments */
    private static final float UPPER_BND = Float.MAX_VALUE/4.0f;
    private static final float LOWER_BND = -UPPER_BND;

    /* Precision (in bits) used in forward differencing */
    private static final int FWD_PREC = 7;

    /* Precision (in bits) used for the rounding in the midpoint test */
    private static final int MDP_PREC = 10;

    private static final int MDP_MULT = 1 &lt;&lt; MDP_PREC;
    private static final int MDP_HALF_MULT = MDP_MULT &gt;&gt; 1;

    /* Boundaries used for clipping large path segments (those are inside
     * [UPPER/LOWER]_BND boundaries)
     */
    private static final int UPPER_OUT_BND = 1 &lt;&lt; (30 - MDP_PREC);
    private static final int LOWER_OUT_BND = -UPPER_OUT_BND;


    /* Calculation boundaries. They are used for switching to the more slow but
     * allowing larger input values method of calculation of the initial values
     * of the scan converted line segments inside the FillPolygon
     */
    private static final float CALC_UBND = 1 &lt;&lt; (30 - MDP_PREC);
    private static final float CALC_LBND = -CALC_UBND;


    /* Following constants are used for providing open boundaries of the
     * intervals
     */
    public static final int EPSFX = 1;
    public static final float EPSF = ((float)EPSFX)/MDP_MULT;

    /* Bit mask used to separate whole part from the fraction part of the
     * number
     */
    private static final int MDP_W_MASK = -MDP_MULT;

    /* Bit mask used to separate fractional part from the whole part of the
     * number
     */
    private static final int MDP_F_MASK = MDP_MULT - 1;

    /*
     *                  Constants for the forward differencing
     *                      of the cubic and quad curves
     */

    /* Maximum size of the cubic curve (calculated as the size of the bounding
     * box of the control points) which could be rendered without splitting
     */
    private static final int MAX_CUB_SIZE = 256;

    /* Maximum size of the quad curve (calculated as the size of the bounding
     * box of the control points) which could be rendered without splitting
     */
    private static final int MAX_QUAD_SIZE = 1024;

    /* Default power of 2 steps used in the forward differencing. Here DF prefix
     * stands for DeFault. Constants below are used as initial values for the
     * adaptive forward differencing algorithm.
     */
    private static final int DF_CUB_STEPS = 3;
    private static final int DF_QUAD_STEPS = 2;

    /* Shift of the current point of the curve for preparing to the midpoint
     * rounding
     */
    private static final int DF_CUB_SHIFT = FWD_PREC + DF_CUB_STEPS*3 -
                                            MDP_PREC;
    private static final int DF_QUAD_SHIFT = FWD_PREC + DF_QUAD_STEPS*2 -
                                             MDP_PREC;

    /* Default amount of steps of the forward differencing */
    private static final int DF_CUB_COUNT = (1&lt;&lt;DF_CUB_STEPS);
    private static final int DF_QUAD_COUNT = (1&lt;&lt;DF_QUAD_STEPS);

    /* Default boundary constants used to check the necessity of the restepping
     */
    private static final int DF_CUB_DEC_BND = 1&lt;&lt;DF_CUB_STEPS*3 + FWD_PREC + 2;
    private static final int DF_CUB_INC_BND = 1&lt;&lt;DF_CUB_STEPS*3 + FWD_PREC - 1;
    private static final int DF_QUAD_DEC_BND = 1&lt;&lt;DF_QUAD_STEPS*2 +
                                                  FWD_PREC + 2;
    private static final int DF_QUAD_INC_BND = 1&lt;&lt;DF_QUAD_STEPS*2 +
                                                  FWD_PREC - 1;

    /* Multipliers for the coefficients of the polynomial form of the cubic and
     * quad curves representation
     */
    private static final int CUB_A_SHIFT = FWD_PREC;
    private static final int CUB_B_SHIFT = (DF_CUB_STEPS + FWD_PREC + 1);
    private static final int CUB_C_SHIFT = (DF_CUB_STEPS*2 + FWD_PREC);

    private static final int CUB_A_MDP_MULT = (1&lt;&lt;CUB_A_SHIFT);
    private static final int CUB_B_MDP_MULT = (1&lt;&lt;CUB_B_SHIFT);
    private static final int CUB_C_MDP_MULT = (1&lt;&lt;CUB_C_SHIFT);

    private static final int QUAD_A_SHIFT = FWD_PREC;
    private static final int QUAD_B_SHIFT = (DF_QUAD_STEPS + FWD_PREC);

    private static final int QUAD_A_MDP_MULT = (1&lt;&lt;QUAD_A_SHIFT);
    private static final int QUAD_B_MDP_MULT = (1&lt;&lt;QUAD_B_SHIFT);

    /* Clipping macros for drawing and filling algorithms */
    private static float CLIP(float a1, float b1, float a2, float b2,
                              double t) {
<span class="nc" id="L283">        return (float)(b1 + (double)(t - a1)*(b2 - b1) / (a2 - a1));</span>
    }

    private static int CLIP(int a1, int b1, int a2, int b2, double t) {
<span class="nc" id="L287">        return (int)(b1 + (double)(t - a1)*(b2 - b1) / (a2 - a1));</span>
    }


    private static final int CRES_MIN_CLIPPED = 0;
    private static final int CRES_MAX_CLIPPED = 1;
    private static final int CRES_NOT_CLIPPED = 3;
    private static final int CRES_INVISIBLE = 4;

    private static boolean IS_CLIPPED(int res) {
<span class="nc bnc" id="L297" title="All 4 branches missed.">        return res == CRES_MIN_CLIPPED || res == CRES_MAX_CLIPPED;</span>
    }

    /* This is java implementation of the macro from ProcessGeneralPath.c.
     * To keep the logic of the java code similar to the native one
     * array and set of indexes are used to point out the data.
     */
    private static int TESTANDCLIP(float LINE_MIN, float LINE_MAX, float[] c,
                                   int a1, int b1, int a2, int b2) {
        double t;
<span class="nc" id="L307">        int res = CRES_NOT_CLIPPED;</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">        if (c[a1] &lt; (LINE_MIN) || c[a1] &gt; (LINE_MAX)) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (c[a1] &lt; (LINE_MIN)) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (c[a2] &lt; (LINE_MIN)) {</span>
<span class="nc" id="L311">                    return CRES_INVISIBLE;</span>
                };
<span class="nc" id="L313">                res = CRES_MIN_CLIPPED;</span>
<span class="nc" id="L314">                t = (LINE_MIN);</span>
            } else {
<span class="nc bnc" id="L316" title="All 2 branches missed.">                if (c[a2] &gt; (LINE_MAX)) {</span>
<span class="nc" id="L317">                    return CRES_INVISIBLE;</span>
                };
<span class="nc" id="L319">                res = CRES_MAX_CLIPPED;</span>
<span class="nc" id="L320">                t = (LINE_MAX);</span>
            }
<span class="nc" id="L322">            c[b1] = CLIP(c[a1], c[b1], c[a2], c[b2], t);</span>
<span class="nc" id="L323">            c[a1] = (float)t;</span>
        }
<span class="nc" id="L325">        return res;</span>
    }

    /* Integer version of the method above */
    private static int TESTANDCLIP(int LINE_MIN, int LINE_MAX, int[] c,
                                   int a1, int b1, int a2, int b2) {
        double t;
<span class="nc" id="L332">        int res = CRES_NOT_CLIPPED;</span>
<span class="nc bnc" id="L333" title="All 4 branches missed.">        if (c[a1] &lt; (LINE_MIN) || c[a1] &gt; (LINE_MAX)) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (c[a1] &lt; (LINE_MIN)) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (c[a2] &lt; (LINE_MIN)) {</span>
<span class="nc" id="L336">                    return CRES_INVISIBLE;</span>
                };
<span class="nc" id="L338">                res = CRES_MIN_CLIPPED;</span>
<span class="nc" id="L339">                t = (LINE_MIN);</span>
            } else {
<span class="nc bnc" id="L341" title="All 2 branches missed.">                if (c[a2] &gt; (LINE_MAX)) {</span>
<span class="nc" id="L342">                    return CRES_INVISIBLE;</span>
                };
<span class="nc" id="L344">                res = CRES_MAX_CLIPPED;</span>
<span class="nc" id="L345">                t = (LINE_MAX);</span>
            }
<span class="nc" id="L347">            c[b1] = CLIP(c[a1], c[b1], c[a2], c[b2], t);</span>
<span class="nc" id="L348">            c[a1] = (int)t;</span>
        }
<span class="nc" id="L350">        return res;</span>
    }



    /* Following method is used for clipping and clumping filled shapes.
     * An example of this process is shown on the picture below:
     *                      ----+          ----+
     *                    |/    |        |/    |
     *                    +     |        +     |
     *                   /|     |        I     |
     *                  / |     |        I     |
     *                  | |     |  ===&gt;  I     |
     *                  \ |     |        I     |
     *                   \|     |        I     |
     *                    +     |        +     |
     *                    |\    |        |\    |
     *                    | ----+        | ----+
     *                 boundary       boundary
     *
     * We can only perform clipping in case of right side of the output area
     * because all segments passed out the right boundary don't influence on the
     * result of scan conversion algorithm (it correctly handles half open
     * contours).
     *
     * This is java implementation of the macro from ProcessGeneralPath.c.
     * To keep the logic of the java code similar to the native one
     * array and set of indexes are used to point out the data.
     *
     */
    private static int CLIPCLAMP(float LINE_MIN, float LINE_MAX, float[] c,
                                 int a1, int b1, int a2, int b2,
                                 int a3, int b3) {
<span class="nc" id="L383">        c[a3] = c[a1];</span>
<span class="nc" id="L384">        c[b3] = c[b1];</span>
<span class="nc" id="L385">        int res = TESTANDCLIP(LINE_MIN, LINE_MAX, c, a1, b1, a2, b2);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L387">            c[a3] = c[a1];</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        } else if (res == CRES_MAX_CLIPPED) {</span>
<span class="nc" id="L389">            c[a3] = c[a1];</span>
<span class="nc" id="L390">            res = CRES_MAX_CLIPPED;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        } else if (res == CRES_INVISIBLE) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (c[a1] &gt; LINE_MAX) {</span>
<span class="nc" id="L393">                res =  CRES_INVISIBLE;</span>
            } else {
<span class="nc" id="L395">                c[a1] = LINE_MIN;</span>
<span class="nc" id="L396">                c[a2] = LINE_MIN;</span>
<span class="nc" id="L397">                res = CRES_NOT_CLIPPED;</span>
            }
        }
<span class="nc" id="L400">        return res;</span>
    }

    /* Integer version of the method above */
    private static int CLIPCLAMP(int LINE_MIN, int LINE_MAX, int[] c,
                                 int a1, int b1, int a2, int b2,
                                 int a3, int b3) {
<span class="nc" id="L407">        c[a3] = c[a1];</span>
<span class="nc" id="L408">        c[b3] = c[b1];</span>
<span class="nc" id="L409">        int res = TESTANDCLIP(LINE_MIN, LINE_MAX, c, a1, b1, a2, b2);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L411">            c[a3] = c[a1];</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        } else if (res == CRES_MAX_CLIPPED) {</span>
<span class="nc" id="L413">            c[a3] = c[a1];</span>
<span class="nc" id="L414">            res = CRES_MAX_CLIPPED;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        } else if (res == CRES_INVISIBLE) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (c[a1] &gt; LINE_MAX) {</span>
<span class="nc" id="L417">                res =  CRES_INVISIBLE;</span>
            } else {
<span class="nc" id="L419">                c[a1] = LINE_MIN;</span>
<span class="nc" id="L420">                c[a2] = LINE_MIN;</span>
<span class="nc" id="L421">                res = CRES_NOT_CLIPPED;</span>
            }
        }
<span class="nc" id="L424">        return res;</span>
    }

    private static class DrawProcessHandler extends ProcessHandler {

        EndSubPathHandler processESP;

        public DrawProcessHandler(DrawHandler dhnd,
                                  EndSubPathHandler processESP) {
<span class="nc" id="L433">            super(dhnd, PH_MODE_DRAW_CLIP);</span>
<span class="nc" id="L434">            this.dhnd = dhnd;</span>
<span class="nc" id="L435">            this.processESP = processESP;</span>
<span class="nc" id="L436">        }</span>

        public void processEndSubPath() {
<span class="nc" id="L439">            processESP.processEndSubPath();</span>
<span class="nc" id="L440">        }</span>

        void PROCESS_LINE(int fX0, int fY0, int fX1, int fY1,
                          boolean checkBounds, int[] pixelInfo) {
<span class="nc" id="L444">            int X0 = fX0 &gt;&gt; MDP_PREC;</span>
<span class="nc" id="L445">            int Y0 = fY0 &gt;&gt; MDP_PREC;</span>
<span class="nc" id="L446">            int X1 = fX1 &gt;&gt; MDP_PREC;</span>
<span class="nc" id="L447">            int Y1 = fY1 &gt;&gt; MDP_PREC;</span>

           /* Handling lines having just one pixel */
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (((X0^X1) | (Y0^Y1)) == 0) {</span>
<span class="nc bnc" id="L451" title="All 10 branches missed.">                if (checkBounds &amp;&amp;</span>
                    (dhnd.yMin &gt; Y0  ||
                     dhnd.yMax &lt;= Y0 ||
                     dhnd.xMin &gt; X0  ||
<span class="nc" id="L455">                     dhnd.xMax &lt;= X0)) return;</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (pixelInfo[0] == 0) {</span>
<span class="nc" id="L458">                    pixelInfo[0] = 1;</span>
<span class="nc" id="L459">                    pixelInfo[1] = X0;</span>
<span class="nc" id="L460">                    pixelInfo[2] = Y0;</span>
<span class="nc" id="L461">                    pixelInfo[3] = X0;</span>
<span class="nc" id="L462">                    pixelInfo[4] = Y0;</span>
<span class="nc" id="L463">                    dhnd.drawPixel(X0, Y0);</span>
<span class="nc bnc" id="L464" title="All 8 branches missed.">                } else if ((X0 != pixelInfo[3] || Y0 != pixelInfo[4]) &amp;&amp;</span>
                           (X0 != pixelInfo[1] || Y0 != pixelInfo[2])) {
<span class="nc" id="L466">                    dhnd.drawPixel(X0, Y0);</span>
<span class="nc" id="L467">                    pixelInfo[3] = X0;</span>
<span class="nc" id="L468">                    pixelInfo[4] = Y0;</span>
                }
<span class="nc" id="L470">                return;</span>
            }

<span class="nc bnc" id="L473" title="All 10 branches missed.">            if (!checkBounds ||</span>
                (dhnd.yMin &lt;= Y0  &amp;&amp;
                 dhnd.yMax &gt; Y0 &amp;&amp;
                 dhnd.xMin &lt;= X0  &amp;&amp;
                 dhnd.xMax &gt; X0))
            {
                /* Switch off first pixel of the line before drawing */
<span class="nc bnc" id="L480" title="All 10 branches missed.">                if (pixelInfo[0] == 1 &amp;&amp;</span>
                    ((pixelInfo[1] == X0 &amp;&amp; pixelInfo[2] == Y0) ||
                     (pixelInfo[3] == X0 &amp;&amp; pixelInfo[4] == Y0)))
                {
<span class="nc" id="L484">                    dhnd.drawPixel(X0, Y0);</span>
                }
            }

<span class="nc" id="L488">            dhnd.drawLine(X0, Y0, X1, Y1);</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (pixelInfo[0] == 0) {</span>
<span class="nc" id="L491">                pixelInfo[0] = 1;</span>
<span class="nc" id="L492">                pixelInfo[1] = X0;</span>
<span class="nc" id="L493">                pixelInfo[2] = Y0;</span>
<span class="nc" id="L494">                pixelInfo[3] = X0;</span>
<span class="nc" id="L495">                pixelInfo[4] = Y0;</span>
            }

            /* Switch on last pixel of the line if it was already
             * drawn during rendering of the previous segments
             */
<span class="nc bnc" id="L501" title="All 8 branches missed.">            if ((pixelInfo[1] == X1 &amp;&amp; pixelInfo[2] == Y1) ||</span>
                (pixelInfo[3] == X1 &amp;&amp; pixelInfo[4] == Y1))
            {
<span class="nc bnc" id="L504" title="All 10 branches missed.">                if (checkBounds &amp;&amp;</span>
                    (dhnd.yMin &gt; Y1  ||
                     dhnd.yMax &lt;= Y1 ||
                     dhnd.xMin &gt; X1  ||
                     dhnd.xMax &lt;= X1)) {
<span class="nc" id="L509">                    return;</span>
                }

<span class="nc" id="L512">                dhnd.drawPixel(X1, Y1);</span>
            }
<span class="nc" id="L514">            pixelInfo[3] = X1;</span>
<span class="nc" id="L515">            pixelInfo[4] = Y1;</span>
<span class="nc" id="L516">        }</span>

        void PROCESS_POINT(int fX, int fY, boolean checkBounds,
                           int[] pixelInfo) {
<span class="nc" id="L520">            int _X = fX&gt;&gt; MDP_PREC;</span>
<span class="nc" id="L521">            int _Y = fY&gt;&gt; MDP_PREC;</span>
<span class="nc bnc" id="L522" title="All 10 branches missed.">            if (checkBounds &amp;&amp;</span>
                (dhnd.yMin &gt; _Y  ||
                 dhnd.yMax &lt;= _Y ||
                 dhnd.xMin &gt; _X  ||
<span class="nc" id="L526">                 dhnd.xMax &lt;= _X)) return;</span>
            /*
             *  (_X,_Y) should be inside boundaries
             *
             *  assert(dhnd.yMin &lt;= _Y &amp;&amp;
             *         dhnd.yMax &gt;  _Y &amp;&amp;
             *         dhnd.xMin &lt;= _X &amp;&amp;
             *         dhnd.xMax &gt;  _X);
             *
             */
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (pixelInfo[0] == 0) {</span>
<span class="nc" id="L537">                pixelInfo[0] = 1;</span>
<span class="nc" id="L538">                pixelInfo[1] = _X;</span>
<span class="nc" id="L539">                pixelInfo[2] = _Y;</span>
<span class="nc" id="L540">                pixelInfo[3] = _X;</span>
<span class="nc" id="L541">                pixelInfo[4] = _Y;</span>
<span class="nc" id="L542">                dhnd.drawPixel(_X, _Y);</span>
<span class="nc bnc" id="L543" title="All 8 branches missed.">            } else if ((_X != pixelInfo[3] || _Y != pixelInfo[4]) &amp;&amp;</span>
                       (_X != pixelInfo[1] || _Y != pixelInfo[2])) {
<span class="nc" id="L545">                dhnd.drawPixel(_X, _Y);</span>
<span class="nc" id="L546">                pixelInfo[3] = _X;</span>
<span class="nc" id="L547">                pixelInfo[4] = _Y;</span>
            }
<span class="nc" id="L549">        }</span>

        /*                  Drawing line with subpixel endpoints
         *
         * (x1, y1), (x2, y2) -  fixed point coordinates of the endpoints
         *                       with MDP_PREC bits for the fractional part
         *
         * pixelInfo          -  structure which keeps drawing info for avoiding
         *                       multiple drawing at the same position on the
         *                       screen (required for the XOR mode of drawing)
         *
         *                          pixelInfo[0]   - state of the drawing
         *                                           0 - no pixel drawn between
         *                                           moveTo/close of the path
         *                                           1 - there are drawn pixels
         *
         *                          pixelInfo[1,2] - first pixel of the path
         *                                           between moveTo/close of the
         *                                           path
         *
         *                          pixelInfo[3,4] - last drawn pixel between
         *                                           moveTo/close of the path
         *
         * checkBounds        - flag showing necessity of checking the clip
         *
         */
        public void  processFixedLine(int x1, int y1, int x2, int y2,
                                      int[] pixelInfo, boolean checkBounds,
                                      boolean endSubPath)  {

            /* Checking if line is inside a (X,Y),(X+MDP_MULT,Y+MDP_MULT) box */
<span class="nc" id="L580">            int c = ((x1 ^ x2) | (y1 ^ y2));</span>
            int rx1, ry1, rx2, ry2;
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if ((c &amp; MDP_W_MASK) == 0) {</span>
                /* Checking for the segments with integer coordinates having
                 * the same start and end points
                 */
<span class="nc bnc" id="L586" title="All 2 branches missed.">                if (c == 0) {</span>
<span class="nc" id="L587">                    PROCESS_POINT(x1 + MDP_HALF_MULT, y1 + MDP_HALF_MULT,</span>
                                  checkBounds, pixelInfo);
                }
<span class="nc" id="L590">                return;</span>
            }

<span class="nc bnc" id="L593" title="All 4 branches missed.">            if (x1 == x2 || y1 == y2) {</span>
<span class="nc" id="L594">                rx1 = x1 + MDP_HALF_MULT;</span>
<span class="nc" id="L595">                rx2 = x2 + MDP_HALF_MULT;</span>
<span class="nc" id="L596">                ry1 = y1 + MDP_HALF_MULT;</span>
<span class="nc" id="L597">                ry2 = y2 + MDP_HALF_MULT;</span>
            } else {
                /* Neither dx nor dy can be zero because of the check above */
<span class="nc" id="L600">                int dx = x2 - x1;</span>
<span class="nc" id="L601">                int dy = y2 - y1;</span>

                /* Floor of x1, y1, x2, y2 */
<span class="nc" id="L604">                int fx1 = x1 &amp; MDP_W_MASK;</span>
<span class="nc" id="L605">                int fy1 = y1 &amp; MDP_W_MASK;</span>
<span class="nc" id="L606">                int fx2 = x2 &amp; MDP_W_MASK;</span>
<span class="nc" id="L607">                int fy2 = y2 &amp; MDP_W_MASK;</span>

                /* Processing first endpoint */
<span class="nc bnc" id="L610" title="All 4 branches missed.">                if (fx1 == x1 || fy1 == y1) {</span>
                    /* Adding MDP_HALF_MULT to the [xy]1 if f[xy]1 == [xy]1
                     * will not affect the result
                     */
<span class="nc" id="L614">                    rx1 = x1 + MDP_HALF_MULT;</span>
<span class="nc" id="L615">                    ry1 = y1 + MDP_HALF_MULT;</span>
                } else {
                    /* Boundary at the direction from (x1,y1) to (x2,y2) */
<span class="nc bnc" id="L618" title="All 2 branches missed.">                    int bx1 = (x1 &lt; x2) ? fx1 + MDP_MULT : fx1;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    int by1 = (y1 &lt; y2) ? fy1 + MDP_MULT : fy1;</span>

                    /* intersection with column bx1 */
<span class="nc" id="L622">                    int cross = y1 + ((bx1 - x1)*dy)/dx;</span>
<span class="nc bnc" id="L623" title="All 4 branches missed.">                    if (cross &gt;= fy1 &amp;&amp; cross &lt;= fy1 + MDP_MULT) {</span>
<span class="nc" id="L624">                        rx1 = bx1;</span>
<span class="nc" id="L625">                        ry1 = cross + MDP_HALF_MULT;</span>
                    } else {
                        /* intersection with row by1 */
<span class="nc" id="L628">                        cross = x1 + ((by1 - y1)*dx)/dy;</span>
<span class="nc" id="L629">                        rx1 = cross + MDP_HALF_MULT;</span>
<span class="nc" id="L630">                        ry1 = by1;</span>
                    }
                }

                /* Processing second endpoint */
<span class="nc bnc" id="L635" title="All 4 branches missed.">                if (fx2 == x2 || fy2 == y2) {</span>
                    /* Adding MDP_HALF_MULT to the [xy]2 if f[xy]2 == [xy]2
                     * will not affect the result
                     */
<span class="nc" id="L639">                    rx2 = x2 + MDP_HALF_MULT;</span>
<span class="nc" id="L640">                    ry2 = y2 + MDP_HALF_MULT;</span>
                } else {
                    /* Boundary at the direction from (x2,y2) to (x1,y1) */
<span class="nc bnc" id="L643" title="All 2 branches missed.">                    int bx2 = (x1 &gt; x2) ? fx2 + MDP_MULT : fx2;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                    int by2 = (y1 &gt; y2) ? fy2 + MDP_MULT : fy2;</span>

                    /* intersection with column bx2 */
<span class="nc" id="L647">                    int cross = y2 + ((bx2 - x2)*dy)/dx;</span>
<span class="nc bnc" id="L648" title="All 4 branches missed.">                    if (cross &gt;= fy2 &amp;&amp; cross &lt;= fy2 + MDP_MULT) {</span>
<span class="nc" id="L649">                        rx2 = bx2;</span>
<span class="nc" id="L650">                        ry2 = cross + MDP_HALF_MULT;</span>
                    } else {
                        /* intersection with row by2 */
<span class="nc" id="L653">                        cross = x2 + ((by2 - y2)*dx)/dy;</span>
<span class="nc" id="L654">                        rx2 = cross + MDP_HALF_MULT;</span>
<span class="nc" id="L655">                        ry2 = by2;</span>
                    }
                }
            }
<span class="nc" id="L659">            PROCESS_LINE(rx1, ry1, rx2, ry2, checkBounds, pixelInfo);</span>
<span class="nc" id="L660">        }</span>
    }

    /* Performing drawing of the monotonic in X and Y quadratic curves with
     * sizes less than MAX_QUAD_SIZE by using forward differencing method of
     * calculation. See comments to the DrawMonotonicQuad in the
     * ProcessGeneralPath.c
     */
    private static void DrawMonotonicQuad(ProcessHandler hnd,
                                          float[] coords,
                                          boolean checkBounds,
                                          int[] pixelInfo) {

<span class="nc" id="L673">        int x0 = (int)(coords[0]*MDP_MULT);</span>
<span class="nc" id="L674">        int y0 = (int)(coords[1]*MDP_MULT);</span>

<span class="nc" id="L676">        int xe = (int)(coords[4]*MDP_MULT);</span>
<span class="nc" id="L677">        int ye = (int)(coords[5]*MDP_MULT);</span>

        /* Extracting fractional part of coordinates of first control point */
<span class="nc" id="L680">        int px = (x0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_QUAD_SHIFT;</span>
<span class="nc" id="L681">        int py = (y0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_QUAD_SHIFT;</span>

        /* Setting default amount of steps */
<span class="nc" id="L684">        int count = DF_QUAD_COUNT;</span>

        /* Setting default shift for preparing to the midpoint rounding */
<span class="nc" id="L687">        int shift =  DF_QUAD_SHIFT;</span>

<span class="nc" id="L689">        int ax = (int)((coords[0] - 2*coords[2] +</span>
                         coords[4])*QUAD_A_MDP_MULT);
<span class="nc" id="L691">        int ay = (int)((coords[1] - 2*coords[3] +</span>
                         coords[5])*QUAD_A_MDP_MULT);

<span class="nc" id="L694">        int bx = (int)((-2*coords[0] + 2*coords[2])*QUAD_B_MDP_MULT);</span>
<span class="nc" id="L695">        int by = (int)((-2*coords[1] + 2*coords[3])*QUAD_B_MDP_MULT);</span>

<span class="nc" id="L697">        int ddpx = 2*ax;</span>
<span class="nc" id="L698">        int ddpy = 2*ay;</span>

<span class="nc" id="L700">        int dpx = ax + bx;</span>
<span class="nc" id="L701">        int dpy = ay + by;</span>

        int x1, y1;

<span class="nc" id="L705">        int x2 = x0;</span>
<span class="nc" id="L706">        int y2 = y0;</span>

<span class="nc" id="L708">        int maxDD = Math.max(Math.abs(ddpx),Math.abs(ddpy));</span>

<span class="nc" id="L710">        int dx = xe - x0;</span>
<span class="nc" id="L711">        int dy = ye - y0;</span>

<span class="nc" id="L713">        int x0w = x0 &amp; MDP_W_MASK;</span>
<span class="nc" id="L714">        int y0w = y0 &amp; MDP_W_MASK;</span>

        /* Perform decreasing step in 2 times if slope of the first forward
         * difference changes too quickly (more than a pixel per step in X or Y
         * direction).  We can perform adjusting of the step size before the
         * rendering loop because the curvature of the quad curve remains the
         * same along all the curve
         */
<span class="nc bnc" id="L722" title="All 2 branches missed.">        while (maxDD &gt; DF_QUAD_DEC_BND) {</span>
<span class="nc" id="L723">            dpx = (dpx&lt;&lt;1) - ax;</span>
<span class="nc" id="L724">            dpy = (dpy&lt;&lt;1) - ay;</span>
<span class="nc" id="L725">            count &lt;&lt;= 1;</span>
<span class="nc" id="L726">            maxDD &gt;&gt;= 2;</span>
<span class="nc" id="L727">            px &lt;&lt;=2;</span>
<span class="nc" id="L728">            py &lt;&lt;=2;</span>
<span class="nc" id="L729">            shift += 2;</span>
        }

<span class="nc bnc" id="L732" title="All 2 branches missed.">        while(count-- &gt; 1) {</span>
<span class="nc" id="L733">            px += dpx;</span>
<span class="nc" id="L734">            py += dpy;</span>

<span class="nc" id="L736">            dpx += ddpx;</span>
<span class="nc" id="L737">            dpy += ddpy;</span>

<span class="nc" id="L739">            x1 = x2;</span>
<span class="nc" id="L740">            y1 = y2;</span>

<span class="nc" id="L742">            x2 = x0w + (px &gt;&gt; shift);</span>
<span class="nc" id="L743">            y2 = y0w + (py &gt;&gt; shift);</span>

            /* Checking that we are not running out of the endpoint and bounding
             * violating coordinate.  The check is pretty simple because the
             * curve passed to the DrawCubic already split into the
             * monotonic in X and Y pieces
             */

            /* Bounding x2 by xe */
<span class="nc bnc" id="L752" title="All 2 branches missed.">            if (((xe-x2)^dx) &lt; 0) {</span>
<span class="nc" id="L753">                x2 = xe;</span>
            }

            /* Bounding y2 by ye */
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (((ye-y2)^dy) &lt; 0) {</span>
<span class="nc" id="L758">                y2 = ye;</span>
            }

<span class="nc" id="L761">            hnd.processFixedLine(x1, y1, x2, y2, pixelInfo, checkBounds, false);</span>
        }

        /* We are performing one step less than necessary and use actual
         * (xe,ye) endpoint of the curve instead of calculated. This prevent us
         * from running above the curve endpoint due to the accumulated errors
         * during the iterations.
         */

<span class="nc" id="L770">        hnd.processFixedLine(x2, y2, xe, ye, pixelInfo, checkBounds, false);</span>
<span class="nc" id="L771">    }</span>

    /*
     * Checking size of the quad curves and split them if necessary.
     * Calling DrawMonotonicQuad for the curves of the appropriate size.
     * Note: coords array could be changed
     */
    private static void ProcessMonotonicQuad(ProcessHandler hnd,
                                             float[] coords,
                                             int[] pixelInfo) {

<span class="nc" id="L782">        float[] coords1 = new float[6];</span>
        float tx, ty;
        float xMin, yMin, xMax, yMax;

<span class="nc" id="L786">        xMin = xMax = coords[0];</span>
<span class="nc" id="L787">        yMin = yMax = coords[1];</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">        for (int i = 2; i &lt; 6; i += 2) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            xMin = (xMin &gt; coords[i])? coords[i] : xMin;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">            xMax = (xMax &lt; coords[i])? coords[i] : xMax;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            yMin = (yMin &gt; coords[i + 1])? coords[i + 1] : yMin;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            yMax = (yMax &lt; coords[i + 1])? coords[i + 1] : yMax;</span>
        }

<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</span>

           /* In case of drawing we could just skip curves which are
            * completely out of bounds
            */
<span class="nc bnc" id="L800" title="All 8 branches missed.">           if (hnd.dhnd.xMaxf &lt; xMin || hnd.dhnd.xMinf &gt; xMax ||</span>
               hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax) {
<span class="nc" id="L802">               return;</span>
           }
        } else {

            /* In case of filling we could skip curves which are above,
             * below and behind the right boundary of the visible area
             */

<span class="nc bnc" id="L810" title="All 6 branches missed.">            if (hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax ||</span>
                hnd.dhnd.xMaxf &lt; xMin)
            {
<span class="nc" id="L813">                return;</span>
            }

            /* We could clamp x coordinates to the corresponding boundary
             * if the curve is completely behind the left one
             */

<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (hnd.dhnd.xMinf &gt; xMax) {</span>
<span class="nc" id="L821">                coords[0] = coords[2] = coords[4] = hnd.dhnd.xMinf;</span>
            }
        }

<span class="nc bnc" id="L825" title="All 4 branches missed.">        if (xMax - xMin &gt; MAX_QUAD_SIZE || yMax - yMin &gt; MAX_QUAD_SIZE) {</span>
<span class="nc" id="L826">            coords1[4] = coords[4];</span>
<span class="nc" id="L827">            coords1[5] = coords[5];</span>
<span class="nc" id="L828">            coords1[2] = (coords[2] + coords[4])/2.0f;</span>
<span class="nc" id="L829">            coords1[3] = (coords[3] + coords[5])/2.0f;</span>
<span class="nc" id="L830">            coords[2] = (coords[0] + coords[2])/2.0f;</span>
<span class="nc" id="L831">            coords[3] = (coords[1] + coords[3])/2.0f;</span>
<span class="nc" id="L832">            coords[4] = coords1[0] = (coords[2] + coords1[2])/2.0f;</span>
<span class="nc" id="L833">            coords[5] = coords1[1] = (coords[3] + coords1[3])/2.0f;</span>

<span class="nc" id="L835">            ProcessMonotonicQuad(hnd, coords, pixelInfo);</span>

<span class="nc" id="L837">            ProcessMonotonicQuad(hnd, coords1, pixelInfo);</span>
        } else {
<span class="nc bnc" id="L839" title="All 8 branches missed.">            DrawMonotonicQuad(hnd, coords,</span>
                              /* Set checkBounds parameter if curve intersects
                               * boundary of the visible area. We know that the
                               * curve is visible, so the check is pretty
                               * simple
                               */
                              hnd.dhnd.xMinf &gt;= xMin ||
                              hnd.dhnd.xMaxf &lt;= xMax ||
                              hnd.dhnd.yMinf &gt;= yMin ||
                              hnd.dhnd.yMaxf &lt;= yMax,
                              pixelInfo);
        }
<span class="nc" id="L851">    }</span>

    /*
     * Split quadratic curve into monotonic in X and Y parts. Calling
     * ProcessMonotonicQuad for each monotonic piece of the curve.
     * Note: coords array could be changed
     */
    private static void ProcessQuad(ProcessHandler hnd, float[] coords,
                                    int[] pixelInfo) {
        /* Temporary array for holding parameters corresponding to the extreme
         * in X and Y points
         */
<span class="nc" id="L863">        double params[] = new double[2];</span>
<span class="nc" id="L864">        int cnt = 0;</span>
        double param;

        /* Simple check for monotonicity in X before searching for the extreme
         * points of the X(t) function. We first check if the curve is
         * monotonic in X by seeing if all of the X coordinates are strongly
         * ordered.
         */
<span class="nc bnc" id="L872" title="All 8 branches missed.">        if ((coords[0] &gt; coords[2] || coords[2] &gt; coords[4]) &amp;&amp;</span>
            (coords[0] &lt; coords[2] || coords[2] &lt; coords[4]))
        {
            /* Searching for extreme points of the X(t) function  by solving
             * dX(t)
             * ----  = 0 equation
             *  dt
             */
<span class="nc" id="L880">            double ax = coords[0] - 2*coords[2] + coords[4];</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">            if (ax != 0) {</span>
                /* Calculating root of the following equation
                 * ax*t + bx = 0
                 */
<span class="nc" id="L885">                double bx = coords[0] - coords[2];</span>

<span class="nc" id="L887">                param = bx/ax;</span>
<span class="nc bnc" id="L888" title="All 4 branches missed.">                if (param &lt; 1.0 &amp;&amp; param &gt; 0.0) {</span>
<span class="nc" id="L889">                    params[cnt++] = param;</span>
                }
            }
        }

        /* Simple check for monotonicity in Y before searching for the extreme
         * points of the Y(t) function. We first check if the curve is
         * monotonic in Y by seeing if all of the Y coordinates are strongly
         * ordered.
         */
<span class="nc bnc" id="L899" title="All 8 branches missed.">        if ((coords[1] &gt; coords[3] || coords[3] &gt; coords[5]) &amp;&amp;</span>
            (coords[1] &lt; coords[3] || coords[3] &lt; coords[5]))
        {
            /* Searching for extreme points of the Y(t) function by solving
             * dY(t)
             * ----- = 0 equation
             *  dt
             */
<span class="nc" id="L907">            double ay = coords[1] - 2*coords[3] + coords[5];</span>

<span class="nc bnc" id="L909" title="All 2 branches missed.">            if (ay != 0) {</span>
                /* Calculating root of the following equation
                 * ay*t + by = 0
                 */
<span class="nc" id="L913">                double by = coords[1] - coords[3];</span>

<span class="nc" id="L915">                param = by/ay;</span>
<span class="nc bnc" id="L916" title="All 4 branches missed.">                if (param &lt; 1.0 &amp;&amp; param &gt; 0.0) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                    if (cnt &gt; 0) {</span>
                        /* Inserting parameter only if it differs from
                         * already stored
                         */
<span class="nc bnc" id="L921" title="All 2 branches missed.">                        if (params[0] &gt;  param) {</span>
<span class="nc" id="L922">                            params[cnt++] = params[0];</span>
<span class="nc" id="L923">                            params[0] = param;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                        } else if (params[0] &lt;  param) {</span>
<span class="nc" id="L925">                            params[cnt++] = param;</span>
                        }
                    } else {
<span class="nc" id="L928">                        params[cnt++] = param;</span>
                    }
                }
            }
        }

        /* Processing obtained monotonic parts */
<span class="nc bnc" id="L935" title="All 4 branches missed.">        switch(cnt) {</span>
            case 0:
<span class="nc" id="L937">                break;</span>
            case 1:
<span class="nc" id="L939">                ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</span>
                                                (float)params[0]);
<span class="nc" id="L941">                break;</span>
            case 2:
<span class="nc" id="L943">                ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</span>
                                                (float)params[0]);
<span class="nc" id="L945">                param = params[1] - params[0];</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                if (param &gt; 0) {</span>
<span class="nc" id="L947">                    ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</span>
                                           /* Scale parameter to match with
                                            * rest of the curve
                                            */
                                           (float)(param/(1.0 - params[0])));
                }
                break;
        }

<span class="nc" id="L956">        ProcessMonotonicQuad(hnd,coords,pixelInfo);</span>
<span class="nc" id="L957">    }</span>

    /*
     * Bite the piece of the quadratic curve from start point till the point
     * corresponding to the specified parameter then call ProcessQuad for the
     * bitten part.
     * Note: coords array will be changed
     */
    private static void ProcessFirstMonotonicPartOfQuad(ProcessHandler hnd,
                                                        float[] coords,
                                                        int[] pixelInfo,
                                                        float t) {
<span class="nc" id="L969">        float[] coords1 = new float[6];</span>

<span class="nc" id="L971">        coords1[0] = coords[0];</span>
<span class="nc" id="L972">        coords1[1] = coords[1];</span>
<span class="nc" id="L973">        coords1[2] = coords[0] + t*(coords[2] - coords[0]);</span>
<span class="nc" id="L974">        coords1[3] = coords[1] + t*(coords[3] - coords[1]);</span>
<span class="nc" id="L975">        coords[2] = coords[2] + t*(coords[4] - coords[2]);</span>
<span class="nc" id="L976">        coords[3] = coords[3] + t*(coords[5] - coords[3]);</span>
<span class="nc" id="L977">        coords[0] = coords1[4] = coords1[2] + t*(coords[2] - coords1[2]);</span>
<span class="nc" id="L978">        coords[1] = coords1[5] = coords1[3] + t*(coords[3] - coords1[3]);</span>

<span class="nc" id="L980">        ProcessMonotonicQuad(hnd, coords1, pixelInfo);</span>
<span class="nc" id="L981">    }</span>

    /* Performing drawing of the monotonic in X and Y cubic curves with sizes
     * less than MAX_CUB_SIZE by using forward differencing method of
     * calculation.  See comments to the DrawMonotonicCubic in the
     * ProcessGeneralPath.c
     */
    private static void DrawMonotonicCubic(ProcessHandler hnd,
                                           float[] coords,
                                           boolean checkBounds,
                                           int[] pixelInfo) {
<span class="nc" id="L992">        int x0 = (int)(coords[0]*MDP_MULT);</span>
<span class="nc" id="L993">        int y0 = (int)(coords[1]*MDP_MULT);</span>

<span class="nc" id="L995">        int xe = (int)(coords[6]*MDP_MULT);</span>
<span class="nc" id="L996">        int ye = (int)(coords[7]*MDP_MULT);</span>

        /* Extracting fractional part of coordinates of first control point */
<span class="nc" id="L999">        int px = (x0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_CUB_SHIFT;</span>
<span class="nc" id="L1000">        int py = (y0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_CUB_SHIFT;</span>

        /* Setting default boundary values for checking first and second forward
         * difference for the necessity of the restepping. See comments to the
         * boundary values in ProcessQuad for more info.
         */
<span class="nc" id="L1006">        int incStepBnd = DF_CUB_INC_BND;</span>
<span class="nc" id="L1007">        int decStepBnd = DF_CUB_DEC_BND;</span>

        /* Setting default amount of steps */
<span class="nc" id="L1010">        int count = DF_CUB_COUNT;</span>

        /* Setting default shift for preparing to the midpoint rounding */
<span class="nc" id="L1013">        int shift =  DF_CUB_SHIFT;</span>

<span class="nc" id="L1015">        int ax = (int)((-coords[0] + 3*coords[2] - 3*coords[4] +</span>
                 coords[6])*CUB_A_MDP_MULT);
<span class="nc" id="L1017">        int ay = (int)((-coords[1] + 3*coords[3] - 3*coords[5] +</span>
                 coords[7])*CUB_A_MDP_MULT);

<span class="nc" id="L1020">        int bx = (int)((3*coords[0] - 6*coords[2] +</span>
                 3*coords[4])*CUB_B_MDP_MULT);
<span class="nc" id="L1022">        int by = (int)((3*coords[1] - 6*coords[3] +</span>
                 3*coords[5])*CUB_B_MDP_MULT);

<span class="nc" id="L1025">        int cx = (int)((-3*coords[0] + 3*coords[2])*(CUB_C_MDP_MULT));</span>
<span class="nc" id="L1026">        int cy = (int)((-3*coords[1] + 3*coords[3])*(CUB_C_MDP_MULT));</span>

<span class="nc" id="L1028">        int dddpx = 6*ax;</span>
<span class="nc" id="L1029">        int dddpy = 6*ay;</span>

<span class="nc" id="L1031">        int ddpx = dddpx + bx;</span>
<span class="nc" id="L1032">        int ddpy = dddpy + by;</span>

<span class="nc" id="L1034">        int dpx = ax + (bx&gt;&gt;1) + cx;</span>
<span class="nc" id="L1035">        int dpy = ay + (by&gt;&gt;1) + cy;</span>

        int x1, y1;

<span class="nc" id="L1039">        int x2 = x0;</span>
<span class="nc" id="L1040">        int y2 = y0;</span>

        /* Calculating whole part of the first point of the curve */
<span class="nc" id="L1043">        int x0w = x0 &amp; MDP_W_MASK;</span>
<span class="nc" id="L1044">        int y0w = y0 &amp; MDP_W_MASK;</span>

<span class="nc" id="L1046">        int dx = xe - x0;</span>
<span class="nc" id="L1047">        int dy = ye - y0;</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">        while (count &gt; 0) {</span>
            /* Perform decreasing step in 2 times if necessary */
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            while (Math.abs(ddpx) &gt; decStepBnd ||</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                   Math.abs(ddpy) &gt; decStepBnd) {</span>
<span class="nc" id="L1053">                ddpx = (ddpx&lt;&lt;1) - dddpx;</span>
<span class="nc" id="L1054">                ddpy = (ddpy&lt;&lt;1) - dddpy;</span>
<span class="nc" id="L1055">                dpx = (dpx&lt;&lt;2) - (ddpx&gt;&gt;1);</span>
<span class="nc" id="L1056">                dpy = (dpy&lt;&lt;2) - (ddpy&gt;&gt;1);</span>
<span class="nc" id="L1057">                count &lt;&lt;=1;</span>
<span class="nc" id="L1058">                decStepBnd &lt;&lt;=3;</span>
<span class="nc" id="L1059">                incStepBnd &lt;&lt;=3;</span>
<span class="nc" id="L1060">                px &lt;&lt;=3;</span>
<span class="nc" id="L1061">                py &lt;&lt;=3;</span>
<span class="nc" id="L1062">                shift += 3;</span>
            }

            /* Perform increasing step in 2 times if necessary.
             * Note: we could do it only in even steps
             */

<span class="nc bnc" id="L1069" title="All 4 branches missed.">            while ((count &amp; 1) == 0 &amp;&amp; shift &gt; DF_CUB_SHIFT &amp;&amp;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                   Math.abs(dpx) &lt;= incStepBnd &amp;&amp;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                   Math.abs(dpy) &lt;= incStepBnd) {</span>
<span class="nc" id="L1072">                dpx = (dpx&gt;&gt;2) + (ddpx&gt;&gt;3);</span>
<span class="nc" id="L1073">                dpy = (dpy&gt;&gt;2) + (ddpy&gt;&gt;3);</span>
<span class="nc" id="L1074">                ddpx = (ddpx + dddpx)&gt;&gt;1;</span>
<span class="nc" id="L1075">                ddpy = (ddpy + dddpy)&gt;&gt;1;</span>
<span class="nc" id="L1076">                count &gt;&gt;=1;</span>
<span class="nc" id="L1077">                decStepBnd &gt;&gt;=3;</span>
<span class="nc" id="L1078">                incStepBnd &gt;&gt;=3;</span>
<span class="nc" id="L1079">                px &gt;&gt;=3;</span>
<span class="nc" id="L1080">                py &gt;&gt;=3;</span>
<span class="nc" id="L1081">                shift -= 3;</span>
            }

<span class="nc" id="L1084">            count--;</span>

            /* Performing one step less than necessary and use actual (xe,ye)
             * curve's endpoint instead of calculated. This prevent us from
             * running above the curve endpoint due to the accumulated errors
             * during the iterations.
             */
<span class="nc bnc" id="L1091" title="All 2 branches missed.">            if (count &gt; 0) {</span>
<span class="nc" id="L1092">                px += dpx;</span>
<span class="nc" id="L1093">                py += dpy;</span>

<span class="nc" id="L1095">                dpx += ddpx;</span>
<span class="nc" id="L1096">                dpy += ddpy;</span>
<span class="nc" id="L1097">                ddpx += dddpx;</span>
<span class="nc" id="L1098">                ddpy += dddpy;</span>

<span class="nc" id="L1100">                x1 = x2;</span>
<span class="nc" id="L1101">                y1 = y2;</span>

<span class="nc" id="L1103">                x2 = x0w + (px &gt;&gt; shift);</span>
<span class="nc" id="L1104">                y2 = y0w + (py &gt;&gt; shift);</span>

                /* Checking that we are not running out of the endpoint and
                 * bounding violating coordinate.  The check is pretty simple
                 * because the curve passed to the DrawCubic already split
                 * into the monotonic in X and Y pieces
                 */

                /* Bounding x2 by xe */
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                if (((xe-x2)^dx) &lt; 0) {</span>
<span class="nc" id="L1114">                    x2 = xe;</span>
                }

                /* Bounding y2 by ye */
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (((ye-y2)^dy) &lt; 0) {</span>
<span class="nc" id="L1119">                    y2 = ye;</span>
                }

<span class="nc" id="L1122">                hnd.processFixedLine(x1, y1, x2, y2, pixelInfo, checkBounds,</span>
                                     false);
            } else {
<span class="nc" id="L1125">                hnd.processFixedLine(x2, y2, xe, ye, pixelInfo, checkBounds,</span>
                                     false);
            }
        }
<span class="nc" id="L1129">    }</span>

    /*
     * Checking size of the cubic curves and split them if necessary.
     * Calling DrawMonotonicCubic for the curves of the appropriate size.
     * Note: coords array could be changed
     */
    private static void ProcessMonotonicCubic(ProcessHandler hnd,
                                              float[] coords,
                                              int[] pixelInfo) {

<span class="nc" id="L1140">        float[] coords1 = new float[8];</span>
        float tx, ty;
        float xMin, xMax;
        float yMin, yMax;

<span class="nc" id="L1145">        xMin = xMax = coords[0];</span>
<span class="nc" id="L1146">        yMin = yMax = coords[1];</span>

<span class="nc bnc" id="L1148" title="All 2 branches missed.">        for (int i = 2; i &lt; 8; i += 2) {</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            xMin = (xMin &gt; coords[i])? coords[i] : xMin;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">            xMax = (xMax &lt; coords[i])? coords[i] : xMax;</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            yMin = (yMin &gt; coords[i + 1])? coords[i + 1] : yMin;</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">            yMax = (yMax &lt; coords[i + 1])? coords[i + 1] : yMax;</span>
        }

<span class="nc bnc" id="L1155" title="All 2 branches missed.">        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</span>
            /* In case of drawing we could just skip curves which are
             * completely out of bounds
             */
<span class="nc bnc" id="L1159" title="All 8 branches missed.">            if (hnd.dhnd.xMaxf &lt; xMin || hnd.dhnd.xMinf &gt; xMax ||</span>
                hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax) {
<span class="nc" id="L1161">                return;</span>
            }
        } else {

            /* In case of filling we could skip curves which are above,
             * below and behind the right boundary of the visible area
             */

<span class="nc bnc" id="L1169" title="All 6 branches missed.">            if (hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax ||</span>
                hnd.dhnd.xMaxf &lt; xMin)
            {
<span class="nc" id="L1172">                return;</span>
            }

            /* We could clamp x coordinates to the corresponding boundary
             * if the curve is completely behind the left one
             */

<span class="nc bnc" id="L1179" title="All 2 branches missed.">            if (hnd.dhnd.xMinf &gt; xMax) {</span>
<span class="nc" id="L1180">                coords[0] = coords[2] = coords[4] = coords[6] =</span>
                    hnd.dhnd.xMinf;
            }
        }

<span class="nc bnc" id="L1185" title="All 4 branches missed.">        if (xMax - xMin &gt; MAX_CUB_SIZE || yMax - yMin &gt; MAX_CUB_SIZE) {</span>
<span class="nc" id="L1186">            coords1[6] = coords[6];</span>
<span class="nc" id="L1187">            coords1[7] = coords[7];</span>
<span class="nc" id="L1188">            coords1[4] = (coords[4] + coords[6])/2.0f;</span>
<span class="nc" id="L1189">            coords1[5] = (coords[5] + coords[7])/2.0f;</span>
<span class="nc" id="L1190">            tx = (coords[2] + coords[4])/2.0f;</span>
<span class="nc" id="L1191">            ty = (coords[3] + coords[5])/2.0f;</span>
<span class="nc" id="L1192">            coords1[2] = (tx + coords1[4])/2.0f;</span>
<span class="nc" id="L1193">            coords1[3] = (ty + coords1[5])/2.0f;</span>
<span class="nc" id="L1194">            coords[2] =  (coords[0] + coords[2])/2.0f;</span>
<span class="nc" id="L1195">            coords[3] =  (coords[1] + coords[3])/2.0f;</span>
<span class="nc" id="L1196">            coords[4] = (coords[2] + tx)/2.0f;</span>
<span class="nc" id="L1197">            coords[5] = (coords[3] + ty)/2.0f;</span>
<span class="nc" id="L1198">            coords[6]=coords1[0]=(coords[4] + coords1[2])/2.0f;</span>
<span class="nc" id="L1199">            coords[7]=coords1[1]=(coords[5] + coords1[3])/2.0f;</span>

<span class="nc" id="L1201">            ProcessMonotonicCubic(hnd, coords, pixelInfo);</span>

<span class="nc" id="L1203">            ProcessMonotonicCubic(hnd, coords1, pixelInfo);</span>
        } else {
<span class="nc bnc" id="L1205" title="All 8 branches missed.">            DrawMonotonicCubic(hnd, coords,</span>
                               /* Set checkBounds parameter if curve intersects
                                * boundary of the visible area. We know that
                                * the curve is visible, so the check is pretty
                                * simple
                                */
                                hnd.dhnd.xMinf &gt; xMin ||
                                hnd.dhnd.xMaxf &lt; xMax ||
                                hnd.dhnd.yMinf &gt; yMin ||
                                hnd.dhnd.yMaxf &lt; yMax,
                                pixelInfo);
        }
<span class="nc" id="L1217">    }</span>

    /*
     * Split cubic curve into monotonic in X and Y parts. Calling
     * ProcessMonotonicCubic for each monotonic piece of the curve.
     *
     * Note: coords array could be changed
     */
    private static void ProcessCubic(ProcessHandler hnd,
                                     float[] coords,
                                     int[] pixelInfo) {
        /* Temporary array for holding parameters corresponding to the extreme
         * in X and Y points
         */
<span class="nc" id="L1231">        double params[] = new double[4];</span>
<span class="nc" id="L1232">        double eqn[] = new double[3];</span>
<span class="nc" id="L1233">        double res[] = new double[2];</span>
<span class="nc" id="L1234">        int cnt = 0;</span>

        /* Simple check for monotonicity in X before searching for the extreme
         * points of the X(t) function. We first check if the curve is
         * monotonic in X by seeing if all of the X coordinates are strongly
         * ordered.
         */
<span class="nc bnc" id="L1241" title="All 12 branches missed.">        if ((coords[0] &gt; coords[2] || coords[2] &gt; coords[4] ||</span>
             coords[4] &gt; coords[6]) &amp;&amp;
            (coords[0] &lt; coords[2] || coords[2] &lt; coords[4] ||
             coords[4] &lt; coords[6]))
        {
            /* Searching for extreme points of the X(t) function  by solving
             * dX(t)
             * ----  = 0 equation
             *  dt
             */
<span class="nc" id="L1251">            eqn[2] = -coords[0] + 3*coords[2] - 3*coords[4] + coords[6];</span>
<span class="nc" id="L1252">            eqn[1] = 2*(coords[0] - 2*coords[2] + coords[4]);</span>
<span class="nc" id="L1253">            eqn[0] = -coords[0] + coords[2];</span>

<span class="nc" id="L1255">            int nr = QuadCurve2D.solveQuadratic(eqn, res);</span>

            /* Following code also correctly works in degenerate case of
             * the quadratic equation (nr = -1) because we do not need
             * splitting in this case.
             */
<span class="nc bnc" id="L1261" title="All 2 branches missed.">            for (int i = 0; i &lt; nr; i++) {</span>
<span class="nc bnc" id="L1262" title="All 4 branches missed.">                if (res[i] &gt; 0 &amp;&amp; res[i] &lt; 1) {</span>
<span class="nc" id="L1263">                    params[cnt++] = res[i];</span>
                }
            }
        }

        /* Simple check for monotonicity in Y before searching for the extreme
         * points of the Y(t) function. We first check if the curve is
         * monotonic in Y by seeing if all of the Y coordinates are strongly
         * ordered.
         */
<span class="nc bnc" id="L1273" title="All 12 branches missed.">        if ((coords[1] &gt; coords[3] || coords[3] &gt; coords[5] ||</span>
             coords[5] &gt; coords[7]) &amp;&amp;
            (coords[1] &lt; coords[3] || coords[3] &lt; coords[5] ||
             coords[5] &lt; coords[7]))
        {
            /* Searching for extreme points of the Y(t) function by solving
             * dY(t)
             * ----- = 0 equation
             *  dt
             */
<span class="nc" id="L1283">            eqn[2] = -coords[1] + 3*coords[3] - 3*coords[5] + coords[7];</span>
<span class="nc" id="L1284">            eqn[1] = 2*(coords[1] - 2*coords[3] + coords[5]);</span>
<span class="nc" id="L1285">            eqn[0] = -coords[1] + coords[3];</span>

<span class="nc" id="L1287">            int nr = QuadCurve2D.solveQuadratic(eqn, res);</span>

            /* Following code also correctly works in degenerate case of
             * the quadratic equation (nr = -1) because we do not need
             * splitting in this case.
             */
<span class="nc bnc" id="L1293" title="All 2 branches missed.">            for (int i = 0; i &lt; nr; i++) {</span>
<span class="nc bnc" id="L1294" title="All 4 branches missed.">                if (res[i] &gt; 0 &amp;&amp; res[i] &lt; 1) {</span>
<span class="nc" id="L1295">                    params[cnt++] = res[i];</span>
                }
            }
        }

<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (cnt &gt; 0) {</span>
            /* Sorting parameter values corresponding to the extreme points
             * of the curve
             */
<span class="nc" id="L1304">            Arrays.sort(params, 0, cnt);</span>

            /* Processing obtained monotonic parts */
<span class="nc" id="L1307">            ProcessFirstMonotonicPartOfCubic(hnd, coords, pixelInfo,</span>
                                             (float)params[0]);
<span class="nc bnc" id="L1309" title="All 2 branches missed.">            for (int i = 1; i &lt; cnt; i++) {</span>
<span class="nc" id="L1310">                double param = params[i] - params[i-1];</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                if (param &gt; 0) {</span>
<span class="nc" id="L1312">                    ProcessFirstMonotonicPartOfCubic(hnd, coords, pixelInfo,</span>
                        /* Scale parameter to match with rest of the curve */
                        (float)(param/(1.0 - params[i - 1])));
                }
            }
        }

<span class="nc" id="L1319">        ProcessMonotonicCubic(hnd,coords,pixelInfo);</span>
<span class="nc" id="L1320">    }</span>

    /*
     * Bite the piece of the cubic curve from start point till the point
     * corresponding to the specified parameter then call ProcessCubic for the
     * bitten part.
     * Note: coords array will be changed
     */
    private static void ProcessFirstMonotonicPartOfCubic(ProcessHandler hnd,
                                                         float[] coords,
                                                         int[] pixelInfo,
                                                         float t)
    {
<span class="nc" id="L1333">        float[] coords1 = new float[8];</span>
        float tx, ty;

<span class="nc" id="L1336">        coords1[0] = coords[0];</span>
<span class="nc" id="L1337">        coords1[1] = coords[1];</span>
<span class="nc" id="L1338">        tx = coords[2] + t*(coords[4] - coords[2]);</span>
<span class="nc" id="L1339">        ty = coords[3] + t*(coords[5] - coords[3]);</span>
<span class="nc" id="L1340">        coords1[2] =  coords[0] + t*(coords[2] - coords[0]);</span>
<span class="nc" id="L1341">        coords1[3] =  coords[1] + t*(coords[3] - coords[1]);</span>
<span class="nc" id="L1342">        coords1[4] = coords1[2] + t*(tx - coords1[2]);</span>
<span class="nc" id="L1343">        coords1[5] = coords1[3] + t*(ty - coords1[3]);</span>
<span class="nc" id="L1344">        coords[4] = coords[4] + t*(coords[6] - coords[4]);</span>
<span class="nc" id="L1345">        coords[5] = coords[5] + t*(coords[7] - coords[5]);</span>
<span class="nc" id="L1346">        coords[2] = tx + t*(coords[4] - tx);</span>
<span class="nc" id="L1347">        coords[3] = ty + t*(coords[5] - ty);</span>
<span class="nc" id="L1348">        coords[0]=coords1[6]=coords1[4] + t*(coords[2] - coords1[4]);</span>
<span class="nc" id="L1349">        coords[1]=coords1[7]=coords1[5] + t*(coords[3] - coords1[5]);</span>

<span class="nc" id="L1351">        ProcessMonotonicCubic(hnd, coords1, pixelInfo);</span>
<span class="nc" id="L1352">    }</span>

    /* Note:
     * For more easy reading of the code below each java version of the macros
     * from the ProcessPath.c preceded by the commented origin call
     * containing verbose names of the parameters
     */
    private static void ProcessLine(ProcessHandler hnd, float x1, float y1,
                                    float x2, float y2, int[] pixelInfo) {
        float xMin, yMin, xMax, yMax;
        int X1, Y1, X2, Y2, X3, Y3, res;
<span class="nc" id="L1363">        boolean clipped = false;</span>
        float x3,y3;
<span class="nc" id="L1365">        float c[] = new float[]{x1, y1, x2, y2, 0, 0};</span>

        boolean lastClipped;

<span class="nc" id="L1369">        xMin = hnd.dhnd.xMinf;</span>
<span class="nc" id="L1370">        yMin = hnd.dhnd.yMinf;</span>
<span class="nc" id="L1371">        xMax = hnd.dhnd.xMaxf;</span>
<span class="nc" id="L1372">        yMax = hnd.dhnd.yMaxf;</span>

        //
        // TESTANDCLIP(yMin, yMax, y1, x1, y2, x2, res);
        //
<span class="nc" id="L1377">        res = TESTANDCLIP(yMin, yMax, c, 1, 0, 3, 2);</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        if (res == CRES_INVISIBLE) return;</span>
<span class="nc" id="L1379">        clipped = IS_CLIPPED(res);</span>
        //
        // TESTANDCLIP(yMin, yMax, y2, x2, y1, x1, res);
        //
<span class="nc" id="L1383">        res = TESTANDCLIP(yMin, yMax, c, 3, 2, 1, 0);</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        if (res == CRES_INVISIBLE) return;</span>
<span class="nc" id="L1385">        lastClipped = IS_CLIPPED(res);</span>
<span class="nc bnc" id="L1386" title="All 4 branches missed.">        clipped = clipped || lastClipped;</span>

<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</span>
            //
            // TESTANDCLIP(xMin, xMax, x1, y1, x2, y2, res);
            //
<span class="nc" id="L1392">            res = TESTANDCLIP(xMin, xMax, c, 0, 1, 2, 3);</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">            if (res == CRES_INVISIBLE) return;</span>
<span class="nc bnc" id="L1394" title="All 4 branches missed.">            clipped = clipped || IS_CLIPPED(res);</span>
            //
            // TESTANDCLIP(xMin, xMax, x2, y2, x1, y1, res);
            //
<span class="nc" id="L1398">            res = TESTANDCLIP(xMin, xMax, c, 2, 3, 0, 1);</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">            if (res == CRES_INVISIBLE) return;</span>
<span class="nc bnc" id="L1400" title="All 4 branches missed.">            lastClipped = lastClipped || IS_CLIPPED(res);</span>
<span class="nc bnc" id="L1401" title="All 4 branches missed.">            clipped = clipped || lastClipped;</span>
<span class="nc" id="L1402">            X1 = (int)(c[0]*MDP_MULT);</span>
<span class="nc" id="L1403">            Y1 = (int)(c[1]*MDP_MULT);</span>
<span class="nc" id="L1404">            X2 = (int)(c[2]*MDP_MULT);</span>
<span class="nc" id="L1405">            Y2 = (int)(c[3]*MDP_MULT);</span>

<span class="nc" id="L1407">            hnd.processFixedLine(X1, Y1, X2, Y2, pixelInfo,</span>
                                 clipped, /* enable boundary checking in
                                             case of clipping to avoid
                                             entering out of bounds which
                                             could happens during rounding
                                           */
                                 lastClipped /* Notify pProcessFixedLine
                                                that
                                                this is the end of the
                                                subpath (because of exiting
                                                out of boundaries)
                                              */
                                 );
        } else {
            /* Clamping starting from first vertex of the the processed
             * segment
             *
             * CLIPCLAMP(xMin, xMax, x1, y1, x2, y2, x3, y3, res);
             */
<span class="nc" id="L1426">            res = CLIPCLAMP(xMin, xMax, c, 0, 1, 2, 3, 4, 5);</span>
<span class="nc" id="L1427">            X1 = (int)(c[0]*MDP_MULT);</span>
<span class="nc" id="L1428">            Y1 = (int)(c[1]*MDP_MULT);</span>

            /* Clamping only by left boundary */
<span class="nc bnc" id="L1431" title="All 2 branches missed.">            if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L1432">                X3 = (int)(c[4]*MDP_MULT);</span>
<span class="nc" id="L1433">                Y3 = (int)(c[5]*MDP_MULT);</span>
<span class="nc" id="L1434">                hnd.processFixedLine(X3, Y3, X1, Y1, pixelInfo,</span>
                                     false, lastClipped);

<span class="nc bnc" id="L1437" title="All 2 branches missed.">            } else if (res == CRES_INVISIBLE) {</span>
<span class="nc" id="L1438">                return;</span>
            }

            /* Clamping starting from last vertex of the the processed
             * segment
             *
             * CLIPCLAMP(xMin, xMax, x2, y2, x1, y1, x3, y3, res);
             */
<span class="nc" id="L1446">            res = CLIPCLAMP(xMin, xMax, c, 2, 3, 0, 1, 4, 5);</span>

            /* Checking if there was a clip by right boundary */
<span class="nc bnc" id="L1449" title="All 4 branches missed.">            lastClipped = lastClipped || (res == CRES_MAX_CLIPPED);</span>

<span class="nc" id="L1451">            X2 = (int)(c[2]*MDP_MULT);</span>
<span class="nc" id="L1452">            Y2 = (int)(c[3]*MDP_MULT);</span>
<span class="nc" id="L1453">            hnd.processFixedLine(X1, Y1, X2, Y2, pixelInfo,</span>
                                 false, lastClipped);

            /* Clamping only by left boundary */
<span class="nc bnc" id="L1457" title="All 2 branches missed.">            if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L1458">                X3 = (int)(c[4]*MDP_MULT);</span>
<span class="nc" id="L1459">                Y3 = (int)(c[5]*MDP_MULT);</span>
<span class="nc" id="L1460">                hnd.processFixedLine(X2, Y2, X3, Y3, pixelInfo,</span>
                                     false, lastClipped);
            }
        }
<span class="nc" id="L1464">    }</span>

    private static boolean doProcessPath(ProcessHandler hnd,
                                         Path2D.Float p2df,
                                         float transXf, float transYf) {
<span class="nc" id="L1469">        float coords[] = new float[8];</span>
<span class="nc" id="L1470">        float tCoords[] = new float[8];</span>
<span class="nc" id="L1471">        float closeCoord[] = new float[] {0.0f, 0.0f};</span>
<span class="nc" id="L1472">        float firstCoord[] = new float[2];</span>
<span class="nc" id="L1473">        int pixelInfo[] = new int[5];</span>
<span class="nc" id="L1474">        boolean subpathStarted = false;</span>
<span class="nc" id="L1475">        boolean skip = false;</span>
        float lastX, lastY;
<span class="nc" id="L1477">        pixelInfo[0] = 0;</span>

        /* Adjusting boundaries to the capabilities of the
         * ProcessPath code
         */
<span class="nc" id="L1482">        hnd.dhnd.adjustBounds(LOWER_OUT_BND, LOWER_OUT_BND,</span>
                              UPPER_OUT_BND, UPPER_OUT_BND);

        /* Adding support of the KEY_STROKE_CONTROL rendering hint.
         * Now we are supporting two modes: &quot;pixels at centers&quot; and
         * &quot;pixels at corners&quot;.
         * First one is disabled by default but could be enabled by setting
         * VALUE_STROKE_PURE to the rendering hint. It means that pixel at the
         * screen (x,y) has (x + 0.5, y + 0.5) float coordinates.
         *
         * Second one is enabled by default and means straightforward mapping
         * (x,y) --&gt; (x,y)
         */
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (hnd.dhnd.strokeControl == SunHints.INTVAL_STROKE_PURE) {</span>
<span class="nc" id="L1496">            closeCoord[0] = -0.5f;</span>
<span class="nc" id="L1497">            closeCoord[1] = -0.5f;</span>
<span class="nc" id="L1498">            transXf -= 0.5;</span>
<span class="nc" id="L1499">            transYf -= 0.5;</span>
        }

<span class="nc" id="L1502">        PathIterator pi = p2df.getPathIterator(null);</span>

<span class="nc bnc" id="L1504" title="All 2 branches missed.">        while (!pi.isDone()) {</span>
<span class="nc bnc" id="L1505" title="All 6 branches missed.">            switch (pi.currentSegment(coords)) {</span>
                case PathIterator.SEG_MOVETO:
                    /* Performing closing of the unclosed segments */
<span class="nc bnc" id="L1508" title="All 4 branches missed.">                    if (subpathStarted &amp;&amp; !skip) {</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">                        if (hnd.clipMode == PH_MODE_FILL_CLIP) {</span>
<span class="nc bnc" id="L1510" title="All 4 branches missed.">                            if (tCoords[0] != closeCoord[0] ||</span>
                                tCoords[1] != closeCoord[1])
                            {
<span class="nc" id="L1513">                                ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                            closeCoord[0], closeCoord[1],
                                            pixelInfo);
                            }
                        }
<span class="nc" id="L1518">                        hnd.processEndSubPath();</span>
                    }

<span class="nc" id="L1521">                    tCoords[0] = coords[0] + transXf;</span>
<span class="nc" id="L1522">                    tCoords[1] = coords[1] + transYf;</span>

                    /* Checking SEG_MOVETO coordinates if they are out of the
                     * [LOWER_BND, UPPER_BND] range.  This check also handles
                     * NaN and Infinity values. Skipping next path segment in
                     * case of invalid data.
                     */

<span class="nc bnc" id="L1530" title="All 8 branches missed.">                    if (tCoords[0] &lt; UPPER_BND &amp;&amp;</span>
                        tCoords[0] &gt; LOWER_BND &amp;&amp;
                        tCoords[1] &lt; UPPER_BND &amp;&amp;
                        tCoords[1] &gt; LOWER_BND)
                    {
<span class="nc" id="L1535">                        subpathStarted = true;</span>
<span class="nc" id="L1536">                        skip = false;</span>
<span class="nc" id="L1537">                        closeCoord[0] = tCoords[0];</span>
<span class="nc" id="L1538">                        closeCoord[1] = tCoords[1];</span>
                    } else {
<span class="nc" id="L1540">                        skip = true;</span>
                    }
<span class="nc" id="L1542">                    pixelInfo[0] = 0;</span>
<span class="nc" id="L1543">                    break;</span>
                case PathIterator.SEG_LINETO:
<span class="nc" id="L1545">                    lastX = tCoords[2] = coords[0] + transXf;</span>
<span class="nc" id="L1546">                    lastY = tCoords[3] = coords[1] + transYf;</span>

                    /* Checking SEG_LINETO coordinates if they are out of the
                     * [LOWER_BND, UPPER_BND] range.  This check also handles
                     * NaN and Infinity values. Ignoring current path segment
                     * in case  of invalid data. If segment is skipped its
                     * endpoint (if valid) is used to begin new subpath.
                     */

<span class="nc bnc" id="L1555" title="All 8 branches missed.">                    if (lastX &lt; UPPER_BND &amp;&amp;</span>
                        lastX &gt; LOWER_BND &amp;&amp;
                        lastY &lt; UPPER_BND &amp;&amp;
                        lastY &gt; LOWER_BND)
                    {
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                        if (skip) {</span>
<span class="nc" id="L1561">                            tCoords[0] = closeCoord[0] = lastX;</span>
<span class="nc" id="L1562">                            tCoords[1] = closeCoord[1] = lastY;</span>
<span class="nc" id="L1563">                            subpathStarted = true;</span>
<span class="nc" id="L1564">                            skip = false;</span>
                        } else {
<span class="nc" id="L1566">                            ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                        tCoords[2], tCoords[3], pixelInfo);
<span class="nc" id="L1568">                            tCoords[0] = lastX;</span>
<span class="nc" id="L1569">                            tCoords[1] = lastY;</span>
                        }
                    }
                    break;
                case PathIterator.SEG_QUADTO:
<span class="nc" id="L1574">                    tCoords[2] = coords[0] + transXf;</span>
<span class="nc" id="L1575">                    tCoords[3] = coords[1] + transYf;</span>
<span class="nc" id="L1576">                    lastX = tCoords[4] = coords[2] + transXf;</span>
<span class="nc" id="L1577">                    lastY = tCoords[5] = coords[3] + transYf;</span>

                    /* Checking SEG_QUADTO coordinates if they are out of the
                     * [LOWER_BND, UPPER_BND] range.  This check also handles
                     * NaN and Infinity values. Ignoring current path segment
                     * in case  of invalid endpoints's data.  Equivalent to
                     * the SEG_LINETO if endpoint coordinates are valid but
                     * there are invalid data among other coordinates
                     */

<span class="nc bnc" id="L1587" title="All 8 branches missed.">                    if (lastX &lt; UPPER_BND &amp;&amp;</span>
                        lastX &gt; LOWER_BND &amp;&amp;
                        lastY &lt; UPPER_BND &amp;&amp;
                        lastY &gt; LOWER_BND)
                    {
<span class="nc bnc" id="L1592" title="All 2 branches missed.">                        if (skip) {</span>
<span class="nc" id="L1593">                            tCoords[0] = closeCoord[0] = lastX;</span>
<span class="nc" id="L1594">                            tCoords[1] = closeCoord[1] = lastY;</span>
<span class="nc" id="L1595">                            subpathStarted = true;</span>
<span class="nc" id="L1596">                            skip = false;</span>
                        } else {
<span class="nc bnc" id="L1598" title="All 8 branches missed.">                            if (tCoords[2] &lt; UPPER_BND &amp;&amp;</span>
                                tCoords[2] &gt; LOWER_BND &amp;&amp;
                                tCoords[3] &lt; UPPER_BND &amp;&amp;
                                tCoords[3] &gt; LOWER_BND)
                            {
<span class="nc" id="L1603">                                ProcessQuad(hnd, tCoords, pixelInfo);</span>
                            } else {
<span class="nc" id="L1605">                                ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                            tCoords[4], tCoords[5],
                                            pixelInfo);
                            }
<span class="nc" id="L1609">                            tCoords[0] = lastX;</span>
<span class="nc" id="L1610">                            tCoords[1] = lastY;</span>
                        }
                    }
                    break;
                case PathIterator.SEG_CUBICTO:
<span class="nc" id="L1615">                    tCoords[2] = coords[0] + transXf;</span>
<span class="nc" id="L1616">                    tCoords[3] = coords[1] + transYf;</span>
<span class="nc" id="L1617">                    tCoords[4] = coords[2] + transXf;</span>
<span class="nc" id="L1618">                    tCoords[5] = coords[3] + transYf;</span>
<span class="nc" id="L1619">                    lastX = tCoords[6] = coords[4] + transXf;</span>
<span class="nc" id="L1620">                    lastY = tCoords[7] = coords[5] + transYf;</span>

                    /* Checking SEG_CUBICTO coordinates if they are out of the
                     * [LOWER_BND, UPPER_BND] range.  This check also handles
                     * NaN and Infinity values. Ignoring current path segment
                     * in case  of invalid endpoints's data.  Equivalent to
                     * the SEG_LINETO if endpoint coordinates are valid but
                     * there are invalid data among other coordinates
                     */

<span class="nc bnc" id="L1630" title="All 8 branches missed.">                    if (lastX &lt; UPPER_BND &amp;&amp;</span>
                        lastX &gt; LOWER_BND &amp;&amp;
                        lastY &lt; UPPER_BND &amp;&amp;
                        lastY &gt; LOWER_BND)
                    {
<span class="nc bnc" id="L1635" title="All 2 branches missed.">                        if (skip) {</span>
<span class="nc" id="L1636">                            tCoords[0] = closeCoord[0] = tCoords[6];</span>
<span class="nc" id="L1637">                            tCoords[1] = closeCoord[1] = tCoords[7];</span>
<span class="nc" id="L1638">                            subpathStarted = true;</span>
<span class="nc" id="L1639">                            skip = false;</span>
                        } else {
<span class="nc bnc" id="L1641" title="All 16 branches missed.">                            if (tCoords[2] &lt; UPPER_BND &amp;&amp;</span>
                                tCoords[2] &gt; LOWER_BND &amp;&amp;
                                tCoords[3] &lt; UPPER_BND &amp;&amp;
                                tCoords[3] &gt; LOWER_BND &amp;&amp;
                                tCoords[4] &lt; UPPER_BND &amp;&amp;
                                tCoords[4] &gt; LOWER_BND &amp;&amp;
                                tCoords[5] &lt; UPPER_BND &amp;&amp;
                                tCoords[5] &gt; LOWER_BND)
                            {
<span class="nc" id="L1650">                                ProcessCubic(hnd, tCoords, pixelInfo);</span>
                            } else {
<span class="nc" id="L1652">                                ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                            tCoords[6], tCoords[7],
                                            pixelInfo);
                            }
<span class="nc" id="L1656">                            tCoords[0] = lastX;</span>
<span class="nc" id="L1657">                            tCoords[1] = lastY;</span>
                        }
                    }
                    break;
                case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L1662" title="All 4 branches missed.">                    if (subpathStarted &amp;&amp; !skip) {</span>
<span class="nc" id="L1663">                        skip = false;</span>
<span class="nc bnc" id="L1664" title="All 4 branches missed.">                        if (tCoords[0] != closeCoord[0] ||</span>
                            tCoords[1] != closeCoord[1])
                        {
<span class="nc" id="L1667">                            ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                        closeCoord[0], closeCoord[1],
                                        pixelInfo);

                            /* Storing last path's point for using in following
                             * segments without initial moveTo
                             */
<span class="nc" id="L1674">                            tCoords[0] = closeCoord[0];</span>
<span class="nc" id="L1675">                            tCoords[1] = closeCoord[1];</span>
                        }
<span class="nc" id="L1677">                        hnd.processEndSubPath();</span>
                    }
                    break;
            }
<span class="nc" id="L1681">            pi.next();</span>
        }

        /* Performing closing of the unclosed segments */
<span class="nc bnc" id="L1685" title="All 4 branches missed.">        if (subpathStarted &amp; !skip) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">            if (hnd.clipMode == PH_MODE_FILL_CLIP) {</span>
<span class="nc bnc" id="L1687" title="All 4 branches missed.">                if (tCoords[0] != closeCoord[0] ||</span>
                    tCoords[1] != closeCoord[1])
                {
<span class="nc" id="L1690">                    ProcessLine(hnd, tCoords[0], tCoords[1],</span>
                                closeCoord[0], closeCoord[1],
                                pixelInfo);
                }
            }
<span class="nc" id="L1695">            hnd.processEndSubPath();</span>
        }
<span class="nc" id="L1697">        return true;</span>
    }

    private static class Point {
        public int x;
        public int y;
        public boolean lastPoint;
        public Point prev;
        public Point next;
        public Point nextByY;
        public Edge edge;
<span class="nc" id="L1708">        public Point(int x, int y, boolean lastPoint) {</span>
<span class="nc" id="L1709">            this.x = x;</span>
<span class="nc" id="L1710">            this.y = y;</span>
<span class="nc" id="L1711">            this.lastPoint = lastPoint;</span>
<span class="nc" id="L1712">        }</span>
    };

    private static class Edge {
        int x;
        int dx;
        Point p;
        int  dir;
        Edge prev;
        Edge next;

<span class="nc" id="L1723">        public Edge(Point p, int x, int dx, int dir) {</span>
<span class="nc" id="L1724">            this.p = p;</span>
<span class="nc" id="L1725">            this.x = x;</span>
<span class="nc" id="L1726">            this.dx = dx;</span>
<span class="nc" id="L1727">            this.dir = dir;</span>
<span class="nc" id="L1728">        }</span>
    };

    /* Size of the default buffer in the FillData structure. This buffer is
     * replaced with heap allocated in case of large paths.
     */
    private static final int DF_MAX_POINT = 256;

    /* Following class accumulates points of the non-continuous flattened
     * general path during iteration through the origin path's segments . The
     * end of the each subpath is marked as lastPoint flag set at the last
     * point
     */
    private static class FillData {
        List&lt;Point&gt;  plgPnts;
        public int  plgYMin;
        public int  plgYMax;

<span class="nc" id="L1746">        public FillData() {</span>
<span class="nc" id="L1747">            plgPnts = new Vector&lt;Point&gt;(DF_MAX_POINT);</span>
<span class="nc" id="L1748">        }</span>

        public void addPoint(int x, int y, boolean lastPoint) {
<span class="nc bnc" id="L1751" title="All 2 branches missed.">            if (plgPnts.size() == 0) {</span>
<span class="nc" id="L1752">                plgYMin = plgYMax = y;</span>
            } else {
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                plgYMin = (plgYMin &gt; y)?y:plgYMin;</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">                plgYMax = (plgYMax &lt; y)?y:plgYMax;</span>
            }

<span class="nc" id="L1758">            plgPnts.add(new Point(x, y, lastPoint));</span>
<span class="nc" id="L1759">        }</span>

        public boolean isEmpty() {
<span class="nc bnc" id="L1762" title="All 2 branches missed.">            return plgPnts.size() == 0;</span>
        }

        public boolean isEnded() {
<span class="nc" id="L1766">            return plgPnts.get(plgPnts.size() - 1).lastPoint;</span>
        }

        public boolean setEnded() {
<span class="nc" id="L1770">            return plgPnts.get(plgPnts.size() - 1).lastPoint = true;</span>
        }
    }

<span class="nc" id="L1774">    private static class ActiveEdgeList {</span>
        Edge head;

        public boolean isEmpty() {
<span class="nc bnc" id="L1778" title="All 2 branches missed.">            return (head == null);</span>
        }

        public void insert(Point pnt, int cy) {
<span class="nc" id="L1782">            Point np = pnt.next;</span>
<span class="nc" id="L1783">            int X1 = pnt.x, Y1 = pnt.y;</span>
<span class="nc" id="L1784">            int X2 = np.x, Y2 = np.y;</span>
            Edge ne;
<span class="nc bnc" id="L1786" title="All 2 branches missed.">            if (Y1 == Y2) {</span>
                /* Skipping horizontal segments */
<span class="nc" id="L1788">                return;</span>
            } else {
<span class="nc" id="L1790">                int dX = X2 - X1;</span>
<span class="nc" id="L1791">                int dY = Y2 - Y1;</span>
                int stepx, x0, dy, dir;

<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if (Y1 &lt; Y2) {</span>
<span class="nc" id="L1795">                    x0 = X1;</span>
<span class="nc" id="L1796">                    dy = cy - Y1;</span>
<span class="nc" id="L1797">                    dir = -1;</span>
                } else { // (Y1 &gt; Y2)
<span class="nc" id="L1799">                    x0 = X2;</span>
<span class="nc" id="L1800">                    dy = cy - Y2;</span>
<span class="nc" id="L1801">                    dir = 1;</span>
                }

                /* We need to worry only about dX because dY is in denominator
                 * and abs(dy) &lt; MDP_MULT (cy is a first scanline of the scan
                 * converted segment and we subtract y coordinate of the
                 * nearest segment's end from it to obtain dy)
                 */
<span class="nc bnc" id="L1809" title="All 4 branches missed.">                if (dX &gt; CALC_UBND || dX &lt; CALC_LBND)  {</span>
<span class="nc" id="L1810">                    stepx = (int)((((double)dX)*MDP_MULT)/dY);</span>
<span class="nc" id="L1811">                    x0 = x0 + (int)((((double)dX)*dy)/dY);</span>
                } else {
<span class="nc" id="L1813">                    stepx = (dX&lt;&lt;MDP_PREC)/dY;</span>
<span class="nc" id="L1814">                    x0 += (dX*dy)/dY;</span>
                }

<span class="nc" id="L1817">                ne = new Edge(pnt, x0, stepx, dir);</span>
            }

<span class="nc" id="L1820">            ne.next = head;</span>
<span class="nc" id="L1821">            ne.prev = null;</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            if (head != null) {</span>
<span class="nc" id="L1823">                head.prev = ne;</span>
            }
<span class="nc" id="L1825">            head = pnt.edge = ne;</span>
<span class="nc" id="L1826">        }</span>

        public void delete(Edge e) {
<span class="nc" id="L1829">            Edge prevp = e.prev;</span>
<span class="nc" id="L1830">            Edge nextp = e.next;</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">            if (prevp != null) {</span>
<span class="nc" id="L1832">                prevp.next = nextp;</span>
            } else {
<span class="nc" id="L1834">                head = nextp;</span>
            }
<span class="nc bnc" id="L1836" title="All 2 branches missed.">            if (nextp != null) {</span>
<span class="nc" id="L1837">                nextp.prev = prevp;</span>
            }
<span class="nc" id="L1839">        }</span>

        /**
         * Bubble sorting in the ascending order of the linked list.  This
         * implementation stops processing the list if there were no changes
         * during the previous pass.
         *
         * We could not use O(N) Radix sort here because in most cases list of
         * edges almost sorted.  So, bubble sort (O(N^2)) is working much
         * better.  Note, in case of array of edges Shell sort is more
         * efficient.
         */
        public void sort() {
<span class="nc" id="L1852">            Edge p, q, r, s = null, temp;</span>
<span class="nc" id="L1853">            boolean wasSwap = true;</span>

            // r precedes p and s points to the node up to which
            // comparisons are to be made
<span class="nc bnc" id="L1857" title="All 4 branches missed.">            while (s != head.next &amp;&amp; wasSwap) {</span>
<span class="nc" id="L1858">                r = p = head;</span>
<span class="nc" id="L1859">                q = p.next;</span>
<span class="nc" id="L1860">                wasSwap = false;</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">                while (p != s) {</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">                    if (p.x &gt;= q.x) {</span>
<span class="nc" id="L1863">                        wasSwap = true;</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">                        if (p == head) {</span>
<span class="nc" id="L1865">                            temp = q.next;</span>
<span class="nc" id="L1866">                            q.next = p;</span>
<span class="nc" id="L1867">                            p.next = temp;</span>
<span class="nc" id="L1868">                            head = q;</span>
<span class="nc" id="L1869">                            r = q;</span>
                        } else {
<span class="nc" id="L1871">                            temp = q.next;</span>
<span class="nc" id="L1872">                            q.next = p;</span>
<span class="nc" id="L1873">                            p.next = temp;</span>
<span class="nc" id="L1874">                            r.next = q;</span>
<span class="nc" id="L1875">                            r = q;</span>
                        }
                    } else {
<span class="nc" id="L1878">                        r = p;</span>
<span class="nc" id="L1879">                        p = p.next;</span>
                    }
<span class="nc" id="L1881">                    q = p.next;</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">                    if (q == s) s = p;</span>
                }
            }

            // correction of the back links in the double linked edge list
<span class="nc" id="L1887">            p = head;</span>
<span class="nc" id="L1888">            q = null;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">            while (p != null) {</span>
<span class="nc" id="L1890">                p.prev = q;</span>
<span class="nc" id="L1891">                q = p;</span>
<span class="nc" id="L1892">                p = p.next;</span>
            }
<span class="nc" id="L1894">        }</span>
    }

    private static void FillPolygon(FillProcessHandler hnd,
                                    int fillRule) {
        int k, y, n;
        boolean drawing;
        Edge active;
<span class="nc" id="L1902">        int rightBnd = hnd.dhnd.xMax - 1;</span>
<span class="nc" id="L1903">        FillData fd = hnd.fd;</span>
<span class="nc" id="L1904">        int yMin = fd.plgYMin;</span>
<span class="nc" id="L1905">        int yMax = fd.plgYMax;</span>
<span class="nc" id="L1906">        int hashSize = ((yMax - yMin)&gt;&gt;MDP_PREC) + 4;</span>

        /* Because of support of the KEY_STROKE_CONTROL hint we are performing
         * shift of the coordinates at the higher level
         */
<span class="nc" id="L1911">        int hashOffset = ((yMin - 1) &amp; MDP_W_MASK);</span>

        /* Winding counter */
        int counter;

        /* Calculating mask to be applied to the winding counter */
<span class="nc bnc" id="L1917" title="All 2 branches missed.">        int counterMask =</span>
            (fillRule == PathIterator.WIND_NON_ZERO)? -1:1;

        int pntOffset;
<span class="nc" id="L1921">        List&lt;Point&gt; pnts = fd.plgPnts;</span>
<span class="nc" id="L1922">        n = pnts.size();</span>

<span class="nc bnc" id="L1924" title="All 2 branches missed.">        if (n &lt;=1) return;</span>

<span class="nc" id="L1926">        Point[] yHash = new Point[hashSize];</span>

        /* Creating double linked list (prev, next links) describing path order
         * and hash table with points which fall between scanlines. nextByY
         * link is used for the points which are between same scanlines.
         * Scanlines are passed through the centers of the pixels.
         */
<span class="nc" id="L1933">        Point curpt = pnts.get(0);</span>
<span class="nc" id="L1934">        curpt.prev = null;</span>
<span class="nc bnc" id="L1935" title="All 2 branches missed.">        for (int i = 0; i &lt; n - 1; i++) {</span>
<span class="nc" id="L1936">            curpt = pnts.get(i);</span>
<span class="nc" id="L1937">            Point nextpt = pnts.get(i + 1);</span>
<span class="nc" id="L1938">            int curHashInd = (curpt.y - hashOffset - 1) &gt;&gt; MDP_PREC;</span>
<span class="nc" id="L1939">            curpt.nextByY = yHash[curHashInd];</span>
<span class="nc" id="L1940">            yHash[curHashInd] = curpt;</span>
<span class="nc" id="L1941">            curpt.next = nextpt;</span>
<span class="nc" id="L1942">            nextpt.prev = curpt;</span>
        }

<span class="nc" id="L1945">        Point ept = pnts.get(n - 1);</span>
<span class="nc" id="L1946">        int curHashInd = (ept.y - hashOffset - 1) &gt;&gt; MDP_PREC;</span>
<span class="nc" id="L1947">        ept.nextByY = yHash[curHashInd];</span>
<span class="nc" id="L1948">        yHash[curHashInd] = ept;</span>

<span class="nc" id="L1950">        ActiveEdgeList activeList = new ActiveEdgeList();</span>

<span class="nc" id="L1952">        for (y=hashOffset + MDP_MULT,k = 0;</span>
<span class="nc bnc" id="L1953" title="All 4 branches missed.">             y&lt;=yMax &amp;&amp; k &lt; hashSize; y += MDP_MULT, k++)</span>
        {
<span class="nc bnc" id="L1955" title="All 2 branches missed.">            for(Point pt = yHash[k];pt != null; pt=pt.nextByY) {</span>
                /* pt.y should be inside hashed interval
                 * assert(y-MDP_MULT &lt;= pt.y &amp;&amp; pt.y &lt; y);
                 */
<span class="nc bnc" id="L1959" title="All 4 branches missed.">                if (pt.prev != null &amp;&amp; !pt.prev.lastPoint) {</span>
<span class="nc bnc" id="L1960" title="All 4 branches missed.">                    if (pt.prev.edge != null &amp;&amp; pt.prev.y &lt;= y) {</span>
<span class="nc" id="L1961">                        activeList.delete(pt.prev.edge);</span>
<span class="nc" id="L1962">                        pt.prev.edge = null;</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                    } else  if (pt.prev.y &gt; y) {</span>
<span class="nc" id="L1964">                        activeList.insert(pt.prev, y);</span>
                    }
                }

<span class="nc bnc" id="L1968" title="All 4 branches missed.">                if (!pt.lastPoint &amp;&amp; pt.next != null) {</span>
<span class="nc bnc" id="L1969" title="All 4 branches missed.">                    if (pt.edge != null &amp;&amp; pt.next.y &lt;= y) {</span>
<span class="nc" id="L1970">                        activeList.delete(pt.edge);</span>
<span class="nc" id="L1971">                        pt.edge = null;</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                    } else if (pt.next.y &gt; y) {</span>
<span class="nc" id="L1973">                        activeList.insert(pt, y);</span>
                    }
                }
            }

<span class="nc bnc" id="L1978" title="All 2 branches missed.">            if (activeList.isEmpty()) continue;</span>

<span class="nc" id="L1980">            activeList.sort();</span>

<span class="nc" id="L1982">            counter = 0;</span>
<span class="nc" id="L1983">            drawing = false;</span>
            int xl, xr;
<span class="nc" id="L1985">            xl = xr = hnd.dhnd.xMin;</span>
<span class="nc" id="L1986">            Edge curEdge = activeList.head;</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            while (curEdge != null) {</span>
<span class="nc" id="L1988">                counter += curEdge.dir;</span>
<span class="nc bnc" id="L1989" title="All 4 branches missed.">                if ((counter &amp; counterMask) != 0 &amp;&amp; !drawing) {</span>
<span class="nc" id="L1990">                    xl = (curEdge.x + MDP_MULT - 1)&gt;&gt;MDP_PREC;</span>
<span class="nc" id="L1991">                    drawing = true;</span>
                }

<span class="nc bnc" id="L1994" title="All 4 branches missed.">                if ((counter &amp; counterMask) == 0 &amp;&amp; drawing) {</span>
<span class="nc" id="L1995">                    xr = (curEdge.x - 1) &gt;&gt; MDP_PREC;</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                    if (xl &lt;= xr) {</span>
<span class="nc" id="L1997">                        hnd.dhnd.drawScanline(xl, xr, y &gt;&gt; MDP_PREC);</span>
                    }
<span class="nc" id="L1999">                    drawing = false;</span>
                }

<span class="nc" id="L2002">                curEdge.x += curEdge.dx;</span>
<span class="nc" id="L2003">                curEdge = curEdge.next;</span>
            }

            /* Performing drawing till the right boundary (for correct
             * rendering shapes clipped at the right side)
             */
<span class="nc bnc" id="L2009" title="All 4 branches missed.">            if (drawing &amp;&amp; xl &lt;= rightBnd) {</span>

                /* Support of the strokeHint was added into the
                 * draw and fill methods of the sun.java2d.pipe.LoopPipe
                 */
<span class="nc" id="L2014">                hnd.dhnd.drawScanline(xl, rightBnd, y  &gt;&gt; MDP_PREC);</span>
            }
        }
<span class="nc" id="L2017">    }</span>

<span class="nc" id="L2019">    private static class FillProcessHandler extends ProcessHandler {</span>

        FillData fd;

        /* Note: For more easy reading of the code below each java version of
         * the macros from the ProcessPath.c preceded by the commented
         * origin call containing verbose names of the parameters
         */
        public void  processFixedLine(int x1, int y1, int x2, int y2,
                                      int[] pixelInfo, boolean checkBounds,
                                      boolean endSubPath)
        {
            int outXMin, outXMax, outYMin, outYMax;
            int res;

            /* There is no need to round line coordinates to the forward
             * differencing precision anymore. Such a rounding was used for
             * preventing the curve go out the endpoint (this sometimes does
             * not help). The problem was fixed in the forward differencing
             * loops.
             */
<span class="nc bnc" id="L2040" title="All 2 branches missed.">            if (checkBounds) {</span>
                boolean lastClipped;

                /* This function is used only for filling shapes, so there is no
                 * check for the type of clipping
                 */
<span class="nc" id="L2046">                int c[] = new int[]{x1, y1, x2, y2, 0, 0};</span>
<span class="nc" id="L2047">                outXMin = (int)(dhnd.xMinf * MDP_MULT);</span>
<span class="nc" id="L2048">                outXMax = (int)(dhnd.xMaxf * MDP_MULT);</span>
<span class="nc" id="L2049">                outYMin = (int)(dhnd.yMinf * MDP_MULT);</span>
<span class="nc" id="L2050">                outYMax = (int)(dhnd.yMaxf * MDP_MULT);</span>

                /*
                 * TESTANDCLIP(outYMin, outYMax, y1, x1, y2, x2, res);
                 */
<span class="nc" id="L2055">                res = TESTANDCLIP(outYMin, outYMax, c, 1, 0, 3, 2);</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">                if (res == CRES_INVISIBLE) return;</span>

                /*
                 * TESTANDCLIP(outYMin, outYMax, y2, x2, y1, x1, res);
                 */
<span class="nc" id="L2061">                res = TESTANDCLIP(outYMin, outYMax, c, 3, 2, 1, 0);</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                if (res == CRES_INVISIBLE) return;</span>
<span class="nc" id="L2063">                lastClipped = IS_CLIPPED(res);</span>

                /* Clamping starting from first vertex of the the processed
                 * segment
                 *
                 * CLIPCLAMP(outXMin, outXMax, x1, y1, x2, y2, x3, y3, res);
                 */
<span class="nc" id="L2070">                res = CLIPCLAMP(outXMin, outXMax, c, 0, 1, 2, 3, 4, 5);</span>

                /* Clamping only by left boundary */
<span class="nc bnc" id="L2073" title="All 2 branches missed.">                if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L2074">                    processFixedLine(c[4], c[5], c[0], c[1], pixelInfo,</span>
                                     false, lastClipped);

<span class="nc bnc" id="L2077" title="All 2 branches missed.">                } else if (res == CRES_INVISIBLE) {</span>
<span class="nc" id="L2078">                    return;</span>
                }

                /* Clamping starting from last vertex of the the processed
                 * segment
                 *
                 * CLIPCLAMP(outXMin, outXMax, x2, y2, x1, y1, x3, y3, res);
                 */
<span class="nc" id="L2086">                res = CLIPCLAMP(outXMin, outXMax, c, 2, 3, 0, 1, 4, 5);</span>

                /* Checking if there was a clip by right boundary */
<span class="nc bnc" id="L2089" title="All 4 branches missed.">                lastClipped = lastClipped || (res == CRES_MAX_CLIPPED);</span>

<span class="nc" id="L2091">                processFixedLine(c[0], c[1], c[2], c[3], pixelInfo,</span>
                                 false, lastClipped);

                /* Clamping only by left boundary */
<span class="nc bnc" id="L2095" title="All 2 branches missed.">                if (res == CRES_MIN_CLIPPED) {</span>
<span class="nc" id="L2096">                    processFixedLine(c[2], c[3], c[4], c[5], pixelInfo,</span>
                                     false, lastClipped);
                }

<span class="nc" id="L2100">                return;</span>
            }

            /* Adding first point of the line only in case of empty or just
             * finished path
             */
<span class="nc bnc" id="L2106" title="All 4 branches missed.">            if (fd.isEmpty() || fd.isEnded()) {</span>
<span class="nc" id="L2107">                fd.addPoint(x1, y1, false);</span>
            }

<span class="nc" id="L2110">            fd.addPoint(x2, y2, false);</span>

<span class="nc bnc" id="L2112" title="All 2 branches missed.">            if (endSubPath) {</span>
<span class="nc" id="L2113">                fd.setEnded();</span>
            }
<span class="nc" id="L2115">        }</span>

        FillProcessHandler(DrawHandler dhnd) {
<span class="nc" id="L2118">            super(dhnd, PH_MODE_FILL_CLIP);</span>
<span class="nc" id="L2119">            this.fd = new FillData();</span>
<span class="nc" id="L2120">        }</span>

        public void processEndSubPath() {
<span class="nc bnc" id="L2123" title="All 2 branches missed.">            if (!fd.isEmpty()) {</span>
<span class="nc" id="L2124">                fd.setEnded();</span>
            }
<span class="nc" id="L2126">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>