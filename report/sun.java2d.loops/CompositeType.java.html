<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CompositeType.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.loops</a> &gt; <span class="el_source">CompositeType.java</span></div><h1>CompositeType.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.loops;

import java.awt.image.BufferedImage;
import java.awt.AlphaComposite;
import java.util.HashMap;

/**
 * A CompositeType object provides a chained description of a type of
 * algorithm for color compositing.  The object will provide a single
 * String constant descriptor which is one way of describing a particular
 * compositing algorithm as well as a pointer to another CompositeType
 * which describes a more general algorithm for achieving the same result.
 * &lt;p&gt;
 * A description of a more specific algorithm is considered a &quot;subtype&quot;
 * and a description of a more general algorithm is considered a &quot;supertype&quot;.
 * Thus, the deriveSubType method provides a way to create a new CompositeType
 * that is related to but more specific than an existing CompositeType and
 * the getSuperType method provides a way to ask a given CompositeType
 * for a more general algorithm to achieve the same result.
 * &lt;p&gt;
 * Note that you cannot construct a brand new root for a chain since
 * the constructor is private.  Every chain of types must at some point
 * derive from the Any node provided here using the deriveSubType()
 * method.  The presence of this common Any node on every chain
 * ensures that all chains end with the DESC_ANY descriptor so that
 * a suitable General GraphicsPrimitive object can be obtained for
 * the indicated algorithm if all of the more specific searches fail.
 */
public final class CompositeType {

<span class="nc" id="L56">    private static int unusedUID = 1;</span>
<span class="nc" id="L57">    private static final HashMap&lt;String,Integer&gt; compositeUIDMap =</span>
        new HashMap&lt;String,Integer&gt;(100);

    /*
     * CONSTANTS USED BY ALL PRIMITIVES TO DESCRIBE THE COMPOSITING
     * ALGORITHMS THEY CAN PERFORM
     */

    /**
     * algorithm is a general algorithm that uses a CompositeContext
     * to do the rendering.
     */
    public static final String DESC_ANY      = &quot;Any CompositeContext&quot;;

    /**
     * constant used to describe the Graphics.setXORMode() algorithm
     */
    public static final String DESC_XOR      = &quot;XOR mode&quot;;

    /**
     * constants used to describe the various AlphaComposite
     * algorithms.
     */
    public static final String DESC_CLEAR     = &quot;Porter-Duff Clear&quot;;
    public static final String DESC_SRC       = &quot;Porter-Duff Src&quot;;
    public static final String DESC_DST       = &quot;Porter-Duff Dst&quot;;
    public static final String DESC_SRC_OVER  = &quot;Porter-Duff Src Over Dst&quot;;
    public static final String DESC_DST_OVER  = &quot;Porter-Duff Dst Over Src&quot;;
    public static final String DESC_SRC_IN    = &quot;Porter-Duff Src In Dst&quot;;
    public static final String DESC_DST_IN    = &quot;Porter-Duff Dst In Src&quot;;
    public static final String DESC_SRC_OUT   = &quot;Porter-Duff Src HeldOutBy Dst&quot;;
    public static final String DESC_DST_OUT   = &quot;Porter-Duff Dst HeldOutBy Src&quot;;
    public static final String DESC_SRC_ATOP  = &quot;Porter-Duff Src Atop Dst&quot;;
    public static final String DESC_DST_ATOP  = &quot;Porter-Duff Dst Atop Src&quot;;
    public static final String DESC_ALPHA_XOR = &quot;Porter-Duff Xor&quot;;

    /**
     * constants used to describe the two common cases of
     * AlphaComposite algorithms that are simpler if there
     * is not extraAlpha.
     */
    public static final String
        DESC_SRC_NO_EA      = &quot;Porter-Duff Src, No Extra Alpha&quot;;
    public static final String
        DESC_SRC_OVER_NO_EA = &quot;Porter-Duff SrcOverDst, No Extra Alpha&quot;;

    /**
     * constant used to describe an algorithm that implements all 8 of
     * the Porter-Duff rules in one Primitive.
     */
    public static final String DESC_ANY_ALPHA = &quot;Any AlphaComposite Rule&quot;;

    /*
     * END OF COMPOSITE ALGORITHM TYPE CONSTANTS
     */

    /**
     * The root CompositeType object for all chains of algorithm descriptions.
     */
    public static final CompositeType
<span class="nc" id="L117">        Any           = new CompositeType(null, DESC_ANY);</span>

    /*
     * START OF CompositeeType OBJECTS FOR THE VARIOUS CONSTANTS
     */

    public static final CompositeType
<span class="nc" id="L124">        General       = Any;</span>

    public static final CompositeType
<span class="nc" id="L127">        AnyAlpha      = General.deriveSubType(DESC_ANY_ALPHA);</span>
    public static final CompositeType
<span class="nc" id="L129">        Xor           = General.deriveSubType(DESC_XOR);</span>

    public static final CompositeType
<span class="nc" id="L132">        Clear         = AnyAlpha.deriveSubType(DESC_CLEAR);</span>
    public static final CompositeType
<span class="nc" id="L134">        Src           = AnyAlpha.deriveSubType(DESC_SRC);</span>
    public static final CompositeType
<span class="nc" id="L136">        Dst           = AnyAlpha.deriveSubType(DESC_DST);</span>
    public static final CompositeType
<span class="nc" id="L138">        SrcOver       = AnyAlpha.deriveSubType(DESC_SRC_OVER);</span>
    public static final CompositeType
<span class="nc" id="L140">        DstOver       = AnyAlpha.deriveSubType(DESC_DST_OVER);</span>
    public static final CompositeType
<span class="nc" id="L142">        SrcIn         = AnyAlpha.deriveSubType(DESC_SRC_IN);</span>
    public static final CompositeType
<span class="nc" id="L144">        DstIn         = AnyAlpha.deriveSubType(DESC_DST_IN);</span>
    public static final CompositeType
<span class="nc" id="L146">        SrcOut        = AnyAlpha.deriveSubType(DESC_SRC_OUT);</span>
    public static final CompositeType
<span class="nc" id="L148">        DstOut        = AnyAlpha.deriveSubType(DESC_DST_OUT);</span>
    public static final CompositeType
<span class="nc" id="L150">        SrcAtop       = AnyAlpha.deriveSubType(DESC_SRC_ATOP);</span>
    public static final CompositeType
<span class="nc" id="L152">        DstAtop       = AnyAlpha.deriveSubType(DESC_DST_ATOP);</span>
    public static final CompositeType
<span class="nc" id="L154">        AlphaXor      = AnyAlpha.deriveSubType(DESC_ALPHA_XOR);</span>

    public static final CompositeType
<span class="nc" id="L157">        SrcNoEa       = Src.deriveSubType(DESC_SRC_NO_EA);</span>
    public static final CompositeType
<span class="nc" id="L159">        SrcOverNoEa   = SrcOver.deriveSubType(DESC_SRC_OVER_NO_EA);</span>

    /*
     * A special CompositeType for the case where we are filling in
     * SrcOverNoEa mode with an opaque color.  In that case then the
     * best loop for us to use would be a SrcNoEa loop, but what if
     * there is no such loop?  In that case then we would end up
     * backing off to a Src loop (which should still be fine) or an
     * AnyAlpha loop which would be slower than a SrcOver loop in
     * most cases.
     * The fix is to use the following chain which looks for loops
     * in the following order:
     *    SrcNoEa, Src, SrcOverNoEa, SrcOver, AnyAlpha
     */
    public static final CompositeType
<span class="nc" id="L174">        OpaqueSrcOverNoEa = SrcOverNoEa.deriveSubType(DESC_SRC)</span>
<span class="nc" id="L175">                                       .deriveSubType(DESC_SRC_NO_EA);</span>

    /*
     * END OF CompositeType OBJECTS FOR THE VARIOUS CONSTANTS
     */

    /**
     * Return a new CompositeType object which uses this object as its
     * more general &quot;supertype&quot; descriptor.  If no operation can be
     * found that implements the algorithm described more exactly
     * by desc, then this object will define the more general
     * compositing algorithm that can be used instead.
     */
    public CompositeType deriveSubType(String desc) {
<span class="nc" id="L189">        return new CompositeType(this, desc);</span>
    }

    /**
     * Return a CompositeType object for the specified AlphaComposite
     * rule.
     */
    public static CompositeType forAlphaComposite(AlphaComposite ac) {
<span class="nc bnc" id="L197" title="All 13 branches missed.">        switch (ac.getRule()) {</span>
        case AlphaComposite.CLEAR:
<span class="nc" id="L199">            return Clear;</span>
        case AlphaComposite.SRC:
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (ac.getAlpha() &gt;= 1.0f) {</span>
<span class="nc" id="L202">                return SrcNoEa;</span>
            } else {
<span class="nc" id="L204">                return Src;</span>
            }
        case AlphaComposite.DST:
<span class="nc" id="L207">            return Dst;</span>
        case AlphaComposite.SRC_OVER:
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (ac.getAlpha() &gt;= 1.0f) {</span>
<span class="nc" id="L210">                return SrcOverNoEa;</span>
            } else {
<span class="nc" id="L212">                return SrcOver;</span>
            }
        case AlphaComposite.DST_OVER:
<span class="nc" id="L215">            return DstOver;</span>
        case AlphaComposite.SRC_IN:
<span class="nc" id="L217">            return SrcIn;</span>
        case AlphaComposite.DST_IN:
<span class="nc" id="L219">            return DstIn;</span>
        case AlphaComposite.SRC_OUT:
<span class="nc" id="L221">            return SrcOut;</span>
        case AlphaComposite.DST_OUT:
<span class="nc" id="L223">            return DstOut;</span>
        case AlphaComposite.SRC_ATOP:
<span class="nc" id="L225">            return SrcAtop;</span>
        case AlphaComposite.DST_ATOP:
<span class="nc" id="L227">            return DstAtop;</span>
        case AlphaComposite.XOR:
<span class="nc" id="L229">            return AlphaXor;</span>
        default:
<span class="nc" id="L231">            throw new InternalError(&quot;Unrecognized alpha rule&quot;);</span>
        }
    }

    private int uniqueID;
    private String desc;
    private CompositeType next;

<span class="nc" id="L239">    private CompositeType(CompositeType parent, String desc) {</span>
<span class="nc" id="L240">        next = parent;</span>
<span class="nc" id="L241">        this.desc = desc;</span>
<span class="nc" id="L242">        this.uniqueID = makeUniqueID(desc);</span>
<span class="nc" id="L243">    }</span>

    public synchronized static final int makeUniqueID(String desc) {
<span class="nc" id="L246">        Integer i = compositeUIDMap.get(desc);</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (i == null) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (unusedUID &gt; 255) {</span>
<span class="nc" id="L250">                throw new InternalError(&quot;composite type id overflow&quot;);</span>
            }
<span class="nc" id="L252">            i = unusedUID++;</span>
<span class="nc" id="L253">            compositeUIDMap.put(desc, i);</span>
        }
<span class="nc" id="L255">        return i;</span>
    }

    public int getUniqueID() {
<span class="nc" id="L259">        return uniqueID;</span>
    }

    public String getDescriptor() {
<span class="nc" id="L263">        return desc;</span>
    }

    public CompositeType getSuperType() {
<span class="nc" id="L267">        return next;</span>
    }

    public int hashCode() {
<span class="nc" id="L271">        return desc.hashCode();</span>
    }

    public boolean isDerivedFrom(CompositeType other) {
<span class="nc" id="L275">        CompositeType comptype = this;</span>
        do {
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (comptype.desc == other.desc) {</span>
<span class="nc" id="L278">                return true;</span>
            }
<span class="nc" id="L280">            comptype = comptype.next;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        } while (comptype != null);</span>
<span class="nc" id="L282">        return false;</span>
    }

    public boolean equals(Object o) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (o instanceof CompositeType) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            return (((CompositeType) o).uniqueID == this.uniqueID);</span>
        }
<span class="nc" id="L289">        return false;</span>
    }

    public String toString() {
<span class="nc" id="L293">        return desc;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>