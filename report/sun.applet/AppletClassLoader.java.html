<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AppletClassLoader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.applet</a> &gt; <span class="el_source">AppletClassLoader.java</span></div><h1>AppletClassLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.applet;

import java.lang.NullPointerException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.SocketPermission;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.io.File;
import java.io.FilePermission;
import java.io.IOException;
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.NoSuchElementException;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.security.CodeSource;
import java.security.Permission;
import java.security.PermissionCollection;
import sun.awt.AppContext;
import sun.awt.SunToolkit;
import sun.misc.IOUtils;
import sun.net.www.ParseUtil;
import sun.security.util.SecurityConstants;

/**
 * This class defines the class loader for loading applet classes and
 * resources. It extends URLClassLoader to search the applet code base
 * for the class or resource after checking any loaded JAR files.
 */
public class AppletClassLoader extends URLClassLoader {
    private URL base;   /* applet code base URL */
    private CodeSource codesource; /* codesource for the base URL */
    private AccessControlContext acc;
<span class="fc" id="L67">    private boolean exceptionStatus = false;</span>

<span class="fc" id="L69">    private final Object threadGroupSynchronizer = new Object();</span>
<span class="fc" id="L70">    private final Object grabReleaseSynchronizer = new Object();</span>

<span class="fc" id="L72">    private boolean codebaseLookup = true;</span>
<span class="fc" id="L73">    private volatile boolean allowRecursiveDirectoryRead = true;</span>

    /*
     * Creates a new AppletClassLoader for the specified base URL.
     */
    protected AppletClassLoader(URL base) {
<span class="fc" id="L79">        super(new URL[0]);</span>
<span class="fc" id="L80">        this.base = base;</span>
<span class="fc" id="L81">        this.codesource =</span>
            new CodeSource(base, (java.security.cert.Certificate[]) null);
<span class="fc" id="L83">        acc = AccessController.getContext();</span>
<span class="fc" id="L84">    }</span>

    public void disableRecursiveDirectoryRead() {
<span class="nc" id="L87">        allowRecursiveDirectoryRead = false;</span>
<span class="nc" id="L88">    }</span>


    /**
     * Set the codebase lookup flag.
     */
    void setCodebaseLookup(boolean codebaseLookup)  {
<span class="nc" id="L95">        this.codebaseLookup = codebaseLookup;</span>
<span class="nc" id="L96">    }</span>

    /*
     * Returns the applet code base URL.
     */
    URL getBaseURL() {
<span class="nc" id="L102">        return base;</span>
    }

    /*
     * Returns the URLs used for loading classes and resources.
     */
    public URL[] getURLs() {
<span class="nc" id="L109">        URL[] jars = super.getURLs();</span>
<span class="nc" id="L110">        URL[] urls = new URL[jars.length + 1];</span>
<span class="nc" id="L111">        System.arraycopy(jars, 0, urls, 0, jars.length);</span>
<span class="nc" id="L112">        urls[urls.length - 1] = base;</span>
<span class="nc" id="L113">        return urls;</span>
    }

    /*
     * Adds the specified JAR file to the search path of loaded JAR files.
     * Changed modifier to protected in order to be able to overwrite addJar()
     * in PluginClassLoader.java
     */
    protected void addJar(String name) throws IOException {
        URL url;
        try {
<span class="nc" id="L124">            url = new URL(base, name);</span>
<span class="nc" id="L125">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;name&quot;);</span>
<span class="nc" id="L127">        }</span>
<span class="nc" id="L128">        addURL(url);</span>
        // DEBUG
        //URL[] urls = getURLs();
        //for (int i = 0; i &lt; urls.length; i++) {
        //    System.out.println(&quot;url[&quot; + i + &quot;] = &quot; + urls[i]);
        //}
<span class="nc" id="L134">    }</span>

    /*
     * Override loadClass so that class loading errors can be caught in
     * order to print better error messages.
     */
    public synchronized Class loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        // First check if we have permission to access the package. This
        // should go away once we've added support for exported packages.
<span class="fc" id="L145">        int i = name.lastIndexOf('.');</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        if (i != -1) {</span>
<span class="fc" id="L147">            SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">            if (sm != null)</span>
<span class="fc" id="L149">                sm.checkPackageAccess(name.substring(0, i));</span>
        }
        try {
<span class="fc" id="L152">            return super.loadClass(name, resolve);</span>
<span class="nc" id="L153">        } catch (ClassNotFoundException e) {</span>
            //printError(name, e.getException());
<span class="nc" id="L155">            throw e;</span>
<span class="nc" id="L156">        } catch (RuntimeException e) {</span>
            //printError(name, e);
<span class="nc" id="L158">            throw e;</span>
<span class="nc" id="L159">        } catch (Error e) {</span>
            //printError(name, e);
<span class="nc" id="L161">            throw e;</span>
        }
    }

    /*
     * Finds the applet class with the specified name. First searches
     * loaded JAR files then the applet code base for the class.
     */
    protected Class findClass(String name) throws ClassNotFoundException {

<span class="fc" id="L171">        int index = name.indexOf(&quot;;&quot;);</span>
<span class="fc" id="L172">        String cookie = &quot;&quot;;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if(index != -1) {</span>
<span class="nc" id="L174">                cookie = name.substring(index, name.length());</span>
<span class="nc" id="L175">                name = name.substring(0, index);</span>
        }

        // check loaded JAR files
        try {
<span class="nc" id="L180">            return super.findClass(name);</span>
<span class="fc" id="L181">        } catch (ClassNotFoundException e) {</span>
        }

        // Otherwise, try loading the class from the code base URL

        // 4668479: Option to turn off codebase lookup in AppletClassLoader
        // during resource requests. [stanley.ho]
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (codebaseLookup == false)</span>
<span class="nc" id="L189">            throw new ClassNotFoundException(name);</span>

//      final String path = name.replace('.', '/').concat(&quot;.class&quot;).concat(cookie);
<span class="fc" id="L192">        String encodedName = ParseUtil.encodePath(name.replace('.', '/'), false);</span>
<span class="fc" id="L193">        final String path = (new StringBuffer(encodedName)).append(&quot;.class&quot;).append(cookie).toString();</span>
        try {
<span class="fc" id="L195">            byte[] b = (byte[]) AccessController.doPrivileged(</span>
<span class="fc" id="L196">                               new PrivilegedExceptionAction() {</span>
                public Object run() throws IOException {
                   try {
<span class="fc" id="L199">                        URL finalURL = new URL(base, path);</span>

                        // Make sure the codebase won't be modified
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                        if (base.getProtocol().equals(finalURL.getProtocol()) &amp;&amp;</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">                            base.getHost().equals(finalURL.getHost()) &amp;&amp;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                            base.getPort() == finalURL.getPort()) {</span>
<span class="fc" id="L205">                            return getBytes(finalURL);</span>
                        }
                        else {
<span class="nc" id="L208">                            return null;</span>
                        }
<span class="nc" id="L210">                    } catch (Exception e) {</span>
<span class="nc" id="L211">                        return null;</span>
                    }
                }
            }, acc);

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (b != null) {</span>
<span class="fc" id="L217">                return defineClass(name, b, 0, b.length, codesource);</span>
            } else {
<span class="nc" id="L219">                throw new ClassNotFoundException(name);</span>
            }
<span class="nc" id="L221">        } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L222">            throw new ClassNotFoundException(name, e.getException());</span>
        }
    }

    /**
     * Returns the permissions for the given codesource object.
     * The implementation of this method first calls super.getPermissions,
     * to get the permissions
     * granted by the super class, and then adds additional permissions
     * based on the URL of the codesource.
     * &lt;p&gt;
     * If the protocol is &quot;file&quot;
     * and the path specifies a file, permission is granted to read all files
     * and (recursively) all files and subdirectories contained in
     * that directory. This is so applets with a codebase of
     * file:/blah/some.jar can read in file:/blah/, which is needed to
     * be backward compatible. We also add permission to connect back to
     * the &quot;localhost&quot;.
     *
     * @param codesource the codesource
     * @throws NullPointerException if {@code codesource} is {@code null}.
     * @return the permissions granted to the codesource
     */
    protected PermissionCollection getPermissions(CodeSource codesource)
    {
<span class="fc" id="L247">        final PermissionCollection perms = super.getPermissions(codesource);</span>

<span class="fc" id="L249">        URL url = codesource.getLocation();</span>

<span class="fc" id="L251">        String path = null;</span>
        Permission p;

        try {
<span class="fc" id="L255">            p = url.openConnection().getPermission();</span>
<span class="nc" id="L256">        } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L257">            p = null;</span>
<span class="fc" id="L258">        }</span>

<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if (p instanceof FilePermission) {</span>
<span class="nc" id="L261">            path = p.getName();</span>
<span class="pc bpc" id="L262" title="3 of 4 branches missed.">        } else if ((p == null) &amp;&amp; (url.getProtocol().equals(&quot;file&quot;))) {</span>
<span class="nc" id="L263">            path = url.getFile().replace('/', File.separatorChar);</span>
<span class="nc" id="L264">            path = ParseUtil.decode(path);</span>
        }

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (path != null) {</span>
<span class="nc" id="L268">            final String rawPath = path;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (!path.endsWith(File.separator)) {</span>
<span class="nc" id="L270">                int endIndex = path.lastIndexOf(File.separatorChar);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (endIndex != -1) {</span>
<span class="nc" id="L272">                        path = path.substring(0, endIndex + 1) + &quot;-&quot;;</span>
<span class="nc" id="L273">                        perms.add(new FilePermission(path,</span>
                            SecurityConstants.FILE_READ_ACTION));
                }
            }
<span class="nc" id="L277">            final File f = new File(rawPath);</span>
<span class="nc" id="L278">            final boolean isDirectory = f.isDirectory();</span>
            // grant codebase recursive read permission
            // this should only be granted to non-UNC file URL codebase and
            // the codesource path must either be a directory, or a file
            // that ends with .jar or .zip
<span class="nc bnc" id="L283" title="All 4 branches missed.">            if (allowRecursiveDirectoryRead &amp;&amp; (isDirectory ||</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                    rawPath.toLowerCase().endsWith(&quot;.jar&quot;) ||</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                    rawPath.toLowerCase().endsWith(&quot;.zip&quot;))) {</span>

            Permission bperm;
                try {
<span class="nc" id="L289">                    bperm = base.openConnection().getPermission();</span>
<span class="nc" id="L290">                } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L291">                    bperm = null;</span>
<span class="nc" id="L292">                }</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                if (bperm instanceof FilePermission) {</span>
<span class="nc" id="L294">                    String bpath = bperm.getName();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                    if (bpath.endsWith(File.separator)) {</span>
<span class="nc" id="L296">                        bpath += &quot;-&quot;;</span>
                    }
<span class="nc" id="L298">                    perms.add(new FilePermission(bpath,</span>
                        SecurityConstants.FILE_READ_ACTION));
<span class="nc bnc" id="L300" title="All 4 branches missed.">                } else if ((bperm == null) &amp;&amp; (base.getProtocol().equals(&quot;file&quot;))) {</span>
<span class="nc" id="L301">                    String bpath = base.getFile().replace('/', File.separatorChar);</span>
<span class="nc" id="L302">                    bpath = ParseUtil.decode(bpath);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                    if (bpath.endsWith(File.separator)) {</span>
<span class="nc" id="L304">                        bpath += &quot;-&quot;;</span>
                    }
<span class="nc" id="L306">                    perms.add(new FilePermission(bpath, SecurityConstants.FILE_READ_ACTION));</span>
                }

            }
        }
<span class="fc" id="L311">        return perms;</span>
    }

    /*
     * Returns the contents of the specified URL as an array of bytes.
     */
    private static byte[] getBytes(URL url) throws IOException {
<span class="fc" id="L318">        URLConnection uc = url.openConnection();</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if (uc instanceof java.net.HttpURLConnection) {</span>
<span class="fc" id="L320">            java.net.HttpURLConnection huc = (java.net.HttpURLConnection) uc;</span>
<span class="fc" id="L321">            int code = huc.getResponseCode();</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            if (code &gt;= java.net.HttpURLConnection.HTTP_BAD_REQUEST) {</span>
<span class="nc" id="L323">                throw new IOException(&quot;open HTTP connection failed.&quot;);</span>
            }
        }
<span class="fc" id="L326">        int len = uc.getContentLength();</span>

        // Fixed #4507227: Slow performance to load
        // class and resources. [stanleyh]
        //
        // Use buffered input stream [stanleyh]
<span class="fc" id="L332">        InputStream in = new BufferedInputStream(uc.getInputStream());</span>

        byte[] b;
        try {
<span class="fc" id="L336">            b = IOUtils.readFully(in, len, true);</span>
        } finally {
<span class="pc" id="L338">            in.close();</span>
<span class="fc" id="L339">        }</span>
<span class="fc" id="L340">        return b;</span>
    }

    // Object for synchronization around getResourceAsStream()
<span class="fc" id="L344">    private Object syncResourceAsStream = new Object();</span>
<span class="fc" id="L345">    private Object syncResourceAsStreamFromJar = new Object();</span>

    // Flag to indicate getResourceAsStream() is in call
<span class="fc" id="L348">    private boolean resourceAsStreamInCall = false;</span>
<span class="fc" id="L349">    private boolean resourceAsStreamFromJarInCall = false;</span>

    /**
     * Returns an input stream for reading the specified resource.
     *
     * The search order is described in the documentation for {@link
     * #getResource(String)}.&lt;p&gt;
     *
     * @param  name the resource name
     * @return an input stream for reading the resource, or &lt;code&gt;null&lt;/code&gt;
     *         if the resource could not be found
     * @since  JDK1.1
     */
    public InputStream getResourceAsStream(String name)
    {

<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L366">            throw new NullPointerException(&quot;name&quot;);</span>
        }

        try
        {
<span class="nc" id="L371">            InputStream is = null;</span>

            // Fixed #4507227: Slow performance to load
            // class and resources. [stanleyh]
            //
            // The following is used to avoid calling
            // AppletClassLoader.findResource() in
            // super.getResourceAsStream(). Otherwise,
            // unnecessary connection will be made.
            //
<span class="nc" id="L381">            synchronized(syncResourceAsStream)</span>
            {
<span class="nc" id="L383">                resourceAsStreamInCall = true;</span>

                // Call super class
<span class="nc" id="L386">                is = super.getResourceAsStream(name);</span>

<span class="nc" id="L388">                resourceAsStreamInCall = false;</span>
<span class="nc" id="L389">            }</span>

            // 4668479: Option to turn off codebase lookup in AppletClassLoader
            // during resource requests. [stanley.ho]
<span class="nc bnc" id="L393" title="All 4 branches missed.">            if (codebaseLookup == true &amp;&amp; is == null)</span>
            {
                // If resource cannot be obtained,
                // try to download it from codebase
<span class="nc" id="L397">                URL url = new URL(base, ParseUtil.encodePath(name, false));</span>
<span class="nc" id="L398">                is = url.openStream();</span>
            }

<span class="nc" id="L401">            return is;</span>
        }
<span class="nc" id="L403">        catch (Exception e)</span>
        {
<span class="nc" id="L405">            return null;</span>
        }
    }


    /**
     * Returns an input stream for reading the specified resource from the
     * the loaded jar files.
     *
     * The search order is described in the documentation for {@link
     * #getResource(String)}.&lt;p&gt;
     *
     * @param  name the resource name
     * @return an input stream for reading the resource, or &lt;code&gt;null&lt;/code&gt;
     *         if the resource could not be found
     * @since  JDK1.1
     */
    public InputStream getResourceAsStreamFromJar(String name) {

<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L425">            throw new NullPointerException(&quot;name&quot;);</span>
        }

        try {
<span class="nc" id="L429">            InputStream is = null;</span>
<span class="nc" id="L430">            synchronized(syncResourceAsStreamFromJar) {</span>
<span class="nc" id="L431">                resourceAsStreamFromJarInCall = true;</span>
                // Call super class
<span class="nc" id="L433">                is = super.getResourceAsStream(name);</span>
<span class="nc" id="L434">                resourceAsStreamFromJarInCall = false;</span>
<span class="nc" id="L435">            }</span>

<span class="nc" id="L437">            return is;</span>
<span class="nc" id="L438">        } catch (Exception e) {</span>
<span class="nc" id="L439">            return null;</span>
        }
    }


    /*
     * Finds the applet resource with the specified name. First checks
     * loaded JAR files then the applet code base for the resource.
     */
    public URL findResource(String name) {
        // check loaded JAR files
<span class="nc" id="L450">        URL url = super.findResource(name);</span>

        // 6215746:  Disable META-INF/* lookup from codebase in
        // applet/plugin classloader. [stanley.ho]
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (name.startsWith(&quot;META-INF/&quot;))</span>
<span class="nc" id="L455">            return url;</span>

        // 4668479: Option to turn off codebase lookup in AppletClassLoader
        // during resource requests. [stanley.ho]
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (codebaseLookup == false)</span>
<span class="nc" id="L460">            return url;</span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (url == null)</span>
        {
            //#4805170, if it is a call from Applet.getImage()
            //we should check for the image only in the archives
<span class="nc" id="L466">            boolean insideGetResourceAsStreamFromJar = false;</span>
<span class="nc" id="L467">                synchronized(syncResourceAsStreamFromJar) {</span>
<span class="nc" id="L468">                insideGetResourceAsStreamFromJar = resourceAsStreamFromJarInCall;</span>
<span class="nc" id="L469">            }</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (insideGetResourceAsStreamFromJar) {</span>
<span class="nc" id="L472">                return null;</span>
            }

            // Fixed #4507227: Slow performance to load
            // class and resources. [stanleyh]
            //
            // Check if getResourceAsStream is called.
            //
<span class="nc" id="L480">            boolean insideGetResourceAsStream = false;</span>

<span class="nc" id="L482">            synchronized(syncResourceAsStream)</span>
            {
<span class="nc" id="L484">                insideGetResourceAsStream = resourceAsStreamInCall;</span>
<span class="nc" id="L485">            }</span>

            // If getResourceAsStream is called, don't
            // trigger the following code. Otherwise,
            // unnecessary connection will be made.
            //
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (insideGetResourceAsStream == false)</span>
            {
                // otherwise, try the code base
                try {
<span class="nc" id="L495">                    url = new URL(base, ParseUtil.encodePath(name, false));</span>
                    // check if resource exists
<span class="nc bnc" id="L497" title="All 2 branches missed.">                    if(!resourceExists(url))</span>
<span class="nc" id="L498">                        url = null;</span>
<span class="nc" id="L499">                } catch (Exception e) {</span>
                    // all exceptions, including security exceptions, are caught
<span class="nc" id="L501">                    url = null;</span>
<span class="nc" id="L502">                }</span>
            }
        }
<span class="nc" id="L505">        return url;</span>
    }


    private boolean resourceExists(URL url) {
        // Check if the resource exists.
        // It almost works to just try to do an openConnection() but
        // HttpURLConnection will return true on HTTP_BAD_REQUEST
        // when the requested name ends in &quot;.html&quot;, &quot;.htm&quot;, and &quot;.txt&quot;
        // and we want to be able to handle these
        //
        // Also, cannot just open a connection for things like FileURLConnection,
        // because they succeed when connecting to a nonexistent file.
        // So, in those cases we open and close an input stream.
<span class="nc" id="L519">        boolean ok = true;</span>
        try {
<span class="nc" id="L521">            URLConnection conn = url.openConnection();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">            if (conn instanceof java.net.HttpURLConnection) {</span>
<span class="nc" id="L523">                java.net.HttpURLConnection hconn =</span>
                    (java.net.HttpURLConnection) conn;

                // To reduce overhead, using http HEAD method instead of GET method
<span class="nc" id="L527">                hconn.setRequestMethod(&quot;HEAD&quot;);</span>

<span class="nc" id="L529">                int code = hconn.getResponseCode();</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                if (code == java.net.HttpURLConnection.HTTP_OK) {</span>
<span class="nc" id="L531">                    return true;</span>
                }
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (code &gt;= java.net.HttpURLConnection.HTTP_BAD_REQUEST) {</span>
<span class="nc" id="L534">                    return false;</span>
                }
<span class="nc" id="L536">            } else {</span>
                /**
                 * Fix for #4182052 - stanleyh
                 *
                 * The same connection should be reused to avoid multiple
                 * HTTP connections
                 */

                // our best guess for the other cases
<span class="nc" id="L545">                InputStream is = conn.getInputStream();</span>
<span class="nc" id="L546">                is.close();</span>
            }
<span class="nc" id="L548">        } catch (Exception ex) {</span>
<span class="nc" id="L549">            ok = false;</span>
<span class="nc" id="L550">        }</span>
<span class="nc" id="L551">        return ok;</span>
    }

    /*
     * Returns an enumeration of all the applet resources with the specified
     * name. First checks loaded JAR files then the applet code base for all
     * available resources.
     */
    public Enumeration findResources(String name) throws IOException {

<span class="nc" id="L561">        final Enumeration e = super.findResources(name);</span>

        // 6215746:  Disable META-INF/* lookup from codebase in
        // applet/plugin classloader. [stanley.ho]
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (name.startsWith(&quot;META-INF/&quot;))</span>
<span class="nc" id="L566">            return e;</span>

        // 4668479: Option to turn off codebase lookup in AppletClassLoader
        // during resource requests. [stanley.ho]
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (codebaseLookup == false)</span>
<span class="nc" id="L571">            return e;</span>

<span class="nc" id="L573">        URL u = new URL(base, ParseUtil.encodePath(name, false));</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (!resourceExists(u)) {</span>
<span class="nc" id="L575">            u = null;</span>
        }

<span class="nc" id="L578">        final URL url = u;</span>
<span class="nc" id="L579">        return new Enumeration() {</span>
            private boolean done;
            public Object nextElement() {
<span class="nc bnc" id="L582" title="All 2 branches missed.">                if (!done) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">                    if (e.hasMoreElements()) {</span>
<span class="nc" id="L584">                        return e.nextElement();</span>
                    }
<span class="nc" id="L586">                    done = true;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                    if (url != null) {</span>
<span class="nc" id="L588">                        return url;</span>
                    }
                }
<span class="nc" id="L591">                throw new NoSuchElementException();</span>
            }
            public boolean hasMoreElements() {
<span class="nc bnc" id="L594" title="All 6 branches missed.">                return !done &amp;&amp; (e.hasMoreElements() || url != null);</span>
            }
        };
    }

    /*
     * Load and resolve the file specified by the applet tag CODE
     * attribute. The argument can either be the relative path
     * of the class file itself or just the name of the class.
     */
    Class loadCode(String name) throws ClassNotFoundException {
        // first convert any '/' or native file separator to .
<span class="nc" id="L606">        name = name.replace('/', '.');</span>
<span class="nc" id="L607">        name = name.replace(File.separatorChar, '.');</span>

        // deal with URL rewriting
<span class="nc" id="L610">        String cookie = null;</span>
<span class="nc" id="L611">        int index = name.indexOf(&quot;;&quot;);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if(index != -1) {</span>
<span class="nc" id="L613">                cookie = name.substring(index, name.length());</span>
<span class="nc" id="L614">                name = name.substring(0, index);</span>
        }

        // save that name for later
<span class="nc" id="L618">        String fullName = name;</span>
        // then strip off any suffixes
<span class="nc bnc" id="L620" title="All 4 branches missed.">        if (name.endsWith(&quot;.class&quot;) || name.endsWith(&quot;.java&quot;)) {</span>
<span class="nc" id="L621">            name = name.substring(0, name.lastIndexOf('.'));</span>
        }
        try {
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if(cookie != null)</span>
<span class="nc" id="L625">                        name = (new StringBuffer(name)).append(cookie).toString();</span>
<span class="nc" id="L626">            return loadClass(name);</span>
<span class="nc" id="L627">        } catch (ClassNotFoundException e) {</span>
        }
        // then if it didn't end with .java or .class, or in the
        // really pathological case of a class named class or java
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if(cookie != null)</span>
<span class="nc" id="L632">                fullName = (new StringBuffer(fullName)).append(cookie).toString();</span>

<span class="nc" id="L634">        return loadClass(fullName);</span>
    }

    /*
     * The threadgroup that the applets loaded by this classloader live
     * in. In the sun.* implementation of applets, the security manager's
     * (AppletSecurity) getThreadGroup returns the thread group of the
     * first applet on the stack, which is the applet's thread group.
     */
    private AppletThreadGroup threadGroup;
    private AppContext appContext;

    public ThreadGroup getThreadGroup() {
<span class="nc" id="L647">      synchronized (threadGroupSynchronizer) {</span>
<span class="nc bnc" id="L648" title="All 4 branches missed.">        if (threadGroup == null || threadGroup.isDestroyed()) {</span>
<span class="nc" id="L649">            AccessController.doPrivileged(new PrivilegedAction() {</span>
                public Object run() {
<span class="nc" id="L651">                    threadGroup = new AppletThreadGroup(base + &quot;-threadGroup&quot;);</span>
                    // threadGroup.setDaemon(true);
                    // threadGroup is now destroyed by AppContext.dispose()

                    // Create the new AppContext from within a Thread belonging
                    // to the newly created ThreadGroup, and wait for the
                    // creation to complete before returning from this method.
<span class="nc" id="L658">                    AppContextCreator creatorThread = new AppContextCreator(threadGroup);</span>

                    // Since this thread will later be used to launch the
                    // applet's AWT-event dispatch thread and we want the applet
                    // code executing the AWT callbacks to use their own class
                    // loader rather than the system class loader, explicitly
                    // set the context class loader to the AppletClassLoader.
<span class="nc" id="L665">                    creatorThread.setContextClassLoader(AppletClassLoader.this);</span>

<span class="nc" id="L667">                    creatorThread.start();</span>
                    try {
<span class="nc" id="L669">                        synchronized(creatorThread.syncObject) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                            while (!creatorThread.created) {</span>
<span class="nc" id="L671">                                creatorThread.syncObject.wait();</span>
                            }
<span class="nc" id="L673">                        }</span>
<span class="nc" id="L674">                    } catch (InterruptedException e) { }</span>
<span class="nc" id="L675">                    appContext = creatorThread.appContext;</span>
<span class="nc" id="L676">                    return null;</span>
                }
            });
        }
<span class="nc" id="L680">        return threadGroup;</span>
<span class="nc" id="L681">      }</span>
    }

    /*
     * Get the AppContext, if any, corresponding to this AppletClassLoader.
     */
    public AppContext getAppContext()  {
<span class="nc" id="L688">        return appContext;</span>
    }

<span class="fc" id="L691">    int usageCount = 0;</span>

    /**
     * Grab this AppletClassLoader and its ThreadGroup/AppContext, so they
     * won't be destroyed.
     */
public     void grab() {
<span class="nc" id="L698">        synchronized(grabReleaseSynchronizer) {</span>
<span class="nc" id="L699">            usageCount++;</span>
<span class="nc" id="L700">        }</span>
<span class="nc" id="L701">        getThreadGroup(); // Make sure ThreadGroup/AppContext exist</span>
<span class="nc" id="L702">    }</span>

    protected void setExceptionStatus()
    {
<span class="nc" id="L706">        exceptionStatus = true;</span>
<span class="nc" id="L707">    }</span>

    public boolean getExceptionStatus()
    {
<span class="nc" id="L711">        return exceptionStatus;</span>
    }

    /**
     * Release this AppletClassLoader and its ThreadGroup/AppContext.
     * If nothing else has grabbed this AppletClassLoader, its ThreadGroup
     * and AppContext will be destroyed.
     *
     * Because this method may destroy the AppletClassLoader's ThreadGroup,
     * this method should NOT be called from within the AppletClassLoader's
     * ThreadGroup.
     *
     * Changed modifier to protected in order to be able to overwrite this
     * function in PluginClassLoader.java
     */
    protected void release() {

<span class="nc" id="L728">        AppContext tempAppContext = null;</span>

<span class="nc" id="L730">        synchronized(grabReleaseSynchronizer) {</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (usageCount &gt; 1)  {</span>
<span class="nc" id="L732">                --usageCount;</span>
            } else {
<span class="nc" id="L734">                synchronized(threadGroupSynchronizer) {</span>
<span class="nc" id="L735">                    tempAppContext = resetAppContext();</span>
<span class="nc" id="L736">                }</span>
            }
<span class="nc" id="L738">        }</span>

        // Dispose appContext outside any sync block to
        // prevent potential deadlock.
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (tempAppContext != null)  {</span>
            try {
<span class="nc" id="L744">                tempAppContext.dispose(); // nuke the world!</span>
<span class="nc" id="L745">            } catch (IllegalThreadStateException e) { }</span>
        }
<span class="nc" id="L747">    }</span>

    /*
     * reset classloader's AppContext and ThreadGroup
     * This method is for subclass PluginClassLoader to
     * reset superclass's AppContext and ThreadGroup but do
     * not dispose the AppContext. PluginClassLoader does not
     * use UsageCount to decide whether to dispose AppContext
     *
     * @return previous AppContext
     */
    protected AppContext resetAppContext() {
<span class="nc" id="L759">        AppContext tempAppContext = null;</span>

<span class="nc" id="L761">        synchronized(threadGroupSynchronizer) {</span>
            // Store app context in temp variable
<span class="nc" id="L763">            tempAppContext = appContext;</span>
<span class="nc" id="L764">            usageCount = 0;</span>
<span class="nc" id="L765">            appContext = null;</span>
<span class="nc" id="L766">            threadGroup = null;</span>
<span class="nc" id="L767">        }</span>
<span class="nc" id="L768">        return tempAppContext;</span>
    }


    // Hash map to store applet compatibility info
<span class="fc" id="L773">    private HashMap jdk11AppletInfo = new HashMap();</span>
<span class="fc" id="L774">    private HashMap jdk12AppletInfo = new HashMap();</span>

    /**
     * Set applet target level as JDK 1.1.
     *
     * @param clazz Applet class.
     * @param bool true if JDK is targeted for JDK 1.1;
     *             false otherwise.
     */
    void setJDK11Target(Class clazz, boolean bool)
    {
<span class="nc" id="L785">         jdk11AppletInfo.put(clazz.toString(), Boolean.valueOf(bool));</span>
<span class="nc" id="L786">    }</span>

    /**
     * Set applet target level as JDK 1.2.
     *
     * @param clazz Applet class.
     * @param bool true if JDK is targeted for JDK 1.2;
     *             false otherwise.
     */
    void setJDK12Target(Class clazz, boolean bool)
    {
<span class="nc" id="L797">        jdk12AppletInfo.put(clazz.toString(), Boolean.valueOf(bool));</span>
<span class="nc" id="L798">    }</span>

    /**
     * Determine if applet is targeted for JDK 1.1.
     *
     * @param applet Applet class.
     * @return TRUE if applet is targeted for JDK 1.1;
     *         FALSE if applet is not;
     *         null if applet is unknown.
     */
    Boolean isJDK11Target(Class clazz)
    {
<span class="nc" id="L810">        return (Boolean) jdk11AppletInfo.get(clazz.toString());</span>
    }

    /**
     * Determine if applet is targeted for JDK 1.2.
     *
     * @param applet Applet class.
     * @return TRUE if applet is targeted for JDK 1.2;
     *         FALSE if applet is not;
     *         null if applet is unknown.
     */
    Boolean isJDK12Target(Class clazz)
    {
<span class="nc" id="L823">        return (Boolean) jdk12AppletInfo.get(clazz.toString());</span>
    }

<span class="fc" id="L826">    private static AppletMessageHandler mh =</span>
        new AppletMessageHandler(&quot;appletclassloader&quot;);

    /*
     * Prints a class loading error message.
     */
    private static void printError(String name, Throwable e) {
<span class="nc" id="L833">        String s = null;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L835">            s = mh.getMessage(&quot;filenotfound&quot;, name);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">        } else if (e instanceof IOException) {</span>
<span class="nc" id="L837">            s = mh.getMessage(&quot;fileioexception&quot;, name);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">        } else if (e instanceof ClassFormatError) {</span>
<span class="nc" id="L839">            s = mh.getMessage(&quot;fileformat&quot;, name);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">        } else if (e instanceof ThreadDeath) {</span>
<span class="nc" id="L841">            s = mh.getMessage(&quot;filedeath&quot;, name);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">        } else if (e instanceof Error) {</span>
<span class="nc" id="L843">            s = mh.getMessage(&quot;fileerror&quot;, e.toString(), name);</span>
        }
<span class="nc bnc" id="L845" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L846">            System.err.println(s);</span>
        }
<span class="nc" id="L848">    }</span>
}

/*
 * The AppContextCreator class is used to create an AppContext from within
 * a Thread belonging to the new AppContext's ThreadGroup.  To wait for
 * this operation to complete before continuing, wait for the notifyAll()
 * operation on the syncObject to occur.
 */
class AppContextCreator extends Thread  {
<span class="nc" id="L858">    Object syncObject = new Object();</span>
<span class="nc" id="L859">    AppContext appContext = null;</span>
<span class="nc" id="L860">    volatile boolean created = false;</span>

    AppContextCreator(ThreadGroup group)  {
<span class="nc" id="L863">        super(group, &quot;AppContextCreator&quot;);</span>
<span class="nc" id="L864">    }</span>

    public void run()  {
<span class="nc" id="L867">        appContext = SunToolkit.createNewAppContext();</span>
<span class="nc" id="L868">        created = true;</span>
<span class="nc" id="L869">        synchronized(syncObject) {</span>
<span class="nc" id="L870">            syncObject.notifyAll();</span>
<span class="nc" id="L871">        }</span>
<span class="nc" id="L872">    } // run()</span>

} // class AppContextCreator
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>