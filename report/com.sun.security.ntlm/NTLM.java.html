<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NTLM.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.security.ntlm</a> &gt; <span class="el_source">NTLM.java</span></div><h1>NTLM.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.ntlm;

import static com.sun.security.ntlm.Version.*;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import java.util.Locale;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * NTLM authentication implemented according to MS-NLMP, version 12.1
 * @since 1.7
 */
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">class NTLM {</span>

    private final SecretKeyFactory fac;
    private final Cipher cipher;
    private final MessageDigest md4;
    private final Mac hmac;
    private final MessageDigest md5;
<span class="fc" id="L58">    private static final boolean DEBUG =</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            System.getProperty(&quot;ntlm.debug&quot;) != null;</span>

    final Version v;

    final boolean writeLM;
    final boolean writeNTLM;

<span class="fc" id="L66">    protected NTLM(String version) throws NTLMException {</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (version == null) version = &quot;LMv2/NTLMv2&quot;;</span>
<span class="pc bpc" id="L68" title="27 of 30 branches missed.">        switch (version) {</span>
<span class="nc" id="L69">            case &quot;LM&quot;: v = NTLM; writeLM = true; writeNTLM = false; break;</span>
<span class="nc" id="L70">            case &quot;NTLM&quot;: v = NTLM; writeLM = false; writeNTLM = true; break;</span>
<span class="nc" id="L71">            case &quot;LM/NTLM&quot;: v = NTLM; writeLM = writeNTLM = true; break;</span>
<span class="nc" id="L72">            case &quot;NTLM2&quot;: v = NTLM2; writeLM = writeNTLM = true; break;</span>
<span class="nc" id="L73">            case &quot;LMv2&quot;: v = NTLMv2; writeLM = true; writeNTLM = false; break;</span>
<span class="nc" id="L74">            case &quot;NTLMv2&quot;: v = NTLMv2; writeLM = false; writeNTLM = true; break;</span>
<span class="fc" id="L75">            case &quot;LMv2/NTLMv2&quot;: v = NTLMv2; writeLM = writeNTLM = true; break;</span>
<span class="nc" id="L76">            default: throw new NTLMException(NTLMException.BAD_VERSION,</span>
                    &quot;Unknown version &quot; + version);
        }
        try {
<span class="nc" id="L80">            fac = SecretKeyFactory.getInstance (&quot;DES&quot;);</span>
<span class="nc" id="L81">            cipher = Cipher.getInstance (&quot;DES/ECB/NoPadding&quot;);</span>
<span class="nc" id="L82">            md4 = sun.security.provider.MD4.getInstance();</span>
<span class="nc" id="L83">            hmac = Mac.getInstance(&quot;HmacMD5&quot;);</span>
<span class="nc" id="L84">            md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L85">        } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L86">            throw new AssertionError();</span>
<span class="nc" id="L87">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L88">            throw new AssertionError();</span>
<span class="nc" id="L89">        }</span>
<span class="nc" id="L90">    }</span>

    /**
     * Prints out a formatted string, called in various places inside then NTLM
     * implementation for debugging/logging purposes. When the system property
     * &quot;ntlm.debug&quot; is set, &lt;code&gt;System.out.printf(format, args)&lt;/code&gt; is
     * called. This method is designed to be overridden by child classes to
     * match their own debugging/logging mechanisms.
     * @param format a format string
     * @param args the arguments referenced by &lt;code&gt;format&lt;/code&gt;
     * @see java.io.PrintStream#printf(java.lang.String, java.lang.Object[])
     */
    public void debug(String format, Object... args) {
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L104">            System.out.printf(format, args);</span>
        }
<span class="nc" id="L106">    }</span>

    /**
     * Prints out the content of a byte array, called in various places inside
     * the NTLM implementation for debugging/logging purposes. When the system
     * property &quot;ntlm.debug&quot; is set, the hexdump of the array is printed into
     * System.out. This method is designed to be overridden by child classes to
     * match their own debugging/logging mechanisms.
     * @param bytes the byte array to print out
     */
    public void debug(byte[] bytes) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (DEBUG) {</span>
            try {
<span class="nc" id="L119">                new sun.misc.HexDumpEncoder().encodeBuffer(bytes, System.out);</span>
<span class="nc" id="L120">            } catch (IOException ioe) {</span>
                // Impossible
<span class="nc" id="L122">            }</span>
        }
<span class="nc" id="L124">    }</span>

    /**
     * Reading an NTLM packet
     */
    static class Reader {

        private final byte[] internal;

<span class="nc" id="L133">        Reader(byte[] data) {</span>
<span class="nc" id="L134">            internal = data;</span>
<span class="nc" id="L135">        }</span>

        int readInt(int offset) throws NTLMException {
            try {
<span class="nc" id="L139">                return (internal[offset] &amp; 0xff) +</span>
                        ((internal[offset+1] &amp; 0xff) &lt;&lt; 8) +
                        ((internal[offset+2] &amp; 0xff) &lt;&lt; 16) +
                        ((internal[offset+3] &amp; 0xff) &lt;&lt; 24);
<span class="nc" id="L143">            } catch (ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L144">                throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
                        &quot;Input message incorrect size&quot;);
            }
        }

        int readShort(int offset) throws NTLMException {
            try {
<span class="nc" id="L151">                return (internal[offset] &amp; 0xff) +</span>
                        ((internal[offset+1] &amp; 0xff &lt;&lt; 8));
<span class="nc" id="L153">            } catch (ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L154">                throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
                        &quot;Input message incorrect size&quot;);
            }
        }

        byte[] readBytes(int offset, int len) throws NTLMException {
            try {
<span class="nc" id="L161">                return Arrays.copyOfRange(internal, offset, offset + len);</span>
<span class="nc" id="L162">            } catch (ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L163">                throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
                        &quot;Input message incorrect size&quot;);
            }
        }

        byte[] readSecurityBuffer(int offset) throws NTLMException {
<span class="nc" id="L169">            int pos = readInt(offset+4);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (pos == 0) return null;</span>
            try {
<span class="nc" id="L172">                return Arrays.copyOfRange(</span>
<span class="nc" id="L173">                        internal, pos, pos + readShort(offset));</span>
<span class="nc" id="L174">            } catch (ArrayIndexOutOfBoundsException ex) {</span>
<span class="nc" id="L175">                throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
                        &quot;Input message incorrect size&quot;);
            }
        }

        String readSecurityBuffer(int offset, boolean unicode)
                throws NTLMException {
<span class="nc" id="L182">            byte[] raw = readSecurityBuffer(offset);</span>
            try {
<span class="nc bnc" id="L184" title="All 4 branches missed.">                return raw == null ? null : new String(</span>
                        raw, unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;);
<span class="nc" id="L186">            } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L187">                throw new NTLMException(NTLMException.PACKET_READ_ERROR,</span>
                        &quot;Invalid input encoding&quot;);
            }
        }
    }

    /**
     * Writing an NTLM packet
     */
<span class="nc bnc" id="L196" title="All 2 branches missed.">    static class Writer {</span>

        private byte[] internal;    // buffer
        private int current;        // current written content interface buffer

        /**
         * Starts writing a NTLM packet
         * @param type NEGOTIATE || CHALLENGE || AUTHENTICATE
         * @param len the base length, without security buffers
         */
<span class="nc" id="L206">        Writer(int type, int len) {</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">            assert len &lt; 256;</span>
<span class="nc" id="L208">            internal = new byte[256];</span>
<span class="nc" id="L209">            current = len;</span>
<span class="nc" id="L210">            System.arraycopy (</span>
                    new byte[] {'N','T','L','M','S','S','P',0,(byte)type},
                    0, internal, 0, 9);
<span class="nc" id="L213">        }</span>

        void writeShort(int offset, int number) {
<span class="nc" id="L216">            internal[offset] = (byte)(number);</span>
<span class="nc" id="L217">            internal[offset+1] = (byte)(number &gt;&gt; 8);</span>
<span class="nc" id="L218">        }</span>

        void writeInt(int offset, int number) {
<span class="nc" id="L221">            internal[offset] = (byte)(number);</span>
<span class="nc" id="L222">            internal[offset+1] = (byte)(number &gt;&gt; 8);</span>
<span class="nc" id="L223">            internal[offset+2] = (byte)(number &gt;&gt; 16);</span>
<span class="nc" id="L224">            internal[offset+3] = (byte)(number &gt;&gt; 24);</span>
<span class="nc" id="L225">        }</span>

        void writeBytes(int offset, byte[] data) {
<span class="nc" id="L228">            System.arraycopy(data, 0, internal, offset, data.length);</span>
<span class="nc" id="L229">        }</span>

        void writeSecurityBuffer(int offset, byte[] data) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (data == null) {</span>
<span class="nc" id="L233">                writeShort(offset+4, current);</span>
            } else {
<span class="nc" id="L235">                int len = data.length;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                if (current + len &gt; internal.length) {</span>
<span class="nc" id="L237">                    internal = Arrays.copyOf(internal, current + len + 256);</span>
                }
<span class="nc" id="L239">                writeShort(offset, len);</span>
<span class="nc" id="L240">                writeShort(offset+2, len);</span>
<span class="nc" id="L241">                writeShort(offset+4, current);</span>
<span class="nc" id="L242">                System.arraycopy(data, 0, internal, current, len);</span>
<span class="nc" id="L243">                current += len;</span>
            }
<span class="nc" id="L245">        }</span>

        void writeSecurityBuffer(int offset, String str, boolean unicode) {
            try {
<span class="nc bnc" id="L249" title="All 4 branches missed.">                writeSecurityBuffer(offset, str == null ? null : str.getBytes(</span>
                        unicode ? &quot;UnicodeLittleUnmarked&quot; : &quot;ISO8859_1&quot;));
<span class="nc" id="L251">            } catch (UnsupportedEncodingException ex) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                assert false;</span>
<span class="nc" id="L253">            }</span>
<span class="nc" id="L254">        }</span>

        byte[] getBytes() {
<span class="nc" id="L257">            return Arrays.copyOf(internal, current);</span>
        }
    }

    // LM/NTLM

    /* Convert a 7 byte array to an 8 byte array (for a des key with parity)
     * input starts at offset off
     */
    byte[] makeDesKey (byte[] input, int off) {
<span class="nc" id="L267">        int[] in = new int [input.length];</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (int i=0; i&lt;in.length; i++ ) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            in[i] = input[i]&lt;0 ? input[i]+256: input[i];</span>
        }
<span class="nc" id="L271">        byte[] out = new byte[8];</span>
<span class="nc" id="L272">        out[0] = (byte)in[off+0];</span>
<span class="nc" id="L273">        out[1] = (byte)(((in[off+0] &lt;&lt; 7) &amp; 0xFF) | (in[off+1] &gt;&gt; 1));</span>
<span class="nc" id="L274">        out[2] = (byte)(((in[off+1] &lt;&lt; 6) &amp; 0xFF) | (in[off+2] &gt;&gt; 2));</span>
<span class="nc" id="L275">        out[3] = (byte)(((in[off+2] &lt;&lt; 5) &amp; 0xFF) | (in[off+3] &gt;&gt; 3));</span>
<span class="nc" id="L276">        out[4] = (byte)(((in[off+3] &lt;&lt; 4) &amp; 0xFF) | (in[off+4] &gt;&gt; 4));</span>
<span class="nc" id="L277">        out[5] = (byte)(((in[off+4] &lt;&lt; 3) &amp; 0xFF) | (in[off+5] &gt;&gt; 5));</span>
<span class="nc" id="L278">        out[6] = (byte)(((in[off+5] &lt;&lt; 2) &amp; 0xFF) | (in[off+6] &gt;&gt; 6));</span>
<span class="nc" id="L279">        out[7] = (byte)((in[off+6] &lt;&lt; 1) &amp; 0xFF);</span>
<span class="nc" id="L280">        return out;</span>
    }

    byte[] calcLMHash (byte[] pwb) {
<span class="nc" id="L284">        byte[] magic = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};</span>
<span class="nc" id="L285">        byte[] pwb1 = new byte [14];</span>
<span class="nc" id="L286">        int len = pwb.length;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (len &gt; 14)</span>
<span class="nc" id="L288">            len = 14;</span>
<span class="nc" id="L289">        System.arraycopy (pwb, 0, pwb1, 0, len); /* Zero padded */</span>

        try {
<span class="nc" id="L292">            DESKeySpec dks1 = new DESKeySpec (makeDesKey (pwb1, 0));</span>
<span class="nc" id="L293">            DESKeySpec dks2 = new DESKeySpec (makeDesKey (pwb1, 7));</span>

<span class="nc" id="L295">            SecretKey key1 = fac.generateSecret (dks1);</span>
<span class="nc" id="L296">            SecretKey key2 = fac.generateSecret (dks2);</span>
<span class="nc" id="L297">            cipher.init (Cipher.ENCRYPT_MODE, key1);</span>
<span class="nc" id="L298">            byte[] out1 = cipher.doFinal (magic, 0, 8);</span>
<span class="nc" id="L299">            cipher.init (Cipher.ENCRYPT_MODE, key2);</span>
<span class="nc" id="L300">            byte[] out2 = cipher.doFinal (magic, 0, 8);</span>
<span class="nc" id="L301">            byte[] result = new byte [21];</span>
<span class="nc" id="L302">            System.arraycopy (out1, 0, result, 0, 8);</span>
<span class="nc" id="L303">            System.arraycopy (out2, 0, result, 8, 8);</span>
<span class="nc" id="L304">            return result;</span>
<span class="nc" id="L305">        } catch (InvalidKeyException ive) {</span>
            // Will not happen, all key material are 8 bytes
<span class="nc bnc" id="L307" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L308">        } catch (InvalidKeySpecException ikse) {</span>
            // Will not happen, we only feed DESKeySpec to DES factory
<span class="nc bnc" id="L310" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L311">        } catch (IllegalBlockSizeException ibse) {</span>
            // Will not happen, we encrypt 8 bytes
<span class="nc bnc" id="L313" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L314">        } catch (BadPaddingException bpe) {</span>
            // Will not happen, this is encryption
<span class="nc bnc" id="L316" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L317">        }</span>
<span class="nc" id="L318">        return null;    // will not happen, we returned already</span>
    }

    byte[] calcNTHash (byte[] pw) {
<span class="nc" id="L322">        byte[] out = md4.digest (pw);</span>
<span class="nc" id="L323">        byte[] result = new byte [21];</span>
<span class="nc" id="L324">        System.arraycopy (out, 0, result, 0, 16);</span>
<span class="nc" id="L325">        return result;</span>
    }

    /* key is a 21 byte array. Split it into 3 7 byte chunks,
     * Convert each to 8 byte DES keys, encrypt the text arg with
     * each key and return the three results in a sequential []
     */
    byte[] calcResponse (byte[] key, byte[] text) {
        try {
<span class="nc bnc" id="L334" title="All 4 branches missed.">            assert key.length == 21;</span>
<span class="nc" id="L335">            DESKeySpec dks1 = new DESKeySpec(makeDesKey(key, 0));</span>
<span class="nc" id="L336">            DESKeySpec dks2 = new DESKeySpec(makeDesKey(key, 7));</span>
<span class="nc" id="L337">            DESKeySpec dks3 = new DESKeySpec(makeDesKey(key, 14));</span>
<span class="nc" id="L338">            SecretKey key1 = fac.generateSecret(dks1);</span>
<span class="nc" id="L339">            SecretKey key2 = fac.generateSecret(dks2);</span>
<span class="nc" id="L340">            SecretKey key3 = fac.generateSecret(dks3);</span>
<span class="nc" id="L341">            cipher.init(Cipher.ENCRYPT_MODE, key1);</span>
<span class="nc" id="L342">            byte[] out1 = cipher.doFinal(text, 0, 8);</span>
<span class="nc" id="L343">            cipher.init(Cipher.ENCRYPT_MODE, key2);</span>
<span class="nc" id="L344">            byte[] out2 = cipher.doFinal(text, 0, 8);</span>
<span class="nc" id="L345">            cipher.init(Cipher.ENCRYPT_MODE, key3);</span>
<span class="nc" id="L346">            byte[] out3 = cipher.doFinal(text, 0, 8);</span>
<span class="nc" id="L347">            byte[] result = new byte[24];</span>
<span class="nc" id="L348">            System.arraycopy(out1, 0, result, 0, 8);</span>
<span class="nc" id="L349">            System.arraycopy(out2, 0, result, 8, 8);</span>
<span class="nc" id="L350">            System.arraycopy(out3, 0, result, 16, 8);</span>
<span class="nc" id="L351">            return result;</span>
<span class="nc" id="L352">        } catch (IllegalBlockSizeException ex) {    // None will happen</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L354">        } catch (BadPaddingException ex) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L356">        } catch (InvalidKeySpecException ex) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L358">        } catch (InvalidKeyException ex) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L360">        }</span>
<span class="nc" id="L361">        return null;</span>
    }

    // LMv2/NTLMv2

    byte[] hmacMD5(byte[] key, byte[] text) {
        try {
<span class="nc" id="L368">            SecretKeySpec skey =</span>
<span class="nc" id="L369">                    new SecretKeySpec(Arrays.copyOf(key, 16), &quot;HmacMD5&quot;);</span>
<span class="nc" id="L370">            hmac.init(skey);</span>
<span class="nc" id="L371">            return hmac.doFinal(text);</span>
<span class="nc" id="L372">        } catch (InvalidKeyException ex) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L374">        } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            assert false;</span>
<span class="nc" id="L376">        }</span>
<span class="nc" id="L377">        return null;</span>
    }

    byte[] calcV2(byte[] nthash, String text, byte[] blob, byte[] challenge) {
        try {
<span class="nc" id="L382">            byte[] ntlmv2hash = hmacMD5(nthash,</span>
<span class="nc" id="L383">                    text.getBytes(&quot;UnicodeLittleUnmarked&quot;));</span>
<span class="nc" id="L384">            byte[] cn = new byte[blob.length+8];</span>
<span class="nc" id="L385">            System.arraycopy(challenge, 0, cn, 0, 8);</span>
<span class="nc" id="L386">            System.arraycopy(blob, 0, cn, 8, blob.length);</span>
<span class="nc" id="L387">            byte[] result = new byte[16+blob.length];</span>
<span class="nc" id="L388">            System.arraycopy(hmacMD5(ntlmv2hash, cn), 0, result, 0, 16);</span>
<span class="nc" id="L389">            System.arraycopy(blob, 0, result, 16, blob.length);</span>
<span class="nc" id="L390">            return result;</span>
<span class="nc" id="L391">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            assert false;</span>
        }
<span class="nc" id="L394">        return null;</span>
    }

    // NTLM2 LM/NTLM

    static byte[] ntlm2LM(byte[] nonce) {
<span class="nc" id="L400">        return Arrays.copyOf(nonce, 24);</span>
    }

    byte[] ntlm2NTLM(byte[] ntlmHash, byte[] nonce, byte[] challenge) {
<span class="nc" id="L404">        byte[] b = Arrays.copyOf(challenge, 16);</span>
<span class="nc" id="L405">        System.arraycopy(nonce, 0, b, 8, 8);</span>
<span class="nc" id="L406">        byte[] sesshash = Arrays.copyOf(md5.digest(b), 8);</span>
<span class="nc" id="L407">        return calcResponse(ntlmHash, sesshash);</span>
    }

    // Password in ASCII and UNICODE

    static byte[] getP1(char[] password) {
        try {
<span class="nc" id="L414">            return new String(password).toUpperCase(</span>
<span class="nc" id="L415">                                    Locale.ENGLISH).getBytes(&quot;ISO8859_1&quot;);</span>
<span class="nc" id="L416">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L417">            return null;</span>
        }
    }

    static byte[] getP2(char[] password) {
        try {
<span class="nc" id="L423">            return new String(password).getBytes(&quot;UnicodeLittleUnmarked&quot;);</span>
<span class="nc" id="L424">        } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L425">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>