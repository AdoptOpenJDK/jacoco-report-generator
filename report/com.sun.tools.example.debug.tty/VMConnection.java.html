<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VMConnection.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.tools.example.debug.tty</a> &gt; <span class="el_source">VMConnection.java</span></div><h1>VMConnection.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.tty;

import com.sun.jdi.*;
import com.sun.jdi.connect.*;
import com.sun.jdi.request.EventRequestManager;
import com.sun.jdi.request.ThreadStartRequest;
import com.sun.jdi.request.ThreadDeathRequest;

import java.util.*;
import java.util.regex.*;
import java.io.*;

class VMConnection {

    private VirtualMachine vm;
<span class="nc" id="L50">    private Process process = null;</span>
<span class="nc" id="L51">    private int outputCompleteCount = 0;</span>

    private final Connector connector;
    private final Map&lt;String, com.sun.jdi.connect.Connector.Argument&gt; connectorArgs;
    private final int traceFlags;

    synchronized void notifyOutputComplete() {
<span class="nc" id="L58">        outputCompleteCount++;</span>
<span class="nc" id="L59">        notifyAll();</span>
<span class="nc" id="L60">    }</span>

    synchronized void waitOutputComplete() {
        // Wait for stderr and stdout
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (process != null) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">            while (outputCompleteCount &lt; 2) {</span>
<span class="nc" id="L66">                try {wait();} catch (InterruptedException e) {}</span>
            }
        }
<span class="nc" id="L69">    }</span>

    private Connector findConnector(String name) {
        for (Connector connector :
<span class="nc bnc" id="L73" title="All 2 branches missed.">                 Bootstrap.virtualMachineManager().allConnectors()) {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            if (connector.name().equals(name)) {</span>
<span class="nc" id="L75">                return connector;</span>
            }
<span class="nc" id="L77">        }</span>
<span class="nc" id="L78">        return null;</span>
    }

    private Map &lt;String, com.sun.jdi.connect.Connector.Argument&gt; parseConnectorArgs(Connector connector, String argString) {
<span class="nc" id="L82">        Map&lt;String, com.sun.jdi.connect.Connector.Argument&gt; arguments = connector.defaultArguments();</span>

        /*
         * We are parsing strings of the form:
         *    name1=value1,[name2=value2,...]
         * However, the value1...valuen substrings may contain
         * embedded comma(s), so make provision for quoting inside
         * the value substrings. (Bug ID 4285874)
         */
<span class="nc" id="L91">        String regexPattern =</span>
            &quot;(quote=[^,]+,)|&quot; +           // special case for quote=.,
            &quot;(\\w+=)&quot; +                   // name=
            &quot;(((\&quot;[^\&quot;]*\&quot;)|&quot; +           //   ( &quot;l , ue&quot;
            &quot;('[^']*')|&quot; +                //     'l , ue'
            &quot;([^,'\&quot;]+))+,)&quot;;             //     v a l u e )+ ,
<span class="nc" id="L97">        Pattern p = Pattern.compile(regexPattern);</span>
<span class="nc" id="L98">        Matcher m = p.matcher(argString);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        while (m.find()) {</span>
<span class="nc" id="L100">            int startPosition = m.start();</span>
<span class="nc" id="L101">            int endPosition = m.end();</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (startPosition &gt; 0) {</span>
                /*
                 * It is an error if parsing skips over any part of argString.
                 */
<span class="nc" id="L106">                throw new IllegalArgumentException</span>
<span class="nc" id="L107">                    (MessageOutput.format(&quot;Illegal connector argument&quot;,</span>
                                          argString));
            }

<span class="nc" id="L111">            String token = argString.substring(startPosition, endPosition);</span>
<span class="nc" id="L112">            int index = token.indexOf('=');</span>
<span class="nc" id="L113">            String name = token.substring(0, index);</span>
<span class="nc" id="L114">            String value = token.substring(index + 1,</span>
<span class="nc" id="L115">                                           token.length() - 1); // Remove comma delimiter</span>

            /*
             * for values enclosed in quotes (single and/or double quotes)
             * strip off enclosing quote chars
             * needed for quote enclosed delimited substrings
             */
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (name.equals(&quot;options&quot;)) {</span>
<span class="nc" id="L123">                StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                for (String s : splitStringAtNonEnclosedWhiteSpace(value)) {</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">                    while (isEnclosed(s, &quot;\&quot;&quot;) || isEnclosed(s, &quot;'&quot;)) {</span>
<span class="nc" id="L126">                        s = s.substring(1, s.length() - 1);</span>
                    }
<span class="nc" id="L128">                    sb.append(s);</span>
<span class="nc" id="L129">                    sb.append(&quot; &quot;);</span>
<span class="nc" id="L130">                }</span>
<span class="nc" id="L131">                value = sb.toString();</span>
            }

<span class="nc" id="L134">            Connector.Argument argument = arguments.get(name);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (argument == null) {</span>
<span class="nc" id="L136">                throw new IllegalArgumentException</span>
<span class="nc" id="L137">                    (MessageOutput.format(&quot;Argument is not defined for connector:&quot;,</span>
<span class="nc" id="L138">                                          new Object [] {name, connector.name()}));</span>
            }
<span class="nc" id="L140">            argument.setValue(value);</span>

<span class="nc" id="L142">            argString = argString.substring(endPosition); // Remove what was just parsed...</span>
<span class="nc" id="L143">            m = p.matcher(argString);                     //    and parse again on what is left.</span>
<span class="nc" id="L144">        }</span>
<span class="nc bnc" id="L145" title="All 4 branches missed.">        if ((! argString.equals(&quot;,&quot;)) &amp;&amp; (argString.length() &gt; 0)) {</span>
            /*
             * It is an error if any part of argString is left over,
             * unless it was empty to begin with.
             */
<span class="nc" id="L150">            throw new IllegalArgumentException</span>
<span class="nc" id="L151">                (MessageOutput.format(&quot;Illegal connector argument&quot;, argString));</span>
        }
<span class="nc" id="L153">        return arguments;</span>
    }

    private static boolean isEnclosed(String value, String enclosingChar) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (value.indexOf(enclosingChar) == 0) {</span>
<span class="nc" id="L158">            int lastIndex = value.lastIndexOf(enclosingChar);</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">            if (lastIndex &gt; 0 &amp;&amp; lastIndex  == value.length() - 1) {</span>
<span class="nc" id="L160">                return true;</span>
            }
        }
<span class="nc" id="L163">        return false;</span>
    }

    private static List&lt;String&gt; splitStringAtNonEnclosedWhiteSpace(String value) throws IllegalArgumentException {
<span class="nc" id="L167">        List&lt;String&gt; al = new ArrayList&lt;String&gt;();</span>
        char[] arr;
<span class="nc" id="L169">        int startPosition = 0;</span>
<span class="nc" id="L170">        int endPosition = 0;</span>
        final char SPACE = ' ';
        final char DOUBLEQ = '&quot;';
        final char SINGLEQ = '\'';

        /*
         * An &quot;open&quot; or &quot;active&quot; enclosing state is where
         * the first valid start quote qualifier is found,
         * and there is a search in progress for the
         * relevant end matching quote
         *
         * enclosingTargetChar set to SPACE
         * is used to signal a non open enclosing state
         */
<span class="nc" id="L184">        char enclosingTargetChar = SPACE;</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L187">            throw new IllegalArgumentException</span>
<span class="nc" id="L188">                (MessageOutput.format(&quot;value string is null&quot;));</span>
        }

        // split parameter string into individual chars
<span class="nc" id="L192">        arr = value.toCharArray();</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="nc bnc" id="L195" title="All 3 branches missed.">            switch (arr[i]) {</span>
                case SPACE: {
                    // do nothing for spaces
                    // unless last in array
<span class="nc bnc" id="L199" title="All 2 branches missed.">                    if (isLastChar(arr, i)) {</span>
<span class="nc" id="L200">                        endPosition = i;</span>
                        // break for substring creation
<span class="nc" id="L202">                        break;</span>
                    }
                    continue;
                }
                case DOUBLEQ:
                case SINGLEQ: {
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (enclosingTargetChar == arr[i]) {</span>
                        // potential match to close open enclosing
<span class="nc bnc" id="L210" title="All 2 branches missed.">                        if (isNextCharWhitespace(arr, i)) {</span>
                            // if peek next is whitespace
                            // then enclosing is a valid substring
<span class="nc" id="L213">                            endPosition = i;</span>
                            // reset enclosing target char
<span class="nc" id="L215">                            enclosingTargetChar = SPACE;</span>
                            // break for substring creation
<span class="nc" id="L217">                            break;</span>
                        }
                    }
<span class="nc bnc" id="L220" title="All 2 branches missed.">                    if (enclosingTargetChar == SPACE) {</span>
                        // no open enclosing state
                        // handle as normal char
<span class="nc bnc" id="L223" title="All 2 branches missed.">                        if (isPreviousCharWhitespace(arr, i)) {</span>
<span class="nc" id="L224">                            startPosition = i;</span>
                            // peek forward for end candidates
<span class="nc bnc" id="L226" title="All 2 branches missed.">                            if (value.indexOf(arr[i], i + 1) &gt;= 0) {</span>
                                // set open enclosing state by
                                // setting up the target char
<span class="nc" id="L229">                                enclosingTargetChar = arr[i];</span>
                            } else {
                                // no more target chars left to match
                                // end enclosing, handle as normal char
<span class="nc bnc" id="L233" title="All 2 branches missed.">                                if (isNextCharWhitespace(arr, i)) {</span>
<span class="nc" id="L234">                                    endPosition = i;</span>
                                    // break for substring creation
<span class="nc" id="L236">                                    break;</span>
                                }
                            }
                        }
                    }
                    continue;
                }
                default: {
                    // normal non-space, non-&quot; and non-' chars
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    if (enclosingTargetChar == SPACE) {</span>
                        // no open enclosing state
<span class="nc bnc" id="L247" title="All 2 branches missed.">                        if (isPreviousCharWhitespace(arr, i)) {</span>
                            // start of space delim substring
<span class="nc" id="L249">                            startPosition = i;</span>
                        }
<span class="nc bnc" id="L251" title="All 2 branches missed.">                        if (isNextCharWhitespace(arr, i)) {</span>
                            // end of space delim substring
<span class="nc" id="L253">                            endPosition = i;</span>
                            // break for substring creation
                            break;
                        }
                    }
                    continue;
                }
            }

            // break's end up here
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (startPosition &gt; endPosition) {</span>
<span class="nc" id="L264">                throw new IllegalArgumentException</span>
<span class="nc" id="L265">                    (MessageOutput.format(&quot;Illegal option values&quot;));</span>
            }

            // extract substring and add to List&lt;String&gt;
<span class="nc" id="L269">            al.add(value.substring(startPosition, ++endPosition));</span>

            // set new start position
<span class="nc" id="L272">            i = startPosition = endPosition;</span>

        } // for loop

<span class="nc" id="L276">        return al;</span>
    }

    static private boolean isPreviousCharWhitespace(char[] arr, int curr_pos) {
<span class="nc" id="L280">        return isCharWhitespace(arr, curr_pos - 1);</span>
    }

    static private boolean isNextCharWhitespace(char[] arr, int curr_pos) {
<span class="nc" id="L284">        return isCharWhitespace(arr, curr_pos + 1);</span>
    }

    static private boolean isCharWhitespace(char[] arr, int pos) {
<span class="nc bnc" id="L288" title="All 4 branches missed.">        if (pos &lt; 0 || pos &gt;= arr.length) {</span>
            // outside arraybounds is considered an implicit space
<span class="nc" id="L290">            return true;</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (arr[pos] == ' ') {</span>
<span class="nc" id="L293">            return true;</span>
        }
<span class="nc" id="L295">        return false;</span>
    }

    static private boolean isLastChar(char[] arr, int pos) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        return (pos + 1 == arr.length);</span>
    }

<span class="nc" id="L302">    VMConnection(String connectSpec, int traceFlags) {</span>
        String nameString;
        String argString;
<span class="nc" id="L305">        int index = connectSpec.indexOf(':');</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L307">            nameString = connectSpec;</span>
<span class="nc" id="L308">            argString = &quot;&quot;;</span>
        } else {
<span class="nc" id="L310">            nameString = connectSpec.substring(0, index);</span>
<span class="nc" id="L311">            argString = connectSpec.substring(index + 1);</span>
        }

<span class="nc" id="L314">        connector = findConnector(nameString);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (connector == null) {</span>
<span class="nc" id="L316">            throw new IllegalArgumentException</span>
<span class="nc" id="L317">                (MessageOutput.format(&quot;No connector named:&quot;, nameString));</span>
        }

<span class="nc" id="L320">        connectorArgs = parseConnectorArgs(connector, argString);</span>
<span class="nc" id="L321">        this.traceFlags = traceFlags;</span>
<span class="nc" id="L322">    }</span>

    synchronized VirtualMachine open() {
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (connector instanceof LaunchingConnector) {</span>
<span class="nc" id="L326">            vm = launchTarget();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        } else if (connector instanceof AttachingConnector) {</span>
<span class="nc" id="L328">            vm = attachTarget();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        } else if (connector instanceof ListeningConnector) {</span>
<span class="nc" id="L330">            vm = listenTarget();</span>
        } else {
<span class="nc" id="L332">            throw new InternalError</span>
<span class="nc" id="L333">                (MessageOutput.format(&quot;Invalid connect type&quot;));</span>
        }
<span class="nc" id="L335">        vm.setDebugTraceMode(traceFlags);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (vm.canBeModified()){</span>
<span class="nc" id="L337">            setEventRequests(vm);</span>
<span class="nc" id="L338">            resolveEventRequests();</span>
        }
        /*
         * Now that the vm connection is open, fetch the debugee
         * classpath and set up a default sourcepath.
         * (Unless user supplied a sourcepath on the command line)
         * (Bug ID 4186582)
         */
<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (Env.getSourcePath().length() == 0) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            if (vm instanceof PathSearchingVirtualMachine) {</span>
<span class="nc" id="L348">                PathSearchingVirtualMachine psvm =</span>
                    (PathSearchingVirtualMachine) vm;
<span class="nc" id="L350">                Env.setSourcePath(psvm.classPath());</span>
<span class="nc" id="L351">            } else {</span>
<span class="nc" id="L352">                Env.setSourcePath(&quot;.&quot;);</span>
            }
        }

<span class="nc" id="L356">        return vm;</span>
    }

    boolean setConnectorArg(String name, String value) {
        /*
         * Too late if the connection already made
         */
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (vm != null) {</span>
<span class="nc" id="L364">            return false;</span>
        }

<span class="nc" id="L367">        Connector.Argument argument = connectorArgs.get(name);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (argument == null) {</span>
<span class="nc" id="L369">            return false;</span>
        }
<span class="nc" id="L371">        argument.setValue(value);</span>
<span class="nc" id="L372">        return true;</span>
    }

    String connectorArg(String name) {
<span class="nc" id="L376">        Connector.Argument argument = connectorArgs.get(name);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (argument == null) {</span>
<span class="nc" id="L378">            return &quot;&quot;;</span>
        }
<span class="nc" id="L380">        return argument.value();</span>
    }

    public synchronized VirtualMachine vm() {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (vm == null) {</span>
<span class="nc" id="L385">            throw new VMNotConnectedException();</span>
        } else {
<span class="nc" id="L387">            return vm;</span>
        }
    }

    boolean isOpen() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        return (vm != null);</span>
    }

    boolean isLaunch() {
<span class="nc" id="L396">        return (connector instanceof LaunchingConnector);</span>
    }

    public void disposeVM() {
        try {
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (vm != null) {</span>
<span class="nc" id="L402">                vm.dispose();</span>
<span class="nc" id="L403">                vm = null;</span>
            }
        } finally {
<span class="nc bnc" id="L406" title="All 4 branches missed.">            if (process != null) {</span>
<span class="nc" id="L407">                process.destroy();</span>
<span class="nc" id="L408">                process = null;</span>
            }
<span class="nc" id="L410">            waitOutputComplete();</span>
<span class="nc" id="L411">        }</span>
<span class="nc" id="L412">    }</span>

    private void setEventRequests(VirtualMachine vm) {
<span class="nc" id="L415">        EventRequestManager erm = vm.eventRequestManager();</span>

        // Normally, we want all uncaught exceptions.  We request them
        // via the same mechanism as Commands.commandCatchException()
        // so the user can ignore them later if they are not
        // interested.
        // FIXME: this works but generates spurious messages on stdout
        //        during startup:
        //          Set uncaught java.lang.Throwable
        //          Set deferred uncaught java.lang.Throwable
<span class="nc" id="L425">        Commands evaluator = new Commands();</span>
<span class="nc" id="L426">        evaluator.commandCatchException</span>
<span class="nc" id="L427">            (new StringTokenizer(&quot;uncaught java.lang.Throwable&quot;));</span>

<span class="nc" id="L429">        ThreadStartRequest tsr = erm.createThreadStartRequest();</span>
<span class="nc" id="L430">        tsr.enable();</span>
<span class="nc" id="L431">        ThreadDeathRequest tdr = erm.createThreadDeathRequest();</span>
<span class="nc" id="L432">        tdr.enable();</span>
<span class="nc" id="L433">    }</span>

    private void resolveEventRequests() {
<span class="nc" id="L436">        Env.specList.resolveAll();</span>
<span class="nc" id="L437">    }</span>

    private void dumpStream(InputStream stream) throws IOException {
<span class="nc" id="L440">        BufferedReader in =</span>
            new BufferedReader(new InputStreamReader(stream));
        int i;
        try {
<span class="nc bnc" id="L444" title="All 2 branches missed.">            while ((i = in.read()) != -1) {</span>
<span class="nc" id="L445">                   MessageOutput.printDirect((char)i);// Special case: use</span>
                                                      //   printDirect()
            }
<span class="nc" id="L448">        } catch (IOException ex) {</span>
<span class="nc" id="L449">            String s = ex.getMessage();</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            if (!s.startsWith(&quot;Bad file number&quot;)) {</span>
<span class="nc" id="L451">                  throw ex;</span>
            }
            // else we got a Bad file number IOException which just means
            // that the debuggee has gone away.  We'll just treat it the
            // same as if we got an EOF.
<span class="nc" id="L456">        }</span>
<span class="nc" id="L457">    }</span>

    /**
     *  Create a Thread that will retrieve and display any output.
     *  Needs to be high priority, else debugger may exit before
     *  it can be displayed.
     */
    private void displayRemoteOutput(final InputStream stream) {
<span class="nc" id="L465">        Thread thr = new Thread(&quot;output reader&quot;) {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L469">                    dumpStream(stream);</span>
<span class="nc" id="L470">                } catch (IOException ex) {</span>
<span class="nc" id="L471">                    MessageOutput.fatalError(&quot;Failed reading output&quot;);</span>
                } finally {
<span class="nc" id="L473">                    notifyOutputComplete();</span>
<span class="nc" id="L474">                }</span>
<span class="nc" id="L475">            }</span>
        };
<span class="nc" id="L477">        thr.setPriority(Thread.MAX_PRIORITY-1);</span>
<span class="nc" id="L478">        thr.start();</span>
<span class="nc" id="L479">    }</span>

    private void dumpFailedLaunchInfo(Process process) {
        try {
<span class="nc" id="L483">            dumpStream(process.getErrorStream());</span>
<span class="nc" id="L484">            dumpStream(process.getInputStream());</span>
<span class="nc" id="L485">        } catch (IOException e) {</span>
<span class="nc" id="L486">            MessageOutput.println(&quot;Unable to display process output:&quot;,</span>
<span class="nc" id="L487">                                  e.getMessage());</span>
<span class="nc" id="L488">        }</span>
<span class="nc" id="L489">    }</span>

    /* launch child target vm */
    private VirtualMachine launchTarget() {
<span class="nc" id="L493">        LaunchingConnector launcher = (LaunchingConnector)connector;</span>
        try {
<span class="nc" id="L495">            VirtualMachine vm = launcher.launch(connectorArgs);</span>
<span class="nc" id="L496">            process = vm.process();</span>
<span class="nc" id="L497">            displayRemoteOutput(process.getErrorStream());</span>
<span class="nc" id="L498">            displayRemoteOutput(process.getInputStream());</span>
<span class="nc" id="L499">            return vm;</span>
<span class="nc" id="L500">        } catch (IOException ioe) {</span>
<span class="nc" id="L501">            ioe.printStackTrace();</span>
<span class="nc" id="L502">            MessageOutput.fatalError(&quot;Unable to launch target VM.&quot;);</span>
<span class="nc" id="L503">        } catch (IllegalConnectorArgumentsException icae) {</span>
<span class="nc" id="L504">            icae.printStackTrace();</span>
<span class="nc" id="L505">            MessageOutput.fatalError(&quot;Internal debugger error.&quot;);</span>
<span class="nc" id="L506">        } catch (VMStartException vmse) {</span>
<span class="nc" id="L507">            MessageOutput.println(&quot;vmstartexception&quot;, vmse.getMessage());</span>
<span class="nc" id="L508">            MessageOutput.println();</span>
<span class="nc" id="L509">            dumpFailedLaunchInfo(vmse.process());</span>
<span class="nc" id="L510">            MessageOutput.fatalError(&quot;Target VM failed to initialize.&quot;);</span>
<span class="nc" id="L511">        }</span>
<span class="nc" id="L512">        return null; // Shuts up the compiler</span>
    }

    /* attach to running target vm */
    private VirtualMachine attachTarget() {
<span class="nc" id="L517">        AttachingConnector attacher = (AttachingConnector)connector;</span>
        try {
<span class="nc" id="L519">            return attacher.attach(connectorArgs);</span>
<span class="nc" id="L520">        } catch (IOException ioe) {</span>
<span class="nc" id="L521">            ioe.printStackTrace();</span>
<span class="nc" id="L522">            MessageOutput.fatalError(&quot;Unable to attach to target VM.&quot;);</span>
<span class="nc" id="L523">        } catch (IllegalConnectorArgumentsException icae) {</span>
<span class="nc" id="L524">            icae.printStackTrace();</span>
<span class="nc" id="L525">            MessageOutput.fatalError(&quot;Internal debugger error.&quot;);</span>
<span class="nc" id="L526">        }</span>
<span class="nc" id="L527">        return null; // Shuts up the compiler</span>
    }

    /* listen for connection from target vm */
    private VirtualMachine listenTarget() {
<span class="nc" id="L532">        ListeningConnector listener = (ListeningConnector)connector;</span>
        try {
<span class="nc" id="L534">            String retAddress = listener.startListening(connectorArgs);</span>
<span class="nc" id="L535">            MessageOutput.println(&quot;Listening at address:&quot;, retAddress);</span>
<span class="nc" id="L536">            vm = listener.accept(connectorArgs);</span>
<span class="nc" id="L537">            listener.stopListening(connectorArgs);</span>
<span class="nc" id="L538">            return vm;</span>
<span class="nc" id="L539">        } catch (IOException ioe) {</span>
<span class="nc" id="L540">            ioe.printStackTrace();</span>
<span class="nc" id="L541">            MessageOutput.fatalError(&quot;Unable to attach to target VM.&quot;);</span>
<span class="nc" id="L542">        } catch (IllegalConnectorArgumentsException icae) {</span>
<span class="nc" id="L543">            icae.printStackTrace();</span>
<span class="nc" id="L544">            MessageOutput.fatalError(&quot;Internal debugger error.&quot;);</span>
<span class="nc" id="L545">        }</span>
<span class="nc" id="L546">        return null; // Shuts up the compiler</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>