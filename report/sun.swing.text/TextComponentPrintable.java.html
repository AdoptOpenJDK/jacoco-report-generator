<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextComponentPrintable.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.swing.text</a> &gt; <span class="el_source">TextComponentPrintable.java</span></div><h1>TextComponentPrintable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.swing.text;

import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.Component;
import java.awt.Container;
import java.awt.font.FontRenderContext;
import java.awt.print.PageFormat;
import java.awt.print.Printable;
import java.awt.print.PrinterException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicReference;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;
import javax.swing.text.Document;
import javax.swing.text.EditorKit;
import javax.swing.text.AbstractDocument;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTML;

import sun.font.FontDesignMetrics;

import sun.swing.text.html.FrameEditorPaneTag;

/**
 * An implementation of {@code Printable} to print {@code JTextComponent} with
 * the header and footer.
 *
 * &lt;h1&gt;
 * WARNING: this class is to be used in
 * javax.swing.text.JTextComponent only.
 * &lt;/h1&gt;
 *
 * &lt;p&gt;
 * The implementation creates a new {@code JTextComponent} ({@code printShell})
 * to print the content using the {@code Document}, {@code EditorKit} and
 * rendering-affecting properties from the original {@code JTextComponent}.
 *
 * &lt;p&gt;
 * {@code printShell} is laid out on the first {@code print} invocation.
 *
 * &lt;p&gt;
 * This class can be used on any thread. Part of the implementation is executed
 * on the EDT though.
 *
 * @author Igor Kushnirskiy
 *
 * @since 1.6
 */
<span class="nc bnc" id="L90" title="All 2 branches missed.">public class TextComponentPrintable implements CountingPrintable {</span>


    private static final int LIST_SIZE = 1000;

<span class="nc" id="L95">    private boolean isLayouted = false;</span>

    /*
     * The text component to print.
     */
    private final JTextComponent textComponentToPrint;

    /*
     * The FontRenderContext to layout and print with
     */
<span class="nc" id="L105">    private final AtomicReference&lt;FontRenderContext&gt; frc =</span>
        new AtomicReference&lt;FontRenderContext&gt;(null);

    /**
     * Special text component used to print to the printer.
     */
    private final JTextComponent printShell;

    private final MessageFormat headerFormat;
    private final MessageFormat footerFormat;

    private static final float HEADER_FONT_SIZE = 18.0f;
    private static final float FOOTER_FONT_SIZE = 12.0f;

    private final Font headerFont;
    private final Font footerFont;

    /**
     * stores metrics for the unhandled rows. The only metrics we need are
     * yStart and yEnd when row is handled by updatePagesMetrics it is removed
     * from the list. Thus the head of the list is the fist row to handle.
     *
     * sorted
     */
    private final List&lt;IntegerSegment&gt; rowsMetrics;

    /**
     * thread-safe list for storing pages metrics. The only metrics we need are
     * yStart and yEnd.
     * It has to be thread-safe since metrics are calculated on
     * the printing thread and accessed on the EDT thread.
     *
     * sorted
     */
    private final List&lt;IntegerSegment&gt; pagesMetrics;

    /**
     * Returns {@code TextComponentPrintable} to print {@code textComponent}.
     *
     * @param textComponent {@code JTextComponent} to print
     * @param headerFormat the page header, or {@code null} for none
     * @param footerFormat the page footer, or {@code null} for none
     * @return {@code TextComponentPrintable} to print {@code textComponent}
     */
    public static Printable getPrintable(final JTextComponent textComponent,
            final MessageFormat headerFormat,
            final MessageFormat footerFormat) {

<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (textComponent instanceof JEditorPane</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                &amp;&amp; isFrameSetDocument(textComponent.getDocument())) {</span>
            //for document with frames we create one printable per
            //frame and merge them with the CompoundPrintable.
<span class="nc" id="L157">            List&lt;JEditorPane&gt; frames = getFrames((JEditorPane) textComponent);</span>
<span class="nc" id="L158">            List&lt;CountingPrintable&gt; printables =</span>
                new ArrayList&lt;CountingPrintable&gt;();
<span class="nc bnc" id="L160" title="All 2 branches missed.">            for (JEditorPane frame : frames) {</span>
<span class="nc" id="L161">                printables.add((CountingPrintable)</span>
<span class="nc" id="L162">                               getPrintable(frame, headerFormat, footerFormat));</span>
<span class="nc" id="L163">            }</span>
<span class="nc" id="L164">            return new CompoundPrintable(printables);</span>
        } else {
<span class="nc" id="L166">            return new TextComponentPrintable(textComponent,</span>
               headerFormat, footerFormat);
        }
    }

    /**
     * Checks whether the document has frames. Only HTMLDocument might
     * have frames.
     *
     * @param document the {@code Document} to check
     * @return {@code true} if the {@code document} has frames
     */
    private static boolean isFrameSetDocument(final Document document) {
<span class="nc" id="L179">        boolean ret = false;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (document instanceof HTMLDocument) {</span>
<span class="nc" id="L181">            HTMLDocument htmlDocument = (HTMLDocument)document;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (htmlDocument.getIterator(HTML.Tag.FRAME).isValid()) {</span>
<span class="nc" id="L183">                ret = true;</span>
            }
        }
<span class="nc" id="L186">        return ret;</span>
    }


    /**
     * Returns frames under the {@code editor}.
     * The frames are created if necessary.
     *
     * @param editor the {@JEditorPane} to find the frames for
     * @return list of all frames
     */
    private static List&lt;JEditorPane&gt; getFrames(final JEditorPane editor) {
<span class="nc" id="L198">        List&lt;JEditorPane&gt; list = new ArrayList&lt;JEditorPane&gt;();</span>
<span class="nc" id="L199">        getFrames(editor, list);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (list.size() == 0) {</span>
            //the frames have not been created yet.
            //let's trigger the frames creation.
<span class="nc" id="L203">            createFrames(editor);</span>
<span class="nc" id="L204">            getFrames(editor, list);</span>
        }
<span class="nc" id="L206">        return list;</span>
    }

    /**
     * Adds all {@code JEditorPanes} under {@code container} tagged by {@code
     * FrameEditorPaneTag} to the {@code list}. It adds only top
     * level {@code JEditorPanes}.  For instance if there is a frame
     * inside the frame it will return the top frame only.
     *
     * @param c the container to find all frames under
     * @param list {@code List} to append the results too
     */
    private static void getFrames(final Container container, List&lt;JEditorPane&gt; list) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (Component c : container.getComponents()) {</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">            if (c instanceof FrameEditorPaneTag</span>
                &amp;&amp; c instanceof JEditorPane ) { //it should be always JEditorPane
<span class="nc" id="L222">                list.add((JEditorPane) c);</span>
            } else {
<span class="nc bnc" id="L224" title="All 2 branches missed.">                if (c instanceof Container) {</span>
<span class="nc" id="L225">                    getFrames((Container) c, list);</span>
                }
            }
        }
<span class="nc" id="L229">    }</span>

    /**
     * Triggers the frames creation for {@code JEditorPane}
     *
     * @param editor the {@code JEditorPane} to create frames for
     */
    private static void createFrames(final JEditorPane editor) {
<span class="nc" id="L237">        Runnable doCreateFrames =</span>
<span class="nc" id="L238">            new Runnable() {</span>
                public void run() {
                    final int WIDTH = 500;
                    final int HEIGHT = 500;
<span class="nc" id="L242">                    CellRendererPane rendererPane = new CellRendererPane();</span>
<span class="nc" id="L243">                    rendererPane.add(editor);</span>
                    //the values do not matter
                    //we only need to get frames created
<span class="nc" id="L246">                    rendererPane.setSize(WIDTH, HEIGHT);</span>
<span class="nc" id="L247">                };</span>
            };
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L250">            doCreateFrames.run();</span>
        } else {
            try {
<span class="nc" id="L253">                SwingUtilities.invokeAndWait(doCreateFrames);</span>
<span class="nc" id="L254">            } catch (Exception e) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                if (e instanceof RuntimeException) {</span>
<span class="nc" id="L256">                    throw (RuntimeException) e;</span>
                } else {
<span class="nc" id="L258">                    throw new RuntimeException(e);</span>
                }
<span class="nc" id="L260">            }</span>
        }
<span class="nc" id="L262">    }</span>

    /**
     * Constructs  {@code TextComponentPrintable} to print {@code JTextComponent}
     * {@code textComponent} with {@code headerFormat} and {@code footerFormat}.
     *
     * @param textComponent {@code JTextComponent} to print
     * @param headerFormat the page header or {@code null} for none
     * @param footerFormat the page footer or {@code null} for none
     */
    private TextComponentPrintable(JTextComponent textComponent,
            MessageFormat headerFormat,
<span class="nc" id="L274">            MessageFormat footerFormat) {</span>
<span class="nc" id="L275">        this.textComponentToPrint = textComponent;</span>
<span class="nc" id="L276">        this.headerFormat = headerFormat;</span>
<span class="nc" id="L277">        this.footerFormat = footerFormat;</span>
<span class="nc" id="L278">        headerFont = textComponent.getFont().deriveFont(Font.BOLD,</span>
            HEADER_FONT_SIZE);
<span class="nc" id="L280">        footerFont = textComponent.getFont().deriveFont(Font.PLAIN,</span>
            FOOTER_FONT_SIZE);
<span class="nc" id="L282">        this.pagesMetrics =</span>
<span class="nc" id="L283">            Collections.synchronizedList(new ArrayList&lt;IntegerSegment&gt;());</span>
<span class="nc" id="L284">        this.rowsMetrics = new ArrayList&lt;IntegerSegment&gt;(LIST_SIZE);</span>
<span class="nc" id="L285">        this.printShell = createPrintShell(textComponent);</span>
<span class="nc" id="L286">    }</span>


    /**
     * creates a printShell.
     * It creates closest text component to {@code textComponent}
     * which uses {@code frc} from the {@code TextComponentPrintable}
     * for the {@code getFontMetrics} method.
     *
     * @param textComponent {@code JTextComponent} to create a
     *        printShell for
     * @return the print shell
     */
    private JTextComponent createPrintShell(final JTextComponent textComponent) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L301">            return createPrintShellOnEDT(textComponent);</span>
        } else {
<span class="nc" id="L303">            FutureTask&lt;JTextComponent&gt; futureCreateShell =</span>
                new FutureTask&lt;JTextComponent&gt;(
<span class="nc" id="L305">                    new Callable&lt;JTextComponent&gt;() {</span>
                        public JTextComponent call() throws Exception {
<span class="nc" id="L307">                            return createPrintShellOnEDT(textComponent);</span>
                        }
                    });
<span class="nc" id="L310">            SwingUtilities.invokeLater(futureCreateShell);</span>
            try {
<span class="nc" id="L312">                return futureCreateShell.get();</span>
<span class="nc" id="L313">            } catch (InterruptedException e) {</span>
<span class="nc" id="L314">                throw new RuntimeException(e);</span>
<span class="nc" id="L315">            } catch (ExecutionException e) {</span>
<span class="nc" id="L316">                Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">                if (cause instanceof Error) {</span>
<span class="nc" id="L318">                    throw (Error) cause;</span>
                }
<span class="nc bnc" id="L320" title="All 2 branches missed.">                if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L321">                    throw (RuntimeException) cause;</span>
                }
<span class="nc" id="L323">                throw new AssertionError(cause);</span>
            }
        }
    }
    private JTextComponent createPrintShellOnEDT(final JTextComponent textComponent) {
<span class="nc bnc" id="L328" title="All 4 branches missed.">        assert SwingUtilities.isEventDispatchThread();</span>

<span class="nc" id="L330">        JTextComponent ret = null;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (textComponent instanceof JPasswordField) {</span>
<span class="nc" id="L332">            ret =</span>
<span class="nc" id="L333">                new JPasswordField() {</span>
                    {
<span class="nc" id="L335">                        setEchoChar(((JPasswordField) textComponent).getEchoChar());</span>
<span class="nc" id="L336">                        setHorizontalAlignment(</span>
<span class="nc" id="L337">                            ((JTextField) textComponent).getHorizontalAlignment());</span>
<span class="nc" id="L338">                    }</span>
                    @Override
                    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L341" title="All 2 branches missed.">                        return (frc.get() == null)</span>
<span class="nc" id="L342">                            ? super.getFontMetrics(font)</span>
<span class="nc" id="L343">                            : FontDesignMetrics.getMetrics(font, frc.get());</span>
                    }
                };
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (textComponent instanceof JTextField) {</span>
<span class="nc" id="L347">            ret =</span>
<span class="nc" id="L348">                new JTextField() {</span>
                    {
<span class="nc" id="L350">                        setHorizontalAlignment(</span>
<span class="nc" id="L351">                            ((JTextField) textComponent).getHorizontalAlignment());</span>
<span class="nc" id="L352">                    }</span>
                    @Override
                    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L355" title="All 2 branches missed.">                        return (frc.get() == null)</span>
<span class="nc" id="L356">                            ? super.getFontMetrics(font)</span>
<span class="nc" id="L357">                            : FontDesignMetrics.getMetrics(font, frc.get());</span>
                    }
                };
<span class="nc bnc" id="L360" title="All 2 branches missed.">        } else if (textComponent instanceof JTextArea) {</span>
<span class="nc" id="L361">            ret =</span>
<span class="nc" id="L362">                new JTextArea() {</span>
                    {
<span class="nc" id="L364">                        JTextArea textArea = (JTextArea) textComponent;</span>
<span class="nc" id="L365">                        setLineWrap(textArea.getLineWrap());</span>
<span class="nc" id="L366">                        setWrapStyleWord(textArea.getWrapStyleWord());</span>
<span class="nc" id="L367">                        setTabSize(textArea.getTabSize());</span>
<span class="nc" id="L368">                    }</span>
                    @Override
                    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L371" title="All 2 branches missed.">                        return (frc.get() == null)</span>
<span class="nc" id="L372">                            ? super.getFontMetrics(font)</span>
<span class="nc" id="L373">                            : FontDesignMetrics.getMetrics(font, frc.get());</span>
                    }
                };
<span class="nc bnc" id="L376" title="All 2 branches missed.">        } else if (textComponent instanceof JTextPane) {</span>
<span class="nc" id="L377">            ret =</span>
<span class="nc" id="L378">                new JTextPane() {</span>
                    @Override
                    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">                        return (frc.get() == null)</span>
<span class="nc" id="L382">                            ? super.getFontMetrics(font)</span>
<span class="nc" id="L383">                            : FontDesignMetrics.getMetrics(font, frc.get());</span>
                    }
                    @Override
                    public EditorKit getEditorKit() {
<span class="nc bnc" id="L387" title="All 2 branches missed.">                        if (getDocument() == textComponent.getDocument()) {</span>
<span class="nc" id="L388">                            return ((JTextPane) textComponent).getEditorKit();</span>
                        } else {
<span class="nc" id="L390">                            return super.getEditorKit();</span>
                        }
                    }
                };
<span class="nc bnc" id="L394" title="All 2 branches missed.">        } else if (textComponent instanceof JEditorPane) {</span>
<span class="nc" id="L395">            ret =</span>
<span class="nc" id="L396">                new JEditorPane() {</span>
                    @Override
                    public FontMetrics getFontMetrics(Font font) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">                        return (frc.get() == null)</span>
<span class="nc" id="L400">                            ? super.getFontMetrics(font)</span>
<span class="nc" id="L401">                            : FontDesignMetrics.getMetrics(font, frc.get());</span>
                    }
                    @Override
                    public EditorKit getEditorKit() {
<span class="nc bnc" id="L405" title="All 2 branches missed.">                        if (getDocument() == textComponent.getDocument()) {</span>
<span class="nc" id="L406">                            return ((JEditorPane) textComponent).getEditorKit();</span>
                        } else {
<span class="nc" id="L408">                            return super.getEditorKit();</span>
                        }
                    }
                };
        }
        //want to occupy the whole width and height by text
<span class="nc" id="L414">        ret.setBorder(null);</span>

        //set properties from the component to print
<span class="nc" id="L417">        ret.setOpaque(textComponent.isOpaque());</span>
<span class="nc" id="L418">        ret.setEditable(textComponent.isEditable());</span>
<span class="nc" id="L419">        ret.setEnabled(textComponent.isEnabled());</span>
<span class="nc" id="L420">        ret.setFont(textComponent.getFont());</span>
<span class="nc" id="L421">        ret.setBackground(textComponent.getBackground());</span>
<span class="nc" id="L422">        ret.setForeground(textComponent.getForeground());</span>
<span class="nc" id="L423">        ret.setComponentOrientation(</span>
<span class="nc" id="L424">            textComponent.getComponentOrientation());</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (ret instanceof JEditorPane) {</span>
<span class="nc" id="L427">            ret.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,</span>
<span class="nc" id="L428">                textComponent.getClientProperty(</span>
                JEditorPane.HONOR_DISPLAY_PROPERTIES));
<span class="nc" id="L430">            ret.putClientProperty(JEditorPane.W3C_LENGTH_UNITS,</span>
<span class="nc" id="L431">                textComponent.getClientProperty(JEditorPane.W3C_LENGTH_UNITS));</span>
<span class="nc" id="L432">            ret.putClientProperty(&quot;charset&quot;,</span>
<span class="nc" id="L433">                textComponent.getClientProperty(&quot;charset&quot;));</span>
        }
<span class="nc" id="L435">        ret.setDocument(textComponent.getDocument());</span>
<span class="nc" id="L436">        return ret;</span>
    }




    /**
     * Returns the number of pages in this printable.
     * &lt;p&gt;
     * This number is defined only after {@code print} returns NO_SUCH_PAGE.
     *
     * @return the number of pages.
     */
    public int getNumberOfPages() {
<span class="nc" id="L450">        return pagesMetrics.size();</span>
    }

    /**
     * See Printable.print for the API description.
     *
     * There are two parts in the implementation.
     * First part (print) is to be called on the printing thread.
     * Second part (printOnEDT) is to be called on the EDT only.
     *
     * print triggers printOnEDT
     */
    public int print(final Graphics graphics,
            final PageFormat pf,
            final int pageIndex) throws PrinterException {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (!isLayouted) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (graphics instanceof Graphics2D) {</span>
<span class="nc" id="L467">                frc.set(((Graphics2D)graphics).getFontRenderContext());</span>
            }
<span class="nc" id="L469">            layout((int)Math.floor(pf.getImageableWidth()));</span>
<span class="nc" id="L470">            calculateRowsMetrics();</span>
        }
        int ret;
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (!SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L474">            Callable&lt;Integer&gt; doPrintOnEDT = new Callable&lt;Integer&gt;() {</span>
                public Integer call() throws Exception {
<span class="nc" id="L476">                    return printOnEDT(graphics, pf, pageIndex);</span>
                }
            };
<span class="nc" id="L479">            FutureTask&lt;Integer&gt; futurePrintOnEDT =</span>
                new FutureTask&lt;Integer&gt;(doPrintOnEDT);
<span class="nc" id="L481">            SwingUtilities.invokeLater(futurePrintOnEDT);</span>
            try {
<span class="nc" id="L483">                ret = futurePrintOnEDT.get();</span>
<span class="nc" id="L484">            } catch (InterruptedException e) {</span>
<span class="nc" id="L485">                throw new RuntimeException(e);</span>
<span class="nc" id="L486">            } catch (ExecutionException e) {</span>
<span class="nc" id="L487">                Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                if (cause instanceof PrinterException) {</span>
<span class="nc" id="L489">                    throw (PrinterException)cause;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                } else if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L491">                    throw (RuntimeException) cause;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                } else if (cause instanceof Error) {</span>
<span class="nc" id="L493">                    throw (Error) cause;</span>
                } else {
<span class="nc" id="L495">                    throw new RuntimeException(cause);</span>
                }
<span class="nc" id="L497">            }</span>
<span class="nc" id="L498">        } else {</span>
<span class="nc" id="L499">            ret = printOnEDT(graphics, pf, pageIndex);</span>
        }
<span class="nc" id="L501">        return ret;</span>
    }


    /**
     * The EDT part of the print method.
     *
     * This method is to be called on the EDT only. Layout should be done before
     * calling this method.
     */
    private int printOnEDT(final Graphics graphics,
            final PageFormat pf,
            final int pageIndex) throws PrinterException {
<span class="nc bnc" id="L514" title="All 4 branches missed.">        assert SwingUtilities.isEventDispatchThread();</span>
<span class="nc" id="L515">        Border border = BorderFactory.createEmptyBorder();</span>
        //handle header and footer
<span class="nc bnc" id="L517" title="All 4 branches missed.">        if (headerFormat != null || footerFormat != null) {</span>
            //Printable page enumeration is 0 base. We need 1 based.
<span class="nc" id="L519">            Object[] formatArg = new Object[]{Integer.valueOf(pageIndex + 1)};</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (headerFormat != null) {</span>
<span class="nc" id="L521">                border = new TitledBorder(border,</span>
<span class="nc" id="L522">                    headerFormat.format(formatArg),</span>
                    TitledBorder.CENTER, TitledBorder.ABOVE_TOP,
<span class="nc" id="L524">                    headerFont, printShell.getForeground());</span>
            }
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (footerFormat != null) {</span>
<span class="nc" id="L527">                border = new TitledBorder(border,</span>
<span class="nc" id="L528">                    footerFormat.format(formatArg),</span>
                    TitledBorder.CENTER, TitledBorder.BELOW_BOTTOM,
<span class="nc" id="L530">                    footerFont, printShell.getForeground());</span>
            }
        }
<span class="nc" id="L533">        Insets borderInsets = border.getBorderInsets(printShell);</span>
<span class="nc" id="L534">        updatePagesMetrics(pageIndex,</span>
<span class="nc" id="L535">            (int)Math.floor(pf.getImageableHeight()) - borderInsets.top</span>
                           - borderInsets.bottom);

<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (pagesMetrics.size() &lt;= pageIndex) {</span>
<span class="nc" id="L539">            return NO_SUCH_PAGE;</span>
        }

<span class="nc" id="L542">        Graphics2D g2d = (Graphics2D)graphics.create();</span>

<span class="nc" id="L544">        g2d.translate(pf.getImageableX(), pf.getImageableY());</span>
<span class="nc" id="L545">        border.paintBorder(printShell, g2d, 0, 0,</span>
<span class="nc" id="L546">            (int)Math.floor(pf.getImageableWidth()),</span>
<span class="nc" id="L547">            (int)Math.floor(pf.getImageableHeight()));</span>

<span class="nc" id="L549">        g2d.translate(0, borderInsets.top);</span>
        //want to clip only vertically
<span class="nc" id="L551">        Rectangle clip = new Rectangle(0, 0,</span>
<span class="nc" id="L552">            (int) pf.getWidth(),</span>
<span class="nc" id="L553">            pagesMetrics.get(pageIndex).end</span>
<span class="nc" id="L554">                - pagesMetrics.get(pageIndex).start + 1);</span>

<span class="nc" id="L556">        g2d.clip(clip);</span>
<span class="nc" id="L557">        int xStart = 0;</span>
<span class="nc" id="L558">        if (ComponentOrientation.RIGHT_TO_LEFT ==</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                printShell.getComponentOrientation()) {</span>
<span class="nc" id="L560">            xStart = (int) pf.getImageableWidth() - printShell.getWidth();</span>
        }
<span class="nc" id="L562">        g2d.translate(xStart, - pagesMetrics.get(pageIndex).start);</span>
<span class="nc" id="L563">        printShell.print(g2d);</span>

<span class="nc" id="L565">        g2d.dispose();</span>

<span class="nc" id="L567">        return Printable.PAGE_EXISTS;</span>
    }


<span class="nc" id="L571">    private boolean needReadLock = false;</span>

    /**
     * Tries to release document's readlock
     *
     * Note: Not to be called on the EDT.
     */
    private void releaseReadLock() {
<span class="nc bnc" id="L579" title="All 4 branches missed.">        assert ! SwingUtilities.isEventDispatchThread();</span>
<span class="nc" id="L580">        Document document = textComponentToPrint.getDocument();</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (document instanceof AbstractDocument) {</span>
            try {
<span class="nc" id="L583">                ((AbstractDocument) document).readUnlock();</span>
<span class="nc" id="L584">                needReadLock = true;</span>
<span class="nc" id="L585">            } catch (Error ignore) {</span>
                // readUnlock() might throw StateInvariantError
<span class="nc" id="L587">            }</span>
        }
<span class="nc" id="L589">    }</span>


    /**
     * Tries to acquire document's readLock if it was released
     * in releaseReadLock() method.
     *
     * Note: Not to be called on the EDT.
     */
    private void acquireReadLock() {
<span class="nc bnc" id="L599" title="All 4 branches missed.">        assert ! SwingUtilities.isEventDispatchThread();</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (needReadLock) {</span>
            try {
                /*
                 * wait until all the EDT events are processed
                 * some of the document changes are asynchronous
                 * we need to make sure we get the lock after those changes
                 */
<span class="nc" id="L607">                SwingUtilities.invokeAndWait(</span>
<span class="nc" id="L608">                    new Runnable() {</span>
                        public void run() {
<span class="nc" id="L610">                        }</span>
                    });
<span class="nc" id="L612">            } catch (InterruptedException ignore) {</span>
<span class="nc" id="L613">            } catch (java.lang.reflect.InvocationTargetException ignore) {</span>
<span class="nc" id="L614">            }</span>
<span class="nc" id="L615">            Document document = textComponentToPrint.getDocument();</span>
<span class="nc" id="L616">            ((AbstractDocument) document).readLock();</span>
<span class="nc" id="L617">            needReadLock = false;</span>
        }
<span class="nc" id="L619">    }</span>

    /**
     * Prepares {@code printShell} for printing.
     *
     * Sets properties from the component to print.
     * Sets width and FontRenderContext.
     *
     * Triggers Views creation for the printShell.
     *
     * There are two parts in the implementation.
     * First part (layout) is to be called on the printing thread.
     * Second part (layoutOnEDT) is to be called on the EDT only.
     *
     * {@code layout} triggers {@code layoutOnEDT}.
     *
     * @param width width to layout the text for
     */
    private void layout(final int width) {
<span class="nc bnc" id="L638" title="All 2 branches missed.">        if (!SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L639">            Callable&lt;Object&gt; doLayoutOnEDT = new Callable&lt;Object&gt;() {</span>
                public Object call() throws Exception {
<span class="nc" id="L641">                    layoutOnEDT(width);</span>
<span class="nc" id="L642">                    return null;</span>
                }
            };
<span class="nc" id="L645">            FutureTask&lt;Object&gt; futureLayoutOnEDT = new FutureTask&lt;Object&gt;(</span>
                doLayoutOnEDT);

            /*
             * We need to release document's readlock while printShell is
             * initializing
             */
<span class="nc" id="L652">            releaseReadLock();</span>
<span class="nc" id="L653">            SwingUtilities.invokeLater(futureLayoutOnEDT);</span>
            try {
<span class="nc" id="L655">                futureLayoutOnEDT.get();</span>
<span class="nc" id="L656">            } catch (InterruptedException e) {</span>
<span class="nc" id="L657">                throw new RuntimeException(e);</span>
<span class="nc" id="L658">            } catch (ExecutionException e) {</span>
<span class="nc" id="L659">                Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if (cause instanceof RuntimeException) {</span>
<span class="nc" id="L661">                    throw (RuntimeException) cause;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                } else if (cause instanceof Error) {</span>
<span class="nc" id="L663">                    throw (Error) cause;</span>
                } else {
<span class="nc" id="L665">                    throw new RuntimeException(cause);</span>
                }
            } finally {
<span class="nc" id="L668">                acquireReadLock();</span>
<span class="nc" id="L669">            }</span>
<span class="nc" id="L670">        } else {</span>
<span class="nc" id="L671">            layoutOnEDT(width);</span>
        }

<span class="nc" id="L674">        isLayouted = true;</span>
<span class="nc" id="L675">    }</span>

    /**
     * The EDT part of layout method.
     *
     * This method is to be called on the EDT only.
     */
    private void layoutOnEDT(final int width) {
<span class="nc bnc" id="L683" title="All 4 branches missed.">        assert SwingUtilities.isEventDispatchThread();</span>
        //need to have big value but smaller than MAX_VALUE otherwise
        //printing goes south due to overflow somewhere
        final int HUGE_INTEGER = Integer.MAX_VALUE - 1000;

<span class="nc" id="L688">        CellRendererPane rendererPane = new CellRendererPane();</span>

        //need to use JViewport since text is layouted to the viewPort width
        //otherwise it will be layouted to the maximum text width
<span class="nc" id="L692">        JViewport viewport = new JViewport();</span>
<span class="nc" id="L693">        viewport.setBorder(null);</span>
<span class="nc" id="L694">        Dimension size = new Dimension(width, HUGE_INTEGER);</span>

        //JTextField is a special case
        //it layouts text in the middle by Y
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (printShell instanceof JTextField) {</span>
<span class="nc" id="L699">            size =</span>
<span class="nc" id="L700">                new Dimension(size.width, printShell.getPreferredSize().height);</span>
        }
<span class="nc" id="L702">        printShell.setSize(size);</span>
<span class="nc" id="L703">        viewport.setComponentOrientation(printShell.getComponentOrientation());</span>
<span class="nc" id="L704">        viewport.setSize(size);</span>
<span class="nc" id="L705">        viewport.add(printShell);</span>
<span class="nc" id="L706">        rendererPane.add(viewport);</span>
<span class="nc" id="L707">    }</span>

    /**
     * Calculates pageMetrics for the pages up to the {@code pageIndex} using
     * {@code rowsMetrics}.
     * Metrics are stored in the {@code pagesMetrics}.
     *
     * @param pageIndex the page to update the metrics for
     * @param pageHeight the page height
     */
    private void updatePagesMetrics(final int pageIndex, final int pageHeight) {
<span class="nc bnc" id="L718" title="All 4 branches missed.">        while (pageIndex &gt;= pagesMetrics.size() &amp;&amp; !rowsMetrics.isEmpty()) {</span>
            // add one page to the pageMetrics
<span class="nc" id="L720">            int lastPage = pagesMetrics.size() - 1;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">            int pageStart = (lastPage &gt;= 0)</span>
<span class="nc" id="L722">               ? pagesMetrics.get(lastPage).end + 1</span>
               : 0;
            int rowIndex;
<span class="nc" id="L725">            for (rowIndex = 0;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                   rowIndex &lt; rowsMetrics.size()</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                   &amp;&amp; (rowsMetrics.get(rowIndex).end - pageStart + 1)</span>
                     &lt;= pageHeight;
<span class="nc" id="L729">                   rowIndex++) {</span>
            }
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if (rowIndex == 0) {</span>
                // can not fit a single row
                // need to split
<span class="nc" id="L734">                pagesMetrics.add(</span>
                    new IntegerSegment(pageStart, pageStart + pageHeight - 1));
            } else {
<span class="nc" id="L737">                rowIndex--;</span>
<span class="nc" id="L738">                pagesMetrics.add(new IntegerSegment(pageStart,</span>
<span class="nc" id="L739">                    rowsMetrics.get(rowIndex).end));</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                for (int i = 0; i &lt;= rowIndex; i++) {</span>
<span class="nc" id="L741">                    rowsMetrics.remove(0);</span>
                }
            }
<span class="nc" id="L744">        }</span>
<span class="nc" id="L745">    }</span>

    /**
     * Calculates rowsMetrics for the document. The result is stored
     * in the {@code rowsMetrics}.
     *
     * Two steps process.
     * First step is to find yStart and yEnd for the every document position.
     * Second step is to merge all intersected segments ( [yStart, yEnd] ).
     */
    private void calculateRowsMetrics() {
<span class="nc" id="L756">        final int documentLength = printShell.getDocument().getLength();</span>
<span class="nc" id="L757">        List&lt;IntegerSegment&gt; documentMetrics = new ArrayList&lt;IntegerSegment&gt;(LIST_SIZE);</span>
        Rectangle rect;
<span class="nc bnc" id="L759" title="All 2 branches missed.">        for (int i = 0, previousY = -1, previousHeight = -1; i &lt; documentLength;</span>
<span class="nc" id="L760">                 i++) {</span>
            try {
<span class="nc" id="L762">                rect = printShell.modelToView(i);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                if (rect != null) {</span>
<span class="nc" id="L764">                    int y = (int) rect.getY();</span>
<span class="nc" id="L765">                    int height = (int) rect.getHeight();</span>
<span class="nc bnc" id="L766" title="All 6 branches missed.">                    if (height != 0</span>
                            &amp;&amp; (y != previousY || height != previousHeight)) {
                        /*
                         * we do not store the same value as previous. in our
                         * documents it is often for consequent positons to have
                         * the same modelToView y and height.
                         */
<span class="nc" id="L773">                        previousY = y;</span>
<span class="nc" id="L774">                        previousHeight = height;</span>
<span class="nc" id="L775">                        documentMetrics.add(new IntegerSegment(y, y + height - 1));</span>
                    }
                }
<span class="nc" id="L778">            } catch (BadLocationException e) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                assert false;</span>
<span class="nc" id="L780">            }</span>
        }
        /*
         * Merge all intersected segments.
         */
<span class="nc" id="L785">        Collections.sort(documentMetrics);</span>
<span class="nc" id="L786">        int yStart = Integer.MIN_VALUE;</span>
<span class="nc" id="L787">        int yEnd = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">        for (IntegerSegment segment : documentMetrics) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (yEnd &lt; segment.start) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                if (yEnd != Integer.MIN_VALUE) {</span>
<span class="nc" id="L791">                    rowsMetrics.add(new IntegerSegment(yStart, yEnd));</span>
                }
<span class="nc" id="L793">                yStart = segment.start;</span>
<span class="nc" id="L794">                yEnd = segment.end;</span>
            } else {
<span class="nc" id="L796">                yEnd = segment.end;</span>
            }
<span class="nc" id="L798">        }</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (yEnd != Integer.MIN_VALUE) {</span>
<span class="nc" id="L800">            rowsMetrics.add(new IntegerSegment(yStart, yEnd));</span>
        }
<span class="nc" id="L802">    }</span>

    /**
     *  Class to represent segment of integers.
     *  we do not call it Segment to avoid confusion with
     *  javax.swing.text.Segment
     */
    private static class IntegerSegment implements Comparable&lt;IntegerSegment&gt; {
        final int start;
        final int end;

<span class="nc" id="L813">        IntegerSegment(int start, int end) {</span>
<span class="nc" id="L814">            this.start = start;</span>
<span class="nc" id="L815">            this.end = end;</span>
<span class="nc" id="L816">        }</span>

        public int compareTo(IntegerSegment object) {
<span class="nc" id="L819">            int startsDelta = start - object.start;</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            return (startsDelta != 0) ? startsDelta : end - object.end;</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">            if (obj instanceof IntegerSegment) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                return compareTo((IntegerSegment) obj) == 0;</span>
            } else {
<span class="nc" id="L828">                return false;</span>
            }
        }

        @Override
        public int hashCode() {
            // from the &quot;Effective Java: Programming Language Guide&quot;
<span class="nc" id="L835">            int result = 17;</span>
<span class="nc" id="L836">            result = 37 * result + start;</span>
<span class="nc" id="L837">            result = 37 * result + end;</span>
<span class="nc" id="L838">            return result;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L843">            return &quot;IntegerSegment [&quot; + start + &quot;, &quot; + end + &quot;]&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>