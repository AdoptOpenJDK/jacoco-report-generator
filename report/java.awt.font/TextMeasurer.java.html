<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextMeasurer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.font</a> &gt; <span class="el_source">TextMeasurer.java</span></div><h1>TextMeasurer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright Taligent, Inc. 1996 - 1997, All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 1998, All Rights Reserved
 *
 * The original version of this source code and documentation is
 * copyrighted and owned by Taligent, Inc., a wholly-owned subsidiary
 * of IBM. These materials are provided under terms of a License
 * Agreement between Taligent and Sun. This technology is protected
 * by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 *
 */

package java.awt.font;

import java.awt.Font;

import java.text.AttributedCharacterIterator;
import java.text.AttributedCharacterIterator.Attribute;
import java.text.AttributedString;
import java.text.Bidi;
import java.text.BreakIterator;
import java.text.CharacterIterator;

import java.awt.font.FontRenderContext;

import java.util.Hashtable;
import java.util.Map;

import sun.font.AttributeValues;
import sun.font.BidiUtils;
import sun.font.TextLineComponent;
import sun.font.TextLabelFactory;
import sun.font.FontResolver;

/**
 * The &lt;code&gt;TextMeasurer&lt;/code&gt; class provides the primitive operations
 * needed for line break: measuring up to a given advance, determining the
 * advance of a range of characters, and generating a
 * &lt;code&gt;TextLayout&lt;/code&gt; for a range of characters. It also provides
 * methods for incremental editing of paragraphs.
 * &lt;p&gt;
 * A &lt;code&gt;TextMeasurer&lt;/code&gt; object is constructed with an
 * {@link java.text.AttributedCharacterIterator AttributedCharacterIterator}
 * representing a single paragraph of text.  The value returned by the
 * {@link AttributedCharacterIterator#getBeginIndex() getBeginIndex}
 * method of &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
 * defines the absolute index of the first character.  The value
 * returned by the
 * {@link AttributedCharacterIterator#getEndIndex() getEndIndex}
 * method of &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; defines the index
 * past the last character.  These values define the range of indexes to
 * use in calls to the &lt;code&gt;TextMeasurer&lt;/code&gt;.  For example, calls to
 * get the advance of a range of text or the line break of a range of text
 * must use indexes between the beginning and end index values.  Calls to
 * {@link #insertChar(java.text.AttributedCharacterIterator, int) insertChar}
 * and
 * {@link #deleteChar(java.text.AttributedCharacterIterator, int) deleteChar}
 * reset the &lt;code&gt;TextMeasurer&lt;/code&gt; to use the beginning index and end
 * index of the &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; passed in those calls.
 * &lt;p&gt;
 * Most clients will use the more convenient &lt;code&gt;LineBreakMeasurer&lt;/code&gt;,
 * which implements the standard line break policy (placing as many words
 * as will fit on each line).
 *
 * @author John Raley
 * @see LineBreakMeasurer
 * @since 1.3
 */

public final class TextMeasurer implements Cloneable {

    // Number of lines to format to.
<span class="nc" id="L101">    private static float EST_LINES = (float) 2.1;</span>

    /*
    static {
        String s = System.getProperty(&quot;estLines&quot;);
        if (s != null) {
            try {
                Float f = new Float(s);
                EST_LINES = f.floatValue();
            }
            catch(NumberFormatException e) {
            }
        }
        //System.out.println(&quot;EST_LINES=&quot;+EST_LINES);
    }
    */

    private FontRenderContext fFrc;

    private int fStart;

    // characters in source text
    private char[] fChars;

    // Bidi for this paragraph
    private Bidi fBidi;

    // Levels array for chars in this paragraph - needed to reorder
    // trailing counterdirectional whitespace
    private byte[] fLevels;

    // line components in logical order
    private TextLineComponent[] fComponents;

    // index where components begin
    private int fComponentStart;

    // index where components end
    private int fComponentLimit;

    private boolean haveLayoutWindow;

    // used to find valid starting points for line components
<span class="nc" id="L144">    private BreakIterator fLineBreak = null;</span>
<span class="nc" id="L145">    private CharArrayIterator charIter = null;</span>
<span class="nc" id="L146">    int layoutCount = 0;</span>
<span class="nc" id="L147">    int layoutCharCount = 0;</span>

    // paragraph, with resolved fonts and styles
    private StyledParagraph fParagraph;

    // paragraph data - same across all layouts
    private boolean fIsDirectionLTR;
    private byte fBaseline;
    private float[] fBaselineOffsets;
<span class="nc" id="L156">    private float fJustifyRatio = 1;</span>

    /**
     * Constructs a &lt;code&gt;TextMeasurer&lt;/code&gt; from the source text.
     * The source text should be a single entire paragraph.
     * @param text the source paragraph.  Cannot be null.
     * @param frc the information about a graphics device which is needed
     *       to measure the text correctly.  Cannot be null.
     */
<span class="nc" id="L165">    public TextMeasurer(AttributedCharacterIterator text, FontRenderContext frc) {</span>

<span class="nc" id="L167">        fFrc = frc;</span>
<span class="nc" id="L168">        initAll(text);</span>
<span class="nc" id="L169">    }</span>

    protected Object clone() {
        TextMeasurer other;
        try {
<span class="nc" id="L174">            other = (TextMeasurer) super.clone();</span>
        }
<span class="nc" id="L176">        catch(CloneNotSupportedException e) {</span>
<span class="nc" id="L177">            throw new Error();</span>
<span class="nc" id="L178">        }</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (fComponents != null) {</span>
<span class="nc" id="L180">            other.fComponents = fComponents.clone();</span>
        }
<span class="nc" id="L182">        return other;</span>
    }

    private void invalidateComponents() {
<span class="nc" id="L186">        fComponentStart = fComponentLimit = fChars.length;</span>
<span class="nc" id="L187">        fComponents = null;</span>
<span class="nc" id="L188">        haveLayoutWindow = false;</span>
<span class="nc" id="L189">    }</span>

    /**
     * Initialize state, including fChars array, direction, and
     * fBidi.
     */
    private void initAll(AttributedCharacterIterator text) {

<span class="nc" id="L197">        fStart = text.getBeginIndex();</span>

        // extract chars
<span class="nc" id="L200">        fChars = new char[text.getEndIndex() - fStart];</span>

<span class="nc" id="L202">        int n = 0;</span>
<span class="nc" id="L203">        for (char c = text.first();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">             c != CharacterIterator.DONE;</span>
<span class="nc" id="L205">             c = text.next())</span>
        {
<span class="nc" id="L207">            fChars[n++] = c;</span>
        }

<span class="nc" id="L210">        text.first();</span>

<span class="nc" id="L212">        fBidi = new Bidi(text);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (fBidi.isLeftToRight()) {</span>
<span class="nc" id="L214">            fBidi = null;</span>
        }

<span class="nc" id="L217">        text.first();</span>
<span class="nc" id="L218">        Map&lt;? extends Attribute, ?&gt; paragraphAttrs = text.getAttributes();</span>
<span class="nc" id="L219">        NumericShaper shaper = AttributeValues.getNumericShaping(paragraphAttrs);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (shaper != null) {</span>
<span class="nc" id="L221">            shaper.shape(fChars, 0, fChars.length);</span>
        }

<span class="nc" id="L224">        fParagraph = new StyledParagraph(text, fChars);</span>

        // set paragraph attributes
        {
            // If there's an embedded graphic at the start of the
            // paragraph, look for the first non-graphic character
            // and use it and its font to initialize the paragraph.
            // If not, use the first graphic to initialize.
<span class="nc" id="L232">            fJustifyRatio = AttributeValues.getJustification(paragraphAttrs);</span>

<span class="nc" id="L234">            boolean haveFont = TextLine.advanceToFirstFont(text);</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (haveFont) {</span>
<span class="nc" id="L237">                Font defaultFont = TextLine.getFontAtCurrentPos(text);</span>
<span class="nc" id="L238">                int charsStart = text.getIndex() - text.getBeginIndex();</span>
<span class="nc" id="L239">                LineMetrics lm = defaultFont.getLineMetrics(fChars, charsStart, charsStart+1, fFrc);</span>
<span class="nc" id="L240">                fBaseline = (byte) lm.getBaselineIndex();</span>
<span class="nc" id="L241">                fBaselineOffsets = lm.getBaselineOffsets();</span>
<span class="nc" id="L242">            }</span>
            else {
                // hmmm what to do here?  Just try to supply reasonable
                // values I guess.

<span class="nc" id="L247">                GraphicAttribute graphic = (GraphicAttribute)</span>
<span class="nc" id="L248">                                paragraphAttrs.get(TextAttribute.CHAR_REPLACEMENT);</span>
<span class="nc" id="L249">                fBaseline = TextLayout.getBaselineFromGraphic(graphic);</span>
<span class="nc" id="L250">                Hashtable&lt;Attribute, ?&gt; fmap = new Hashtable&lt;&gt;(5, (float)0.9);</span>
<span class="nc" id="L251">                Font dummyFont = new Font(fmap);</span>
<span class="nc" id="L252">                LineMetrics lm = dummyFont.getLineMetrics(&quot; &quot;, 0, 1, fFrc);</span>
<span class="nc" id="L253">                fBaselineOffsets = lm.getBaselineOffsets();</span>
            }
<span class="nc" id="L255">            fBaselineOffsets = TextLine.getNormalizedOffsets(fBaselineOffsets, fBaseline);</span>
        }

<span class="nc" id="L258">        invalidateComponents();</span>
<span class="nc" id="L259">    }</span>

    /**
     * Generate components for the paragraph.  fChars, fBidi should have been
     * initialized already.
     */
    private void generateComponents(int startingAt, int endingAt) {

<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (collectStats) {</span>
<span class="nc" id="L268">            formattedChars += (endingAt-startingAt);</span>
        }
<span class="nc" id="L270">        int layoutFlags = 0; // no extra info yet, bidi determines run and line direction</span>
<span class="nc" id="L271">        TextLabelFactory factory = new TextLabelFactory(fFrc, fChars, fBidi, layoutFlags);</span>

<span class="nc" id="L273">        int[] charsLtoV = null;</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (fBidi != null) {</span>
<span class="nc" id="L276">            fLevels = BidiUtils.getLevels(fBidi);</span>
<span class="nc" id="L277">            int[] charsVtoL = BidiUtils.createVisualToLogicalMap(fLevels);</span>
<span class="nc" id="L278">            charsLtoV = BidiUtils.createInverseMap(charsVtoL);</span>
<span class="nc" id="L279">            fIsDirectionLTR = fBidi.baseIsLeftToRight();</span>
<span class="nc" id="L280">        }</span>
        else {
<span class="nc" id="L282">            fLevels = null;</span>
<span class="nc" id="L283">            fIsDirectionLTR = true;</span>
        }

        try {
<span class="nc" id="L287">            fComponents = TextLine.getComponents(</span>
                fParagraph, fChars, startingAt, endingAt, charsLtoV, fLevels, factory);
        }
<span class="nc" id="L290">        catch(IllegalArgumentException e) {</span>
<span class="nc" id="L291">            System.out.println(&quot;startingAt=&quot;+startingAt+&quot;; endingAt=&quot;+endingAt);</span>
<span class="nc" id="L292">            System.out.println(&quot;fComponentLimit=&quot;+fComponentLimit);</span>
<span class="nc" id="L293">            throw e;</span>
<span class="nc" id="L294">        }</span>

<span class="nc" id="L296">        fComponentStart = startingAt;</span>
<span class="nc" id="L297">        fComponentLimit = endingAt;</span>
        //debugFormatCount += (endingAt-startingAt);
<span class="nc" id="L299">    }</span>

    private int calcLineBreak(final int pos, final float maxAdvance) {

        // either of these statements removes the bug:
        //generateComponents(0, fChars.length);
        //generateComponents(pos, fChars.length);

<span class="nc" id="L307">        int startPos = pos;</span>
<span class="nc" id="L308">        float width = maxAdvance;</span>

        int tlcIndex;
<span class="nc" id="L311">        int tlcStart = fComponentStart;</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">        for (tlcIndex = 0; tlcIndex &lt; fComponents.length; tlcIndex++) {</span>
<span class="nc" id="L314">            int gaLimit = tlcStart + fComponents[tlcIndex].getNumCharacters();</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (gaLimit &gt; startPos) {</span>
<span class="nc" id="L316">                break;</span>
            }
            else {
<span class="nc" id="L319">                tlcStart = gaLimit;</span>
            }
        }

        // tlcStart is now the start of the tlc at tlcIndex

<span class="nc bnc" id="L325" title="All 2 branches missed.">        for (; tlcIndex &lt; fComponents.length; tlcIndex++) {</span>

<span class="nc" id="L327">            TextLineComponent tlc = fComponents[tlcIndex];</span>
<span class="nc" id="L328">            int numCharsInGa = tlc.getNumCharacters();</span>

<span class="nc" id="L330">            int lineBreak = tlc.getLineBreakIndex(startPos - tlcStart, width);</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">            if (lineBreak == numCharsInGa &amp;&amp; tlcIndex &lt; fComponents.length) {</span>
<span class="nc" id="L332">                width -= tlc.getAdvanceBetween(startPos - tlcStart, lineBreak);</span>
<span class="nc" id="L333">                tlcStart += numCharsInGa;</span>
<span class="nc" id="L334">                startPos = tlcStart;</span>
            }
            else {
<span class="nc" id="L337">                return tlcStart + lineBreak;</span>
            }
        }

<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (fComponentLimit &lt; fChars.length) {</span>
            // format more text and try again
            //if (haveLayoutWindow) {
            //    outOfWindow++;
            //}

<span class="nc" id="L347">            generateComponents(pos, fChars.length);</span>
<span class="nc" id="L348">            return calcLineBreak(pos, maxAdvance);</span>
        }

<span class="nc" id="L351">        return fChars.length;</span>
    }

    /**
     * According to the Unicode Bidirectional Behavior specification
     * (Unicode Standard 2.0, section 3.11), whitespace at the ends
     * of lines which would naturally flow against the base direction
     * must be made to flow with the line direction, and moved to the
     * end of the line.  This method returns the start of the sequence
     * of trailing whitespace characters to move to the end of a
     * line taken from the given range.
     */
    private int trailingCdWhitespaceStart(int startPos, int limitPos) {

<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (fLevels != null) {</span>
            // Back up over counterdirectional whitespace
<span class="nc bnc" id="L367" title="All 2 branches missed.">            final byte baseLevel = (byte) (fIsDirectionLTR? 0 : 1);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            for (int cdWsStart = limitPos; --cdWsStart &gt;= startPos;) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if ((fLevels[cdWsStart] % 2) == baseLevel ||</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                        Character.getDirectionality(fChars[cdWsStart]) != Character.DIRECTIONALITY_WHITESPACE) {</span>
<span class="nc" id="L371">                    return ++cdWsStart;</span>
                }
            }
        }

<span class="nc" id="L376">        return startPos;</span>
    }

    private TextLineComponent[] makeComponentsOnRange(int startPos,
                                                      int limitPos) {

        // sigh I really hate to do this here since it's part of the
        // bidi algorithm.
        // cdWsStart is the start of the trailing counterdirectional
        // whitespace
<span class="nc" id="L386">        final int cdWsStart = trailingCdWhitespaceStart(startPos, limitPos);</span>

        int tlcIndex;
<span class="nc" id="L389">        int tlcStart = fComponentStart;</span>

<span class="nc bnc" id="L391" title="All 2 branches missed.">        for (tlcIndex = 0; tlcIndex &lt; fComponents.length; tlcIndex++) {</span>
<span class="nc" id="L392">            int gaLimit = tlcStart + fComponents[tlcIndex].getNumCharacters();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if (gaLimit &gt; startPos) {</span>
<span class="nc" id="L394">                break;</span>
            }
            else {
<span class="nc" id="L397">                tlcStart = gaLimit;</span>
            }
        }

        // tlcStart is now the start of the tlc at tlcIndex

        int componentCount;
        {
<span class="nc" id="L405">            boolean split = false;</span>
<span class="nc" id="L406">            int compStart = tlcStart;</span>
<span class="nc" id="L407">            int lim=tlcIndex;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            for (boolean cont=true; cont; lim++) {</span>
<span class="nc" id="L409">                int gaLimit = compStart + fComponents[lim].getNumCharacters();</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                if (cdWsStart &gt; Math.max(compStart, startPos)</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                            &amp;&amp; cdWsStart &lt; Math.min(gaLimit, limitPos)) {</span>
<span class="nc" id="L412">                    split = true;</span>
                }
<span class="nc bnc" id="L414" title="All 2 branches missed.">                if (gaLimit &gt;= limitPos) {</span>
<span class="nc" id="L415">                    cont=false;</span>
                }
                else {
<span class="nc" id="L418">                    compStart = gaLimit;</span>
                }
            }
<span class="nc" id="L421">            componentCount = lim-tlcIndex;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (split) {</span>
<span class="nc" id="L423">                componentCount++;</span>
            }
        }

<span class="nc" id="L427">        TextLineComponent[] components = new TextLineComponent[componentCount];</span>
<span class="nc" id="L428">        int newCompIndex = 0;</span>
<span class="nc" id="L429">        int linePos = startPos;</span>

<span class="nc" id="L431">        int breakPt = cdWsStart;</span>

        int subsetFlag;
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (breakPt == startPos) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            subsetFlag = fIsDirectionLTR? TextLineComponent.LEFT_TO_RIGHT :</span>
                                          TextLineComponent.RIGHT_TO_LEFT;
<span class="nc" id="L437">            breakPt = limitPos;</span>
        }
        else {
<span class="nc" id="L440">            subsetFlag = TextLineComponent.UNCHANGED;</span>
        }

<span class="nc bnc" id="L443" title="All 2 branches missed.">        while (linePos &lt; limitPos) {</span>

<span class="nc" id="L445">            int compLength = fComponents[tlcIndex].getNumCharacters();</span>
<span class="nc" id="L446">            int tlcLimit = tlcStart + compLength;</span>

<span class="nc" id="L448">            int start = Math.max(linePos, tlcStart);</span>
<span class="nc" id="L449">            int limit = Math.min(breakPt, tlcLimit);</span>

<span class="nc" id="L451">            components[newCompIndex++] = fComponents[tlcIndex].getSubset(</span>
                                                                start-tlcStart,
                                                                limit-tlcStart,
                                                                subsetFlag);
<span class="nc" id="L455">            linePos += (limit-start);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (linePos == breakPt) {</span>
<span class="nc" id="L457">                breakPt = limitPos;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                subsetFlag = fIsDirectionLTR? TextLineComponent.LEFT_TO_RIGHT :</span>
                                              TextLineComponent.RIGHT_TO_LEFT;
            }
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (linePos == tlcLimit) {</span>
<span class="nc" id="L462">                tlcIndex++;</span>
<span class="nc" id="L463">                tlcStart = tlcLimit;</span>
            }
<span class="nc" id="L465">        }</span>

<span class="nc" id="L467">        return components;</span>
    }

    private TextLine makeTextLineOnRange(int startPos, int limitPos) {

<span class="nc" id="L472">        int[] charsLtoV = null;</span>
<span class="nc" id="L473">        byte[] charLevels = null;</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (fBidi != null) {</span>
<span class="nc" id="L476">            Bidi lineBidi = fBidi.createLineBidi(startPos, limitPos);</span>
<span class="nc" id="L477">            charLevels = BidiUtils.getLevels(lineBidi);</span>
<span class="nc" id="L478">            int[] charsVtoL = BidiUtils.createVisualToLogicalMap(charLevels);</span>
<span class="nc" id="L479">            charsLtoV = BidiUtils.createInverseMap(charsVtoL);</span>
        }

<span class="nc" id="L482">        TextLineComponent[] components = makeComponentsOnRange(startPos, limitPos);</span>

<span class="nc" id="L484">        return new TextLine(fFrc,</span>
                            components,
                            fBaselineOffsets,
                            fChars,
                            startPos,
                            limitPos,
                            charsLtoV,
                            charLevels,
                            fIsDirectionLTR);

    }

    private void ensureComponents(int start, int limit) {

<span class="nc bnc" id="L498" title="All 4 branches missed.">        if (start &lt; fComponentStart || limit &gt; fComponentLimit) {</span>
<span class="nc" id="L499">            generateComponents(start, limit);</span>
        }
<span class="nc" id="L501">    }</span>

    private void makeLayoutWindow(int localStart) {

<span class="nc" id="L505">        int compStart = localStart;</span>
<span class="nc" id="L506">        int compLimit = fChars.length;</span>

        // If we've already gone past the layout window, format to end of paragraph
<span class="nc bnc" id="L509" title="All 4 branches missed.">        if (layoutCount &gt; 0 &amp;&amp; !haveLayoutWindow) {</span>
<span class="nc" id="L510">            float avgLineLength = Math.max(layoutCharCount / layoutCount, 1);</span>
<span class="nc" id="L511">            compLimit = Math.min(localStart + (int)(avgLineLength*EST_LINES), fChars.length);</span>
        }

<span class="nc bnc" id="L514" title="All 4 branches missed.">        if (localStart &gt; 0 || compLimit &lt; fChars.length) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (charIter == null) {</span>
<span class="nc" id="L516">                charIter = new CharArrayIterator(fChars);</span>
            }
            else {
<span class="nc" id="L519">                charIter.reset(fChars);</span>
            }
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (fLineBreak == null) {</span>
<span class="nc" id="L522">                fLineBreak = BreakIterator.getLineInstance();</span>
            }
<span class="nc" id="L524">            fLineBreak.setText(charIter);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (localStart &gt; 0) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                if (!fLineBreak.isBoundary(localStart)) {</span>
<span class="nc" id="L527">                    compStart = fLineBreak.preceding(localStart);</span>
                }
            }
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (compLimit &lt; fChars.length) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                if (!fLineBreak.isBoundary(compLimit)) {</span>
<span class="nc" id="L532">                    compLimit = fLineBreak.following(compLimit);</span>
                }
            }
        }

<span class="nc" id="L537">        ensureComponents(compStart, compLimit);</span>
<span class="nc" id="L538">        haveLayoutWindow = true;</span>
<span class="nc" id="L539">    }</span>

    /**
     * Returns the index of the first character which will not fit on
     * on a line beginning at &lt;code&gt;start&lt;/code&gt; and possible
     * measuring up to &lt;code&gt;maxAdvance&lt;/code&gt; in graphical width.
     *
     * @param start the character index at which to start measuring.
     *  &lt;code&gt;start&lt;/code&gt; is an absolute index, not relative to the
     *  start of the paragraph
     * @param maxAdvance the graphical width in which the line must fit
     * @return the index after the last character that will fit
     *  on a line beginning at &lt;code&gt;start&lt;/code&gt;, which is not longer
     *  than &lt;code&gt;maxAdvance&lt;/code&gt; in graphical width
     * @throws IllegalArgumentException if &lt;code&gt;start&lt;/code&gt; is
     *          less than the beginning of the paragraph.
     */
    public int getLineBreakIndex(int start, float maxAdvance) {

<span class="nc" id="L558">        int localStart = start - fStart;</span>

<span class="nc bnc" id="L560" title="All 6 branches missed.">        if (!haveLayoutWindow ||</span>
                localStart &lt; fComponentStart ||
                localStart &gt;= fComponentLimit) {
<span class="nc" id="L563">            makeLayoutWindow(localStart);</span>
        }

<span class="nc" id="L566">        return calcLineBreak(localStart, maxAdvance) + fStart;</span>
    }

    /**
     * Returns the graphical width of a line beginning at &lt;code&gt;start&lt;/code&gt;
     * and including characters up to &lt;code&gt;limit&lt;/code&gt;.
     * &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;limit&lt;/code&gt; are absolute indices,
     * not relative to the start of the paragraph.
     *
     * @param start the character index at which to start measuring
     * @param limit the character index at which to stop measuring
     * @return the graphical width of a line beginning at &lt;code&gt;start&lt;/code&gt;
     *   and including characters up to &lt;code&gt;limit&lt;/code&gt;
     * @throws IndexOutOfBoundsException if &lt;code&gt;limit&lt;/code&gt; is less
     *         than &lt;code&gt;start&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;start&lt;/code&gt; or
     *          &lt;code&gt;limit&lt;/code&gt; is not between the beginning of
     *          the paragraph and the end of the paragraph.
     */
    public float getAdvanceBetween(int start, int limit) {

<span class="nc" id="L587">        int localStart = start - fStart;</span>
<span class="nc" id="L588">        int localLimit = limit - fStart;</span>

<span class="nc" id="L590">        ensureComponents(localStart, localLimit);</span>
<span class="nc" id="L591">        TextLine line = makeTextLineOnRange(localStart, localLimit);</span>
<span class="nc" id="L592">        return line.getMetrics().advance;</span>
        // could cache line in case getLayout is called with same start, limit
    }

    /**
     * Returns a &lt;code&gt;TextLayout&lt;/code&gt; on the given character range.
     *
     * @param start the index of the first character
     * @param limit the index after the last character.  Must be greater
     *   than &lt;code&gt;start&lt;/code&gt;
     * @return a &lt;code&gt;TextLayout&lt;/code&gt; for the characters beginning at
     *  &lt;code&gt;start&lt;/code&gt; up to (but not including) &lt;code&gt;limit&lt;/code&gt;
     * @throws IndexOutOfBoundsException if &lt;code&gt;limit&lt;/code&gt; is less
     *         than &lt;code&gt;start&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;start&lt;/code&gt; or
     *          &lt;code&gt;limit&lt;/code&gt; is not between the beginning of
     *          the paragraph and the end of the paragraph.
     */
    public TextLayout getLayout(int start, int limit) {

<span class="nc" id="L612">        int localStart = start - fStart;</span>
<span class="nc" id="L613">        int localLimit = limit - fStart;</span>

<span class="nc" id="L615">        ensureComponents(localStart, localLimit);</span>
<span class="nc" id="L616">        TextLine textLine = makeTextLineOnRange(localStart, localLimit);</span>

<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (localLimit &lt; fChars.length) {</span>
<span class="nc" id="L619">            layoutCharCount += limit-start;</span>
<span class="nc" id="L620">            layoutCount++;</span>
        }

<span class="nc" id="L623">        return new TextLayout(textLine,</span>
                              fBaseline,
                              fBaselineOffsets,
                              fJustifyRatio);
    }

<span class="nc" id="L629">    private int formattedChars = 0;</span>
<span class="nc" id="L630">    private static boolean wantStats = false;/*&quot;true&quot;.equals(System.getProperty(&quot;collectStats&quot;));*/</span>
<span class="nc" id="L631">    private boolean collectStats = false;</span>

    private void printStats() {
<span class="nc" id="L634">        System.out.println(&quot;formattedChars: &quot; + formattedChars);</span>
        //formattedChars = 0;
<span class="nc" id="L636">        collectStats = false;</span>
<span class="nc" id="L637">    }</span>

    /**
     * Updates the &lt;code&gt;TextMeasurer&lt;/code&gt; after a single character has
     * been inserted
     * into the paragraph currently represented by this
     * &lt;code&gt;TextMeasurer&lt;/code&gt;.  After this call, this
     * &lt;code&gt;TextMeasurer&lt;/code&gt; is equivalent to a new
     * &lt;code&gt;TextMeasurer&lt;/code&gt; created from the text;  however, it will
     * usually be more efficient to update an existing
     * &lt;code&gt;TextMeasurer&lt;/code&gt; than to create a new one from scratch.
     *
     * @param newParagraph the text of the paragraph after performing
     * the insertion.  Cannot be null.
     * @param insertPos the position in the text where the character was
     * inserted.  Must not be less than the start of
     * &lt;code&gt;newParagraph&lt;/code&gt;, and must be less than the end of
     * &lt;code&gt;newParagraph&lt;/code&gt;.
     * @throws IndexOutOfBoundsException if &lt;code&gt;insertPos&lt;/code&gt; is less
     *         than the start of &lt;code&gt;newParagraph&lt;/code&gt; or greater than
     *         or equal to the end of &lt;code&gt;newParagraph&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;newParagraph&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     */
    public void insertChar(AttributedCharacterIterator newParagraph, int insertPos) {

<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (collectStats) {</span>
<span class="nc" id="L664">            printStats();</span>
        }
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (wantStats) {</span>
<span class="nc" id="L667">            collectStats = true;</span>
        }

<span class="nc" id="L670">        fStart = newParagraph.getBeginIndex();</span>
<span class="nc" id="L671">        int end = newParagraph.getEndIndex();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (end - fStart != fChars.length+1) {</span>
<span class="nc" id="L673">            initAll(newParagraph);</span>
        }

<span class="nc" id="L676">        char[] newChars = new char[end-fStart];</span>
<span class="nc" id="L677">        int newCharIndex = insertPos - fStart;</span>
<span class="nc" id="L678">        System.arraycopy(fChars, 0, newChars, 0, newCharIndex);</span>

<span class="nc" id="L680">        char newChar = newParagraph.setIndex(insertPos);</span>
<span class="nc" id="L681">        newChars[newCharIndex] = newChar;</span>
<span class="nc" id="L682">        System.arraycopy(fChars,</span>
                         newCharIndex,
                         newChars,
                         newCharIndex+1,
                         end-insertPos-1);
<span class="nc" id="L687">        fChars = newChars;</span>

<span class="nc bnc" id="L689" title="All 4 branches missed.">        if (fBidi != null || Bidi.requiresBidi(newChars, newCharIndex, newCharIndex + 1) ||</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                newParagraph.getAttribute(TextAttribute.BIDI_EMBEDDING) != null) {</span>

<span class="nc" id="L692">            fBidi = new Bidi(newParagraph);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (fBidi.isLeftToRight()) {</span>
<span class="nc" id="L694">                fBidi = null;</span>
            }
        }

<span class="nc" id="L698">        fParagraph = StyledParagraph.insertChar(newParagraph,</span>
                                                fChars,
                                                insertPos,
                                                fParagraph);
<span class="nc" id="L702">        invalidateComponents();</span>
<span class="nc" id="L703">    }</span>

    /**
     * Updates the &lt;code&gt;TextMeasurer&lt;/code&gt; after a single character has
     * been deleted
     * from the paragraph currently represented by this
     * &lt;code&gt;TextMeasurer&lt;/code&gt;.  After this call, this
     * &lt;code&gt;TextMeasurer&lt;/code&gt; is equivalent to a new &lt;code&gt;TextMeasurer&lt;/code&gt;
     * created from the text;  however, it will usually be more efficient
     * to update an existing &lt;code&gt;TextMeasurer&lt;/code&gt; than to create a new one
     * from scratch.
     *
     * @param newParagraph the text of the paragraph after performing
     * the deletion.  Cannot be null.
     * @param deletePos the position in the text where the character was removed.
     * Must not be less than
     * the start of &lt;code&gt;newParagraph&lt;/code&gt;, and must not be greater than the
     * end of &lt;code&gt;newParagraph&lt;/code&gt;.
     * @throws IndexOutOfBoundsException if &lt;code&gt;deletePos&lt;/code&gt; is
     *         less than the start of &lt;code&gt;newParagraph&lt;/code&gt; or greater
     *         than the end of &lt;code&gt;newParagraph&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;newParagraph&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt;
     */
    public void deleteChar(AttributedCharacterIterator newParagraph, int deletePos) {

<span class="nc" id="L729">        fStart = newParagraph.getBeginIndex();</span>
<span class="nc" id="L730">        int end = newParagraph.getEndIndex();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (end - fStart != fChars.length-1) {</span>
<span class="nc" id="L732">            initAll(newParagraph);</span>
        }

<span class="nc" id="L735">        char[] newChars = new char[end-fStart];</span>
<span class="nc" id="L736">        int changedIndex = deletePos-fStart;</span>

<span class="nc" id="L738">        System.arraycopy(fChars, 0, newChars, 0, deletePos-fStart);</span>
<span class="nc" id="L739">        System.arraycopy(fChars, changedIndex+1, newChars, changedIndex, end-deletePos);</span>
<span class="nc" id="L740">        fChars = newChars;</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (fBidi != null) {</span>
<span class="nc" id="L743">            fBidi = new Bidi(newParagraph);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (fBidi.isLeftToRight()) {</span>
<span class="nc" id="L745">                fBidi = null;</span>
            }
        }

<span class="nc" id="L749">        fParagraph = StyledParagraph.deleteChar(newParagraph,</span>
                                                fChars,
                                                deletePos,
                                                fParagraph);
<span class="nc" id="L753">        invalidateComponents();</span>
<span class="nc" id="L754">    }</span>

    /**
     * NOTE:  This method is only for LineBreakMeasurer's use.  It is package-
     * private because it returns internal data.
     */
    char[] getChars() {

<span class="nc" id="L762">        return fChars;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>