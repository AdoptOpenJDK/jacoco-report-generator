<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NumericShaper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.font</a> &gt; <span class="el_source">NumericShaper.java</span></div><h1>NumericShaper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.font;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Set;

/**
 * The &lt;code&gt;NumericShaper&lt;/code&gt; class is used to convert Latin-1 (European)
 * digits to other Unicode decimal digits.  Users of this class will
 * primarily be people who wish to present data using
 * national digit shapes, but find it more convenient to represent the
 * data internally using Latin-1 (European) digits.  This does not
 * interpret the deprecated numeric shape selector character (U+206E).
 * &lt;p&gt;
 * Instances of &lt;code&gt;NumericShaper&lt;/code&gt; are typically applied
 * as attributes to text with the
 * {@link TextAttribute#NUMERIC_SHAPING NUMERIC_SHAPING} attribute
 * of the &lt;code&gt;TextAttribute&lt;/code&gt; class.
 * For example, this code snippet causes a &lt;code&gt;TextLayout&lt;/code&gt; to
 * shape European digits to Arabic in an Arabic context:&lt;br&gt;
 * &lt;blockquote&gt;&lt;pre&gt;
 * Map map = new HashMap();
 * map.put(TextAttribute.NUMERIC_SHAPING,
 *     NumericShaper.getContextualShaper(NumericShaper.ARABIC));
 * FontRenderContext frc = ...;
 * TextLayout layout = new TextLayout(text, map, frc);
 * layout.draw(g2d, x, y);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;br&gt;
 * It is also possible to perform numeric shaping explicitly using instances
 * of &lt;code&gt;NumericShaper&lt;/code&gt;, as this code snippet demonstrates:&lt;br&gt;
 * &lt;blockquote&gt;&lt;pre&gt;
 * char[] text = ...;
 * // shape all EUROPEAN digits (except zero) to ARABIC digits
 * NumericShaper shaper = NumericShaper.getShaper(NumericShaper.ARABIC);
 * shaper.shape(text, start, count);
 *
 * // shape European digits to ARABIC digits if preceding text is Arabic, or
 * // shape European digits to TAMIL digits if preceding text is Tamil, or
 * // leave European digits alone if there is no preceding text, or
 * // preceding text is neither Arabic nor Tamil
 * NumericShaper shaper =
 *     NumericShaper.getContextualShaper(NumericShaper.ARABIC |
 *                                         NumericShaper.TAMIL,
 *                                       NumericShaper.EUROPEAN);
 * shaper.shape(text, start, count);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt;&lt;b&gt;Bit mask- and enum-based Unicode ranges&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;This class supports two different programming interfaces to
 * represent Unicode ranges for script-specific digits: bit
 * mask-based ones, such as {@link #ARABIC NumericShaper.ARABIC}, and
 * enum-based ones, such as {@link NumericShaper.Range#ARABIC}.
 * Multiple ranges can be specified by ORing bit mask-based constants,
 * such as:
 * &lt;blockquote&gt;&lt;pre&gt;
 * NumericShaper.ARABIC | NumericShaper.TAMIL
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * or creating a {@code Set} with the {@link NumericShaper.Range}
 * constants, such as:
 * &lt;blockquote&gt;&lt;pre&gt;
 * EnumSet.of(NumericShaper.Scirpt.ARABIC, NumericShaper.Range.TAMIL)
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * The enum-based ranges are a super set of the bit mask-based ones.
 *
 * &lt;p&gt;If the two interfaces are mixed (including serialization),
 * Unicode range values are mapped to their counterparts where such
 * mapping is possible, such as {@code NumericShaper.Range.ARABIC}
 * from/to {@code NumericShaper.ARABIC}.  If any unmappable range
 * values are specified, such as {@code NumericShaper.Range.BALINESE},
 * those ranges are ignored.
 *
 * &lt;p&gt;&lt;b&gt;Decimal Digits Precedence&lt;/b&gt;&lt;/p&gt;
 *
 * &lt;p&gt;A Unicode range may have more than one set of decimal digits. If
 * multiple decimal digits sets are specified for the same Unicode
 * range, one of the sets will take precedence as follows.
 *
 * &lt;table border=1 cellspacing=3 cellpadding=0 summary=&quot;NumericShaper constants precedence.&quot;&gt;
 *    &lt;tr&gt;
 *       &lt;th class=&quot;TableHeadingColor&quot;&gt;Unicode Range&lt;/th&gt;
 *       &lt;th class=&quot;TableHeadingColor&quot;&gt;&lt;code&gt;NumericShaper&lt;/code&gt; Constants&lt;/th&gt;
 *       &lt;th class=&quot;TableHeadingColor&quot;&gt;Precedence&lt;/th&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *       &lt;td rowspan=&quot;2&quot;&gt;Arabic&lt;/td&gt;
 *       &lt;td&gt;{@link NumericShaper#ARABIC NumericShaper.ARABIC}&lt;br&gt;
 *           {@link NumericShaper#EASTERN_ARABIC NumericShaper.EASTERN_ARABIC}&lt;/td&gt;
 *       &lt;td&gt;{@link NumericShaper#EASTERN_ARABIC NumericShaper.EASTERN_ARABIC}&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *       &lt;td&gt;{@link NumericShaper.Range#ARABIC}&lt;br&gt;
 *           {@link NumericShaper.Range#EASTERN_ARABIC}&lt;/td&gt;
 *       &lt;td&gt;{@link NumericShaper.Range#EASTERN_ARABIC}&lt;/td&gt;
 *    &lt;/tr&gt;
 *    &lt;tr&gt;
 *       &lt;td&gt;Tai Tham&lt;/td&gt;
 *       &lt;td&gt;{@link NumericShaper.Range#TAI_THAM_HORA}&lt;br&gt;
 *           {@link NumericShaper.Range#TAI_THAM_THAM}&lt;/td&gt;
 *       &lt;td&gt;{@link NumericShaper.Range#TAI_THAM_THAM}&lt;/td&gt;
 *    &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * @since 1.4
 */

public final class NumericShaper implements java.io.Serializable {
    /**
     * A {@code NumericShaper.Range} represents a Unicode range of a
     * script having its own decimal digits. For example, the {@link
     * NumericShaper.Range#THAI} range has the Thai digits, THAI DIGIT
     * ZERO (U+0E50) to THAI DIGIT NINE (U+0E59).
     *
     * &lt;p&gt;The &lt;code&gt;Range&lt;/code&gt; enum replaces the traditional bit
     * mask-based values (e.g., {@link NumericShaper#ARABIC}), and
     * supports more Unicode ranges than the bit mask-based ones. For
     * example, the following code using the bit mask:
     * &lt;blockquote&gt;&lt;pre&gt;
     * NumericShaper.getContextualShaper(NumericShaper.ARABIC |
     *                                     NumericShaper.TAMIL,
     *                                   NumericShaper.EUROPEAN);
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * can be written using this enum as:
     * &lt;blockquote&gt;&lt;pre&gt;
     * NumericShaper.getContextualShaper(EnumSet.of(
     *                                     NumericShaper.Range.ARABIC,
     *                                     NumericShaper.Range.TAMIL),
     *                                   NumericShaper.Range.EUROPEAN);
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @since 1.7
     */
<span class="nc" id="L162">    public static enum Range {</span>
        // The order of EUROPEAN to MOGOLIAN must be consistent
        // with the bitmask-based constants.
        /**
         * The Latin (European) range with the Latin (ASCII) digits.
         */
<span class="nc" id="L168">        EUROPEAN        ('\u0030', '\u0000', '\u0300'),</span>
        /**
         * The Arabic range with the Arabic-Indic digits.
         */
<span class="nc" id="L172">        ARABIC          ('\u0660', '\u0600', '\u0780'),</span>
        /**
         * The Arabic range with the Eastern Arabic-Indic digits.
         */
<span class="nc" id="L176">        EASTERN_ARABIC  ('\u06f0', '\u0600', '\u0780'),</span>
        /**
         * The Devanagari range with the Devanagari digits.
         */
<span class="nc" id="L180">        DEVANAGARI      ('\u0966', '\u0900', '\u0980'),</span>
        /**
         * The Bengali range with the Bengali digits.
         */
<span class="nc" id="L184">        BENGALI         ('\u09e6', '\u0980', '\u0a00'),</span>
        /**
         * The Gurmukhi range with the Gurmukhi digits.
         */
<span class="nc" id="L188">        GURMUKHI        ('\u0a66', '\u0a00', '\u0a80'),</span>
        /**
         * The Gujarati range with the Gujarati digits.
         */
<span class="nc" id="L192">        GUJARATI        ('\u0ae6', '\u0b00', '\u0b80'),</span>
        /**
         * The Oriya range with the Oriya digits.
         */
<span class="nc" id="L196">        ORIYA           ('\u0b66', '\u0b00', '\u0b80'),</span>
        /**
         * The Tamil range with the Tamil digits.
         */
<span class="nc" id="L200">        TAMIL           ('\u0be6', '\u0b80', '\u0c00'),</span>
        /**
         * The Telugu range with the Telugu digits.
         */
<span class="nc" id="L204">        TELUGU          ('\u0c66', '\u0c00', '\u0c80'),</span>
        /**
         * The Kannada range with the Kannada digits.
         */
<span class="nc" id="L208">        KANNADA         ('\u0ce6', '\u0c80', '\u0d00'),</span>
        /**
         * The Malayalam range with the Malayalam digits.
         */
<span class="nc" id="L212">        MALAYALAM       ('\u0d66', '\u0d00', '\u0d80'),</span>
        /**
         * The Thai range with the Thai digits.
         */
<span class="nc" id="L216">        THAI            ('\u0e50', '\u0e00', '\u0e80'),</span>
        /**
         * The Lao range with the Lao digits.
         */
<span class="nc" id="L220">        LAO             ('\u0ed0', '\u0e80', '\u0f00'),</span>
        /**
         * The Tibetan range with the Tibetan digits.
         */
<span class="nc" id="L224">        TIBETAN         ('\u0f20', '\u0f00', '\u1000'),</span>
        /**
         * The Myanmar range with the Myanmar digits.
         */
<span class="nc" id="L228">        MYANMAR         ('\u1040', '\u1000', '\u1080'),</span>
        /**
         * The Ethiopic range with the Ethiopic digits. Ethiopic
         * does not have a decimal digit 0 so Latin (European) 0 is
         * used.
         */
<span class="nc" id="L234">        ETHIOPIC        ('\u1369', '\u1200', '\u1380') {</span>
            @Override
<span class="nc" id="L236">            char getNumericBase() { return 1; }</span>
        },
        /**
         * The Khmer range with the Khmer digits.
         */
<span class="nc" id="L241">        KHMER           ('\u17e0', '\u1780', '\u1800'),</span>
        /**
         * The Mongolian range with the Mongolian digits.
         */
<span class="nc" id="L245">        MONGOLIAN       ('\u1810', '\u1800', '\u1900'),</span>
        // The order of EUROPEAN to MOGOLIAN must be consistent
        // with the bitmask-based constants.

        /**
         * The N'Ko range with the N'Ko digits.
         */
<span class="nc" id="L252">        NKO             ('\u07c0', '\u07c0', '\u0800'),</span>
        /**
         * The Myanmar range with the Myanmar Shan digits.
         */
<span class="nc" id="L256">        MYANMAR_SHAN    ('\u1090', '\u1000', '\u10a0'),</span>
        /**
         * The Limbu range with the Limbu digits.
         */
<span class="nc" id="L260">        LIMBU           ('\u1946', '\u1900', '\u1950'),</span>
        /**
         * The New Tai Lue range with the New Tai Lue digits.
         */
<span class="nc" id="L264">        NEW_TAI_LUE     ('\u19d0', '\u1980', '\u19e0'),</span>
        /**
         * The Balinese range with the Balinese digits.
         */
<span class="nc" id="L268">        BALINESE        ('\u1b50', '\u1b00', '\u1b80'),</span>
        /**
         * The Sundanese range with the Sundanese digits.
         */
<span class="nc" id="L272">        SUNDANESE       ('\u1bb0', '\u1b80', '\u1bc0'),</span>
        /**
         * The Lepcha range with the Lepcha digits.
         */
<span class="nc" id="L276">        LEPCHA          ('\u1c40', '\u1c00', '\u1c50'),</span>
        /**
         * The Ol Chiki range with the Ol Chiki digits.
         */
<span class="nc" id="L280">        OL_CHIKI        ('\u1c50', '\u1c50', '\u1c80'),</span>
        /**
         * The Vai range with the Vai digits.
         */
<span class="nc" id="L284">        VAI             ('\ua620', '\ua500', '\ua640'),</span>
        /**
         * The Saurashtra range with the Saurashtra digits.
         */
<span class="nc" id="L288">        SAURASHTRA      ('\ua8d0', '\ua880', '\ua8e0'),</span>
        /**
         * The Kayah Li range with the Kayah Li digits.
         */
<span class="nc" id="L292">        KAYAH_LI        ('\ua900', '\ua900', '\ua930'),</span>
        /**
         * The Cham range with the Cham digits.
         */
<span class="nc" id="L296">        CHAM            ('\uaa50', '\uaa00', '\uaa60'),</span>
        /**
         * The Tai Tham Hora range with the Tai Tham Hora digits.
         */
<span class="nc" id="L300">        TAI_THAM_HORA   ('\u1a80', '\u1a20', '\u1ab0'),</span>
        /**
         * The Tai Tham Tham range with the Tai Tham Tham digits.
         */
<span class="nc" id="L304">        TAI_THAM_THAM   ('\u1a90', '\u1a20', '\u1ab0'),</span>
        /**
         * The Javanese range with the Javanese digits.
         */
<span class="nc" id="L308">        JAVANESE        ('\ua9d0', '\ua980', '\ua9e0'),</span>
        /**
         * The Meetei Mayek range with the Meetei Mayek digits.
         */
<span class="nc" id="L312">        MEETEI_MAYEK    ('\uabf0', '\uabc0', '\uac00');</span>

        private static int toRangeIndex(Range script) {
<span class="nc" id="L315">            int index = script.ordinal();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            return index &lt; NUM_KEYS ? index : -1;</span>
        }

        private static Range indexToRange(int index) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">            return index &lt; NUM_KEYS ? Range.values()[index] : null;</span>
        }

        private static int toRangeMask(Set&lt;Range&gt; ranges) {
<span class="nc" id="L324">            int m = 0;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (Range range : ranges) {</span>
<span class="nc" id="L326">                int index = range.ordinal();</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (index &lt; NUM_KEYS) {</span>
<span class="nc" id="L328">                    m |= 1 &lt;&lt; index;</span>
                }
<span class="nc" id="L330">            }</span>
<span class="nc" id="L331">            return m;</span>
        }

        private static Set&lt;Range&gt; maskToRangeSet(int mask) {
<span class="nc" id="L335">            Set&lt;Range&gt; set = EnumSet.noneOf(Range.class);</span>
<span class="nc" id="L336">            Range[] a = Range.values();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            for (int i = 0; i &lt; NUM_KEYS; i++) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if ((mask &amp; (1 &lt;&lt; i)) != 0) {</span>
<span class="nc" id="L339">                    set.add(a[i]);</span>
                }
            }
<span class="nc" id="L342">            return set;</span>
        }

        // base character of range digits
        private final int base;
        // Unicode range
        private final int start, // inclusive
                          end;   // exclusive

<span class="nc" id="L351">        private Range(int base, int start, int end) {</span>
<span class="nc" id="L352">            this.base = base - ('0' + getNumericBase());</span>
<span class="nc" id="L353">            this.start = start;</span>
<span class="nc" id="L354">            this.end = end;</span>
<span class="nc" id="L355">        }</span>

        private int getDigitBase() {
<span class="nc" id="L358">            return base;</span>
        }

        char getNumericBase() {
<span class="nc" id="L362">            return 0;</span>
        }

        private boolean inRange(int c) {
<span class="nc bnc" id="L366" title="All 4 branches missed.">            return start &lt;= c &amp;&amp; c &lt; end;</span>
        }
    }

    /** index of context for contextual shaping - values range from 0 to 18 */
    private int key;

    /** flag indicating whether to shape contextually (high bit) and which
     *  digit ranges to shape (bits 0-18)
     */
    private int mask;

    /**
     * The context {@code Range} for contextual shaping or the {@code
     * Range} for non-contextual shaping. {@code null} for the bit
     * mask-based API.
     *
     * @since 1.7
     */
    private Range shapingRange;

    /**
     * {@code Set&lt;Range&gt;} indicating which Unicode ranges to
     * shape. {@code null} for the bit mask-based API.
     */
    private transient Set&lt;Range&gt; rangeSet;

    /**
     * rangeSet.toArray() value. Sorted by Range.base when the number
     * of elements is greater then BSEARCH_THRESHOLD.
     */
    private transient Range[] rangeArray;

    /**
     * If more than BSEARCH_THRESHOLD ranges are specified, binary search is used.
     */
    private static final int BSEARCH_THRESHOLD = 3;

    private static final long serialVersionUID = -8022764705923730308L;

    /** Identifies the Latin-1 (European) and extended range, and
     *  Latin-1 (European) decimal base.
     */
    public static final int EUROPEAN = 1&lt;&lt;0;

    /** Identifies the ARABIC range and decimal base. */
    public static final int ARABIC = 1&lt;&lt;1;

    /** Identifies the ARABIC range and ARABIC_EXTENDED decimal base. */
    public static final int EASTERN_ARABIC = 1&lt;&lt;2;

    /** Identifies the DEVANAGARI range and decimal base. */
    public static final int DEVANAGARI = 1&lt;&lt;3;

    /** Identifies the BENGALI range and decimal base. */
    public static final int BENGALI = 1&lt;&lt;4;

    /** Identifies the GURMUKHI range and decimal base. */
    public static final int GURMUKHI = 1&lt;&lt;5;

    /** Identifies the GUJARATI range and decimal base. */
    public static final int GUJARATI = 1&lt;&lt;6;

    /** Identifies the ORIYA range and decimal base. */
    public static final int ORIYA = 1&lt;&lt;7;

    /** Identifies the TAMIL range and decimal base. */
    // TAMIL DIGIT ZERO was added in Unicode 4.1
    public static final int TAMIL = 1&lt;&lt;8;

    /** Identifies the TELUGU range and decimal base. */
    public static final int TELUGU = 1&lt;&lt;9;

    /** Identifies the KANNADA range and decimal base. */
    public static final int KANNADA = 1&lt;&lt;10;

    /** Identifies the MALAYALAM range and decimal base. */
    public static final int MALAYALAM = 1&lt;&lt;11;

    /** Identifies the THAI range and decimal base. */
    public static final int THAI = 1&lt;&lt;12;

    /** Identifies the LAO range and decimal base. */
    public static final int LAO = 1&lt;&lt;13;

    /** Identifies the TIBETAN range and decimal base. */
    public static final int TIBETAN = 1&lt;&lt;14;

    /** Identifies the MYANMAR range and decimal base. */
    public static final int MYANMAR = 1&lt;&lt;15;

    /** Identifies the ETHIOPIC range and decimal base. */
    public static final int ETHIOPIC = 1&lt;&lt;16;

    /** Identifies the KHMER range and decimal base. */
    public static final int KHMER = 1&lt;&lt;17;

    /** Identifies the MONGOLIAN range and decimal base. */
    public static final int MONGOLIAN = 1&lt;&lt;18;

    /** Identifies all ranges, for full contextual shaping.
     *
     * &lt;p&gt;This constant specifies all of the bit mask-based
     * ranges. Use {@code EmunSet.allOf(NumericShaper.Range.class)} to
     * specify all of the enum-based ranges.
     */
    public static final int ALL_RANGES = 0x0007ffff;

    private static final int EUROPEAN_KEY = 0;
    private static final int ARABIC_KEY = 1;
    private static final int EASTERN_ARABIC_KEY = 2;
    private static final int DEVANAGARI_KEY = 3;
    private static final int BENGALI_KEY = 4;
    private static final int GURMUKHI_KEY = 5;
    private static final int GUJARATI_KEY = 6;
    private static final int ORIYA_KEY = 7;
    private static final int TAMIL_KEY = 8;
    private static final int TELUGU_KEY = 9;
    private static final int KANNADA_KEY = 10;
    private static final int MALAYALAM_KEY = 11;
    private static final int THAI_KEY = 12;
    private static final int LAO_KEY = 13;
    private static final int TIBETAN_KEY = 14;
    private static final int MYANMAR_KEY = 15;
    private static final int ETHIOPIC_KEY = 16;
    private static final int KHMER_KEY = 17;
    private static final int MONGOLIAN_KEY = 18;

    private static final int NUM_KEYS = MONGOLIAN_KEY + 1; // fixed

    private static final int CONTEXTUAL_MASK = 1&lt;&lt;31;

<span class="nc" id="L498">    private static final char[] bases = {</span>
        '\u0030' - '\u0030', // EUROPEAN
        '\u0660' - '\u0030', // ARABIC-INDIC
        '\u06f0' - '\u0030', // EXTENDED ARABIC-INDIC (EASTERN_ARABIC)
        '\u0966' - '\u0030', // DEVANAGARI
        '\u09e6' - '\u0030', // BENGALI
        '\u0a66' - '\u0030', // GURMUKHI
        '\u0ae6' - '\u0030', // GUJARATI
        '\u0b66' - '\u0030', // ORIYA
        '\u0be6' - '\u0030', // TAMIL - zero was added in Unicode 4.1
        '\u0c66' - '\u0030', // TELUGU
        '\u0ce6' - '\u0030', // KANNADA
        '\u0d66' - '\u0030', // MALAYALAM
        '\u0e50' - '\u0030', // THAI
        '\u0ed0' - '\u0030', // LAO
        '\u0f20' - '\u0030', // TIBETAN
        '\u1040' - '\u0030', // MYANMAR
        '\u1369' - '\u0031', // ETHIOPIC - no zero
        '\u17e0' - '\u0030', // KHMER
        '\u1810' - '\u0030', // MONGOLIAN
    };

    // some ranges adjoin or overlap, rethink if we want to do a binary search on this

<span class="nc" id="L522">    private static final char[] contexts = {</span>
        '\u0000', '\u0300', // 'EUROPEAN' (really latin-1 and extended)
        '\u0600', '\u0780', // ARABIC
        '\u0600', '\u0780', // EASTERN_ARABIC -- note overlap with arabic
        '\u0900', '\u0980', // DEVANAGARI
        '\u0980', '\u0a00', // BENGALI
        '\u0a00', '\u0a80', // GURMUKHI
        '\u0a80', '\u0b00', // GUJARATI
        '\u0b00', '\u0b80', // ORIYA
        '\u0b80', '\u0c00', // TAMIL
        '\u0c00', '\u0c80', // TELUGU
        '\u0c80', '\u0d00', // KANNADA
        '\u0d00', '\u0d80', // MALAYALAM
        '\u0e00', '\u0e80', // THAI
        '\u0e80', '\u0f00', // LAO
        '\u0f00', '\u1000', // TIBETAN
        '\u1000', '\u1080', // MYANMAR
        '\u1200', '\u1380', // ETHIOPIC - note missing zero
        '\u1780', '\u1800', // KHMER
        '\u1800', '\u1900', // MONGOLIAN
        '\uffff',
    };

    // assume most characters are near each other so probing the cache is infrequent,
    // and a linear probe is ok.

<span class="nc" id="L548">    private static int ctCache = 0;</span>
<span class="nc" id="L549">    private static int ctCacheLimit = contexts.length - 2;</span>

    // warning, synchronize access to this as it modifies state
    private static int getContextKey(char c) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (c &lt; contexts[ctCache]) {</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">            while (ctCache &gt; 0 &amp;&amp; c &lt; contexts[ctCache]) --ctCache;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        } else if (c &gt;= contexts[ctCache + 1]) {</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">            while (ctCache &lt; ctCacheLimit &amp;&amp; c &gt;= contexts[ctCache + 1]) ++ctCache;</span>
        }

        // if we're not in a known range, then return EUROPEAN as the range key
<span class="nc bnc" id="L560" title="All 2 branches missed.">        return (ctCache &amp; 0x1) == 0 ? (ctCache / 2) : EUROPEAN_KEY;</span>
    }

    // cache for the NumericShaper.Range version
<span class="nc" id="L564">    private transient volatile Range currentRange = Range.EUROPEAN;</span>

    private Range rangeForCodePoint(final int codepoint) {
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (currentRange.inRange(codepoint)) {</span>
<span class="nc" id="L568">            return currentRange;</span>
        }

<span class="nc" id="L571">        final Range[] ranges = rangeArray;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (ranges.length &gt; BSEARCH_THRESHOLD) {</span>
<span class="nc" id="L573">            int lo = 0;</span>
<span class="nc" id="L574">            int hi = ranges.length - 1;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            while (lo &lt;= hi) {</span>
<span class="nc" id="L576">                int mid = (lo + hi) / 2;</span>
<span class="nc" id="L577">                Range range = ranges[mid];</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">                if (codepoint &lt; range.start) {</span>
<span class="nc" id="L579">                    hi = mid - 1;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                } else if (codepoint &gt;= range.end) {</span>
<span class="nc" id="L581">                    lo = mid + 1;</span>
                } else {
<span class="nc" id="L583">                    currentRange = range;</span>
<span class="nc" id="L584">                    return range;</span>
                }
<span class="nc" id="L586">            }</span>
<span class="nc" id="L587">        } else {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            for (int i = 0; i &lt; ranges.length; i++) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (ranges[i].inRange(codepoint)) {</span>
<span class="nc" id="L590">                    return ranges[i];</span>
                }
            }
        }
<span class="nc" id="L594">        return Range.EUROPEAN;</span>
    }

    /*
     * A range table of strong directional characters (types L, R, AL).
     * Even (left) indexes are starts of ranges of non-strong-directional (or undefined)
     * characters, odd (right) indexes are starts of ranges of strong directional
     * characters.
     */
<span class="nc" id="L603">    private static int[] strongTable = {</span>
        0x0000, 0x0041,
        0x005b, 0x0061,
        0x007b, 0x00aa,
        0x00ab, 0x00b5,
        0x00b6, 0x00ba,
        0x00bb, 0x00c0,
        0x00d7, 0x00d8,
        0x00f7, 0x00f8,
        0x02b9, 0x02bb,
        0x02c2, 0x02d0,
        0x02d2, 0x02e0,
        0x02e5, 0x02ee,
        0x02ef, 0x0370,
        0x0374, 0x0376,
        0x037e, 0x0386,
        0x0387, 0x0388,
        0x03f6, 0x03f7,
        0x0483, 0x048a,
        0x058a, 0x05be,
        0x05bf, 0x05c0,
        0x05c1, 0x05c3,
        0x05c4, 0x05c6,
        0x05c7, 0x05d0,
        0x0600, 0x0608,
        0x0609, 0x060b,
        0x060c, 0x060d,
        0x060e, 0x061b,
        0x064b, 0x066d,
        0x0670, 0x0671,
        0x06d6, 0x06e5,
        0x06e7, 0x06ee,
        0x06f0, 0x06fa,
        0x0711, 0x0712,
        0x0730, 0x074d,
        0x07a6, 0x07b1,
        0x07eb, 0x07f4,
        0x07f6, 0x07fa,
        0x0816, 0x081a,
        0x081b, 0x0824,
        0x0825, 0x0828,
        0x0829, 0x0830,
        0x0859, 0x085e,
        0x08e4, 0x0903,
        0x093a, 0x093b,
        0x093c, 0x093d,
        0x0941, 0x0949,
        0x094d, 0x094e,
        0x0951, 0x0958,
        0x0962, 0x0964,
        0x0981, 0x0982,
        0x09bc, 0x09bd,
        0x09c1, 0x09c7,
        0x09cd, 0x09ce,
        0x09e2, 0x09e6,
        0x09f2, 0x09f4,
        0x09fb, 0x0a03,
        0x0a3c, 0x0a3e,
        0x0a41, 0x0a59,
        0x0a70, 0x0a72,
        0x0a75, 0x0a83,
        0x0abc, 0x0abd,
        0x0ac1, 0x0ac9,
        0x0acd, 0x0ad0,
        0x0ae2, 0x0ae6,
        0x0af1, 0x0b02,
        0x0b3c, 0x0b3d,
        0x0b3f, 0x0b40,
        0x0b41, 0x0b47,
        0x0b4d, 0x0b57,
        0x0b62, 0x0b66,
        0x0b82, 0x0b83,
        0x0bc0, 0x0bc1,
        0x0bcd, 0x0bd0,
        0x0bf3, 0x0c01,
        0x0c3e, 0x0c41,
        0x0c46, 0x0c58,
        0x0c62, 0x0c66,
        0x0c78, 0x0c7f,
        0x0cbc, 0x0cbd,
        0x0ccc, 0x0cd5,
        0x0ce2, 0x0ce6,
        0x0d41, 0x0d46,
        0x0d4d, 0x0d4e,
        0x0d62, 0x0d66,
        0x0dca, 0x0dcf,
        0x0dd2, 0x0dd8,
        0x0e31, 0x0e32,
        0x0e34, 0x0e40,
        0x0e47, 0x0e4f,
        0x0eb1, 0x0eb2,
        0x0eb4, 0x0ebd,
        0x0ec8, 0x0ed0,
        0x0f18, 0x0f1a,
        0x0f35, 0x0f36,
        0x0f37, 0x0f38,
        0x0f39, 0x0f3e,
        0x0f71, 0x0f7f,
        0x0f80, 0x0f85,
        0x0f86, 0x0f88,
        0x0f8d, 0x0fbe,
        0x0fc6, 0x0fc7,
        0x102d, 0x1031,
        0x1032, 0x1038,
        0x1039, 0x103b,
        0x103d, 0x103f,
        0x1058, 0x105a,
        0x105e, 0x1061,
        0x1071, 0x1075,
        0x1082, 0x1083,
        0x1085, 0x1087,
        0x108d, 0x108e,
        0x109d, 0x109e,
        0x135d, 0x1360,
        0x1390, 0x13a0,
        0x1400, 0x1401,
        0x1680, 0x1681,
        0x169b, 0x16a0,
        0x1712, 0x1720,
        0x1732, 0x1735,
        0x1752, 0x1760,
        0x1772, 0x1780,
        0x17b4, 0x17b6,
        0x17b7, 0x17be,
        0x17c6, 0x17c7,
        0x17c9, 0x17d4,
        0x17db, 0x17dc,
        0x17dd, 0x17e0,
        0x17f0, 0x1810,
        0x18a9, 0x18aa,
        0x1920, 0x1923,
        0x1927, 0x1929,
        0x1932, 0x1933,
        0x1939, 0x1946,
        0x19de, 0x1a00,
        0x1a17, 0x1a19,
        0x1a56, 0x1a57,
        0x1a58, 0x1a61,
        0x1a62, 0x1a63,
        0x1a65, 0x1a6d,
        0x1a73, 0x1a80,
        0x1b00, 0x1b04,
        0x1b34, 0x1b35,
        0x1b36, 0x1b3b,
        0x1b3c, 0x1b3d,
        0x1b42, 0x1b43,
        0x1b6b, 0x1b74,
        0x1b80, 0x1b82,
        0x1ba2, 0x1ba6,
        0x1ba8, 0x1baa,
        0x1bab, 0x1bac,
        0x1be6, 0x1be7,
        0x1be8, 0x1bea,
        0x1bed, 0x1bee,
        0x1bef, 0x1bf2,
        0x1c2c, 0x1c34,
        0x1c36, 0x1c3b,
        0x1cd0, 0x1cd3,
        0x1cd4, 0x1ce1,
        0x1ce2, 0x1ce9,
        0x1ced, 0x1cee,
        0x1cf4, 0x1cf5,
        0x1dc0, 0x1e00,
        0x1fbd, 0x1fbe,
        0x1fbf, 0x1fc2,
        0x1fcd, 0x1fd0,
        0x1fdd, 0x1fe0,
        0x1fed, 0x1ff2,
        0x1ffd, 0x200e,
        0x2010, 0x2071,
        0x2074, 0x207f,
        0x2080, 0x2090,
        0x20a0, 0x2102,
        0x2103, 0x2107,
        0x2108, 0x210a,
        0x2114, 0x2115,
        0x2116, 0x2119,
        0x211e, 0x2124,
        0x2125, 0x2126,
        0x2127, 0x2128,
        0x2129, 0x212a,
        0x212e, 0x212f,
        0x213a, 0x213c,
        0x2140, 0x2145,
        0x214a, 0x214e,
        0x2150, 0x2160,
        0x2189, 0x2336,
        0x237b, 0x2395,
        0x2396, 0x249c,
        0x24ea, 0x26ac,
        0x26ad, 0x2800,
        0x2900, 0x2c00,
        0x2ce5, 0x2ceb,
        0x2cef, 0x2cf2,
        0x2cf9, 0x2d00,
        0x2d7f, 0x2d80,
        0x2de0, 0x3005,
        0x3008, 0x3021,
        0x302a, 0x3031,
        0x3036, 0x3038,
        0x303d, 0x3041,
        0x3099, 0x309d,
        0x30a0, 0x30a1,
        0x30fb, 0x30fc,
        0x31c0, 0x31f0,
        0x321d, 0x3220,
        0x3250, 0x3260,
        0x327c, 0x327f,
        0x32b1, 0x32c0,
        0x32cc, 0x32d0,
        0x3377, 0x337b,
        0x33de, 0x33e0,
        0x33ff, 0x3400,
        0x4dc0, 0x4e00,
        0xa490, 0xa4d0,
        0xa60d, 0xa610,
        0xa66f, 0xa680,
        0xa69f, 0xa6a0,
        0xa6f0, 0xa6f2,
        0xa700, 0xa722,
        0xa788, 0xa789,
        0xa802, 0xa803,
        0xa806, 0xa807,
        0xa80b, 0xa80c,
        0xa825, 0xa827,
        0xa828, 0xa830,
        0xa838, 0xa840,
        0xa874, 0xa880,
        0xa8c4, 0xa8ce,
        0xa8e0, 0xa8f2,
        0xa926, 0xa92e,
        0xa947, 0xa952,
        0xa980, 0xa983,
        0xa9b3, 0xa9b4,
        0xa9b6, 0xa9ba,
        0xa9bc, 0xa9bd,
        0xaa29, 0xaa2f,
        0xaa31, 0xaa33,
        0xaa35, 0xaa40,
        0xaa43, 0xaa44,
        0xaa4c, 0xaa4d,
        0xaab0, 0xaab1,
        0xaab2, 0xaab5,
        0xaab7, 0xaab9,
        0xaabe, 0xaac0,
        0xaac1, 0xaac2,
        0xaaec, 0xaaee,
        0xaaf6, 0xab01,
        0xabe5, 0xabe6,
        0xabe8, 0xabe9,
        0xabed, 0xabf0,
        0xfb1e, 0xfb1f,
        0xfb29, 0xfb2a,
        0xfd3e, 0xfd50,
        0xfdfd, 0xfe70,
        0xfeff, 0xff21,
        0xff3b, 0xff41,
        0xff5b, 0xff66,
        0xffe0, 0x10000,
        0x10101, 0x10102,
        0x10140, 0x101d0,
        0x101fd, 0x10280,
        0x1091f, 0x10920,
        0x10a01, 0x10a10,
        0x10a38, 0x10a40,
        0x10b39, 0x10b40,
        0x10e60, 0x11000,
        0x11001, 0x11002,
        0x11038, 0x11047,
        0x11052, 0x11066,
        0x11080, 0x11082,
        0x110b3, 0x110b7,
        0x110b9, 0x110bb,
        0x11100, 0x11103,
        0x11127, 0x1112c,
        0x1112d, 0x11136,
        0x11180, 0x11182,
        0x111b6, 0x111bf,
        0x116ab, 0x116ac,
        0x116ad, 0x116ae,
        0x116b0, 0x116b6,
        0x116b7, 0x116c0,
        0x16f8f, 0x16f93,
        0x1d167, 0x1d16a,
        0x1d173, 0x1d183,
        0x1d185, 0x1d18c,
        0x1d1aa, 0x1d1ae,
        0x1d200, 0x1d360,
        0x1d6db, 0x1d6dc,
        0x1d715, 0x1d716,
        0x1d74f, 0x1d750,
        0x1d789, 0x1d78a,
        0x1d7c3, 0x1d7c4,
        0x1d7ce, 0x1ee00,
        0x1eef0, 0x1f110,
        0x1f16a, 0x1f170,
        0x1f300, 0x1f48c,
        0x1f48d, 0x1f524,
        0x1f525, 0x20000,
        0xe0001, 0xf0000,
        0x10fffe, 0x10ffff // sentinel
    };


    // use a binary search with a cache

<span class="nc" id="L909">    private transient volatile int stCache = 0;</span>

    private boolean isStrongDirectional(char c) {
<span class="nc" id="L912">        int cachedIndex = stCache;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (c &lt; strongTable[cachedIndex]) {</span>
<span class="nc" id="L914">            cachedIndex = search(c, strongTable, 0, cachedIndex);</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">        } else if (c &gt;= strongTable[cachedIndex + 1]) {</span>
<span class="nc" id="L916">            cachedIndex = search(c, strongTable, cachedIndex + 1,</span>
                                 strongTable.length - cachedIndex - 1);
        }
<span class="nc bnc" id="L919" title="All 2 branches missed.">        boolean val = (cachedIndex &amp; 0x1) == 1;</span>
<span class="nc" id="L920">        stCache = cachedIndex;</span>
<span class="nc" id="L921">        return val;</span>
    }

    private static int getKeyFromMask(int mask) {
<span class="nc" id="L925">        int key = 0;</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">        while (key &lt; NUM_KEYS &amp;&amp; ((mask &amp; (1&lt;&lt;key)) == 0)) {</span>
<span class="nc" id="L927">            ++key;</span>
        }
<span class="nc bnc" id="L929" title="All 4 branches missed.">        if (key == NUM_KEYS || ((mask &amp; ~(1&lt;&lt;key)) != 0)) {</span>
<span class="nc" id="L930">            throw new IllegalArgumentException(&quot;invalid shaper: &quot; + Integer.toHexString(mask));</span>
        }
<span class="nc" id="L932">        return key;</span>
    }

    /**
     * Returns a shaper for the provided unicode range.  All
     * Latin-1 (EUROPEAN) digits are converted
     * to the corresponding decimal unicode digits.
     * @param singleRange the specified Unicode range
     * @return a non-contextual numeric shaper
     * @throws IllegalArgumentException if the range is not a single range
     */
    public static NumericShaper getShaper(int singleRange) {
<span class="nc" id="L944">        int key = getKeyFromMask(singleRange);</span>
<span class="nc" id="L945">        return new NumericShaper(key, singleRange);</span>
    }

    /**
     * Returns a shaper for the provided Unicode
     * range. All Latin-1 (EUROPEAN) digits are converted to the
     * corresponding decimal digits of the specified Unicode range.
     *
     * @param singleRange the Unicode range given by a {@link
     *                    NumericShaper.Range} constant.
     * @return a non-contextual {@code NumericShaper}.
     * @throws NullPointerException if {@code singleRange} is {@code null}
     * @since 1.7
     */
    public static NumericShaper getShaper(Range singleRange) {
<span class="nc" id="L960">        return new NumericShaper(singleRange, EnumSet.of(singleRange));</span>
    }

    /**
     * Returns a contextual shaper for the provided unicode range(s).
     * Latin-1 (EUROPEAN) digits are converted to the decimal digits
     * corresponding to the range of the preceding text, if the
     * range is one of the provided ranges.  Multiple ranges are
     * represented by or-ing the values together, such as,
     * &lt;code&gt;NumericShaper.ARABIC | NumericShaper.THAI&lt;/code&gt;.  The
     * shaper assumes EUROPEAN as the starting context, that is, if
     * EUROPEAN digits are encountered before any strong directional
     * text in the string, the context is presumed to be EUROPEAN, and
     * so the digits will not shape.
     * @param ranges the specified Unicode ranges
     * @return a shaper for the specified ranges
     */
    public static NumericShaper getContextualShaper(int ranges) {
<span class="nc" id="L978">        ranges |= CONTEXTUAL_MASK;</span>
<span class="nc" id="L979">        return new NumericShaper(EUROPEAN_KEY, ranges);</span>
    }

    /**
     * Returns a contextual shaper for the provided Unicode
     * range(s). The Latin-1 (EUROPEAN) digits are converted to the
     * decimal digits corresponding to the range of the preceding
     * text, if the range is one of the provided ranges.
     *
     * &lt;p&gt;The shaper assumes EUROPEAN as the starting context, that
     * is, if EUROPEAN digits are encountered before any strong
     * directional text in the string, the context is presumed to be
     * EUROPEAN, and so the digits will not shape.
     *
     * @param ranges the specified Unicode ranges
     * @return a contextual shaper for the specified ranges
     * @throws NullPointerException if {@code ranges} is {@code null}.
     * @since 1.7
     */
    public static NumericShaper getContextualShaper(Set&lt;Range&gt; ranges) {
<span class="nc" id="L999">        NumericShaper shaper = new NumericShaper(Range.EUROPEAN, ranges);</span>
<span class="nc" id="L1000">        shaper.mask = CONTEXTUAL_MASK;</span>
<span class="nc" id="L1001">        return shaper;</span>
    }

    /**
     * Returns a contextual shaper for the provided unicode range(s).
     * Latin-1 (EUROPEAN) digits will be converted to the decimal digits
     * corresponding to the range of the preceding text, if the
     * range is one of the provided ranges.  Multiple ranges are
     * represented by or-ing the values together, for example,
     * &lt;code&gt;NumericShaper.ARABIC | NumericShaper.THAI&lt;/code&gt;.  The
     * shaper uses defaultContext as the starting context.
     * @param ranges the specified Unicode ranges
     * @param defaultContext the starting context, such as
     * &lt;code&gt;NumericShaper.EUROPEAN&lt;/code&gt;
     * @return a shaper for the specified Unicode ranges.
     * @throws IllegalArgumentException if the specified
     * &lt;code&gt;defaultContext&lt;/code&gt; is not a single valid range.
     */
    public static NumericShaper getContextualShaper(int ranges, int defaultContext) {
<span class="nc" id="L1020">        int key = getKeyFromMask(defaultContext);</span>
<span class="nc" id="L1021">        ranges |= CONTEXTUAL_MASK;</span>
<span class="nc" id="L1022">        return new NumericShaper(key, ranges);</span>
    }

    /**
     * Returns a contextual shaper for the provided Unicode range(s).
     * The Latin-1 (EUROPEAN) digits will be converted to the decimal
     * digits corresponding to the range of the preceding text, if the
     * range is one of the provided ranges. The shaper uses {@code
     * defaultContext} as the starting context.
     *
     * @param ranges the specified Unicode ranges
     * @param defaultContext the starting context, such as
     *                       {@code NumericShaper.Range.EUROPEAN}
     * @return a contextual shaper for the specified Unicode ranges.
     * @throws NullPointerException
     *         if {@code ranges} or {@code defaultContext} is {@code null}
     * @since 1.7
     */
    public static NumericShaper getContextualShaper(Set&lt;Range&gt; ranges,
                                                    Range defaultContext) {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (defaultContext == null) {</span>
<span class="nc" id="L1043">            throw new NullPointerException();</span>
        }
<span class="nc" id="L1045">        NumericShaper shaper = new NumericShaper(defaultContext, ranges);</span>
<span class="nc" id="L1046">        shaper.mask = CONTEXTUAL_MASK;</span>
<span class="nc" id="L1047">        return shaper;</span>
    }

    /**
     * Private constructor.
     */
<span class="nc" id="L1053">    private NumericShaper(int key, int mask) {</span>
<span class="nc" id="L1054">        this.key = key;</span>
<span class="nc" id="L1055">        this.mask = mask;</span>
<span class="nc" id="L1056">    }</span>

<span class="nc" id="L1058">    private NumericShaper(Range defaultContext, Set&lt;Range&gt; ranges) {</span>
<span class="nc" id="L1059">        shapingRange = defaultContext;</span>
<span class="nc" id="L1060">        rangeSet = EnumSet.copyOf(ranges); // throws NPE if ranges is null.</span>

        // Give precedance to EASTERN_ARABIC if both ARABIC and
        // EASTERN_ARABIC are specified.
<span class="nc bnc" id="L1064" title="All 2 branches missed.">        if (rangeSet.contains(Range.EASTERN_ARABIC)</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            &amp;&amp; rangeSet.contains(Range.ARABIC)) {</span>
<span class="nc" id="L1066">            rangeSet.remove(Range.ARABIC);</span>
        }

        // As well as the above case, give precedance to TAI_THAM_THAM if both
        // TAI_THAM_HORA and TAI_THAM_THAM are specified.
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (rangeSet.contains(Range.TAI_THAM_THAM)</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            &amp;&amp; rangeSet.contains(Range.TAI_THAM_HORA)) {</span>
<span class="nc" id="L1073">            rangeSet.remove(Range.TAI_THAM_HORA);</span>
        }

<span class="nc" id="L1076">        rangeArray = rangeSet.toArray(new Range[rangeSet.size()]);</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (rangeArray.length &gt; BSEARCH_THRESHOLD) {</span>
            // sort rangeArray for binary search
<span class="nc" id="L1079">            Arrays.sort(rangeArray,</span>
<span class="nc" id="L1080">                        new Comparator&lt;Range&gt;() {</span>
                            public int compare(Range s1, Range s2) {
<span class="nc bnc" id="L1082" title="All 4 branches missed.">                                return s1.base &gt; s2.base ? 1 : s1.base == s2.base ? 0 : -1;</span>
                            }
                        });
        }
<span class="nc" id="L1086">    }</span>

    /**
     * Converts the digits in the text that occur between start and
     * start + count.
     * @param text an array of characters to convert
     * @param start the index into &lt;code&gt;text&lt;/code&gt; to start
     *        converting
     * @param count the number of characters in &lt;code&gt;text&lt;/code&gt;
     *        to convert
     * @throws IndexOutOfBoundsException if start or start + count is
     *        out of bounds
     * @throws NullPointerException if text is null
     */
    public void shape(char[] text, int start, int count) {
<span class="nc" id="L1101">        checkParams(text, start, count);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (isContextual()) {</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (rangeSet == null) {</span>
<span class="nc" id="L1104">                shapeContextually(text, start, count, key);</span>
            } else {
<span class="nc" id="L1106">                shapeContextually(text, start, count, shapingRange);</span>
            }
        } else {
<span class="nc" id="L1109">            shapeNonContextually(text, start, count);</span>
        }
<span class="nc" id="L1111">    }</span>

    /**
     * Converts the digits in the text that occur between start and
     * start + count, using the provided context.
     * Context is ignored if the shaper is not a contextual shaper.
     * @param text an array of characters
     * @param start the index into &lt;code&gt;text&lt;/code&gt; to start
     *        converting
     * @param count the number of characters in &lt;code&gt;text&lt;/code&gt;
     *        to convert
     * @param context the context to which to convert the
     *        characters, such as &lt;code&gt;NumericShaper.EUROPEAN&lt;/code&gt;
     * @throws IndexOutOfBoundsException if start or start + count is
     *        out of bounds
     * @throws NullPointerException if text is null
     * @throws IllegalArgumentException if this is a contextual shaper
     * and the specified &lt;code&gt;context&lt;/code&gt; is not a single valid
     * range.
     */
    public void shape(char[] text, int start, int count, int context) {
<span class="nc" id="L1132">        checkParams(text, start, count);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">        if (isContextual()) {</span>
<span class="nc" id="L1134">            int ctxKey = getKeyFromMask(context);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">            if (rangeSet == null) {</span>
<span class="nc" id="L1136">                shapeContextually(text, start, count, ctxKey);</span>
            } else {
<span class="nc" id="L1138">                shapeContextually(text, start, count, Range.values()[ctxKey]);</span>
            }
<span class="nc" id="L1140">        } else {</span>
<span class="nc" id="L1141">            shapeNonContextually(text, start, count);</span>
        }
<span class="nc" id="L1143">    }</span>

    /**
     * Converts the digits in the text that occur between {@code
     * start} and {@code start + count}, using the provided {@code
     * context}. {@code Context} is ignored if the shaper is not a
     * contextual shaper.
     *
     * @param text  a {@code char} array
     * @param start the index into {@code text} to start converting
     * @param count the number of {@code char}s in {@code text}
     *              to convert
     * @param context the context to which to convert the characters,
     *                such as {@code NumericShaper.Range.EUROPEAN}
     * @throws IndexOutOfBoundsException
     *         if {@code start} or {@code start + count} is out of bounds
     * @throws NullPointerException
     *         if {@code text} or {@code context} is null
     * @since 1.7
     */
    public void shape(char[] text, int start, int count, Range context) {
<span class="nc" id="L1164">        checkParams(text, start, count);</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L1166">            throw new NullPointerException(&quot;context is null&quot;);</span>
        }

<span class="nc bnc" id="L1169" title="All 2 branches missed.">        if (isContextual()) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (rangeSet != null) {</span>
<span class="nc" id="L1171">                shapeContextually(text, start, count, context);</span>
            } else {
<span class="nc" id="L1173">                int key = Range.toRangeIndex(context);</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">                if (key &gt;= 0) {</span>
<span class="nc" id="L1175">                    shapeContextually(text, start, count, key);</span>
                } else {
<span class="nc" id="L1177">                    shapeContextually(text, start, count, shapingRange);</span>
                }
<span class="nc" id="L1179">            }</span>
        } else {
<span class="nc" id="L1181">            shapeNonContextually(text, start, count);</span>
        }
<span class="nc" id="L1183">    }</span>

    private void checkParams(char[] text, int start, int count) {
<span class="nc bnc" id="L1186" title="All 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L1187">            throw new NullPointerException(&quot;text is null&quot;);</span>
        }
<span class="nc bnc" id="L1189" title="All 8 branches missed.">        if ((start &lt; 0)</span>
            || (start &gt; text.length)
            || ((start + count) &lt; 0)
            || ((start + count) &gt; text.length)) {
<span class="nc" id="L1193">            throw new IndexOutOfBoundsException(</span>
                &quot;bad start or count for text of length &quot; + text.length);
        }
<span class="nc" id="L1196">    }</span>

    /**
     * Returns a &lt;code&gt;boolean&lt;/code&gt; indicating whether or not
     * this shaper shapes contextually.
     * @return &lt;code&gt;true&lt;/code&gt; if this shaper is contextual;
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isContextual() {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">        return (mask &amp; CONTEXTUAL_MASK) != 0;</span>
    }

    /**
     * Returns an &lt;code&gt;int&lt;/code&gt; that ORs together the values for
     * all the ranges that will be shaped.
     * &lt;p&gt;
     * For example, to check if a shaper shapes to Arabic, you would use the
     * following:
     * &lt;blockquote&gt;
     *   &lt;code&gt;if ((shaper.getRanges() &amp;amp; shaper.ARABIC) != 0) { ... &lt;/code&gt;
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt;Note that this method supports only the bit mask-based
     * ranges. Call {@link #getRangeSet()} for the enum-based ranges.
     *
     * @return the values for all the ranges to be shaped.
     */
    public int getRanges() {
<span class="nc" id="L1224">        return mask &amp; ~CONTEXTUAL_MASK;</span>
    }

    /**
     * Returns a {@code Set} representing all the Unicode ranges in
     * this {@code NumericShaper} that will be shaped.
     *
     * @return all the Unicode ranges to be shaped.
     * @since 1.7
     */
    public Set&lt;Range&gt; getRangeSet() {
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (rangeSet != null) {</span>
<span class="nc" id="L1236">            return EnumSet.copyOf(rangeSet);</span>
        }
<span class="nc" id="L1238">        return Range.maskToRangeSet(mask);</span>
    }

    /**
     * Perform non-contextual shaping.
     */
    private void shapeNonContextually(char[] text, int start, int count) {
        int base;
<span class="nc" id="L1246">        char minDigit = '0';</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if (shapingRange != null) {</span>
<span class="nc" id="L1248">            base = shapingRange.getDigitBase();</span>
<span class="nc" id="L1249">            minDigit += shapingRange.getNumericBase();</span>
        } else {
<span class="nc" id="L1251">            base = bases[key];</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            if (key == ETHIOPIC_KEY) {</span>
<span class="nc" id="L1253">                minDigit++; // Ethiopic doesn't use decimal zero</span>
            }
        }
<span class="nc bnc" id="L1256" title="All 2 branches missed.">        for (int i = start, e = start + count; i &lt; e; ++i) {</span>
<span class="nc" id="L1257">            char c = text[i];</span>
<span class="nc bnc" id="L1258" title="All 4 branches missed.">            if (c &gt;= minDigit &amp;&amp; c &lt;= '\u0039') {</span>
<span class="nc" id="L1259">                text[i] = (char)(c + base);</span>
            }
        }
<span class="nc" id="L1262">    }</span>

    /**
     * Perform contextual shaping.
     * Synchronized to protect caches used in getContextKey.
     */
    private synchronized void shapeContextually(char[] text, int start, int count, int ctxKey) {

        // if we don't support this context, then don't shape
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if ((mask &amp; (1&lt;&lt;ctxKey)) == 0) {</span>
<span class="nc" id="L1272">            ctxKey = EUROPEAN_KEY;</span>
        }
<span class="nc" id="L1274">        int lastkey = ctxKey;</span>

<span class="nc" id="L1276">        int base = bases[ctxKey];</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">        char minDigit = ctxKey == ETHIOPIC_KEY ? '1' : '0'; // Ethiopic doesn't use decimal zero</span>

<span class="nc" id="L1279">        synchronized (NumericShaper.class) {</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">            for (int i = start, e = start + count; i &lt; e; ++i) {</span>
<span class="nc" id="L1281">                char c = text[i];</span>
<span class="nc bnc" id="L1282" title="All 4 branches missed.">                if (c &gt;= minDigit &amp;&amp; c &lt;= '\u0039') {</span>
<span class="nc" id="L1283">                    text[i] = (char)(c + base);</span>
                }

<span class="nc bnc" id="L1286" title="All 2 branches missed.">                if (isStrongDirectional(c)) {</span>
<span class="nc" id="L1287">                    int newkey = getContextKey(c);</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">                    if (newkey != lastkey) {</span>
<span class="nc" id="L1289">                        lastkey = newkey;</span>

<span class="nc" id="L1291">                        ctxKey = newkey;</span>
<span class="nc bnc" id="L1292" title="All 6 branches missed.">                        if (((mask &amp; EASTERN_ARABIC) != 0) &amp;&amp;</span>
                             (ctxKey == ARABIC_KEY ||
                              ctxKey == EASTERN_ARABIC_KEY)) {
<span class="nc" id="L1295">                            ctxKey = EASTERN_ARABIC_KEY;</span>
<span class="nc bnc" id="L1296" title="All 6 branches missed.">                        } else if (((mask &amp; ARABIC) != 0) &amp;&amp;</span>
                             (ctxKey == ARABIC_KEY ||
                              ctxKey == EASTERN_ARABIC_KEY)) {
<span class="nc" id="L1299">                            ctxKey = ARABIC_KEY;</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                        } else if ((mask &amp; (1&lt;&lt;ctxKey)) == 0) {</span>
<span class="nc" id="L1301">                            ctxKey = EUROPEAN_KEY;</span>
                        }

<span class="nc" id="L1304">                        base = bases[ctxKey];</span>

<span class="nc bnc" id="L1306" title="All 2 branches missed.">                        minDigit = ctxKey == ETHIOPIC_KEY ? '1' : '0'; // Ethiopic doesn't use decimal zero</span>
                    }
                }
            }
<span class="nc" id="L1310">        }</span>
<span class="nc" id="L1311">    }</span>

    private void shapeContextually(char[] text, int start, int count, Range ctxKey) {
        // if we don't support the specified context, then don't shape.
<span class="nc bnc" id="L1315" title="All 4 branches missed.">        if (ctxKey == null || !rangeSet.contains(ctxKey)) {</span>
<span class="nc" id="L1316">            ctxKey = Range.EUROPEAN;</span>
        }

<span class="nc" id="L1319">        Range lastKey = ctxKey;</span>
<span class="nc" id="L1320">        int base = ctxKey.getDigitBase();</span>
<span class="nc" id="L1321">        char minDigit = (char)('0' + ctxKey.getNumericBase());</span>
<span class="nc" id="L1322">        final int end = start + count;</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1324">            char c = text[i];</span>
<span class="nc bnc" id="L1325" title="All 4 branches missed.">            if (c &gt;= minDigit &amp;&amp; c &lt;= '9') {</span>
<span class="nc" id="L1326">                text[i] = (char)(c + base);</span>
<span class="nc" id="L1327">                continue;</span>
            }
<span class="nc bnc" id="L1329" title="All 2 branches missed.">            if (isStrongDirectional(c)) {</span>
<span class="nc" id="L1330">                ctxKey = rangeForCodePoint(c);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                if (ctxKey != lastKey) {</span>
<span class="nc" id="L1332">                    lastKey = ctxKey;</span>
<span class="nc" id="L1333">                    base = ctxKey.getDigitBase();</span>
<span class="nc" id="L1334">                    minDigit = (char)('0' + ctxKey.getNumericBase());</span>
                }
            }
        }
<span class="nc" id="L1338">    }</span>

    /**
     * Returns a hash code for this shaper.
     * @return this shaper's hash code.
     * @see java.lang.Object#hashCode
     */
    public int hashCode() {
<span class="nc" id="L1346">        int hash = mask;</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (rangeSet != null) {</span>
            // Use the CONTEXTUAL_MASK bit only for the enum-based
            // NumericShaper. A deserialized NumericShaper might have
            // bit masks.
<span class="nc" id="L1351">            hash &amp;= CONTEXTUAL_MASK;</span>
<span class="nc" id="L1352">            hash ^= rangeSet.hashCode();</span>
        }
<span class="nc" id="L1354">        return hash;</span>
    }

    /**
     * Returns {@code true} if the specified object is an instance of
     * &lt;code&gt;NumericShaper&lt;/code&gt; and shapes identically to this one,
     * regardless of the range representations, the bit mask or the
     * enum. For example, the following code produces {@code &quot;true&quot;}.
     * &lt;blockquote&gt;&lt;pre&gt;
     * NumericShaper ns1 = NumericShaper.getShaper(NumericShaper.ARABIC);
     * NumericShaper ns2 = NumericShaper.getShaper(NumericShaper.Range.ARABIC);
     * System.out.println(ns1.equals(ns2));
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param o the specified object to compare to this
     *          &lt;code&gt;NumericShaper&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is an instance
     *         of &lt;code&gt;NumericShaper&lt;/code&gt; and shapes in the same way;
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L1376" title="All 2 branches missed.">        if (o != null) {</span>
            try {
<span class="nc" id="L1378">                NumericShaper rhs = (NumericShaper)o;</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">                if (rangeSet != null) {</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                    if (rhs.rangeSet != null) {</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                        return isContextual() == rhs.isContextual()</span>
<span class="nc bnc" id="L1382" title="All 4 branches missed.">                            &amp;&amp; rangeSet.equals(rhs.rangeSet)</span>
                            &amp;&amp; shapingRange == rhs.shapingRange;
                    }
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                    return isContextual() == rhs.isContextual()</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                        &amp;&amp; rangeSet.equals(Range.maskToRangeSet(rhs.mask))</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                        &amp;&amp; shapingRange == Range.indexToRange(rhs.key);</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">                } else if (rhs.rangeSet != null) {</span>
<span class="nc" id="L1389">                    Set&lt;Range&gt; rset = Range.maskToRangeSet(mask);</span>
<span class="nc" id="L1390">                    Range srange = Range.indexToRange(key);</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">                    return isContextual() == rhs.isContextual()</span>
<span class="nc bnc" id="L1392" title="All 4 branches missed.">                        &amp;&amp; rset.equals(rhs.rangeSet)</span>
                        &amp;&amp; srange == rhs.shapingRange;
                }
<span class="nc bnc" id="L1395" title="All 4 branches missed.">                return rhs.mask == mask &amp;&amp; rhs.key == key;</span>
            }
<span class="nc" id="L1397">            catch (ClassCastException e) {</span>
            }
        }
<span class="nc" id="L1400">        return false;</span>
    }

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; that describes this shaper. This method
     * is used for debugging purposes only.
     * @return a &lt;code&gt;String&lt;/code&gt; describing this shaper.
     */
    public String toString() {
<span class="nc" id="L1409">        StringBuilder buf = new StringBuilder(super.toString());</span>

<span class="nc" id="L1411">        buf.append(&quot;[contextual:&quot;).append(isContextual());</span>

<span class="nc" id="L1413">        String[] keyNames = null;</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        if (isContextual()) {</span>
<span class="nc" id="L1415">            buf.append(&quot;, context:&quot;);</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            buf.append(shapingRange == null ? Range.values()[key] : shapingRange);</span>
        }

<span class="nc bnc" id="L1419" title="All 2 branches missed.">        if (rangeSet == null) {</span>
<span class="nc" id="L1420">            buf.append(&quot;, range(s): &quot;);</span>
<span class="nc" id="L1421">            boolean first = true;</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">            for (int i = 0; i &lt; NUM_KEYS; ++i) {</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                if ((mask &amp; (1 &lt;&lt; i)) != 0) {</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">                    if (first) {</span>
<span class="nc" id="L1425">                        first = false;</span>
                    } else {
<span class="nc" id="L1427">                        buf.append(&quot;, &quot;);</span>
                    }
<span class="nc" id="L1429">                    buf.append(Range.values()[i]);</span>
                }
            }
<span class="nc" id="L1432">        } else {</span>
<span class="nc" id="L1433">            buf.append(&quot;, range set: &quot;).append(rangeSet);</span>
        }
<span class="nc" id="L1435">        buf.append(']');</span>

<span class="nc" id="L1437">        return buf.toString();</span>
    }

    /**
     * Returns the index of the high bit in value (assuming le, actually
     * power of 2 &gt;= value). value must be positive.
     */
    private static int getHighBit(int value) {
<span class="nc bnc" id="L1445" title="All 2 branches missed.">        if (value &lt;= 0) {</span>
<span class="nc" id="L1446">            return -32;</span>
        }

<span class="nc" id="L1449">        int bit = 0;</span>

<span class="nc bnc" id="L1451" title="All 2 branches missed.">        if (value &gt;= 1 &lt;&lt; 16) {</span>
<span class="nc" id="L1452">            value &gt;&gt;= 16;</span>
<span class="nc" id="L1453">            bit += 16;</span>
        }

<span class="nc bnc" id="L1456" title="All 2 branches missed.">        if (value &gt;= 1 &lt;&lt; 8) {</span>
<span class="nc" id="L1457">            value &gt;&gt;= 8;</span>
<span class="nc" id="L1458">            bit += 8;</span>
        }

<span class="nc bnc" id="L1461" title="All 2 branches missed.">        if (value &gt;= 1 &lt;&lt; 4) {</span>
<span class="nc" id="L1462">            value &gt;&gt;= 4;</span>
<span class="nc" id="L1463">            bit += 4;</span>
        }

<span class="nc bnc" id="L1466" title="All 2 branches missed.">        if (value &gt;= 1 &lt;&lt; 2) {</span>
<span class="nc" id="L1467">            value &gt;&gt;= 2;</span>
<span class="nc" id="L1468">            bit += 2;</span>
        }

<span class="nc bnc" id="L1471" title="All 2 branches missed.">        if (value &gt;= 1 &lt;&lt; 1) {</span>
<span class="nc" id="L1472">            bit += 1;</span>
        }

<span class="nc" id="L1475">        return bit;</span>
    }

    /**
     * fast binary search over subrange of array.
     */
    private static int search(int value, int[] array, int start, int length)
    {
<span class="nc" id="L1483">        int power = 1 &lt;&lt; getHighBit(length);</span>
<span class="nc" id="L1484">        int extra = length - power;</span>
<span class="nc" id="L1485">        int probe = power;</span>
<span class="nc" id="L1486">        int index = start;</span>

<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (value &gt;= array[index + extra]) {</span>
<span class="nc" id="L1489">            index += extra;</span>
        }

<span class="nc bnc" id="L1492" title="All 2 branches missed.">        while (probe &gt; 1) {</span>
<span class="nc" id="L1493">            probe &gt;&gt;= 1;</span>

<span class="nc bnc" id="L1495" title="All 2 branches missed.">            if (value &gt;= array[index + probe]) {</span>
<span class="nc" id="L1496">                index += probe;</span>
            }
        }

<span class="nc" id="L1500">        return index;</span>
    }

    /**
     * Converts the {@code NumericShaper.Range} enum-based parameters,
     * if any, to the bit mask-based counterparts and writes this
     * object to the {@code stream}. Any enum constants that have no
     * bit mask-based counterparts are ignored in the conversion.
     *
     * @param stream the output stream to write to
     * @throws IOException if an I/O error occurs while writing to {@code stream}
     * @since 1.7
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
<span class="nc bnc" id="L1514" title="All 2 branches missed.">        if (shapingRange != null) {</span>
<span class="nc" id="L1515">            int index = Range.toRangeIndex(shapingRange);</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            if (index &gt;= 0) {</span>
<span class="nc" id="L1517">                key = index;</span>
            }
        }
<span class="nc bnc" id="L1520" title="All 2 branches missed.">        if (rangeSet != null) {</span>
<span class="nc" id="L1521">            mask |= Range.toRangeMask(rangeSet);</span>
        }
<span class="nc" id="L1523">        stream.defaultWriteObject();</span>
<span class="nc" id="L1524">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>