<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SSLContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.net.ssl</a> &gt; <span class="el_source">SSLContext.java</span></div><h1>SSLContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.net.ssl;

import java.security.*;

import sun.security.jca.GetInstance;

/**
 * Instances of this class represent a secure socket protocol
 * implementation which acts as a factory for secure socket
 * factories or &lt;code&gt;SSLEngine&lt;/code&gt;s. This class is initialized
 * with an optional set of key and trust managers and source of
 * secure random bytes.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support the
 * following standard &lt;code&gt;SSLContext&lt;/code&gt; protocol:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;tt&gt;TLSv1&lt;/tt&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * This protocol is described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SSLContext&quot;&gt;
 * SSLContext section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other algorithms are supported.
 *
 * @since 1.4
 */
public class SSLContext {
    private final Provider provider;

    private final SSLContextSpi contextSpi;

    private final String protocol;

    /**
     * Creates an SSLContext object.
     *
     * @param contextSpi the delegate
     * @param provider the provider
     * @param protocol the protocol
     */
    protected SSLContext(SSLContextSpi contextSpi, Provider provider,
<span class="fc" id="L68">            String protocol) {</span>
<span class="fc" id="L69">        this.contextSpi = contextSpi;</span>
<span class="fc" id="L70">        this.provider = provider;</span>
<span class="fc" id="L71">        this.protocol = protocol;</span>
<span class="fc" id="L72">    }</span>

    private static SSLContext defaultContext;

    /**
     * Returns the default SSL context.
     *
     * &lt;p&gt;If a default context was set using the {@link #setDefault
     * SSLContext.setDefault()} method, it is returned. Otherwise, the first
     * call of this method triggers the call
     * &lt;code&gt;SSLContext.getInstance(&quot;Default&quot;)&lt;/code&gt;.
     * If successful, that object is made the default SSL context and returned.
     *
     * &lt;p&gt;The default context is immediately
     * usable and does not require {@linkplain #init initialization}.
     *
     * @return the default SSL context
     * @throws NoSuchAlgorithmException if the
     *   {@link SSLContext#getInstance SSLContext.getInstance()} call fails
     * @since 1.6
     */
    public static synchronized SSLContext getDefault()
            throws NoSuchAlgorithmException {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (defaultContext == null) {</span>
<span class="fc" id="L96">            defaultContext = SSLContext.getInstance(&quot;Default&quot;);</span>
        }
<span class="fc" id="L98">        return defaultContext;</span>
    }

    /**
     * Sets the default SSL context. It will be returned by subsequent calls
     * to {@link #getDefault}. The default context must be immediately usable
     * and not require {@linkplain #init initialization}.
     *
     * @param context the SSLContext
     * @throws  NullPointerException if context is null
     * @throws  SecurityException if a security manager exists and its
     *          &lt;code&gt;checkPermission&lt;/code&gt; method does not allow
     *          &lt;code&gt;SSLPermission(&quot;setDefaultSSLContext&quot;)&lt;/code&gt;
     * @since 1.6
     */
    public static synchronized void setDefault(SSLContext context) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L115">            throw new NullPointerException();</span>
        }
<span class="fc" id="L117">        SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L119">            sm.checkPermission(new SSLPermission(&quot;setDefaultSSLContext&quot;));</span>
        }
<span class="fc" id="L121">        defaultContext = context;</span>
<span class="fc" id="L122">    }</span>

    /**
     * Returns a &lt;code&gt;SSLContext&lt;/code&gt; object that implements the
     * specified secure socket protocol.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new SSLContext object encapsulating the
     * SSLContextSpi implementation from the first
     * Provider that supports the specified protocol is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param protocol the standard name of the requested protocol.
     *          See the SSLContext section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SSLContext&quot;&gt;
     *          Java Cryptography Architecture Standard Algorithm Name
     *          Documentation&lt;/a&gt;
     *          for information about standard protocol names.
     *
     * @return the new &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          SSLContextSpi implementation for the
     *          specified protocol.
     * @exception NullPointerException if protocol is null.
     *
     * @see java.security.Provider
     */
    public static SSLContext getInstance(String protocol)
            throws NoSuchAlgorithmException {
<span class="fc" id="L155">        GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L156">                (&quot;SSLContext&quot;, SSLContextSpi.class, protocol);</span>
<span class="fc" id="L157">        return new SSLContext((SSLContextSpi)instance.impl, instance.provider,</span>
                protocol);
    }

    /**
     * Returns a &lt;code&gt;SSLContext&lt;/code&gt; object that implements the
     * specified secure socket protocol.
     *
     * &lt;p&gt; A new SSLContext object encapsulating the
     * SSLContextSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param protocol the standard name of the requested protocol.
     *          See the SSLContext section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SSLContext&quot;&gt;
     *          Java Cryptography Architecture Standard Algorithm Name
     *          Documentation&lt;/a&gt;
     *          for information about standard protocol names.
     *
     * @param provider the name of the provider.
     *
     * @return the new &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * @throws NoSuchAlgorithmException if a SSLContextSpi
     *          implementation for the specified protocol is not
     *          available from the specified provider.
     *
     * @throws NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @throws IllegalArgumentException if the provider name is null or empty.
     * @throws NullPointerException if protocol is null.
     *
     * @see java.security.Provider
     */
    public static SSLContext getInstance(String protocol, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="nc" id="L198">        GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="nc" id="L199">                (&quot;SSLContext&quot;, SSLContextSpi.class, protocol, provider);</span>
<span class="nc" id="L200">        return new SSLContext((SSLContextSpi)instance.impl, instance.provider,</span>
                protocol);
    }

    /**
     * Returns a &lt;code&gt;SSLContext&lt;/code&gt; object that implements the
     * specified secure socket protocol.
     *
     * &lt;p&gt; A new SSLContext object encapsulating the
     * SSLContextSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param protocol the standard name of the requested protocol.
     *          See the SSLContext section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SSLContext&quot;&gt;
     *          Java Cryptography Architecture Standard Algorithm Name
     *          Documentation&lt;/a&gt;
     *          for information about standard protocol names.
     *
     * @param provider an instance of the provider.
     *
     * @return the new &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * @throws NoSuchAlgorithmException if a SSLContextSpi
     *          implementation for the specified protocol is not available
     *          from the specified Provider object.
     *
     * @throws IllegalArgumentException if the provider is null.
     * @throws NullPointerException if protocol is null.
     *
     * @see java.security.Provider
     */
    public static SSLContext getInstance(String protocol, Provider provider)
            throws NoSuchAlgorithmException {
<span class="fc" id="L235">        GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L236">                (&quot;SSLContext&quot;, SSLContextSpi.class, protocol, provider);</span>
<span class="fc" id="L237">        return new SSLContext((SSLContextSpi)instance.impl, instance.provider,</span>
                protocol);
    }

    /**
     * Returns the protocol name of this &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * &lt;p&gt;This is the same name that was specified in one of the
     * &lt;code&gt;getInstance&lt;/code&gt; calls that created this
     * &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * @return the protocol name of this &lt;code&gt;SSLContext&lt;/code&gt; object.
     */
    public final String getProtocol() {
<span class="nc" id="L251">        return this.protocol;</span>
    }

    /**
     * Returns the provider of this &lt;code&gt;SSLContext&lt;/code&gt; object.
     *
     * @return the provider of this &lt;code&gt;SSLContext&lt;/code&gt; object
     */
    public final Provider getProvider() {
<span class="nc" id="L260">        return this.provider;</span>
    }

    /**
     * Initializes this context. Either of the first two parameters
     * may be null in which case the installed security providers will
     * be searched for the highest priority implementation of the
     * appropriate factory. Likewise, the secure random parameter may
     * be null in which case the default implementation will be used.
     * &lt;P&gt;
     * Only the first instance of a particular key and/or trust manager
     * implementation type in the array is used.  (For example, only
     * the first javax.net.ssl.X509KeyManager in the array will be used.)
     *
     * @param km the sources of authentication keys or null
     * @param tm the sources of peer authentication trust decisions or null
     * @param random the source of randomness for this generator or null
     * @throws KeyManagementException if this operation fails
     */
    public final void init(KeyManager[] km, TrustManager[] tm,
                                SecureRandom random)
        throws KeyManagementException {
<span class="fc" id="L282">        contextSpi.engineInit(km, tm, random);</span>
<span class="fc" id="L283">    }</span>

    /**
     * Returns a &lt;code&gt;SocketFactory&lt;/code&gt; object for this
     * context.
     *
     * @return the &lt;code&gt;SocketFactory&lt;/code&gt; object
     * @throws IllegalStateException if the SSLContextImpl requires
     *          initialization and the &lt;code&gt;init()&lt;/code&gt; has not been called
     */
    public final SSLSocketFactory getSocketFactory() {
<span class="fc" id="L294">        return contextSpi.engineGetSocketFactory();</span>
    }

    /**
     * Returns a &lt;code&gt;ServerSocketFactory&lt;/code&gt; object for
     * this context.
     *
     * @return the &lt;code&gt;ServerSocketFactory&lt;/code&gt; object
     * @throws IllegalStateException if the SSLContextImpl requires
     *          initialization and the &lt;code&gt;init()&lt;/code&gt; has not been called
     */
    public final SSLServerSocketFactory getServerSocketFactory() {
<span class="fc" id="L306">        return contextSpi.engineGetServerSocketFactory();</span>
    }

    /**
     * Creates a new &lt;code&gt;SSLEngine&lt;/code&gt; using this context.
     * &lt;P&gt;
     * Applications using this factory method are providing no hints
     * for an internal session reuse strategy. If hints are desired,
     * {@link #createSSLEngine(String, int)} should be used
     * instead.
     * &lt;P&gt;
     * Some cipher suites (such as Kerberos) require remote hostname
     * information, in which case this factory method should not be used.
     *
     * @return  the &lt;code&gt;SSLEngine&lt;/code&gt; object
     * @throws  UnsupportedOperationException if the underlying provider
     *          does not implement the operation.
     * @throws  IllegalStateException if the SSLContextImpl requires
     *          initialization and the &lt;code&gt;init()&lt;/code&gt; has not been called
     * @since   1.5
     */
    public final SSLEngine createSSLEngine() {
        try {
<span class="fc" id="L329">            return contextSpi.engineCreateSSLEngine();</span>
<span class="nc" id="L330">        } catch (AbstractMethodError e) {</span>
<span class="nc" id="L331">            UnsupportedOperationException unsup =</span>
                new UnsupportedOperationException(
<span class="nc" id="L333">                    &quot;Provider: &quot; + getProvider() +</span>
                    &quot; doesn't support this operation&quot;);
<span class="nc" id="L335">            unsup.initCause(e);</span>
<span class="nc" id="L336">            throw unsup;</span>
        }
    }

    /**
     * Creates a new &lt;code&gt;SSLEngine&lt;/code&gt; using this context using
     * advisory peer information.
     * &lt;P&gt;
     * Applications using this factory method are providing hints
     * for an internal session reuse strategy.
     * &lt;P&gt;
     * Some cipher suites (such as Kerberos) require remote hostname
     * information, in which case peerHost needs to be specified.
     *
     * @param   peerHost the non-authoritative name of the host
     * @param   peerPort the non-authoritative port
     * @return  the new &lt;code&gt;SSLEngine&lt;/code&gt; object
     * @throws  UnsupportedOperationException if the underlying provider
     *          does not implement the operation.
     * @throws  IllegalStateException if the SSLContextImpl requires
     *          initialization and the &lt;code&gt;init()&lt;/code&gt; has not been called
     * @since   1.5
     */
    public final SSLEngine createSSLEngine(String peerHost, int peerPort) {
        try {
<span class="fc" id="L361">            return contextSpi.engineCreateSSLEngine(peerHost, peerPort);</span>
<span class="nc" id="L362">        } catch (AbstractMethodError e) {</span>
<span class="nc" id="L363">            UnsupportedOperationException unsup =</span>
                new UnsupportedOperationException(
<span class="nc" id="L365">                    &quot;Provider: &quot; + getProvider() +</span>
                    &quot; does not support this operation&quot;);
<span class="nc" id="L367">            unsup.initCause(e);</span>
<span class="nc" id="L368">            throw unsup;</span>
        }
    }

    /**
     * Returns the server session context, which represents the set of
     * SSL sessions available for use during the handshake phase of
     * server-side SSL sockets.
     * &lt;P&gt;
     * This context may be unavailable in some environments, in which
     * case this method returns null. For example, when the underlying
     * SSL provider does not provide an implementation of SSLSessionContext
     * interface, this method returns null. A non-null session context
     * is returned otherwise.
     *
     * @return server session context bound to this SSL context
     */
    public final SSLSessionContext getServerSessionContext() {
<span class="fc" id="L386">        return contextSpi.engineGetServerSessionContext();</span>
    }

    /**
     * Returns the client session context, which represents the set of
     * SSL sessions available for use during the handshake phase of
     * client-side SSL sockets.
     * &lt;P&gt;
     * This context may be unavailable in some environments, in which
     * case this method returns null. For example, when the underlying
     * SSL provider does not provide an implementation of SSLSessionContext
     * interface, this method returns null. A non-null session context
     * is returned otherwise.
     *
     * @return client session context bound to this SSL context
     */
    public final SSLSessionContext getClientSessionContext() {
<span class="fc" id="L403">        return contextSpi.engineGetClientSessionContext();</span>
    }

    /**
     * Returns a copy of the SSLParameters indicating the default
     * settings for this SSL context.
     *
     * &lt;p&gt;The parameters will always have the ciphersuites and protocols
     * arrays set to non-null values.
     *
     * @return a copy of the SSLParameters object with the default settings
     * @throws UnsupportedOperationException if the default SSL parameters
     *   could not be obtained.
     * @since 1.6
     */
    public final SSLParameters getDefaultSSLParameters() {
<span class="fc" id="L419">        return contextSpi.engineGetDefaultSSLParameters();</span>
    }

    /**
     * Returns a copy of the SSLParameters indicating the supported
     * settings for this SSL context.
     *
     * &lt;p&gt;The parameters will always have the ciphersuites and protocols
     * arrays set to non-null values.
     *
     * @return a copy of the SSLParameters object with the supported
     *   settings
     * @throws UnsupportedOperationException if the supported SSL parameters
     *   could not be obtained.
     * @since 1.6
     */
    public final SSLParameters getSupportedSSLParameters() {
<span class="fc" id="L436">        return contextSpi.engineGetSupportedSSLParameters();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>