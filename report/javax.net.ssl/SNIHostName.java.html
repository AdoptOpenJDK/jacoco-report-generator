<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SNIHostName.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.net.ssl</a> &gt; <span class="el_source">SNIHostName.java</span></div><h1>SNIHostName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.net.ssl;

import java.net.IDN;
import java.nio.ByteBuffer;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharacterCodingException;
import java.util.Locale;
import java.util.Objects;
import java.util.regex.Pattern;

/**
 * Instances of this class represent a server name of type
 * {@link StandardConstants#SNI_HOST_NAME host_name} in a Server Name
 * Indication (SNI) extension.
 * &lt;P&gt;
 * As described in section 3, &quot;Server Name Indication&quot;, of
 * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/A&gt;,
 * &quot;HostName&quot; contains the fully qualified DNS hostname of the server, as
 * understood by the client.  The encoded server name value of a hostname is
 * represented as a byte string using ASCII encoding without a trailing dot.
 * This allows the support of Internationalized Domain Names (IDN) through
 * the use of A-labels (the ASCII-Compatible Encoding (ACE) form of a valid
 * string of Internationalized Domain Names for Applications (IDNA)) defined
 * in &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890&lt;/A&gt;.
 * &lt;P&gt;
 * Note that {@code SNIHostName} objects are immutable.
 *
 * @see SNIServerName
 * @see StandardConstants#SNI_HOST_NAME
 *
 * @since 1.8
 */
public final class SNIHostName extends SNIServerName {

    // the decoded string value of the server name
    private final String hostname;

    /**
     * Creates an {@code SNIHostName} using the specified hostname.
     * &lt;P&gt;
     * Note that per &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/A&gt;,
     * the encoded server name value of a hostname is
     * {@link StandardCharsets#US_ASCII}-compliant.  In this method,
     * {@code hostname} can be a user-friendly Internationalized Domain Name
     * (IDN).  {@link IDN#toASCII(String, int)} is used to enforce the
     * restrictions on ASCII characters in hostnames (see
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/A&gt;,
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/A&gt;,
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/A&gt;) and
     * translate the {@code hostname} into ASCII Compatible Encoding (ACE), as:
     * &lt;pre&gt;
     *     IDN.toASCII(hostname, IDN.USE_STD3_ASCII_RULES);
     * &lt;/pre&gt;
     * &lt;P&gt;
     * The {@code hostname} argument is illegal if it:
     * &lt;ul&gt;
     * &lt;li&gt; {@code hostname} is empty,&lt;/li&gt;
     * &lt;li&gt; {@code hostname} ends with a trailing dot,&lt;/li&gt;
     * &lt;li&gt; {@code hostname} is not a valid Internationalized
     *      Domain Name (IDN) compliant with the RFC 3490 specification.&lt;/li&gt;
     * &lt;/ul&gt;
     * @param  hostname
     *         the hostname of this server name
     *
     * @throws NullPointerException if {@code hostname} is {@code null}
     * @throws IllegalArgumentException if {@code hostname} is illegal
     */
    public SNIHostName(String hostname) {
        // IllegalArgumentException will be thrown if {@code hostname} is
        // not a valid IDN.
<span class="nc" id="L98">        super(StandardConstants.SNI_HOST_NAME,</span>
<span class="nc" id="L99">                (hostname = IDN.toASCII(</span>
<span class="nc" id="L100">                    Objects.requireNonNull(hostname,</span>
                        &quot;Server name value of host_name cannot be null&quot;),
                    IDN.USE_STD3_ASCII_RULES))
<span class="nc" id="L103">                .getBytes(StandardCharsets.US_ASCII));</span>

<span class="nc" id="L105">        this.hostname = hostname;</span>

        // check the validity of the string hostname
<span class="nc" id="L108">        checkHostName();</span>
<span class="nc" id="L109">    }</span>

    /**
     * Creates an {@code SNIHostName} using the specified encoded value.
     * &lt;P&gt;
     * This method is normally used to parse the encoded name value in a
     * requested SNI extension.
     * &lt;P&gt;
     * Per &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/A&gt;,
     * the encoded name value of a hostname is
     * {@link StandardCharsets#US_ASCII}-compliant.  However, in the previous
     * version of the SNI extension (
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc4366.txt&quot;&gt;RFC 4366&lt;/A&gt;),
     * the encoded hostname is represented as a byte string using UTF-8
     * encoding.  For the purpose of version tolerance, this method allows
     * that the charset of {@code encoded} argument can be
     * {@link StandardCharsets#UTF_8}, as well as
     * {@link StandardCharsets#US_ASCII}.  {@link IDN#toASCII(String)} is used
     * to translate the {@code encoded} argument into ASCII Compatible
     * Encoding (ACE) hostname.
     * &lt;P&gt;
     * It is strongly recommended that this constructor is only used to parse
     * the encoded name value in a requested SNI extension.  Otherwise, to
     * comply with &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/A&gt;,
     * please always use {@link StandardCharsets#US_ASCII}-compliant charset
     * and enforce the restrictions on ASCII characters in hostnames (see
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/A&gt;,
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/A&gt;,
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/A&gt;)
     * for {@code encoded} argument, or use
     * {@link SNIHostName#SNIHostName(String)} instead.
     * &lt;P&gt;
     * The {@code encoded} argument is illegal if it:
     * &lt;ul&gt;
     * &lt;li&gt; {@code encoded} is empty,&lt;/li&gt;
     * &lt;li&gt; {@code encoded} ends with a trailing dot,&lt;/li&gt;
     * &lt;li&gt; {@code encoded} is not encoded in
     *      {@link StandardCharsets#US_ASCII} or
     *      {@link StandardCharsets#UTF_8}-compliant charset,&lt;/li&gt;
     * &lt;li&gt; {@code encoded} is not a valid Internationalized
     *      Domain Name (IDN) compliant with the RFC 3490 specification.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;P&gt;
     * Note that the {@code encoded} byte array is cloned
     * to protect against subsequent modification.
     *
     * @param  encoded
     *         the encoded hostname of this server name
     *
     * @throws NullPointerException if {@code encoded} is {@code null}
     * @throws IllegalArgumentException if {@code encoded} is illegal
     */
    public SNIHostName(byte[] encoded) {
        // NullPointerException will be thrown if {@code encoded} is null
<span class="fc" id="L164">        super(StandardConstants.SNI_HOST_NAME, encoded);</span>

        // Compliance: RFC 4366 requires that the hostname is represented
        // as a byte string using UTF_8 encoding [UTF8]
        try {
            // Please don't use {@link String} constructors because they
            // do not report coding errors.
<span class="nc" id="L171">            CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()</span>
<span class="nc" id="L172">                    .onMalformedInput(CodingErrorAction.REPORT)</span>
<span class="nc" id="L173">                    .onUnmappableCharacter(CodingErrorAction.REPORT);</span>

<span class="nc" id="L175">            this.hostname = IDN.toASCII(</span>
<span class="nc" id="L176">                    decoder.decode(ByteBuffer.wrap(encoded)).toString());</span>
<span class="nc" id="L177">        } catch (RuntimeException | CharacterCodingException e) {</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(</span>
                        &quot;The encoded server name value is invalid&quot;, e);
<span class="nc" id="L180">        }</span>

        // check the validity of the string hostname
<span class="nc" id="L183">        checkHostName();</span>
<span class="nc" id="L184">    }</span>

    /**
     * Returns the {@link StandardCharsets#US_ASCII}-compliant hostname of
     * this {@code SNIHostName} object.
     * &lt;P&gt;
     * Note that, per
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/A&gt;, the
     * returned hostname may be an internationalized domain name that
     * contains A-labels. See
     * &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890&lt;/A&gt;
     * for more information about the detailed A-label specification.
     *
     * @return the {@link StandardCharsets#US_ASCII}-compliant hostname
     *         of this {@code SNIHostName} object
     */
    public String getAsciiName() {
<span class="nc" id="L201">        return hostname;</span>
    }

    /**
     * Compares this server name to the specified object.
     * &lt;P&gt;
     * Per &lt;A HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/A&gt;, DNS
     * hostnames are case-insensitive.  Two server hostnames are equal if,
     * and only if, they have the same name type, and the hostnames are
     * equal in a case-independent comparison.
     *
     * @param  other
     *         the other server name object to compare with.
     * @return true if, and only if, the {@code other} is considered
     *         equal to this instance
     */
    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (this == other) {</span>
<span class="nc" id="L220">            return true;</span>
        }

<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (other instanceof SNIHostName) {</span>
<span class="nc" id="L224">            return hostname.equalsIgnoreCase(((SNIHostName)other).hostname);</span>
        }

<span class="nc" id="L227">        return false;</span>
    }

    /**
     * Returns a hash code value for this {@code SNIHostName}.
     * &lt;P&gt;
     * The hash code value is generated using the case-insensitive hostname
     * of this {@code SNIHostName}.
     *
     * @return a hash code value for this {@code SNIHostName}.
     */
    @Override
    public int hashCode() {
<span class="nc" id="L240">        int result = 17;        // 17/31: prime number to decrease collisions</span>
<span class="nc" id="L241">        result = 31 * result + hostname.toUpperCase(Locale.ENGLISH).hashCode();</span>

<span class="nc" id="L243">        return result;</span>
    }

    /**
     * Returns a string representation of the object, including the DNS
     * hostname in this {@code SNIHostName} object.
     * &lt;P&gt;
     * The exact details of the representation are unspecified and subject
     * to change, but the following may be regarded as typical:
     * &lt;pre&gt;
     *     &quot;type=host_name (0), value={@literal &lt;hostname&gt;}&quot;
     * &lt;/pre&gt;
     * The &quot;{@literal &lt;hostname&gt;}&quot; is an ASCII representation of the hostname,
     * which may contains A-labels.  For example, a returned value of an pseudo
     * hostname may look like:
     * &lt;pre&gt;
     *     &quot;type=host_name (0), value=www.example.com&quot;
     * &lt;/pre&gt;
     * or
     * &lt;pre&gt;
     *     &quot;type=host_name (0), value=xn--fsqu00a.xn--0zwm56d&quot;
     * &lt;/pre&gt;
     * &lt;P&gt;
     * Please NOTE that the exact details of the representation are unspecified
     * and subject to change.
     *
     * @return a string representation of the object.
     */
    @Override
    public String toString() {
<span class="nc" id="L273">        return &quot;type=host_name (0), value=&quot; + hostname;</span>
    }

    /**
     * Creates an {@link SNIMatcher} object for {@code SNIHostName}s.
     * &lt;P&gt;
     * This method can be used by a server to verify the acceptable
     * {@code SNIHostName}s.  For example,
     * &lt;pre&gt;
     *     SNIMatcher matcher =
     *         SNIHostName.createSNIMatcher(&quot;www\\.example\\.com&quot;);
     * &lt;/pre&gt;
     * will accept the hostname &quot;www.example.com&quot;.
     * &lt;pre&gt;
     *     SNIMatcher matcher =
     *         SNIHostName.createSNIMatcher(&quot;www\\.example\\.(com|org)&quot;);
     * &lt;/pre&gt;
     * will accept hostnames &quot;www.example.com&quot; and &quot;www.example.org&quot;.
     *
     * @param  regex
     *         the &lt;a href=&quot;{@docRoot}/java/util/regex/Pattern.html#sum&quot;&gt;
     *         regular expression pattern&lt;/a&gt;
     *         representing the hostname(s) to match
     * @return a {@code SNIMatcher} object for {@code SNIHostName}s
     * @throws NullPointerException if {@code regex} is
     *         {@code null}
     * @throws java.util.regex.PatternSyntaxException if the regular expression's
     *         syntax is invalid
     */
    public static SNIMatcher createSNIMatcher(String regex) {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (regex == null) {</span>
<span class="nc" id="L304">            throw new NullPointerException(</span>
                &quot;The regular expression cannot be null&quot;);
        }

<span class="fc" id="L308">        return new SNIHostNameMatcher(regex);</span>
    }

    // check the validity of the string hostname
    private void checkHostName() {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (hostname.isEmpty()) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(</span>
                &quot;Server name value of host_name cannot be empty&quot;);
        }

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (hostname.endsWith(&quot;.&quot;)) {</span>
<span class="nc" id="L319">            throw new IllegalArgumentException(</span>
                &quot;Server name value of host_name cannot have the trailing dot&quot;);
        }
<span class="nc" id="L322">    }</span>

    private final static class SNIHostNameMatcher extends SNIMatcher {

        // the compiled representation of a regular expression.
        private final Pattern pattern;

        /**
         * Creates an SNIHostNameMatcher object.
         *
         * @param  regex
         *         the &lt;a href=&quot;{@docRoot}/java/util/regex/Pattern.html#sum&quot;&gt;
         *         regular expression pattern&lt;/a&gt;
         *         representing the hostname(s) to match
         * @throws NullPointerException if {@code regex} is
         *         {@code null}
         * @throws PatternSyntaxException if the regular expression's syntax
         *         is invalid
         */
        SNIHostNameMatcher(String regex) {
<span class="fc" id="L342">            super(StandardConstants.SNI_HOST_NAME);</span>
<span class="fc" id="L343">            pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L344">        }</span>

        /**
         * Attempts to match the given {@link SNIServerName}.
         *
         * @param  serverName
         *         the {@link SNIServerName} instance on which this matcher
         *         performs match operations
         *
         * @return {@code true} if, and only if, the matcher matches the
         *         given {@code serverName}
         *
         * @throws NullPointerException if {@code serverName} is {@code null}
         * @throws IllegalArgumentException if {@code serverName} is
         *         not of {@code StandardConstants#SNI_HOST_NAME} type
         *
         * @see SNIServerName
         */
        @Override
        public boolean matches(SNIServerName serverName) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (serverName == null) {</span>
<span class="nc" id="L365">                throw new NullPointerException(</span>
                    &quot;The SNIServerName argument cannot be null&quot;);
            }

            SNIHostName hostname;
<span class="nc bnc" id="L370" title="All 2 branches missed.">            if (!(serverName instanceof SNIHostName)) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (serverName.getType() != StandardConstants.SNI_HOST_NAME) {</span>
<span class="nc" id="L372">                    throw new IllegalArgumentException(</span>
                        &quot;The server name type is not host_name&quot;);
                }

                try {
<span class="nc" id="L377">                    hostname = new SNIHostName(serverName.getEncoded());</span>
<span class="nc" id="L378">                } catch (NullPointerException | IllegalArgumentException e) {</span>
<span class="nc" id="L379">                    return false;</span>
<span class="nc" id="L380">                }</span>
            } else {
<span class="nc" id="L382">                hostname = (SNIHostName)serverName;</span>
            }

            // Let's first try the ascii name matching
<span class="nc" id="L386">            String asciiName = hostname.getAsciiName();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (pattern.matcher(asciiName).matches()) {</span>
<span class="nc" id="L388">                return true;</span>
            }

            // May be an internationalized domain name, check the Unicode
            // representations.
<span class="nc" id="L393">            return pattern.matcher(IDN.toUnicode(asciiName)).matches();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>