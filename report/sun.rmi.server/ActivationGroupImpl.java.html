<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ActivationGroupImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.server</a> &gt; <span class="el_source">ActivationGroupImpl.java</span></div><h1>ActivationGroupImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.server;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.ServerSocket;
import java.rmi.MarshalledObject;
import java.rmi.NoSuchObjectException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.activation.Activatable;
import java.rmi.activation.ActivationDesc;
import java.rmi.activation.ActivationException;
import java.rmi.activation.ActivationGroup;
import java.rmi.activation.ActivationGroupID;
import java.rmi.activation.ActivationID;
import java.rmi.activation.UnknownObjectException;
import java.rmi.server.RMIClassLoader;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import sun.rmi.registry.RegistryImpl;

/**
 * The default activation group implementation.
 *
 * @author      Ann Wollrath
 * @since       1.2
 * @see         java.rmi.activation.ActivationGroup
 */
public class ActivationGroupImpl extends ActivationGroup {

    // use serialVersionUID from JDK 1.2.2 for interoperability
    private static final long serialVersionUID = 5758693559430427303L;

    /** maps persistent IDs to activated remote objects */
<span class="fc" id="L68">    private final Hashtable&lt;ActivationID,ActiveEntry&gt; active =</span>
        new Hashtable&lt;&gt;();
<span class="fc" id="L70">    private boolean groupInactive = false;</span>
    private final ActivationGroupID groupID;
<span class="fc" id="L72">    private final List&lt;ActivationID&gt; lockedIDs = new ArrayList&lt;&gt;();</span>

    /**
     * Creates a default activation group implementation.
     *
     * @param id the group's identifier
     * @param data ignored
     */
    public ActivationGroupImpl(ActivationGroupID id, MarshalledObject&lt;?&gt; data)
        throws RemoteException
    {
<span class="fc" id="L83">        super(id);</span>
<span class="fc" id="L84">        groupID = id;</span>

        /*
         * Unexport activation group impl and attempt to export it on
         * an unshared anonymous port.  See 4692286.
         */
<span class="fc" id="L90">        unexportObject(this, true);</span>
<span class="fc" id="L91">        RMIServerSocketFactory ssf = new ServerSocketFactoryImpl();</span>
<span class="fc" id="L92">        UnicastRemoteObject.exportObject(this, 0, null, ssf);</span>

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (System.getSecurityManager() == null) {</span>
            try {
                // Provide a default security manager.
<span class="nc" id="L97">                System.setSecurityManager(new SecurityManager());</span>

<span class="nc" id="L99">            } catch (Exception e) {</span>
<span class="nc" id="L100">                throw new RemoteException(&quot;unable to set security manager&quot;, e);</span>
<span class="nc" id="L101">            }</span>
        }
<span class="fc" id="L103">    }</span>

    /**
     * Trivial server socket factory used to export the activation group
     * impl on an unshared port.
     */
<span class="fc" id="L109">    private static class ServerSocketFactoryImpl</span>
        implements RMIServerSocketFactory
    {
        public ServerSocket createServerSocket(int port) throws IOException
        {
<span class="fc" id="L114">            RMISocketFactory sf = RMISocketFactory.getSocketFactory();</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (sf == null) {</span>
<span class="fc" id="L116">                sf = RMISocketFactory.getDefaultSocketFactory();</span>
            }
<span class="fc" id="L118">            return sf.createServerSocket(port);</span>
        }
    }

    /*
     * Obtains a lock on the ActivationID id before returning. Allows only one
     * thread at a time to hold a lock on a particular id.  If the lock for id
     * is in use, all requests for an equivalent (in the Object.equals sense)
     * id will wait for the id to be notified and use the supplied id as the
     * next lock. The caller of &quot;acquireLock&quot; must execute the &quot;releaseLock&quot;
     * method&quot; to release the lock and &quot;notifyAll&quot; waiters for the id lock
     * obtained from this method.  The typical usage pattern is as follows:
     *
     * try {
     *    acquireLock(id);
     *    // do stuff pertaining to id...
     * } finally {
     *    releaseLock(id);
     *    checkInactiveGroup();
     * }
     */
    private void acquireLock(ActivationID id) {

        ActivationID waitForID;

        for (;;) {

<span class="fc" id="L145">            synchronized (lockedIDs) {</span>
<span class="fc" id="L146">                int index = lockedIDs.indexOf(id);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                if (index &lt; 0) {</span>
<span class="fc" id="L148">                    lockedIDs.add(id);</span>
<span class="fc" id="L149">                    return;</span>
                } else {
<span class="nc" id="L151">                    waitForID = lockedIDs.get(index);</span>
                }
<span class="nc" id="L153">            }</span>

<span class="nc" id="L155">            synchronized (waitForID) {</span>
<span class="nc" id="L156">                synchronized (lockedIDs) {</span>
<span class="nc" id="L157">                    int index = lockedIDs.indexOf(waitForID);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">                    if (index &lt; 0) continue;</span>
<span class="nc" id="L159">                    ActivationID actualID = lockedIDs.get(index);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                    if (actualID != waitForID)</span>
                        /*
                         * don't wait on an id that won't be notified.
                         */
<span class="nc" id="L164">                        continue;</span>
<span class="nc" id="L165">                }</span>

                try {
<span class="nc" id="L168">                    waitForID.wait();</span>
<span class="nc" id="L169">                } catch (InterruptedException ignore) {</span>
<span class="nc" id="L170">                }</span>
<span class="nc" id="L171">            }</span>
        }

    }

    /*
     * Releases the id lock obtained via the &quot;acquireLock&quot; method and then
     * notifies all threads waiting on the lock.
     */
    private void releaseLock(ActivationID id) {
<span class="fc" id="L181">        synchronized (lockedIDs) {</span>
<span class="fc" id="L182">            id = lockedIDs.remove(lockedIDs.indexOf(id));</span>
<span class="pc" id="L183">        }</span>

<span class="fc" id="L185">        synchronized (id) {</span>
<span class="fc" id="L186">            id.notifyAll();</span>
<span class="pc" id="L187">        }</span>
<span class="fc" id="L188">    }</span>

    /**
     * Creates a new instance of an activatable remote object. The
     * &lt;code&gt;Activator&lt;/code&gt; calls this method to create an activatable
     * object in this group. This method should be idempotent; a call to
     * activate an already active object should return the previously
     * activated object.
     *
     * Note: this method assumes that the Activator will only invoke
     * newInstance for the same object in a serial fashion (i.e.,
     * the activator will not allow the group to see concurrent requests
     * to activate the same object.
     *
     * @param id the object's activation identifier
     * @param desc the object's activation descriptor
     * @return a marshalled object containing the activated object's stub
     */
    public MarshalledObject&lt;? extends Remote&gt;
                                      newInstance(final ActivationID id,
                                                  final ActivationDesc desc)
        throws ActivationException, RemoteException
    {
<span class="fc" id="L211">        RegistryImpl.checkAccess(&quot;ActivationInstantiator.newInstance&quot;);</span>

<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (!groupID.equals(desc.getGroupID()))</span>
<span class="nc" id="L214">            throw new ActivationException(&quot;newInstance in wrong group&quot;);</span>

        try {
<span class="fc" id="L217">            acquireLock(id);</span>
<span class="fc" id="L218">            synchronized (this) {</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                if (groupInactive == true)</span>
<span class="nc" id="L220">                    throw new InactiveGroupException(&quot;group is inactive&quot;);</span>
<span class="pc" id="L221">            }</span>

<span class="fc" id="L223">            ActiveEntry entry = active.get(id);</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (entry != null)</span>
<span class="nc" id="L225">                return entry.mobj;</span>

<span class="fc" id="L227">            String className = desc.getClassName();</span>

<span class="fc" id="L229">            final Class&lt;? extends Remote&gt; cl =</span>
<span class="fc" id="L230">                RMIClassLoader.loadClass(desc.getLocation(), className)</span>
<span class="fc" id="L231">                .asSubclass(Remote.class);</span>
<span class="fc" id="L232">            Remote impl = null;</span>

<span class="fc" id="L234">            final Thread t = Thread.currentThread();</span>
<span class="fc" id="L235">            final ClassLoader savedCcl = t.getContextClassLoader();</span>
<span class="fc" id="L236">            ClassLoader objcl = cl.getClassLoader();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            final ClassLoader ccl = covers(objcl, savedCcl) ? objcl : savedCcl;</span>

            /*
             * Fix for 4164971: allow non-public activatable class
             * and/or constructor, create the activatable object in a
             * privileged block
             */
            try {
                /*
                 * The code below is in a doPrivileged block to
                 * protect against user code which code might have set
                 * a global socket factory (in which case application
                 * code would be on the stack).
                 */
<span class="fc" id="L251">                impl = AccessController.doPrivileged(</span>
<span class="fc" id="L252">                      new PrivilegedExceptionAction&lt;Remote&gt;() {</span>
                      public Remote run() throws InstantiationException,
                          NoSuchMethodException, IllegalAccessException,
                          InvocationTargetException
                      {
<span class="fc" id="L257">                          Constructor&lt;? extends Remote&gt; constructor =</span>
<span class="fc" id="L258">                              cl.getDeclaredConstructor(</span>
                                  ActivationID.class, MarshalledObject.class);
<span class="fc" id="L260">                          constructor.setAccessible(true);</span>
                          try {
                              /*
                               * Fix for 4289544: make sure to set the
                               * context class loader to be the class
                               * loader of the impl class before
                               * constructing that class.
                               */
<span class="fc" id="L268">                              t.setContextClassLoader(ccl);</span>
<span class="fc" id="L269">                              return constructor.newInstance(id,</span>
<span class="fc" id="L270">                                                             desc.getData());</span>
                          } finally {
<span class="fc" id="L272">                              t.setContextClassLoader(savedCcl);</span>
                          }
                      }
                  });
<span class="fc" id="L276">            } catch (PrivilegedActionException pae) {</span>
<span class="fc" id="L277">                Throwable e = pae.getException();</span>

                // narrow the exception's type and rethrow it
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">                if (e instanceof InstantiationException) {</span>
<span class="nc" id="L281">                    throw (InstantiationException) e;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">                } else if (e instanceof NoSuchMethodException) {</span>
<span class="fc" id="L283">                    throw (NoSuchMethodException) e;</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                } else if (e instanceof IllegalAccessException) {</span>
<span class="nc" id="L285">                    throw (IllegalAccessException) e;</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                } else if (e instanceof InvocationTargetException) {</span>
<span class="fc" id="L287">                    throw (InvocationTargetException) e;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                } else if (e instanceof RuntimeException) {</span>
<span class="nc" id="L289">                    throw (RuntimeException) e;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                } else if (e instanceof Error) {</span>
<span class="nc" id="L291">                    throw (Error) e;</span>
                }
<span class="fc" id="L293">            }</span>

<span class="fc" id="L295">            entry = new ActiveEntry(impl);</span>
<span class="fc" id="L296">            active.put(id, entry);</span>
<span class="fc" id="L297">            return entry.mobj;</span>

<span class="fc" id="L299">        } catch (NoSuchMethodException | NoSuchMethodError e) {</span>
            /* user forgot to provide activatable constructor?
             * or code recompiled and user forgot to provide
             *  activatable constructor?
             */
<span class="fc" id="L304">            throw new ActivationException</span>
                (&quot;Activatable object must provide an activation&quot;+
                 &quot; constructor&quot;, e );

<span class="fc" id="L308">        } catch (InvocationTargetException e) {</span>
<span class="fc" id="L309">            throw new ActivationException(&quot;exception in object constructor&quot;,</span>
<span class="fc" id="L310">                                          e.getTargetException());</span>

<span class="nc" id="L312">        } catch (Exception e) {</span>
<span class="nc" id="L313">            throw new ActivationException(&quot;unable to activate object&quot;, e);</span>
        } finally {
<span class="pc" id="L315">            releaseLock(id);</span>
<span class="pc" id="L316">            checkInactiveGroup();</span>
        }
    }


   /**
    * The group's &lt;code&gt;inactiveObject&lt;/code&gt; method is called
    * indirectly via a call to the &lt;code&gt;Activatable.inactive&lt;/code&gt;
    * method. A remote object implementation must call
    * &lt;code&gt;Activatable&lt;/code&gt;'s &lt;code&gt;inactive&lt;/code&gt; method when
    * that object deactivates (the object deems that it is no longer
    * active). If the object does not call
    * &lt;code&gt;Activatable.inactive&lt;/code&gt; when it deactivates, the
    * object will never be garbage collected since the group keeps
    * strong references to the objects it creates. &lt;p&gt;
    *
    * The group's &lt;code&gt;inactiveObject&lt;/code&gt; method
    * unexports the remote object from the RMI runtime so that the
    * object can no longer receive incoming RMI calls. This call will
    * only succeed if the object has no pending/executing calls. If
    * the object does have pending/executing RMI calls, then false
    * will be returned.
    *
    * If the object has no pending/executing calls, the object is
    * removed from the RMI runtime and the group informs its
    * &lt;code&gt;ActivationMonitor&lt;/code&gt; (via the monitor's
    * &lt;code&gt;inactiveObject&lt;/code&gt; method) that the remote object is
    * not currently active so that the remote object will be
    * re-activated by the activator upon a subsequent activation
    * request.
    *
    * @param id the object's activation identifier
    * @returns true if the operation succeeds (the operation will
    * succeed if the object in currently known to be active and is
    * either already unexported or is currently exported and has no
    * pending/executing calls); false is returned if the object has
    * pending/executing calls in which case it cannot be deactivated
    * @exception UnknownObjectException if object is unknown (may already
    * be inactive)
    * @exception RemoteException if call informing monitor fails
    */
    public boolean inactiveObject(ActivationID id)
        throws ActivationException, UnknownObjectException, RemoteException
    {

        try {
<span class="fc" id="L362">            acquireLock(id);</span>
<span class="fc" id="L363">            synchronized (this) {</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">                if (groupInactive == true)</span>
<span class="nc" id="L365">                    throw new ActivationException(&quot;group is inactive&quot;);</span>
<span class="pc" id="L366">            }</span>

<span class="fc" id="L368">            ActiveEntry entry = active.get(id);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">            if (entry == null) {</span>
                // REMIND: should this be silent?
<span class="nc" id="L371">                throw new UnknownObjectException(&quot;object not active&quot;);</span>
            }

            try {
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (Activatable.unexportObject(entry.impl, false) == false)</span>
<span class="fc" id="L376">                    return false;</span>
<span class="fc" id="L377">            } catch (NoSuchObjectException allowUnexportedObjects) {</span>
<span class="fc" id="L378">            }</span>

            try {
<span class="fc" id="L381">                super.inactiveObject(id);</span>
<span class="fc" id="L382">            } catch (UnknownObjectException allowUnregisteredObjects) {</span>
<span class="fc" id="L383">            }</span>

<span class="fc" id="L385">            active.remove(id);</span>

        } finally {
<span class="pc" id="L388">            releaseLock(id);</span>
<span class="pc" id="L389">            checkInactiveGroup();</span>
<span class="fc" id="L390">        }</span>

<span class="fc" id="L392">        return true;</span>
    }

    /*
     * Determines if the group has become inactive and
     * marks it as such.
     */
    private void checkInactiveGroup() {
<span class="fc" id="L400">        boolean groupMarkedInactive = false;</span>
<span class="fc" id="L401">        synchronized (this) {</span>
<span class="pc bpc" id="L402" title="1 of 6 branches missed.">            if (active.size() == 0 &amp;&amp; lockedIDs.size() == 0 &amp;&amp;</span>
                groupInactive == false)
            {
<span class="fc" id="L405">                groupInactive = true;</span>
<span class="fc" id="L406">                groupMarkedInactive = true;</span>
            }
<span class="pc" id="L408">        }</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (groupMarkedInactive) {</span>
            try {
<span class="fc" id="L412">                super.inactiveGroup();</span>
<span class="fc" id="L413">            } catch (Exception ignoreDeactivateFailure) {</span>
<span class="fc" id="L414">            }</span>

            try {
<span class="fc" id="L417">                UnicastRemoteObject.unexportObject(this, true);</span>
<span class="nc" id="L418">            } catch (NoSuchObjectException allowUnexportedGroup) {</span>
<span class="fc" id="L419">            }</span>
        }
<span class="fc" id="L421">    }</span>

    /**
     * The group's &lt;code&gt;activeObject&lt;/code&gt; method is called when an
     * object is exported (either by &lt;code&gt;Activatable&lt;/code&gt; object
     * construction or an explicit call to
     * &lt;code&gt;Activatable.exportObject&lt;/code&gt;. The group must inform its
     * &lt;code&gt;ActivationMonitor&lt;/code&gt; that the object is active (via
     * the monitor's &lt;code&gt;activeObject&lt;/code&gt; method) if the group
     * hasn't already done so.
     *
     * @param id the object's identifier
     * @param obj the remote object implementation
     * @exception UnknownObjectException if object is not registered
     * @exception RemoteException if call informing monitor fails
     */
    public void activeObject(ActivationID id, Remote impl)
        throws ActivationException, UnknownObjectException, RemoteException
    {

        try {
<span class="fc" id="L442">            acquireLock(id);</span>
<span class="fc" id="L443">            synchronized (this) {</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">                if (groupInactive == true)</span>
<span class="nc" id="L445">                    throw new ActivationException(&quot;group is inactive&quot;);</span>
<span class="pc" id="L446">            }</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">            if (!active.contains(id)) {</span>
<span class="fc" id="L448">                ActiveEntry entry = new ActiveEntry(impl);</span>
<span class="fc" id="L449">                active.put(id, entry);</span>
                // created new entry, so inform monitor of active object
                try {
<span class="fc" id="L452">                    super.activeObject(id, entry.mobj);</span>
<span class="nc" id="L453">                } catch (RemoteException e) {</span>
                    // daemon can still find it by calling newInstance
<span class="fc" id="L455">                }</span>
            }
        } finally {
<span class="pc" id="L458">            releaseLock(id);</span>
<span class="pc" id="L459">            checkInactiveGroup();</span>
<span class="fc" id="L460">        }</span>
<span class="fc" id="L461">    }</span>

    /**
     * Entry in table for active object.
     */
    private static class ActiveEntry {
        Remote impl;
        MarshalledObject&lt;Remote&gt; mobj;

<span class="fc" id="L470">        ActiveEntry(Remote impl) throws ActivationException {</span>
<span class="fc" id="L471">            this.impl =  impl;</span>
            try {
<span class="fc" id="L473">                this.mobj = new MarshalledObject&lt;Remote&gt;(impl);</span>
<span class="nc" id="L474">            } catch (IOException e) {</span>
<span class="nc" id="L475">                throw new</span>
                    ActivationException(&quot;failed to marshal remote object&quot;, e);
<span class="fc" id="L477">            }</span>
<span class="fc" id="L478">        }</span>
    }

    /**
     * Returns true if the first argument is either equal to, or is a
     * descendant of, the second argument.  Null is treated as the root of
     * the tree.
     */
    private static boolean covers(ClassLoader sub, ClassLoader sup) {
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (sup == null) {</span>
<span class="nc" id="L488">            return true;</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        } else if (sub == null) {</span>
<span class="nc" id="L490">            return false;</span>
        }
        do {
<span class="fc bfc" id="L493" title="All 2 branches covered.">            if (sub == sup) {</span>
<span class="fc" id="L494">                return true;</span>
            }
<span class="fc" id="L496">            sub = sub.getParent();</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">        } while (sub != null);</span>
<span class="fc" id="L498">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>