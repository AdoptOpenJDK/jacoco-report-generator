<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ActivatableRef.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.server</a> &gt; <span class="el_source">ActivatableRef.java</span></div><h1>ActivatableRef.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.server;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.lang.reflect.Proxy;
import java.net.MalformedURLException;
import java.net.URL;
import java.rmi.*;
import java.rmi.activation.*;
import java.rmi.server.Operation;
import java.rmi.server.RMIClassLoader;
import java.rmi.server.RemoteCall;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.rmi.server.RemoteRef;
import java.rmi.server.RemoteStub;

<span class="fc bfc" id="L44" title="All 2 branches covered.">@SuppressWarnings(&quot;deprecation&quot;)</span>
public class ActivatableRef implements RemoteRef {

    private static final long serialVersionUID = 7579060052569229166L;

    protected ActivationID id;
    protected RemoteRef ref;
<span class="fc" id="L51">    transient boolean force = false;</span>

    private static final int MAX_RETRIES = 3;
    private static final String versionComplaint =
        &quot;activation requires 1.2 stubs&quot;;

    /**
     * Create a new (empty) ActivatableRef
     */
    public ActivatableRef()
<span class="fc" id="L61">    {}</span>

    /**
     * Create a ActivatableRef with the specified id
     */
    public ActivatableRef(ActivationID id, RemoteRef ref)
<span class="fc" id="L67">    {</span>
<span class="fc" id="L68">        this.id = id;</span>
<span class="fc" id="L69">        this.ref = ref;</span>
<span class="fc" id="L70">    }</span>

    /**
     * Returns the stub for the remote object whose class is
     * specified in the activation descriptor. The ActivatableRef
     * in the resulting stub has its activation id set to the
     * activation id supplied as the second argument.
     */
    public static Remote getStub(ActivationDesc desc, ActivationID id)
        throws StubNotFoundException
    {
<span class="fc" id="L81">        String className = desc.getClassName();</span>

        try {
<span class="fc" id="L84">            Class&lt;?&gt; cl =</span>
<span class="fc" id="L85">                RMIClassLoader.loadClass(desc.getLocation(), className);</span>
<span class="fc" id="L86">            RemoteRef clientRef = new ActivatableRef(id, null);</span>
<span class="fc" id="L87">            return Util.createProxy(cl, clientRef, false);</span>

<span class="nc" id="L89">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L90">            throw new StubNotFoundException(</span>
                &quot;class implements an illegal remote interface&quot;, e);

<span class="nc" id="L93">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L94">            throw new StubNotFoundException(&quot;unable to load class: &quot; +</span>
                                            className, e);
<span class="nc" id="L96">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L97">            throw new StubNotFoundException(&quot;malformed URL&quot;, e);</span>
        }
    }

    /**
     * Invoke method on remote object. This method delegates remote
     * method invocation to the underlying ref type.  If the
     * underlying reference is not known (is null), then the object
     * must be activated first.  If an attempt at method invocation
     * fails, the object should force reactivation.  Method invocation
     * must preserve &quot;at most once&quot; call semantics.  In RMI, &quot;at most
     * once&quot; applies to parameter deserialization at the remote site
     * and the remote object's method execution.  &quot;At most once&quot; does
     * not apply to parameter serialization at the client so the
     * parameters of a call don't need to be buffered in anticipation
     * of call retry. Thus, a method call is only be retried if the
     * initial method invocation does not execute at all at the server
     * (including parameter deserialization).
     */
    public Object invoke(Remote obj,
                         java.lang.reflect.Method method,
                         Object[] params,
                         long opnum)
        throws Exception
    {

<span class="fc" id="L123">        boolean force = false;</span>
        RemoteRef localRef;
<span class="fc" id="L125">        Exception exception = null;</span>

        /*
         * Attempt object activation if active ref is unknown.
         * Throws a RemoteException if object can't be activated.
         */
<span class="fc" id="L131">        synchronized (this) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (ref == null) {</span>
<span class="fc" id="L133">                localRef = activate(force);</span>
<span class="fc" id="L134">                force = true;</span>
            } else {
<span class="fc" id="L136">                localRef = ref;</span>
            }
<span class="fc" id="L138">        }</span>

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">        for (int retries = MAX_RETRIES; retries &gt; 0; retries--) {</span>

            try {
<span class="fc" id="L143">                return localRef.invoke(obj, method, params, opnum);</span>
<span class="fc" id="L144">            } catch (NoSuchObjectException e) {</span>
                /*
                 * Object is not active in VM; retry call
                 */
<span class="fc" id="L148">                exception = e;</span>
<span class="fc" id="L149">            } catch (ConnectException e) {</span>
                /*
                 * Failure during connection setup; retry call
                 */
<span class="fc" id="L153">                exception = e;</span>
<span class="nc" id="L154">            } catch (UnknownHostException e) {</span>
                /*
                 * Failure during connection setup; retry call.
                 */
<span class="nc" id="L158">                exception = e;</span>
<span class="nc" id="L159">            } catch (ConnectIOException e) {</span>
                /*
                 * Failure setting up multiplexed connection or reusing
                 * cached connection; retry call
                 */
<span class="nc" id="L164">                exception = e;</span>
<span class="nc" id="L165">            } catch (MarshalException e) {</span>
                /*
                 * Failure during parameter serialization; call may
                 * have reached server, so call retry not possible.
                 */
<span class="nc" id="L170">                throw e;</span>
<span class="nc" id="L171">            } catch (ServerError e) {</span>
                /*
                 * Call reached server; propagate remote exception.
                 */
<span class="nc" id="L175">                throw e;</span>
<span class="nc" id="L176">            } catch (ServerException e) {</span>
                /*
                 * Call reached server; propagate remote exception
                 */
<span class="nc" id="L180">                throw e;</span>
<span class="fc" id="L181">            } catch (RemoteException e) {</span>
                /*
                 * This is a catch-all for other RemoteExceptions.
                 * UnmarshalException being the only one relevant.
                 *
                 * StubNotFoundException should never show up because
                 * it is generally thrown when attempting to locate
                 * a stub.
                 *
                 * UnexpectedException should never show up because
                 * it is only thrown by a stub and would be wrapped
                 * in a ServerException if it was propagated by a
                 * remote call.
                 */
<span class="fc" id="L195">                synchronized (this) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">                    if (localRef == ref) {</span>
<span class="fc" id="L197">                        ref = null;     // this may be overly conservative</span>
                    }
<span class="pc" id="L199">                }</span>

<span class="fc" id="L201">                throw e;</span>
<span class="pc" id="L202">            }</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (retries &gt; 1) {</span>
                /*
                 * Activate object, since object could not be reached.
                 */
<span class="fc" id="L208">                synchronized (this) {</span>
<span class="pc bpc" id="L209" title="3 of 4 branches missed.">                    if (localRef.remoteEquals(ref) || ref == null) {</span>
<span class="fc" id="L210">                        RemoteRef newRef = activate(force);</span>

<span class="pc bpc" id="L212" title="5 of 6 branches missed.">                        if (newRef.remoteEquals(localRef) &amp;&amp;</span>
                            exception instanceof NoSuchObjectException &amp;&amp;
                            force == false) {
                            /*
                             * If last exception was NoSuchObjectException,
                             * then old value of ref is definitely wrong,
                             * so make sure that it is different.
                             */
<span class="nc" id="L220">                            newRef = activate(true);</span>
                        }

<span class="fc" id="L223">                        localRef = newRef;</span>
<span class="fc" id="L224">                        force = true;</span>
<span class="fc" id="L225">                    } else {</span>
<span class="nc" id="L226">                        localRef = ref;</span>
<span class="nc" id="L227">                        force = false;</span>
                    }
<span class="fc" id="L229">                }</span>
            }
        }

        /*
         * Retries unsuccessful, so throw last exception
         */
<span class="nc" id="L236">        throw exception;</span>
    }

    /**
     * private method to obtain the ref for a call.
     */
    private synchronized RemoteRef getRef()
        throws RemoteException
    {
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (ref == null) {</span>
<span class="nc" id="L246">            ref = activate(false);</span>
        }

<span class="nc" id="L249">        return ref;</span>
    }

    /**
     * private method to activate the remote object.
     *
     * NOTE: the caller must be synchronized on &quot;this&quot; before
     * calling this method.
     */
    private RemoteRef activate(boolean force)
        throws RemoteException
    {
<span class="pc bpc" id="L261" title="1 of 4 branches missed.">        assert Thread.holdsLock(this);</span>

<span class="fc" id="L263">        ref = null;</span>
        try {
            /*
             * Activate the object and retrieve the remote reference
             * from inside the stub returned as the result. Then
             * set this activatable ref's internal ref to be the
             * ref inside the ref of the stub. In more clear terms,
             * the stub returned from the activate call contains an
             * ActivatableRef. We need to set the ref in *this*
             * ActivatableRef to the ref inside the ActivatableRef
             * retrieved from the stub. The ref type embedded in the
             * ActivatableRef is typically a UnicastRef.
             */

<span class="fc" id="L277">            Remote proxy = id.activate(force);</span>
<span class="fc" id="L278">            ActivatableRef newRef = null;</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">            if (proxy instanceof RemoteStub) {</span>
<span class="fc" id="L281">                newRef = (ActivatableRef) ((RemoteStub) proxy).getRef();</span>
            } else {
                /*
                 * Assume that proxy is an instance of a dynamic proxy
                 * class.  If that assumption is not correct, or either of
                 * the casts below fails, the resulting exception will be
                 * wrapped in an ActivateFailedException below.
                 */
<span class="fc" id="L289">                RemoteObjectInvocationHandler handler =</span>
                    (RemoteObjectInvocationHandler)
<span class="fc" id="L291">                    Proxy.getInvocationHandler(proxy);</span>
<span class="fc" id="L292">                newRef = (ActivatableRef) handler.getRef();</span>
            }
<span class="fc" id="L294">            ref = newRef.ref;</span>
<span class="fc" id="L295">            return ref;</span>

<span class="nc" id="L297">        } catch (ConnectException e) {</span>
<span class="nc" id="L298">            throw new ConnectException(&quot;activation failed&quot;, e);</span>
<span class="nc" id="L299">        } catch (RemoteException e) {</span>
<span class="nc" id="L300">            throw new ConnectIOException(&quot;activation failed&quot;, e);</span>
<span class="fc" id="L301">        } catch (UnknownObjectException e) {</span>
<span class="fc" id="L302">            throw new NoSuchObjectException(&quot;object not registered&quot;);</span>
<span class="fc" id="L303">        } catch (ActivationException e) {</span>
<span class="fc" id="L304">            throw new ActivateFailedException(&quot;activation failed&quot;, e);</span>
        }
    }

    /**
     * This call is used by the old 1.1 stub protocol and is
     * unsupported since activation requires 1.2 stubs.
     */
    public synchronized RemoteCall newCall(RemoteObject obj,
                                           Operation[] ops,
                                           int opnum,
                                           long hash)
        throws RemoteException
    {
<span class="nc" id="L318">        throw new UnsupportedOperationException(versionComplaint);</span>
    }

    /**
     * This call is used by the old 1.1 stub protocol and is
     * unsupported since activation requires 1.2 stubs.
     */
    public void invoke(RemoteCall call) throws Exception
    {
<span class="nc" id="L327">        throw new UnsupportedOperationException(versionComplaint);</span>
    }

    /**
     * This call is used by the old 1.1 stub protocol and is
     * unsupported since activation requires 1.2 stubs.
     */
    public void done(RemoteCall call) throws RemoteException {
<span class="nc" id="L335">        throw new UnsupportedOperationException(versionComplaint);</span>
    }

    /**
     * Returns the class of the ref type to be serialized
     */
    public String getRefClass(ObjectOutput out)
    {
<span class="fc" id="L343">        return &quot;ActivatableRef&quot;;</span>
    }

    /**
     * Write out external representation for remote ref.
     */
    public void writeExternal(ObjectOutput out) throws IOException
    {
<span class="fc" id="L351">        RemoteRef localRef = ref;</span>

<span class="fc" id="L353">        out.writeObject(id);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (localRef == null) {</span>
<span class="fc" id="L355">            out.writeUTF(&quot;&quot;);</span>
        } else {
<span class="fc" id="L357">            out.writeUTF(localRef.getRefClass(out));</span>
<span class="fc" id="L358">            localRef.writeExternal(out);</span>
        }
<span class="fc" id="L360">    }</span>

    /**
     * Read in external representation for remote ref.
     * @exception ClassNotFoundException If the class for an object
     * being restored cannot be found.
     */
    public void readExternal(ObjectInput in)
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L370">        id = (ActivationID)in.readObject();</span>
<span class="fc" id="L371">        ref = null;</span>
<span class="fc" id="L372">        String className = in.readUTF();</span>

<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (className.equals(&quot;&quot;)) return;</span>

        try {
<span class="fc" id="L377">            Class&lt;?&gt; refClass = Class.forName(RemoteRef.packagePrefix + &quot;.&quot; +</span>
                                              className);
<span class="fc" id="L379">            ref = (RemoteRef)refClass.newInstance();</span>
<span class="fc" id="L380">            ref.readExternal(in);</span>
<span class="nc" id="L381">        } catch (InstantiationException e) {</span>
<span class="nc" id="L382">            throw new UnmarshalException(&quot;Unable to create remote reference&quot;,</span>
                                         e);
<span class="nc" id="L384">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L385">            throw new UnmarshalException(&quot;Illegal access creating remote reference&quot;);</span>
<span class="fc" id="L386">        }</span>
<span class="fc" id="L387">    }</span>

    //----------------------------------------------------------------------;
    /**
     * Method from object, forward from RemoteObject
     */
    public String remoteToString() {
<span class="fc" id="L394">        return Util.getUnqualifiedName(getClass()) +</span>
                &quot; [remoteRef: &quot; + ref + &quot;]&quot;;
    }

    /**
     * default implementation of hashCode for remote objects
     */
    public int remoteHashCode() {
<span class="nc" id="L402">        return id.hashCode();</span>
    }

    /** default implementation of equals for remote objects
     */
    public boolean remoteEquals(RemoteRef ref) {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (ref instanceof ActivatableRef)</span>
<span class="nc" id="L409">            return id.equals(((ActivatableRef)ref).id);</span>
<span class="nc" id="L410">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>