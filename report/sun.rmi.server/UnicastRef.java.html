<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UnicastRef.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.server</a> &gt; <span class="el_source">UnicastRef.java</span></div><h1>UnicastRef.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.server;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.lang.reflect.Method;
import java.rmi.MarshalException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.ServerException;
import java.rmi.UnmarshalException;
import java.rmi.server.Operation;
import java.rmi.server.RemoteCall;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteRef;
import java.security.AccessController;
import sun.rmi.runtime.Log;
import sun.rmi.transport.Connection;
import sun.rmi.transport.LiveRef;
import sun.rmi.transport.StreamRemoteCall;
import sun.security.action.GetBooleanAction;

/**
 * NOTE: There is a JDK-internal dependency on the existence of this
 * class's getLiveRef method (as it is inherited by UnicastRef2) in
 * the implementation of javax.management.remote.rmi.RMIConnector.
 */
@SuppressWarnings(&quot;deprecation&quot;)
public class UnicastRef implements RemoteRef {

    /**
     * Client-side transport log.
     */
<span class="fc" id="L59">    public static final Log clientRefLog =</span>
<span class="fc" id="L60">        Log.getLog(&quot;sun.rmi.client.ref&quot;, &quot;transport&quot;,  Util.logLevel);</span>

    /**
     * Client-side call log.
     */
<span class="fc" id="L65">    public static final Log clientCallLog =</span>
<span class="fc" id="L66">        Log.getLog(&quot;sun.rmi.client.call&quot;, &quot;RMI&quot;,</span>
<span class="fc" id="L67">                   AccessController.doPrivileged(</span>
                       new GetBooleanAction(&quot;sun.rmi.client.logCalls&quot;)));
    private static final long serialVersionUID = 8258372400816541186L;

    protected LiveRef ref;

    /**
     * Create a new (empty) Unicast remote reference.
     */
<span class="fc" id="L76">    public UnicastRef() {</span>
<span class="fc" id="L77">    }</span>

    /**
     * Create a new Unicast RemoteRef.
     */
<span class="fc" id="L82">    public UnicastRef(LiveRef liveRef) {</span>
<span class="fc" id="L83">        ref = liveRef;</span>
<span class="fc" id="L84">    }</span>

    /**
     * Returns the current value of this UnicastRef's underlying
     * LiveRef.
     *
     * NOTE: There is a JDK-internal dependency on the existence of
     * this method (as it is inherited by UnicastRef) in the
     * implementation of javax.management.remote.rmi.RMIConnector.
     **/
    public LiveRef getLiveRef() {
<span class="fc" id="L95">        return ref;</span>
    }

    /**
     * Invoke a method. This form of delegating method invocation
     * to the reference allows the reference to take care of
     * setting up the connection to the remote host, marshalling
     * some representation for the method and parameters, then
     * communicating the method invocation to the remote host.
     * This method either returns the result of a method invocation
     * on the remote object which resides on the remote host or
     * throws a RemoteException if the call failed or an
     * application-level exception if the remote invocation throws
     * an exception.
     *
     * @param obj the proxy for the remote object
     * @param method the method to be invoked
     * @param params the parameter list
     * @param opnum  a hash that may be used to represent the method
     * @since 1.2
     */
    public Object invoke(Remote obj,
                         Method method,
                         Object[] params,
                         long opnum)
        throws Exception
    {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (clientRefLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L123">            clientRefLog.log(Log.VERBOSE, &quot;method: &quot; + method);</span>
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (clientCallLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L127">            logClientCall(obj, method);</span>
        }

<span class="fc" id="L130">        Connection conn = ref.getChannel().newConnection();</span>
<span class="fc" id="L131">        RemoteCall call = null;</span>
<span class="fc" id="L132">        boolean reuse = true;</span>

        /* If the call connection is &quot;reused&quot; early, remember not to
         * reuse again.
         */
<span class="fc" id="L137">        boolean alreadyFreed = false;</span>

        try {
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (clientRefLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L141">                clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + opnum);</span>
            }

            // create call context
<span class="fc" id="L145">            call = new StreamRemoteCall(conn, ref.getObjID(), -1, opnum);</span>

            // marshal parameters
            try {
<span class="fc" id="L149">                ObjectOutput out = call.getOutputStream();</span>
<span class="fc" id="L150">                marshalCustomCallData(out);</span>
<span class="fc" id="L151">                Class&lt;?&gt;[] types = method.getParameterTypes();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">                for (int i = 0; i &lt; types.length; i++) {</span>
<span class="fc" id="L153">                    marshalValue(types[i], params[i], out);</span>
                }
<span class="fc" id="L155">            } catch (IOException e) {</span>
<span class="fc" id="L156">                clientRefLog.log(Log.BRIEF,</span>
                    &quot;IOException marshalling arguments: &quot;, e);
<span class="fc" id="L158">                throw new MarshalException(&quot;error marshalling arguments&quot;, e);</span>
<span class="fc" id="L159">            }</span>

            // unmarshal return
<span class="fc" id="L162">            call.executeCall();</span>

            try {
<span class="fc" id="L165">                Class&lt;?&gt; rtype = method.getReturnType();</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (rtype == void.class)</span>
<span class="fc" id="L167">                    return null;</span>
<span class="fc" id="L168">                ObjectInput in = call.getInputStream();</span>

                /* StreamRemoteCall.done() does not actually make use
                 * of conn, therefore it is safe to reuse this
                 * connection before the dirty call is sent for
                 * registered refs.
                 */
<span class="fc" id="L175">                Object returnValue = unmarshalValue(rtype, in);</span>

                /* we are freeing the connection now, do not free
                 * again or reuse.
                 */
<span class="fc" id="L180">                alreadyFreed = true;</span>

                /* if we got to this point, reuse must have been true. */
<span class="fc" id="L183">                clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;);</span>

                /* Free the call's connection early. */
<span class="fc" id="L186">                ref.getChannel().free(conn, true);</span>

<span class="fc" id="L188">                return returnValue;</span>

<span class="nc" id="L190">            } catch (IOException e) {</span>
<span class="nc" id="L191">                clientRefLog.log(Log.BRIEF,</span>
                                 &quot;IOException unmarshalling return: &quot;, e);
<span class="nc" id="L193">                throw new UnmarshalException(&quot;error unmarshalling return&quot;, e);</span>
<span class="nc" id="L194">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L195">                clientRefLog.log(Log.BRIEF,</span>
                    &quot;ClassNotFoundException unmarshalling return: &quot;, e);

<span class="nc" id="L198">                throw new UnmarshalException(&quot;error unmarshalling return&quot;, e);</span>
            } finally {
<span class="fc" id="L200">                try {</span>
<span class="fc" id="L201">                    call.done();</span>
<span class="nc" id="L202">                } catch (IOException e) {</span>
                    /* WARNING: If the conn has been reused early,
                     * then it is too late to recover from thrown
                     * IOExceptions caught here. This code is relying
                     * on StreamRemoteCall.done() not actually
                     * throwing IOExceptions.
                     */
<span class="nc" id="L209">                    reuse = false;</span>
<span class="fc" id="L210">                }</span>
            }

<span class="fc" id="L213">        } catch (RuntimeException e) {</span>
            /*
             * Need to distinguish between client (generated by the
             * invoke method itself) and server RuntimeExceptions.
             * Client side RuntimeExceptions are likely to have
             * corrupted the call connection and those from the server
             * are not likely to have done so.  If the exception came
             * from the server the call connection should be reused.
             */
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if ((call == null) ||</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">                (((StreamRemoteCall) call).getServerException() != e))</span>
            {
<span class="fc" id="L225">                reuse = false;</span>
            }
<span class="fc" id="L227">            throw e;</span>

<span class="fc" id="L229">        } catch (RemoteException e) {</span>
            /*
             * Some failure during call; assume connection cannot
             * be reused.  Must assume failure even if ServerException
             * or ServerError occurs since these failures can happen
             * during parameter deserialization which would leave
             * the connection in a corrupted state.
             */
<span class="fc" id="L237">            reuse = false;</span>
<span class="fc" id="L238">            throw e;</span>

<span class="fc" id="L240">        } catch (Error e) {</span>
            /* If errors occurred, the connection is most likely not
             *  reusable.
             */
<span class="fc" id="L244">            reuse = false;</span>
<span class="fc" id="L245">            throw e;</span>

        } finally {

            /* alreadyFreed ensures that we do not log a reuse that
             * may have already happened.
             */
<span class="pc bpc" id="L252" title="3 of 6 branches missed.">            if (!alreadyFreed) {</span>
<span class="pc bpc" id="L253" title="4 of 6 branches missed.">                if (clientRefLog.isLoggable(Log.BRIEF)) {</span>
<span class="nc" id="L254">                    clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = &quot; +</span>
                                           reuse + &quot;)&quot;);
                }
<span class="pc" id="L257">                ref.getChannel().free(conn, reuse);</span>
            }
        }
    }

    protected void marshalCustomCallData(ObjectOutput out) throws IOException
<span class="fc" id="L263">    {}</span>

    /**
     * Marshal value to an ObjectOutput sink using RMI's serialization
     * format for parameters or return values.
     */
    protected static void marshalValue(Class&lt;?&gt; type, Object value,
                                       ObjectOutput out)
        throws IOException
    {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (type.isPrimitive()) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (type == int.class) {</span>
<span class="fc" id="L275">                out.writeInt(((Integer) value).intValue());</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            } else if (type == boolean.class) {</span>
<span class="fc" id="L277">                out.writeBoolean(((Boolean) value).booleanValue());</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            } else if (type == byte.class) {</span>
<span class="nc" id="L279">                out.writeByte(((Byte) value).byteValue());</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            } else if (type == char.class) {</span>
<span class="nc" id="L281">                out.writeChar(((Character) value).charValue());</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            } else if (type == short.class) {</span>
<span class="nc" id="L283">                out.writeShort(((Short) value).shortValue());</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">            } else if (type == long.class) {</span>
<span class="fc" id="L285">                out.writeLong(((Long) value).longValue());</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            } else if (type == float.class) {</span>
<span class="nc" id="L287">                out.writeFloat(((Float) value).floatValue());</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">            } else if (type == double.class) {</span>
<span class="nc" id="L289">                out.writeDouble(((Double) value).doubleValue());</span>
            } else {
<span class="nc" id="L291">                throw new Error(&quot;Unrecognized primitive type: &quot; + type);</span>
            }
        } else {
<span class="fc" id="L294">            out.writeObject(value);</span>
        }
<span class="fc" id="L296">    }</span>

    /**
     * Unmarshal value from an ObjectInput source using RMI's serialization
     * format for parameters or return values.
     */
    protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in)
        throws IOException, ClassNotFoundException
    {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (type.isPrimitive()) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            if (type == int.class) {</span>
<span class="fc" id="L307">                return Integer.valueOf(in.readInt());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            } else if (type == boolean.class) {</span>
<span class="fc" id="L309">                return Boolean.valueOf(in.readBoolean());</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            } else if (type == byte.class) {</span>
<span class="nc" id="L311">                return Byte.valueOf(in.readByte());</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">            } else if (type == char.class) {</span>
<span class="nc" id="L313">                return Character.valueOf(in.readChar());</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">            } else if (type == short.class) {</span>
<span class="nc" id="L315">                return Short.valueOf(in.readShort());</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            } else if (type == long.class) {</span>
<span class="fc" id="L317">                return Long.valueOf(in.readLong());</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            } else if (type == float.class) {</span>
<span class="nc" id="L319">                return Float.valueOf(in.readFloat());</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            } else if (type == double.class) {</span>
<span class="nc" id="L321">                return Double.valueOf(in.readDouble());</span>
            } else {
<span class="nc" id="L323">                throw new Error(&quot;Unrecognized primitive type: &quot; + type);</span>
            }
        } else {
<span class="fc" id="L326">            return in.readObject();</span>
        }
    }

    /**
     * Create an appropriate call object for a new call on this object.
     * Passing operation array and index, allows the stubs generator to
     * assign the operation indexes and interpret them. The RemoteRef
     * may need the operation to encode in for the call.
     */
    public RemoteCall newCall(RemoteObject obj, Operation[] ops, int opnum,
                              long hash)
        throws RemoteException
    {
<span class="fc" id="L340">        clientRefLog.log(Log.BRIEF, &quot;get connection&quot;);</span>

<span class="fc" id="L342">        Connection conn = ref.getChannel().newConnection();</span>
        try {
<span class="fc" id="L344">            clientRefLog.log(Log.VERBOSE, &quot;create call context&quot;);</span>

            /* log information about the outgoing call */
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (clientCallLog.isLoggable(Log.VERBOSE)) {</span>
<span class="fc" id="L348">                logClientCall(obj, ops[opnum]);</span>
            }

<span class="fc" id="L351">            RemoteCall call =</span>
<span class="fc" id="L352">                new StreamRemoteCall(conn, ref.getObjID(), opnum, hash);</span>
            try {
<span class="fc" id="L354">                marshalCustomCallData(call.getOutputStream());</span>
<span class="nc" id="L355">            } catch (IOException e) {</span>
<span class="nc" id="L356">                throw new MarshalException(&quot;error marshaling &quot; +</span>
                                           &quot;custom call data&quot;);
<span class="fc" id="L358">            }</span>
<span class="fc" id="L359">            return call;</span>
<span class="nc" id="L360">        } catch (RemoteException e) {</span>
<span class="nc" id="L361">            ref.getChannel().free(conn, false);</span>
<span class="nc" id="L362">            throw e;</span>
        }
    }

    /**
     * Invoke makes the remote call present in the RemoteCall object.
     *
     * Invoke will raise any &quot;user&quot; exceptions which
     * should pass through and not be caught by the stub.  If any
     * exception is raised during the remote invocation, invoke should
     * take care of cleaning up the connection before raising the
     * &quot;user&quot; or remote exception.
     */
    public void invoke(RemoteCall call) throws Exception {
        try {
<span class="fc" id="L377">            clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;);</span>

<span class="fc" id="L379">            call.executeCall();</span>

<span class="fc" id="L381">        } catch (RemoteException e) {</span>
            /*
             * Call did not complete; connection can't be reused.
             */
<span class="fc" id="L385">            clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);</span>
<span class="fc" id="L386">            free(call, false);</span>
<span class="fc" id="L387">            throw e;</span>

<span class="nc" id="L389">        } catch (Error e) {</span>
            /* If errors occurred, the connection is most likely not
             *  reusable.
             */
<span class="nc" id="L393">            clientRefLog.log(Log.BRIEF, &quot;error: &quot;, e);</span>
<span class="nc" id="L394">            free(call, false);</span>
<span class="nc" id="L395">            throw e;</span>

<span class="nc" id="L397">        } catch (RuntimeException e) {</span>
            /*
             * REMIND: Since runtime exceptions are no longer wrapped,
             * we can't assue that the connection was left in
             * a reusable state. Is this okay?
             */
<span class="nc" id="L403">            clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);</span>
<span class="nc" id="L404">            free(call, false);</span>
<span class="nc" id="L405">            throw e;</span>

<span class="fc" id="L407">        } catch (Exception e) {</span>
            /*
             * Assume that these other exceptions are user exceptions
             * and leave the connection in a reusable state.
             */
<span class="fc" id="L412">            clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);</span>
<span class="fc" id="L413">            free(call, true);</span>
            /* reraise user (and unknown) exceptions. */
<span class="fc" id="L415">            throw e;</span>
<span class="fc" id="L416">        }</span>

        /*
         * Don't free the connection if an exception did not
         * occur because the stub needs to unmarshal the
         * return value. The connection will be freed
         * by a call to the &quot;done&quot; method.
         */
<span class="fc" id="L424">    }</span>

    /**
     * Private method to free a connection.
     */
    private void free(RemoteCall call, boolean reuse) throws RemoteException {
<span class="fc" id="L430">        Connection conn = ((StreamRemoteCall)call).getConnection();</span>
<span class="fc" id="L431">        ref.getChannel().free(conn, reuse);</span>
<span class="fc" id="L432">    }</span>

    /**
     * Done should only be called if the invoke returns successfully
     * (non-exceptionally) to the stub. It allows the remote reference to
     * clean up (or reuse) the connection.
     */
    public void done(RemoteCall call) throws RemoteException {

        /* Done only uses the connection inside the call to obtain the
         * channel the connection uses.  Once all information is read
         * from the connection, the connection may be freed.
         */
<span class="fc" id="L445">        clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;);</span>

        /* Free the call connection early. */
<span class="fc" id="L448">        free(call, true);</span>

        try {
<span class="fc" id="L451">            call.done();</span>
<span class="nc" id="L452">        } catch (IOException e) {</span>
            /* WARNING: If the conn has been reused early, then it is
             * too late to recover from thrown IOExceptions caught
             * here. This code is relying on StreamRemoteCall.done()
             * not actually throwing IOExceptions.
             */
<span class="fc" id="L458">        }</span>
<span class="fc" id="L459">    }</span>

    /**
     * Log the details of an outgoing call.  The method parameter is either of
     * type java.lang.reflect.Method or java.rmi.server.Operation.
     */
    void logClientCall(Object obj, Object method) {
<span class="fc" id="L466">        clientCallLog.log(Log.VERBOSE, &quot;outbound call: &quot; +</span>
<span class="fc" id="L467">            ref + &quot; : &quot; + obj.getClass().getName() +</span>
<span class="fc" id="L468">            ref.getObjID().toString() + &quot;: &quot; + method);</span>
<span class="fc" id="L469">    }</span>

    /**
     * Returns the class of the ref type to be serialized
     */
    public String getRefClass(ObjectOutput out) {
<span class="fc" id="L475">        return &quot;UnicastRef&quot;;</span>
    }

    /**
     * Write out external representation for remote ref.
     */
    public void writeExternal(ObjectOutput out) throws IOException {
<span class="fc" id="L482">        ref.write(out, false);</span>
<span class="fc" id="L483">    }</span>

    /**
     * Read in external representation for remote ref.
     * @exception ClassNotFoundException If the class for an object
     * being restored cannot be found.
     */
    public void readExternal(ObjectInput in)
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L493">        ref = LiveRef.read(in, false);</span>
<span class="fc" id="L494">    }</span>

    //----------------------------------------------------------------------;
    /**
     * Method from object, forward from RemoteObject
     */
    public String remoteToString() {
<span class="fc" id="L501">        return Util.getUnqualifiedName(getClass()) + &quot; [liveRef: &quot; + ref + &quot;]&quot;;</span>
    }

    /**
     * default implementation of hashCode for remote objects
     */
    public int remoteHashCode() {
<span class="fc" id="L508">        return ref.hashCode();</span>
    }

    /** default implementation of equals for remote objects
     */
    public boolean remoteEquals(RemoteRef sub) {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (sub instanceof UnicastRef)</span>
<span class="fc" id="L515">            return ref.remoteEquals(((UnicastRef)sub).ref);</span>
<span class="nc" id="L516">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>