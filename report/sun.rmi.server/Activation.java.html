<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Activation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.rmi.server</a> &gt; <span class="el_source">Activation.java</span></div><h1>Activation.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.rmi.server;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.lang.Process;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.file.Files;
import java.nio.channels.Channel;
import java.nio.channels.ServerSocketChannel;
import java.rmi.AccessException;
import java.rmi.AlreadyBoundException;
import java.rmi.ConnectException;
import java.rmi.ConnectIOException;
import java.rmi.MarshalledObject;
import java.rmi.NoSuchObjectException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.activation.ActivationDesc;
import java.rmi.activation.ActivationException;
import java.rmi.activation.ActivationGroupDesc;
import java.rmi.activation.ActivationGroup;
import java.rmi.activation.ActivationGroupID;
import java.rmi.activation.ActivationID;
import java.rmi.activation.ActivationInstantiator;
import java.rmi.activation.ActivationMonitor;
import java.rmi.activation.ActivationSystem;
import java.rmi.activation.Activator;
import java.rmi.activation.UnknownGroupException;
import java.rmi.activation.UnknownObjectException;
import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.rmi.server.RMIClassLoader;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteServer;
import java.rmi.server.UnicastRemoteObject;
import java.security.AccessControlException;
import java.security.AccessController;
import java.security.AllPermission;
import java.security.CodeSource;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.Permissions;
import java.security.Policy;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.cert.Certificate;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import sun.rmi.log.LogHandler;
import sun.rmi.log.ReliableLog;
import sun.rmi.registry.RegistryImpl;
import sun.rmi.runtime.NewThreadAction;
import sun.rmi.server.UnicastServerRef;
import sun.rmi.transport.LiveRef;
import sun.security.action.GetBooleanAction;
import sun.security.action.GetIntegerAction;
import sun.security.action.GetPropertyAction;
import sun.security.provider.PolicyFile;
import com.sun.rmi.rmid.ExecPermission;
import com.sun.rmi.rmid.ExecOptionPermission;

/**
 * The Activator facilitates remote object activation. A &quot;faulting&quot;
 * remote reference calls the activator's &lt;code&gt;activate&lt;/code&gt; method
 * to obtain a &quot;live&quot; reference to a activatable remote object. Upon
 * receiving a request for activation, the activator looks up the
 * activation descriptor for the activation identifier, id, determines
 * the group in which the object should be activated and invokes the
 * activate method on the object's activation group (described by the
 * remote interface &lt;code&gt;ActivationInstantiator&lt;/code&gt;). The
 * activator initiates the execution of activation groups as
 * necessary. For example, if an activation group for a specific group
 * identifier is not already executing, the activator will spawn a
 * child process for the activation group. &lt;p&gt;
 *
 * The activator is responsible for monitoring and detecting when
 * activation groups fail so that it can remove stale remote references
 * from its internal tables. &lt;p&gt;
 *
 * @author      Ann Wollrath
 * @since       1.2
 */
public class Activation implements Serializable {

    /** indicate compatibility with JDK 1.2 version of class */
    private static final long serialVersionUID = 2921265612698155191L;
    private static final byte MAJOR_VERSION = 1;
    private static final byte MINOR_VERSION = 0;

    /** exec policy object */
    private static Object execPolicy;
    private static Method execPolicyMethod;
    private static boolean debugExec;

    /** maps activation id to its respective group id */
<span class="fc" id="L151">    private Map&lt;ActivationID,ActivationGroupID&gt; idTable =</span>
        new ConcurrentHashMap&lt;&gt;();
    /** maps group id to its GroupEntry groups */
<span class="fc" id="L154">    private Map&lt;ActivationGroupID,GroupEntry&gt; groupTable =</span>
        new ConcurrentHashMap&lt;&gt;();

<span class="fc" id="L157">    private byte majorVersion = MAJOR_VERSION;</span>
<span class="fc" id="L158">    private byte minorVersion = MINOR_VERSION;</span>

    /** number of simultaneous group exec's */
    private transient int groupSemaphore;
    /** counter for numbering groups */
    private transient int groupCounter;
    /** reliable log to hold descriptor table */
    private transient ReliableLog log;
    /** number of updates since last snapshot */
    private transient int numUpdates;

    /** the java command */
    // accessed by GroupEntry
    private transient String[] command;
    /** timeout on wait for child process to be created or destroyed */
<span class="fc" id="L173">    private static final long groupTimeout =</span>
<span class="fc" id="L174">        getInt(&quot;sun.rmi.activation.groupTimeout&quot;, 60000);</span>
    /** take snapshot after this many updates */
<span class="fc" id="L176">    private static final int snapshotInterval =</span>
<span class="fc" id="L177">        getInt(&quot;sun.rmi.activation.snapshotInterval&quot;, 200);</span>
    /** timeout on wait for child process to be created */
<span class="fc" id="L179">    private static final long execTimeout =</span>
<span class="fc" id="L180">        getInt(&quot;sun.rmi.activation.execTimeout&quot;, 30000);</span>

<span class="fc" id="L182">    private static final Object initLock = new Object();</span>
<span class="fc" id="L183">    private static boolean initDone = false;</span>

    // this should be a *private* method since it is privileged
    private static int getInt(String name, int def) {
<span class="fc" id="L187">        return AccessController.doPrivileged(new GetIntegerAction(name, def));</span>
    }

    private transient Activator activator;
    private transient Activator activatorStub;
    private transient ActivationSystem system;
    private transient ActivationSystem systemStub;
    private transient ActivationMonitor monitor;
    private transient Registry registry;
<span class="fc" id="L196">    private transient volatile boolean shuttingDown = false;</span>
    private transient volatile Object startupLock;
    private transient Thread shutdownHook;

<span class="fc" id="L200">    private static ResourceBundle resources = null;</span>

    /**
     * Create an uninitialized instance of Activation that can be
     * populated with log data.  This is only called when the initial
     * snapshot is taken during the first incarnation of rmid.
     */
<span class="fc" id="L207">    private Activation() {}</span>

    /**
     * Recover activation state from the reliable log and initialize
     * activation services.
     */
    private static void startActivation(int port,
                                        RMIServerSocketFactory ssf,
                                        String logName,
                                        String[] childArgs)
        throws Exception
    {
<span class="fc" id="L219">        ReliableLog log = new ReliableLog(logName, new ActLogHandler());</span>
<span class="fc" id="L220">        Activation state = (Activation) log.recover();</span>
<span class="fc" id="L221">        state.init(port, ssf, log, childArgs);</span>
<span class="fc" id="L222">    }</span>

    /**
     * Initialize the Activation instantiation; start activation
     * services.
     */
    private void init(int port,
                      RMIServerSocketFactory ssf,
                      ReliableLog log,
                      String[] childArgs)
        throws Exception
    {
        // initialize
<span class="fc" id="L235">        this.log = log;</span>
<span class="fc" id="L236">        numUpdates = 0;</span>
<span class="fc" id="L237">        shutdownHook =  new ShutdownHook();</span>
<span class="fc" id="L238">        groupSemaphore = getInt(&quot;sun.rmi.activation.groupThrottle&quot;, 3);</span>
<span class="fc" id="L239">        groupCounter = 0;</span>
<span class="fc" id="L240">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span>

        // Use array size of 0, since the value from calling size()
        // may be out of date by the time toArray() is called.
<span class="fc" id="L244">        ActivationGroupID[] gids =</span>
<span class="fc" id="L245">            groupTable.keySet().toArray(new ActivationGroupID[0]);</span>

<span class="fc" id="L247">        synchronized (startupLock = new Object()) {</span>
            // all the remote methods briefly synchronize on startupLock
            // (via checkShutdown) to make sure they don't happen in the
            // middle of this block.  This block must not cause any such
            // incoming remote calls to happen, or deadlock would result!
<span class="fc" id="L252">            activator = new ActivatorImpl(port, ssf);</span>
<span class="fc" id="L253">            activatorStub = (Activator) RemoteObject.toStub(activator);</span>
<span class="fc" id="L254">            system = new ActivationSystemImpl(port, ssf);</span>
<span class="fc" id="L255">            systemStub = (ActivationSystem) RemoteObject.toStub(system);</span>
<span class="fc" id="L256">            monitor = new ActivationMonitorImpl(port, ssf);</span>
<span class="fc" id="L257">            initCommand(childArgs);</span>
<span class="fc" id="L258">            registry = new SystemRegistryImpl(port, null, ssf, systemStub);</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (ssf != null) {</span>
<span class="fc" id="L261">                synchronized (initLock) {</span>
<span class="fc" id="L262">                    initDone = true;</span>
<span class="fc" id="L263">                    initLock.notifyAll();</span>
<span class="pc" id="L264">                }</span>
            }
<span class="pc" id="L266">        }</span>
<span class="fc" id="L267">        startupLock = null;</span>

        // restart services
<span class="fc bfc" id="L270" title="All 2 branches covered.">        for (int i = gids.length; --i &gt;= 0; ) {</span>
            try {
<span class="fc" id="L272">                getGroupEntry(gids[i]).restartServices();</span>
<span class="nc" id="L273">            } catch (UnknownGroupException e) {</span>
<span class="nc" id="L274">                System.err.println(</span>
<span class="nc" id="L275">                    getTextResource(&quot;rmid.restart.group.warning&quot;));</span>
<span class="nc" id="L276">                e.printStackTrace();</span>
<span class="pc" id="L277">            }</span>
        }
<span class="fc" id="L279">    }</span>

    /**
     * Previous versions used HashMap instead of ConcurrentHashMap.
     * Replace any HashMaps found during deserialization with
     * ConcurrentHashMaps.
     */
    private void readObject(ObjectInputStream ois)
        throws IOException, ClassNotFoundException
    {
<span class="fc" id="L289">        ois.defaultReadObject();</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">        if (! (groupTable instanceof ConcurrentHashMap)) {</span>
<span class="nc" id="L291">            groupTable = new ConcurrentHashMap&lt;&gt;(groupTable);</span>
        }
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">        if (! (idTable instanceof ConcurrentHashMap)) {</span>
<span class="nc" id="L294">            idTable = new ConcurrentHashMap&lt;&gt;(idTable);</span>
        }
<span class="fc" id="L296">    }</span>

    private static class SystemRegistryImpl extends RegistryImpl {

<span class="fc" id="L300">        private static final String NAME = ActivationSystem.class.getName();</span>
        private static final long serialVersionUID = 4877330021609408794L;
        private final ActivationSystem systemStub;

        SystemRegistryImpl(int port,
                           RMIClientSocketFactory csf,
                           RMIServerSocketFactory ssf,
                           ActivationSystem systemStub)
            throws RemoteException
        {
<span class="fc" id="L310">            super(port, csf, ssf);</span>
<span class="fc" id="L311">            this.systemStub = systemStub;</span>
<span class="fc" id="L312">        }</span>

        /**
         * Returns the activation system stub if the specified name
         * matches the activation system's class name, otherwise
         * returns the result of invoking super.lookup with the specified
         * name.
         */
        public Remote lookup(String name)
            throws RemoteException, NotBoundException
        {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (name.equals(NAME)) {</span>
<span class="fc" id="L324">                return systemStub;</span>
            } else {
<span class="nc" id="L326">                return super.lookup(name);</span>
            }
        }

        public String[] list() throws RemoteException {
<span class="fc" id="L331">            String[] list1 = super.list();</span>
<span class="fc" id="L332">            int length = list1.length;</span>
<span class="fc" id="L333">            String[] list2 = new String[length + 1];</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">            if (length &gt; 0) {</span>
<span class="nc" id="L335">                System.arraycopy(list1, 0, list2, 0, length);</span>
            }
<span class="fc" id="L337">            list2[length] = NAME;</span>
<span class="fc" id="L338">            return list2;</span>
        }

        public void bind(String name, Remote obj)
            throws RemoteException, AlreadyBoundException, AccessException
        {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (name.equals(NAME)) {</span>
<span class="fc" id="L345">                throw new AccessException(</span>
                    &quot;binding ActivationSystem is disallowed&quot;);
            } else {
<span class="nc" id="L348">                super.bind(name, obj);</span>
            }
<span class="nc" id="L350">        }</span>

        public void unbind(String name)
            throws RemoteException, NotBoundException, AccessException
        {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (name.equals(NAME)) {</span>
<span class="fc" id="L356">                throw new AccessException(</span>
                    &quot;unbinding ActivationSystem is disallowed&quot;);
            } else {
<span class="nc" id="L359">                super.unbind(name);</span>
            }
<span class="nc" id="L361">        }</span>


        public void rebind(String name, Remote obj)
            throws RemoteException, AccessException
        {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (name.equals(NAME)) {</span>
<span class="fc" id="L368">                throw new AccessException(</span>
                    &quot;binding ActivationSystem is disallowed&quot;);
            } else {
<span class="nc" id="L371">                super.rebind(name, obj);</span>
            }
<span class="nc" id="L373">        }</span>
    }


    class ActivatorImpl extends RemoteServer implements Activator {
        // Because ActivatorImpl has a fixed ObjID, it can be
        // called by clients holding stale remote references.  Each of
        // its remote methods, then, must check startupLock (calling
        // checkShutdown() is easiest).

        private static final long serialVersionUID = -3654244726254566136L;

        /**
         * Construct a new Activator on a specified port.
         */
        ActivatorImpl(int port, RMIServerSocketFactory ssf)
            throws RemoteException
<span class="fc" id="L390">        {</span>
            /* Server ref must be created and assigned before remote object
             * 'this' can be exported.
             */
<span class="fc" id="L394">            LiveRef lref =</span>
                new LiveRef(new ObjID(ObjID.ACTIVATOR_ID), port, null, ssf);
<span class="fc" id="L396">            UnicastServerRef uref = new UnicastServerRef(lref);</span>
<span class="fc" id="L397">            ref = uref;</span>
<span class="fc" id="L398">            uref.exportObject(this, null, false);</span>
<span class="fc" id="L399">        }</span>

        public MarshalledObject&lt;? extends Remote&gt; activate(ActivationID id,
                                                           boolean force)
            throws ActivationException, UnknownObjectException, RemoteException
        {
<span class="fc" id="L405">            checkShutdown();</span>
<span class="fc" id="L406">            return getGroupEntry(id).activate(id, force);</span>
        }
    }

    class ActivationMonitorImpl extends UnicastRemoteObject
        implements ActivationMonitor
    {
        private static final long serialVersionUID = -6214940464757948867L;

        ActivationMonitorImpl(int port, RMIServerSocketFactory ssf)
            throws RemoteException
<span class="fc" id="L417">        {</span>
<span class="fc" id="L418">            super(port, null, ssf);</span>
<span class="fc" id="L419">        }</span>

        public void inactiveObject(ActivationID id)
            throws UnknownObjectException, RemoteException
        {
            try {
<span class="fc" id="L425">                checkShutdown();</span>
<span class="fc" id="L426">            } catch (ActivationException e) {</span>
<span class="fc" id="L427">                return;</span>
<span class="fc" id="L428">            }</span>
<span class="fc" id="L429">            RegistryImpl.checkAccess(&quot;Activator.inactiveObject&quot;);</span>
<span class="fc" id="L430">            getGroupEntry(id).inactiveObject(id);</span>
<span class="fc" id="L431">        }</span>

        public void activeObject(ActivationID id,
                                 MarshalledObject&lt;? extends Remote&gt; mobj)
            throws UnknownObjectException, RemoteException
        {
            try {
<span class="fc" id="L438">                checkShutdown();</span>
<span class="nc" id="L439">            } catch (ActivationException e) {</span>
<span class="nc" id="L440">                return;</span>
<span class="fc" id="L441">            }</span>
<span class="fc" id="L442">            RegistryImpl.checkAccess(&quot;ActivationSystem.activeObject&quot;);</span>
<span class="fc" id="L443">            getGroupEntry(id).activeObject(id, mobj);</span>
<span class="fc" id="L444">        }</span>

        public void inactiveGroup(ActivationGroupID id,
                                  long incarnation)
            throws UnknownGroupException, RemoteException
        {
            try {
<span class="fc" id="L451">                checkShutdown();</span>
<span class="fc" id="L452">            } catch (ActivationException e) {</span>
<span class="fc" id="L453">                return;</span>
<span class="fc" id="L454">            }</span>
<span class="fc" id="L455">            RegistryImpl.checkAccess(&quot;ActivationMonitor.inactiveGroup&quot;);</span>
<span class="fc" id="L456">            getGroupEntry(id).inactiveGroup(incarnation, false);</span>
<span class="fc" id="L457">        }</span>
    }


    class ActivationSystemImpl
        extends RemoteServer
        implements ActivationSystem
    {
        private static final long serialVersionUID = 9100152600327688967L;

        // Because ActivationSystemImpl has a fixed ObjID, it can be
        // called by clients holding stale remote references.  Each of
        // its remote methods, then, must check startupLock (calling
        // checkShutdown() is easiest).
        ActivationSystemImpl(int port, RMIServerSocketFactory ssf)
            throws RemoteException
<span class="fc" id="L473">        {</span>
            /* Server ref must be created and assigned before remote object
             * 'this' can be exported.
             */
<span class="fc" id="L477">            LiveRef lref = new LiveRef(new ObjID(4), port, null, ssf);</span>
<span class="fc" id="L478">            UnicastServerRef uref = new UnicastServerRef(lref);</span>
<span class="fc" id="L479">            ref = uref;</span>
<span class="fc" id="L480">            uref.exportObject(this, null);</span>
<span class="fc" id="L481">        }</span>

        public ActivationID registerObject(ActivationDesc desc)
            throws ActivationException, UnknownGroupException, RemoteException
        {
<span class="fc" id="L486">            checkShutdown();</span>
<span class="fc" id="L487">            RegistryImpl.checkAccess(&quot;ActivationSystem.registerObject&quot;);</span>

<span class="fc" id="L489">            ActivationGroupID groupID = desc.getGroupID();</span>
<span class="fc" id="L490">            ActivationID id = new ActivationID(activatorStub);</span>
<span class="fc" id="L491">            getGroupEntry(groupID).registerObject(id, desc, true);</span>
<span class="fc" id="L492">            return id;</span>
        }

        public void unregisterObject(ActivationID id)
            throws ActivationException, UnknownObjectException, RemoteException
        {
<span class="fc" id="L498">            checkShutdown();</span>
<span class="fc" id="L499">            RegistryImpl.checkAccess(&quot;ActivationSystem.unregisterObject&quot;);</span>
<span class="fc" id="L500">            getGroupEntry(id).unregisterObject(id, true);</span>
<span class="fc" id="L501">        }</span>

        public ActivationGroupID registerGroup(ActivationGroupDesc desc)
            throws ActivationException, RemoteException
        {
<span class="fc" id="L506">            checkShutdown();</span>
<span class="fc" id="L507">            RegistryImpl.checkAccess(&quot;ActivationSystem.registerGroup&quot;);</span>
<span class="fc" id="L508">            checkArgs(desc, null);</span>

<span class="fc" id="L510">            ActivationGroupID id = new ActivationGroupID(systemStub);</span>
<span class="fc" id="L511">            GroupEntry entry = new GroupEntry(id, desc);</span>
            // table insertion must take place before log update
<span class="fc" id="L513">            groupTable.put(id, entry);</span>
<span class="fc" id="L514">            addLogRecord(new LogRegisterGroup(id, desc));</span>
<span class="fc" id="L515">            return id;</span>
        }

        public ActivationMonitor activeGroup(ActivationGroupID id,
                                             ActivationInstantiator group,
                                             long incarnation)
            throws ActivationException, UnknownGroupException, RemoteException
        {
<span class="fc" id="L523">            checkShutdown();</span>
<span class="fc" id="L524">            RegistryImpl.checkAccess(&quot;ActivationSystem.activeGroup&quot;);</span>

<span class="fc" id="L526">            getGroupEntry(id).activeGroup(group, incarnation);</span>
<span class="fc" id="L527">            return monitor;</span>
        }

        public void unregisterGroup(ActivationGroupID id)
            throws ActivationException, UnknownGroupException, RemoteException
        {
<span class="fc" id="L533">            checkShutdown();</span>
<span class="fc" id="L534">            RegistryImpl.checkAccess(&quot;ActivationSystem.unregisterGroup&quot;);</span>

            // remove entry before unregister so state is updated before
            // logged
<span class="fc" id="L538">            removeGroupEntry(id).unregisterGroup(true);</span>
<span class="fc" id="L539">        }</span>

        public ActivationDesc setActivationDesc(ActivationID id,
                                                ActivationDesc desc)
            throws ActivationException, UnknownObjectException, RemoteException
        {
<span class="fc" id="L545">            checkShutdown();</span>
<span class="fc" id="L546">            RegistryImpl.checkAccess(&quot;ActivationSystem.setActivationDesc&quot;);</span>

<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if (!getGroupID(id).equals(desc.getGroupID())) {</span>
<span class="nc" id="L549">                throw new ActivationException(</span>
                    &quot;ActivationDesc contains wrong group&quot;);
            }
<span class="fc" id="L552">            return getGroupEntry(id).setActivationDesc(id, desc, true);</span>
        }

        public ActivationGroupDesc setActivationGroupDesc(ActivationGroupID id,
                                                          ActivationGroupDesc desc)
            throws ActivationException, UnknownGroupException, RemoteException
        {
<span class="fc" id="L559">            checkShutdown();</span>
<span class="fc" id="L560">            RegistryImpl.checkAccess(</span>
                &quot;ActivationSystem.setActivationGroupDesc&quot;);

<span class="fc" id="L563">            checkArgs(desc, null);</span>
<span class="fc" id="L564">            return getGroupEntry(id).setActivationGroupDesc(id, desc, true);</span>
        }

        public ActivationDesc getActivationDesc(ActivationID id)
            throws ActivationException, UnknownObjectException, RemoteException
        {
<span class="fc" id="L570">            checkShutdown();</span>
<span class="fc" id="L571">            RegistryImpl.checkAccess(&quot;ActivationSystem.getActivationDesc&quot;);</span>

<span class="fc" id="L573">            return getGroupEntry(id).getActivationDesc(id);</span>
        }

        public ActivationGroupDesc getActivationGroupDesc(ActivationGroupID id)
            throws ActivationException, UnknownGroupException, RemoteException
        {
<span class="fc" id="L579">            checkShutdown();</span>
<span class="fc" id="L580">            RegistryImpl.checkAccess</span>
<span class="fc" id="L581">                (&quot;ActivationSystem.getActivationGroupDesc&quot;);</span>

<span class="fc" id="L583">            return getGroupEntry(id).desc;</span>
        }

        /**
         * Shutdown the activation system. Destroys all groups spawned by
         * the activation daemon and exits the activation daemon.
         */
        public void shutdown() throws AccessException {
<span class="fc" id="L591">            RegistryImpl.checkAccess(&quot;ActivationSystem.shutdown&quot;);</span>

<span class="fc" id="L593">            Object lock = startupLock;</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">            if (lock != null) {</span>
<span class="nc" id="L595">                synchronized (lock) {</span>
                    // nothing
<span class="nc" id="L597">                }</span>
            }

<span class="fc" id="L600">            synchronized (Activation.this) {</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">                if (!shuttingDown) {</span>
<span class="fc" id="L602">                    shuttingDown = true;</span>
<span class="fc" id="L603">                    (new Shutdown()).start();</span>
                }
<span class="pc" id="L605">            }</span>
<span class="fc" id="L606">        }</span>
    }

    private void checkShutdown() throws ActivationException {
        // if the startup critical section is running, wait until it
        // completes/fails before continuing with the remote call.
<span class="fc" id="L612">        Object lock = startupLock;</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if (lock != null) {</span>
<span class="nc" id="L614">            synchronized (lock) {</span>
                // nothing
<span class="nc" id="L616">            }</span>
        }

<span class="fc bfc" id="L619" title="All 2 branches covered.">        if (shuttingDown == true) {</span>
<span class="fc" id="L620">            throw new ActivationException(</span>
                &quot;activation system shutting down&quot;);
        }
<span class="fc" id="L623">    }</span>

    private static void unexport(Remote obj) {
        for (;;) {
            try {
<span class="fc bfc" id="L628" title="All 2 branches covered.">                if (UnicastRemoteObject.unexportObject(obj, false) == true) {</span>
<span class="fc" id="L629">                    break;</span>
                } else {
<span class="fc" id="L631">                    Thread.sleep(100);</span>
                }
<span class="nc" id="L633">            } catch (Exception e) {</span>
<span class="nc" id="L634">                continue;</span>
<span class="fc" id="L635">            }</span>
        }
<span class="fc" id="L637">    }</span>

    /**
     * Thread to shutdown rmid.
     */
    private class Shutdown extends Thread {
<span class="fc" id="L643">        Shutdown() {</span>
<span class="fc" id="L644">            super(&quot;rmid Shutdown&quot;);</span>
<span class="fc" id="L645">        }</span>

        public void run() {
            try {
                /*
                 * Unexport activation system services
                 */
<span class="fc" id="L652">                unexport(activator);</span>
<span class="fc" id="L653">                unexport(system);</span>

                // destroy all child processes (groups)
<span class="fc bfc" id="L656" title="All 2 branches covered.">                for (GroupEntry groupEntry : groupTable.values()) {</span>
<span class="fc" id="L657">                    groupEntry.shutdown();</span>
<span class="fc" id="L658">                }</span>

<span class="fc" id="L660">                Runtime.getRuntime().removeShutdownHook(shutdownHook);</span>

                /*
                 * Unexport monitor safely since all processes are destroyed.
                 */
<span class="fc" id="L665">                unexport(monitor);</span>

                /*
                 * Close log file, fix for 4243264: rmid shutdown thread
                 * interferes with remote calls in progress.  Make sure
                 * the log file is only closed when it is impossible for
                 * its closure to interfere with any pending remote calls.
                 * We close the log when all objects in the rmid VM are
                 * unexported.
                 */
                try {
<span class="fc" id="L676">                    synchronized (log) {</span>
<span class="fc" id="L677">                        log.close();</span>
<span class="pc" id="L678">                    }</span>
<span class="nc" id="L679">                } catch (IOException e) {</span>
<span class="fc" id="L680">                }</span>

            } finally {
                /*
                 * Now exit... A System.exit should only be done if
                 * the RMI activation system daemon was started up
                 * by the main method below (in which should always
                 * be the case since the Activation constructor is private).
                 */
<span class="nc" id="L689">                System.err.println(getTextResource(&quot;rmid.daemon.shutdown&quot;));</span>
<span class="nc" id="L690">                System.exit(0);</span>
<span class="nc" id="L691">            }</span>
<span class="nc" id="L692">        }</span>
    }

    /** Thread to destroy children in the event of abnormal termination. */
    private class ShutdownHook extends Thread {
<span class="fc" id="L697">        ShutdownHook() {</span>
<span class="fc" id="L698">            super(&quot;rmid ShutdownHook&quot;);</span>
<span class="fc" id="L699">        }</span>

        public void run() {
<span class="fc" id="L702">            synchronized (Activation.this) {</span>
<span class="fc" id="L703">                shuttingDown = true;</span>
<span class="pc" id="L704">            }</span>

            // destroy all child processes (groups) quickly
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">            for (GroupEntry groupEntry : groupTable.values()) {</span>
<span class="nc" id="L708">                groupEntry.shutdownFast();</span>
<span class="nc" id="L709">            }</span>
<span class="fc" id="L710">        }</span>
    }

    /**
     * Returns the groupID for a given id of an object in the group.
     * Throws UnknownObjectException if the object is not registered.
     */
    private ActivationGroupID getGroupID(ActivationID id)
        throws UnknownObjectException
    {
<span class="fc" id="L720">        ActivationGroupID groupID = idTable.get(id);</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        if (groupID != null) {</span>
<span class="fc" id="L722">            return groupID;</span>
        }
<span class="fc" id="L724">        throw new UnknownObjectException(&quot;unknown object: &quot; + id);</span>
    }

    /**
     * Returns the group entry for the group id, optionally removing it.
     * Throws UnknownGroupException if the group is not registered.
     */
    private GroupEntry getGroupEntry(ActivationGroupID id, boolean rm)
        throws UnknownGroupException
    {
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        if (id.getClass() == ActivationGroupID.class) {</span>
            GroupEntry entry;
<span class="fc bfc" id="L736" title="All 2 branches covered.">            if (rm) {</span>
<span class="fc" id="L737">                entry = groupTable.remove(id);</span>
            } else {
<span class="fc" id="L739">                entry = groupTable.get(id);</span>
            }
<span class="pc bpc" id="L741" title="1 of 4 branches missed.">            if (entry != null &amp;&amp; !entry.removed) {</span>
<span class="fc" id="L742">                return entry;</span>
            }
        }
<span class="fc" id="L745">        throw new UnknownGroupException(&quot;group unknown&quot;);</span>
    }

    /**
     * Returns the group entry for the group id. Throws
     * UnknownGroupException if the group is not registered.
     */
    private GroupEntry getGroupEntry(ActivationGroupID id)
        throws UnknownGroupException
    {
<span class="fc" id="L755">        return getGroupEntry(id, false);</span>
    }

    /**
     * Removes and returns the group entry for the group id. Throws
     * UnknownGroupException if the group is not registered.
     */
    private GroupEntry removeGroupEntry(ActivationGroupID id)
        throws UnknownGroupException
    {
<span class="fc" id="L765">        return getGroupEntry(id, true);</span>
    }

    /**
     * Returns the group entry for the object's id. Throws
     * UnknownObjectException if the object is not registered or the
     * object's group is not registered.
     */
    private GroupEntry getGroupEntry(ActivationID id)
        throws UnknownObjectException
    {
<span class="fc" id="L776">        ActivationGroupID gid = getGroupID(id);</span>
<span class="fc" id="L777">        GroupEntry entry = groupTable.get(gid);</span>
<span class="pc bpc" id="L778" title="2 of 4 branches missed.">        if (entry != null &amp;&amp; !entry.removed) {</span>
<span class="fc" id="L779">            return entry;</span>
        }
<span class="nc" id="L781">        throw new UnknownObjectException(&quot;object's group removed&quot;);</span>
    }

    /**
     * Container for group information: group's descriptor, group's
     * instantiator, flag to indicate pending group creation, and
     * table of the objects that are activated in the group.
     *
     * WARNING: GroupEntry objects should not be written into log file
     * updates.  GroupEntrys are inner classes of Activation and they
     * can not be serialized independent of this class.  If the
     * complete Activation system is written out as a log update, the
     * point of having updates is nullified.
     */
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">    private class GroupEntry implements Serializable {</span>

        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = 7222464070032993304L;
        private static final int MAX_TRIES = 2;
        private static final int NORMAL = 0;
        private static final int CREATING = 1;
        private static final int TERMINATE = 2;
        private static final int TERMINATING = 3;

<span class="fc" id="L805">        ActivationGroupDesc desc = null;</span>
<span class="fc" id="L806">        ActivationGroupID groupID = null;</span>
<span class="fc" id="L807">        long incarnation = 0;</span>
<span class="fc" id="L808">        Map&lt;ActivationID,ObjectEntry&gt; objects = new HashMap&lt;&gt;();</span>
<span class="fc" id="L809">        Set&lt;ActivationID&gt; restartSet = new HashSet&lt;&gt;();</span>

<span class="fc" id="L811">        transient ActivationInstantiator group = null;</span>
<span class="fc" id="L812">        transient int status = NORMAL;</span>
<span class="fc" id="L813">        transient long waitTime = 0;</span>
<span class="fc" id="L814">        transient String groupName = null;</span>
<span class="fc" id="L815">        transient Process child = null;</span>
<span class="fc" id="L816">        transient boolean removed = false;</span>
<span class="fc" id="L817">        transient Watchdog watchdog = null;</span>

<span class="fc" id="L819">        GroupEntry(ActivationGroupID groupID, ActivationGroupDesc desc) {</span>
<span class="fc" id="L820">            this.groupID = groupID;</span>
<span class="fc" id="L821">            this.desc = desc;</span>
<span class="fc" id="L822">        }</span>

        void restartServices() {
<span class="fc" id="L825">            Iterator&lt;ActivationID&gt; iter = null;</span>

<span class="fc" id="L827">            synchronized (this) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                if (restartSet.isEmpty()) {</span>
<span class="fc" id="L829">                    return;</span>
                }

                /*
                 * Clone the restartSet so the set does not have to be locked
                 * during iteration. Locking the restartSet could cause
                 * deadlock if an object we are restarting caused another
                 * object in this group to be activated.
                 */
<span class="fc" id="L838">                iter = (new HashSet&lt;ActivationID&gt;(restartSet)).iterator();</span>
<span class="pc" id="L839">            }</span>

<span class="fc bfc" id="L841" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L842">                ActivationID id = iter.next();</span>
                try {
<span class="fc" id="L844">                    activate(id, true);</span>
<span class="fc" id="L845">                } catch (Exception e) {</span>
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">                    if (shuttingDown) {</span>
<span class="fc" id="L847">                        return;</span>
                    }
<span class="nc" id="L849">                    System.err.println(</span>
<span class="nc" id="L850">                        getTextResource(&quot;rmid.restart.service.warning&quot;));</span>
<span class="nc" id="L851">                    e.printStackTrace();</span>
<span class="fc" id="L852">                }</span>
<span class="fc" id="L853">            }</span>
<span class="fc" id="L854">        }</span>

        synchronized void activeGroup(ActivationInstantiator inst,
                                      long instIncarnation)
            throws ActivationException, UnknownGroupException
        {
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">            if (incarnation != instIncarnation) {</span>
<span class="nc" id="L861">                throw new ActivationException(&quot;invalid incarnation&quot;);</span>
            }

<span class="fc bfc" id="L864" title="All 2 branches covered.">            if (group != null) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">                if (group.equals(inst)) {</span>
<span class="fc" id="L866">                    return;</span>
                } else {
<span class="fc" id="L868">                    throw new ActivationException(&quot;group already active&quot;);</span>
                }
            }

<span class="pc bpc" id="L872" title="1 of 4 branches missed.">            if (child != null &amp;&amp; status != CREATING) {</span>
<span class="nc" id="L873">                throw new ActivationException(&quot;group not being created&quot;);</span>
            }

<span class="fc" id="L876">            group = inst;</span>
<span class="fc" id="L877">            status = NORMAL;</span>
<span class="fc" id="L878">            notifyAll();</span>
<span class="fc" id="L879">        }</span>

        private void checkRemoved() throws UnknownGroupException {
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">            if (removed) {</span>
<span class="nc" id="L883">                throw new UnknownGroupException(&quot;group removed&quot;);</span>
            }
<span class="fc" id="L885">        }</span>

        private ObjectEntry getObjectEntry(ActivationID id)
            throws UnknownObjectException
        {
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            if (removed) {</span>
<span class="nc" id="L891">                throw new UnknownObjectException(&quot;object's group removed&quot;);</span>
            }
<span class="fc" id="L893">            ObjectEntry objEntry = objects.get(id);</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">            if (objEntry == null) {</span>
<span class="nc" id="L895">                throw new UnknownObjectException(&quot;object unknown&quot;);</span>
            }
<span class="fc" id="L897">            return objEntry;</span>
        }

        synchronized void registerObject(ActivationID id,
                                         ActivationDesc desc,
                                         boolean addRecord)
            throws UnknownGroupException, ActivationException
        {
<span class="fc" id="L905">            checkRemoved();</span>
<span class="fc" id="L906">            objects.put(id, new ObjectEntry(desc));</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">            if (desc.getRestartMode() == true) {</span>
<span class="fc" id="L908">                restartSet.add(id);</span>
            }

            // table insertion must take place before log update
<span class="fc" id="L912">            idTable.put(id, groupID);</span>

<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (addRecord) {</span>
<span class="fc" id="L915">                addLogRecord(new LogRegisterObject(id, desc));</span>
            }
<span class="fc" id="L917">        }</span>

        synchronized void unregisterObject(ActivationID id, boolean addRecord)
            throws UnknownGroupException, ActivationException
        {
<span class="fc" id="L922">            ObjectEntry objEntry = getObjectEntry(id);</span>
<span class="fc" id="L923">            objEntry.removed = true;</span>
<span class="fc" id="L924">            objects.remove(id);</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">            if (objEntry.desc.getRestartMode() == true) {</span>
<span class="nc" id="L926">                restartSet.remove(id);</span>
            }

            // table removal must take place before log update
<span class="fc" id="L930">            idTable.remove(id);</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            if (addRecord) {</span>
<span class="fc" id="L932">                addLogRecord(new LogUnregisterObject(id));</span>
            }
<span class="fc" id="L934">        }</span>

        synchronized void unregisterGroup(boolean addRecord)
           throws UnknownGroupException, ActivationException
        {
<span class="fc" id="L939">            checkRemoved();</span>
<span class="fc" id="L940">            removed = true;</span>
            for (Map.Entry&lt;ActivationID,ObjectEntry&gt; entry :
<span class="fc bfc" id="L942" title="All 2 branches covered.">                     objects.entrySet())</span>
            {
<span class="fc" id="L944">                ActivationID id = entry.getKey();</span>
<span class="fc" id="L945">                idTable.remove(id);</span>
<span class="fc" id="L946">                ObjectEntry objEntry = entry.getValue();</span>
<span class="fc" id="L947">                objEntry.removed = true;</span>
<span class="fc" id="L948">            }</span>
<span class="fc" id="L949">            objects.clear();</span>
<span class="fc" id="L950">            restartSet.clear();</span>
<span class="fc" id="L951">            reset();</span>
<span class="fc" id="L952">            childGone();</span>

            // removal should be recorded before log update
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">            if (addRecord) {</span>
<span class="fc" id="L956">                addLogRecord(new LogUnregisterGroup(groupID));</span>
            }
<span class="fc" id="L958">        }</span>

        synchronized ActivationDesc setActivationDesc(ActivationID id,
                                                      ActivationDesc desc,
                                                      boolean addRecord)
            throws UnknownObjectException, UnknownGroupException,
                   ActivationException
        {
<span class="fc" id="L966">            ObjectEntry objEntry = getObjectEntry(id);</span>
<span class="fc" id="L967">            ActivationDesc oldDesc = objEntry.desc;</span>
<span class="fc" id="L968">            objEntry.desc = desc;</span>
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">            if (desc.getRestartMode() == true) {</span>
<span class="nc" id="L970">                restartSet.add(id);</span>
            } else {
<span class="fc" id="L972">                restartSet.remove(id);</span>
            }
            // restart information should be recorded before log update
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (addRecord) {</span>
<span class="fc" id="L976">                addLogRecord(new LogUpdateDesc(id, desc));</span>
            }

<span class="fc" id="L979">            return oldDesc;</span>
        }

        synchronized ActivationDesc getActivationDesc(ActivationID id)
            throws UnknownObjectException, UnknownGroupException
        {
<span class="fc" id="L985">            return getObjectEntry(id).desc;</span>
        }

        synchronized ActivationGroupDesc setActivationGroupDesc(
                ActivationGroupID id,
                ActivationGroupDesc desc,
                boolean addRecord)
            throws UnknownGroupException, ActivationException
        {
<span class="fc" id="L994">            checkRemoved();</span>
<span class="fc" id="L995">            ActivationGroupDesc oldDesc = this.desc;</span>
<span class="fc" id="L996">            this.desc = desc;</span>
            // state update should occur before log update
<span class="fc bfc" id="L998" title="All 2 branches covered.">            if (addRecord) {</span>
<span class="fc" id="L999">                addLogRecord(new LogUpdateGroupDesc(id, desc));</span>
            }
<span class="fc" id="L1001">            return oldDesc;</span>
        }

        synchronized void inactiveGroup(long incarnation, boolean failure)
            throws UnknownGroupException
        {
<span class="fc" id="L1007">            checkRemoved();</span>
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">            if (this.incarnation != incarnation) {</span>
<span class="nc" id="L1009">                throw new UnknownGroupException(&quot;invalid incarnation&quot;);</span>
            }

<span class="fc" id="L1012">            reset();</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">            if (failure) {</span>
<span class="fc" id="L1014">                terminate();</span>
<span class="pc bpc" id="L1015" title="1 of 4 branches missed.">            } else if (child != null &amp;&amp; status == NORMAL) {</span>
<span class="fc" id="L1016">                status = TERMINATE;</span>
<span class="fc" id="L1017">                watchdog.noRestart();</span>
            }
<span class="fc" id="L1019">        }</span>

        synchronized void activeObject(ActivationID id,
                                       MarshalledObject&lt;? extends Remote&gt; mobj)
                throws UnknownObjectException
        {
<span class="fc" id="L1025">            getObjectEntry(id).stub = mobj;</span>
<span class="fc" id="L1026">        }</span>

        synchronized void inactiveObject(ActivationID id)
            throws UnknownObjectException
        {
<span class="fc" id="L1031">            getObjectEntry(id).reset();</span>
<span class="fc" id="L1032">        }</span>

        private synchronized void reset() {
<span class="fc" id="L1035">            group = null;</span>
<span class="fc bfc" id="L1036" title="All 2 branches covered.">            for (ObjectEntry objectEntry : objects.values()) {</span>
<span class="fc" id="L1037">                objectEntry.reset();</span>
<span class="fc" id="L1038">            }</span>
<span class="fc" id="L1039">        }</span>

        private void childGone() {
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">            if (child != null) {</span>
<span class="fc" id="L1043">                child = null;</span>
<span class="fc" id="L1044">                watchdog.dispose();</span>
<span class="fc" id="L1045">                watchdog = null;</span>
<span class="fc" id="L1046">                status = NORMAL;</span>
<span class="fc" id="L1047">                notifyAll();</span>
            }
<span class="fc" id="L1049">        }</span>

        private void terminate() {
<span class="fc bfc" id="L1052" title="All 4 branches covered.">            if (child != null &amp;&amp; status != TERMINATING) {</span>
<span class="fc" id="L1053">                child.destroy();</span>
<span class="fc" id="L1054">                status = TERMINATING;</span>
<span class="fc" id="L1055">                waitTime = System.currentTimeMillis() + groupTimeout;</span>
<span class="fc" id="L1056">                notifyAll();</span>
            }
<span class="fc" id="L1058">        }</span>

       /*
        * Fallthrough from TERMINATE to TERMINATING
        * is intentional
        */
        @SuppressWarnings(&quot;fallthrough&quot;)
        private void await() {
            while (true) {
<span class="pc bpc" id="L1067" title="2 of 5 branches missed.">                switch (status) {</span>
                case NORMAL:
<span class="fc" id="L1069">                    return;</span>
                case TERMINATE:
<span class="fc" id="L1071">                    terminate();</span>
                case TERMINATING:
                    try {
<span class="nc" id="L1074">                        child.exitValue();</span>
<span class="fc" id="L1075">                    } catch (IllegalThreadStateException e) {</span>
<span class="fc" id="L1076">                        long now = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">                        if (waitTime &gt; now) {</span>
                            try {
<span class="fc" id="L1079">                                wait(waitTime - now);</span>
<span class="nc" id="L1080">                            } catch (InterruptedException ee) {</span>
<span class="fc" id="L1081">                            }</span>
<span class="fc" id="L1082">                            continue;</span>
                        }
                        // REMIND: print message that group did not terminate?
<span class="nc" id="L1085">                    }</span>
<span class="nc" id="L1086">                    childGone();</span>
<span class="nc" id="L1087">                    return;</span>
                case CREATING:
                    try {
<span class="nc" id="L1090">                        wait();</span>
<span class="nc" id="L1091">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L1092">                    }</span>
                }
            }
        }

        // no synchronization to avoid delay wrt getInstantiator
        void shutdownFast() {
<span class="nc" id="L1099">            Process p = child;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            if (p != null) {</span>
<span class="nc" id="L1101">                p.destroy();</span>
            }
<span class="nc" id="L1103">        }</span>

        synchronized void shutdown() {
<span class="fc" id="L1106">            reset();</span>
<span class="fc" id="L1107">            terminate();</span>
<span class="fc" id="L1108">            await();</span>
<span class="fc" id="L1109">        }</span>

        MarshalledObject&lt;? extends Remote&gt; activate(ActivationID id,
                                                    boolean force)
            throws ActivationException
        {
<span class="fc" id="L1115">            Exception detail = null;</span>

            /*
             * Attempt to activate object and reattempt (several times)
             * if activation fails due to communication problems.
             */
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">            for (int tries = MAX_TRIES; tries &gt; 0; tries--) {</span>
                ActivationInstantiator inst;
                long currentIncarnation;

                // look up object to activate
                ObjectEntry objEntry;
<span class="fc" id="L1127">                synchronized (this) {</span>
<span class="fc" id="L1128">                    objEntry = getObjectEntry(id);</span>
                    // if not forcing activation, return cached stub
<span class="fc bfc" id="L1130" title="All 4 branches covered.">                    if (!force &amp;&amp; objEntry.stub != null) {</span>
<span class="fc" id="L1131">                        return objEntry.stub;</span>
                    }
<span class="fc" id="L1133">                    inst = getInstantiator(groupID);</span>
<span class="fc" id="L1134">                    currentIncarnation = incarnation;</span>
<span class="fc" id="L1135">                }</span>

<span class="fc" id="L1137">                boolean groupInactive = false;</span>
<span class="fc" id="L1138">                boolean failure = false;</span>
                // activate object
                try {
<span class="fc" id="L1141">                    return objEntry.activate(id, force, inst);</span>
<span class="nc" id="L1142">                } catch (NoSuchObjectException e) {</span>
<span class="nc" id="L1143">                    groupInactive = true;</span>
<span class="nc" id="L1144">                    detail = e;</span>
<span class="fc" id="L1145">                } catch (ConnectException e) {</span>
<span class="fc" id="L1146">                    groupInactive = true;</span>
<span class="fc" id="L1147">                    failure = true;</span>
<span class="fc" id="L1148">                    detail = e;</span>
<span class="nc" id="L1149">                } catch (ConnectIOException e) {</span>
<span class="nc" id="L1150">                    groupInactive = true;</span>
<span class="nc" id="L1151">                    failure = true;</span>
<span class="nc" id="L1152">                    detail = e;</span>
<span class="nc" id="L1153">                } catch (InactiveGroupException e) {</span>
<span class="nc" id="L1154">                    groupInactive = true;</span>
<span class="nc" id="L1155">                    detail = e;</span>
<span class="nc" id="L1156">                } catch (RemoteException e) {</span>
                    // REMIND: wait some here before continuing?
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                    if (detail == null) {</span>
<span class="nc" id="L1159">                        detail = e;</span>
                    }
<span class="pc" id="L1161">                }</span>

<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">                if (groupInactive) {</span>
                    // group has failed or is inactive; mark inactive
                    try {
<span class="fc" id="L1166">                        System.err.println(</span>
<span class="fc" id="L1167">                            MessageFormat.format(</span>
<span class="fc" id="L1168">                                getTextResource(&quot;rmid.group.inactive&quot;),</span>
<span class="fc" id="L1169">                                detail.toString()));</span>
<span class="fc" id="L1170">                        detail.printStackTrace();</span>
<span class="fc" id="L1171">                        getGroupEntry(groupID).</span>
<span class="fc" id="L1172">                            inactiveGroup(currentIncarnation, failure);</span>
<span class="nc" id="L1173">                    } catch (UnknownGroupException e) {</span>
                        // not a problem
<span class="fc" id="L1175">                    }</span>
                }
            }

            /**
             * signal that group activation failed, nested exception
             * specifies what exception occurred when the group did not
             * activate
             */
<span class="nc" id="L1184">            throw new ActivationException(&quot;object activation failed after &quot; +</span>
                                          MAX_TRIES + &quot; tries&quot;, detail);
        }

        /**
         * Returns the instantiator for the group specified by id and
         * entry. If the group is currently inactive, exec some
         * bootstrap code to create the group.
         */
        private ActivationInstantiator getInstantiator(ActivationGroupID id)
            throws ActivationException
        {
<span class="pc bpc" id="L1196" title="3 of 4 branches missed.">            assert Thread.holdsLock(this);</span>

<span class="fc" id="L1198">            await();</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">            if (group != null) {</span>
<span class="fc" id="L1200">                return group;</span>
            }
<span class="fc" id="L1202">            checkRemoved();</span>
<span class="fc" id="L1203">            boolean acquired = false;</span>

            try {
<span class="fc" id="L1206">                groupName = Pstartgroup();</span>
<span class="fc" id="L1207">                acquired = true;</span>
<span class="fc" id="L1208">                String[] argv = activationArgs(desc);</span>
<span class="fc" id="L1209">                checkArgs(desc, argv);</span>

<span class="fc bfc" id="L1211" title="All 2 branches covered.">                if (debugExec) {</span>
<span class="fc" id="L1212">                    StringBuffer sb = new StringBuffer(argv[0]);</span>
                    int j;
<span class="fc bfc" id="L1214" title="All 2 branches covered.">                    for (j = 1; j &lt; argv.length; j++) {</span>
<span class="fc" id="L1215">                        sb.append(' ');</span>
<span class="fc" id="L1216">                        sb.append(argv[j]);</span>
                    }
<span class="fc" id="L1218">                    System.err.println(</span>
<span class="fc" id="L1219">                        MessageFormat.format(</span>
<span class="fc" id="L1220">                            getTextResource(&quot;rmid.exec.command&quot;),</span>
<span class="fc" id="L1221">                            sb.toString()));</span>
                }

                try {
<span class="fc" id="L1225">                    child = Runtime.getRuntime().exec(argv);</span>
<span class="fc" id="L1226">                    status = CREATING;</span>
<span class="fc" id="L1227">                    ++incarnation;</span>
<span class="fc" id="L1228">                    watchdog = new Watchdog();</span>
<span class="fc" id="L1229">                    watchdog.start();</span>
<span class="fc" id="L1230">                    addLogRecord(new LogGroupIncarnation(id, incarnation));</span>

                    // handle child I/O streams before writing to child
<span class="fc" id="L1233">                    PipeWriter.plugTogetherPair</span>
<span class="fc" id="L1234">                        (child.getInputStream(), System.out,</span>
<span class="fc" id="L1235">                         child.getErrorStream(), System.err);</span>
<span class="pc" id="L1236">                    try (MarshalOutputStream out =</span>
<span class="fc" id="L1237">                            new MarshalOutputStream(child.getOutputStream())) {</span>
<span class="fc" id="L1238">                        out.writeObject(id);</span>
<span class="fc" id="L1239">                        out.writeObject(desc);</span>
<span class="fc" id="L1240">                        out.writeLong(incarnation);</span>
<span class="fc" id="L1241">                        out.flush();</span>
<span class="pc bpc" id="L1242" title="6 of 8 branches missed.">                    }</span>


<span class="nc" id="L1245">                } catch (IOException e) {</span>
<span class="nc" id="L1246">                    terminate();</span>
<span class="nc" id="L1247">                    throw new ActivationException(</span>
                        &quot;unable to create activation group&quot;, e);
<span class="fc" id="L1249">                }</span>

                try {
<span class="fc" id="L1252">                    long now = System.currentTimeMillis();</span>
<span class="fc" id="L1253">                    long stop = now + execTimeout;</span>
                    do {
<span class="fc" id="L1255">                        wait(stop - now);</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">                        if (group != null) {</span>
<span class="fc" id="L1257">                            return group;</span>
                        }
<span class="fc" id="L1259">                        now = System.currentTimeMillis();</span>
<span class="pc bpc" id="L1260" title="3 of 4 branches missed.">                    } while (status == CREATING &amp;&amp; now &lt; stop);</span>
<span class="nc" id="L1261">                } catch (InterruptedException e) {</span>
<span class="fc" id="L1262">                }</span>

<span class="fc" id="L1264">                terminate();</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">                throw new ActivationException(</span>
                        (removed ?
                         &quot;activation group unregistered&quot; :
                         &quot;timeout creating child process&quot;));
            } finally {
<span class="pc bpc" id="L1270" title="2 of 4 branches missed.">                if (acquired) {</span>
<span class="fc" id="L1271">                    Vstartgroup();</span>
                }
            }
        }

        /**
         * Waits for process termination and then restarts services.
         */
        private class Watchdog extends Thread {
<span class="fc" id="L1280">            private final Process groupProcess = child;</span>
<span class="fc" id="L1281">            private final long groupIncarnation = incarnation;</span>
<span class="fc" id="L1282">            private boolean canInterrupt = true;</span>
<span class="fc" id="L1283">            private boolean shouldQuit = false;</span>
<span class="fc" id="L1284">            private boolean shouldRestart = true;</span>

<span class="fc" id="L1286">            Watchdog() {</span>
<span class="fc" id="L1287">                super(&quot;WatchDog-&quot;  + groupName + &quot;-&quot; + incarnation);</span>
<span class="fc" id="L1288">                setDaemon(true);</span>
<span class="fc" id="L1289">            }</span>

            public void run() {

<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">                if (shouldQuit) {</span>
<span class="nc" id="L1294">                    return;</span>
                }

                /*
                 * Wait for the group to crash or exit.
                 */
                try {
<span class="fc" id="L1301">                    groupProcess.waitFor();</span>
<span class="fc" id="L1302">                } catch (InterruptedException exit) {</span>
<span class="fc" id="L1303">                    return;</span>
<span class="fc" id="L1304">                }</span>

<span class="fc" id="L1306">                boolean restart = false;</span>
<span class="fc" id="L1307">                synchronized (GroupEntry.this) {</span>
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">                    if (shouldQuit) {</span>
<span class="nc" id="L1309">                        return;</span>
                    }
<span class="fc" id="L1311">                    canInterrupt = false;</span>
<span class="fc" id="L1312">                    interrupted(); // clear interrupt bit</span>
                    /*
                     * Since the group crashed, we should
                     * reset the entry before activating objects
                     */
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">                    if (groupIncarnation == incarnation) {</span>
<span class="fc bfc" id="L1318" title="All 4 branches covered.">                        restart = shouldRestart &amp;&amp; !shuttingDown;</span>
<span class="fc" id="L1319">                        reset();</span>
<span class="fc" id="L1320">                        childGone();</span>
                    }
<span class="pc" id="L1322">                }</span>

                /*
                 * Activate those objects that require restarting
                 * after a crash.
                 */
<span class="fc bfc" id="L1328" title="All 2 branches covered.">                if (restart) {</span>
<span class="fc" id="L1329">                    restartServices();</span>
                }
<span class="fc" id="L1331">            }</span>

            /**
             * Marks this thread as one that is no longer needed.
             * If the thread is in a state in which it can be interrupted,
             * then the thread is interrupted.
             */
            void dispose() {
<span class="fc" id="L1339">                shouldQuit = true;</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">                if (canInterrupt) {</span>
<span class="fc" id="L1341">                    interrupt();</span>
                }
<span class="fc" id="L1343">            }</span>

            /**
             * Marks this thread as no longer needing to restart objects.
             */
            void noRestart() {
<span class="fc" id="L1349">                shouldRestart = false;</span>
<span class="fc" id="L1350">            }</span>
        }
    }

    private String[] activationArgs(ActivationGroupDesc desc) {
        ActivationGroupDesc.CommandEnvironment cmdenv;
<span class="fc" id="L1356">        cmdenv = desc.getCommandEnvironment();</span>

        // argv is the literal command to exec
<span class="fc" id="L1359">        List&lt;String&gt; argv = new ArrayList&lt;&gt;();</span>

        // Command name/path
<span class="pc bpc" id="L1362" title="3 of 4 branches missed.">        argv.add((cmdenv != null &amp;&amp; cmdenv.getCommandPath() != null)</span>
<span class="pc" id="L1363">                    ? cmdenv.getCommandPath()</span>
                    : command[0]);

        // Group-specific command options
<span class="pc bpc" id="L1367" title="3 of 4 branches missed.">        if (cmdenv != null &amp;&amp; cmdenv.getCommandOptions() != null) {</span>
<span class="nc" id="L1368">            argv.addAll(Arrays.asList(cmdenv.getCommandOptions()));</span>
        }

        // Properties become -D parameters
<span class="fc" id="L1372">        Properties props = desc.getPropertyOverrides();</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">        if (props != null) {</span>
<span class="fc" id="L1374">            for (Enumeration&lt;?&gt; p = props.propertyNames();</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                 p.hasMoreElements();)</span>
            {
<span class="fc" id="L1377">                String name = (String) p.nextElement();</span>
                /* Note on quoting: it would be wrong
                 * here, since argv will be passed to
                 * Runtime.exec, which should not parse
                 * arguments or split on whitespace.
                 */
<span class="fc" id="L1383">                argv.add(&quot;-D&quot; + name + &quot;=&quot; + props.getProperty(name));</span>
<span class="fc" id="L1384">            }</span>
        }

        /* Finally, rmid-global command options (e.g. -C options)
         * and the classname
         */
<span class="fc bfc" id="L1390" title="All 2 branches covered.">        for (int i = 1; i &lt; command.length; i++) {</span>
<span class="fc" id="L1391">            argv.add(command[i]);</span>
        }

<span class="fc" id="L1394">        String[] realArgv = new String[argv.size()];</span>
<span class="fc" id="L1395">        System.arraycopy(argv.toArray(), 0, realArgv, 0, realArgv.length);</span>

<span class="fc" id="L1397">        return realArgv;</span>
    }

    private void checkArgs(ActivationGroupDesc desc, String[] cmd)
        throws SecurityException, ActivationException
    {
        /*
         * Check exec command using execPolicy object
         */
<span class="fc bfc" id="L1406" title="All 2 branches covered.">        if (execPolicyMethod != null) {</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">            if (cmd == null) {</span>
<span class="fc" id="L1408">                cmd = activationArgs(desc);</span>
            }
            try {
<span class="fc" id="L1411">                execPolicyMethod.invoke(execPolicy, desc, cmd);</span>
<span class="nc" id="L1412">            } catch (InvocationTargetException e) {</span>
<span class="nc" id="L1413">                Throwable targetException = e.getTargetException();</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                if (targetException instanceof SecurityException) {</span>
<span class="nc" id="L1415">                    throw (SecurityException) targetException;</span>
                } else {
<span class="nc" id="L1417">                    throw new ActivationException(</span>
<span class="nc" id="L1418">                        execPolicyMethod.getName() + &quot;: unexpected exception&quot;,</span>
                        e);
                }
<span class="nc" id="L1421">            } catch (Exception e) {</span>
<span class="nc" id="L1422">                throw new ActivationException(</span>
<span class="nc" id="L1423">                    execPolicyMethod.getName() + &quot;: unexpected exception&quot;, e);</span>
<span class="fc" id="L1424">            }</span>
        }
<span class="fc" id="L1426">    }</span>

    private static class ObjectEntry implements Serializable {

        private static final long serialVersionUID = -5500114225321357856L;

        /** descriptor for object */
        ActivationDesc desc;
        /** the stub (if active) */
<span class="fc" id="L1435">        volatile transient MarshalledObject&lt;? extends Remote&gt; stub = null;</span>
<span class="fc" id="L1436">        volatile transient boolean removed = false;</span>

<span class="fc" id="L1438">        ObjectEntry(ActivationDesc desc) {</span>
<span class="fc" id="L1439">            this.desc = desc;</span>
<span class="fc" id="L1440">        }</span>

        synchronized MarshalledObject&lt;? extends Remote&gt;
            activate(ActivationID id,
                     boolean force,
                     ActivationInstantiator inst)
            throws RemoteException, ActivationException
        {
<span class="fc" id="L1448">            MarshalledObject&lt;? extends Remote&gt; nstub = stub;</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">            if (removed) {</span>
<span class="nc" id="L1450">                throw new UnknownObjectException(&quot;object removed&quot;);</span>
<span class="pc bpc" id="L1451" title="1 of 4 branches missed.">            } else if (!force &amp;&amp; nstub != null) {</span>
<span class="nc" id="L1452">                return nstub;</span>
            }

<span class="fc" id="L1455">            nstub = inst.newInstance(id, desc);</span>
<span class="fc" id="L1456">            stub = nstub;</span>
            /*
             * stub could be set to null by a group reset, so return
             * the newstub here to prevent returning null.
             */
<span class="fc" id="L1461">            return nstub;</span>
        }

        void reset() {
<span class="fc" id="L1465">            stub = null;</span>
<span class="fc" id="L1466">        }</span>
    }

    /**
     * Add a record to the activation log. If the number of updates
     * passes a predetermined threshold, record a snapshot.
     */
    private void addLogRecord(LogRecord rec) throws ActivationException {
<span class="fc" id="L1474">        synchronized (log) {</span>
<span class="fc" id="L1475">            checkShutdown();</span>
            try {
<span class="fc" id="L1477">                log.update(rec, true);</span>
<span class="nc" id="L1478">            } catch (Exception e) {</span>
<span class="nc" id="L1479">                numUpdates = snapshotInterval;</span>
<span class="nc" id="L1480">                System.err.println(getTextResource(&quot;rmid.log.update.warning&quot;));</span>
<span class="nc" id="L1481">                e.printStackTrace();</span>
<span class="fc" id="L1482">            }</span>
<span class="fc bfc" id="L1483" title="All 2 branches covered.">            if (++numUpdates &lt; snapshotInterval) {</span>
<span class="fc" id="L1484">                return;</span>
            }
            try {
<span class="fc" id="L1487">                log.snapshot(this);</span>
<span class="fc" id="L1488">                numUpdates = 0;</span>
<span class="fc" id="L1489">            } catch (Exception e) {</span>
<span class="fc" id="L1490">                System.err.println(</span>
<span class="fc" id="L1491">                    getTextResource(&quot;rmid.log.snapshot.warning&quot;));</span>
<span class="fc" id="L1492">                e.printStackTrace();</span>
                try {
                    // shutdown activation system because snapshot failed
<span class="fc" id="L1495">                    system.shutdown();</span>
<span class="nc" id="L1496">                } catch (RemoteException ignore) {</span>
                    // can't happen
<span class="fc" id="L1498">                }</span>
                // warn the client of the original update problem
<span class="fc" id="L1500">                throw new ActivationException(&quot;log snapshot failed&quot;, e);</span>
<span class="fc" id="L1501">            }</span>
<span class="fc" id="L1502">        }</span>
<span class="fc" id="L1503">    }</span>

    /**
     * Handler for the log that knows how to take the initial snapshot
     * and apply an update (a LogRecord) to the current state.
     */
    private static class ActLogHandler extends LogHandler {

<span class="fc" id="L1511">        ActLogHandler() {</span>
<span class="fc" id="L1512">        }</span>

        public Object initialSnapshot()
        {
            /**
             * Return an empty Activation object.  Log will update
             * this object with recovered state.
             */
<span class="fc" id="L1520">            return new Activation();</span>
        }

        public Object applyUpdate(Object update, Object state)
            throws Exception
        {
<span class="fc" id="L1526">            return ((LogRecord) update).apply(state);</span>
        }

    }

    /**
     * Abstract class for all log records. The subclass contains
     * specific update information and implements the apply method
     * that applys the update information contained in the record
     * to the current state.
     */
<span class="fc" id="L1537">    private static abstract class LogRecord implements Serializable {</span>
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = 8395140512322687529L;
        abstract Object apply(Object state) throws Exception;
    }

    /**
     * Log record for registering an object.
     */
    private static class LogRegisterObject extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = -6280336276146085143L;
        private ActivationID id;
        private ActivationDesc desc;

<span class="fc" id="L1552">        LogRegisterObject(ActivationID id, ActivationDesc desc) {</span>
<span class="fc" id="L1553">            this.id = id;</span>
<span class="fc" id="L1554">            this.desc = desc;</span>
<span class="fc" id="L1555">        }</span>

        Object apply(Object state) {
            try {
<span class="fc" id="L1559">                ((Activation) state).getGroupEntry(desc.getGroupID()).</span>
<span class="fc" id="L1560">                    registerObject(id, desc, false);</span>
<span class="nc" id="L1561">            } catch (Exception ignore) {</span>
<span class="nc" id="L1562">                System.err.println(</span>
<span class="nc" id="L1563">                    MessageFormat.format(</span>
<span class="nc" id="L1564">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogRegisterObject&quot;));
<span class="nc" id="L1566">                ignore.printStackTrace();</span>
<span class="fc" id="L1567">            }</span>
<span class="fc" id="L1568">            return state;</span>
        }
    }

    /**
     * Log record for unregistering an object.
     */
    private static class LogUnregisterObject extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = 6269824097396935501L;
        private ActivationID id;

<span class="fc" id="L1580">        LogUnregisterObject(ActivationID id) {</span>
<span class="fc" id="L1581">            this.id = id;</span>
<span class="fc" id="L1582">        }</span>

        Object apply(Object state) {
            try {
<span class="nc" id="L1586">                ((Activation) state).getGroupEntry(id).</span>
<span class="nc" id="L1587">                    unregisterObject(id, false);</span>
<span class="nc" id="L1588">            } catch (Exception ignore) {</span>
<span class="nc" id="L1589">                System.err.println(</span>
<span class="nc" id="L1590">                    MessageFormat.format(</span>
<span class="nc" id="L1591">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogUnregisterObject&quot;));
<span class="nc" id="L1593">                ignore.printStackTrace();</span>
<span class="nc" id="L1594">            }</span>
<span class="nc" id="L1595">            return state;</span>
        }
    }

    /**
     * Log record for registering a group.
     */
    private static class LogRegisterGroup extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = -1966827458515403625L;
        private ActivationGroupID id;
        private ActivationGroupDesc desc;

<span class="fc" id="L1608">        LogRegisterGroup(ActivationGroupID id, ActivationGroupDesc desc) {</span>
<span class="fc" id="L1609">            this.id = id;</span>
<span class="fc" id="L1610">            this.desc = desc;</span>
<span class="fc" id="L1611">        }</span>

        Object apply(Object state) {
            // modify state directly; cant ask a nonexistent GroupEntry
            // to register itself.
<span class="fc" id="L1616">            ((Activation) state).groupTable.put(id, ((Activation) state).new</span>
                                                GroupEntry(id, desc));
<span class="fc" id="L1618">            return state;</span>
        }
    }

    /**
     * Log record for udpating an activation desc
     */
    private static class LogUpdateDesc extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = 545511539051179885L;

        private ActivationID id;
        private ActivationDesc desc;

<span class="fc" id="L1632">        LogUpdateDesc(ActivationID id, ActivationDesc desc) {</span>
<span class="fc" id="L1633">            this.id = id;</span>
<span class="fc" id="L1634">            this.desc = desc;</span>
<span class="fc" id="L1635">        }</span>

        Object apply(Object state) {
            try {
<span class="fc" id="L1639">                ((Activation) state).getGroupEntry(id).</span>
<span class="fc" id="L1640">                    setActivationDesc(id, desc, false);</span>
<span class="nc" id="L1641">            } catch (Exception ignore) {</span>
<span class="nc" id="L1642">                System.err.println(</span>
<span class="nc" id="L1643">                    MessageFormat.format(</span>
<span class="nc" id="L1644">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogUpdateDesc&quot;));
<span class="nc" id="L1646">                ignore.printStackTrace();</span>
<span class="fc" id="L1647">            }</span>
<span class="fc" id="L1648">            return state;</span>
        }
    }

    /**
     * Log record for unregistering a group.
     */
    private static class LogUpdateGroupDesc extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = -1271300989218424337L;
        private ActivationGroupID id;
        private ActivationGroupDesc desc;

<span class="fc" id="L1661">        LogUpdateGroupDesc(ActivationGroupID id, ActivationGroupDesc desc) {</span>
<span class="fc" id="L1662">            this.id = id;</span>
<span class="fc" id="L1663">            this.desc = desc;</span>
<span class="fc" id="L1664">        }</span>

        Object apply(Object state) {
            try {
<span class="fc" id="L1668">                ((Activation) state).getGroupEntry(id).</span>
<span class="fc" id="L1669">                    setActivationGroupDesc(id, desc, false);</span>
<span class="nc" id="L1670">            } catch (Exception ignore) {</span>
<span class="nc" id="L1671">                System.err.println(</span>
<span class="nc" id="L1672">                    MessageFormat.format(</span>
<span class="nc" id="L1673">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogUpdateGroupDesc&quot;));
<span class="nc" id="L1675">                ignore.printStackTrace();</span>
<span class="fc" id="L1676">            }</span>
<span class="fc" id="L1677">            return state;</span>
        }
    }

    /**
     * Log record for unregistering a group.
     */
    private static class LogUnregisterGroup extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = -3356306586522147344L;
        private ActivationGroupID id;

<span class="fc" id="L1689">        LogUnregisterGroup(ActivationGroupID id) {</span>
<span class="fc" id="L1690">            this.id = id;</span>
<span class="fc" id="L1691">        }</span>

        Object apply(Object state) {
<span class="nc" id="L1694">            GroupEntry entry = ((Activation) state).groupTable.remove(id);</span>
            try {
<span class="nc" id="L1696">                entry.unregisterGroup(false);</span>
<span class="nc" id="L1697">            } catch (Exception ignore) {</span>
<span class="nc" id="L1698">                System.err.println(</span>
<span class="nc" id="L1699">                    MessageFormat.format(</span>
<span class="nc" id="L1700">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogUnregisterGroup&quot;));
<span class="nc" id="L1702">                ignore.printStackTrace();</span>
<span class="nc" id="L1703">            }</span>
<span class="nc" id="L1704">            return state;</span>
        }
    }

    /**
     * Log record for an active group incarnation
     */
    private static class LogGroupIncarnation extends LogRecord {
        /** indicate compatibility with JDK 1.2 version of class */
        private static final long serialVersionUID = 4146872747377631897L;
        private ActivationGroupID id;
        private long inc;

<span class="fc" id="L1717">        LogGroupIncarnation(ActivationGroupID id, long inc) {</span>
<span class="fc" id="L1718">            this.id = id;</span>
<span class="fc" id="L1719">            this.inc = inc;</span>
<span class="fc" id="L1720">        }</span>

        Object apply(Object state) {
            try {
<span class="fc" id="L1724">                GroupEntry entry = ((Activation) state).getGroupEntry(id);</span>
<span class="fc" id="L1725">                entry.incarnation = inc;</span>
<span class="nc" id="L1726">            } catch (Exception ignore) {</span>
<span class="nc" id="L1727">                System.err.println(</span>
<span class="nc" id="L1728">                    MessageFormat.format(</span>
<span class="nc" id="L1729">                        getTextResource(&quot;rmid.log.recover.warning&quot;),</span>
                        &quot;LogGroupIncarnation&quot;));
<span class="nc" id="L1731">                ignore.printStackTrace();</span>
<span class="fc" id="L1732">            }</span>
<span class="fc" id="L1733">            return state;</span>
        }
    }

    /**
     * Initialize command to exec a default group.
     */
    private void initCommand(String[] childArgs) {
<span class="fc" id="L1741">        command = new String[childArgs.length + 2];</span>
<span class="fc" id="L1742">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
                try {
<span class="fc" id="L1745">                    command[0] = System.getProperty(&quot;java.home&quot;) +</span>
                        File.separator + &quot;bin&quot; + File.separator + &quot;java&quot;;
<span class="nc" id="L1747">                } catch (Exception e) {</span>
<span class="nc" id="L1748">                    System.err.println(</span>
<span class="nc" id="L1749">                        getTextResource(&quot;rmid.unfound.java.home.property&quot;));</span>
<span class="nc" id="L1750">                    command[0] = &quot;java&quot;;</span>
<span class="fc" id="L1751">                }</span>
<span class="fc" id="L1752">                return null;</span>
            }
        });
<span class="fc" id="L1755">        System.arraycopy(childArgs, 0, command, 1, childArgs.length);</span>
<span class="fc" id="L1756">        command[command.length-1] = &quot;sun.rmi.server.ActivationGroupInit&quot;;</span>
<span class="fc" id="L1757">    }</span>

    private static void bomb(String error) {
<span class="nc" id="L1760">        System.err.println(&quot;rmid: &quot; + error); // $NON-NLS$</span>
<span class="nc" id="L1761">        System.err.println(MessageFormat.format(getTextResource(&quot;rmid.usage&quot;),</span>
                    &quot;rmid&quot;));
<span class="nc" id="L1763">        System.exit(1);</span>
<span class="nc" id="L1764">    }</span>

    /**
     * The default policy for checking a command before it is executed
     * makes sure the appropriate com.sun.rmi.rmid.ExecPermission and
     * set of com.sun.rmi.rmid.ExecOptionPermissions have been granted.
     */
<span class="fc" id="L1771">    public static class DefaultExecPolicy {</span>

        public void checkExecCommand(ActivationGroupDesc desc, String[] cmd)
            throws SecurityException
        {
<span class="fc" id="L1776">            PermissionCollection perms = getExecPermissions();</span>

            /*
             * Check properties overrides.
             */
<span class="fc" id="L1781">            Properties props = desc.getPropertyOverrides();</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">            if (props != null) {</span>
<span class="fc" id="L1783">                Enumeration&lt;?&gt; p = props.propertyNames();</span>
<span class="fc bfc" id="L1784" title="All 2 branches covered.">                while (p.hasMoreElements()) {</span>
<span class="fc" id="L1785">                    String name = (String) p.nextElement();</span>
<span class="fc" id="L1786">                    String value = props.getProperty(name);</span>
<span class="fc" id="L1787">                    String option = &quot;-D&quot; + name + &quot;=&quot; + value;</span>
                    try {
<span class="fc" id="L1789">                        checkPermission(perms,</span>
                            new ExecOptionPermission(option));
<span class="fc" id="L1791">                    } catch (AccessControlException e) {</span>
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">                        if (value.equals(&quot;&quot;)) {</span>
<span class="fc" id="L1793">                            checkPermission(perms,</span>
                                new ExecOptionPermission(&quot;-D&quot; + name));
                        } else {
<span class="nc" id="L1796">                            throw e;</span>
                        }
<span class="fc" id="L1798">                    }</span>
<span class="fc" id="L1799">                }</span>
            }

            /*
             * Check group class name (allow nothing but the default),
             * code location (must be null), and data (must be null).
             */
<span class="fc" id="L1806">            String groupClassName = desc.getClassName();</span>
<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">            if ((groupClassName != null &amp;&amp;</span>
<span class="pc bnc" id="L1808" title="All 2 branches missed.">                 !groupClassName.equals(</span>
<span class="nc" id="L1809">                    ActivationGroupImpl.class.getName())) ||</span>
<span class="pc bpc" id="L1810" title="1 of 2 branches missed.">                (desc.getLocation() != null) ||</span>
<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">                (desc.getData() != null))</span>
            {
<span class="nc" id="L1813">                throw new AccessControlException(</span>
                    &quot;access denied (custom group implementation not allowed)&quot;);
            }

            /*
             * If group descriptor has a command environment, check
             * command and options.
             */
            ActivationGroupDesc.CommandEnvironment cmdenv;
<span class="fc" id="L1822">            cmdenv = desc.getCommandEnvironment();</span>
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">            if (cmdenv != null) {</span>
<span class="nc" id="L1824">                String path = cmdenv.getCommandPath();</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">                if (path != null) {</span>
<span class="nc" id="L1826">                    checkPermission(perms, new ExecPermission(path));</span>
                }

<span class="nc" id="L1829">                String[] options = cmdenv.getCommandOptions();</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">                if (options != null) {</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">                    for (String option : options) {</span>
<span class="nc" id="L1832">                        checkPermission(perms,</span>
                                        new ExecOptionPermission(option));
                    }
                }
            }
<span class="fc" id="L1837">        }</span>

        /**
         * Prints warning message if installed Policy is the default Policy
         * implementation and globally granted permissions do not include
         * AllPermission or any ExecPermissions/ExecOptionPermissions.
         */
        static void checkConfiguration() {
<span class="fc" id="L1845">            Policy policy =</span>
<span class="fc" id="L1846">                AccessController.doPrivileged(new PrivilegedAction&lt;Policy&gt;() {</span>
                    public Policy run() {
<span class="fc" id="L1848">                        return Policy.getPolicy();</span>
                    }
                });
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">            if (!(policy instanceof PolicyFile)) {</span>
<span class="nc" id="L1852">                return;</span>
            }
<span class="fc" id="L1854">            PermissionCollection perms = getExecPermissions();</span>
<span class="fc" id="L1855">            for (Enumeration&lt;Permission&gt; e = perms.elements();</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">                 e.hasMoreElements();)</span>
            {
<span class="fc" id="L1858">                Permission p = e.nextElement();</span>
<span class="pc bpc" id="L1859" title="2 of 6 branches missed.">                if (p instanceof AllPermission ||</span>
                    p instanceof ExecPermission ||
                    p instanceof ExecOptionPermission)
                {
<span class="fc" id="L1863">                    return;</span>
                }
<span class="fc" id="L1865">            }</span>
<span class="fc" id="L1866">            System.err.println(getTextResource(&quot;rmid.exec.perms.inadequate&quot;));</span>
<span class="fc" id="L1867">        }</span>

        private static PermissionCollection getExecPermissions() {
            /*
             * The approach used here is taken from the similar method
             * getLoaderAccessControlContext() in the class
             * sun.rmi.server.LoaderHandler.
             */

            // obtain permissions granted to all code in current policy
<span class="fc" id="L1877">            PermissionCollection perms = AccessController.doPrivileged(</span>
<span class="fc" id="L1878">                new PrivilegedAction&lt;PermissionCollection&gt;() {</span>
                    public PermissionCollection run() {
<span class="fc" id="L1880">                        CodeSource codesource =</span>
                            new CodeSource(null, (Certificate[]) null);
<span class="fc" id="L1882">                        Policy p = Policy.getPolicy();</span>
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">                        if (p != null) {</span>
<span class="fc" id="L1884">                            return p.getPermissions(codesource);</span>
                        } else {
<span class="nc" id="L1886">                            return new Permissions();</span>
                        }
                    }
                });

<span class="fc" id="L1891">            return perms;</span>
        }

        private static void checkPermission(PermissionCollection perms,
                                            Permission p)
            throws AccessControlException
        {
<span class="fc bfc" id="L1898" title="All 2 branches covered.">            if (!perms.implies(p)) {</span>
<span class="fc" id="L1899">                throw new AccessControlException(</span>
<span class="fc" id="L1900">                   &quot;access denied &quot; + p.toString());</span>
            }
<span class="fc" id="L1902">        }</span>
    }

    /**
     * Main program to start the activation system. &lt;br&gt;
     * The usage is as follows: rmid [-port num] [-log dir].
     */
    public static void main(String[] args) {
<span class="fc" id="L1910">        boolean stop = false;</span>

        // Create and install the security manager if one is not installed
        // already.
<span class="fc bfc" id="L1914" title="All 2 branches covered.">        if (System.getSecurityManager() == null) {</span>
<span class="fc" id="L1915">            System.setSecurityManager(new SecurityManager());</span>
        }

        try {
<span class="fc" id="L1919">            int port = ActivationSystem.SYSTEM_PORT;</span>
<span class="fc" id="L1920">            RMIServerSocketFactory ssf = null;</span>

            /*
             * If rmid has an inherited channel (meaning that it was
             * launched from inetd), set the server socket factory to
             * return the inherited server socket.
             **/
<span class="fc" id="L1927">            Channel inheritedChannel = AccessController.doPrivileged(</span>
<span class="fc" id="L1928">                new PrivilegedExceptionAction&lt;Channel&gt;() {</span>
                    public Channel run() throws IOException {
<span class="fc" id="L1930">                        return System.inheritedChannel();</span>
                    }
                });

<span class="fc bfc" id="L1934" title="All 4 branches covered.">            if (inheritedChannel != null &amp;&amp;</span>
                inheritedChannel instanceof ServerSocketChannel)
            {
                /*
                 * Redirect System.err output to a file.
                 */
<span class="fc" id="L1940">                AccessController.doPrivileged(</span>
<span class="fc" id="L1941">                    new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                        public Void run() throws IOException {
<span class="fc" id="L1943">                            File file =</span>
<span class="fc" id="L1944">                                Files.createTempFile(&quot;rmid-err&quot;, null).toFile();</span>
<span class="fc" id="L1945">                            PrintStream errStream =</span>
                                new PrintStream(new FileOutputStream(file));
<span class="fc" id="L1947">                            System.setErr(errStream);</span>
<span class="fc" id="L1948">                            return null;</span>
                        }
                    });

<span class="fc" id="L1952">                ServerSocket serverSocket =</span>
<span class="fc" id="L1953">                    ((ServerSocketChannel) inheritedChannel).socket();</span>
<span class="fc" id="L1954">                port = serverSocket.getLocalPort();</span>
<span class="fc" id="L1955">                ssf = new ActivationServerSocketFactory(serverSocket);</span>

<span class="fc" id="L1957">                System.err.println(new Date());</span>
<span class="fc" id="L1958">                System.err.println(getTextResource(</span>
                                       &quot;rmid.inherited.channel.info&quot;) +
                                       &quot;: &quot; + inheritedChannel);
            }

<span class="fc" id="L1963">            String log = null;</span>
<span class="fc" id="L1964">            List&lt;String&gt; childArgs = new ArrayList&lt;&gt;();</span>

            /*
             * Parse arguments
             */
<span class="fc bfc" id="L1969" title="All 2 branches covered.">            for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">                if (args[i].equals(&quot;-port&quot;)) {</span>
<span class="pc bpc" id="L1971" title="1 of 2 branches missed.">                    if (ssf != null) {</span>
<span class="nc" id="L1972">                        bomb(getTextResource(&quot;rmid.syntax.port.badarg&quot;));</span>
                    }
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">                    if ((i + 1) &lt; args.length) {</span>
                        try {
<span class="fc" id="L1976">                            port = Integer.parseInt(args[++i]);</span>
<span class="nc" id="L1977">                        } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L1978">                            bomb(getTextResource(&quot;rmid.syntax.port.badnumber&quot;));</span>
<span class="pc" id="L1979">                        }</span>
                    } else {
<span class="nc" id="L1981">                        bomb(getTextResource(&quot;rmid.syntax.port.missing&quot;));</span>
                    }

<span class="fc bfc" id="L1984" title="All 2 branches covered.">                } else if (args[i].equals(&quot;-log&quot;)) {</span>
<span class="pc bpc" id="L1985" title="1 of 2 branches missed.">                    if ((i + 1) &lt; args.length) {</span>
<span class="fc" id="L1986">                        log = args[++i];</span>
                    } else {
<span class="nc" id="L1988">                        bomb(getTextResource(&quot;rmid.syntax.log.missing&quot;));</span>
                    }

<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">                } else if (args[i].equals(&quot;-stop&quot;)) {</span>
<span class="nc" id="L1992">                    stop = true;</span>

<span class="pc bpc" id="L1994" title="1 of 2 branches missed.">                } else if (args[i].startsWith(&quot;-C&quot;)) {</span>
<span class="fc" id="L1995">                    childArgs.add(args[i].substring(2));</span>

                } else {
<span class="nc" id="L1998">                    bomb(MessageFormat.format(</span>
<span class="nc" id="L1999">                        getTextResource(&quot;rmid.syntax.illegal.option&quot;),</span>
                        args[i]));
                }
            }

<span class="fc bfc" id="L2004" title="All 2 branches covered.">            if (log == null) {</span>
<span class="pc bpc" id="L2005" title="1 of 2 branches missed.">                if (ssf != null) {</span>
<span class="nc" id="L2006">                    bomb(getTextResource(&quot;rmid.syntax.log.required&quot;));</span>
                } else {
<span class="fc" id="L2008">                    log = &quot;log&quot;;</span>
                }
            }

<span class="fc" id="L2012">            debugExec = AccessController.doPrivileged(</span>
                new GetBooleanAction(&quot;sun.rmi.server.activation.debugExec&quot;));

            /**
             * Determine class name for activation exec policy (if any).
             */
<span class="fc" id="L2018">            String execPolicyClassName = AccessController.doPrivileged(</span>
                new GetPropertyAction(&quot;sun.rmi.activation.execPolicy&quot;, null));
<span class="fc bfc" id="L2020" title="All 2 branches covered.">            if (execPolicyClassName == null) {</span>
<span class="pc bpc" id="L2021" title="1 of 2 branches missed.">                if (!stop) {</span>
<span class="fc" id="L2022">                    DefaultExecPolicy.checkConfiguration();</span>
                }
<span class="fc" id="L2024">                execPolicyClassName = &quot;default&quot;;</span>
            }

            /**
             * Initialize method for activation exec policy.
             */
<span class="fc bfc" id="L2030" title="All 2 branches covered.">            if (!execPolicyClassName.equals(&quot;none&quot;)) {</span>
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">                if (execPolicyClassName.equals(&quot;&quot;) ||</span>
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">                    execPolicyClassName.equals(&quot;default&quot;))</span>
                {
<span class="fc" id="L2034">                    execPolicyClassName = DefaultExecPolicy.class.getName();</span>
                }

                try {
<span class="fc" id="L2038">                    Class&lt;?&gt; execPolicyClass = getRMIClass(execPolicyClassName);</span>
<span class="fc" id="L2039">                    execPolicy = execPolicyClass.newInstance();</span>
<span class="fc" id="L2040">                    execPolicyMethod =</span>
<span class="fc" id="L2041">                        execPolicyClass.getMethod(&quot;checkExecCommand&quot;,</span>
                                                  ActivationGroupDesc.class,
                                                  String[].class);
<span class="nc" id="L2044">                } catch (Exception e) {</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">                    if (debugExec) {</span>
<span class="nc" id="L2046">                        System.err.println(</span>
<span class="nc" id="L2047">                            getTextResource(&quot;rmid.exec.policy.exception&quot;));</span>
<span class="nc" id="L2048">                        e.printStackTrace();</span>
                    }
<span class="nc" id="L2050">                    bomb(getTextResource(&quot;rmid.exec.policy.invalid&quot;));</span>
<span class="fc" id="L2051">                }</span>
            }

<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">            if (stop == true) {</span>
<span class="nc" id="L2055">                final int finalPort = port;</span>
<span class="nc" id="L2056">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="nc" id="L2058">                        System.setProperty(&quot;java.rmi.activation.port&quot;,</span>
<span class="nc" id="L2059">                                           Integer.toString(finalPort));</span>
<span class="nc" id="L2060">                        return null;</span>
                    }
                });
<span class="nc" id="L2063">                ActivationSystem system = ActivationGroup.getSystem();</span>
<span class="nc" id="L2064">                system.shutdown();</span>
<span class="nc" id="L2065">                System.exit(0);</span>
            }

            /*
             * Fix for 4173960: Create and initialize activation using
             * a static method, startActivation, which will build the
             * Activation state in two ways: if when rmid is run, no
             * log file is found, the ActLogHandler.recover(...)
             * method will create a new Activation instance.
             * Alternatively, if a logfile is available, a serialized
             * instance of activation will be read from the log's
             * snapshot file.  Log updates will be applied to this
             * Activation object until rmid's state has been fully
             * recovered.  In either case, only one instance of
             * Activation is created.
             */
<span class="fc" id="L2081">            startActivation(port, ssf, log,</span>
<span class="fc" id="L2082">                            childArgs.toArray(new String[childArgs.size()]));</span>

            // prevent activator from exiting
            while (true) {
                try {
<span class="nc" id="L2087">                    Thread.sleep(Long.MAX_VALUE);</span>
<span class="nc" id="L2088">                } catch (InterruptedException e) {</span>
<span class="nc" id="L2089">                }</span>
            }
<span class="nc" id="L2091">        } catch (Exception e) {</span>
<span class="nc" id="L2092">            System.err.println(</span>
<span class="nc" id="L2093">                MessageFormat.format(</span>
<span class="nc" id="L2094">                    getTextResource(&quot;rmid.unexpected.exception&quot;), e));</span>
<span class="nc" id="L2095">            e.printStackTrace();</span>
        }
<span class="nc" id="L2097">        System.exit(1);</span>
<span class="nc" id="L2098">    }</span>

    /**
     * Retrieves text resources from the locale-specific properties file.
     */
    private static String getTextResource(String key) {
<span class="pc bpc" id="L2104" title="1 of 2 branches missed.">        if (Activation.resources == null) {</span>
            try {
<span class="nc" id="L2106">                Activation.resources = ResourceBundle.getBundle(</span>
                    &quot;sun.rmi.server.resources.rmid&quot;);
<span class="fc" id="L2108">            } catch (MissingResourceException mre) {</span>
<span class="nc" id="L2109">            }</span>
<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">            if (Activation.resources == null) {</span>
                // throwing an Error is a bit extreme, methinks
<span class="fc" id="L2112">                return (&quot;[missing resource file: &quot; + key + &quot;]&quot;);</span>
            }
        }

<span class="nc" id="L2116">        String val = null;</span>
        try {
<span class="nc" id="L2118">            val = Activation.resources.getString (key);</span>
<span class="nc" id="L2119">        } catch (MissingResourceException mre) {</span>
<span class="nc" id="L2120">        }</span>

<span class="nc bnc" id="L2122" title="All 2 branches missed.">        if (val == null) {</span>
<span class="nc" id="L2123">            return (&quot;[missing resource: &quot; + key + &quot;]&quot;);</span>
        } else {
<span class="nc" id="L2125">            return val;</span>
        }
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    private static Class&lt;?&gt; getRMIClass(String execPolicyClassName) throws Exception  {
<span class="fc" id="L2131">        return RMIClassLoader.loadClass(execPolicyClassName);</span>
    }
    /*
     * Dijkstra semaphore operations to limit the number of subprocesses
     * rmid attempts to make at once.
     */
    /**
     * Acquire the group semaphore and return a group name.  Each
     * Pstartgroup must be followed by a Vstartgroup.  The calling thread
     * will wait until there are fewer than &lt;code&gt;N&lt;/code&gt; other threads
     * holding the group semaphore.  The calling thread will then acquire
     * the semaphore and return.
     */
    private synchronized String Pstartgroup() throws ActivationException {
        while (true) {
<span class="fc" id="L2146">            checkShutdown();</span>
            // Wait until positive, then decrement.
<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">            if (groupSemaphore &gt; 0) {</span>
<span class="fc" id="L2149">                groupSemaphore--;</span>
<span class="fc" id="L2150">                return &quot;Group-&quot; + groupCounter++;</span>
            }

            try {
<span class="nc" id="L2154">                wait();</span>
<span class="nc" id="L2155">            } catch (InterruptedException e) {</span>
<span class="nc" id="L2156">            }</span>
        }
    }

    /**
     * Release the group semaphore.  Every P operation must be
     * followed by a V operation.  This may cause another thread to
     * wake up and return from its P operation.
     */
    private synchronized void Vstartgroup() {
        // Increment and notify a waiter (not necessarily FIFO).
<span class="fc" id="L2167">        groupSemaphore++;</span>
<span class="fc" id="L2168">        notifyAll();</span>
<span class="fc" id="L2169">    }</span>

    /**
     * A server socket factory to use when rmid is launched via 'inetd'
     * with 'wait' status.  This socket factory's 'createServerSocket'
     * method returns the server socket specified during construction that
     * is specialized to delay accepting requests until the
     * 'initDone' flag is 'true'.  The server socket supplied to
     * the constructor should be the server socket obtained from the
     * ServerSocketChannel returned from the 'System.inheritedChannel'
     * method.
     **/
    private static class ActivationServerSocketFactory
        implements RMIServerSocketFactory
    {
        private final ServerSocket serverSocket;

        /**
         * Constructs an 'ActivationServerSocketFactory' with the specified
         * 'serverSocket'.
         **/
<span class="fc" id="L2190">        ActivationServerSocketFactory(ServerSocket serverSocket) {</span>
<span class="fc" id="L2191">            this.serverSocket = serverSocket;</span>
<span class="fc" id="L2192">        }</span>

        /**
         * Returns the server socket specified during construction wrapped
         * in a 'DelayedAcceptServerSocket'.
         **/
        public ServerSocket createServerSocket(int port)
            throws IOException
        {
<span class="fc" id="L2201">            return new DelayedAcceptServerSocket(serverSocket);</span>
        }

    }

    /**
     * A server socket that delegates all public methods to the underlying
     * server socket specified at construction.  The accept method is
     * overridden to delay calling accept on the underlying server socket
     * until the 'initDone' flag is 'true'.
     **/
    private static class DelayedAcceptServerSocket extends ServerSocket {

        private final ServerSocket serverSocket;

        DelayedAcceptServerSocket(ServerSocket serverSocket)
            throws IOException
<span class="fc" id="L2218">        {</span>
<span class="fc" id="L2219">            this.serverSocket = serverSocket;</span>
<span class="fc" id="L2220">        }</span>

        public void bind(SocketAddress endpoint) throws IOException {
<span class="nc" id="L2223">            serverSocket.bind(endpoint);</span>
<span class="nc" id="L2224">        }</span>

        public void bind(SocketAddress endpoint, int backlog)
                throws IOException
        {
<span class="nc" id="L2229">            serverSocket.bind(endpoint, backlog);</span>
<span class="nc" id="L2230">        }</span>

        public InetAddress getInetAddress() {
<span class="nc" id="L2233">            return AccessController.doPrivileged(</span>
<span class="nc" id="L2234">                new PrivilegedAction&lt;InetAddress&gt;() {</span>
                    @Override
                    public InetAddress run() {
<span class="nc" id="L2237">                        return serverSocket.getInetAddress();</span>
                    }
                });
        }

        public int getLocalPort() {
<span class="nc" id="L2243">            return serverSocket.getLocalPort();</span>
        }

        public SocketAddress getLocalSocketAddress() {
<span class="nc" id="L2247">            return AccessController.doPrivileged(</span>
<span class="nc" id="L2248">                new PrivilegedAction&lt;SocketAddress&gt;() {</span>
                    @Override
                    public SocketAddress run() {
<span class="nc" id="L2251">                        return serverSocket.getLocalSocketAddress();</span>
                    }
                });
        }

        /**
         * Delays calling accept on the underlying server socket until the
         * remote service is bound in the registry.
         **/
        public Socket accept() throws IOException {
<span class="fc" id="L2261">            synchronized (initLock) {</span>
                try {
<span class="fc bfc" id="L2263" title="All 2 branches covered.">                    while (!initDone) {</span>
<span class="fc" id="L2264">                        initLock.wait();</span>
                    }
<span class="nc" id="L2266">                } catch (InterruptedException ignore) {</span>
<span class="nc" id="L2267">                    throw new AssertionError(ignore);</span>
<span class="fc" id="L2268">                }</span>
<span class="pc" id="L2269">            }</span>
<span class="fc" id="L2270">            return serverSocket.accept();</span>
        }

        public void close() throws IOException {
<span class="nc" id="L2274">            serverSocket.close();</span>
<span class="nc" id="L2275">        }</span>

        public ServerSocketChannel getChannel() {
<span class="nc" id="L2278">            return serverSocket.getChannel();</span>
        }

        public boolean isBound() {
<span class="nc" id="L2282">            return serverSocket.isBound();</span>
        }

        public boolean isClosed() {
<span class="nc" id="L2286">            return serverSocket.isClosed();</span>
        }

        public void setSoTimeout(int timeout)
            throws SocketException
        {
<span class="nc" id="L2292">            serverSocket.setSoTimeout(timeout);</span>
<span class="nc" id="L2293">        }</span>

        public int getSoTimeout() throws IOException {
<span class="nc" id="L2296">            return serverSocket.getSoTimeout();</span>
        }

        public void setReuseAddress(boolean on) throws SocketException {
<span class="nc" id="L2300">            serverSocket.setReuseAddress(on);</span>
<span class="nc" id="L2301">        }</span>

        public boolean getReuseAddress() throws SocketException {
<span class="nc" id="L2304">            return serverSocket.getReuseAddress();</span>
        }

        public String toString() {
<span class="nc" id="L2308">            return serverSocket.toString();</span>
        }

        public void setReceiveBufferSize(int size)
            throws SocketException
        {
<span class="nc" id="L2314">            serverSocket.setReceiveBufferSize(size);</span>
<span class="nc" id="L2315">        }</span>

        public int getReceiveBufferSize()
            throws SocketException
        {
<span class="nc" id="L2320">            return serverSocket.getReceiveBufferSize();</span>
        }
    }
}

/**
 * PipeWriter plugs together two pairs of input and output streams by
 * providing readers for input streams and writing through to
 * appropriate output streams.  Both output streams are annotated on a
 * per-line basis.
 *
 * @author Laird Dornin, much code borrowed from Peter Jones, Ken
 *         Arnold and Ann Wollrath.
 */
class PipeWriter implements Runnable {

    /** stream used for buffering lines */
    private ByteArrayOutputStream bufOut;

    /** count since last separator */
    private int cLast;

    /** current chunk of input being compared to lineSeparator.*/
    private byte[] currSep;

    private PrintWriter out;
    private InputStream in;

    private String pipeString;
    private String execString;

    private static String lineSeparator;
    private static int lineSeparatorLength;

<span class="fc" id="L2354">    private static int numExecs = 0;</span>

    static {
<span class="fc" id="L2357">        lineSeparator = AccessController.doPrivileged(</span>
            new GetPropertyAction(&quot;line.separator&quot;));
<span class="fc" id="L2359">        lineSeparatorLength = lineSeparator.length();</span>
<span class="fc" id="L2360">    }</span>

    /**
     * Create a new PipeWriter object. All methods of PipeWriter,
     * except plugTogetherPair, are only accesible to PipeWriter
     * itself.  Synchronization is unnecessary on functions that will
     * only be used internally in PipeWriter.
     *
     * @param in input stream from which pipe input flows
     * @param out output stream to which log messages will be sent
     * @param dest String which tags output stream as 'out' or 'err'
     * @param nExecs number of execed processes, Activation groups.
     */
    private PipeWriter
<span class="fc" id="L2374">        (InputStream in, OutputStream out, String tag, int nExecs) {</span>

<span class="fc" id="L2376">        this.in = in;</span>
<span class="fc" id="L2377">        this.out = new PrintWriter(out);</span>

<span class="fc" id="L2379">        bufOut = new ByteArrayOutputStream();</span>
<span class="fc" id="L2380">        currSep = new byte[lineSeparatorLength];</span>

        /* set unique pipe/pair annotations */
<span class="fc" id="L2383">        execString = &quot;:ExecGroup-&quot; +</span>
<span class="fc" id="L2384">            Integer.toString(nExecs) + ':' + tag + ':';</span>
<span class="fc" id="L2385">    }</span>

    /**
     * Create a thread to listen and read from input stream, in.  buffer
     * the data that is read until a marker which equals lineSeparator
     * is read.  Once such a string has been discovered; write out an
     * annotation string followed by the buffered data and a line
     * separator.
     */
    public void run() {
<span class="fc" id="L2395">        byte[] buf = new byte[256];</span>
        int count;

        try {
            /* read bytes till there are no more. */
<span class="fc bfc" id="L2400" title="All 2 branches covered.">            while ((count = in.read(buf)) != -1) {</span>
<span class="fc" id="L2401">                write(buf, 0, count);</span>
            }

            /*  flush internal buffer... may not have ended on a line
             *  separator, we also need a last annotation if
             *  something was left.
             */
<span class="fc" id="L2408">            String lastInBuffer = bufOut.toString();</span>
<span class="fc" id="L2409">            bufOut.reset();</span>
<span class="pc bpc" id="L2410" title="1 of 2 branches missed.">            if (lastInBuffer.length() &gt; 0) {</span>
<span class="nc" id="L2411">                out.println (createAnnotation() + lastInBuffer);</span>
<span class="nc" id="L2412">                out.flush();                    // add a line separator</span>
                                                // to make output nicer
            }

<span class="fc" id="L2416">        } catch (IOException e) {</span>
<span class="fc" id="L2417">        }</span>
<span class="fc" id="L2418">    }</span>

    /**
     * Write a subarray of bytes.  Pass each through write byte method.
     */
    private void write(byte b[], int off, int len) throws IOException {

<span class="pc bpc" id="L2425" title="1 of 2 branches missed.">        if (len &lt; 0) {</span>
<span class="nc" id="L2426">            throw new ArrayIndexOutOfBoundsException(len);</span>
        }
<span class="fc bfc" id="L2428" title="All 2 branches covered.">        for (int i = 0; i &lt; len; ++ i) {</span>
<span class="fc" id="L2429">            write(b[off + i]);</span>
        }
<span class="fc" id="L2431">    }</span>

    /**
     * Write a byte of data to the stream.  If we have not matched a
     * line separator string, then the byte is appended to the internal
     * buffer.  If we have matched a line separator, then the currently
     * buffered line is sent to the output writer with a prepended
     * annotation string.
     */
    private void write(byte b) throws IOException {
<span class="fc" id="L2441">        int i = 0;</span>

        /* shift current to the left */
<span class="pc bpc" id="L2444" title="1 of 2 branches missed.">        for (i = 1 ; i &lt; (currSep.length); i ++) {</span>
<span class="nc" id="L2445">            currSep[i-1] = currSep[i];</span>
        }
<span class="fc" id="L2447">        currSep[i-1] = b;</span>
<span class="fc" id="L2448">        bufOut.write(b);</span>

        /* enough characters for a separator? */
<span class="pc bpc" id="L2451" title="1 of 2 branches missed.">        if ( (cLast &gt;= (lineSeparatorLength - 1)) &amp;&amp;</span>
<span class="fc bfc" id="L2452" title="All 2 branches covered.">             (lineSeparator.equals(new String(currSep))) ) {</span>

<span class="fc" id="L2454">            cLast = 0;</span>

            /* write prefix through to underlying byte stream */
<span class="fc" id="L2457">            out.print(createAnnotation() + bufOut.toString());</span>
<span class="fc" id="L2458">            out.flush();</span>
<span class="fc" id="L2459">            bufOut.reset();</span>

<span class="pc bpc" id="L2461" title="1 of 2 branches missed.">            if (out.checkError()) {</span>
<span class="nc" id="L2462">                throw new IOException</span>
                    (&quot;PipeWriter: IO Exception when&quot;+
                     &quot; writing to output stream.&quot;);
            }

        } else {
<span class="fc" id="L2468">            cLast++;</span>
        }
<span class="fc" id="L2470">    }</span>

    /**
     * Create an annotation string to be printed out after
     * a new line and end of stream.
     */
    private String createAnnotation() {

        /* construct prefix for log messages:
         * date/time stamp...
         */
<span class="fc" id="L2481">        return ((new Date()).toString()  +</span>
                 /* ... print pair # ... */
                 (execString));
    }

    /**
     * Allow plugging together two pipes at a time, to associate
     * output from an execed process.  This is the only publicly
     * accessible method of this object; this helps ensure that
     * synchronization will not be an issue in the annotation
     * process.
     *
     * @param in input stream from which pipe input comes
     * @param out output stream to which log messages will be sent
     * @param in1 input stream from which pipe input comes
     * @param out1 output stream to which log messages will be sent
     */
    static void plugTogetherPair(InputStream in,
                                 OutputStream out,
                                 InputStream in1,
                                 OutputStream out1) {
<span class="fc" id="L2502">        Thread inThread = null;</span>
<span class="fc" id="L2503">        Thread outThread = null;</span>

<span class="fc" id="L2505">        int nExecs = getNumExec();</span>

        /* start RMI threads to read output from child process */
<span class="fc" id="L2508">        inThread = AccessController.doPrivileged(</span>
            new NewThreadAction(new PipeWriter(in, out, &quot;out&quot;, nExecs),
                                &quot;out&quot;, true));
<span class="fc" id="L2511">        outThread = AccessController.doPrivileged(</span>
            new NewThreadAction(new PipeWriter(in1, out1, &quot;err&quot;, nExecs),
                                &quot;err&quot;, true));
<span class="fc" id="L2514">        inThread.start();</span>
<span class="fc" id="L2515">        outThread.start();</span>
<span class="fc" id="L2516">    }</span>

    private static synchronized int getNumExec() {
<span class="fc" id="L2519">        return numExecs++;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>