<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CheckMethodAdapter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.util</a> &gt; <span class="el_source">CheckMethodAdapter.java</span></div><h1>CheckMethodAdapter.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.util;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jdk.internal.org.objectweb.asm.AnnotationVisitor;
import jdk.internal.org.objectweb.asm.Attribute;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.TypePath;
import jdk.internal.org.objectweb.asm.TypeReference;
import jdk.internal.org.objectweb.asm.tree.MethodNode;
import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
import jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier;

/**
 * A {@link MethodVisitor} that checks that its methods are properly used. More
 * precisely this method adapter checks each instruction individually, i.e.,
 * each visit method checks some preconditions based &lt;i&gt;only&lt;/i&gt; on its
 * arguments - such as the fact that the given opcode is correct for a given
 * visit method. This adapter can also perform some basic data flow checks (more
 * precisely those that can be performed without the full class hierarchy - see
 * {@link jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier}). For instance in a
 * method whose signature is &lt;tt&gt;void m ()&lt;/tt&gt;, the invalid instruction
 * IRETURN, or the invalid sequence IADD L2I will be detected if the data flow
 * checks are enabled. These checks are enabled by using the
 * {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)} constructor.
 * They are not performed if any other constructor is used.
 *
 * @author Eric Bruneton
 */
public class CheckMethodAdapter extends MethodVisitor {

    /**
     * The class version number.
     */
    public int version;

    /**
     * The access flags of the method.
     */
    private int access;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitCode method has been called.
     */
    private boolean startCode;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitMaxs method has been called.
     */
    private boolean endCode;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitEnd method has been called.
     */
    private boolean endMethod;

    /**
     * Number of visited instructions.
     */
    private int insnCount;

    /**
     * The already visited labels. This map associate Integer values to pseudo
     * code offsets.
     */
    private final Map&lt;Label, Integer&gt; labels;

    /**
     * The labels used in this method. Every used label must be visited with
     * visitLabel before the end of the method (i.e. should be in #labels).
     */
    private Set&lt;Label&gt; usedLabels;

    /**
     * Number of visited frames in expanded form.
     */
    private int expandedFrames;

    /**
     * Number of visited frames in compressed form.
     */
    private int compressedFrames;

    /**
     * Number of instructions before the last visited frame.
     */
<span class="nc" id="L158">    private int lastFrame = -1;</span>

    /**
     * The exception handler ranges. Each pair of list element contains the
     * start and end labels of an exception handler block.
     */
    private List&lt;Label&gt; handlers;

    /**
     * Code of the visit method to be used for each opcode.
     */
    private static final int[] TYPE;

    /**
     * The Label.status field.
     */
    private static Field labelStatusField;

    static {
<span class="nc" id="L177">        String s = &quot;BBBBBBBBBBBBBBBBCCIAADDDDDAAAAAAAAAAAAAAAAAAAABBBBBBBBDD&quot;</span>
                + &quot;DDDAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;
                + &quot;BBBBBBBBBBBBBBBBBBBJBBBBBBBBBBBBBBBBBBBBHHHHHHHHHHHHHHHHD&quot;
                + &quot;KLBBBBBBFFFFGGGGAECEBBEEBBAMHHAA&quot;;
<span class="nc" id="L181">        TYPE = new int[s.length()];</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (int i = 0; i &lt; TYPE.length; ++i) {</span>
<span class="nc" id="L183">            TYPE[i] = s.charAt(i) - 'A' - 1;</span>
        }
<span class="nc" id="L185">    }</span>

    // code to generate the above string
    // public static void main (String[] args) {
    // int[] TYPE = new int[] {
    // 0, //NOP
    // 0, //ACONST_NULL
    // 0, //ICONST_M1
    // 0, //ICONST_0
    // 0, //ICONST_1
    // 0, //ICONST_2
    // 0, //ICONST_3
    // 0, //ICONST_4
    // 0, //ICONST_5
    // 0, //LCONST_0
    // 0, //LCONST_1
    // 0, //FCONST_0
    // 0, //FCONST_1
    // 0, //FCONST_2
    // 0, //DCONST_0
    // 0, //DCONST_1
    // 1, //BIPUSH
    // 1, //SIPUSH
    // 7, //LDC
    // -1, //LDC_W
    // -1, //LDC2_W
    // 2, //ILOAD
    // 2, //LLOAD
    // 2, //FLOAD
    // 2, //DLOAD
    // 2, //ALOAD
    // -1, //ILOAD_0
    // -1, //ILOAD_1
    // -1, //ILOAD_2
    // -1, //ILOAD_3
    // -1, //LLOAD_0
    // -1, //LLOAD_1
    // -1, //LLOAD_2
    // -1, //LLOAD_3
    // -1, //FLOAD_0
    // -1, //FLOAD_1
    // -1, //FLOAD_2
    // -1, //FLOAD_3
    // -1, //DLOAD_0
    // -1, //DLOAD_1
    // -1, //DLOAD_2
    // -1, //DLOAD_3
    // -1, //ALOAD_0
    // -1, //ALOAD_1
    // -1, //ALOAD_2
    // -1, //ALOAD_3
    // 0, //IALOAD
    // 0, //LALOAD
    // 0, //FALOAD
    // 0, //DALOAD
    // 0, //AALOAD
    // 0, //BALOAD
    // 0, //CALOAD
    // 0, //SALOAD
    // 2, //ISTORE
    // 2, //LSTORE
    // 2, //FSTORE
    // 2, //DSTORE
    // 2, //ASTORE
    // -1, //ISTORE_0
    // -1, //ISTORE_1
    // -1, //ISTORE_2
    // -1, //ISTORE_3
    // -1, //LSTORE_0
    // -1, //LSTORE_1
    // -1, //LSTORE_2
    // -1, //LSTORE_3
    // -1, //FSTORE_0
    // -1, //FSTORE_1
    // -1, //FSTORE_2
    // -1, //FSTORE_3
    // -1, //DSTORE_0
    // -1, //DSTORE_1
    // -1, //DSTORE_2
    // -1, //DSTORE_3
    // -1, //ASTORE_0
    // -1, //ASTORE_1
    // -1, //ASTORE_2
    // -1, //ASTORE_3
    // 0, //IASTORE
    // 0, //LASTORE
    // 0, //FASTORE
    // 0, //DASTORE
    // 0, //AASTORE
    // 0, //BASTORE
    // 0, //CASTORE
    // 0, //SASTORE
    // 0, //POP
    // 0, //POP2
    // 0, //DUP
    // 0, //DUP_X1
    // 0, //DUP_X2
    // 0, //DUP2
    // 0, //DUP2_X1
    // 0, //DUP2_X2
    // 0, //SWAP
    // 0, //IADD
    // 0, //LADD
    // 0, //FADD
    // 0, //DADD
    // 0, //ISUB
    // 0, //LSUB
    // 0, //FSUB
    // 0, //DSUB
    // 0, //IMUL
    // 0, //LMUL
    // 0, //FMUL
    // 0, //DMUL
    // 0, //IDIV
    // 0, //LDIV
    // 0, //FDIV
    // 0, //DDIV
    // 0, //IREM
    // 0, //LREM
    // 0, //FREM
    // 0, //DREM
    // 0, //INEG
    // 0, //LNEG
    // 0, //FNEG
    // 0, //DNEG
    // 0, //ISHL
    // 0, //LSHL
    // 0, //ISHR
    // 0, //LSHR
    // 0, //IUSHR
    // 0, //LUSHR
    // 0, //IAND
    // 0, //LAND
    // 0, //IOR
    // 0, //LOR
    // 0, //IXOR
    // 0, //LXOR
    // 8, //IINC
    // 0, //I2L
    // 0, //I2F
    // 0, //I2D
    // 0, //L2I
    // 0, //L2F
    // 0, //L2D
    // 0, //F2I
    // 0, //F2L
    // 0, //F2D
    // 0, //D2I
    // 0, //D2L
    // 0, //D2F
    // 0, //I2B
    // 0, //I2C
    // 0, //I2S
    // 0, //LCMP
    // 0, //FCMPL
    // 0, //FCMPG
    // 0, //DCMPL
    // 0, //DCMPG
    // 6, //IFEQ
    // 6, //IFNE
    // 6, //IFLT
    // 6, //IFGE
    // 6, //IFGT
    // 6, //IFLE
    // 6, //IF_ICMPEQ
    // 6, //IF_ICMPNE
    // 6, //IF_ICMPLT
    // 6, //IF_ICMPGE
    // 6, //IF_ICMPGT
    // 6, //IF_ICMPLE
    // 6, //IF_ACMPEQ
    // 6, //IF_ACMPNE
    // 6, //GOTO
    // 6, //JSR
    // 2, //RET
    // 9, //TABLESWITCH
    // 10, //LOOKUPSWITCH
    // 0, //IRETURN
    // 0, //LRETURN
    // 0, //FRETURN
    // 0, //DRETURN
    // 0, //ARETURN
    // 0, //RETURN
    // 4, //GETSTATIC
    // 4, //PUTSTATIC
    // 4, //GETFIELD
    // 4, //PUTFIELD
    // 5, //INVOKEVIRTUAL
    // 5, //INVOKESPECIAL
    // 5, //INVOKESTATIC
    // 5, //INVOKEINTERFACE
    // -1, //INVOKEDYNAMIC
    // 3, //NEW
    // 1, //NEWARRAY
    // 3, //ANEWARRAY
    // 0, //ARRAYLENGTH
    // 0, //ATHROW
    // 3, //CHECKCAST
    // 3, //INSTANCEOF
    // 0, //MONITORENTER
    // 0, //MONITOREXIT
    // -1, //WIDE
    // 11, //MULTIANEWARRAY
    // 6, //IFNULL
    // 6, //IFNONNULL
    // -1, //GOTO_W
    // -1 //JSR_W
    // };
    // for (int i = 0; i &lt; TYPE.length; ++i) {
    // System.out.print((char)(TYPE[i] + 1 + 'A'));
    // }
    // System.out.println();
    // }

    /**
     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
     * will not perform any data flow check (see
     * {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
     * &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead, they must use
     * the {@link #CheckMethodAdapter(int, MethodVisitor, Map)} version.
     *
     * @param mv
     *            the method visitor to which this adapter must delegate calls.
     */
    public CheckMethodAdapter(final MethodVisitor mv) {
<span class="nc" id="L410">        this(mv, new HashMap&lt;Label, Integer&gt;());</span>
<span class="nc" id="L411">    }</span>

    /**
     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
     * will not perform any data flow check (see
     * {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
     * &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead, they must use
     * the {@link #CheckMethodAdapter(int, MethodVisitor, Map)} version.
     *
     * @param mv
     *            the method visitor to which this adapter must delegate calls.
     * @param labels
     *            a map of already visited labels (in other methods).
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public CheckMethodAdapter(final MethodVisitor mv,
            final Map&lt;Label, Integer&gt; labels) {
<span class="nc" id="L429">        this(Opcodes.ASM5, mv, labels);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (getClass() != CheckMethodAdapter.class) {</span>
<span class="nc" id="L431">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L433">    }</span>

    /**
     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
     * will not perform any data flow check (see
     * {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
     *
     * @param mv
     *            the method visitor to which this adapter must delegate calls.
     * @param labels
     *            a map of already visited labels (in other methods).
     */
    protected CheckMethodAdapter(final int api, final MethodVisitor mv,
            final Map&lt;Label, Integer&gt; labels) {
<span class="nc" id="L447">        super(api, mv);</span>
<span class="nc" id="L448">        this.labels = labels;</span>
<span class="nc" id="L449">        this.usedLabels = new HashSet&lt;Label&gt;();</span>
<span class="nc" id="L450">        this.handlers = new ArrayList&lt;Label&gt;();</span>
<span class="nc" id="L451">    }</span>

    /**
     * Constructs a new {@link CheckMethodAdapter} object. This method adapter
     * will perform basic data flow checks. For instance in a method whose
     * signature is &lt;tt&gt;void m ()&lt;/tt&gt;, the invalid instruction IRETURN, or the
     * invalid sequence IADD L2I will be detected.
     *
     * @param access
     *            the method's access flags.
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     * @param cmv
     *            the method visitor to which this adapter must delegate calls.
     * @param labels
     *            a map of already visited labels (in other methods).
     */
    public CheckMethodAdapter(final int access, final String name,
            final String desc, final MethodVisitor cmv,
            final Map&lt;Label, Integer&gt; labels) {
<span class="nc" id="L473">        this(new MethodNode(Opcodes.ASM5, access, name, desc, null, null) {</span>
            @Override
            public void visitEnd() {
<span class="nc" id="L476">                Analyzer&lt;BasicValue&gt; a = new Analyzer&lt;BasicValue&gt;(</span>
                        new BasicVerifier());
                try {
<span class="nc" id="L479">                    a.analyze(&quot;dummy&quot;, this);</span>
<span class="nc" id="L480">                } catch (Exception e) {</span>
<span class="nc bnc" id="L481" title="All 6 branches missed.">                    if (e instanceof IndexOutOfBoundsException</span>
                            &amp;&amp; maxLocals == 0 &amp;&amp; maxStack == 0) {
<span class="nc" id="L483">                        throw new RuntimeException(</span>
                                &quot;Data flow checking option requires valid, non zero maxLocals and maxStack values.&quot;);
                    }
<span class="nc" id="L486">                    e.printStackTrace();</span>
<span class="nc" id="L487">                    StringWriter sw = new StringWriter();</span>
<span class="nc" id="L488">                    PrintWriter pw = new PrintWriter(sw, true);</span>
<span class="nc" id="L489">                    CheckClassAdapter.printAnalyzerResult(this, a, pw);</span>
<span class="nc" id="L490">                    pw.close();</span>
<span class="nc" id="L491">                    throw new RuntimeException(e.getMessage() + ' '</span>
<span class="nc" id="L492">                            + sw.toString());</span>
<span class="nc" id="L493">                }</span>
<span class="nc" id="L494">                accept(cmv);</span>
<span class="nc" id="L495">            }</span>
        }, labels);
<span class="nc" id="L497">        this.access = access;</span>
<span class="nc" id="L498">    }</span>

    @Override
    public void visitParameter(String name, int access) {
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (name != null) {</span>
<span class="nc" id="L503">            checkUnqualifiedName(version, name, &quot;name&quot;);</span>
        }
<span class="nc" id="L505">        CheckClassAdapter.checkAccess(access, Opcodes.ACC_FINAL</span>
                + Opcodes.ACC_MANDATED + Opcodes.ACC_SYNTHETIC);
<span class="nc" id="L507">        super.visitParameter(name, access);</span>
<span class="nc" id="L508">    }</span>

    @Override
    public AnnotationVisitor visitAnnotation(final String desc,
            final boolean visible) {
<span class="nc" id="L513">        checkEndMethod();</span>
<span class="nc" id="L514">        checkDesc(desc, false);</span>
<span class="nc" id="L515">        return new CheckAnnotationAdapter(super.visitAnnotation(desc, visible));</span>
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L521">        checkEndMethod();</span>
<span class="nc" id="L522">        int sort = typeRef &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L523" title="All 12 branches missed.">        if (sort != TypeReference.METHOD_TYPE_PARAMETER</span>
                &amp;&amp; sort != TypeReference.METHOD_TYPE_PARAMETER_BOUND
                &amp;&amp; sort != TypeReference.METHOD_RETURN
                &amp;&amp; sort != TypeReference.METHOD_RECEIVER
                &amp;&amp; sort != TypeReference.METHOD_FORMAL_PARAMETER
                &amp;&amp; sort != TypeReference.THROWS) {
<span class="nc" id="L529">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L530">                    + Integer.toHexString(sort));</span>
        }
<span class="nc" id="L532">        CheckClassAdapter.checkTypeRefAndPath(typeRef, typePath);</span>
<span class="nc" id="L533">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc" id="L534">        return new CheckAnnotationAdapter(super.visitTypeAnnotation(typeRef,</span>
                typePath, desc, visible));
    }

    @Override
    public AnnotationVisitor visitAnnotationDefault() {
<span class="nc" id="L540">        checkEndMethod();</span>
<span class="nc" id="L541">        return new CheckAnnotationAdapter(super.visitAnnotationDefault(), false);</span>
    }

    @Override
    public AnnotationVisitor visitParameterAnnotation(final int parameter,
            final String desc, final boolean visible) {
<span class="nc" id="L547">        checkEndMethod();</span>
<span class="nc" id="L548">        checkDesc(desc, false);</span>
<span class="nc" id="L549">        return new CheckAnnotationAdapter(super.visitParameterAnnotation(</span>
                parameter, desc, visible));
    }

    @Override
    public void visitAttribute(final Attribute attr) {
<span class="nc" id="L555">        checkEndMethod();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (attr == null) {</span>
<span class="nc" id="L557">            throw new IllegalArgumentException(</span>
                    &quot;Invalid attribute (must not be null)&quot;);
        }
<span class="nc" id="L560">        super.visitAttribute(attr);</span>
<span class="nc" id="L561">    }</span>

    @Override
    public void visitCode() {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_ABSTRACT) != 0) {</span>
<span class="nc" id="L566">            throw new RuntimeException(&quot;Abstract methods cannot have code&quot;);</span>
        }
<span class="nc" id="L568">        startCode = true;</span>
<span class="nc" id="L569">        super.visitCode();</span>
<span class="nc" id="L570">    }</span>

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
<span class="nc bnc" id="L575" title="All 2 branches missed.">        if (insnCount == lastFrame) {</span>
<span class="nc" id="L576">            throw new IllegalStateException(</span>
                    &quot;At most one frame can be visited at a given code location.&quot;);
        }
<span class="nc" id="L579">        lastFrame = insnCount;</span>
        int mLocal;
        int mStack;
<span class="nc bnc" id="L582" title="All 5 branches missed.">        switch (type) {</span>
        case Opcodes.F_NEW:
        case Opcodes.F_FULL:
<span class="nc" id="L585">            mLocal = Integer.MAX_VALUE;</span>
<span class="nc" id="L586">            mStack = Integer.MAX_VALUE;</span>
<span class="nc" id="L587">            break;</span>

        case Opcodes.F_SAME:
<span class="nc" id="L590">            mLocal = 0;</span>
<span class="nc" id="L591">            mStack = 0;</span>
<span class="nc" id="L592">            break;</span>

        case Opcodes.F_SAME1:
<span class="nc" id="L595">            mLocal = 0;</span>
<span class="nc" id="L596">            mStack = 1;</span>
<span class="nc" id="L597">            break;</span>

        case Opcodes.F_APPEND:
        case Opcodes.F_CHOP:
<span class="nc" id="L601">            mLocal = 3;</span>
<span class="nc" id="L602">            mStack = 0;</span>
<span class="nc" id="L603">            break;</span>

        default:
<span class="nc" id="L606">            throw new IllegalArgumentException(&quot;Invalid frame type &quot; + type);</span>
        }

<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (nLocal &gt; mLocal) {</span>
<span class="nc" id="L610">            throw new IllegalArgumentException(&quot;Invalid nLocal=&quot; + nLocal</span>
                    + &quot; for frame type &quot; + type);
        }
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (nStack &gt; mStack) {</span>
<span class="nc" id="L614">            throw new IllegalArgumentException(&quot;Invalid nStack=&quot; + nStack</span>
                    + &quot; for frame type &quot; + type);
        }

<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (type != Opcodes.F_CHOP) {</span>
<span class="nc bnc" id="L619" title="All 6 branches missed.">            if (nLocal &gt; 0 &amp;&amp; (local == null || local.length &lt; nLocal)) {</span>
<span class="nc" id="L620">                throw new IllegalArgumentException(</span>
                        &quot;Array local[] is shorter than nLocal&quot;);
            }
<span class="nc bnc" id="L623" title="All 2 branches missed.">            for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L624">                checkFrameValue(local[i]);</span>
            }
        }
<span class="nc bnc" id="L627" title="All 6 branches missed.">        if (nStack &gt; 0 &amp;&amp; (stack == null || stack.length &lt; nStack)) {</span>
<span class="nc" id="L628">            throw new IllegalArgumentException(</span>
                    &quot;Array stack[] is shorter than nStack&quot;);
        }
<span class="nc bnc" id="L631" title="All 2 branches missed.">        for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc" id="L632">            checkFrameValue(stack[i]);</span>
        }
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (type == Opcodes.F_NEW) {</span>
<span class="nc" id="L635">            ++expandedFrames;</span>
        } else {
<span class="nc" id="L637">            ++compressedFrames;</span>
        }
<span class="nc bnc" id="L639" title="All 4 branches missed.">        if (expandedFrames &gt; 0 &amp;&amp; compressedFrames &gt; 0) {</span>
<span class="nc" id="L640">            throw new RuntimeException(</span>
                    &quot;Expanded and compressed frames must not be mixed.&quot;);
        }
<span class="nc" id="L643">        super.visitFrame(type, nLocal, local, nStack, stack);</span>
<span class="nc" id="L644">    }</span>

    @Override
    public void visitInsn(final int opcode) {
<span class="nc" id="L648">        checkStartCode();</span>
<span class="nc" id="L649">        checkEndCode();</span>
<span class="nc" id="L650">        checkOpcode(opcode, 0);</span>
<span class="nc" id="L651">        super.visitInsn(opcode);</span>
<span class="nc" id="L652">        ++insnCount;</span>
<span class="nc" id="L653">    }</span>

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
<span class="nc" id="L657">        checkStartCode();</span>
<span class="nc" id="L658">        checkEndCode();</span>
<span class="nc" id="L659">        checkOpcode(opcode, 1);</span>
<span class="nc bnc" id="L660" title="All 3 branches missed.">        switch (opcode) {</span>
        case Opcodes.BIPUSH:
<span class="nc" id="L662">            checkSignedByte(operand, &quot;Invalid operand&quot;);</span>
<span class="nc" id="L663">            break;</span>
        case Opcodes.SIPUSH:
<span class="nc" id="L665">            checkSignedShort(operand, &quot;Invalid operand&quot;);</span>
<span class="nc" id="L666">            break;</span>
        // case Constants.NEWARRAY:
        default:
<span class="nc bnc" id="L669" title="All 4 branches missed.">            if (operand &lt; Opcodes.T_BOOLEAN || operand &gt; Opcodes.T_LONG) {</span>
<span class="nc" id="L670">                throw new IllegalArgumentException(</span>
                        &quot;Invalid operand (must be an array type code T_...): &quot;
                                + operand);
            }
        }
<span class="nc" id="L675">        super.visitIntInsn(opcode, operand);</span>
<span class="nc" id="L676">        ++insnCount;</span>
<span class="nc" id="L677">    }</span>

    @Override
    public void visitVarInsn(final int opcode, final int var) {
<span class="nc" id="L681">        checkStartCode();</span>
<span class="nc" id="L682">        checkEndCode();</span>
<span class="nc" id="L683">        checkOpcode(opcode, 2);</span>
<span class="nc" id="L684">        checkUnsignedShort(var, &quot;Invalid variable index&quot;);</span>
<span class="nc" id="L685">        super.visitVarInsn(opcode, var);</span>
<span class="nc" id="L686">        ++insnCount;</span>
<span class="nc" id="L687">    }</span>

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
<span class="nc" id="L691">        checkStartCode();</span>
<span class="nc" id="L692">        checkEndCode();</span>
<span class="nc" id="L693">        checkOpcode(opcode, 3);</span>
<span class="nc" id="L694">        checkInternalName(type, &quot;type&quot;);</span>
<span class="nc bnc" id="L695" title="All 4 branches missed.">        if (opcode == Opcodes.NEW &amp;&amp; type.charAt(0) == '[') {</span>
<span class="nc" id="L696">            throw new IllegalArgumentException(</span>
                    &quot;NEW cannot be used to create arrays: &quot; + type);
        }
<span class="nc" id="L699">        super.visitTypeInsn(opcode, type);</span>
<span class="nc" id="L700">        ++insnCount;</span>
<span class="nc" id="L701">    }</span>

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc" id="L706">        checkStartCode();</span>
<span class="nc" id="L707">        checkEndCode();</span>
<span class="nc" id="L708">        checkOpcode(opcode, 4);</span>
<span class="nc" id="L709">        checkInternalName(owner, &quot;owner&quot;);</span>
<span class="nc" id="L710">        checkUnqualifiedName(version, name, &quot;name&quot;);</span>
<span class="nc" id="L711">        checkDesc(desc, false);</span>
<span class="nc" id="L712">        super.visitFieldInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L713">        ++insnCount;</span>
<span class="nc" id="L714">    }</span>

    @Deprecated
    @Override
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (api &gt;= Opcodes.ASM5) {</span>
<span class="nc" id="L721">            super.visitMethodInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L722">            return;</span>
        }
<span class="nc bnc" id="L724" title="All 2 branches missed.">        doVisitMethodInsn(opcode, owner, name, desc,</span>
                opcode == Opcodes.INVOKEINTERFACE);
<span class="nc" id="L726">    }</span>

    @Override
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc, boolean itf) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L732">            super.visitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L733">            return;</span>
        }
<span class="nc" id="L735">        doVisitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L736">    }</span>

    private void doVisitMethodInsn(int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="nc" id="L740">        checkStartCode();</span>
<span class="nc" id="L741">        checkEndCode();</span>
<span class="nc" id="L742">        checkOpcode(opcode, 5);</span>
<span class="nc bnc" id="L743" title="All 4 branches missed.">        if (opcode != Opcodes.INVOKESPECIAL || !&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L744">            checkMethodIdentifier(version, name, &quot;name&quot;);</span>
        }
<span class="nc" id="L746">        checkInternalName(owner, &quot;owner&quot;);</span>
<span class="nc" id="L747">        checkMethodDesc(desc);</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">        if (opcode == Opcodes.INVOKEVIRTUAL &amp;&amp; itf) {</span>
<span class="nc" id="L749">            throw new IllegalArgumentException(</span>
                    &quot;INVOKEVIRTUAL can't be used with interfaces&quot;);
        }
<span class="nc bnc" id="L752" title="All 4 branches missed.">        if (opcode == Opcodes.INVOKEINTERFACE &amp;&amp; !itf) {</span>
<span class="nc" id="L753">            throw new IllegalArgumentException(</span>
                    &quot;INVOKEINTERFACE can't be used with classes&quot;);
        }
        // Calling super.visitMethodInsn requires to call the correct version
        // depending on this.api (otherwise infinite loops can occur). To
        // simplify and to make it easier to automatically remove the backward
        // compatibility code, we inline the code of the overridden method here.
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L761">            mv.visitMethodInsn(opcode, owner, name, desc, itf);</span>
        }
<span class="nc" id="L763">        ++insnCount;</span>
<span class="nc" id="L764">    }</span>

    @Override
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
            Object... bsmArgs) {
<span class="nc" id="L769">        checkStartCode();</span>
<span class="nc" id="L770">        checkEndCode();</span>
<span class="nc" id="L771">        checkMethodIdentifier(version, name, &quot;name&quot;);</span>
<span class="nc" id="L772">        checkMethodDesc(desc);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">        if (bsm.getTag() != Opcodes.H_INVOKESTATIC</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                &amp;&amp; bsm.getTag() != Opcodes.H_NEWINVOKESPECIAL) {</span>
<span class="nc" id="L775">            throw new IllegalArgumentException(&quot;invalid handle tag &quot;</span>
<span class="nc" id="L776">                    + bsm.getTag());</span>
        }
<span class="nc bnc" id="L778" title="All 2 branches missed.">        for (int i = 0; i &lt; bsmArgs.length; i++) {</span>
<span class="nc" id="L779">            checkLDCConstant(bsmArgs[i]);</span>
        }
<span class="nc" id="L781">        super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);</span>
<span class="nc" id="L782">        ++insnCount;</span>
<span class="nc" id="L783">    }</span>

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
<span class="nc" id="L787">        checkStartCode();</span>
<span class="nc" id="L788">        checkEndCode();</span>
<span class="nc" id="L789">        checkOpcode(opcode, 6);</span>
<span class="nc" id="L790">        checkLabel(label, false, &quot;label&quot;);</span>
<span class="nc" id="L791">        checkNonDebugLabel(label);</span>
<span class="nc" id="L792">        super.visitJumpInsn(opcode, label);</span>
<span class="nc" id="L793">        usedLabels.add(label);</span>
<span class="nc" id="L794">        ++insnCount;</span>
<span class="nc" id="L795">    }</span>

    @Override
    public void visitLabel(final Label label) {
<span class="nc" id="L799">        checkStartCode();</span>
<span class="nc" id="L800">        checkEndCode();</span>
<span class="nc" id="L801">        checkLabel(label, false, &quot;label&quot;);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (labels.get(label) != null) {</span>
<span class="nc" id="L803">            throw new IllegalArgumentException(&quot;Already visited label&quot;);</span>
        }
<span class="nc" id="L805">        labels.put(label, new Integer(insnCount));</span>
<span class="nc" id="L806">        super.visitLabel(label);</span>
<span class="nc" id="L807">    }</span>

    @Override
    public void visitLdcInsn(final Object cst) {
<span class="nc" id="L811">        checkStartCode();</span>
<span class="nc" id="L812">        checkEndCode();</span>
<span class="nc" id="L813">        checkLDCConstant(cst);</span>
<span class="nc" id="L814">        super.visitLdcInsn(cst);</span>
<span class="nc" id="L815">        ++insnCount;</span>
<span class="nc" id="L816">    }</span>

    @Override
    public void visitIincInsn(final int var, final int increment) {
<span class="nc" id="L820">        checkStartCode();</span>
<span class="nc" id="L821">        checkEndCode();</span>
<span class="nc" id="L822">        checkUnsignedShort(var, &quot;Invalid variable index&quot;);</span>
<span class="nc" id="L823">        checkSignedShort(increment, &quot;Invalid increment&quot;);</span>
<span class="nc" id="L824">        super.visitIincInsn(var, increment);</span>
<span class="nc" id="L825">        ++insnCount;</span>
<span class="nc" id="L826">    }</span>

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels) {
<span class="nc" id="L831">        checkStartCode();</span>
<span class="nc" id="L832">        checkEndCode();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (max &lt; min) {</span>
<span class="nc" id="L834">            throw new IllegalArgumentException(&quot;Max = &quot; + max</span>
                    + &quot; must be greater than or equal to min = &quot; + min);
        }
<span class="nc" id="L837">        checkLabel(dflt, false, &quot;default label&quot;);</span>
<span class="nc" id="L838">        checkNonDebugLabel(dflt);</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">        if (labels == null || labels.length != max - min + 1) {</span>
<span class="nc" id="L840">            throw new IllegalArgumentException(</span>
                    &quot;There must be max - min + 1 labels&quot;);
        }
<span class="nc bnc" id="L843" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L844">            checkLabel(labels[i], false, &quot;label at index &quot; + i);</span>
<span class="nc" id="L845">            checkNonDebugLabel(labels[i]);</span>
        }
<span class="nc" id="L847">        super.visitTableSwitchInsn(min, max, dflt, labels);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L849">            usedLabels.add(labels[i]);</span>
        }
<span class="nc" id="L851">        ++insnCount;</span>
<span class="nc" id="L852">    }</span>

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
            final Label[] labels) {
<span class="nc" id="L857">        checkEndCode();</span>
<span class="nc" id="L858">        checkStartCode();</span>
<span class="nc" id="L859">        checkLabel(dflt, false, &quot;default label&quot;);</span>
<span class="nc" id="L860">        checkNonDebugLabel(dflt);</span>
<span class="nc bnc" id="L861" title="All 6 branches missed.">        if (keys == null || labels == null || keys.length != labels.length) {</span>
<span class="nc" id="L862">            throw new IllegalArgumentException(</span>
                    &quot;There must be the same number of keys and labels&quot;);
        }
<span class="nc bnc" id="L865" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L866">            checkLabel(labels[i], false, &quot;label at index &quot; + i);</span>
<span class="nc" id="L867">            checkNonDebugLabel(labels[i]);</span>
        }
<span class="nc" id="L869">        super.visitLookupSwitchInsn(dflt, keys, labels);</span>
<span class="nc" id="L870">        usedLabels.add(dflt);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L872">            usedLabels.add(labels[i]);</span>
        }
<span class="nc" id="L874">        ++insnCount;</span>
<span class="nc" id="L875">    }</span>

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L879">        checkStartCode();</span>
<span class="nc" id="L880">        checkEndCode();</span>
<span class="nc" id="L881">        checkDesc(desc, false);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (desc.charAt(0) != '[') {</span>
<span class="nc" id="L883">            throw new IllegalArgumentException(</span>
                    &quot;Invalid descriptor (must be an array type descriptor): &quot;
                            + desc);
        }
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (dims &lt; 1) {</span>
<span class="nc" id="L888">            throw new IllegalArgumentException(</span>
                    &quot;Invalid dimensions (must be greater than 0): &quot; + dims);
        }
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (dims &gt; desc.lastIndexOf('[') + 1) {</span>
<span class="nc" id="L892">            throw new IllegalArgumentException(</span>
                    &quot;Invalid dimensions (must not be greater than dims(desc)): &quot;
                            + dims);
        }
<span class="nc" id="L896">        super.visitMultiANewArrayInsn(desc, dims);</span>
<span class="nc" id="L897">        ++insnCount;</span>
<span class="nc" id="L898">    }</span>

    @Override
    public AnnotationVisitor visitInsnAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L903">        checkStartCode();</span>
<span class="nc" id="L904">        checkEndCode();</span>
<span class="nc" id="L905">        int sort = typeRef &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L906" title="All 18 branches missed.">        if (sort != TypeReference.INSTANCEOF &amp;&amp; sort != TypeReference.NEW</span>
                &amp;&amp; sort != TypeReference.CONSTRUCTOR_REFERENCE
                &amp;&amp; sort != TypeReference.METHOD_REFERENCE
                &amp;&amp; sort != TypeReference.CAST
                &amp;&amp; sort != TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
                &amp;&amp; sort != TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT
                &amp;&amp; sort != TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
                &amp;&amp; sort != TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT) {
<span class="nc" id="L914">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L915">                    + Integer.toHexString(sort));</span>
        }
<span class="nc" id="L917">        CheckClassAdapter.checkTypeRefAndPath(typeRef, typePath);</span>
<span class="nc" id="L918">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc" id="L919">        return new CheckAnnotationAdapter(super.visitInsnAnnotation(typeRef,</span>
                typePath, desc, visible));
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end,
            final Label handler, final String type) {
<span class="nc" id="L926">        checkStartCode();</span>
<span class="nc" id="L927">        checkEndCode();</span>
<span class="nc" id="L928">        checkLabel(start, false, &quot;start label&quot;);</span>
<span class="nc" id="L929">        checkLabel(end, false, &quot;end label&quot;);</span>
<span class="nc" id="L930">        checkLabel(handler, false, &quot;handler label&quot;);</span>
<span class="nc" id="L931">        checkNonDebugLabel(start);</span>
<span class="nc" id="L932">        checkNonDebugLabel(end);</span>
<span class="nc" id="L933">        checkNonDebugLabel(handler);</span>
<span class="nc bnc" id="L934" title="All 4 branches missed.">        if (labels.get(start) != null || labels.get(end) != null</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                || labels.get(handler) != null) {</span>
<span class="nc" id="L936">            throw new IllegalStateException(</span>
                    &quot;Try catch blocks must be visited before their labels&quot;);
        }
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (type != null) {</span>
<span class="nc" id="L940">            checkInternalName(type, &quot;type&quot;);</span>
        }
<span class="nc" id="L942">        super.visitTryCatchBlock(start, end, handler, type);</span>
<span class="nc" id="L943">        handlers.add(start);</span>
<span class="nc" id="L944">        handlers.add(end);</span>
<span class="nc" id="L945">    }</span>

    @Override
    public AnnotationVisitor visitTryCatchAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L950">        checkStartCode();</span>
<span class="nc" id="L951">        checkEndCode();</span>
<span class="nc" id="L952">        int sort = typeRef &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (sort != TypeReference.EXCEPTION_PARAMETER) {</span>
<span class="nc" id="L954">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L955">                    + Integer.toHexString(sort));</span>
        }
<span class="nc" id="L957">        CheckClassAdapter.checkTypeRefAndPath(typeRef, typePath);</span>
<span class="nc" id="L958">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc" id="L959">        return new CheckAnnotationAdapter(super.visitTryCatchAnnotation(</span>
                typeRef, typePath, desc, visible));
    }

    @Override
    public void visitLocalVariable(final String name, final String desc,
            final String signature, final Label start, final Label end,
            final int index) {
<span class="nc" id="L967">        checkStartCode();</span>
<span class="nc" id="L968">        checkEndCode();</span>
<span class="nc" id="L969">        checkUnqualifiedName(version, name, &quot;name&quot;);</span>
<span class="nc" id="L970">        checkDesc(desc, false);</span>
<span class="nc" id="L971">        checkLabel(start, true, &quot;start label&quot;);</span>
<span class="nc" id="L972">        checkLabel(end, true, &quot;end label&quot;);</span>
<span class="nc" id="L973">        checkUnsignedShort(index, &quot;Invalid variable index&quot;);</span>
<span class="nc" id="L974">        int s = labels.get(start).intValue();</span>
<span class="nc" id="L975">        int e = labels.get(end).intValue();</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (e &lt; s) {</span>
<span class="nc" id="L977">            throw new IllegalArgumentException(</span>
                    &quot;Invalid start and end labels (end must be greater than start)&quot;);
        }
<span class="nc" id="L980">        super.visitLocalVariable(name, desc, signature, start, end, index);</span>
<span class="nc" id="L981">    }</span>

    @Override
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
            TypePath typePath, Label[] start, Label[] end, int[] index,
            String desc, boolean visible) {
<span class="nc" id="L987">        checkStartCode();</span>
<span class="nc" id="L988">        checkEndCode();</span>
<span class="nc" id="L989">        int sort = typeRef &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">        if (sort != TypeReference.LOCAL_VARIABLE</span>
                &amp;&amp; sort != TypeReference.RESOURCE_VARIABLE) {
<span class="nc" id="L992">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L993">                    + Integer.toHexString(sort));</span>
        }
<span class="nc" id="L995">        CheckClassAdapter.checkTypeRefAndPath(typeRef, typePath);</span>
<span class="nc" id="L996">        checkDesc(desc, false);</span>
<span class="nc bnc" id="L997" title="All 10 branches missed.">        if (start == null || end == null || index == null</span>
                || end.length != start.length || index.length != start.length) {
<span class="nc" id="L999">            throw new IllegalArgumentException(</span>
                    &quot;Invalid start, end and index arrays (must be non null and of identical length&quot;);
        }
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        for (int i = 0; i &lt; start.length; ++i) {</span>
<span class="nc" id="L1003">            checkLabel(start[i], true, &quot;start label&quot;);</span>
<span class="nc" id="L1004">            checkLabel(end[i], true, &quot;end label&quot;);</span>
<span class="nc" id="L1005">            checkUnsignedShort(index[i], &quot;Invalid variable index&quot;);</span>
<span class="nc" id="L1006">            int s = labels.get(start[i]).intValue();</span>
<span class="nc" id="L1007">            int e = labels.get(end[i]).intValue();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if (e &lt; s) {</span>
<span class="nc" id="L1009">                throw new IllegalArgumentException(</span>
                        &quot;Invalid start and end labels (end must be greater than start)&quot;);
            }
        }
<span class="nc" id="L1013">        return super.visitLocalVariableAnnotation(typeRef, typePath, start,</span>
                end, index, desc, visible);
    }

    @Override
    public void visitLineNumber(final int line, final Label start) {
<span class="nc" id="L1019">        checkStartCode();</span>
<span class="nc" id="L1020">        checkEndCode();</span>
<span class="nc" id="L1021">        checkUnsignedShort(line, &quot;Invalid line number&quot;);</span>
<span class="nc" id="L1022">        checkLabel(start, true, &quot;start label&quot;);</span>
<span class="nc" id="L1023">        super.visitLineNumber(line, start);</span>
<span class="nc" id="L1024">    }</span>

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="nc" id="L1028">        checkStartCode();</span>
<span class="nc" id="L1029">        checkEndCode();</span>
<span class="nc" id="L1030">        endCode = true;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        for (Label l : usedLabels) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if (labels.get(l) == null) {</span>
<span class="nc" id="L1033">                throw new IllegalStateException(&quot;Undefined label used&quot;);</span>
            }
<span class="nc" id="L1035">        }</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        for (int i = 0; i &lt; handlers.size();) {</span>
<span class="nc" id="L1037">            Integer start = labels.get(handlers.get(i++));</span>
<span class="nc" id="L1038">            Integer end = labels.get(handlers.get(i++));</span>
<span class="nc bnc" id="L1039" title="All 4 branches missed.">            if (start == null || end == null) {</span>
<span class="nc" id="L1040">                throw new IllegalStateException(</span>
                        &quot;Undefined try catch block labels&quot;);
            }
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if (end.intValue() &lt;= start.intValue()) {</span>
<span class="nc" id="L1044">                throw new IllegalStateException(</span>
                        &quot;Emty try catch block handler range&quot;);
            }
<span class="nc" id="L1047">        }</span>
<span class="nc" id="L1048">        checkUnsignedShort(maxStack, &quot;Invalid max stack&quot;);</span>
<span class="nc" id="L1049">        checkUnsignedShort(maxLocals, &quot;Invalid max locals&quot;);</span>
<span class="nc" id="L1050">        super.visitMaxs(maxStack, maxLocals);</span>
<span class="nc" id="L1051">    }</span>

    @Override
    public void visitEnd() {
<span class="nc" id="L1055">        checkEndMethod();</span>
<span class="nc" id="L1056">        endMethod = true;</span>
<span class="nc" id="L1057">        super.visitEnd();</span>
<span class="nc" id="L1058">    }</span>

    // -------------------------------------------------------------------------

    /**
     * Checks that the visitCode method has been called.
     */
    void checkStartCode() {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (!startCode) {</span>
<span class="nc" id="L1067">            throw new IllegalStateException(</span>
                    &quot;Cannot visit instructions before visitCode has been called.&quot;);
        }
<span class="nc" id="L1070">    }</span>

    /**
     * Checks that the visitMaxs method has not been called.
     */
    void checkEndCode() {
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (endCode) {</span>
<span class="nc" id="L1077">            throw new IllegalStateException(</span>
                    &quot;Cannot visit instructions after visitMaxs has been called.&quot;);
        }
<span class="nc" id="L1080">    }</span>

    /**
     * Checks that the visitEnd method has not been called.
     */
    void checkEndMethod() {
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (endMethod) {</span>
<span class="nc" id="L1087">            throw new IllegalStateException(</span>
                    &quot;Cannot visit elements after visitEnd has been called.&quot;);
        }
<span class="nc" id="L1090">    }</span>

    /**
     * Checks a stack frame value.
     *
     * @param value
     *            the value to be checked.
     */
    void checkFrameValue(final Object value) {
<span class="nc bnc" id="L1099" title="All 14 branches missed.">        if (value == Opcodes.TOP || value == Opcodes.INTEGER</span>
                || value == Opcodes.FLOAT || value == Opcodes.LONG
                || value == Opcodes.DOUBLE || value == Opcodes.NULL
                || value == Opcodes.UNINITIALIZED_THIS) {
<span class="nc" id="L1103">            return;</span>
        }
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if (value instanceof String) {</span>
<span class="nc" id="L1106">            checkInternalName((String) value, &quot;Invalid stack frame value&quot;);</span>
<span class="nc" id="L1107">            return;</span>
        }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (!(value instanceof Label)) {</span>
<span class="nc" id="L1110">            throw new IllegalArgumentException(&quot;Invalid stack frame value: &quot;</span>
                    + value);
        } else {
<span class="nc" id="L1113">            usedLabels.add((Label) value);</span>
        }
<span class="nc" id="L1115">    }</span>

    /**
     * Checks that the type of the given opcode is equal to the given type.
     *
     * @param opcode
     *            the opcode to be checked.
     * @param type
     *            the expected opcode type.
     */
    static void checkOpcode(final int opcode, final int type) {
<span class="nc bnc" id="L1126" title="All 6 branches missed.">        if (opcode &lt; 0 || opcode &gt; 199 || TYPE[opcode] != type) {</span>
<span class="nc" id="L1127">            throw new IllegalArgumentException(&quot;Invalid opcode: &quot; + opcode);</span>
        }
<span class="nc" id="L1129">    }</span>

    /**
     * Checks that the given value is a signed byte.
     *
     * @param value
     *            the value to be checked.
     * @param msg
     *            an message to be used in case of error.
     */
    static void checkSignedByte(final int value, final String msg) {
<span class="nc bnc" id="L1140" title="All 4 branches missed.">        if (value &lt; Byte.MIN_VALUE || value &gt; Byte.MAX_VALUE) {</span>
<span class="nc" id="L1141">            throw new IllegalArgumentException(msg</span>
                    + &quot; (must be a signed byte): &quot; + value);
        }
<span class="nc" id="L1144">    }</span>

    /**
     * Checks that the given value is a signed short.
     *
     * @param value
     *            the value to be checked.
     * @param msg
     *            an message to be used in case of error.
     */
    static void checkSignedShort(final int value, final String msg) {
<span class="nc bnc" id="L1155" title="All 4 branches missed.">        if (value &lt; Short.MIN_VALUE || value &gt; Short.MAX_VALUE) {</span>
<span class="nc" id="L1156">            throw new IllegalArgumentException(msg</span>
                    + &quot; (must be a signed short): &quot; + value);
        }
<span class="nc" id="L1159">    }</span>

    /**
     * Checks that the given value is an unsigned short.
     *
     * @param value
     *            the value to be checked.
     * @param msg
     *            an message to be used in case of error.
     */
    static void checkUnsignedShort(final int value, final String msg) {
<span class="nc bnc" id="L1170" title="All 4 branches missed.">        if (value &lt; 0 || value &gt; 65535) {</span>
<span class="nc" id="L1171">            throw new IllegalArgumentException(msg</span>
                    + &quot; (must be an unsigned short): &quot; + value);
        }
<span class="nc" id="L1174">    }</span>

    /**
     * Checks that the given value is an {@link Integer}, a{@link Float}, a
     * {@link Long}, a {@link Double} or a {@link String}.
     *
     * @param cst
     *            the value to be checked.
     */
    static void checkConstant(final Object cst) {
<span class="nc bnc" id="L1184" title="All 10 branches missed.">        if (!(cst instanceof Integer) &amp;&amp; !(cst instanceof Float)</span>
                &amp;&amp; !(cst instanceof Long) &amp;&amp; !(cst instanceof Double)
                &amp;&amp; !(cst instanceof String)) {
<span class="nc" id="L1187">            throw new IllegalArgumentException(&quot;Invalid constant: &quot; + cst);</span>
        }
<span class="nc" id="L1189">    }</span>

    void checkLDCConstant(final Object cst) {
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        if (cst instanceof Type) {</span>
<span class="nc" id="L1193">            int s = ((Type) cst).getSort();</span>
<span class="nc bnc" id="L1194" title="All 6 branches missed.">            if (s != Type.OBJECT &amp;&amp; s != Type.ARRAY &amp;&amp; s != Type.METHOD) {</span>
<span class="nc" id="L1195">                throw new IllegalArgumentException(&quot;Illegal LDC constant value&quot;);</span>
            }
<span class="nc bnc" id="L1197" title="All 4 branches missed.">            if (s != Type.METHOD &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_5) {</span>
<span class="nc" id="L1198">                throw new IllegalArgumentException(</span>
                        &quot;ldc of a constant class requires at least version 1.5&quot;);
            }
<span class="nc bnc" id="L1201" title="All 4 branches missed.">            if (s == Type.METHOD &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_7) {</span>
<span class="nc" id="L1202">                throw new IllegalArgumentException(</span>
                        &quot;ldc of a method type requires at least version 1.7&quot;);
            }
<span class="nc bnc" id="L1205" title="All 2 branches missed.">        } else if (cst instanceof Handle) {</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            if ((version &amp; 0xFFFF) &lt; Opcodes.V1_7) {</span>
<span class="nc" id="L1207">                throw new IllegalArgumentException(</span>
                        &quot;ldc of a handle requires at least version 1.7&quot;);
            }
<span class="nc" id="L1210">            int tag = ((Handle) cst).getTag();</span>
<span class="nc bnc" id="L1211" title="All 4 branches missed.">            if (tag &lt; Opcodes.H_GETFIELD || tag &gt; Opcodes.H_INVOKEINTERFACE) {</span>
<span class="nc" id="L1212">                throw new IllegalArgumentException(&quot;invalid handle tag &quot; + tag);</span>
            }
<span class="nc" id="L1214">        } else {</span>
<span class="nc" id="L1215">            checkConstant(cst);</span>
        }
<span class="nc" id="L1217">    }</span>

    /**
     * Checks that the given string is a valid unqualified name.
     *
     * @param version
     *            the class version.
     * @param name
     *            the string to be checked.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkUnqualifiedName(int version, final String name,
            final String msg) {
<span class="nc bnc" id="L1231" title="All 2 branches missed.">        if ((version &amp; 0xFFFF) &lt; Opcodes.V1_5) {</span>
<span class="nc" id="L1232">            checkIdentifier(name, msg);</span>
        } else {
<span class="nc bnc" id="L1234" title="All 2 branches missed.">            for (int i = 0; i &lt; name.length(); ++i) {</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                if (&quot;.;[/&quot;.indexOf(name.charAt(i)) != -1) {</span>
<span class="nc" id="L1236">                    throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                            + &quot; (must be a valid unqualified name): &quot; + name);
                }
            }
        }
<span class="nc" id="L1241">    }</span>

    /**
     * Checks that the given string is a valid Java identifier.
     *
     * @param name
     *            the string to be checked.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkIdentifier(final String name, final String msg) {
<span class="nc" id="L1252">        checkIdentifier(name, 0, -1, msg);</span>
<span class="nc" id="L1253">    }</span>

    /**
     * Checks that the given substring is a valid Java identifier.
     *
     * @param name
     *            the string to be checked.
     * @param start
     *            index of the first character of the identifier (inclusive).
     * @param end
     *            index of the last character of the identifier (exclusive). -1
     *            is equivalent to &lt;tt&gt;name.length()&lt;/tt&gt; if name is not
     *            &lt;tt&gt;null&lt;/tt&gt;.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkIdentifier(final String name, final int start,
            final int end, final String msg) {
<span class="nc bnc" id="L1271" title="All 8 branches missed.">        if (name == null || (end == -1 ? name.length() &lt;= start : end &lt;= start)) {</span>
<span class="nc" id="L1272">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must not be null or empty)&quot;);
        }
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (!Character.isJavaIdentifierStart(name.charAt(start))) {</span>
<span class="nc" id="L1276">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must be a valid Java identifier): &quot; + name);
        }
<span class="nc bnc" id="L1279" title="All 2 branches missed.">        int max = end == -1 ? name.length() : end;</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        for (int i = start + 1; i &lt; max; ++i) {</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">            if (!Character.isJavaIdentifierPart(name.charAt(i))) {</span>
<span class="nc" id="L1282">                throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                        + &quot; (must be a valid Java identifier): &quot; + name);
            }
        }
<span class="nc" id="L1286">    }</span>

    /**
     * Checks that the given string is a valid Java identifier.
     *
     * @param version
     *            the class version.
     * @param name
     *            the string to be checked.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkMethodIdentifier(int version, final String name,
            final String msg) {
<span class="nc bnc" id="L1300" title="All 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L1301">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must not be null or empty)&quot;);
        }
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if ((version &amp; 0xFFFF) &gt;= Opcodes.V1_5) {</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            for (int i = 0; i &lt; name.length(); ++i) {</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if (&quot;.;[/&lt;&gt;&quot;.indexOf(name.charAt(i)) != -1) {</span>
<span class="nc" id="L1307">                    throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                            + &quot; (must be a valid unqualified name): &quot; + name);
                }
            }
<span class="nc" id="L1311">            return;</span>
        }
<span class="nc bnc" id="L1313" title="All 2 branches missed.">        if (!Character.isJavaIdentifierStart(name.charAt(0))) {</span>
<span class="nc" id="L1314">            throw new IllegalArgumentException(</span>
                    &quot;Invalid &quot;
                            + msg
                            + &quot; (must be a '&lt;init&gt;', '&lt;clinit&gt;' or a valid Java identifier): &quot;
                            + name);
        }
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        for (int i = 1; i &lt; name.length(); ++i) {</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if (!Character.isJavaIdentifierPart(name.charAt(i))) {</span>
<span class="nc" id="L1322">                throw new IllegalArgumentException(</span>
                        &quot;Invalid &quot;
                                + msg
                                + &quot; (must be '&lt;init&gt;' or '&lt;clinit&gt;' or a valid Java identifier): &quot;
                                + name);
            }
        }
<span class="nc" id="L1329">    }</span>

    /**
     * Checks that the given string is a valid internal class name.
     *
     * @param name
     *            the string to be checked.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkInternalName(final String name, final String msg) {
<span class="nc bnc" id="L1340" title="All 4 branches missed.">        if (name == null || name.length() == 0) {</span>
<span class="nc" id="L1341">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must not be null or empty)&quot;);
        }
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (name.charAt(0) == '[') {</span>
<span class="nc" id="L1345">            checkDesc(name, false);</span>
        } else {
<span class="nc" id="L1347">            checkInternalName(name, 0, -1, msg);</span>
        }
<span class="nc" id="L1349">    }</span>

    /**
     * Checks that the given substring is a valid internal class name.
     *
     * @param name
     *            the string to be checked.
     * @param start
     *            index of the first character of the identifier (inclusive).
     * @param end
     *            index of the last character of the identifier (exclusive). -1
     *            is equivalent to &lt;tt&gt;name.length()&lt;/tt&gt; if name is not
     *            &lt;tt&gt;null&lt;/tt&gt;.
     * @param msg
     *            a message to be used in case of error.
     */
    static void checkInternalName(final String name, final int start,
            final int end, final String msg) {
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        int max = end == -1 ? name.length() : end;</span>
        try {
<span class="nc" id="L1369">            int begin = start;</span>
            int slash;
            do {
<span class="nc" id="L1372">                slash = name.indexOf('/', begin + 1);</span>
<span class="nc bnc" id="L1373" title="All 4 branches missed.">                if (slash == -1 || slash &gt; max) {</span>
<span class="nc" id="L1374">                    slash = max;</span>
                }
<span class="nc" id="L1376">                checkIdentifier(name, begin, slash, null);</span>
<span class="nc" id="L1377">                begin = slash + 1;</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">            } while (slash != max);</span>
<span class="nc" id="L1379">        } catch (IllegalArgumentException unused) {</span>
<span class="nc" id="L1380">            throw new IllegalArgumentException(</span>
                    &quot;Invalid &quot;
                            + msg
                            + &quot; (must be a fully qualified class name in internal form): &quot;
                            + name);
<span class="nc" id="L1385">        }</span>
<span class="nc" id="L1386">    }</span>

    /**
     * Checks that the given string is a valid type descriptor.
     *
     * @param desc
     *            the string to be checked.
     * @param canBeVoid
     *            &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;V&lt;/tt&gt; can be considered valid.
     */
    static void checkDesc(final String desc, final boolean canBeVoid) {
<span class="nc" id="L1397">        int end = checkDesc(desc, 0, canBeVoid);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (end != desc.length()) {</span>
<span class="nc" id="L1399">            throw new IllegalArgumentException(&quot;Invalid descriptor: &quot; + desc);</span>
        }
<span class="nc" id="L1401">    }</span>

    /**
     * Checks that a the given substring is a valid type descriptor.
     *
     * @param desc
     *            the string to be checked.
     * @param start
     *            index of the first character of the identifier (inclusive).
     * @param canBeVoid
     *            &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;V&lt;/tt&gt; can be considered valid.
     * @return the index of the last character of the type decriptor, plus one.
     */
    static int checkDesc(final String desc, final int start,
            final boolean canBeVoid) {
<span class="nc bnc" id="L1416" title="All 4 branches missed.">        if (desc == null || start &gt;= desc.length()) {</span>
<span class="nc" id="L1417">            throw new IllegalArgumentException(</span>
                    &quot;Invalid type descriptor (must not be null or empty)&quot;);
        }
        int index;
<span class="nc bnc" id="L1421" title="All 5 branches missed.">        switch (desc.charAt(start)) {</span>
        case 'V':
<span class="nc bnc" id="L1423" title="All 2 branches missed.">            if (canBeVoid) {</span>
<span class="nc" id="L1424">                return start + 1;</span>
            } else {
<span class="nc" id="L1426">                throw new IllegalArgumentException(&quot;Invalid descriptor: &quot;</span>
                        + desc);
            }
        case 'Z':
        case 'C':
        case 'B':
        case 'S':
        case 'I':
        case 'F':
        case 'J':
        case 'D':
<span class="nc" id="L1437">            return start + 1;</span>
        case '[':
<span class="nc" id="L1439">            index = start + 1;</span>
<span class="nc bnc" id="L1440" title="All 4 branches missed.">            while (index &lt; desc.length() &amp;&amp; desc.charAt(index) == '[') {</span>
<span class="nc" id="L1441">                ++index;</span>
            }
<span class="nc bnc" id="L1443" title="All 2 branches missed.">            if (index &lt; desc.length()) {</span>
<span class="nc" id="L1444">                return checkDesc(desc, index, false);</span>
            } else {
<span class="nc" id="L1446">                throw new IllegalArgumentException(&quot;Invalid descriptor: &quot;</span>
                        + desc);
            }
        case 'L':
<span class="nc" id="L1450">            index = desc.indexOf(';', start);</span>
<span class="nc bnc" id="L1451" title="All 4 branches missed.">            if (index == -1 || index - start &lt; 2) {</span>
<span class="nc" id="L1452">                throw new IllegalArgumentException(&quot;Invalid descriptor: &quot;</span>
                        + desc);
            }
            try {
<span class="nc" id="L1456">                checkInternalName(desc, start + 1, index, null);</span>
<span class="nc" id="L1457">            } catch (IllegalArgumentException unused) {</span>
<span class="nc" id="L1458">                throw new IllegalArgumentException(&quot;Invalid descriptor: &quot;</span>
                        + desc);
<span class="nc" id="L1460">            }</span>
<span class="nc" id="L1461">            return index + 1;</span>
        default:
<span class="nc" id="L1463">            throw new IllegalArgumentException(&quot;Invalid descriptor: &quot; + desc);</span>
        }
    }

    /**
     * Checks that the given string is a valid method descriptor.
     *
     * @param desc
     *            the string to be checked.
     */
    static void checkMethodDesc(final String desc) {
<span class="nc bnc" id="L1474" title="All 4 branches missed.">        if (desc == null || desc.length() == 0) {</span>
<span class="nc" id="L1475">            throw new IllegalArgumentException(</span>
                    &quot;Invalid method descriptor (must not be null or empty)&quot;);
        }
<span class="nc bnc" id="L1478" title="All 4 branches missed.">        if (desc.charAt(0) != '(' || desc.length() &lt; 3) {</span>
<span class="nc" id="L1479">            throw new IllegalArgumentException(&quot;Invalid descriptor: &quot; + desc);</span>
        }
<span class="nc" id="L1481">        int start = 1;</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (desc.charAt(start) != ')') {</span>
            do {
<span class="nc bnc" id="L1484" title="All 2 branches missed.">                if (desc.charAt(start) == 'V') {</span>
<span class="nc" id="L1485">                    throw new IllegalArgumentException(&quot;Invalid descriptor: &quot;</span>
                            + desc);
                }
<span class="nc" id="L1488">                start = checkDesc(desc, start, false);</span>
<span class="nc bnc" id="L1489" title="All 4 branches missed.">            } while (start &lt; desc.length() &amp;&amp; desc.charAt(start) != ')');</span>
        }
<span class="nc" id="L1491">        start = checkDesc(desc, start + 1, true);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (start != desc.length()) {</span>
<span class="nc" id="L1493">            throw new IllegalArgumentException(&quot;Invalid descriptor: &quot; + desc);</span>
        }
<span class="nc" id="L1495">    }</span>

    /**
     * Checks that the given label is not null. This method can also check that
     * the label has been visited.
     *
     * @param label
     *            the label to be checked.
     * @param checkVisited
     *            &lt;tt&gt;true&lt;/tt&gt; to check that the label has been visited.
     * @param msg
     *            a message to be used in case of error.
     */
    void checkLabel(final Label label, final boolean checkVisited,
            final String msg) {
<span class="nc bnc" id="L1510" title="All 2 branches missed.">        if (label == null) {</span>
<span class="nc" id="L1511">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must not be null)&quot;);
        }
<span class="nc bnc" id="L1514" title="All 4 branches missed.">        if (checkVisited &amp;&amp; labels.get(label) == null) {</span>
<span class="nc" id="L1515">            throw new IllegalArgumentException(&quot;Invalid &quot; + msg</span>
                    + &quot; (must be visited first)&quot;);
        }
<span class="nc" id="L1518">    }</span>

    /**
     * Checks that the given label is not a label used only for debug purposes.
     *
     * @param label
     *            the label to be checked.
     */
    private static void checkNonDebugLabel(final Label label) {
<span class="nc" id="L1527">        Field f = getLabelStatusField();</span>
<span class="nc" id="L1528">        int status = 0;</span>
        try {
<span class="nc bnc" id="L1530" title="All 2 branches missed.">            status = f == null ? 0 : ((Integer) f.get(label)).intValue();</span>
<span class="nc" id="L1531">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L1532">            throw new Error(&quot;Internal error&quot;);</span>
<span class="nc" id="L1533">        }</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">        if ((status &amp; 0x01) != 0) {</span>
<span class="nc" id="L1535">            throw new IllegalArgumentException(</span>
                    &quot;Labels used for debug info cannot be reused for control flow&quot;);
        }
<span class="nc" id="L1538">    }</span>

    /**
     * Returns the Field object corresponding to the Label.status field.
     *
     * @return the Field object corresponding to the Label.status field.
     */
    private static Field getLabelStatusField() {
<span class="nc bnc" id="L1546" title="All 2 branches missed.">        if (labelStatusField == null) {</span>
<span class="nc" id="L1547">            labelStatusField = getLabelField(&quot;a&quot;);</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            if (labelStatusField == null) {</span>
<span class="nc" id="L1549">                labelStatusField = getLabelField(&quot;status&quot;);</span>
            }
        }
<span class="nc" id="L1552">        return labelStatusField;</span>
    }

    /**
     * Returns the field of the Label class whose name is given.
     *
     * @param name
     *            a field name.
     * @return the field of the Label class whose name is given, or null.
     */
    private static Field getLabelField(final String name) {
        try {
<span class="nc" id="L1564">            Field f = Label.class.getDeclaredField(name);</span>
<span class="nc" id="L1565">            f.setAccessible(true);</span>
<span class="nc" id="L1566">            return f;</span>
<span class="nc" id="L1567">        } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1568">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>