<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CheckClassAdapter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.util</a> &gt; <span class="el_source">CheckClassAdapter.java</span></div><h1>CheckClassAdapter.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.util;

import java.io.FileInputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import jdk.internal.org.objectweb.asm.AnnotationVisitor;
import jdk.internal.org.objectweb.asm.Attribute;
import jdk.internal.org.objectweb.asm.ClassReader;
import jdk.internal.org.objectweb.asm.ClassVisitor;
import jdk.internal.org.objectweb.asm.FieldVisitor;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.Type;
import jdk.internal.org.objectweb.asm.TypePath;
import jdk.internal.org.objectweb.asm.TypeReference;
import jdk.internal.org.objectweb.asm.tree.ClassNode;
import jdk.internal.org.objectweb.asm.tree.MethodNode;
import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
import jdk.internal.org.objectweb.asm.tree.analysis.Frame;
import jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier;

/**
 * A {@link ClassVisitor} that checks that its methods are properly used. More
 * precisely this class adapter checks each method call individually, based
 * &lt;i&gt;only&lt;/i&gt; on its arguments, but does &lt;i&gt;not&lt;/i&gt; check the &lt;i&gt;sequence&lt;/i&gt;
 * of method calls. For example, the invalid sequence
 * &lt;tt&gt;visitField(ACC_PUBLIC, &quot;i&quot;, &quot;I&quot;, null)&lt;/tt&gt; &lt;tt&gt;visitField(ACC_PUBLIC,
 * &quot;i&quot;, &quot;D&quot;, null)&lt;/tt&gt; will &lt;i&gt;not&lt;/i&gt; be detected by this class adapter.
 *
 * &lt;p&gt;
 * &lt;code&gt;CheckClassAdapter&lt;/code&gt; can be also used to verify bytecode
 * transformations in order to make sure transformed bytecode is sane. For
 * example:
 *
 * &lt;pre&gt;
 *   InputStream is = ...; // get bytes for the source class
 *   ClassReader cr = new ClassReader(is);
 *   ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
 *   ClassVisitor cv = new &lt;b&gt;MyClassAdapter&lt;/b&gt;(new CheckClassAdapter(cw));
 *   cr.accept(cv, 0);
 *
 *   StringWriter sw = new StringWriter();
 *   PrintWriter pw = new PrintWriter(sw);
 *   CheckClassAdapter.verify(new ClassReader(cw.toByteArray()), false, pw);
 *   assertTrue(sw.toString(), sw.toString().length()==0);
 * &lt;/pre&gt;
 *
 * Above code runs transformed bytecode trough the
 * &lt;code&gt;CheckClassAdapter&lt;/code&gt;. It won't be exactly the same verification as
 * JVM does, but it run data flow analysis for the code of each method and
 * checks that expectations are met for each method instruction.
 *
 * &lt;p&gt;
 * If method bytecode has errors, assertion text will show the erroneous
 * instruction number and dump of the failed method with information about
 * locals and stack slot for each instruction. For example (format is -
 * insnNumber locals : stack):
 *
 * &lt;pre&gt;
 * jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .
 *   at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:289)
 *   at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:135)
 * ...
 * remove()V
 * 00000 LinkedBlockingQueue$Itr . . . . . . . .  :
 *   ICONST_0
 * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I
 *   ISTORE 2
 * 00001 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 * ...
 *
 * 00071 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 *   ILOAD 1
 * 00072 &lt;b&gt;?&lt;/b&gt;
 *   INVOKESPECIAL java/lang/Integer.&amp;lt;init&amp;gt; (I)V
 * ...
 * &lt;/pre&gt;
 *
 * In the above output you can see that variable 1 loaded by
 * &lt;code&gt;ILOAD 1&lt;/code&gt; instruction at position &lt;code&gt;00071&lt;/code&gt; is not
 * initialized. You can also see that at the beginning of the method (code
 * inserted by the transformation) variable 2 is initialized.
 *
 * &lt;p&gt;
 * Note that when used like that, &lt;code&gt;CheckClassAdapter.verify()&lt;/code&gt; can
 * trigger additional class loading, because it is using
 * &lt;code&gt;SimpleVerifier&lt;/code&gt;.
 *
 * @author Eric Bruneton
 */
public class CheckClassAdapter extends ClassVisitor {

    /**
     * The class version number.
     */
    private int version;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visit method has been called.
     */
    private boolean start;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitSource method has been called.
     */
    private boolean source;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitOuterClass method has been called.
     */
    private boolean outer;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the visitEnd method has been called.
     */
    private boolean end;

    /**
     * The already visited labels. This map associate Integer values to Label
     * keys.
     */
    private Map&lt;Label, Integer&gt; labels;

    /**
     * &lt;tt&gt;true&lt;/tt&gt; if the method code must be checked with a BasicVerifier.
     */
    private boolean checkDataFlow;

    /**
     * Checks a given class.
     * &lt;p&gt;
     * Usage: CheckClassAdapter &amp;lt;binary class name or class file name&amp;gt;
     *
     * @param args
     *            the command line arguments.
     *
     * @throws Exception
     *             if the class cannot be found, or if an IO exception occurs.
     */
    public static void main(final String[] args) throws Exception {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (args.length != 1) {</span>
<span class="nc" id="L207">            System.err.println(&quot;Verifies the given class.&quot;);</span>
<span class="nc" id="L208">            System.err.println(&quot;Usage: CheckClassAdapter &quot;</span>
                    + &quot;&lt;fully qualified class name or class file name&gt;&quot;);
<span class="nc" id="L210">            return;</span>
        }
        ClassReader cr;
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (args[0].endsWith(&quot;.class&quot;)) {</span>
<span class="nc" id="L214">            cr = new ClassReader(new FileInputStream(args[0]));</span>
        } else {
<span class="nc" id="L216">            cr = new ClassReader(args[0]);</span>
        }

<span class="nc" id="L219">        verify(cr, false, new PrintWriter(System.err));</span>
<span class="nc" id="L220">    }</span>

    /**
     * Checks a given class.
     *
     * @param cr
     *            a &lt;code&gt;ClassReader&lt;/code&gt; that contains bytecode for the
     *            analysis.
     * @param loader
     *            a &lt;code&gt;ClassLoader&lt;/code&gt; which will be used to load
     *            referenced classes. This is useful if you are verifiying
     *            multiple interdependent classes.
     * @param dump
     *            true if bytecode should be printed out not only when errors
     *            are found.
     * @param pw
     *            write where results going to be printed
     */
    public static void verify(final ClassReader cr, final ClassLoader loader,
            final boolean dump, final PrintWriter pw) {
<span class="nc" id="L240">        ClassNode cn = new ClassNode();</span>
<span class="nc" id="L241">        cr.accept(new CheckClassAdapter(cn, false), ClassReader.SKIP_DEBUG);</span>

<span class="nc bnc" id="L243" title="All 2 branches missed.">        Type syperType = cn.superName == null ? null : Type</span>
<span class="nc" id="L244">                .getObjectType(cn.superName);</span>
<span class="nc" id="L245">        List&lt;MethodNode&gt; methods = cn.methods;</span>

<span class="nc" id="L247">        List&lt;Type&gt; interfaces = new ArrayList&lt;Type&gt;();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (Iterator&lt;String&gt; i = cn.interfaces.iterator(); i.hasNext();) {</span>
<span class="nc" id="L249">            interfaces.add(Type.getObjectType(i.next()));</span>
        }

<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.size(); ++i) {</span>
<span class="nc" id="L253">            MethodNode method = methods.get(i);</span>
<span class="nc" id="L254">            SimpleVerifier verifier = new SimpleVerifier(</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    Type.getObjectType(cn.name), syperType, interfaces,</span>
                    (cn.access &amp; Opcodes.ACC_INTERFACE) != 0);
<span class="nc" id="L257">            Analyzer&lt;BasicValue&gt; a = new Analyzer&lt;BasicValue&gt;(verifier);</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (loader != null) {</span>
<span class="nc" id="L259">                verifier.setClassLoader(loader);</span>
            }
            try {
<span class="nc" id="L262">                a.analyze(cn.name, method);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                if (!dump) {</span>
<span class="nc" id="L264">                    continue;</span>
                }
<span class="nc" id="L266">            } catch (Exception e) {</span>
<span class="nc" id="L267">                e.printStackTrace(pw);</span>
<span class="nc" id="L268">            }</span>
<span class="nc" id="L269">            printAnalyzerResult(method, a, pw);</span>
        }
<span class="nc" id="L271">        pw.flush();</span>
<span class="nc" id="L272">    }</span>

    /**
     * Checks a given class
     *
     * @param cr
     *            a &lt;code&gt;ClassReader&lt;/code&gt; that contains bytecode for the
     *            analysis.
     * @param dump
     *            true if bytecode should be printed out not only when errors
     *            are found.
     * @param pw
     *            write where results going to be printed
     */
    public static void verify(final ClassReader cr, final boolean dump,
            final PrintWriter pw) {
<span class="nc" id="L288">        verify(cr, null, dump, pw);</span>
<span class="nc" id="L289">    }</span>

    static void printAnalyzerResult(MethodNode method, Analyzer&lt;BasicValue&gt; a,
            final PrintWriter pw) {
<span class="nc" id="L293">        Frame&lt;BasicValue&gt;[] frames = a.getFrames();</span>
<span class="nc" id="L294">        Textifier t = new Textifier();</span>
<span class="nc" id="L295">        TraceMethodVisitor mv = new TraceMethodVisitor(t);</span>

<span class="nc" id="L297">        pw.println(method.name + method.desc);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (int j = 0; j &lt; method.instructions.size(); ++j) {</span>
<span class="nc" id="L299">            method.instructions.get(j).accept(mv);</span>

<span class="nc" id="L301">            StringBuffer s = new StringBuffer();</span>
<span class="nc" id="L302">            Frame&lt;BasicValue&gt; f = frames[j];</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (f == null) {</span>
<span class="nc" id="L304">                s.append('?');</span>
            } else {
<span class="nc bnc" id="L306" title="All 2 branches missed.">                for (int k = 0; k &lt; f.getLocals(); ++k) {</span>
<span class="nc" id="L307">                    s.append(getShortName(f.getLocal(k).toString()))</span>
<span class="nc" id="L308">                            .append(' ');</span>
                }
<span class="nc" id="L310">                s.append(&quot; : &quot;);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                for (int k = 0; k &lt; f.getStackSize(); ++k) {</span>
<span class="nc" id="L312">                    s.append(getShortName(f.getStack(k).toString()))</span>
<span class="nc" id="L313">                            .append(' ');</span>
                }
            }
<span class="nc bnc" id="L316" title="All 2 branches missed.">            while (s.length() &lt; method.maxStack + method.maxLocals + 1) {</span>
<span class="nc" id="L317">                s.append(' ');</span>
            }
<span class="nc" id="L319">            pw.print(Integer.toString(j + 100000).substring(1));</span>
<span class="nc" id="L320">            pw.print(&quot; &quot; + s + &quot; : &quot; + t.text.get(t.text.size() - 1));</span>
        }
<span class="nc bnc" id="L322" title="All 2 branches missed.">        for (int j = 0; j &lt; method.tryCatchBlocks.size(); ++j) {</span>
<span class="nc" id="L323">            method.tryCatchBlocks.get(j).accept(mv);</span>
<span class="nc" id="L324">            pw.print(&quot; &quot; + t.text.get(t.text.size() - 1));</span>
        }
<span class="nc" id="L326">        pw.println();</span>
<span class="nc" id="L327">    }</span>

    private static String getShortName(final String name) {
<span class="nc" id="L330">        int n = name.lastIndexOf('/');</span>
<span class="nc" id="L331">        int k = name.length();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (name.charAt(k - 1) == ';') {</span>
<span class="nc" id="L333">            k--;</span>
        }
<span class="nc bnc" id="L335" title="All 2 branches missed.">        return n == -1 ? name : name.substring(n + 1, k);</span>
    }

    /**
     * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use
     * this constructor&lt;/i&gt;. Instead, they must use the
     * {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
     *
     * @param cv
     *            the class visitor to which this adapter must delegate calls.
     */
    public CheckClassAdapter(final ClassVisitor cv) {
<span class="nc" id="L347">        this(cv, true);</span>
<span class="nc" id="L348">    }</span>

    /**
     * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use
     * this constructor&lt;/i&gt;. Instead, they must use the
     * {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
     *
     * @param cv
     *            the class visitor to which this adapter must delegate calls.
     * @param checkDataFlow
     *            &lt;tt&gt;true&lt;/tt&gt; to perform basic data flow checks, or
     *            &lt;tt&gt;false&lt;/tt&gt; to not perform any data flow check (see
     *            {@link CheckMethodAdapter}). This option requires valid
     *            maxLocals and maxStack values.
     * @throws IllegalStateException
     *             If a subclass calls this constructor.
     */
    public CheckClassAdapter(final ClassVisitor cv, final boolean checkDataFlow) {
<span class="nc" id="L366">        this(Opcodes.ASM5, cv, checkDataFlow);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (getClass() != CheckClassAdapter.class) {</span>
<span class="nc" id="L368">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L370">    }</span>

    /**
     * Constructs a new {@link CheckClassAdapter}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param cv
     *            the class visitor to which this adapter must delegate calls.
     * @param checkDataFlow
     *            &lt;tt&gt;true&lt;/tt&gt; to perform basic data flow checks, or
     *            &lt;tt&gt;false&lt;/tt&gt; to not perform any data flow check (see
     *            {@link CheckMethodAdapter}). This option requires valid
     *            maxLocals and maxStack values.
     */
    protected CheckClassAdapter(final int api, final ClassVisitor cv,
            final boolean checkDataFlow) {
<span class="nc" id="L388">        super(api, cv);</span>
<span class="nc" id="L389">        this.labels = new HashMap&lt;Label, Integer&gt;();</span>
<span class="nc" id="L390">        this.checkDataFlow = checkDataFlow;</span>
<span class="nc" id="L391">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the ClassVisitor interface
    // ------------------------------------------------------------------------

    @Override
    public void visit(final int version, final int access, final String name,
            final String signature, final String superName,
            final String[] interfaces) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (start) {</span>
<span class="nc" id="L402">            throw new IllegalStateException(&quot;visit must be called only once&quot;);</span>
        }
<span class="nc" id="L404">        start = true;</span>
<span class="nc" id="L405">        checkState();</span>
<span class="nc" id="L406">        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL</span>
                + Opcodes.ACC_SUPER + Opcodes.ACC_INTERFACE
                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC
                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM
                + Opcodes.ACC_DEPRECATED + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
<span class="nc bnc" id="L411" title="All 4 branches missed.">        if (name == null || !name.endsWith(&quot;package-info&quot;)) {</span>
<span class="nc" id="L412">            CheckMethodAdapter.checkInternalName(name, &quot;class name&quot;);</span>
        }
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (&quot;java/lang/Object&quot;.equals(name)) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (superName != null) {</span>
<span class="nc" id="L416">                throw new IllegalArgumentException(</span>
                        &quot;The super class name of the Object class must be 'null'&quot;);
            }
        } else {
<span class="nc" id="L420">            CheckMethodAdapter.checkInternalName(superName, &quot;super class name&quot;);</span>
        }
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (signature != null) {</span>
<span class="nc" id="L423">            checkClassSignature(signature);</span>
        }
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_INTERFACE) != 0) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (!&quot;java/lang/Object&quot;.equals(superName)) {</span>
<span class="nc" id="L427">                throw new IllegalArgumentException(</span>
                        &quot;The super class name of interfaces must be 'java/lang/Object'&quot;);
            }
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (interfaces != null) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">            for (int i = 0; i &lt; interfaces.length; ++i) {</span>
<span class="nc" id="L433">                CheckMethodAdapter.checkInternalName(interfaces[i],</span>
                        &quot;interface name at index &quot; + i);
            }
        }
<span class="nc" id="L437">        this.version = version;</span>
<span class="nc" id="L438">        super.visit(version, access, name, signature, superName, interfaces);</span>
<span class="nc" id="L439">    }</span>

    @Override
    public void visitSource(final String file, final String debug) {
<span class="nc" id="L443">        checkState();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (source) {</span>
<span class="nc" id="L445">            throw new IllegalStateException(</span>
                    &quot;visitSource can be called only once.&quot;);
        }
<span class="nc" id="L448">        source = true;</span>
<span class="nc" id="L449">        super.visitSource(file, debug);</span>
<span class="nc" id="L450">    }</span>

    @Override
    public void visitOuterClass(final String owner, final String name,
            final String desc) {
<span class="nc" id="L455">        checkState();</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (outer) {</span>
<span class="nc" id="L457">            throw new IllegalStateException(</span>
                    &quot;visitOuterClass can be called only once.&quot;);
        }
<span class="nc" id="L460">        outer = true;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (owner == null) {</span>
<span class="nc" id="L462">            throw new IllegalArgumentException(&quot;Illegal outer class owner&quot;);</span>
        }
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (desc != null) {</span>
<span class="nc" id="L465">            CheckMethodAdapter.checkMethodDesc(desc);</span>
        }
<span class="nc" id="L467">        super.visitOuterClass(owner, name, desc);</span>
<span class="nc" id="L468">    }</span>

    @Override
    public void visitInnerClass(final String name, final String outerName,
            final String innerName, final int access) {
<span class="nc" id="L473">        checkState();</span>
<span class="nc" id="L474">        CheckMethodAdapter.checkInternalName(name, &quot;class name&quot;);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (outerName != null) {</span>
<span class="nc" id="L476">            CheckMethodAdapter.checkInternalName(outerName, &quot;outer class name&quot;);</span>
        }
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (innerName != null) {</span>
<span class="nc" id="L479">            int start = 0;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">            while (start &lt; innerName.length()</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">                    &amp;&amp; Character.isDigit(innerName.charAt(start))) {</span>
<span class="nc" id="L482">                start++;</span>
            }
<span class="nc bnc" id="L484" title="All 4 branches missed.">            if (start == 0 || start &lt; innerName.length()) {</span>
<span class="nc" id="L485">                CheckMethodAdapter.checkIdentifier(innerName, start, -1,</span>
                        &quot;inner class name&quot;);
            }
        }
<span class="nc" id="L489">        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE</span>
                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
                + Opcodes.ACC_FINAL + Opcodes.ACC_INTERFACE
                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC
                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM);
<span class="nc" id="L494">        super.visitInnerClass(name, outerName, innerName, access);</span>
<span class="nc" id="L495">    }</span>

    @Override
    public FieldVisitor visitField(final int access, final String name,
            final String desc, final String signature, final Object value) {
<span class="nc" id="L500">        checkState();</span>
<span class="nc" id="L501">        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE</span>
                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
                + Opcodes.ACC_FINAL + Opcodes.ACC_VOLATILE
                + Opcodes.ACC_TRANSIENT + Opcodes.ACC_SYNTHETIC
                + Opcodes.ACC_ENUM + Opcodes.ACC_DEPRECATED + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
<span class="nc" id="L506">        CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;field name&quot;);</span>
<span class="nc" id="L507">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        if (signature != null) {</span>
<span class="nc" id="L509">            checkFieldSignature(signature);</span>
        }
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L512">            CheckMethodAdapter.checkConstant(value);</span>
        }
<span class="nc" id="L514">        FieldVisitor av = super</span>
<span class="nc" id="L515">                .visitField(access, name, desc, signature, value);</span>
<span class="nc" id="L516">        return new CheckFieldAdapter(av);</span>
    }

    @Override
    public MethodVisitor visitMethod(final int access, final String name,
            final String desc, final String signature, final String[] exceptions) {
<span class="nc" id="L522">        checkState();</span>
<span class="nc" id="L523">        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE</span>
                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC
                + Opcodes.ACC_FINAL + Opcodes.ACC_SYNCHRONIZED
                + Opcodes.ACC_BRIDGE + Opcodes.ACC_VARARGS + Opcodes.ACC_NATIVE
                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_STRICT
                + Opcodes.ACC_SYNTHETIC + Opcodes.ACC_DEPRECATED + 0x40000); // ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
<span class="nc bnc" id="L529" title="All 4 branches missed.">        if (!&quot;&lt;init&gt;&quot;.equals(name) &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L530">            CheckMethodAdapter.checkMethodIdentifier(version, name,</span>
                    &quot;method name&quot;);
        }
<span class="nc" id="L533">        CheckMethodAdapter.checkMethodDesc(desc);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (signature != null) {</span>
<span class="nc" id="L535">            checkMethodSignature(signature);</span>
        }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (exceptions != null) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            for (int i = 0; i &lt; exceptions.length; ++i) {</span>
<span class="nc" id="L539">                CheckMethodAdapter.checkInternalName(exceptions[i],</span>
                        &quot;exception name at index &quot; + i);
            }
        }
        CheckMethodAdapter cma;
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (checkDataFlow) {</span>
<span class="nc" id="L545">            cma = new CheckMethodAdapter(access, name, desc, super.visitMethod(</span>
                    access, name, desc, signature, exceptions), labels);
        } else {
<span class="nc" id="L548">            cma = new CheckMethodAdapter(super.visitMethod(access, name, desc,</span>
                    signature, exceptions), labels);
        }
<span class="nc" id="L551">        cma.version = version;</span>
<span class="nc" id="L552">        return cma;</span>
    }

    @Override
    public AnnotationVisitor visitAnnotation(final String desc,
            final boolean visible) {
<span class="nc" id="L558">        checkState();</span>
<span class="nc" id="L559">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc" id="L560">        return new CheckAnnotationAdapter(super.visitAnnotation(desc, visible));</span>
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L566">        checkState();</span>
<span class="nc" id="L567">        int sort = typeRef &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L568" title="All 6 branches missed.">        if (sort != TypeReference.CLASS_TYPE_PARAMETER</span>
                &amp;&amp; sort != TypeReference.CLASS_TYPE_PARAMETER_BOUND
                &amp;&amp; sort != TypeReference.CLASS_EXTENDS) {
<span class="nc" id="L571">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L572">                    + Integer.toHexString(sort));</span>
        }
<span class="nc" id="L574">        checkTypeRefAndPath(typeRef, typePath);</span>
<span class="nc" id="L575">        CheckMethodAdapter.checkDesc(desc, false);</span>
<span class="nc" id="L576">        return new CheckAnnotationAdapter(super.visitTypeAnnotation(typeRef,</span>
                typePath, desc, visible));
    }

    @Override
    public void visitAttribute(final Attribute attr) {
<span class="nc" id="L582">        checkState();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (attr == null) {</span>
<span class="nc" id="L584">            throw new IllegalArgumentException(</span>
                    &quot;Invalid attribute (must not be null)&quot;);
        }
<span class="nc" id="L587">        super.visitAttribute(attr);</span>
<span class="nc" id="L588">    }</span>

    @Override
    public void visitEnd() {
<span class="nc" id="L592">        checkState();</span>
<span class="nc" id="L593">        end = true;</span>
<span class="nc" id="L594">        super.visitEnd();</span>
<span class="nc" id="L595">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods
    // ------------------------------------------------------------------------

    /**
     * Checks that the visit method has been called and that visitEnd has not
     * been called.
     */
    private void checkState() {
<span class="nc bnc" id="L606" title="All 2 branches missed.">        if (!start) {</span>
<span class="nc" id="L607">            throw new IllegalStateException(</span>
                    &quot;Cannot visit member before visit has been called.&quot;);
        }
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (end) {</span>
<span class="nc" id="L611">            throw new IllegalStateException(</span>
                    &quot;Cannot visit member after visitEnd has been called.&quot;);
        }
<span class="nc" id="L614">    }</span>

    /**
     * Checks that the given access flags do not contain invalid flags. This
     * method also checks that mutually incompatible flags are not set
     * simultaneously.
     *
     * @param access
     *            the access flags to be checked
     * @param possibleAccess
     *            the valid access flags.
     */
    static void checkAccess(final int access, final int possibleAccess) {
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if ((access &amp; ~possibleAccess) != 0) {</span>
<span class="nc" id="L628">            throw new IllegalArgumentException(&quot;Invalid access flags: &quot;</span>
                    + access);
        }
<span class="nc bnc" id="L631" title="All 2 branches missed.">        int pub = (access &amp; Opcodes.ACC_PUBLIC) == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        int pri = (access &amp; Opcodes.ACC_PRIVATE) == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">        int pro = (access &amp; Opcodes.ACC_PROTECTED) == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">        if (pub + pri + pro &gt; 1) {</span>
<span class="nc" id="L635">            throw new IllegalArgumentException(</span>
                    &quot;public private and protected are mutually exclusive: &quot;
                            + access);
        }
<span class="nc bnc" id="L639" title="All 2 branches missed.">        int fin = (access &amp; Opcodes.ACC_FINAL) == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">        int abs = (access &amp; Opcodes.ACC_ABSTRACT) == 0 ? 0 : 1;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (fin + abs &gt; 1) {</span>
<span class="nc" id="L642">            throw new IllegalArgumentException(</span>
                    &quot;final and abstract are mutually exclusive: &quot; + access);
        }
<span class="nc" id="L645">    }</span>

    /**
     * Checks a class signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     */
    public static void checkClassSignature(final String signature) {
        // ClassSignature:
        // FormalTypeParameters? ClassTypeSignature ClassTypeSignature*

<span class="nc" id="L657">        int pos = 0;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (getChar(signature, 0) == '&lt;') {</span>
<span class="nc" id="L659">            pos = checkFormalTypeParameters(signature, pos);</span>
        }
<span class="nc" id="L661">        pos = checkClassTypeSignature(signature, pos);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        while (getChar(signature, pos) == 'L') {</span>
<span class="nc" id="L663">            pos = checkClassTypeSignature(signature, pos);</span>
        }
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (pos != signature.length()) {</span>
<span class="nc" id="L666">            throw new IllegalArgumentException(signature + &quot;: error at index &quot;</span>
                    + pos);
        }
<span class="nc" id="L669">    }</span>

    /**
     * Checks a method signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     */
    public static void checkMethodSignature(final String signature) {
        // MethodTypeSignature:
        // FormalTypeParameters? ( TypeSignature* ) ( TypeSignature | V ) (
        // ^ClassTypeSignature | ^TypeVariableSignature )*

<span class="nc" id="L682">        int pos = 0;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (getChar(signature, 0) == '&lt;') {</span>
<span class="nc" id="L684">            pos = checkFormalTypeParameters(signature, pos);</span>
        }
<span class="nc" id="L686">        pos = checkChar('(', signature, pos);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">        while (&quot;ZCBSIFJDL[T&quot;.indexOf(getChar(signature, pos)) != -1) {</span>
<span class="nc" id="L688">            pos = checkTypeSignature(signature, pos);</span>
        }
<span class="nc" id="L690">        pos = checkChar(')', signature, pos);</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">        if (getChar(signature, pos) == 'V') {</span>
<span class="nc" id="L692">            ++pos;</span>
        } else {
<span class="nc" id="L694">            pos = checkTypeSignature(signature, pos);</span>
        }
<span class="nc bnc" id="L696" title="All 2 branches missed.">        while (getChar(signature, pos) == '^') {</span>
<span class="nc" id="L697">            ++pos;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (getChar(signature, pos) == 'L') {</span>
<span class="nc" id="L699">                pos = checkClassTypeSignature(signature, pos);</span>
            } else {
<span class="nc" id="L701">                pos = checkTypeVariableSignature(signature, pos);</span>
            }
        }
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (pos != signature.length()) {</span>
<span class="nc" id="L705">            throw new IllegalArgumentException(signature + &quot;: error at index &quot;</span>
                    + pos);
        }
<span class="nc" id="L708">    }</span>

    /**
     * Checks a field signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     */
    public static void checkFieldSignature(final String signature) {
<span class="nc" id="L717">        int pos = checkFieldTypeSignature(signature, 0);</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (pos != signature.length()) {</span>
<span class="nc" id="L719">            throw new IllegalArgumentException(signature + &quot;: error at index &quot;</span>
                    + pos);
        }
<span class="nc" id="L722">    }</span>

    /**
     * Checks the reference to a type in a type annotation.
     *
     * @param typeRef
     *            a reference to an annotated type.
     * @param typePath
     *            the path to the annotated type argument, wildcard bound, array
     *            element type, or static inner type within 'typeRef'. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the annotation targets 'typeRef' as a whole.
     */
    static void checkTypeRefAndPath(int typeRef, TypePath typePath) {
<span class="nc" id="L735">        int mask = 0;</span>
<span class="nc bnc" id="L736" title="All 5 branches missed.">        switch (typeRef &gt;&gt;&gt; 24) {</span>
        case TypeReference.CLASS_TYPE_PARAMETER:
        case TypeReference.METHOD_TYPE_PARAMETER:
        case TypeReference.METHOD_FORMAL_PARAMETER:
<span class="nc" id="L740">            mask = 0xFFFF0000;</span>
<span class="nc" id="L741">            break;</span>
        case TypeReference.FIELD:
        case TypeReference.METHOD_RETURN:
        case TypeReference.METHOD_RECEIVER:
        case TypeReference.LOCAL_VARIABLE:
        case TypeReference.RESOURCE_VARIABLE:
        case TypeReference.INSTANCEOF:
        case TypeReference.NEW:
        case TypeReference.CONSTRUCTOR_REFERENCE:
        case TypeReference.METHOD_REFERENCE:
<span class="nc" id="L751">            mask = 0xFF000000;</span>
<span class="nc" id="L752">            break;</span>
        case TypeReference.CLASS_EXTENDS:
        case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
        case TypeReference.THROWS:
        case TypeReference.EXCEPTION_PARAMETER:
<span class="nc" id="L758">            mask = 0xFFFFFF00;</span>
<span class="nc" id="L759">            break;</span>
        case TypeReference.CAST:
        case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
        case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
        case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
<span class="nc" id="L765">            mask = 0xFF0000FF;</span>
<span class="nc" id="L766">            break;</span>
        default:
<span class="nc" id="L768">            throw new IllegalArgumentException(&quot;Invalid type reference sort 0x&quot;</span>
<span class="nc" id="L769">                    + Integer.toHexString(typeRef &gt;&gt;&gt; 24));</span>
        }
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if ((typeRef &amp; ~mask) != 0) {</span>
<span class="nc" id="L772">            throw new IllegalArgumentException(&quot;Invalid type reference 0x&quot;</span>
<span class="nc" id="L773">                    + Integer.toHexString(typeRef));</span>
        }
<span class="nc bnc" id="L775" title="All 2 branches missed.">        if (typePath != null) {</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            for (int i = 0; i &lt; typePath.getLength(); ++i) {</span>
<span class="nc" id="L777">                int step = typePath.getStep(i);</span>
<span class="nc bnc" id="L778" title="All 8 branches missed.">                if (step != TypePath.ARRAY_ELEMENT</span>
                        &amp;&amp; step != TypePath.INNER_TYPE
                        &amp;&amp; step != TypePath.TYPE_ARGUMENT
                        &amp;&amp; step != TypePath.WILDCARD_BOUND) {
<span class="nc" id="L782">                    throw new IllegalArgumentException(</span>
                            &quot;Invalid type path step &quot; + i + &quot; in &quot; + typePath);
                }
<span class="nc bnc" id="L785" title="All 2 branches missed.">                if (step != TypePath.TYPE_ARGUMENT</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                        &amp;&amp; typePath.getStepArgument(i) != 0) {</span>
<span class="nc" id="L787">                    throw new IllegalArgumentException(</span>
                            &quot;Invalid type path step argument for step &quot; + i
                                    + &quot; in &quot; + typePath);
                }
            }
        }
<span class="nc" id="L793">    }</span>

    /**
     * Checks the formal type parameters of a class or method signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkFormalTypeParameters(final String signature, int pos) {
        // FormalTypeParameters:
        // &lt; FormalTypeParameter+ &gt;

<span class="nc" id="L808">        pos = checkChar('&lt;', signature, pos);</span>
<span class="nc" id="L809">        pos = checkFormalTypeParameter(signature, pos);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">        while (getChar(signature, pos) != '&gt;') {</span>
<span class="nc" id="L811">            pos = checkFormalTypeParameter(signature, pos);</span>
        }
<span class="nc" id="L813">        return pos + 1;</span>
    }

    /**
     * Checks a formal type parameter of a class or method signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkFormalTypeParameter(final String signature, int pos) {
        // FormalTypeParameter:
        // Identifier : FieldTypeSignature? (: FieldTypeSignature)*

<span class="nc" id="L829">        pos = checkIdentifier(signature, pos);</span>
<span class="nc" id="L830">        pos = checkChar(':', signature, pos);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (&quot;L[T&quot;.indexOf(getChar(signature, pos)) != -1) {</span>
<span class="nc" id="L832">            pos = checkFieldTypeSignature(signature, pos);</span>
        }
<span class="nc bnc" id="L834" title="All 2 branches missed.">        while (getChar(signature, pos) == ':') {</span>
<span class="nc" id="L835">            pos = checkFieldTypeSignature(signature, pos + 1);</span>
        }
<span class="nc" id="L837">        return pos;</span>
    }

    /**
     * Checks a field type signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkFieldTypeSignature(final String signature, int pos) {
        // FieldTypeSignature:
        // ClassTypeSignature | ArrayTypeSignature | TypeVariableSignature
        //
        // ArrayTypeSignature:
        // [ TypeSignature

<span class="nc bnc" id="L856" title="All 3 branches missed.">        switch (getChar(signature, pos)) {</span>
        case 'L':
<span class="nc" id="L858">            return checkClassTypeSignature(signature, pos);</span>
        case '[':
<span class="nc" id="L860">            return checkTypeSignature(signature, pos + 1);</span>
        default:
<span class="nc" id="L862">            return checkTypeVariableSignature(signature, pos);</span>
        }
    }

    /**
     * Checks a class type signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkClassTypeSignature(final String signature, int pos) {
        // ClassTypeSignature:
        // L Identifier ( / Identifier )* TypeArguments? ( . Identifier
        // TypeArguments? )* ;

<span class="nc" id="L880">        pos = checkChar('L', signature, pos);</span>
<span class="nc" id="L881">        pos = checkIdentifier(signature, pos);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        while (getChar(signature, pos) == '/') {</span>
<span class="nc" id="L883">            pos = checkIdentifier(signature, pos + 1);</span>
        }
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (getChar(signature, pos) == '&lt;') {</span>
<span class="nc" id="L886">            pos = checkTypeArguments(signature, pos);</span>
        }
<span class="nc bnc" id="L888" title="All 2 branches missed.">        while (getChar(signature, pos) == '.') {</span>
<span class="nc" id="L889">            pos = checkIdentifier(signature, pos + 1);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">            if (getChar(signature, pos) == '&lt;') {</span>
<span class="nc" id="L891">                pos = checkTypeArguments(signature, pos);</span>
            }
        }
<span class="nc" id="L894">        return checkChar(';', signature, pos);</span>
    }

    /**
     * Checks the type arguments in a class type signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkTypeArguments(final String signature, int pos) {
        // TypeArguments:
        // &lt; TypeArgument+ &gt;

<span class="nc" id="L910">        pos = checkChar('&lt;', signature, pos);</span>
<span class="nc" id="L911">        pos = checkTypeArgument(signature, pos);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        while (getChar(signature, pos) != '&gt;') {</span>
<span class="nc" id="L913">            pos = checkTypeArgument(signature, pos);</span>
        }
<span class="nc" id="L915">        return pos + 1;</span>
    }

    /**
     * Checks a type argument in a class type signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkTypeArgument(final String signature, int pos) {
        // TypeArgument:
        // * | ( ( + | - )? FieldTypeSignature )

<span class="nc" id="L931">        char c = getChar(signature, pos);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (c == '*') {</span>
<span class="nc" id="L933">            return pos + 1;</span>
<span class="nc bnc" id="L934" title="All 4 branches missed.">        } else if (c == '+' || c == '-') {</span>
<span class="nc" id="L935">            pos++;</span>
        }
<span class="nc" id="L937">        return checkFieldTypeSignature(signature, pos);</span>
    }

    /**
     * Checks a type variable signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkTypeVariableSignature(final String signature,
            int pos) {
        // TypeVariableSignature:
        // T Identifier ;

<span class="nc" id="L954">        pos = checkChar('T', signature, pos);</span>
<span class="nc" id="L955">        pos = checkIdentifier(signature, pos);</span>
<span class="nc" id="L956">        return checkChar(';', signature, pos);</span>
    }

    /**
     * Checks a type signature.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkTypeSignature(final String signature, int pos) {
        // TypeSignature:
        // Z | C | B | S | I | F | J | D | FieldTypeSignature

<span class="nc bnc" id="L972" title="All 2 branches missed.">        switch (getChar(signature, pos)) {</span>
        case 'Z':
        case 'C':
        case 'B':
        case 'S':
        case 'I':
        case 'F':
        case 'J':
        case 'D':
<span class="nc" id="L981">            return pos + 1;</span>
        default:
<span class="nc" id="L983">            return checkFieldTypeSignature(signature, pos);</span>
        }
    }

    /**
     * Checks an identifier.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkIdentifier(final String signature, int pos) {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (!Character.isJavaIdentifierStart(getChar(signature, pos))) {</span>
<span class="nc" id="L998">            throw new IllegalArgumentException(signature</span>
                    + &quot;: identifier expected at index &quot; + pos);
        }
<span class="nc" id="L1001">        ++pos;</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">        while (Character.isJavaIdentifierPart(getChar(signature, pos))) {</span>
<span class="nc" id="L1003">            ++pos;</span>
        }
<span class="nc" id="L1005">        return pos;</span>
    }

    /**
     * Checks a single character.
     *
     * @param signature
     *            a string containing the signature that must be checked.
     * @param pos
     *            index of first character to be checked.
     * @return the index of the first character after the checked part.
     */
    private static int checkChar(final char c, final String signature, int pos) {
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if (getChar(signature, pos) == c) {</span>
<span class="nc" id="L1019">            return pos + 1;</span>
        }
<span class="nc" id="L1021">        throw new IllegalArgumentException(signature + &quot;: '&quot; + c</span>
                + &quot;' expected at index &quot; + pos);
    }

    /**
     * Returns the signature car at the given index.
     *
     * @param signature
     *            a signature.
     * @param pos
     *            an index in signature.
     * @return the character at the given index, or 0 if there is no such
     *         character.
     */
    private static char getChar(final String signature, int pos) {
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        return pos &lt; signature.length() ? signature.charAt(pos) : (char) 0;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>