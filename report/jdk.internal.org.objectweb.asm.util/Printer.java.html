<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Printer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm.util</a> &gt; <span class="el_source">Printer.java</span></div><h1>Printer.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm.util;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import jdk.internal.org.objectweb.asm.Attribute;
import jdk.internal.org.objectweb.asm.Handle;
import jdk.internal.org.objectweb.asm.Label;
import jdk.internal.org.objectweb.asm.Opcodes;
import jdk.internal.org.objectweb.asm.TypePath;

/**
 * An abstract converter from visit events to text.
 *
 * @author Eric Bruneton
 */
public abstract class Printer {

    /**
     * The names of the Java Virtual Machine opcodes.
     */
    public static final String[] OPCODES;

    /**
     * The names of the for &lt;code&gt;operand&lt;/code&gt; parameter values of the
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitIntInsn} method when
     * &lt;code&gt;opcode&lt;/code&gt; is &lt;code&gt;NEWARRAY&lt;/code&gt;.
     */
    public static final String[] TYPES;

    /**
     * The names of the &lt;code&gt;tag&lt;/code&gt; field values for
     * {@link jdk.internal.org.objectweb.asm.Handle}.
     */
    public static final String[] HANDLE_TAG;

    static {
<span class="nc" id="L97">        String s = &quot;NOP,ACONST_NULL,ICONST_M1,ICONST_0,ICONST_1,ICONST_2,&quot;</span>
                + &quot;ICONST_3,ICONST_4,ICONST_5,LCONST_0,LCONST_1,FCONST_0,&quot;
                + &quot;FCONST_1,FCONST_2,DCONST_0,DCONST_1,BIPUSH,SIPUSH,LDC,,,&quot;
                + &quot;ILOAD,LLOAD,FLOAD,DLOAD,ALOAD,,,,,,,,,,,,,,,,,,,,,IALOAD,&quot;
                + &quot;LALOAD,FALOAD,DALOAD,AALOAD,BALOAD,CALOAD,SALOAD,ISTORE,&quot;
                + &quot;LSTORE,FSTORE,DSTORE,ASTORE,,,,,,,,,,,,,,,,,,,,,IASTORE,&quot;
                + &quot;LASTORE,FASTORE,DASTORE,AASTORE,BASTORE,CASTORE,SASTORE,POP,&quot;
                + &quot;POP2,DUP,DUP_X1,DUP_X2,DUP2,DUP2_X1,DUP2_X2,SWAP,IADD,LADD,&quot;
                + &quot;FADD,DADD,ISUB,LSUB,FSUB,DSUB,IMUL,LMUL,FMUL,DMUL,IDIV,LDIV,&quot;
                + &quot;FDIV,DDIV,IREM,LREM,FREM,DREM,INEG,LNEG,FNEG,DNEG,ISHL,LSHL,&quot;
                + &quot;ISHR,LSHR,IUSHR,LUSHR,IAND,LAND,IOR,LOR,IXOR,LXOR,IINC,I2L,&quot;
                + &quot;I2F,I2D,L2I,L2F,L2D,F2I,F2L,F2D,D2I,D2L,D2F,I2B,I2C,I2S,LCMP,&quot;
                + &quot;FCMPL,FCMPG,DCMPL,DCMPG,IFEQ,IFNE,IFLT,IFGE,IFGT,IFLE,&quot;
                + &quot;IF_ICMPEQ,IF_ICMPNE,IF_ICMPLT,IF_ICMPGE,IF_ICMPGT,IF_ICMPLE,&quot;
                + &quot;IF_ACMPEQ,IF_ACMPNE,GOTO,JSR,RET,TABLESWITCH,LOOKUPSWITCH,&quot;
                + &quot;IRETURN,LRETURN,FRETURN,DRETURN,ARETURN,RETURN,GETSTATIC,&quot;
                + &quot;PUTSTATIC,GETFIELD,PUTFIELD,INVOKEVIRTUAL,INVOKESPECIAL,&quot;
                + &quot;INVOKESTATIC,INVOKEINTERFACE,INVOKEDYNAMIC,NEW,NEWARRAY,&quot;
                + &quot;ANEWARRAY,ARRAYLENGTH,ATHROW,CHECKCAST,INSTANCEOF,&quot;
                + &quot;MONITORENTER,MONITOREXIT,,MULTIANEWARRAY,IFNULL,IFNONNULL,&quot;;
<span class="nc" id="L117">        OPCODES = new String[200];</span>
<span class="nc" id="L118">        int i = 0;</span>
<span class="nc" id="L119">        int j = 0;</span>
        int l;
<span class="nc bnc" id="L121" title="All 2 branches missed.">        while ((l = s.indexOf(',', j)) &gt; 0) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            OPCODES[i++] = j + 1 == l ? null : s.substring(j, l);</span>
<span class="nc" id="L123">            j = l + 1;</span>
        }

<span class="nc" id="L126">        s = &quot;T_BOOLEAN,T_CHAR,T_FLOAT,T_DOUBLE,T_BYTE,T_SHORT,T_INT,T_LONG,&quot;;</span>
<span class="nc" id="L127">        TYPES = new String[12];</span>
<span class="nc" id="L128">        j = 0;</span>
<span class="nc" id="L129">        i = 4;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        while ((l = s.indexOf(',', j)) &gt; 0) {</span>
<span class="nc" id="L131">            TYPES[i++] = s.substring(j, l);</span>
<span class="nc" id="L132">            j = l + 1;</span>
        }

<span class="nc" id="L135">        s = &quot;H_GETFIELD,H_GETSTATIC,H_PUTFIELD,H_PUTSTATIC,&quot;</span>
                + &quot;H_INVOKEVIRTUAL,H_INVOKESTATIC,H_INVOKESPECIAL,&quot;
                + &quot;H_NEWINVOKESPECIAL,H_INVOKEINTERFACE,&quot;;
<span class="nc" id="L138">        HANDLE_TAG = new String[10];</span>
<span class="nc" id="L139">        j = 0;</span>
<span class="nc" id="L140">        i = 1;</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">        while ((l = s.indexOf(',', j)) &gt; 0) {</span>
<span class="nc" id="L142">            HANDLE_TAG[i++] = s.substring(j, l);</span>
<span class="nc" id="L143">            j = l + 1;</span>
        }
<span class="nc" id="L145">    }</span>

    /**
     * The ASM API version implemented by this class. The value of this field
     * must be one of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     */
    protected final int api;

    /**
     * A buffer that can be used to create strings.
     */
    protected final StringBuffer buf;

    /**
     * The text to be printed. Since the code of methods is not necessarily
     * visited in sequential order, one method after the other, but can be
     * interlaced (some instructions from method one, then some instructions
     * from method two, then some instructions from method one again...), it is
     * not possible to print the visited instructions directly to a sequential
     * stream. A class is therefore printed in a two steps process: a string
     * tree is constructed during the visit, and printed to a sequential stream
     * at the end of the visit. This string tree is stored in this field, as a
     * string list that can contain other string lists, which can themselves
     * contain other string lists, and so on.
     */
    public final List&lt;Object&gt; text;

    /**
     * Constructs a new {@link Printer}.
     */
<span class="nc" id="L175">    protected Printer(final int api) {</span>
<span class="nc" id="L176">        this.api = api;</span>
<span class="nc" id="L177">        this.buf = new StringBuffer();</span>
<span class="nc" id="L178">        this.text = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L179">    }</span>

    /**
     * Class header. See {@link jdk.internal.org.objectweb.asm.ClassVisitor#visit}.
     */
    public abstract void visit(final int version, final int access,
            final String name, final String signature, final String superName,
            final String[] interfaces);

    /**
     * Class source. See {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitSource}.
     */
    public abstract void visitSource(final String file, final String debug);

    /**
     * Class outer class. See
     * {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitOuterClass}.
     */
    public abstract void visitOuterClass(final String owner, final String name,
            final String desc);

    /**
     * Class annotation. See
     * {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitAnnotation}.
     */
    public abstract Printer visitClassAnnotation(final String desc,
            final boolean visible);

    /**
     * Class type annotation. See
     * {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitTypeAnnotation}.
     */
    public Printer visitClassTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L213">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Class attribute. See
     * {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitAttribute}.
     */
    public abstract void visitClassAttribute(final Attribute attr);

    /**
     * Class inner name. See
     * {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitInnerClass}.
     */
    public abstract void visitInnerClass(final String name,
            final String outerName, final String innerName, final int access);

    /**
     * Class field. See {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitField}.
     */
    public abstract Printer visitField(final int access, final String name,
            final String desc, final String signature, final Object value);

    /**
     * Class method. See {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitMethod}.
     */
    public abstract Printer visitMethod(final int access, final String name,
            final String desc, final String signature, final String[] exceptions);

    /**
     * Class end. See {@link jdk.internal.org.objectweb.asm.ClassVisitor#visitEnd}.
     */
    public abstract void visitClassEnd();

    // ------------------------------------------------------------------------
    // Annotations
    // ------------------------------------------------------------------------

    /**
     * Annotation value. See {@link jdk.internal.org.objectweb.asm.AnnotationVisitor#visit}.
     */
    public abstract void visit(final String name, final Object value);

    /**
     * Annotation enum value. See
     * {@link jdk.internal.org.objectweb.asm.AnnotationVisitor#visitEnum}.
     */
    public abstract void visitEnum(final String name, final String desc,
            final String value);

    /**
     * Nested annotation value. See
     * {@link jdk.internal.org.objectweb.asm.AnnotationVisitor#visitAnnotation}.
     */
    public abstract Printer visitAnnotation(final String name, final String desc);

    /**
     * Annotation array value. See
     * {@link jdk.internal.org.objectweb.asm.AnnotationVisitor#visitArray}.
     */
    public abstract Printer visitArray(final String name);

    /**
     * Annotation end. See {@link jdk.internal.org.objectweb.asm.AnnotationVisitor#visitEnd}.
     */
    public abstract void visitAnnotationEnd();

    // ------------------------------------------------------------------------
    // Fields
    // ------------------------------------------------------------------------

    /**
     * Field annotation. See
     * {@link jdk.internal.org.objectweb.asm.FieldVisitor#visitAnnotation}.
     */
    public abstract Printer visitFieldAnnotation(final String desc,
            final boolean visible);

    /**
     * Field type annotation. See
     * {@link jdk.internal.org.objectweb.asm.FieldVisitor#visitTypeAnnotation}.
     */
    public Printer visitFieldTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L296">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Field attribute. See
     * {@link jdk.internal.org.objectweb.asm.FieldVisitor#visitAttribute}.
     */
    public abstract void visitFieldAttribute(final Attribute attr);

    /**
     * Field end. See {@link jdk.internal.org.objectweb.asm.FieldVisitor#visitEnd}.
     */
    public abstract void visitFieldEnd();

    // ------------------------------------------------------------------------
    // Methods
    // ------------------------------------------------------------------------

    /**
     * Method parameter. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitParameter(String, int)}.
     */
    public void visitParameter(String name, int access) {
<span class="nc" id="L319">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method default annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitAnnotationDefault}.
     */
    public abstract Printer visitAnnotationDefault();

    /**
     * Method annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitAnnotation}.
     */
    public abstract Printer visitMethodAnnotation(final String desc,
            final boolean visible);

    /**
     * Method type annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTypeAnnotation}.
     */
    public Printer visitMethodTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L341">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method parameter annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitParameterAnnotation}.
     */
    public abstract Printer visitParameterAnnotation(final int parameter,
            final String desc, final boolean visible);

    /**
     * Method attribute. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitAttribute}.
     */
    public abstract void visitMethodAttribute(final Attribute attr);

    /**
     * Method start. See {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitCode}.
     */
    public abstract void visitCode();

    /**
     * Method stack frame. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitFrame}.
     */
    public abstract void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack);

    /**
     * Method instruction. See {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitInsn}
     * .
     */
    public abstract void visitInsn(final int opcode);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitIntInsn}.
     */
    public abstract void visitIntInsn(final int opcode, final int operand);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitVarInsn}.
     */
    public abstract void visitVarInsn(final int opcode, final int var);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTypeInsn}.
     */
    public abstract void visitTypeInsn(final int opcode, final String type);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitFieldInsn}.
     */
    public abstract void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitMethodInsn}.
     */
    @Deprecated
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (api &gt;= Opcodes.ASM5) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            boolean itf = opcode == Opcodes.INVOKEINTERFACE;</span>
<span class="nc" id="L409">            visitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L410">            return;</span>
        }
<span class="nc" id="L412">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitMethodInsn}.
     */
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc bnc" id="L422" title="All 4 branches missed.">            if (itf != (opcode == Opcodes.INVOKEINTERFACE)) {</span>
<span class="nc" id="L423">                throw new IllegalArgumentException(</span>
                        &quot;INVOKESPECIAL/STATIC on interfaces require ASM 5&quot;);
            }
<span class="nc" id="L426">            visitMethodInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L427">            return;</span>
        }
<span class="nc" id="L429">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitInvokeDynamicInsn}.
     */
    public abstract void visitInvokeDynamicInsn(String name, String desc,
            Handle bsm, Object... bsmArgs);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitJumpInsn}.
     */
    public abstract void visitJumpInsn(final int opcode, final Label label);

    /**
     * Method label. See {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitLabel}.
     */
    public abstract void visitLabel(final Label label);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitLdcInsn}.
     */
    public abstract void visitLdcInsn(final Object cst);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitIincInsn}.
     */
    public abstract void visitIincInsn(final int var, final int increment);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTableSwitchInsn}.
     */
    public abstract void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitLookupSwitchInsn}.
     */
    public abstract void visitLookupSwitchInsn(final Label dflt,
            final int[] keys, final Label[] labels);

    /**
     * Method instruction. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitMultiANewArrayInsn}.
     */
    public abstract void visitMultiANewArrayInsn(final String desc,
            final int dims);

    /**
     * Instruction type annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitInsnAnnotation}.
     */
    public Printer visitInsnAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L489">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method exception handler. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTryCatchBlock}.
     */
    public abstract void visitTryCatchBlock(final Label start, final Label end,
            final Label handler, final String type);

    /**
     * Try catch block type annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTryCatchAnnotation}.
     */
    public Printer visitTryCatchAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
<span class="nc" id="L505">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method debug info. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitLocalVariable}.
     */
    public abstract void visitLocalVariable(final String name,
            final String desc, final String signature, final Label start,
            final Label end, final int index);

    /**
     * Local variable type annotation. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitTryCatchAnnotation}.
     */
    public Printer visitLocalVariableAnnotation(final int typeRef,
            final TypePath typePath, final Label[] start, final Label[] end,
            final int[] index, final String desc, final boolean visible) {
<span class="nc" id="L523">        throw new RuntimeException(&quot;Must be overriden&quot;);</span>
    }

    /**
     * Method debug info. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitLineNumber}.
     */
    public abstract void visitLineNumber(final int line, final Label start);

    /**
     * Method max stack and max locals. See
     * {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitMaxs}.
     */
    public abstract void visitMaxs(final int maxStack, final int maxLocals);

    /**
     * Method end. See {@link jdk.internal.org.objectweb.asm.MethodVisitor#visitEnd}.
     */
    public abstract void visitMethodEnd();

    /**
     * Returns the text constructed by this visitor.
     *
     * @return the text constructed by this visitor.
     */
    public List&lt;Object&gt; getText() {
<span class="nc" id="L549">        return text;</span>
    }

    /**
     * Prints the text constructed by this visitor.
     *
     * @param pw
     *            the print writer to be used.
     */
    public void print(final PrintWriter pw) {
<span class="nc" id="L559">        printList(pw, text);</span>
<span class="nc" id="L560">    }</span>

    /**
     * Appends a quoted string to a given buffer.
     *
     * @param buf
     *            the buffer where the string must be added.
     * @param s
     *            the string to be added.
     */
    public static void appendString(final StringBuffer buf, final String s) {
<span class="nc" id="L571">        buf.append('\&quot;');</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">        for (int i = 0; i &lt; s.length(); ++i) {</span>
<span class="nc" id="L573">            char c = s.charAt(i);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (c == '\n') {</span>
<span class="nc" id="L575">                buf.append(&quot;\\n&quot;);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            } else if (c == '\r') {</span>
<span class="nc" id="L577">                buf.append(&quot;\\r&quot;);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            } else if (c == '\\') {</span>
<span class="nc" id="L579">                buf.append(&quot;\\\\&quot;);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            } else if (c == '&quot;') {</span>
<span class="nc" id="L581">                buf.append(&quot;\\\&quot;&quot;);</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">            } else if (c &lt; 0x20 || c &gt; 0x7f) {</span>
<span class="nc" id="L583">                buf.append(&quot;\\u&quot;);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (c &lt; 0x10) {</span>
<span class="nc" id="L585">                    buf.append(&quot;000&quot;);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                } else if (c &lt; 0x100) {</span>
<span class="nc" id="L587">                    buf.append(&quot;00&quot;);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">                } else if (c &lt; 0x1000) {</span>
<span class="nc" id="L589">                    buf.append('0');</span>
                }
<span class="nc" id="L591">                buf.append(Integer.toString(c, 16));</span>
            } else {
<span class="nc" id="L593">                buf.append(c);</span>
            }
        }
<span class="nc" id="L596">        buf.append('\&quot;');</span>
<span class="nc" id="L597">    }</span>

    /**
     * Prints the given string tree.
     *
     * @param pw
     *            the writer to be used to print the tree.
     * @param l
     *            a string tree, i.e., a string list that can contain other
     *            string lists, and so on recursively.
     */
    static void printList(final PrintWriter pw, final List&lt;?&gt; l) {
<span class="nc bnc" id="L609" title="All 2 branches missed.">        for (int i = 0; i &lt; l.size(); ++i) {</span>
<span class="nc" id="L610">            Object o = l.get(i);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (o instanceof List) {</span>
<span class="nc" id="L612">                printList(pw, (List&lt;?&gt;) o);</span>
            } else {
<span class="nc" id="L614">                pw.print(o.toString());</span>
            }
        }
<span class="nc" id="L617">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>