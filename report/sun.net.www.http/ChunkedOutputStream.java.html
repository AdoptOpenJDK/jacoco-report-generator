<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ChunkedOutputStream.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www.http</a> &gt; <span class="el_source">ChunkedOutputStream.java</span></div><h1>ChunkedOutputStream.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.net.www.http;

import java.io.*;

/**
 * OutputStream that sends the output to the underlying stream using chunked
 * encoding as specified in RFC 2068.
 */
public class ChunkedOutputStream extends PrintStream {

    /* Default chunk size (including chunk header) if not specified */
    static final int DEFAULT_CHUNK_SIZE = 4096;
<span class="fc" id="L37">    private static final byte[] CRLF = {'\r', '\n'};</span>
<span class="fc" id="L38">    private static final int CRLF_SIZE = CRLF.length;</span>
<span class="fc" id="L39">    private static final byte[] FOOTER = CRLF;</span>
<span class="fc" id="L40">    private static final int FOOTER_SIZE = CRLF_SIZE;</span>
<span class="fc" id="L41">    private static final byte[] EMPTY_CHUNK_HEADER = getHeader(0);</span>
<span class="fc" id="L42">    private static final int EMPTY_CHUNK_HEADER_SIZE = getHeaderSize(0);</span>

    /* internal buffer */
    private byte buf[];
    /* size of data (excluding footers and headers) already stored in buf */
    private int size;
    /* current index in buf (i.e. buf[count] */
    private int count;
    /* number of bytes to be filled up to complete a data chunk
     * currently being built */
    private int spaceInCurrentChunk;

    /* underlying stream */
    private PrintStream out;

    /* the chunk size we use */
    private int preferredChunkDataSize;
    private int preferedHeaderSize;
    private int preferredChunkGrossSize;
    /* header for a complete Chunk */
    private byte[] completeHeader;

    /* return the size of the header for a particular chunk size */
    private static int getHeaderSize(int size) {
<span class="fc" id="L66">        return (Integer.toHexString(size)).length() + CRLF_SIZE;</span>
    }

    /* return a header for a particular chunk size */
    private static byte[] getHeader(int size){
        try {
<span class="fc" id="L72">            String hexStr =  Integer.toHexString(size);</span>
<span class="fc" id="L73">            byte[] hexBytes = hexStr.getBytes(&quot;US-ASCII&quot;);</span>
<span class="fc" id="L74">            byte[] header = new byte[getHeaderSize(size)];</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            for (int i=0; i&lt;hexBytes.length; i++)</span>
<span class="fc" id="L76">                header[i] = hexBytes[i];</span>
<span class="fc" id="L77">            header[hexBytes.length] = CRLF[0];</span>
<span class="fc" id="L78">            header[hexBytes.length+1] = CRLF[1];</span>
<span class="fc" id="L79">            return header;</span>
<span class="nc" id="L80">        } catch (java.io.UnsupportedEncodingException e) {</span>
            /* This should never happen */
<span class="nc" id="L82">            throw new InternalError(e.getMessage(), e);</span>
        }
    }

    public ChunkedOutputStream(PrintStream o) {
<span class="nc" id="L87">        this(o, DEFAULT_CHUNK_SIZE);</span>
<span class="nc" id="L88">    }</span>

    public ChunkedOutputStream(PrintStream o, int size) {
<span class="fc" id="L91">        super(o);</span>
<span class="fc" id="L92">        out = o;</span>

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (size &lt;= 0) {</span>
<span class="nc" id="L95">            size = DEFAULT_CHUNK_SIZE;</span>
        }

        /* Adjust the size to cater for the chunk header - eg: if the
         * preferred chunk size is 1k this means the chunk size should
         * be 1017 bytes (differs by 7 from preferred size because of
         * 3 bytes for chunk size in hex and CRLF (header) and CRLF (footer)).
         *
         * If headerSize(adjusted_size) is shorter then headerSize(size)
         * then try to use the extra byte unless headerSize(adjusted_size+1)
         * increases back to headerSize(size)
         */
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (size &gt; 0) {</span>
<span class="fc" id="L108">            int adjusted_size = size - getHeaderSize(size) - FOOTER_SIZE;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (getHeaderSize(adjusted_size+1) &lt; getHeaderSize(size)){</span>
<span class="fc" id="L110">                adjusted_size++;</span>
            }
<span class="fc" id="L112">            size = adjusted_size;</span>
        }

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (size &gt; 0) {</span>
<span class="fc" id="L116">            preferredChunkDataSize = size;</span>
        } else {
<span class="nc" id="L118">            preferredChunkDataSize = DEFAULT_CHUNK_SIZE -</span>
<span class="nc" id="L119">                    getHeaderSize(DEFAULT_CHUNK_SIZE) - FOOTER_SIZE;</span>
        }

<span class="fc" id="L122">        preferedHeaderSize = getHeaderSize(preferredChunkDataSize);</span>
<span class="fc" id="L123">        preferredChunkGrossSize = preferedHeaderSize + preferredChunkDataSize</span>
                + FOOTER_SIZE;
<span class="fc" id="L125">        completeHeader = getHeader(preferredChunkDataSize);</span>

        /* start with an initial buffer */
<span class="fc" id="L128">        buf = new byte[preferredChunkGrossSize];</span>
<span class="fc" id="L129">        reset();</span>
<span class="fc" id="L130">    }</span>

    /*
     * Flush a buffered, completed chunk to an underlying stream. If the data in
     * the buffer is insufficient to build up a chunk of &quot;preferredChunkSize&quot;
     * then the data do not get flushed unless flushAll is true. If flushAll is
     * true then the remaining data builds up a last chunk which size is smaller
     * than preferredChunkSize, and then the last chunk gets flushed to
     * underlying stream. If flushAll is true and there is no data in a buffer
     * at all then an empty chunk (containing a header only) gets flushed to
     * underlying stream.
     */
     private void flush(boolean flushAll) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (spaceInCurrentChunk == 0) {</span>
            /* flush a completed chunk to underlying stream */
<span class="fc" id="L145">            out.write(buf, 0, preferredChunkGrossSize);</span>
<span class="fc" id="L146">            out.flush();</span>
<span class="fc" id="L147">            reset();</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        } else if (flushAll){</span>
            /* complete the last chunk and flush it to underlying stream */
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (size &gt; 0){</span>
                /* adjust a header start index in case the header of the last
                 * chunk is shorter then preferedHeaderSize */

<span class="fc" id="L154">                int adjustedHeaderStartIndex = preferedHeaderSize -</span>
<span class="fc" id="L155">                        getHeaderSize(size);</span>

                /* write header */
<span class="fc" id="L158">                System.arraycopy(getHeader(size), 0, buf,</span>
<span class="fc" id="L159">                        adjustedHeaderStartIndex, getHeaderSize(size));</span>

                /* write footer */
<span class="fc" id="L162">                buf[count++] = FOOTER[0];</span>
<span class="fc" id="L163">                buf[count++] = FOOTER[1];</span>

                //send the last chunk to underlying stream
<span class="fc" id="L166">                out.write(buf, adjustedHeaderStartIndex, count - adjustedHeaderStartIndex);</span>
<span class="fc" id="L167">            } else {</span>
                //send an empty chunk (containing just a header) to underlying stream
<span class="fc" id="L169">                out.write(EMPTY_CHUNK_HEADER, 0, EMPTY_CHUNK_HEADER_SIZE);</span>
            }

<span class="fc" id="L172">            out.flush();</span>
<span class="fc" id="L173">            reset();</span>
         }
<span class="fc" id="L175">    }</span>

    @Override
    public boolean checkError() {
<span class="fc" id="L179">        return out.checkError();</span>
    }

    /* Check that the output stream is still open */
    private void ensureOpen() {
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (out == null)</span>
<span class="nc" id="L185">            setError();</span>
<span class="fc" id="L186">    }</span>

   /*
    * Writes data from b[] to an internal buffer and stores the data as data
    * chunks of a following format: {Data length in Hex}{CRLF}{data}{CRLF}
    * The size of the data is preferredChunkSize. As soon as a completed chunk
    * is read from b[] a process of reading from b[] suspends, the chunk gets
    * flushed to the underlying stream and then the reading process from b[]
    * continues. When there is no more sufficient data in b[] to build up a
    * chunk of preferredChunkSize size the data get stored as an incomplete
    * chunk of a following format: {space for data length}{CRLF}{data}
    * The size of the data is of course smaller than preferredChunkSize.
    */
    @Override
    public synchronized void write(byte b[], int off, int len) {
<span class="fc" id="L201">        ensureOpen();</span>
<span class="pc bpc" id="L202" title="5 of 10 branches missed.">        if ((off &lt; 0) || (off &gt; b.length) || (len &lt; 0) ||</span>
            ((off + len) &gt; b.length) || ((off + len) &lt; 0)) {
<span class="nc" id="L204">            throw new IndexOutOfBoundsException();</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        } else if (len == 0) {</span>
<span class="nc" id="L206">            return;</span>
        }

        /* if b[] contains enough data then one loop cycle creates one complete
         * data chunk with a header, body and a footer, and then flushes the
         * chunk to the underlying stream. Otherwise, the last loop cycle
         * creates incomplete data chunk with empty header and with no footer
         * and stores this incomplete chunk in an internal buffer buf[]
         */
<span class="fc" id="L215">        int bytesToWrite = len;</span>
<span class="fc" id="L216">        int inputIndex = off;  /* the index of the byte[] currently being written */</span>

        do {
            /* enough data to complete a chunk */
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (bytesToWrite &gt;= spaceInCurrentChunk) {</span>

                /* header */
<span class="fc bfc" id="L223" title="All 2 branches covered.">                for (int i=0; i&lt;completeHeader.length; i++)</span>
<span class="fc" id="L224">                    buf[i] = completeHeader[i];</span>

                /* data */
<span class="fc" id="L227">                System.arraycopy(b, inputIndex, buf, count, spaceInCurrentChunk);</span>
<span class="fc" id="L228">                inputIndex += spaceInCurrentChunk;</span>
<span class="fc" id="L229">                bytesToWrite -= spaceInCurrentChunk;</span>
<span class="fc" id="L230">                count += spaceInCurrentChunk;</span>

                /* footer */
<span class="fc" id="L233">                buf[count++] = FOOTER[0];</span>
<span class="fc" id="L234">                buf[count++] = FOOTER[1];</span>
<span class="fc" id="L235">                spaceInCurrentChunk = 0; //chunk is complete</span>

<span class="fc" id="L237">                flush(false);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                if (checkError()){</span>
<span class="fc" id="L239">                    break;</span>
                }
            }

            /* not enough data to build a chunk */
            else {
                /* header */
                /* do not write header if not enough bytes to build a chunk yet */

                /* data */
<span class="fc" id="L249">                System.arraycopy(b, inputIndex, buf, count, bytesToWrite);</span>
<span class="fc" id="L250">                count += bytesToWrite;</span>
<span class="fc" id="L251">                size += bytesToWrite;</span>
<span class="fc" id="L252">                spaceInCurrentChunk -= bytesToWrite;</span>
<span class="fc" id="L253">                bytesToWrite = 0;</span>

                /* footer */
                /* do not write header if not enough bytes to build a chunk yet */
            }
<span class="fc bfc" id="L258" title="All 2 branches covered.">        } while (bytesToWrite &gt; 0);</span>
<span class="fc" id="L259">    }</span>

    @Override
    public synchronized void write(int _b) {
<span class="fc" id="L263">        byte b[] = {(byte)_b};</span>
<span class="fc" id="L264">        write(b, 0, 1);</span>
<span class="fc" id="L265">    }</span>

    public synchronized void reset() {
<span class="fc" id="L268">        count = preferedHeaderSize;</span>
<span class="fc" id="L269">        size = 0;</span>
<span class="fc" id="L270">        spaceInCurrentChunk = preferredChunkDataSize;</span>
<span class="fc" id="L271">    }</span>

    public int size() {
<span class="nc" id="L274">        return size;</span>
    }

    @Override
    public synchronized void close() {
<span class="fc" id="L279">        ensureOpen();</span>

        /* if we have buffer a chunked send it */
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (size &gt; 0) {</span>
<span class="nc" id="L283">            flush(true);</span>
        }

        /* send a zero length chunk */
<span class="fc" id="L287">        flush(true);</span>

        /* don't close the underlying stream */
<span class="fc" id="L290">        out = null;</span>
<span class="fc" id="L291">    }</span>

    @Override
    public synchronized void flush() {
<span class="fc" id="L295">        ensureOpen();</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (size &gt; 0) {</span>
<span class="fc" id="L297">            flush(true);</span>
        }
<span class="fc" id="L299">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>