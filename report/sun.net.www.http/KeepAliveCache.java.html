<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeepAliveCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.net.www.http</a> &gt; <span class="el_source">KeepAliveCache.java</span></div><h1>KeepAliveCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.net.www.http;

import java.io.IOException;
import java.io.NotSerializableException;
import java.util.ArrayList;
import java.util.HashMap;
import java.net.URL;

/**
 * A class that implements a cache of idle Http connections for keep-alive
 *
 * @author Stephen R. Pietrowicz (NCSA)
 * @author Dave Brown
 */
public class KeepAliveCache
    extends HashMap&lt;KeepAliveKey, ClientVector&gt;
    implements Runnable {
    private static final long serialVersionUID = -2937172892064557949L;

    /* maximum # keep-alive connections to maintain at once
     * This should be 2 by the HTTP spec, but because we don't support pipe-lining
     * a larger value is more appropriate. So we now set a default of 5, and the value
     * refers to the number of idle connections per destination (in the cache) only.
     * It can be reset by setting system property &quot;http.maxConnections&quot;.
     */
    static final int MAX_CONNECTIONS = 5;
<span class="fc" id="L52">    static int result = -1;</span>
    static int getMaxConnections() {
<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (result == -1) {</span>
<span class="fc" id="L55">            result = java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetIntegerAction(&quot;http.maxConnections&quot;,
                                                         MAX_CONNECTIONS))
<span class="fc" id="L58">                .intValue();</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            if (result &lt;= 0)</span>
<span class="nc" id="L60">                result = MAX_CONNECTIONS;</span>
        }
<span class="fc" id="L62">            return result;</span>
    }

    static final int LIFETIME = 5000;

<span class="fc" id="L67">    private Thread keepAliveTimer = null;</span>

    /**
     * Constructor
     */
<span class="fc" id="L72">    public KeepAliveCache() {}</span>

    /**
     * Register this URL and HttpClient (that supports keep-alive) with the cache
     * @param url  The URL contains info about the host and port
     * @param http The HttpClient to be cached
     */
    public synchronized void put(final URL url, Object obj, HttpClient http) {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        boolean startThread = (keepAliveTimer == null);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (!startThread) {</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">            if (!keepAliveTimer.isAlive()) {</span>
<span class="fc" id="L83">                startThread = true;</span>
            }
        }
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (startThread) {</span>
<span class="fc" id="L87">            clear();</span>
            /* Unfortunately, we can't always believe the keep-alive timeout we got
             * back from the server.  If I'm connected through a Netscape proxy
             * to a server that sent me a keep-alive
             * time of 15 sec, the proxy unilaterally terminates my connection
             * The robustness to get around this is in HttpClient.parseHTTP()
             */
<span class="fc" id="L94">            final KeepAliveCache cache = this;</span>
<span class="fc" id="L95">            java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L96">                new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                   // We want to create the Keep-Alive-Timer in the
                    // system threadgroup
<span class="fc" id="L100">                    ThreadGroup grp = Thread.currentThread().getThreadGroup();</span>
<span class="fc" id="L101">                    ThreadGroup parent = null;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                    while ((parent = grp.getParent()) != null) {</span>
<span class="fc" id="L103">                        grp = parent;</span>
                    }

<span class="fc" id="L106">                    keepAliveTimer = new Thread(grp, cache, &quot;Keep-Alive-Timer&quot;);</span>
<span class="fc" id="L107">                    keepAliveTimer.setDaemon(true);</span>
<span class="fc" id="L108">                    keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);</span>
                    // Set the context class loader to null in order to avoid
                    // keeping a strong reference to an application classloader.
<span class="fc" id="L111">                    keepAliveTimer.setContextClassLoader(null);</span>
<span class="fc" id="L112">                    keepAliveTimer.start();</span>
<span class="fc" id="L113">                    return null;</span>
                }
            });
        }

<span class="fc" id="L118">        KeepAliveKey key = new KeepAliveKey(url, obj);</span>
<span class="fc" id="L119">        ClientVector v = super.get(key);</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (v == null) {</span>
<span class="fc" id="L122">            int keepAliveTimeout = http.getKeepAliveTimeout();</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            v = new ClientVector(keepAliveTimeout &gt; 0?</span>
                                 keepAliveTimeout*1000 : LIFETIME);
<span class="fc" id="L125">            v.put(http);</span>
<span class="fc" id="L126">            super.put(key, v);</span>
<span class="fc" id="L127">        } else {</span>
<span class="fc" id="L128">            v.put(http);</span>
        }
<span class="fc" id="L130">    }</span>

    /* remove an obsolete HttpClient from its VectorCache */
    public synchronized void remove (HttpClient h, Object obj) {
<span class="nc" id="L134">        KeepAliveKey key = new KeepAliveKey(h.url, obj);</span>
<span class="nc" id="L135">        ClientVector v = super.get(key);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (v != null) {</span>
<span class="nc" id="L137">            v.remove(h);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (v.empty()) {</span>
<span class="nc" id="L139">                removeVector(key);</span>
            }
        }
<span class="nc" id="L142">    }</span>

    /* called by a clientVector thread when all its connections have timed out
     * and that vector of connections should be removed.
     */
    synchronized void removeVector(KeepAliveKey k) {
<span class="fc" id="L148">        super.remove(k);</span>
<span class="fc" id="L149">    }</span>

    /**
     * Check to see if this URL has a cached HttpClient
     */
    public synchronized HttpClient get(URL url, Object obj) {

<span class="fc" id="L156">        KeepAliveKey key = new KeepAliveKey(url, obj);</span>
<span class="fc" id="L157">        ClientVector v = super.get(key);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (v == null) { // nothing in cache yet</span>
<span class="fc" id="L159">            return null;</span>
        }
<span class="fc" id="L161">        return v.get();</span>
    }

    /* Sleeps for an alloted timeout, then checks for timed out connections.
     * Errs on the side of caution (leave connections idle for a relatively
     * short time).
     */
    @Override
    public void run() {
        do {
            try {
<span class="fc" id="L172">                Thread.sleep(LIFETIME);</span>
<span class="pc" id="L173">            } catch (InterruptedException e) {}</span>
<span class="fc" id="L174">            synchronized (this) {</span>
                /* Remove all unused HttpClients.  Starting from the
                 * bottom of the stack (the least-recently used first).
                 * REMIND: It'd be nice to not remove *all* connections
                 * that aren't presently in use.  One could have been added
                 * a second ago that's still perfectly valid, and we're
                 * needlessly axing it.  But it's not clear how to do this
                 * cleanly, and doing it right may be more trouble than it's
                 * worth.
                 */

<span class="fc" id="L185">                long currentTime = System.currentTimeMillis();</span>

<span class="fc" id="L187">                ArrayList&lt;KeepAliveKey&gt; keysToRemove</span>
                    = new ArrayList&lt;KeepAliveKey&gt;();

<span class="fc bfc" id="L190" title="All 2 branches covered.">                for (KeepAliveKey key : keySet()) {</span>
<span class="fc" id="L191">                    ClientVector v = get(key);</span>
<span class="fc" id="L192">                    synchronized (v) {</span>
                        int i;

<span class="fc bfc" id="L195" title="All 2 branches covered.">                        for (i = 0; i &lt; v.size(); i++) {</span>
<span class="fc" id="L196">                            KeepAliveEntry e = v.elementAt(i);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                            if ((currentTime - e.idleStartTime) &gt; v.nap) {</span>
<span class="fc" id="L198">                                HttpClient h = e.hc;</span>
<span class="fc" id="L199">                                h.closeServer();</span>
                            } else {
                                break;
                            }
                        }
<span class="fc" id="L204">                        v.subList(0, i).clear();</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">                        if (v.size() == 0) {</span>
<span class="fc" id="L207">                            keysToRemove.add(key);</span>
                        }
<span class="pc" id="L209">                    }</span>
<span class="fc" id="L210">                }</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">                for (KeepAliveKey key : keysToRemove) {</span>
<span class="fc" id="L213">                    removeVector(key);</span>
<span class="fc" id="L214">                }</span>
<span class="pc" id="L215">            }</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        } while (size() &gt; 0);</span>

<span class="fc" id="L218">        return;</span>
    }

    /*
     * Do not serialize this class!
     */
    private void writeObject(java.io.ObjectOutputStream stream)
    throws IOException {
<span class="nc" id="L226">        throw new NotSerializableException();</span>
    }

    private void readObject(java.io.ObjectInputStream stream)
    throws IOException, ClassNotFoundException {
<span class="nc" id="L231">        throw new NotSerializableException();</span>
    }
}

/* FILO order for recycling HttpClients, should run in a thread
 * to time them out.  If &gt; maxConns are in use, block.
 */


class ClientVector extends java.util.Stack&lt;KeepAliveEntry&gt; {
    private static final long serialVersionUID = -8680532108106489459L;

    // sleep time in milliseconds, before cache clear
    int nap;



<span class="fc" id="L248">    ClientVector (int nap) {</span>
<span class="fc" id="L249">        this.nap = nap;</span>
<span class="fc" id="L250">    }</span>

    synchronized HttpClient get() {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (empty()) {</span>
<span class="fc" id="L254">            return null;</span>
        } else {
            // Loop until we find a connection that has not timed out
<span class="fc" id="L257">            HttpClient hc = null;</span>
<span class="fc" id="L258">            long currentTime = System.currentTimeMillis();</span>
            do {
<span class="fc" id="L260">                KeepAliveEntry e = pop();</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if ((currentTime - e.idleStartTime) &gt; nap) {</span>
<span class="fc" id="L262">                    e.hc.closeServer();</span>
                } else {
<span class="fc" id="L264">                    hc = e.hc;</span>
                }
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">            } while ((hc== null) &amp;&amp; (!empty()));</span>
<span class="fc" id="L267">            return hc;</span>
        }
    }

    /* return a still valid, unused HttpClient */
    synchronized void put(HttpClient h) {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (size() &gt;= KeepAliveCache.getMaxConnections()) {</span>
<span class="fc" id="L274">            h.closeServer(); // otherwise the connection remains in limbo</span>
        } else {
<span class="fc" id="L276">            push(new KeepAliveEntry(h, System.currentTimeMillis()));</span>
        }
<span class="fc" id="L278">    }</span>

    /*
     * Do not serialize this class!
     */
    private void writeObject(java.io.ObjectOutputStream stream)
    throws IOException {
<span class="nc" id="L285">        throw new NotSerializableException();</span>
    }

    private void readObject(java.io.ObjectInputStream stream)
    throws IOException, ClassNotFoundException {
<span class="nc" id="L290">        throw new NotSerializableException();</span>
    }
}


class KeepAliveKey {
<span class="fc" id="L296">    private String      protocol = null;</span>
<span class="fc" id="L297">    private String      host = null;</span>
<span class="fc" id="L298">    private int         port = 0;</span>
<span class="fc" id="L299">    private Object      obj = null; // additional key, such as socketfactory</span>

    /**
     * Constructor
     *
     * @param url the URL containing the protocol, host and port information
     */
<span class="fc" id="L306">    public KeepAliveKey(URL url, Object obj) {</span>
<span class="fc" id="L307">        this.protocol = url.getProtocol();</span>
<span class="fc" id="L308">        this.host = url.getHost();</span>
<span class="fc" id="L309">        this.port = url.getPort();</span>
<span class="fc" id="L310">        this.obj = obj;</span>
<span class="fc" id="L311">    }</span>

    /**
     * Determine whether or not two objects of this type are equal
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if ((obj instanceof KeepAliveKey) == false)</span>
<span class="nc" id="L319">            return false;</span>
<span class="fc" id="L320">        KeepAliveKey kae = (KeepAliveKey)obj;</span>
<span class="pc bpc" id="L321" title="2 of 4 branches missed.">        return host.equals(kae.host)</span>
            &amp;&amp; (port == kae.port)
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">            &amp;&amp; protocol.equals(kae.protocol)</span>
            &amp;&amp; this.obj == kae.obj;
    }

    /**
     * The hashCode() for this object is the string hashCode() of
     * concatenation of the protocol, host name and port.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L333">        String str = protocol+host+port;</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        return this.obj == null? str.hashCode() :</span>
<span class="fc" id="L335">            str.hashCode() + this.obj.hashCode();</span>
    }
}

class KeepAliveEntry {
    HttpClient hc;
    long idleStartTime;

<span class="fc" id="L343">    KeepAliveEntry(HttpClient hc, long idleStartTime) {</span>
<span class="fc" id="L344">        this.hc = hc;</span>
<span class="fc" id="L345">        this.idleStartTime = idleStartTime;</span>
<span class="fc" id="L346">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>