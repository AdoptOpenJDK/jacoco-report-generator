<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Sasl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.sasl</a> &gt; <span class="el_source">Sasl.java</span></div><h1>Sasl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.sasl;

import javax.security.auth.callback.CallbackHandler;

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.security.Provider;
import java.security.Security;

/**
 * A static class for creating SASL clients and servers.
 *&lt;p&gt;
 * This class defines the policy of how to locate, load, and instantiate
 * SASL clients and servers.
 *&lt;p&gt;
 * For example, an application or library gets a SASL client by doing
 * something like:
 *&lt;blockquote&gt;&lt;pre&gt;
 * SaslClient sc = Sasl.createSaslClient(mechanisms,
 *     authorizationId, protocol, serverName, props, callbackHandler);
 *&lt;/pre&gt;&lt;/blockquote&gt;
 * It can then proceed to use the instance to create an authentication connection.
 *&lt;p&gt;
 * Similarly, a server gets a SASL server by using code that looks as follows:
 *&lt;blockquote&gt;&lt;pre&gt;
 * SaslServer ss = Sasl.createSaslServer(mechanism,
 *     protocol, serverName, props, callbackHandler);
 *&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @since 1.5
 *
 * @author Rosanna Lee
 * @author Rob Weltman
 */
public class Sasl {
    // Cannot create one of these
<span class="nc" id="L66">    private Sasl() {</span>
<span class="nc" id="L67">    }</span>

    /**
     * The name of a property that specifies the quality-of-protection to use.
     * The property contains a comma-separated, ordered list
     * of quality-of-protection values that the
     * client or server is willing to support.  A qop value is one of
     * &lt;ul&gt;
     * &lt;li&gt;{@code &quot;auth&quot;} - authentication only&lt;/li&gt;
     * &lt;li&gt;{@code &quot;auth-int&quot;} - authentication plus integrity protection&lt;/li&gt;
     * &lt;li&gt;{@code &quot;auth-conf&quot;} - authentication plus integrity and confidentiality
     * protection&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * The order of the list specifies the preference order of the client or
     * server. If this property is absent, the default qop is {@code &quot;auth&quot;}.
     * The value of this constant is {@code &quot;javax.security.sasl.qop&quot;}.
     */
    public static final String QOP = &quot;javax.security.sasl.qop&quot;;

    /**
     * The name of a property that specifies the cipher strength to use.
     * The property contains a comma-separated, ordered list
     * of cipher strength values that
     * the client or server is willing to support. A strength value is one of
     * &lt;ul&gt;
     * &lt;li&gt;{@code &quot;low&quot;}&lt;/li&gt;
     * &lt;li&gt;{@code &quot;medium&quot;}&lt;/li&gt;
     * &lt;li&gt;{@code &quot;high&quot;}&lt;/li&gt;
     * &lt;/ul&gt;
     * The order of the list specifies the preference order of the client or
     * server.  An implementation should allow configuration of the meaning
     * of these values.  An application may use the Java Cryptography
     * Extension (JCE) with JCE-aware mechanisms to control the selection of
     * cipher suites that match the strength values.
     * &lt;BR&gt;
     * If this property is absent, the default strength is
     * {@code &quot;high,medium,low&quot;}.
     * The value of this constant is {@code &quot;javax.security.sasl.strength&quot;}.
     */
    public static final String STRENGTH = &quot;javax.security.sasl.strength&quot;;

    /**
     * The name of a property that specifies whether the
     * server must authenticate to the client. The property contains
     * {@code &quot;true&quot;} if the server must
     * authenticate the to client; {@code &quot;false&quot;} otherwise.
     * The default is {@code &quot;false&quot;}.
     * &lt;br&gt;The value of this constant is
     * {@code &quot;javax.security.sasl.server.authentication&quot;}.
     */
    public static final String SERVER_AUTH =
    &quot;javax.security.sasl.server.authentication&quot;;

    /**
     * The name of a property that specifies the bound server name for
     * an unbound server. A server is created as an unbound server by setting
     * the {@code serverName} argument in {@link #createSaslServer} as null.
     * The property contains the bound host name after the authentication
     * exchange has completed. It is only available on the server side.
     * &lt;br&gt;The value of this constant is
     * {@code &quot;javax.security.sasl.bound.server.name&quot;}.
     */
    public static final String BOUND_SERVER_NAME =
    &quot;javax.security.sasl.bound.server.name&quot;;

    /**
     * The name of a property that specifies the maximum size of the receive
     * buffer in bytes of {@code SaslClient}/{@code SaslServer}.
     * The property contains the string representation of an integer.
     * &lt;br&gt;If this property is absent, the default size
     * is defined by the mechanism.
     * &lt;br&gt;The value of this constant is {@code &quot;javax.security.sasl.maxbuffer&quot;}.
     */
    public static final String MAX_BUFFER = &quot;javax.security.sasl.maxbuffer&quot;;

    /**
     * The name of a property that specifies the maximum size of the raw send
     * buffer in bytes of {@code SaslClient}/{@code SaslServer}.
     * The property contains the string representation of an integer.
     * The value of this property is negotiated between the client and server
     * during the authentication exchange.
     * &lt;br&gt;The value of this constant is {@code &quot;javax.security.sasl.rawsendsize&quot;}.
     */
    public static final String RAW_SEND_SIZE = &quot;javax.security.sasl.rawsendsize&quot;;

    /**
     * The name of a property that specifies whether to reuse previously
     * authenticated session information. The property contains &quot;true&quot; if the
     * mechanism implementation may attempt to reuse previously authenticated
     * session information; it contains &quot;false&quot; if the implementation must
     * not reuse previously authenticated session information.  A setting of
     * &quot;true&quot; serves only as a hint: it does not necessarily entail actual
     * reuse because reuse might not be possible due to a number of reasons,
     * including, but not limited to, lack of mechanism support for reuse,
     * expiration of reusable information, and the peer's refusal to support
     * reuse.
     *
     * The property's default value is &quot;false&quot;.  The value of this constant
     * is &quot;javax.security.sasl.reuse&quot;.
     *
     * Note that all other parameters and properties required to create a
     * SASL client/server instance must be provided regardless of whether
     * this property has been supplied. That is, you cannot supply any less
     * information in anticipation of reuse.
     *
     * Mechanism implementations that support reuse might allow customization
     * of its implementation, for factors such as cache size, timeouts, and
     * criteria for reusability. Such customizations are
     * implementation-dependent.
     */
     public static final String REUSE = &quot;javax.security.sasl.reuse&quot;;

    /**
     * The name of a property that specifies
     * whether mechanisms susceptible to simple plain passive attacks (e.g.,
     * &quot;PLAIN&quot;) are not permitted. The property
     * contains {@code &quot;true&quot;} if such mechanisms are not permitted;
     * {@code &quot;false&quot;} if such mechanisms are permitted.
     * The default is {@code &quot;false&quot;}.
     * &lt;br&gt;The value of this constant is
     * {@code &quot;javax.security.sasl.policy.noplaintext&quot;}.
     */
    public static final String POLICY_NOPLAINTEXT =
    &quot;javax.security.sasl.policy.noplaintext&quot;;

    /**
     * The name of a property that specifies whether
     * mechanisms susceptible to active (non-dictionary) attacks
     * are not permitted.
     * The property contains {@code &quot;true&quot;}
     * if mechanisms susceptible to active attacks
     * are not permitted; {@code &quot;false&quot;} if such mechanisms are permitted.
     * The default is {@code &quot;false&quot;}.
     * &lt;br&gt;The value of this constant is
     * {@code &quot;javax.security.sasl.policy.noactive&quot;}.
     */
    public static final String POLICY_NOACTIVE =
    &quot;javax.security.sasl.policy.noactive&quot;;

    /**
     * The name of a property that specifies whether
     * mechanisms susceptible to passive dictionary attacks are not permitted.
     * The property contains {@code &quot;true&quot;}
     * if mechanisms susceptible to dictionary attacks are not permitted;
     * {@code &quot;false&quot;} if such mechanisms are permitted.
     * The default is {@code &quot;false&quot;}.
     *&lt;br&gt;
     * The value of this constant is
     * {@code &quot;javax.security.sasl.policy.nodictionary&quot;}.
     */
    public static final String POLICY_NODICTIONARY =
    &quot;javax.security.sasl.policy.nodictionary&quot;;

    /**
     * The name of a property that specifies whether mechanisms that accept
     * anonymous login are not permitted. The property contains {@code &quot;true&quot;}
     * if mechanisms that accept anonymous login are not permitted;
     * {@code &quot;false&quot;}
     * if such mechanisms are permitted. The default is {@code &quot;false&quot;}.
     *&lt;br&gt;
     * The value of this constant is
     * {@code &quot;javax.security.sasl.policy.noanonymous&quot;}.
     */
    public static final String POLICY_NOANONYMOUS =
    &quot;javax.security.sasl.policy.noanonymous&quot;;

     /**
      * The name of a property that specifies whether mechanisms that implement
      * forward secrecy between sessions are required. Forward secrecy
      * means that breaking into one session will not automatically
      * provide information for breaking into future sessions.
      * The property
      * contains {@code &quot;true&quot;} if mechanisms that implement forward secrecy
      * between sessions are required; {@code &quot;false&quot;} if such mechanisms
      * are not required. The default is {@code &quot;false&quot;}.
      *&lt;br&gt;
      * The value of this constant is
      * {@code &quot;javax.security.sasl.policy.forward&quot;}.
      */
    public static final String POLICY_FORWARD_SECRECY =
    &quot;javax.security.sasl.policy.forward&quot;;

    /**
     * The name of a property that specifies whether
     * mechanisms that pass client credentials are required. The property
     * contains {@code &quot;true&quot;} if mechanisms that pass
     * client credentials are required; {@code &quot;false&quot;}
     * if such mechanisms are not required. The default is {@code &quot;false&quot;}.
     *&lt;br&gt;
     * The value of this constant is
     * {@code &quot;javax.security.sasl.policy.credentials&quot;}.
     */
    public static final String POLICY_PASS_CREDENTIALS =
    &quot;javax.security.sasl.policy.credentials&quot;;

    /**
     * The name of a property that specifies the credentials to use.
     * The property contains a mechanism-specific Java credential object.
     * Mechanism implementations may examine the value of this property
     * to determine whether it is a class that they support.
     * The property may be used to supply credentials to a mechanism that
     * supports delegated authentication.
     *&lt;br&gt;
     * The value of this constant is
     * {@code &quot;javax.security.sasl.credentials&quot;}.
     */
    public static final String CREDENTIALS = &quot;javax.security.sasl.credentials&quot;;

    /**
     * Creates a {@code SaslClient} using the parameters supplied.
     *
     * This method uses the
&lt;a href=&quot;{@docRoot}/../technotes/guides/security/crypto/CryptoSpec.html#Provider&quot;&gt;JCA Security Provider Framework&lt;/a&gt;, described in the
     * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;, for
     * locating and selecting a {@code SaslClient} implementation.
     *
     * First, it
     * obtains an ordered list of {@code SaslClientFactory} instances from
     * the registered security providers for the &quot;SaslClientFactory&quot; service
     * and the specified SASL mechanism(s). It then invokes
     * {@code createSaslClient()} on each factory instance on the list
     * until one produces a non-null {@code SaslClient} instance. It returns
     * the non-null {@code SaslClient} instance, or null if the search fails
     * to produce a non-null {@code SaslClient} instance.
     *&lt;p&gt;
     * A security provider for SaslClientFactory registers with the
     * JCA Security Provider Framework keys of the form &lt;br&gt;
     * {@code SaslClientFactory.}&lt;em&gt;{@code mechanism_name}&lt;/em&gt;
     * &lt;br&gt;
     * and values that are class names of implementations of
     * {@code javax.security.sasl.SaslClientFactory}.
     *
     * For example, a provider that contains a factory class,
     * {@code com.wiz.sasl.digest.ClientFactory}, that supports the
     * &quot;DIGEST-MD5&quot; mechanism would register the following entry with the JCA:
     * {@code SaslClientFactory.DIGEST-MD5 com.wiz.sasl.digest.ClientFactory}
     *&lt;p&gt;
     * See the
     * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;
     * for information about how to install and configure security service
     *  providers.
     *
     * @param mechanisms The non-null list of mechanism names to try. Each is the
     * IANA-registered name of a SASL mechanism. (e.g. &quot;GSSAPI&quot;, &quot;CRAM-MD5&quot;).
     * @param authorizationId The possibly null protocol-dependent
     * identification to be used for authorization.
     * If null or empty, the server derives an authorization
     * ID from the client's authentication credentials.
     * When the SASL authentication completes successfully,
     * the specified entity is granted access.
     *
     * @param protocol The non-null string name of the protocol for which
     * the authentication is being performed (e.g., &quot;ldap&quot;).
     *
     * @param serverName The non-null fully-qualified host name of the server
     * to authenticate to.
     *
     * @param props The possibly null set of properties used to
     * select the SASL mechanism and to configure the authentication
     * exchange of the selected mechanism.
     * For example, if {@code props} contains the
     * {@code Sasl.POLICY_NOPLAINTEXT} property with the value
     * {@code &quot;true&quot;}, then the selected
     * SASL mechanism must not be susceptible to simple plain passive attacks.
     * In addition to the standard properties declared in this class,
     * other, possibly mechanism-specific, properties can be included.
     * Properties not relevant to the selected mechanism are ignored,
     * including any map entries with non-String keys.
     *
     * @param cbh The possibly null callback handler to used by the SASL
     * mechanisms to get further information from the application/library
     * to complete the authentication. For example, a SASL mechanism might
     * require the authentication ID, password and realm from the caller.
     * The authentication ID is requested by using a {@code NameCallback}.
     * The password is requested by using a {@code PasswordCallback}.
     * The realm is requested by using a {@code RealmChoiceCallback} if there is a list
     * of realms to choose from, and by using a {@code RealmCallback} if
     * the realm must be entered.
     *
     *@return A possibly null {@code SaslClient} created using the parameters
     * supplied. If null, cannot find a {@code SaslClientFactory}
     * that will produce one.
     *@exception SaslException If cannot create a {@code SaslClient} because
     * of an error.
     */
    public static SaslClient createSaslClient(
        String[] mechanisms,
        String authorizationId,
        String protocol,
        String serverName,
        Map&lt;String,?&gt; props,
        CallbackHandler cbh) throws SaslException {

<span class="fc" id="L361">        SaslClient mech = null;</span>
        SaslClientFactory fac;
        String className;
        String mechName;

<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        for (int i = 0; i &lt; mechanisms.length; i++) {</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if ((mechName=mechanisms[i]) == null) {</span>
<span class="nc" id="L368">                throw new NullPointerException(</span>
                    &quot;Mechanism name cannot be null&quot;);
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            } else if (mechName.length() == 0) {</span>
<span class="nc" id="L371">                continue;</span>
            }
<span class="fc" id="L373">            String mechFilter = &quot;SaslClientFactory.&quot; + mechName;</span>
<span class="fc" id="L374">            Provider[] provs = Security.getProviders(mechFilter);</span>
<span class="pc bpc" id="L375" title="2 of 4 branches missed.">            for (int j = 0; provs != null &amp;&amp; j &lt; provs.length; j++) {</span>
<span class="fc" id="L376">                className = provs[j].getProperty(mechFilter);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">                if (className == null) {</span>
                    // Case is ignored
<span class="nc" id="L379">                    continue;</span>
                }

<span class="fc" id="L382">                fac = (SaslClientFactory) loadFactory(provs[j], className);</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">                if (fac != null) {</span>
<span class="fc" id="L384">                    mech = fac.createSaslClient(</span>
                        new String[]{mechanisms[i]}, authorizationId,
                        protocol, serverName, props, cbh);
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                    if (mech != null) {</span>
<span class="fc" id="L388">                        return mech;</span>
                    }
                }
            }
        }

<span class="nc" id="L394">        return null;</span>
    }

    private static Object loadFactory(Provider p, String className)
        throws SaslException {
        try {
            /*
             * Load the implementation class with the same class loader
             * that was used to load the provider.
             * In order to get the class loader of a class, the
             * caller's class loader must be the same as or an ancestor of
             * the class loader being returned. Otherwise, the caller must
             * have &quot;getClassLoader&quot; permission, or a SecurityException
             * will be thrown.
             */
<span class="fc" id="L409">            ClassLoader cl = p.getClass().getClassLoader();</span>
            Class&lt;?&gt; implClass;
<span class="fc" id="L411">            implClass = Class.forName(className, true, cl);</span>
<span class="fc" id="L412">            return implClass.newInstance();</span>
<span class="nc" id="L413">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L414">            throw new SaslException(&quot;Cannot load class &quot; + className, e);</span>
<span class="nc" id="L415">        } catch (InstantiationException e) {</span>
<span class="nc" id="L416">            throw new SaslException(&quot;Cannot instantiate class &quot; + className, e);</span>
<span class="nc" id="L417">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L418">            throw new SaslException(&quot;Cannot access class &quot; + className, e);</span>
<span class="nc" id="L419">        } catch (SecurityException e) {</span>
<span class="nc" id="L420">            throw new SaslException(&quot;Cannot access class &quot; + className, e);</span>
        }
    }


    /**
     * Creates a {@code SaslServer} for the specified mechanism.
     *
     * This method uses the
&lt;a href=&quot;{@docRoot}/../technotes/guides/security/crypto/CryptoSpec.html#Provider&quot;&gt;JCA Security Provider Framework&lt;/a&gt;,
     * described in the
     * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;, for
     * locating and selecting a {@code SaslServer} implementation.
     *
     * First, it
     * obtains an ordered list of {@code SaslServerFactory} instances from
     * the registered security providers for the &quot;SaslServerFactory&quot; service
     * and the specified mechanism. It then invokes
     * {@code createSaslServer()} on each factory instance on the list
     * until one produces a non-null {@code SaslServer} instance. It returns
     * the non-null {@code SaslServer} instance, or null if the search fails
     * to produce a non-null {@code SaslServer} instance.
     *&lt;p&gt;
     * A security provider for SaslServerFactory registers with the
     * JCA Security Provider Framework keys of the form &lt;br&gt;
     * {@code SaslServerFactory.}&lt;em&gt;{@code mechanism_name}&lt;/em&gt;
     * &lt;br&gt;
     * and values that are class names of implementations of
     * {@code javax.security.sasl.SaslServerFactory}.
     *
     * For example, a provider that contains a factory class,
     * {@code com.wiz.sasl.digest.ServerFactory}, that supports the
     * &quot;DIGEST-MD5&quot; mechanism would register the following entry with the JCA:
     * {@code SaslServerFactory.DIGEST-MD5  com.wiz.sasl.digest.ServerFactory}
     *&lt;p&gt;
     * See the
     * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;
     * for information about how to install and configure security
     * service providers.
     *
     * @param mechanism The non-null mechanism name. It must be an
     * IANA-registered name of a SASL mechanism. (e.g. &quot;GSSAPI&quot;, &quot;CRAM-MD5&quot;).
     * @param protocol The non-null string name of the protocol for which
     * the authentication is being performed (e.g., &quot;ldap&quot;).
     * @param serverName The fully qualified host name of the server, or null
     * if the server is not bound to any specific host name. If the mechanism
     * does not allow an unbound server, a {@code SaslException} will
     * be thrown.
     * @param props The possibly null set of properties used to
     * select the SASL mechanism and to configure the authentication
     * exchange of the selected mechanism.
     * For example, if {@code props} contains the
     * {@code Sasl.POLICY_NOPLAINTEXT} property with the value
     * {@code &quot;true&quot;}, then the selected
     * SASL mechanism must not be susceptible to simple plain passive attacks.
     * In addition to the standard properties declared in this class,
     * other, possibly mechanism-specific, properties can be included.
     * Properties not relevant to the selected mechanism are ignored,
     * including any map entries with non-String keys.
     *
     * @param cbh The possibly null callback handler to used by the SASL
     * mechanisms to get further information from the application/library
     * to complete the authentication. For example, a SASL mechanism might
     * require the authentication ID, password and realm from the caller.
     * The authentication ID is requested by using a {@code NameCallback}.
     * The password is requested by using a {@code PasswordCallback}.
     * The realm is requested by using a {@code RealmChoiceCallback} if there is a list
     * of realms to choose from, and by using a {@code RealmCallback} if
     * the realm must be entered.
     *
     *@return A possibly null {@code SaslServer} created using the parameters
     * supplied. If null, cannot find a {@code SaslServerFactory}
     * that will produce one.
     *@exception SaslException If cannot create a {@code SaslServer} because
     * of an error.
     **/
    public static SaslServer
        createSaslServer(String mechanism,
                    String protocol,
                    String serverName,
                    Map&lt;String,?&gt; props,
                    javax.security.auth.callback.CallbackHandler cbh)
        throws SaslException {

<span class="fc" id="L504">        SaslServer mech = null;</span>
        SaslServerFactory fac;
        String className;

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (mechanism == null) {</span>
<span class="nc" id="L509">            throw new NullPointerException(&quot;Mechanism name cannot be null&quot;);</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        } else if (mechanism.length() == 0) {</span>
<span class="nc" id="L511">            return null;</span>
        }

<span class="fc" id="L514">        String mechFilter = &quot;SaslServerFactory.&quot; + mechanism;</span>
<span class="fc" id="L515">        Provider[] provs = Security.getProviders(mechFilter);</span>
<span class="pc bpc" id="L516" title="2 of 4 branches missed.">        for (int j = 0; provs != null &amp;&amp; j &lt; provs.length; j++) {</span>
<span class="fc" id="L517">            className = provs[j].getProperty(mechFilter);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (className == null) {</span>
<span class="nc" id="L519">                throw new SaslException(&quot;Provider does not support &quot; +</span>
                    mechFilter);
            }
<span class="fc" id="L522">            fac = (SaslServerFactory) loadFactory(provs[j], className);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            if (fac != null) {</span>
<span class="fc" id="L524">                mech = fac.createSaslServer(</span>
                    mechanism, protocol, serverName, props, cbh);
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                if (mech != null) {</span>
<span class="fc" id="L527">                    return mech;</span>
                }
            }
        }

<span class="nc" id="L532">        return null;</span>
    }

    /**
     * Gets an enumeration of known factories for producing {@code SaslClient}.
     * This method uses the same algorithm for locating factories as
     * {@code createSaslClient()}.
     * @return A non-null enumeration of known factories for producing
     * {@code SaslClient}.
     * @see #createSaslClient
     */
    public static Enumeration&lt;SaslClientFactory&gt; getSaslClientFactories() {
<span class="nc" id="L544">        Set&lt;Object&gt; facs = getFactories(&quot;SaslClientFactory&quot;);</span>
<span class="nc" id="L545">        final Iterator&lt;Object&gt; iter = facs.iterator();</span>
<span class="nc" id="L546">        return new Enumeration&lt;SaslClientFactory&gt;() {</span>
            public boolean hasMoreElements() {
<span class="nc" id="L548">                return iter.hasNext();</span>
            }
            public SaslClientFactory nextElement() {
<span class="nc" id="L551">                return (SaslClientFactory)iter.next();</span>
            }
        };
    }

    /**
     * Gets an enumeration of known factories for producing {@code SaslServer}.
     * This method uses the same algorithm for locating factories as
     * {@code createSaslServer()}.
     * @return A non-null enumeration of known factories for producing
     * {@code SaslServer}.
     * @see #createSaslServer
     */
    public static Enumeration&lt;SaslServerFactory&gt; getSaslServerFactories() {
<span class="nc" id="L565">        Set&lt;Object&gt; facs = getFactories(&quot;SaslServerFactory&quot;);</span>
<span class="nc" id="L566">        final Iterator&lt;Object&gt; iter = facs.iterator();</span>
<span class="nc" id="L567">        return new Enumeration&lt;SaslServerFactory&gt;() {</span>
            public boolean hasMoreElements() {
<span class="nc" id="L569">                return iter.hasNext();</span>
            }
            public SaslServerFactory nextElement() {
<span class="nc" id="L572">                return (SaslServerFactory)iter.next();</span>
            }
        };
    }

    private static Set&lt;Object&gt; getFactories(String serviceName) {
<span class="nc" id="L578">        HashSet&lt;Object&gt; result = new HashSet&lt;Object&gt;();</span>

<span class="nc bnc" id="L580" title="All 4 branches missed.">        if ((serviceName == null) || (serviceName.length() == 0) ||</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            (serviceName.endsWith(&quot;.&quot;))) {</span>
<span class="nc" id="L582">            return result;</span>
        }


<span class="nc" id="L586">        Provider[] providers = Security.getProviders();</span>
<span class="nc" id="L587">        HashSet&lt;String&gt; classes = new HashSet&lt;String&gt;();</span>
        Object fac;

<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (int i = 0; i &lt; providers.length; i++) {</span>
<span class="nc" id="L591">            classes.clear();</span>

            // Check the keys for each provider.
<span class="nc bnc" id="L594" title="All 2 branches missed.">            for (Enumeration&lt;Object&gt; e = providers[i].keys(); e.hasMoreElements(); ) {</span>
<span class="nc" id="L595">                String currentKey = (String)e.nextElement();</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                if (currentKey.startsWith(serviceName)) {</span>
                    // We should skip the currentKey if it contains a
                    // whitespace. The reason is: such an entry in the
                    // provider property contains attributes for the
                    // implementation of an algorithm. We are only interested
                    // in entries which lead to the implementation
                    // classes.
<span class="nc bnc" id="L603" title="All 2 branches missed.">                    if (currentKey.indexOf(&quot; &quot;) &lt; 0) {</span>
<span class="nc" id="L604">                        String className = providers[i].getProperty(currentKey);</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                        if (!classes.contains(className)) {</span>
<span class="nc" id="L606">                            classes.add(className);</span>
                            try {
<span class="nc" id="L608">                                fac = loadFactory(providers[i], className);</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                                if (fac != null) {</span>
<span class="nc" id="L610">                                    result.add(fac);</span>
                                }
<span class="nc" id="L612">                            }catch (Exception ignore) {</span>
<span class="nc" id="L613">                            }</span>
                        }
                    }
                }
<span class="nc" id="L617">            }</span>
        }
<span class="nc" id="L619">        return Collections.unmodifiableSet(result);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>