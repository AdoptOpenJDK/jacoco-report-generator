<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DrawImage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">DrawImage.java</span></div><h1>DrawImage.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Image;
import java.awt.Transparency;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.ImageObserver;
import java.awt.image.IndexColorModel;
import java.awt.image.Raster;
import java.awt.image.VolatileImage;
import sun.awt.SunHints;
import sun.awt.image.ImageRepresentation;
import sun.awt.image.SurfaceManager;
import sun.awt.image.ToolkitImage;
import sun.java2d.InvalidPipeException;
import sun.java2d.SunGraphics2D;
import sun.java2d.SurfaceData;
import sun.java2d.loops.Blit;
import sun.java2d.loops.BlitBg;
import sun.java2d.loops.TransformHelper;
import sun.java2d.loops.MaskBlit;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.ScaledBlit;
import sun.java2d.loops.SurfaceType;

<span class="nc" id="L58">public class DrawImage implements DrawImagePipe</span>
{
    public boolean copyImage(SunGraphics2D sg, Image img,
                             int x, int y,
                             Color bgColor)
    {
<span class="nc" id="L64">        int imgw = img.getWidth(null);</span>
<span class="nc" id="L65">        int imgh = img.getHeight(null);</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (isSimpleTranslate(sg)) {</span>
<span class="nc" id="L67">            return renderImageCopy(sg, img, bgColor,</span>
                                   x + sg.transX, y + sg.transY,
                                   0, 0, imgw, imgh);
        }
<span class="nc" id="L71">        AffineTransform atfm = sg.transform;</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">        if ((x | y) != 0) {</span>
<span class="nc" id="L73">            atfm = new AffineTransform(atfm);</span>
<span class="nc" id="L74">            atfm.translate(x, y);</span>
        }
<span class="nc" id="L76">        transformImage(sg, img, atfm, sg.interpolationType,</span>
                       0, 0, imgw, imgh, bgColor);
<span class="nc" id="L78">        return true;</span>
    }

    public boolean copyImage(SunGraphics2D sg, Image img,
                             int dx, int dy, int sx, int sy, int w, int h,
                             Color bgColor)
    {
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (isSimpleTranslate(sg)) {</span>
<span class="nc" id="L86">            return renderImageCopy(sg, img, bgColor,</span>
                                   dx + sg.transX, dy + sg.transY,
                                   sx, sy, w, h);
        }
<span class="nc" id="L90">        scaleImage(sg, img, dx, dy, (dx + w), (dy + h),</span>
                   sx, sy, (sx + w), (sy + h), bgColor);
<span class="nc" id="L92">        return true;</span>
    }

    public boolean scaleImage(SunGraphics2D sg, Image img, int x, int y,
                              int width, int height,
                              Color bgColor)
    {
<span class="nc" id="L99">        int imgw = img.getWidth(null);</span>
<span class="nc" id="L100">        int imgh = img.getHeight(null);</span>
        // Only accelerate scale if:
        //          - w/h positive values
        //          - sg transform integer translate/identity only
        //          - no bgColor in operation
<span class="nc bnc" id="L105" title="All 6 branches missed.">        if ((width &gt; 0) &amp;&amp; (height &gt; 0) &amp;&amp; isSimpleTranslate(sg)) {</span>
<span class="nc" id="L106">            double dx1 = x + sg.transX;</span>
<span class="nc" id="L107">            double dy1 = y + sg.transY;</span>
<span class="nc" id="L108">            double dx2 = dx1 + width;</span>
<span class="nc" id="L109">            double dy2 = dy1 + height;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (renderImageScale(sg, img, bgColor, sg.interpolationType,</span>
                                 0, 0, imgw, imgh,
                                 dx1, dy1, dx2, dy2))
            {
<span class="nc" id="L114">                return true;</span>
            }
        }

<span class="nc" id="L118">        AffineTransform atfm = sg.transform;</span>
<span class="nc bnc" id="L119" title="All 6 branches missed.">        if ((x | y) != 0 || width != imgw || height != imgh) {</span>
<span class="nc" id="L120">            atfm = new AffineTransform(atfm);</span>
<span class="nc" id="L121">            atfm.translate(x, y);</span>
<span class="nc" id="L122">            atfm.scale(((double)width)/imgw, ((double)height)/imgh);</span>
        }
<span class="nc" id="L124">        transformImage(sg, img, atfm, sg.interpolationType,</span>
                       0, 0, imgw, imgh, bgColor);
<span class="nc" id="L126">        return true;</span>
    }

    /*
     * This method is only called in those circumstances where the
     * operation has a non-null secondary transform specified.  Its
     * role is to check for various optimizations based on the types
     * of both the secondary and SG2D transforms and to do some
     * quick calculations to avoid having to combine the transforms
     * and/or to call a more generalized method.
     */
    protected void transformImage(SunGraphics2D sg, Image img, int x, int y,
                                  AffineTransform extraAT, int interpType)
    {
<span class="nc" id="L140">        int txtype = extraAT.getType();</span>
<span class="nc" id="L141">        int imgw = img.getWidth(null);</span>
<span class="nc" id="L142">        int imgh = img.getHeight(null);</span>
        boolean checkfinalxform;

<span class="nc bnc" id="L145" title="All 6 branches missed.">        if (sg.transformState &lt;= SunGraphics2D.TRANSFORM_ANY_TRANSLATE &amp;&amp;</span>
            (txtype == AffineTransform.TYPE_IDENTITY ||
             txtype == AffineTransform.TYPE_TRANSLATION))
        {
            // First optimization - both are some kind of translate

            // Combine the translations and check if interpolation is necessary.
<span class="nc" id="L152">            double tx = extraAT.getTranslateX();</span>
<span class="nc" id="L153">            double ty = extraAT.getTranslateY();</span>
<span class="nc" id="L154">            tx += sg.transform.getTranslateX();</span>
<span class="nc" id="L155">            ty += sg.transform.getTranslateY();</span>
<span class="nc" id="L156">            int itx = (int) Math.floor(tx + 0.5);</span>
<span class="nc" id="L157">            int ity = (int) Math.floor(ty + 0.5);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (interpType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR ||</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">                (closeToInteger(itx, tx) &amp;&amp; closeToInteger(ity, ty)))</span>
            {
<span class="nc" id="L161">                renderImageCopy(sg, img, null, x+itx, y+ity, 0, 0, imgw, imgh);</span>
<span class="nc" id="L162">                return;</span>
            }
<span class="nc" id="L164">            checkfinalxform = false;</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">        } else if (sg.transformState &lt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE &amp;&amp;</span>
                   ((txtype &amp; (AffineTransform.TYPE_FLIP |
                               AffineTransform.TYPE_MASK_ROTATION |
                               AffineTransform.TYPE_GENERAL_TRANSFORM)) == 0))
        {
            // Second optimization - both are some kind of translate or scale

            // Combine the scales and check if interpolation is necessary.

            // Transform source bounds by extraAT,
            // then translate the bounds again by x, y
            // then transform the bounds again by sg.transform
<span class="nc" id="L177">            double coords[] = new double[] {</span>
                0, 0, imgw, imgh,
            };
<span class="nc" id="L180">            extraAT.transform(coords, 0, coords, 0, 2);</span>
<span class="nc" id="L181">            coords[0] += x;</span>
<span class="nc" id="L182">            coords[1] += y;</span>
<span class="nc" id="L183">            coords[2] += x;</span>
<span class="nc" id="L184">            coords[3] += y;</span>
<span class="nc" id="L185">            sg.transform.transform(coords, 0, coords, 0, 2);</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (tryCopyOrScale(sg, img, 0, 0, imgw, imgh,</span>
                               null, interpType, coords))
            {
<span class="nc" id="L190">                return;</span>
            }
<span class="nc" id="L192">            checkfinalxform = false;</span>
<span class="nc" id="L193">        } else {</span>
<span class="nc" id="L194">            checkfinalxform = true;</span>
        }

        // Begin Transform
<span class="nc" id="L198">        AffineTransform tx = new AffineTransform(sg.transform);</span>
<span class="nc" id="L199">        tx.translate(x, y);</span>
<span class="nc" id="L200">        tx.concatenate(extraAT);</span>

        // Do not try any more optimizations if either of the cases
        // above was tried as we have already verified that the
        // resulting transform will not simplify.
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (checkfinalxform) {</span>
            // In this case neither of the above simple transform
            // pairs was found so we will do some final tests on
            // the final rendering transform which may be the
            // simple product of two complex transforms.
<span class="nc" id="L210">            transformImage(sg, img, tx, interpType, 0, 0, imgw, imgh, null);</span>
        } else {
<span class="nc" id="L212">            renderImageXform(sg, img, tx, interpType, 0, 0, imgw, imgh, null);</span>
        }
<span class="nc" id="L214">    }</span>

    /*
     * This method is called with a final rendering transform that
     * has combined all of the information about the Graphics2D
     * transform attribute with the transformations specified by
     * the arguments to the drawImage call.
     * Its role is to see if the combined transform ends up being
     * acceleratable by either a renderImageCopy or renderImageScale
     * once all of the math is done.
     *
     * Note: The transform supplied here has an origin that is
     * already adjusted to point to the device location where
     * the (sx1, sy1) location of the source image should be placed.
     */
    protected void transformImage(SunGraphics2D sg, Image img,
                                  AffineTransform tx, int interpType,
                                  int sx1, int sy1, int sx2, int sy2,
                                  Color bgColor)
    {
        // Transform 3 source corners by tx and analyze them
        // for simplified operations (Copy or Scale).  Using
        // 3 points lets us analyze any kind of transform,
        // even transforms that involve very tiny amounts of
        // rotation or skew to see if they degenerate to a
        // simple scale or copy operation within the allowable
        // error bounds.
        // Note that we use (0,0,w,h) instead of (sx1,sy1,sx2,sy2)
        // because the transform is already translated such that
        // the origin is where sx1, sy1 should go.
<span class="nc" id="L244">        double coords[] = new double[6];</span>
        /* index:  0  1    2  3    4  5  */
        /* coord: (0, 0), (w, h), (0, h) */
<span class="nc" id="L247">        coords[2] = sx2 - sx1;</span>
<span class="nc" id="L248">        coords[3] = coords[5] = sy2 - sy1;</span>
<span class="nc" id="L249">        tx.transform(coords, 0, coords, 0, 3);</span>
        // First test if the X coords of the transformed UL
        // and LL points match and that the Y coords of the
        // transformed LR and LL points also match.
        // If they do then it is a &quot;rectilinear&quot; transform and
        // tryCopyOrScale will make sure it is upright and
        // integer-based.
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (Math.abs(coords[0] - coords[4]) &lt; MAX_TX_ERROR &amp;&amp;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            Math.abs(coords[3] - coords[5]) &lt; MAX_TX_ERROR &amp;&amp;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">            tryCopyOrScale(sg, img, sx1, sy1, sx2, sy2,</span>
                           bgColor, interpType, coords))
        {
<span class="nc" id="L261">            return;</span>
        }

<span class="nc" id="L264">        renderImageXform(sg, img, tx, interpType, sx1, sy1, sx2, sy2, bgColor);</span>
<span class="nc" id="L265">    }</span>

    /*
     * Check the bounding coordinates of the transformed source
     * image to see if they fall on integer coordinates such
     * that they will cause no interpolation anomalies if we
     * use our simplified Blit or ScaledBlit operations instead
     * of a full transform operation.
     */
    protected boolean tryCopyOrScale(SunGraphics2D sg,
                                     Image img,
                                     int sx1, int sy1,
                                     int sx2, int sy2,
                                     Color bgColor, int interpType,
                                     double coords[])
    {
<span class="nc" id="L281">        double dx = coords[0];</span>
<span class="nc" id="L282">        double dy = coords[1];</span>
<span class="nc" id="L283">        double dw = coords[2] - dx;</span>
<span class="nc" id="L284">        double dh = coords[3] - dy;</span>
        // First check if width and height are very close to img w&amp;h.
<span class="nc bnc" id="L286" title="All 4 branches missed.">        if (closeToInteger(sx2-sx1, dw) &amp;&amp; closeToInteger(sy2-sy1, dh)) {</span>
            // Round location to nearest pixel and then test
            // if it will cause interpolation anomalies.
<span class="nc" id="L289">            int idx = (int) Math.floor(dx + 0.5);</span>
<span class="nc" id="L290">            int idy = (int) Math.floor(dy + 0.5);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (interpType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR ||</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">                (closeToInteger(idx, dx) &amp;&amp; closeToInteger(idy, dy)))</span>
            {
<span class="nc" id="L294">                renderImageCopy(sg, img, bgColor,</span>
                                idx, idy,
                                sx1, sy1, sx2-sx1, sy2-sy1);
<span class="nc" id="L297">                return true;</span>
            }
        }
        // (For now) We can only use our ScaledBlits if the image
        // is upright (i.e. dw &amp; dh both &gt; 0)
<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (dw &gt; 0 &amp;&amp; dh &gt; 0) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (renderImageScale(sg, img, bgColor, interpType,</span>
                                 sx1, sy1, sx2, sy2,
                                 coords[0], coords[1], coords[2], coords[3]))
            {
<span class="nc" id="L307">                return true;</span>
            }
        }
<span class="nc" id="L310">        return false;</span>
    }

    /*
     * Return a BufferedImage of the requested type with the indicated
     * subimage of the original image located at 0,0 in the new image.
     * If a bgColor is supplied, composite the original image over that
     * color with a SrcOver operation, otherwise make a SrcNoEa copy.
     */
    BufferedImage makeBufferedImage(Image img, Color bgColor, int type,
                                    int sx1, int sy1, int sx2, int sy2)
    {
<span class="nc" id="L322">        final int width = sx2 - sx1;</span>
<span class="nc" id="L323">        final int height = sy2 - sy1;</span>
<span class="nc" id="L324">        final BufferedImage bimg = new BufferedImage(width, height, type);</span>
<span class="nc" id="L325">        final SunGraphics2D g2d = (SunGraphics2D) bimg.createGraphics();</span>
<span class="nc" id="L326">        g2d.setComposite(AlphaComposite.Src);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (bgColor != null) {</span>
<span class="nc" id="L328">            g2d.setColor(bgColor);</span>
<span class="nc" id="L329">            g2d.fillRect(0, 0, width, height);</span>
<span class="nc" id="L330">            g2d.setComposite(AlphaComposite.SrcOver);</span>
        }
<span class="nc" id="L332">        g2d.copyImage(img, 0, 0, sx1, sy1, width, height, null, null);</span>
<span class="nc" id="L333">        g2d.dispose();</span>
<span class="nc" id="L334">        return bimg;</span>
    }

    protected void renderImageXform(SunGraphics2D sg, Image img,
                                    AffineTransform tx, int interpType,
                                    int sx1, int sy1, int sx2, int sy2,
                                    Color bgColor)
    {
<span class="nc" id="L342">        Region clip = sg.getCompClip();</span>
<span class="nc" id="L343">        SurfaceData dstData = sg.surfaceData;</span>
<span class="nc" id="L344">        SurfaceData srcData = dstData.getSourceSurfaceData(img,</span>
                                                           SunGraphics2D.TRANSFORM_GENERIC,
                                                           sg.imageComp,
                                                           bgColor);

<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (srcData == null) {</span>
<span class="nc" id="L350">            img = getBufferedImage(img);</span>
<span class="nc" id="L351">            srcData = dstData.getSourceSurfaceData(img,</span>
                                                   SunGraphics2D.TRANSFORM_GENERIC,
                                                   sg.imageComp,
                                                   bgColor);
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (srcData == null) {</span>
                // REMIND: Is this correct?  Can this happen?
<span class="nc" id="L357">                return;</span>
            }
        }

<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (isBgOperation(srcData, bgColor)) {</span>
            // We cannot perform bg operations during transform so make
            // an opaque temp image with the appropriate background
            // and work from there.
<span class="nc" id="L365">            img = makeBufferedImage(img, bgColor, BufferedImage.TYPE_INT_RGB,</span>
                                    sx1, sy1, sx2, sy2);
            // Temp image has appropriate subimage at 0,0 now.
<span class="nc" id="L368">            sx2 -= sx1;</span>
<span class="nc" id="L369">            sy2 -= sy1;</span>
<span class="nc" id="L370">            sx1 = sy1 = 0;</span>

<span class="nc" id="L372">            srcData = dstData.getSourceSurfaceData(img,</span>
                                                   SunGraphics2D.TRANSFORM_GENERIC,
                                                   sg.imageComp,
                                                   bgColor);
        }

<span class="nc" id="L378">        SurfaceType srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L379">        TransformHelper helper = TransformHelper.getFromCache(srcType);</span>

<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (helper == null) {</span>
            /* We have no helper for this source image type.
             * But we know that we do have helpers for both RGB and ARGB,
             * so convert to one of those types depending on transparency.
             * ARGB_PRE might be a better choice if the source image has
             * alpha, but it may cause some recursion here since we only
             * tend to have converters that convert to ARGB.
             */
<span class="nc bnc" id="L389" title="All 2 branches missed.">            int type = ((srcData.getTransparency() == Transparency.OPAQUE)</span>
                        ? BufferedImage.TYPE_INT_RGB
                        : BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L392">            img = makeBufferedImage(img, null, type, sx1, sy1, sx2, sy2);</span>
            // Temp image has appropriate subimage at 0,0 now.
<span class="nc" id="L394">            sx2 -= sx1;</span>
<span class="nc" id="L395">            sy2 -= sy1;</span>
<span class="nc" id="L396">            sx1 = sy1 = 0;</span>

<span class="nc" id="L398">            srcData = dstData.getSourceSurfaceData(img,</span>
                                                   SunGraphics2D.TRANSFORM_GENERIC,
                                                   sg.imageComp,
                                                   null);
<span class="nc" id="L402">            srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L403">            helper = TransformHelper.getFromCache(srcType);</span>
            // assert(helper != null);
        }

        AffineTransform itx;
        try {
<span class="nc" id="L409">            itx = tx.createInverse();</span>
<span class="nc" id="L410">        } catch (NoninvertibleTransformException e) {</span>
            // Non-invertible transform means no output
<span class="nc" id="L412">            return;</span>
<span class="nc" id="L413">        }</span>

        /*
         * Find the maximum bounds on the destination that will be
         * affected by the transformed source.  First, transform all
         * four corners of the source and then min and max the resulting
         * destination coordinates of the transformed corners.
         * Note that tx already has the offset to sx1,sy1 accounted
         * for so we use the box (0, 0, sx2-sx1, sy2-sy1) as the
         * source coordinates.
         */
<span class="nc" id="L424">        double coords[] = new double[8];</span>
        /* corner:  UL      UR      LL      LR   */
        /* index:  0  1    2  3    4  5    6  7  */
        /* coord: (0, 0), (w, 0), (0, h), (w, h) */
<span class="nc" id="L428">        coords[2] = coords[6] = sx2 - sx1;</span>
<span class="nc" id="L429">        coords[5] = coords[7] = sy2 - sy1;</span>
<span class="nc" id="L430">        tx.transform(coords, 0, coords, 0, 4);</span>
        double ddx1, ddy1, ddx2, ddy2;
<span class="nc" id="L432">        ddx1 = ddx2 = coords[0];</span>
<span class="nc" id="L433">        ddy1 = ddy2 = coords[1];</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        for (int i = 2; i &lt; coords.length; i += 2) {</span>
<span class="nc" id="L435">            double d = coords[i];</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (ddx1 &gt; d) ddx1 = d;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">            else if (ddx2 &lt; d) ddx2 = d;</span>
<span class="nc" id="L438">            d = coords[i+1];</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (ddy1 &gt; d) ddy1 = d;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">            else if (ddy2 &lt; d) ddy2 = d;</span>
        }
<span class="nc" id="L442">        int dx1 = (int) Math.floor(ddx1);</span>
<span class="nc" id="L443">        int dy1 = (int) Math.floor(ddy1);</span>
<span class="nc" id="L444">        int dx2 = (int) Math.ceil(ddx2);</span>
<span class="nc" id="L445">        int dy2 = (int) Math.ceil(ddy2);</span>

<span class="nc" id="L447">        SurfaceType dstType = dstData.getSurfaceType();</span>
        MaskBlit maskblit;
        Blit blit;
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (sg.compositeState &lt;= SunGraphics2D.COMP_ALPHA) {</span>
            /* NOTE: We either have, or we can make,
             * a MaskBlit for any alpha composite type
             */
<span class="nc" id="L454">            maskblit = MaskBlit.getFromCache(SurfaceType.IntArgbPre,</span>
                                             sg.imageComp,
                                             dstType);

            /* NOTE: We can only use the native TransformHelper
             * func to go directly to the dest if both the helper
             * and the MaskBlit are native.
             * All helpers are native at this point, but some MaskBlit
             * objects are implemented in Java, so we need to check.
             */
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (maskblit.getNativePrim() != 0) {</span>
                // We can render directly.
<span class="nc" id="L466">                helper.Transform(maskblit, srcData, dstData,</span>
                                 sg.composite, clip,
                                 itx, interpType,
                                 sx1, sy1, sx2, sy2,
                                 dx1, dy1, dx2, dy2,
                                 null, 0, 0);
<span class="nc" id="L472">                return;</span>
            }
<span class="nc" id="L474">            blit = null;</span>
        } else {
            /* NOTE: We either have, or we can make,
             * a Blit for any composite type, even Custom
             */
<span class="nc" id="L479">            maskblit = null;</span>
<span class="nc" id="L480">            blit = Blit.getFromCache(SurfaceType.IntArgbPre,</span>
                                     sg.imageComp,
                                     dstType);
        }

        // We need to transform to a temp image and then copy
        // just the pieces that are valid data to the dest.
<span class="nc" id="L487">        BufferedImage tmpimg = new BufferedImage(dx2-dx1, dy2-dy1,</span>
                                                 BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L489">        SurfaceData tmpData = SurfaceData.getPrimarySurfaceData(tmpimg);</span>
<span class="nc" id="L490">        SurfaceType tmpType = tmpData.getSurfaceType();</span>
<span class="nc" id="L491">        MaskBlit tmpmaskblit =</span>
<span class="nc" id="L492">            MaskBlit.getFromCache(SurfaceType.IntArgbPre,</span>
                                  CompositeType.SrcNoEa,
                                  tmpType);
        /*
         * The helper function fills a temporary edges buffer
         * for us with the bounding coordinates of each scanline
         * in the following format:
         *
         * edges[0, 1] = [top y, bottom y)
         * edges[2, 3] = [left x, right x) of top row
         * ...
         * edges[h*2, h*2+1] = [left x, right x) of bottom row
         *
         * all coordinates in the edges array will be relative to dx1, dy1
         *
         * edges thus has to be h*2+2 in length
         */
<span class="nc" id="L509">        int edges[] = new int[(dy2-dy1)*2+2];</span>
        // It is important that edges[0]=edges[1]=0 when we call
        // Transform in case it must return early and we would
        // not want to render anything on an error condition.
<span class="nc" id="L513">        helper.Transform(tmpmaskblit, srcData, tmpData,</span>
                         AlphaComposite.Src, null,
                         itx, interpType,
                         sx1, sy1, sx2, sy2,
                         0, 0, dx2-dx1, dy2-dy1,
                         edges, dx1, dy1);

        /*
         * Now copy the results, scanline by scanline, into the dest.
         * The edges array helps us minimize the work.
         */
<span class="nc" id="L524">        int index = 2;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int y = edges[0]; y &lt; edges[1]; y++) {</span>
<span class="nc" id="L526">            int relx1 = edges[index++];</span>
<span class="nc" id="L527">            int relx2 = edges[index++];</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">            if (relx1 &gt;= relx2) {</span>
<span class="nc" id="L529">                continue;</span>
            }
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (maskblit != null) {</span>
<span class="nc" id="L532">                maskblit.MaskBlit(tmpData, dstData,</span>
                                  sg.composite, clip,
                                  relx1, y,
                                  dx1+relx1, dy1+y,
                                  relx2 - relx1, 1,
                                  null, 0, 0);
            } else {
<span class="nc" id="L539">                blit.Blit(tmpData, dstData,</span>
                          sg.composite, clip,
                          relx1, y,
                          dx1+relx1, dy1+y,
                          relx2 - relx1, 1);
            }
        }
<span class="nc" id="L546">    }</span>

    // Render an image using only integer translation
    // (no scale or transform or sub-pixel interpolated translations).
    protected boolean renderImageCopy(SunGraphics2D sg, Image img,
                                      Color bgColor,
                                      int dx, int dy,
                                      int sx, int sy,
                                      int w, int h)
    {
<span class="nc" id="L556">        Region clip = sg.getCompClip();</span>
<span class="nc" id="L557">        SurfaceData dstData = sg.surfaceData;</span>

<span class="nc" id="L559">        int attempts = 0;</span>
        // Loop up to twice through; this gives us a chance to
        // revalidate the surfaceData objects in case of an exception
        // and try it once more
        while (true) {
<span class="nc" id="L564">            SurfaceData srcData =</span>
<span class="nc" id="L565">                dstData.getSourceSurfaceData(img,</span>
                                             SunGraphics2D.TRANSFORM_ISIDENT,
                                             sg.imageComp,
                                             bgColor);
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (srcData == null) {</span>
<span class="nc" id="L570">                return false;</span>
            }

            try {
<span class="nc" id="L574">                SurfaceType srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L575">                SurfaceType dstType = dstData.getSurfaceType();</span>
<span class="nc" id="L576">                blitSurfaceData(sg, clip,</span>
                                srcData, dstData, srcType, dstType,
                                sx, sy, dx, dy, w, h, bgColor);
<span class="nc" id="L579">                return true;</span>
<span class="nc" id="L580">            } catch (NullPointerException e) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                if (!(SurfaceData.isNull(dstData) ||</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                      SurfaceData.isNull(srcData)))</span>
                {
                    // Something else caused the exception, throw it...
<span class="nc" id="L585">                    throw e;</span>
                }
<span class="nc" id="L587">                return false;</span>
                // NOP if we have been disposed
<span class="nc" id="L589">            } catch (InvalidPipeException e) {</span>
                // Always catch the exception; try this a couple of times
                // and fail silently if the system is not yet ready to
                // revalidate the source or dest surfaceData objects.
<span class="nc" id="L593">                ++attempts;</span>
<span class="nc" id="L594">                clip = sg.getCompClip();   // ensures sg.surfaceData is valid</span>
<span class="nc" id="L595">                dstData = sg.surfaceData;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                if (SurfaceData.isNull(dstData) ||</span>
<span class="nc bnc" id="L597" title="All 4 branches missed.">                    SurfaceData.isNull(srcData) || (attempts &gt; 1))</span>
                {
<span class="nc" id="L599">                    return false;</span>
                }
            }
<span class="nc" id="L602">        }</span>
    }

    // Render an image using only integer scaling (no transform).
    protected boolean renderImageScale(SunGraphics2D sg, Image img,
                                       Color bgColor, int interpType,
                                       int sx1, int sy1,
                                       int sx2, int sy2,
                                       double dx1, double dy1,
                                       double dx2, double dy2)
    {
        // Currently only NEAREST_NEIGHBOR interpolation is implemented
        // for ScaledBlit operations.
<span class="nc bnc" id="L615" title="All 2 branches missed.">        if (interpType != AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {</span>
<span class="nc" id="L616">            return false;</span>
        }

<span class="nc" id="L619">        Region clip = sg.getCompClip();</span>
<span class="nc" id="L620">        SurfaceData dstData = sg.surfaceData;</span>

<span class="nc" id="L622">        int attempts = 0;</span>
        // Loop up to twice through; this gives us a chance to
        // revalidate the surfaceData objects in case of an exception
        // and try it once more
        while (true) {
<span class="nc" id="L627">            SurfaceData srcData =</span>
<span class="nc" id="L628">                dstData.getSourceSurfaceData(img,</span>
                                             SunGraphics2D.TRANSFORM_TRANSLATESCALE,
                                             sg.imageComp,
                                             bgColor);

<span class="nc bnc" id="L633" title="All 4 branches missed.">            if (srcData == null || isBgOperation(srcData, bgColor)) {</span>
<span class="nc" id="L634">                return false;</span>
            }

            try {
<span class="nc" id="L638">                SurfaceType srcType = srcData.getSurfaceType();</span>
<span class="nc" id="L639">                SurfaceType dstType = dstData.getSurfaceType();</span>
<span class="nc" id="L640">                return scaleSurfaceData(sg, clip,</span>
                                        srcData, dstData, srcType, dstType,
                                        sx1, sy1, sx2, sy2,
                                        dx1, dy1, dx2, dy2);
<span class="nc" id="L644">            } catch (NullPointerException e) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                if (!SurfaceData.isNull(dstData)) {</span>
                    // Something else caused the exception, throw it...
<span class="nc" id="L647">                    throw e;</span>
                }
<span class="nc" id="L649">                return false;</span>
                // NOP if we have been disposed
<span class="nc" id="L651">            } catch (InvalidPipeException e) {</span>
                // Always catch the exception; try this a couple of times
                // and fail silently if the system is not yet ready to
                // revalidate the source or dest surfaceData objects.
<span class="nc" id="L655">                ++attempts;</span>
<span class="nc" id="L656">                clip = sg.getCompClip();  // ensures sg.surfaceData is valid</span>
<span class="nc" id="L657">                dstData = sg.surfaceData;</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">                if (SurfaceData.isNull(dstData) ||</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">                    SurfaceData.isNull(srcData) || (attempts &gt; 1))</span>
                {
<span class="nc" id="L661">                    return false;</span>
                }
            }
<span class="nc" id="L664">        }</span>
    }

    public boolean scaleImage(SunGraphics2D sg, Image img,
                              int dx1, int dy1, int dx2, int dy2,
                              int sx1, int sy1, int sx2, int sy2,
                              Color bgColor)
    {
        int srcW, srcH, dstW, dstH;
        int srcX, srcY, dstX, dstY;
<span class="nc" id="L674">        boolean srcWidthFlip = false;</span>
<span class="nc" id="L675">        boolean srcHeightFlip = false;</span>
<span class="nc" id="L676">        boolean dstWidthFlip = false;</span>
<span class="nc" id="L677">        boolean dstHeightFlip = false;</span>

<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (sx2 &gt; sx1) {</span>
<span class="nc" id="L680">            srcW = sx2 - sx1;</span>
<span class="nc" id="L681">            srcX = sx1;</span>
        } else {
<span class="nc" id="L683">            srcWidthFlip = true;</span>
<span class="nc" id="L684">            srcW = sx1 - sx2;</span>
<span class="nc" id="L685">            srcX = sx2;</span>
        }
<span class="nc bnc" id="L687" title="All 2 branches missed.">        if (sy2 &gt; sy1) {</span>
<span class="nc" id="L688">            srcH = sy2-sy1;</span>
<span class="nc" id="L689">            srcY = sy1;</span>
        } else {
<span class="nc" id="L691">            srcHeightFlip = true;</span>
<span class="nc" id="L692">            srcH = sy1-sy2;</span>
<span class="nc" id="L693">            srcY = sy2;</span>
        }
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (dx2 &gt; dx1) {</span>
<span class="nc" id="L696">            dstW = dx2 - dx1;</span>
<span class="nc" id="L697">            dstX = dx1;</span>
        } else {
<span class="nc" id="L699">            dstW = dx1 - dx2;</span>
<span class="nc" id="L700">            dstWidthFlip = true;</span>
<span class="nc" id="L701">            dstX = dx2;</span>
        }
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (dy2 &gt; dy1) {</span>
<span class="nc" id="L704">            dstH = dy2 - dy1;</span>
<span class="nc" id="L705">            dstY = dy1;</span>
        } else {
<span class="nc" id="L707">            dstH = dy1 - dy2;</span>
<span class="nc" id="L708">            dstHeightFlip = true;</span>
<span class="nc" id="L709">            dstY = dy2;</span>
        }
<span class="nc bnc" id="L711" title="All 4 branches missed.">        if (srcW &lt;= 0 || srcH &lt;= 0) {</span>
<span class="nc" id="L712">            return true;</span>
        }
        // Only accelerate scale if it does not involve a flip or transform
<span class="nc bnc" id="L715" title="All 4 branches missed.">        if ((srcWidthFlip == dstWidthFlip) &amp;&amp;</span>
            (srcHeightFlip == dstHeightFlip) &amp;&amp;
<span class="nc bnc" id="L717" title="All 2 branches missed.">            isSimpleTranslate(sg))</span>
        {
<span class="nc" id="L719">            double ddx1 = dstX + sg.transX;</span>
<span class="nc" id="L720">            double ddy1 = dstY + sg.transY;</span>
<span class="nc" id="L721">            double ddx2 = ddx1 + dstW;</span>
<span class="nc" id="L722">            double ddy2 = ddy1 + dstH;</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (renderImageScale(sg, img, bgColor, sg.interpolationType,</span>
                                 srcX, srcY, srcX+srcW, srcY+srcH,
                                 ddx1, ddy1, ddx2, ddy2))
            {
<span class="nc" id="L727">                return true;</span>
            }
        }

<span class="nc" id="L731">        AffineTransform atfm = new AffineTransform(sg.transform);</span>
<span class="nc" id="L732">        atfm.translate(dx1, dy1);</span>
<span class="nc" id="L733">        double m00 = (double)(dx2-dx1)/(sx2-sx1);</span>
<span class="nc" id="L734">        double m11 = (double)(dy2-dy1)/(sy2-sy1);</span>
<span class="nc" id="L735">        atfm.scale(m00, m11);</span>
<span class="nc" id="L736">        atfm.translate(srcX-sx1, srcY-sy1);</span>

<span class="nc" id="L738">        final int scale = SurfaceManager.getImageScale(img);</span>
<span class="nc" id="L739">        final int imgW = img.getWidth(null) * scale;</span>
<span class="nc" id="L740">        final int imgH = img.getHeight(null) * scale;</span>
<span class="nc" id="L741">        srcW += srcX;</span>
<span class="nc" id="L742">        srcH += srcY;</span>
        // Make sure we are not out of bounds
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (srcW &gt; imgW) {</span>
<span class="nc" id="L745">            srcW = imgW;</span>
        }
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (srcH &gt; imgH) {</span>
<span class="nc" id="L748">            srcH = imgH;</span>
        }
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (srcX &lt; 0) {</span>
<span class="nc" id="L751">            atfm.translate(-srcX, 0);</span>
<span class="nc" id="L752">            srcX = 0;</span>
        }
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (srcY &lt; 0) {</span>
<span class="nc" id="L755">            atfm.translate(0, -srcY);</span>
<span class="nc" id="L756">            srcY = 0;</span>
        }
<span class="nc bnc" id="L758" title="All 4 branches missed.">        if (srcX &gt;= srcW || srcY &gt;= srcH) {</span>
<span class="nc" id="L759">            return true;</span>
        }
        // Note: src[WH] are currently the right and bottom coordinates.
        // The following two lines would adjust src[WH] back to being
        // dimensions.
        //     srcW -= srcX;
        //     srcH -= srcY;
        // Since transformImage needs right and bottom coords we will
        // omit this adjustment.

<span class="nc" id="L769">        transformImage(sg, img, atfm, sg.interpolationType,</span>
                       srcX, srcY, srcW, srcH, bgColor);
<span class="nc" id="L771">        return true;</span>
    }

    /**
     ** Utilities
     ** The following methods are used by the public methods above
     ** for performing various operations
     **/

    /*
     * This constant represents a tradeoff between the
     * need to make sure that image transformations are
     * &quot;very close&quot; to integer device coordinates before
     * we decide to use an integer scale or copy operation
     * as a substitute and the fact that roundoff errors
     * in AffineTransforms are frequently introduced by
     * performing multiple sequential operations on them.
     *
     * The evaluation of bug 4990624 details the potential
     * for this error cutoff to result in display anomalies
     * in different types of image operations and how this
     * value represents a good compromise here.
     */
    private static final double MAX_TX_ERROR = .0001;

    public static boolean closeToInteger(int i, double d) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        return (Math.abs(d-i) &lt; MAX_TX_ERROR);</span>
    }

    public static boolean isSimpleTranslate(SunGraphics2D sg) {
<span class="nc" id="L801">        int ts = sg.transformState;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (ts &lt;= SunGraphics2D.TRANSFORM_INT_TRANSLATE) {</span>
            // Integer translates are always &quot;simple&quot;
<span class="nc" id="L804">            return true;</span>
        }
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (ts &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
            // Scales and beyond are always &quot;not simple&quot;
<span class="nc" id="L808">            return false;</span>
        }
        // non-integer translates are only simple when not interpolating
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (sg.interpolationType == AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {</span>
<span class="nc" id="L812">            return true;</span>
        }
<span class="nc" id="L814">        return false;</span>
    }

    protected static boolean isBgOperation(SurfaceData srcData, Color bgColor) {
        // If we cannot get the srcData, then cannot assume anything about
        // the image
<span class="nc bnc" id="L820" title="All 4 branches missed.">        return ((srcData == null) ||</span>
                ((bgColor != null) &amp;&amp;
<span class="nc bnc" id="L822" title="All 2 branches missed.">                 (srcData.getTransparency() != Transparency.OPAQUE)));</span>
    }

    protected BufferedImage getBufferedImage(Image img) {
<span class="nc bnc" id="L826" title="All 2 branches missed.">        if (img instanceof BufferedImage) {</span>
<span class="nc" id="L827">            return (BufferedImage)img;</span>
        }
        // Must be VolatileImage; get BufferedImage representation
<span class="nc" id="L830">        return ((VolatileImage)img).getSnapshot();</span>
    }

    /*
     * Return the color model to be used with this BufferedImage and
     * transform.
     */
    private ColorModel getTransformColorModel(SunGraphics2D sg,
                                              BufferedImage bImg,
                                              AffineTransform tx) {
<span class="nc" id="L840">        ColorModel cm = bImg.getColorModel();</span>
<span class="nc" id="L841">        ColorModel dstCM = cm;</span>

<span class="nc bnc" id="L843" title="All 2 branches missed.">        if (tx.isIdentity()) {</span>
<span class="nc" id="L844">            return dstCM;</span>
        }
<span class="nc" id="L846">        int type = tx.getType();</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">        boolean needTrans =</span>
                ((type &amp; (AffineTransform.TYPE_MASK_ROTATION |
                          AffineTransform.TYPE_GENERAL_TRANSFORM)) != 0);
<span class="nc bnc" id="L850" title="All 6 branches missed.">        if (! needTrans &amp;&amp;</span>
              type != AffineTransform.TYPE_TRANSLATION &amp;&amp;
              type != AffineTransform.TYPE_IDENTITY)
        {
<span class="nc" id="L854">            double[] mtx = new double[4];</span>
<span class="nc" id="L855">            tx.getMatrix(mtx);</span>
            // Check out the matrix.  A non-integral scale will force ARGB
            // since the edge conditions cannot be guaranteed.
<span class="nc bnc" id="L858" title="All 4 branches missed.">            needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);</span>
        }

<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (sg.renderHint != SunHints.INTVAL_RENDER_QUALITY) {</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (cm instanceof IndexColorModel) {</span>
<span class="nc" id="L863">                Raster raster = bImg.getRaster();</span>
<span class="nc" id="L864">                IndexColorModel icm = (IndexColorModel) cm;</span>
                // Just need to make sure that we have a transparent pixel
<span class="nc bnc" id="L866" title="All 4 branches missed.">                if (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE) {</span>
                    // Fix 4221407
<span class="nc bnc" id="L868" title="All 2 branches missed.">                    if (raster instanceof sun.awt.image.BytePackedRaster) {</span>
<span class="nc" id="L869">                        dstCM = ColorModel.getRGBdefault();</span>
                    }
                    else {
<span class="nc" id="L872">                        double[] matrix = new double[6];</span>
<span class="nc" id="L873">                        tx.getMatrix(matrix);</span>
<span class="nc bnc" id="L874" title="All 8 branches missed.">                        if (matrix[1] == 0. &amp;&amp; matrix[2] ==0.</span>
                            &amp;&amp; matrix[4] == 0. &amp;&amp; matrix[5] == 0.) {
                            // Only scaling so do not need to create
                        }
                        else {
<span class="nc" id="L879">                            int mapSize = icm.getMapSize();</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                            if (mapSize &lt; 256) {</span>
<span class="nc" id="L881">                                int[] cmap = new int[mapSize+1];</span>
<span class="nc" id="L882">                                icm.getRGBs(cmap);</span>
<span class="nc" id="L883">                                cmap[mapSize] = 0x0000;</span>
<span class="nc" id="L884">                                dstCM = new</span>
<span class="nc" id="L885">                                    IndexColorModel(icm.getPixelSize(),</span>
                                                    mapSize+1,
                                                    cmap, 0, true, mapSize,
                                                    DataBuffer.TYPE_BYTE);
<span class="nc" id="L889">                            }</span>
                            else {
<span class="nc" id="L891">                                dstCM = ColorModel.getRGBdefault();</span>
                            }
                        }  /* if (matrix[0] &lt; 1.f ...) */
                    }   /* raster instanceof sun.awt.image.BytePackedRaster */
                } /* if (cm.getTransparency() == cm.OPAQUE) */
<span class="nc" id="L896">            } /* if (cm instanceof IndexColorModel) */</span>
<span class="nc bnc" id="L897" title="All 4 branches missed.">            else if (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE) {</span>
                // Need a bitmask transparency
                // REMIND: for now, use full transparency since no loops
                // for bitmask
<span class="nc" id="L901">                dstCM = ColorModel.getRGBdefault();</span>
            }
        } /* if (sg.renderHint == RENDER_QUALITY) */
        else {

<span class="nc bnc" id="L906" title="All 4 branches missed.">            if (cm instanceof IndexColorModel ||</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">                (needTrans &amp;&amp; cm.getTransparency() == Transparency.OPAQUE))</span>
            {
                // Need a bitmask transparency
                // REMIND: for now, use full transparency since no loops
                // for bitmask
<span class="nc" id="L912">                dstCM = ColorModel.getRGBdefault();</span>
            }
        }

<span class="nc" id="L916">        return dstCM;</span>
    }

    protected void blitSurfaceData(SunGraphics2D sg,
                                   Region clipRegion,
                                   SurfaceData srcData,
                                   SurfaceData dstData,
                                   SurfaceType srcType,
                                   SurfaceType dstType,
                                   int sx, int sy, int dx, int dy,
                                   int w, int h,
                                   Color bgColor)
    {
<span class="nc bnc" id="L929" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
            /*
             * Fix for bugid 4783274 - BlitBg throws an exception for
             * a particular set of anomalous parameters.
             * REMIND: The native loops do proper clipping and would
             * detect this situation themselves, but the Java loops
             * all seem to trust their parameters a little too well
             * to the point where they will try to process a negative
             * area of pixels and throw exceptions.  The real fix is
             * to modify the Java loops to do proper clipping so that
             * they can deal with negative dimensions as well as
             * improperly large dimensions, but that fix is too risky
             * to integrate for Mantis at this point.  In the meantime
             * eliminating the negative or zero dimensions here is
             * &quot;correct&quot; and saves them from some nasty exceptional
             * conditions, one of which is the test case of 4783274.
             */
<span class="nc" id="L946">            return;</span>
        }
<span class="nc" id="L948">        CompositeType comp = sg.imageComp;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">        if (CompositeType.SrcOverNoEa.equals(comp) &amp;&amp;</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">            (srcData.getTransparency() == Transparency.OPAQUE ||</span>
             (bgColor != null &amp;&amp;
<span class="nc bnc" id="L952" title="All 2 branches missed.">              bgColor.getTransparency() == Transparency.OPAQUE)))</span>
        {
<span class="nc" id="L954">            comp = CompositeType.SrcNoEa;</span>
        }
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (!isBgOperation(srcData, bgColor)) {</span>
<span class="nc" id="L957">            Blit blit = Blit.getFromCache(srcType, comp, dstType);</span>
<span class="nc" id="L958">            blit.Blit(srcData, dstData, sg.composite, clipRegion,</span>
                      sx, sy, dx, dy, w, h);
<span class="nc" id="L960">        } else {</span>
<span class="nc" id="L961">            BlitBg blit = BlitBg.getFromCache(srcType, comp, dstType);</span>
<span class="nc" id="L962">            blit.BlitBg(srcData, dstData, sg.composite, clipRegion,</span>
<span class="nc" id="L963">                        bgColor.getRGB(), sx, sy, dx, dy, w, h);</span>
        }
<span class="nc" id="L965">    }</span>

    protected boolean scaleSurfaceData(SunGraphics2D sg,
                                       Region clipRegion,
                                       SurfaceData srcData,
                                       SurfaceData dstData,
                                       SurfaceType srcType,
                                       SurfaceType dstType,
                                       int sx1, int sy1,
                                       int sx2, int sy2,
                                       double dx1, double dy1,
                                       double dx2, double dy2)
    {
<span class="nc" id="L978">        CompositeType comp = sg.imageComp;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        if (CompositeType.SrcOverNoEa.equals(comp) &amp;&amp;</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            (srcData.getTransparency() == Transparency.OPAQUE))</span>
        {
<span class="nc" id="L982">            comp = CompositeType.SrcNoEa;</span>
        }

<span class="nc" id="L985">        ScaledBlit blit = ScaledBlit.getFromCache(srcType, comp, dstType);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">        if (blit != null) {</span>
<span class="nc" id="L987">            blit.Scale(srcData, dstData, sg.composite, clipRegion,</span>
                       sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
<span class="nc" id="L989">            return true;</span>
        }
<span class="nc" id="L991">        return false;</span>
    }

    protected static boolean imageReady(ToolkitImage sunimg,
                                        ImageObserver observer)
    {
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (sunimg.hasError()) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">            if (observer != null) {</span>
<span class="nc" id="L999">                observer.imageUpdate(sunimg,</span>
                                     ImageObserver.ERROR|ImageObserver.ABORT,
                                     -1, -1, -1, -1);
            }
<span class="nc" id="L1003">            return false;</span>
        }
<span class="nc" id="L1005">        return true;</span>
    }

    public boolean copyImage(SunGraphics2D sg, Image img,
                             int x, int y,
                             Color bgColor,
                             ImageObserver observer) {
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L1013">            return copyImage(sg, img, x, y, bgColor);</span>
        } else {
<span class="nc" id="L1015">            ToolkitImage sunimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            if (!imageReady(sunimg, observer)) {</span>
<span class="nc" id="L1017">                return false;</span>
            }
<span class="nc" id="L1019">            ImageRepresentation ir = sunimg.getImageRep();</span>
<span class="nc" id="L1020">            return ir.drawToBufImage(sg, sunimg, x, y, bgColor, observer);</span>
        }
    }

    public boolean copyImage(SunGraphics2D sg, Image img,
                             int dx, int dy, int sx, int sy, int w, int h,
                             Color bgColor,
                             ImageObserver observer) {
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L1029">            return copyImage(sg, img, dx, dy, sx, sy, w, h, bgColor);</span>
        } else {
<span class="nc" id="L1031">            ToolkitImage sunimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            if (!imageReady(sunimg, observer)) {</span>
<span class="nc" id="L1033">                return false;</span>
            }
<span class="nc" id="L1035">            ImageRepresentation ir = sunimg.getImageRep();</span>
<span class="nc" id="L1036">            return ir.drawToBufImage(sg, sunimg,</span>
                                     dx, dy, (dx + w), (dy + h),
                                     sx, sy, (sx + w), (sy + h),
                                     bgColor, observer);
        }
    }

    public boolean scaleImage(SunGraphics2D sg, Image img,
                                int x, int y,
                                int width, int height,
                                Color bgColor,
                                ImageObserver observer) {
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L1049">            return scaleImage(sg, img, x, y, width, height, bgColor);</span>
        } else {
<span class="nc" id="L1051">            ToolkitImage sunimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            if (!imageReady(sunimg, observer)) {</span>
<span class="nc" id="L1053">                return false;</span>
            }
<span class="nc" id="L1055">            ImageRepresentation ir = sunimg.getImageRep();</span>
<span class="nc" id="L1056">            return ir.drawToBufImage(sg, sunimg, x, y, width, height, bgColor,</span>
                                     observer);
        }
    }

    public boolean scaleImage(SunGraphics2D sg, Image img,
                              int dx1, int dy1, int dx2, int dy2,
                              int sx1, int sy1, int sx2, int sy2,
                              Color bgColor,
                              ImageObserver observer) {
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L1067">            return scaleImage(sg, img, dx1, dy1, dx2, dy2,</span>
                              sx1, sy1, sx2, sy2, bgColor);
        } else {
<span class="nc" id="L1070">            ToolkitImage sunimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            if (!imageReady(sunimg, observer)) {</span>
<span class="nc" id="L1072">                return false;</span>
            }
<span class="nc" id="L1074">            ImageRepresentation ir = sunimg.getImageRep();</span>
<span class="nc" id="L1075">            return ir.drawToBufImage(sg, sunimg, dx1, dy1, dx2, dy2,</span>
                                     sx1, sy1, sx2, sy2, bgColor, observer);
        }
    }

    public boolean transformImage(SunGraphics2D sg, Image img,
                                  AffineTransform atfm,
                                  ImageObserver observer) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (!(img instanceof ToolkitImage)) {</span>
<span class="nc" id="L1084">            transformImage(sg, img, 0, 0, atfm, sg.interpolationType);</span>
<span class="nc" id="L1085">            return true;</span>
        } else {
<span class="nc" id="L1087">            ToolkitImage sunimg = (ToolkitImage)img;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">            if (!imageReady(sunimg, observer)) {</span>
<span class="nc" id="L1089">                return false;</span>
            }
<span class="nc" id="L1091">            ImageRepresentation ir = sunimg.getImageRep();</span>
<span class="nc" id="L1092">            return ir.drawToBufImage(sg, sunimg, atfm, observer);</span>
        }
    }

    public void transformImage(SunGraphics2D sg, BufferedImage img,
                               BufferedImageOp op, int x, int y)
    {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (op != null) {</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">            if (op instanceof AffineTransformOp) {</span>
<span class="nc" id="L1101">                AffineTransformOp atop = (AffineTransformOp) op;</span>
<span class="nc" id="L1102">                transformImage(sg, img, x, y,</span>
<span class="nc" id="L1103">                               atop.getTransform(),</span>
<span class="nc" id="L1104">                               atop.getInterpolationType());</span>
<span class="nc" id="L1105">                return;</span>
            } else {
<span class="nc" id="L1107">                img = op.filter(img, null);</span>
            }
        }
<span class="nc" id="L1110">        copyImage(sg, img, x, y, null);</span>
<span class="nc" id="L1111">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>