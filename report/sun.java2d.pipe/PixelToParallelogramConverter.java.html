<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PixelToParallelogramConverter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">PixelToParallelogramConverter.java</span></div><h1>PixelToParallelogramConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.Shape;
import java.awt.BasicStroke;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.AffineTransform;
import sun.java2d.SunGraphics2D;
import sun.awt.SunHints;

/**
 * This class converts calls to the basic pixel rendering methods
 * into calls to the methods on a ParallelogramPipe.
 * Most calls are transformed into calls to the fill(Shape) method
 * by the parent PixelToShapeConverter class, but some calls are
 * transformed into calls to fill/drawParallelogram().
 */
public class PixelToParallelogramConverter extends PixelToShapeConverter
    implements ShapeDrawPipe
{
    ParallelogramPipe outrenderer;
    double minPenSize;
    double normPosition;
    double normRoundingBias;
    boolean adjustfill;

    /**
     * @param shapepipe pipeline to forward shape calls to
     * @param pgrampipe pipeline to forward parallelogram calls to
     *                  (and drawLine calls if possible)
     * @param minPenSize minimum pen size for dropout control
     * @param normPosition sub-pixel location to normalize endpoints
     *                     for STROKE_NORMALIZE cases
     * @param adjustFill boolean to control whethere normalization
     *                   constants are also applied to fill operations
     *                   (normally true for non-AA, false for AA)
     */
    public PixelToParallelogramConverter(ShapeDrawPipe shapepipe,
                                         ParallelogramPipe pgrampipe,
                                         double minPenSize,
                                         double normPosition,
                                         boolean adjustfill)
    {
<span class="nc" id="L69">        super(shapepipe);</span>
<span class="nc" id="L70">        outrenderer = pgrampipe;</span>
<span class="nc" id="L71">        this.minPenSize = minPenSize;</span>
<span class="nc" id="L72">        this.normPosition = normPosition;</span>
<span class="nc" id="L73">        this.normRoundingBias = 0.5 - normPosition;</span>
<span class="nc" id="L74">        this.adjustfill = adjustfill;</span>
<span class="nc" id="L75">    }</span>

    public void drawLine(SunGraphics2D sg2d,
                         int x1, int y1, int x2, int y2)
    {
<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (!drawGeneralLine(sg2d, x1, y1, x2, y2)) {</span>
<span class="nc" id="L81">            super.drawLine(sg2d, x1, y1, x2, y2);</span>
        }
<span class="nc" id="L83">    }</span>

    public void drawRect(SunGraphics2D sg2d,
                         int x, int y, int w, int h)
    {
<span class="nc bnc" id="L88" title="All 4 branches missed.">        if (w &gt;= 0 &amp;&amp; h &gt;= 0) {</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (sg2d.strokeState &lt; SunGraphics2D.STROKE_CUSTOM) {</span>
<span class="nc" id="L90">                BasicStroke bs = ((BasicStroke) sg2d.stroke);</span>
<span class="nc bnc" id="L91" title="All 4 branches missed.">                if (w &gt; 0 &amp;&amp; h &gt; 0) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                    if (bs.getLineJoin() == BasicStroke.JOIN_MITER &amp;&amp;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">                        bs.getDashArray() == null)</span>
                    {
<span class="nc" id="L95">                        double lw = bs.getLineWidth();</span>
<span class="nc" id="L96">                        drawRectangle(sg2d, x, y, w, h, lw);</span>
<span class="nc" id="L97">                        return;</span>
                    }
                } else {
                    // Note: This calls the integer version which
                    // will verify that the local drawLine optimizations
                    // work and call super.drawLine(), if not.
<span class="nc" id="L103">                    drawLine(sg2d, x, y, x+w, y+h);</span>
<span class="nc" id="L104">                    return;</span>
                }
            }
<span class="nc" id="L107">            super.drawRect(sg2d, x, y, w, h);</span>
        }
<span class="nc" id="L109">    }</span>

    public void fillRect(SunGraphics2D sg2d,
                         int x, int y, int w, int h)
    {
<span class="nc bnc" id="L114" title="All 4 branches missed.">        if (w &gt; 0 &amp;&amp; h &gt; 0) {</span>
<span class="nc" id="L115">            fillRectangle(sg2d, x, y, w, h);</span>
        }
<span class="nc" id="L117">    }</span>

    public void draw(SunGraphics2D sg2d, Shape s) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (sg2d.strokeState &lt; SunGraphics2D.STROKE_CUSTOM) {</span>
<span class="nc" id="L121">            BasicStroke bs = ((BasicStroke) sg2d.stroke);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (s instanceof Rectangle2D) {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (bs.getLineJoin() == BasicStroke.JOIN_MITER &amp;&amp;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                    bs.getDashArray() == null)</span>
                {
<span class="nc" id="L126">                    Rectangle2D r2d = (Rectangle2D) s;</span>
<span class="nc" id="L127">                    double w = r2d.getWidth();</span>
<span class="nc" id="L128">                    double h = r2d.getHeight();</span>
<span class="nc" id="L129">                    double x = r2d.getX();</span>
<span class="nc" id="L130">                    double y = r2d.getY();</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">                    if (w &gt;= 0 &amp;&amp; h &gt;= 0) {</span>
<span class="nc" id="L132">                        double lw = bs.getLineWidth();</span>
<span class="nc" id="L133">                        drawRectangle(sg2d, x, y, w, h, lw);</span>
                    }
<span class="nc" id="L135">                    return;</span>
                }
<span class="nc bnc" id="L137" title="All 2 branches missed.">            } else if (s instanceof Line2D) {</span>
<span class="nc" id="L138">                Line2D l2d = (Line2D) s;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">                if (drawGeneralLine(sg2d,</span>
<span class="nc" id="L140">                                    l2d.getX1(), l2d.getY1(),</span>
<span class="nc" id="L141">                                    l2d.getX2(), l2d.getY2()))</span>
                {
<span class="nc" id="L143">                    return;</span>
                }
            }
        }

<span class="nc" id="L148">        outpipe.draw(sg2d, s);</span>
<span class="nc" id="L149">    }</span>

    public void fill(SunGraphics2D sg2d, Shape s) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (s instanceof Rectangle2D) {</span>
<span class="nc" id="L153">            Rectangle2D r2d = (Rectangle2D) s;</span>
<span class="nc" id="L154">            double w = r2d.getWidth();</span>
<span class="nc" id="L155">            double h = r2d.getHeight();</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">            if (w &gt; 0 &amp;&amp; h &gt; 0) {</span>
<span class="nc" id="L157">                double x = r2d.getX();</span>
<span class="nc" id="L158">                double y = r2d.getY();</span>
<span class="nc" id="L159">                fillRectangle(sg2d, x, y, w, h);</span>
            }
<span class="nc" id="L161">            return;</span>
        }

<span class="nc" id="L164">        outpipe.fill(sg2d, s);</span>
<span class="nc" id="L165">    }</span>

    static double len(double x, double y) {
<span class="nc bnc" id="L168" title="All 4 branches missed.">        return ((x == 0) ? Math.abs(y)</span>
<span class="nc" id="L169">                : ((y == 0) ? Math.abs(x)</span>
<span class="nc" id="L170">                   : Math.sqrt(x * x + y * y)));</span>
    }

    double normalize(double v) {
<span class="nc" id="L174">        return Math.floor(v + normRoundingBias) + normPosition;</span>
    }

    public boolean drawGeneralLine(SunGraphics2D sg2d,
                                   double ux1, double uy1,
                                   double ux2, double uy2)
    {
<span class="nc bnc" id="L181" title="All 4 branches missed.">        if (sg2d.strokeState == SunGraphics2D.STROKE_CUSTOM ||</span>
            sg2d.strokeState == SunGraphics2D.STROKE_THINDASHED)
        {
<span class="nc" id="L184">            return false;</span>
        }
<span class="nc" id="L186">        BasicStroke bs = (BasicStroke) sg2d.stroke;</span>
<span class="nc" id="L187">        int cap = bs.getEndCap();</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (cap == BasicStroke.CAP_ROUND || bs.getDashArray() != null) {</span>
            // TODO: we could construct the GeneralPath directly
            // for CAP_ROUND and save a lot of processing in that case...
            // And again, we would need to deal with dropout control...
<span class="nc" id="L192">            return false;</span>
        }
<span class="nc" id="L194">        double lw = bs.getLineWidth();</span>
        // Save the original dx, dy in case we need it to transform
        // the linewidth as a perpendicular vector below
<span class="nc" id="L197">        double dx = ux2 - ux1;</span>
<span class="nc" id="L198">        double dy = uy2 - uy1;</span>
        double x1, y1, x2, y2;
<span class="nc bnc" id="L200" title="All 4 branches missed.">        switch (sg2d.transformState) {</span>
        case SunGraphics2D.TRANSFORM_GENERIC:
        case SunGraphics2D.TRANSFORM_TRANSLATESCALE:
            {
<span class="nc" id="L204">                double coords[] = {ux1, uy1, ux2, uy2};</span>
<span class="nc" id="L205">                sg2d.transform.transform(coords, 0, coords, 0, 2);</span>
<span class="nc" id="L206">                x1 = coords[0];</span>
<span class="nc" id="L207">                y1 = coords[1];</span>
<span class="nc" id="L208">                x2 = coords[2];</span>
<span class="nc" id="L209">                y2 = coords[3];</span>
            }
<span class="nc" id="L211">            break;</span>
        case SunGraphics2D.TRANSFORM_ANY_TRANSLATE:
        case SunGraphics2D.TRANSFORM_INT_TRANSLATE:
            {
<span class="nc" id="L215">                double tx = sg2d.transform.getTranslateX();</span>
<span class="nc" id="L216">                double ty = sg2d.transform.getTranslateY();</span>
<span class="nc" id="L217">                x1 = ux1 + tx;</span>
<span class="nc" id="L218">                y1 = uy1 + ty;</span>
<span class="nc" id="L219">                x2 = ux2 + tx;</span>
<span class="nc" id="L220">                y2 = uy2 + ty;</span>
            }
<span class="nc" id="L222">            break;</span>
        case SunGraphics2D.TRANSFORM_ISIDENT:
<span class="nc" id="L224">            x1 = ux1;</span>
<span class="nc" id="L225">            y1 = uy1;</span>
<span class="nc" id="L226">            x2 = ux2;</span>
<span class="nc" id="L227">            y2 = uy2;</span>
<span class="nc" id="L228">            break;</span>
        default:
<span class="nc" id="L230">            throw new InternalError(&quot;unknown TRANSFORM state...&quot;);</span>
        }
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE) {</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">            if (sg2d.strokeState == SunGraphics2D.STROKE_THIN &amp;&amp;</span>
                outrenderer instanceof PixelDrawPipe)
            {
                // PixelDrawPipes will add sg2d.transXY so we need to factor
                // that out...
<span class="nc" id="L238">                int ix1 = (int) Math.floor(x1 - sg2d.transX);</span>
<span class="nc" id="L239">                int iy1 = (int) Math.floor(y1 - sg2d.transY);</span>
<span class="nc" id="L240">                int ix2 = (int) Math.floor(x2 - sg2d.transX);</span>
<span class="nc" id="L241">                int iy2 = (int) Math.floor(y2 - sg2d.transY);</span>
<span class="nc" id="L242">                ((PixelDrawPipe)outrenderer).drawLine(sg2d, ix1, iy1, ix2, iy2);</span>
<span class="nc" id="L243">                return true;</span>
            }
<span class="nc" id="L245">            x1 = normalize(x1);</span>
<span class="nc" id="L246">            y1 = normalize(y1);</span>
<span class="nc" id="L247">            x2 = normalize(x2);</span>
<span class="nc" id="L248">            y2 = normalize(y2);</span>
        }
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
            // Transform the linewidth...
            // calculate the scaling factor for a unit vector
            // perpendicular to the original user space line.
<span class="nc" id="L254">            double len = len(dx, dy);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (len == 0) {</span>
<span class="nc" id="L256">                dx = len = 1;</span>
                // dy = 0; already
            }
            // delta transform the transposed (90 degree rotated) unit vector
<span class="nc" id="L260">            double unitvector[] = {dy/len, -dx/len};</span>
<span class="nc" id="L261">            sg2d.transform.deltaTransform(unitvector, 0, unitvector, 0, 1);</span>
<span class="nc" id="L262">            lw *= len(unitvector[0], unitvector[1]);</span>
        }
<span class="nc" id="L264">        lw = Math.max(lw, minPenSize);</span>
<span class="nc" id="L265">        dx = x2 - x1;</span>
<span class="nc" id="L266">        dy = y2 - y1;</span>
<span class="nc" id="L267">        double len = len(dx, dy);</span>
        double udx, udy;
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (len == 0) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (cap == BasicStroke.CAP_BUTT) {</span>
<span class="nc" id="L271">                return true;</span>
            }
<span class="nc" id="L273">            udx = lw;</span>
<span class="nc" id="L274">            udy = 0;</span>
        } else {
<span class="nc" id="L276">            udx = lw * dx / len;</span>
<span class="nc" id="L277">            udy = lw * dy / len;</span>
        }
<span class="nc" id="L279">        double px = x1 + udy / 2.0;</span>
<span class="nc" id="L280">        double py = y1 - udx / 2.0;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (cap == BasicStroke.CAP_SQUARE) {</span>
<span class="nc" id="L282">            px -= udx / 2.0;</span>
<span class="nc" id="L283">            py -= udy / 2.0;</span>
<span class="nc" id="L284">            dx += udx;</span>
<span class="nc" id="L285">            dy += udy;</span>
        }
<span class="nc" id="L287">        outrenderer.fillParallelogram(sg2d, ux1, uy1, ux2, uy2,</span>
                                      px, py, -udy, udx, dx, dy);
<span class="nc" id="L289">        return true;</span>
    }

    public void fillRectangle(SunGraphics2D sg2d,
                              double rx, double ry,
                              double rw, double rh)
    {
        double px, py;
        double dx1, dy1, dx2, dy2;
<span class="nc" id="L298">        AffineTransform txform = sg2d.transform;</span>
<span class="nc" id="L299">        dx1 = txform.getScaleX();</span>
<span class="nc" id="L300">        dy1 = txform.getShearY();</span>
<span class="nc" id="L301">        dx2 = txform.getShearX();</span>
<span class="nc" id="L302">        dy2 = txform.getScaleY();</span>
<span class="nc" id="L303">        px = rx * dx1 + ry * dx2 + txform.getTranslateX();</span>
<span class="nc" id="L304">        py = rx * dy1 + ry * dy2 + txform.getTranslateY();</span>
<span class="nc" id="L305">        dx1 *= rw;</span>
<span class="nc" id="L306">        dy1 *= rw;</span>
<span class="nc" id="L307">        dx2 *= rh;</span>
<span class="nc" id="L308">        dy2 *= rh;</span>
<span class="nc bnc" id="L309" title="All 6 branches missed.">        if (adjustfill &amp;&amp;</span>
            sg2d.strokeState &lt; SunGraphics2D.STROKE_CUSTOM &amp;&amp;
            sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE)
        {
<span class="nc" id="L313">            double newx = normalize(px);</span>
<span class="nc" id="L314">            double newy = normalize(py);</span>
<span class="nc" id="L315">            dx1 = normalize(px + dx1) - newx;</span>
<span class="nc" id="L316">            dy1 = normalize(py + dy1) - newy;</span>
<span class="nc" id="L317">            dx2 = normalize(px + dx2) - newx;</span>
<span class="nc" id="L318">            dy2 = normalize(py + dy2) - newy;</span>
<span class="nc" id="L319">            px = newx;</span>
<span class="nc" id="L320">            py = newy;</span>
        }
<span class="nc" id="L322">        outrenderer.fillParallelogram(sg2d, rx, ry, rx+rw, ry+rh,</span>
                                      px, py, dx1, dy1, dx2, dy2);
<span class="nc" id="L324">    }</span>

    public void drawRectangle(SunGraphics2D sg2d,
                              double rx, double ry,
                              double rw, double rh,
                              double lw)
    {
        double px, py;
        double dx1, dy1, dx2, dy2;
        double lw1, lw2;
<span class="nc" id="L334">        AffineTransform txform = sg2d.transform;</span>
<span class="nc" id="L335">        dx1 = txform.getScaleX();</span>
<span class="nc" id="L336">        dy1 = txform.getShearY();</span>
<span class="nc" id="L337">        dx2 = txform.getShearX();</span>
<span class="nc" id="L338">        dy2 = txform.getScaleY();</span>
<span class="nc" id="L339">        px = rx * dx1 + ry * dx2 + txform.getTranslateX();</span>
<span class="nc" id="L340">        py = rx * dy1 + ry * dy2 + txform.getTranslateY();</span>
        // lw along dx1,dy1 scale by transformed length of dx2,dy2 vectors
        // and vice versa
<span class="nc" id="L343">        lw1 = len(dx1, dy1) * lw;</span>
<span class="nc" id="L344">        lw2 = len(dx2, dy2) * lw;</span>
<span class="nc" id="L345">        dx1 *= rw;</span>
<span class="nc" id="L346">        dy1 *= rw;</span>
<span class="nc" id="L347">        dx2 *= rh;</span>
<span class="nc" id="L348">        dy2 *= rh;</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (sg2d.strokeState &lt; SunGraphics2D.STROKE_CUSTOM &amp;&amp;</span>
            sg2d.strokeHint != SunHints.INTVAL_STROKE_PURE)
        {
<span class="nc" id="L352">            double newx = normalize(px);</span>
<span class="nc" id="L353">            double newy = normalize(py);</span>
<span class="nc" id="L354">            dx1 = normalize(px + dx1) - newx;</span>
<span class="nc" id="L355">            dy1 = normalize(py + dy1) - newy;</span>
<span class="nc" id="L356">            dx2 = normalize(px + dx2) - newx;</span>
<span class="nc" id="L357">            dy2 = normalize(py + dy2) - newy;</span>
<span class="nc" id="L358">            px = newx;</span>
<span class="nc" id="L359">            py = newy;</span>
        }
<span class="nc" id="L361">        lw1 = Math.max(lw1, minPenSize);</span>
<span class="nc" id="L362">        lw2 = Math.max(lw2, minPenSize);</span>
<span class="nc" id="L363">        double len1 = len(dx1, dy1);</span>
<span class="nc" id="L364">        double len2 = len(dx2, dy2);</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">        if (lw1 &gt;= len1 || lw2 &gt;= len2) {</span>
            // The line widths are large enough to consume the
            // entire hole in the middle of the parallelogram
            // so we can just fill the outer parallelogram.
<span class="nc" id="L369">            fillOuterParallelogram(sg2d,</span>
                                   rx, ry, rx+rw, ry+rh,
                                   px, py, dx1, dy1, dx2, dy2,
                                   len1, len2, lw1, lw2);
        } else {
<span class="nc" id="L374">            outrenderer.drawParallelogram(sg2d,</span>
                                          rx, ry, rx+rw, ry+rh,
                                          px, py, dx1, dy1, dx2, dy2,
                                          lw1 / len1, lw2 / len2);
        }
<span class="nc" id="L379">    }</span>

    /**
     * This utility function handles the case where a drawRectangle
     * operation discovered that the interior hole in the rectangle
     * or parallelogram has been completely filled in by the stroke
     * width.  It calculates the outer parallelogram of the stroke
     * and issues a single fillParallelogram request to fill it.
     */
    public void fillOuterParallelogram(SunGraphics2D sg2d,
                                       double ux1, double uy1,
                                       double ux2, double uy2,
                                       double px, double py,
                                       double dx1, double dy1,
                                       double dx2, double dy2,
                                       double len1, double len2,
                                       double lw1, double lw2)
    {
<span class="nc" id="L397">        double udx1 = dx1 / len1;</span>
<span class="nc" id="L398">        double udy1 = dy1 / len1;</span>
<span class="nc" id="L399">        double udx2 = dx2 / len2;</span>
<span class="nc" id="L400">        double udy2 = dy2 / len2;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (len1 == 0) {</span>
            // len1 is 0, replace udxy1 with perpendicular of udxy2
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (len2 == 0) {</span>
                // both are 0, use a unit Y vector for udxy2
<span class="nc" id="L405">                udx2 = 0;</span>
<span class="nc" id="L406">                udy2 = 1;</span>
            }
<span class="nc" id="L408">            udx1 = udy2;</span>
<span class="nc" id="L409">            udy1 = -udx2;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        } else if (len2 == 0) {</span>
            // len2 is 0, replace udxy2 with perpendicular of udxy1
<span class="nc" id="L412">            udx2 = udy1;</span>
<span class="nc" id="L413">            udy2 = -udx1;</span>
        }
<span class="nc" id="L415">        udx1 *= lw1;</span>
<span class="nc" id="L416">        udy1 *= lw1;</span>
<span class="nc" id="L417">        udx2 *= lw2;</span>
<span class="nc" id="L418">        udy2 *= lw2;</span>
<span class="nc" id="L419">        px -= (udx1 + udx2) / 2;</span>
<span class="nc" id="L420">        py -= (udy1 + udy2) / 2;</span>
<span class="nc" id="L421">        dx1 += udx1;</span>
<span class="nc" id="L422">        dy1 += udy1;</span>
<span class="nc" id="L423">        dx2 += udx2;</span>
<span class="nc" id="L424">        dy2 += udy2;</span>

<span class="nc" id="L426">        outrenderer.fillParallelogram(sg2d, ux1, uy1, ux2, uy2,</span>
                                      px, py, dx1, dy1, dx2, dy2);
<span class="nc" id="L428">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>