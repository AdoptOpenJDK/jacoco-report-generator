<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Region.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">Region.java</span></div><h1>Region.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.RectangularShape;

/**
 * This class encapsulates a definition of a two dimensional region which
 * consists of a number of Y ranges each containing multiple X bands.
 * &lt;p&gt;
 * A rectangular Region is allowed to have a null band list in which
 * case the rectangular shape is defined by the bounding box parameters
 * (lox, loy, hix, hiy).
 * &lt;p&gt;
 * The band list, if present, consists of a list of rows in ascending Y
 * order, ending at endIndex which is the index beyond the end of the
 * last row.  Each row consists of at least 3 + 2n entries (n &gt;= 1)
 * where the first 3 entries specify the Y range as start, end, and
 * the number of X ranges in that Y range.  These 3 entries are
 * followed by pairs of X coordinates in ascending order:
 * &lt;pre&gt;
 * bands[rowstart+0] = Y0;        // starting Y coordinate
 * bands[rowstart+1] = Y1;        // ending Y coordinate - endY &gt; startY
 * bands[rowstart+2] = N;         // number of X bands - N &gt;= 1
 *
 * bands[rowstart+3] = X10;       // starting X coordinate of first band
 * bands[rowstart+4] = X11;       // ending X coordinate of first band
 * bands[rowstart+5] = X20;       // starting X coordinate of second band
 * bands[rowstart+6] = X21;       // ending X coordinate of second band
 * ...
 * bands[rowstart+3+N*2-2] = XN0; // starting X coord of last band
 * bands[rowstart+3+N*2-1] = XN1; // ending X coord of last band
 *
 * bands[rowstart+3+N*2] = ...    // start of next Y row
 * &lt;/pre&gt;
 */
public class Region {
    static final int INIT_SIZE = 50;
    static final int GROW_SIZE = 50;

    /**
     * Immutable Region.
     */
    private static final class ImmutableRegion extends Region {
        protected ImmutableRegion(int lox, int loy, int hix, int hiy) {
<span class="nc" id="L72">            super(lox, loy, hix, hiy);</span>
<span class="nc" id="L73">        }</span>

        // Override all the methods that mutate the object
<span class="nc" id="L76">        public void appendSpans(sun.java2d.pipe.SpanIterator si) {}</span>
<span class="nc" id="L77">        public void setOutputArea(java.awt.Rectangle r) {}</span>
<span class="nc" id="L78">        public void setOutputAreaXYWH(int x, int y, int w, int h) {}</span>
<span class="nc" id="L79">        public void setOutputArea(int[] box) {}</span>
<span class="nc" id="L80">        public void setOutputAreaXYXY(int lox, int loy, int hix, int hiy) {}</span>
    }

<span class="nc" id="L83">    public static final Region EMPTY_REGION = new ImmutableRegion(0, 0, 0, 0);</span>
<span class="nc" id="L84">    public static final Region WHOLE_REGION = new ImmutableRegion(</span>
            Integer.MIN_VALUE,
            Integer.MIN_VALUE,
            Integer.MAX_VALUE,
            Integer.MAX_VALUE);

    int lox;
    int loy;
    int hix;
    int hiy;

    int endIndex;
    int[] bands;

    private static native void initIDs();

    static {
<span class="nc" id="L101">        initIDs();</span>
<span class="nc" id="L102">    }</span>

    /**
     * Adds the dimension &lt;code&gt;dim&lt;/code&gt; to the coordinate
     * &lt;code&gt;start&lt;/code&gt; with appropriate clipping.  If
     * &lt;code&gt;dim&lt;/code&gt; is non-positive then the method returns
     * the start coordinate.  If the sum overflows an integer
     * data type then the method returns &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    public static int dimAdd(int start, int dim) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (dim &lt;= 0) return start;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if ((dim += start) &lt; start) return Integer.MAX_VALUE;</span>
<span class="nc" id="L114">        return dim;</span>
    }

    /**
     * Adds the delta {@code dv} to the value {@code v} with
     * appropriate clipping to the bounds of Integer resolution.
     * If the answer would be greater than {@code Integer.MAX_VALUE}
     * then {@code Integer.MAX_VALUE} is returned.
     * If the answer would be less than {@code Integer.MIN_VALUE}
     * then {@code Integer.MIN_VALUE} is returned.
     * Otherwise the sum is returned.
     */
    public static int clipAdd(int v, int dv) {
<span class="nc" id="L127">        int newv = v + dv;</span>
<span class="nc bnc" id="L128" title="All 6 branches missed.">        if ((newv &gt; v) != (dv &gt; 0)) {</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            newv = (dv &lt; 0) ? Integer.MIN_VALUE : Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L131">        return newv;</span>
    }

    /**
     * Multiply the scale factor {@code sv} and the value {@code v} with
     * appropriate clipping to the bounds of Integer resolution. If the answer
     * would be greater than {@code Integer.MAX_VALUE} then {@code
     * Integer.MAX_VALUE} is returned. If the answer would be less than {@code
     * Integer.MIN_VALUE} then {@code Integer.MIN_VALUE} is returned. Otherwise
     * the multiplication is returned.
     */
    public static int clipScale(final int v, final double sv) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (sv == 1.0) {</span>
<span class="nc" id="L144">            return v;</span>
        }
<span class="nc" id="L146">        final double newv = v * sv;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (newv &lt; Integer.MIN_VALUE) {</span>
<span class="nc" id="L148">            return Integer.MIN_VALUE;</span>
        }
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (newv &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L151">            return Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L153">        return (int) Math.round(newv);</span>
    }

<span class="nc" id="L156">    protected Region(int lox, int loy, int hix, int hiy) {</span>
<span class="nc" id="L157">        this.lox = lox;</span>
<span class="nc" id="L158">        this.loy = loy;</span>
<span class="nc" id="L159">        this.hix = hix;</span>
<span class="nc" id="L160">        this.hiy = hiy;</span>
<span class="nc" id="L161">    }</span>

    /**
     * Returns a Region object covering the pixels which would be
     * touched by a fill or clip operation on a Graphics implementation
     * on the specified Shape object under the optionally specified
     * AffineTransform object.
     *
     * @param s a non-null Shape object specifying the geometry enclosing
     *          the pixels of interest
     * @param at an optional &lt;code&gt;AffineTransform&lt;/code&gt; to be applied to the
     *          coordinates as they are returned in the iteration, or
     *          &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     */
    public static Region getInstance(Shape s, AffineTransform at) {
<span class="nc" id="L176">        return getInstance(WHOLE_REGION, false, s, at);</span>
    }

    /**
     * Returns a Region object covering the pixels which would be
     * touched by a fill or clip operation on a Graphics implementation
     * on the specified Shape object under the optionally specified
     * AffineTransform object further restricted by the specified
     * device bounds.
     * &lt;p&gt;
     * Note that only the bounds of the specified Region are used to
     * restrict the resulting Region.
     * If devBounds is non-rectangular and clipping to the specific
     * bands of devBounds is needed, then an intersection of the
     * resulting Region with devBounds must be performed in a
     * subsequent step.
     *
     * @param devBounds a non-null Region specifying some bounds to
     *          clip the geometry to
     * @param s a non-null Shape object specifying the geometry enclosing
     *          the pixels of interest
     * @param at an optional &lt;code&gt;AffineTransform&lt;/code&gt; to be applied to the
     *          coordinates as they are returned in the iteration, or
     *          &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     */
    public static Region getInstance(Region devBounds,
                                     Shape s, AffineTransform at)
    {
<span class="nc" id="L204">        return getInstance(devBounds, false, s, at);</span>
    }

    /**
     * Returns a Region object covering the pixels which would be
     * touched by a fill or clip operation on a Graphics implementation
     * on the specified Shape object under the optionally specified
     * AffineTransform object further restricted by the specified
     * device bounds.
     * If the normalize parameter is true then coordinate normalization
     * is performed as per the 2D Graphics non-antialiasing implementation
     * of the VALUE_STROKE_NORMALIZE hint.
     * &lt;p&gt;
     * Note that only the bounds of the specified Region are used to
     * restrict the resulting Region.
     * If devBounds is non-rectangular and clipping to the specific
     * bands of devBounds is needed, then an intersection of the
     * resulting Region with devBounds must be performed in a
     * subsequent step.
     *
     * @param devBounds a non-null Region specifying some bounds to
     *          clip the geometry to
     * @param normalize a boolean indicating whether or not to apply
     *          normalization
     * @param s a non-null Shape object specifying the geometry enclosing
     *          the pixels of interest
     * @param at an optional &lt;code&gt;AffineTransform&lt;/code&gt; to be applied to the
     *          coordinates as they are returned in the iteration, or
     *          &lt;code&gt;null&lt;/code&gt; if untransformed coordinates are desired
     */
    public static Region getInstance(Region devBounds, boolean normalize,
                                     Shape s, AffineTransform at)
    {
        // Optimize for empty shapes to avoid involving the SpanIterator
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (s instanceof RectangularShape &amp;&amp;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                ((RectangularShape)s).isEmpty())</span>
        {
<span class="nc" id="L241">            return EMPTY_REGION;</span>
        }

<span class="nc" id="L244">        int box[] = new int[4];</span>
<span class="nc" id="L245">        ShapeSpanIterator sr = new ShapeSpanIterator(normalize);</span>
        try {
<span class="nc" id="L247">            sr.setOutputArea(devBounds);</span>
<span class="nc" id="L248">            sr.appendPath(s.getPathIterator(at));</span>
<span class="nc" id="L249">            sr.getPathBox(box);</span>
<span class="nc" id="L250">            Region r = Region.getInstance(box);</span>
<span class="nc" id="L251">            r.appendSpans(sr);</span>
<span class="nc" id="L252">            return r;</span>
        } finally {
<span class="nc" id="L254">            sr.dispose();</span>
        }
    }

    /**
     * Returns a Region object with a rectangle of interest specified
     * by the indicated Rectangle object.
     * &lt;p&gt;
     * This method can also be used to create a simple rectangular
     * region.
     */
    public static Region getInstance(Rectangle r) {
<span class="nc" id="L266">        return Region.getInstanceXYWH(r.x, r.y, r.width, r.height);</span>
    }

    /**
     * Returns a Region object with a rectangle of interest specified
     * by the indicated rectangular area in x, y, width, height format.
     * &lt;p&gt;
     * This method can also be used to create a simple rectangular
     * region.
     */
    public static Region getInstanceXYWH(int x, int y, int w, int h) {
<span class="nc" id="L277">        return Region.getInstanceXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
    }

    /**
     * Returns a Region object with a rectangle of interest specified
     * by the indicated span array.
     * &lt;p&gt;
     * This method can also be used to create a simple rectangular
     * region.
     */
    public static Region getInstance(int box[]) {
<span class="nc" id="L288">        return new Region(box[0], box[1], box[2], box[3]);</span>
    }

    /**
     * Returns a Region object with a rectangle of interest specified
     * by the indicated rectangular area in lox, loy, hix, hiy format.
     * &lt;p&gt;
     * This method can also be used to create a simple rectangular
     * region.
     */
    public static Region getInstanceXYXY(int lox, int loy, int hix, int hiy) {
<span class="nc" id="L299">        return new Region(lox, loy, hix, hiy);</span>
    }

    /**
     * Sets the rectangle of interest for storing and returning
     * region bands.
     * &lt;p&gt;
     * This method can also be used to initialize a simple rectangular
     * region.
     */
    public void setOutputArea(Rectangle r) {
<span class="nc" id="L310">        setOutputAreaXYWH(r.x, r.y, r.width, r.height);</span>
<span class="nc" id="L311">    }</span>

    /**
     * Sets the rectangle of interest for storing and returning
     * region bands.  The rectangle is specified in x, y, width, height
     * format and appropriate clipping is performed as per the method
     * &lt;code&gt;dimAdd&lt;/code&gt;.
     * &lt;p&gt;
     * This method can also be used to initialize a simple rectangular
     * region.
     */
    public void setOutputAreaXYWH(int x, int y, int w, int h) {
<span class="nc" id="L323">        setOutputAreaXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
<span class="nc" id="L324">    }</span>

    /**
     * Sets the rectangle of interest for storing and returning
     * region bands.  The rectangle is specified as a span array.
     * &lt;p&gt;
     * This method can also be used to initialize a simple rectangular
     * region.
     */
    public void setOutputArea(int box[]) {
<span class="nc" id="L334">        this.lox = box[0];</span>
<span class="nc" id="L335">        this.loy = box[1];</span>
<span class="nc" id="L336">        this.hix = box[2];</span>
<span class="nc" id="L337">        this.hiy = box[3];</span>
<span class="nc" id="L338">    }</span>

    /**
     * Sets the rectangle of interest for storing and returning
     * region bands.  The rectangle is specified in lox, loy,
     * hix, hiy format.
     * &lt;p&gt;
     * This method can also be used to initialize a simple rectangular
     * region.
     */
    public void setOutputAreaXYXY(int lox, int loy, int hix, int hiy) {
<span class="nc" id="L349">        this.lox = lox;</span>
<span class="nc" id="L350">        this.loy = loy;</span>
<span class="nc" id="L351">        this.hix = hix;</span>
<span class="nc" id="L352">        this.hiy = hiy;</span>
<span class="nc" id="L353">    }</span>

    /**
     * Appends the list of spans returned from the indicated
     * SpanIterator.  Each span must be at a higher starting
     * Y coordinate than the previous data or it must have a
     * Y range equal to the highest Y band in the region and a
     * higher X coordinate than any of the spans in that band.
     */
    public void appendSpans(SpanIterator si) {
<span class="nc" id="L363">        int[] box = new int[6];</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">        while (si.nextSpan(box)) {</span>
<span class="nc" id="L366">            appendSpan(box);</span>
        }

<span class="nc" id="L369">        endRow(box);</span>
<span class="nc" id="L370">        calcBBox();</span>
<span class="nc" id="L371">    }</span>

    /**
     * Returns a Region object that represents the same list of rectangles as
     * the current Region object, scaled by the specified sx, sy factors.
     */
    public Region getScaledRegion(final double sx, final double sy) {
<span class="nc bnc" id="L378" title="All 6 branches missed.">        if (sx == 0 || sy == 0 || this == EMPTY_REGION) {</span>
<span class="nc" id="L379">            return EMPTY_REGION;</span>
        }
<span class="nc bnc" id="L381" title="All 6 branches missed.">        if ((sx == 1.0 &amp;&amp; sy == 1.0) || (this == WHOLE_REGION)) {</span>
<span class="nc" id="L382">            return this;</span>
        }

<span class="nc" id="L385">        int tlox = clipScale(lox, sx);</span>
<span class="nc" id="L386">        int tloy = clipScale(loy, sy);</span>
<span class="nc" id="L387">        int thix = clipScale(hix, sx);</span>
<span class="nc" id="L388">        int thiy = clipScale(hiy, sy);</span>
<span class="nc" id="L389">        Region ret = new Region(tlox, tloy, thix, thiy);</span>
<span class="nc" id="L390">        int bands[] = this.bands;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc" id="L392">            int end = endIndex;</span>
<span class="nc" id="L393">            int newbands[] = new int[end];</span>
<span class="nc" id="L394">            int i = 0; // index for source bands</span>
<span class="nc" id="L395">            int j = 0; // index for translated newbands</span>
            int ncol;
<span class="nc bnc" id="L397" title="All 2 branches missed.">            while (i &lt; end) {</span>
                int y1, y2;
<span class="nc" id="L399">                newbands[j++] = y1   = clipScale(bands[i++], sy);</span>
<span class="nc" id="L400">                newbands[j++] = y2   = clipScale(bands[i++], sy);</span>
<span class="nc" id="L401">                newbands[j++] = ncol = bands[i++];</span>
<span class="nc" id="L402">                int savej = j;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (y1 &lt; y2) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    while (--ncol &gt;= 0) {</span>
<span class="nc" id="L405">                        int x1 = clipScale(bands[i++], sx);</span>
<span class="nc" id="L406">                        int x2 = clipScale(bands[i++], sx);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                        if (x1 &lt; x2) {</span>
<span class="nc" id="L408">                            newbands[j++] = x1;</span>
<span class="nc" id="L409">                            newbands[j++] = x2;</span>
                        }
<span class="nc" id="L411">                    }</span>
                } else {
<span class="nc" id="L413">                    i += ncol * 2;</span>
                }
                // Did we get any non-empty bands in this row?
<span class="nc bnc" id="L416" title="All 2 branches missed.">                if (j &gt; savej) {</span>
<span class="nc" id="L417">                    newbands[savej-1] = (j - savej) / 2;</span>
                } else {
<span class="nc" id="L419">                    j = savej - 3;</span>
                }
<span class="nc" id="L421">            }</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (j &lt;= 5) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (j &lt; 5) {</span>
                    // No rows or bands were generated...
<span class="nc" id="L425">                    ret.lox = ret.loy = ret.hix = ret.hiy = 0;</span>
                } else {
                    // Only generated one single rect in the end...
<span class="nc" id="L428">                    ret.loy = newbands[0];</span>
<span class="nc" id="L429">                    ret.hiy = newbands[1];</span>
<span class="nc" id="L430">                    ret.lox = newbands[3];</span>
<span class="nc" id="L431">                    ret.hix = newbands[4];</span>
                }
                // ret.endIndex and ret.bands were never initialized...
                // ret.endIndex = 0;
                // ret.newbands = null;
            } else {
                // Generated multiple bands and/or multiple rows...
<span class="nc" id="L438">                ret.endIndex = j;</span>
<span class="nc" id="L439">                ret.bands = newbands;</span>
            }
        }
<span class="nc" id="L442">        return ret;</span>
    }


    /**
     * Returns a Region object that represents the same list of
     * rectangles as the current Region object, translated by
     * the specified dx, dy translation factors.
     */
    public Region getTranslatedRegion(int dx, int dy) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if ((dx | dy) == 0) {</span>
<span class="nc" id="L453">            return this;</span>
        }
<span class="nc" id="L455">        int tlox = lox + dx;</span>
<span class="nc" id="L456">        int tloy = loy + dy;</span>
<span class="nc" id="L457">        int thix = hix + dx;</span>
<span class="nc" id="L458">        int thiy = hiy + dy;</span>
<span class="nc bnc" id="L459" title="All 24 branches missed.">        if ((tlox &gt; lox) != (dx &gt; 0) ||</span>
            (tloy &gt; loy) != (dy &gt; 0) ||
            (thix &gt; hix) != (dx &gt; 0) ||
            (thiy &gt; hiy) != (dy &gt; 0))
        {
<span class="nc" id="L464">            return getSafeTranslatedRegion(dx, dy);</span>
        }
<span class="nc" id="L466">        Region ret = new Region(tlox, tloy, thix, thiy);</span>
<span class="nc" id="L467">        int bands[] = this.bands;</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc" id="L469">            int end = endIndex;</span>
<span class="nc" id="L470">            ret.endIndex = end;</span>
<span class="nc" id="L471">            int newbands[] = new int[end];</span>
<span class="nc" id="L472">            ret.bands = newbands;</span>
<span class="nc" id="L473">            int i = 0;</span>
            int ncol;
<span class="nc bnc" id="L475" title="All 2 branches missed.">            while (i &lt; end) {</span>
<span class="nc" id="L476">                newbands[i] = bands[i] + dy; i++;</span>
<span class="nc" id="L477">                newbands[i] = bands[i] + dy; i++;</span>
<span class="nc" id="L478">                newbands[i] = ncol = bands[i]; i++;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                while (--ncol &gt;= 0) {</span>
<span class="nc" id="L480">                    newbands[i] = bands[i] + dx; i++;</span>
<span class="nc" id="L481">                    newbands[i] = bands[i] + dx; i++;</span>
                }
            }
        }
<span class="nc" id="L485">        return ret;</span>
    }

    private Region getSafeTranslatedRegion(int dx, int dy) {
<span class="nc" id="L489">        int tlox = clipAdd(lox, dx);</span>
<span class="nc" id="L490">        int tloy = clipAdd(loy, dy);</span>
<span class="nc" id="L491">        int thix = clipAdd(hix, dx);</span>
<span class="nc" id="L492">        int thiy = clipAdd(hiy, dy);</span>
<span class="nc" id="L493">        Region ret = new Region(tlox, tloy, thix, thiy);</span>
<span class="nc" id="L494">        int bands[] = this.bands;</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc" id="L496">            int end = endIndex;</span>
<span class="nc" id="L497">            int newbands[] = new int[end];</span>
<span class="nc" id="L498">            int i = 0; // index for source bands</span>
<span class="nc" id="L499">            int j = 0; // index for translated newbands</span>
            int ncol;
<span class="nc bnc" id="L501" title="All 2 branches missed.">            while (i &lt; end) {</span>
                int y1, y2;
<span class="nc" id="L503">                newbands[j++] = y1   = clipAdd(bands[i++], dy);</span>
<span class="nc" id="L504">                newbands[j++] = y2   = clipAdd(bands[i++], dy);</span>
<span class="nc" id="L505">                newbands[j++] = ncol = bands[i++];</span>
<span class="nc" id="L506">                int savej = j;</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                if (y1 &lt; y2) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                    while (--ncol &gt;= 0) {</span>
<span class="nc" id="L509">                        int x1 = clipAdd(bands[i++], dx);</span>
<span class="nc" id="L510">                        int x2 = clipAdd(bands[i++], dx);</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                        if (x1 &lt; x2) {</span>
<span class="nc" id="L512">                            newbands[j++] = x1;</span>
<span class="nc" id="L513">                            newbands[j++] = x2;</span>
                        }
<span class="nc" id="L515">                    }</span>
                } else {
<span class="nc" id="L517">                    i += ncol * 2;</span>
                }
                // Did we get any non-empty bands in this row?
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (j &gt; savej) {</span>
<span class="nc" id="L521">                    newbands[savej-1] = (j - savej) / 2;</span>
                } else {
<span class="nc" id="L523">                    j = savej - 3;</span>
                }
<span class="nc" id="L525">            }</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (j &lt;= 5) {</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                if (j &lt; 5) {</span>
                    // No rows or bands were generated...
<span class="nc" id="L529">                    ret.lox = ret.loy = ret.hix = ret.hiy = 0;</span>
                } else {
                    // Only generated one single rect in the end...
<span class="nc" id="L532">                    ret.loy = newbands[0];</span>
<span class="nc" id="L533">                    ret.hiy = newbands[1];</span>
<span class="nc" id="L534">                    ret.lox = newbands[3];</span>
<span class="nc" id="L535">                    ret.hix = newbands[4];</span>
                }
                // ret.endIndex and ret.bands were never initialized...
                // ret.endIndex = 0;
                // ret.newbands = null;
            } else {
                // Generated multiple bands and/or multiple rows...
<span class="nc" id="L542">                ret.endIndex = j;</span>
<span class="nc" id="L543">                ret.bands = newbands;</span>
            }
        }
<span class="nc" id="L546">        return ret;</span>
    }

    /**
     * Returns a Region object that represents the intersection of
     * this object with the specified Rectangle.  The return value
     * may be this same object if no clipping occurs.
     */
    public Region getIntersection(Rectangle r) {
<span class="nc" id="L555">        return getIntersectionXYWH(r.x, r.y, r.width, r.height);</span>
    }

    /**
     * Returns a Region object that represents the intersection of
     * this object with the specified rectangular area.  The return
     * value may be this same object if no clipping occurs.
     */
    public Region getIntersectionXYWH(int x, int y, int w, int h) {
<span class="nc" id="L564">        return getIntersectionXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
    }

    /**
     * Returns a Region object that represents the intersection of
     * this object with the specified rectangular area.  The return
     * value may be this same object if no clipping occurs.
     */
    public Region getIntersectionXYXY(int lox, int loy, int hix, int hiy) {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (isInsideXYXY(lox, loy, hix, hiy)) {</span>
<span class="nc" id="L574">            return this;</span>
        }
<span class="nc bnc" id="L576" title="All 8 branches missed.">        Region ret = new Region((lox &lt; this.lox) ? this.lox : lox,</span>
                                (loy &lt; this.loy) ? this.loy : loy,
                                (hix &gt; this.hix) ? this.hix : hix,
                                (hiy &gt; this.hiy) ? this.hiy : hiy);
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc" id="L581">            ret.appendSpans(this.getSpanIterator());</span>
        }
<span class="nc" id="L583">        return ret;</span>
    }

    /**
     * Returns a Region object that represents the intersection of this
     * object with the specified Region object.
     * &lt;p&gt;
     * If {@code A} and {@code B} are both Region Objects and
     * &lt;code&gt;C = A.getIntersection(B);&lt;/code&gt; then a point will
     * be contained in {@code C} iff it is contained in both
     * {@code A} and {@code B}.
     * &lt;p&gt;
     * The return value may be this same object or the argument
     * Region object if no clipping occurs.
     */
    public Region getIntersection(Region r) {
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (this.isInsideQuickCheck(r)) {</span>
<span class="nc" id="L600">            return this;</span>
        }
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (r.isInsideQuickCheck(this)) {</span>
<span class="nc" id="L603">            return r;</span>
        }
<span class="nc bnc" id="L605" title="All 8 branches missed.">        Region ret = new Region((r.lox &lt; this.lox) ? this.lox : r.lox,</span>
                                (r.loy &lt; this.loy) ? this.loy : r.loy,
                                (r.hix &gt; this.hix) ? this.hix : r.hix,
                                (r.hiy &gt; this.hiy) ? this.hiy : r.hiy);
<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (!ret.isEmpty()) {</span>
<span class="nc" id="L610">            ret.filterSpans(this, r, INCLUDE_COMMON);</span>
        }
<span class="nc" id="L612">        return ret;</span>
    }

    /**
     * Returns a Region object that represents the union of this
     * object with the specified Region object.
     * &lt;p&gt;
     * If {@code A} and {@code B} are both Region Objects and
     * &lt;code&gt;C = A.getUnion(B);&lt;/code&gt; then a point will
     * be contained in {@code C} iff it is contained in either
     * {@code A} or {@code B}.
     * &lt;p&gt;
     * The return value may be this same object or the argument
     * Region object if no augmentation occurs.
     */
    public Region getUnion(Region r) {
<span class="nc bnc" id="L628" title="All 4 branches missed.">        if (r.isEmpty() || r.isInsideQuickCheck(this)) {</span>
<span class="nc" id="L629">            return this;</span>
        }
<span class="nc bnc" id="L631" title="All 4 branches missed.">        if (this.isEmpty() || this.isInsideQuickCheck(r)) {</span>
<span class="nc" id="L632">            return r;</span>
        }
<span class="nc bnc" id="L634" title="All 8 branches missed.">        Region ret = new Region((r.lox &gt; this.lox) ? this.lox : r.lox,</span>
                                (r.loy &gt; this.loy) ? this.loy : r.loy,
                                (r.hix &lt; this.hix) ? this.hix : r.hix,
                                (r.hiy &lt; this.hiy) ? this.hiy : r.hiy);
<span class="nc" id="L638">        ret.filterSpans(this, r, INCLUDE_A | INCLUDE_B | INCLUDE_COMMON);</span>
<span class="nc" id="L639">        return ret;</span>
    }

    /**
     * Returns a Region object that represents the difference of the
     * specified Region object subtracted from this object.
     * &lt;p&gt;
     * If {@code A} and {@code B} are both Region Objects and
     * &lt;code&gt;C = A.getDifference(B);&lt;/code&gt; then a point will
     * be contained in {@code C} iff it is contained in
     * {@code A} but not contained in {@code B}.
     * &lt;p&gt;
     * The return value may be this same object or the argument
     * Region object if no clipping occurs.
     */
    public Region getDifference(Region r) {
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (!r.intersectsQuickCheck(this)) {</span>
<span class="nc" id="L656">            return this;</span>
        }
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (this.isInsideQuickCheck(r)) {</span>
<span class="nc" id="L659">            return EMPTY_REGION;</span>
        }
<span class="nc" id="L661">        Region ret = new Region(this.lox, this.loy, this.hix, this.hiy);</span>
<span class="nc" id="L662">        ret.filterSpans(this, r, INCLUDE_A);</span>
<span class="nc" id="L663">        return ret;</span>
    }

    /**
     * Returns a Region object that represents the exclusive or of this
     * object with the specified Region object.
     * &lt;p&gt;
     * If {@code A} and {@code B} are both Region Objects and
     * &lt;code&gt;C = A.getExclusiveOr(B);&lt;/code&gt; then a point will
     * be contained in {@code C} iff it is contained in either
     * {@code A} or {@code B}, but not if it is contained in both.
     * &lt;p&gt;
     * The return value may be this same object or the argument
     * Region object if either is empty.
     */
    public Region getExclusiveOr(Region r) {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (r.isEmpty()) {</span>
<span class="nc" id="L680">            return this;</span>
        }
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (this.isEmpty()) {</span>
<span class="nc" id="L683">            return r;</span>
        }
<span class="nc bnc" id="L685" title="All 8 branches missed.">        Region ret = new Region((r.lox &gt; this.lox) ? this.lox : r.lox,</span>
                                (r.loy &gt; this.loy) ? this.loy : r.loy,
                                (r.hix &lt; this.hix) ? this.hix : r.hix,
                                (r.hiy &lt; this.hiy) ? this.hiy : r.hiy);
<span class="nc" id="L689">        ret.filterSpans(this, r, INCLUDE_A | INCLUDE_B);</span>
<span class="nc" id="L690">        return ret;</span>
    }

    static final int INCLUDE_A      = 1;
    static final int INCLUDE_B      = 2;
    static final int INCLUDE_COMMON = 4;

    private void filterSpans(Region ra, Region rb, int flags) {
<span class="nc" id="L698">        int abands[] = ra.bands;</span>
<span class="nc" id="L699">        int bbands[] = rb.bands;</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (abands == null) {</span>
<span class="nc" id="L701">            abands = new int[] {ra.loy, ra.hiy, 1, ra.lox, ra.hix};</span>
        }
<span class="nc bnc" id="L703" title="All 2 branches missed.">        if (bbands == null) {</span>
<span class="nc" id="L704">            bbands = new int[] {rb.loy, rb.hiy, 1, rb.lox, rb.hix};</span>
        }
<span class="nc" id="L706">        int box[] = new int[6];</span>
<span class="nc" id="L707">        int acolstart = 0;</span>
<span class="nc" id="L708">        int ay1 = abands[acolstart++];</span>
<span class="nc" id="L709">        int ay2 = abands[acolstart++];</span>
<span class="nc" id="L710">        int acolend = abands[acolstart++];</span>
<span class="nc" id="L711">        acolend = acolstart + 2 * acolend;</span>
<span class="nc" id="L712">        int bcolstart = 0;</span>
<span class="nc" id="L713">        int by1 = bbands[bcolstart++];</span>
<span class="nc" id="L714">        int by2 = bbands[bcolstart++];</span>
<span class="nc" id="L715">        int bcolend = bbands[bcolstart++];</span>
<span class="nc" id="L716">        bcolend = bcolstart + 2 * bcolend;</span>
<span class="nc" id="L717">        int y = loy;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        while (y &lt; hiy) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (y &gt;= ay2) {</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                if (acolend &lt; ra.endIndex) {</span>
<span class="nc" id="L721">                    acolstart = acolend;</span>
<span class="nc" id="L722">                    ay1 = abands[acolstart++];</span>
<span class="nc" id="L723">                    ay2 = abands[acolstart++];</span>
<span class="nc" id="L724">                    acolend = abands[acolstart++];</span>
<span class="nc" id="L725">                    acolend = acolstart + 2 * acolend;</span>
                } else {
<span class="nc bnc" id="L727" title="All 2 branches missed.">                    if ((flags &amp; INCLUDE_B) == 0) break;</span>
<span class="nc" id="L728">                    ay1 = ay2 = hiy;</span>
                }
<span class="nc" id="L730">                continue;</span>
            }
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (y &gt;= by2) {</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (bcolend &lt; rb.endIndex) {</span>
<span class="nc" id="L734">                    bcolstart = bcolend;</span>
<span class="nc" id="L735">                    by1 = bbands[bcolstart++];</span>
<span class="nc" id="L736">                    by2 = bbands[bcolstart++];</span>
<span class="nc" id="L737">                    bcolend = bbands[bcolstart++];</span>
<span class="nc" id="L738">                    bcolend = bcolstart + 2 * bcolend;</span>
                } else {
<span class="nc bnc" id="L740" title="All 2 branches missed.">                    if ((flags &amp; INCLUDE_A) == 0) break;</span>
<span class="nc" id="L741">                    by1 = by2 = hiy;</span>
                }
<span class="nc" id="L743">                continue;</span>
            }
            int yend;
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (y &lt; by1) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">                if (y &lt; ay1) {</span>
<span class="nc" id="L748">                    y = Math.min(ay1, by1);</span>
<span class="nc" id="L749">                    continue;</span>
                }
                // We are in a set of rows that belong only to A
<span class="nc" id="L752">                yend = Math.min(ay2, by1);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                if ((flags &amp; INCLUDE_A) != 0) {</span>
<span class="nc" id="L754">                    box[1] = y;</span>
<span class="nc" id="L755">                    box[3] = yend;</span>
<span class="nc" id="L756">                    int acol = acolstart;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">                    while (acol &lt; acolend) {</span>
<span class="nc" id="L758">                        box[0] = abands[acol++];</span>
<span class="nc" id="L759">                        box[2] = abands[acol++];</span>
<span class="nc" id="L760">                        appendSpan(box);</span>
                    }
<span class="nc" id="L762">                }</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            } else if (y &lt; ay1) {</span>
                // We are in a set of rows that belong only to B
<span class="nc" id="L765">                yend = Math.min(by2, ay1);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                if ((flags &amp; INCLUDE_B) != 0) {</span>
<span class="nc" id="L767">                    box[1] = y;</span>
<span class="nc" id="L768">                    box[3] = yend;</span>
<span class="nc" id="L769">                    int bcol = bcolstart;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                    while (bcol &lt; bcolend) {</span>
<span class="nc" id="L771">                        box[0] = bbands[bcol++];</span>
<span class="nc" id="L772">                        box[2] = bbands[bcol++];</span>
<span class="nc" id="L773">                        appendSpan(box);</span>
                    }
<span class="nc" id="L775">                }</span>
            } else {
                // We are in a set of rows that belong to both A and B
<span class="nc" id="L778">                yend = Math.min(ay2, by2);</span>
<span class="nc" id="L779">                box[1] = y;</span>
<span class="nc" id="L780">                box[3] = yend;</span>
<span class="nc" id="L781">                int acol = acolstart;</span>
<span class="nc" id="L782">                int bcol = bcolstart;</span>
<span class="nc" id="L783">                int ax1 = abands[acol++];</span>
<span class="nc" id="L784">                int ax2 = abands[acol++];</span>
<span class="nc" id="L785">                int bx1 = bbands[bcol++];</span>
<span class="nc" id="L786">                int bx2 = bbands[bcol++];</span>
<span class="nc" id="L787">                int x = Math.min(ax1, bx1);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                if (x &lt; lox) x = lox;</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                while (x &lt; hix) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                    if (x &gt;= ax2) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                        if (acol &lt; acolend) {</span>
<span class="nc" id="L792">                            ax1 = abands[acol++];</span>
<span class="nc" id="L793">                            ax2 = abands[acol++];</span>
                        } else {
<span class="nc bnc" id="L795" title="All 2 branches missed.">                            if ((flags &amp; INCLUDE_B) == 0) break;</span>
<span class="nc" id="L796">                            ax1 = ax2 = hix;</span>
                        }
<span class="nc" id="L798">                        continue;</span>
                    }
<span class="nc bnc" id="L800" title="All 2 branches missed.">                    if (x &gt;= bx2) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                        if (bcol &lt; bcolend) {</span>
<span class="nc" id="L802">                            bx1 = bbands[bcol++];</span>
<span class="nc" id="L803">                            bx2 = bbands[bcol++];</span>
                        } else {
<span class="nc bnc" id="L805" title="All 2 branches missed.">                            if ((flags &amp; INCLUDE_A) == 0) break;</span>
<span class="nc" id="L806">                            bx1 = bx2 = hix;</span>
                        }
<span class="nc" id="L808">                        continue;</span>
                    }
                    int xend;
                    boolean appendit;
<span class="nc bnc" id="L812" title="All 2 branches missed.">                    if (x &lt; bx1) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                        if (x &lt; ax1) {</span>
<span class="nc" id="L814">                            xend = Math.min(ax1, bx1);</span>
<span class="nc" id="L815">                            appendit = false;</span>
                        } else {
<span class="nc" id="L817">                            xend = Math.min(ax2, bx1);</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                            appendit = ((flags &amp; INCLUDE_A) != 0);</span>
                        }
<span class="nc bnc" id="L820" title="All 2 branches missed.">                    } else if (x &lt; ax1) {</span>
<span class="nc" id="L821">                        xend = Math.min(ax1, bx2);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                        appendit = ((flags &amp; INCLUDE_B) != 0);</span>
                    } else {
<span class="nc" id="L824">                        xend = Math.min(ax2, bx2);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                        appendit = ((flags &amp; INCLUDE_COMMON) != 0);</span>
                    }
<span class="nc bnc" id="L827" title="All 2 branches missed.">                    if (appendit) {</span>
<span class="nc" id="L828">                        box[0] = x;</span>
<span class="nc" id="L829">                        box[2] = xend;</span>
<span class="nc" id="L830">                        appendSpan(box);</span>
                    }
<span class="nc" id="L832">                    x = xend;</span>
<span class="nc" id="L833">                }</span>
            }
<span class="nc" id="L835">            y = yend;</span>
<span class="nc" id="L836">        }</span>
<span class="nc" id="L837">        endRow(box);</span>
<span class="nc" id="L838">        calcBBox();</span>
<span class="nc" id="L839">    }</span>

    /**
     * Returns a Region object that represents the bounds of the
     * intersection of this object with the bounds of the specified
     * Region object.
     * &lt;p&gt;
     * The return value may be this same object if no clipping occurs
     * and this Region is rectangular.
     */
    public Region getBoundsIntersection(Rectangle r) {
<span class="nc" id="L850">        return getBoundsIntersectionXYWH(r.x, r.y, r.width, r.height);</span>
    }

    /**
     * Returns a Region object that represents the bounds of the
     * intersection of this object with the bounds of the specified
     * rectangular area in x, y, width, height format.
     * &lt;p&gt;
     * The return value may be this same object if no clipping occurs
     * and this Region is rectangular.
     */
    public Region getBoundsIntersectionXYWH(int x, int y, int w, int h) {
<span class="nc" id="L862">        return getBoundsIntersectionXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
    }

    /**
     * Returns a Region object that represents the bounds of the
     * intersection of this object with the bounds of the specified
     * rectangular area in lox, loy, hix, hiy format.
     * &lt;p&gt;
     * The return value may be this same object if no clipping occurs
     * and this Region is rectangular.
     */
    public Region getBoundsIntersectionXYXY(int lox, int loy,
                                            int hix, int hiy)
    {
<span class="nc bnc" id="L876" title="All 10 branches missed.">        if (this.bands == null &amp;&amp;</span>
            this.lox &gt;= lox &amp;&amp; this.loy &gt;= loy &amp;&amp;
            this.hix &lt;= hix &amp;&amp; this.hiy &lt;= hiy)
        {
<span class="nc" id="L880">            return this;</span>
        }
<span class="nc bnc" id="L882" title="All 8 branches missed.">        return new Region((lox &lt; this.lox) ? this.lox : lox,</span>
                          (loy &lt; this.loy) ? this.loy : loy,
                          (hix &gt; this.hix) ? this.hix : hix,
                          (hiy &gt; this.hiy) ? this.hiy : hiy);
    }

    /**
     * Returns a Region object that represents the intersection of
     * this object with the bounds of the specified Region object.
     * &lt;p&gt;
     * The return value may be this same object or the argument
     * Region object if no clipping occurs and the Regions are
     * rectangular.
     */
    public Region getBoundsIntersection(Region r) {
<span class="nc bnc" id="L897" title="All 2 branches missed.">        if (this.encompasses(r)) {</span>
<span class="nc" id="L898">            return r;</span>
        }
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (r.encompasses(this)) {</span>
<span class="nc" id="L901">            return this;</span>
        }
<span class="nc bnc" id="L903" title="All 8 branches missed.">        return new Region((r.lox &lt; this.lox) ? this.lox : r.lox,</span>
                          (r.loy &lt; this.loy) ? this.loy : r.loy,
                          (r.hix &gt; this.hix) ? this.hix : r.hix,
                          (r.hiy &gt; this.hiy) ? this.hiy : r.hiy);
    }

    /**
     * Appends a single span defined by the 4 parameters
     * spanlox, spanloy, spanhix, spanhiy.
     * This span must be at a higher starting Y coordinate than
     * the previous data or it must have a Y range equal to the
     * highest Y band in the region and a higher X coordinate
     * than any of the spans in that band.
     */
    private void appendSpan(int box[]) {
        int spanlox, spanloy, spanhix, spanhiy;
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if ((spanlox = box[0]) &lt; lox) spanlox = lox;</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        if ((spanloy = box[1]) &lt; loy) spanloy = loy;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        if ((spanhix = box[2]) &gt; hix) spanhix = hix;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">        if ((spanhiy = box[3]) &gt; hiy) spanhiy = hiy;</span>
<span class="nc bnc" id="L923" title="All 4 branches missed.">        if (spanhix &lt;= spanlox || spanhiy &lt;= spanloy) {</span>
<span class="nc" id="L924">            return;</span>
        }

<span class="nc" id="L927">        int curYrow = box[4];</span>
<span class="nc bnc" id="L928" title="All 4 branches missed.">        if (endIndex == 0 || spanloy &gt;= bands[curYrow + 1]) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (bands == null) {</span>
<span class="nc" id="L930">                bands = new int[INIT_SIZE];</span>
            } else {
<span class="nc" id="L932">                needSpace(5);</span>
<span class="nc" id="L933">                endRow(box);</span>
<span class="nc" id="L934">                curYrow = box[4];</span>
            }
<span class="nc" id="L936">            bands[endIndex++] = spanloy;</span>
<span class="nc" id="L937">            bands[endIndex++] = spanhiy;</span>
<span class="nc" id="L938">            bands[endIndex++] = 0;</span>
<span class="nc bnc" id="L939" title="All 6 branches missed.">        } else if (spanloy == bands[curYrow] &amp;&amp;</span>
                   spanhiy == bands[curYrow + 1] &amp;&amp;
                   spanlox &gt;= bands[endIndex - 1]) {
<span class="nc bnc" id="L942" title="All 2 branches missed.">            if (spanlox == bands[endIndex - 1]) {</span>
<span class="nc" id="L943">                bands[endIndex - 1] = spanhix;</span>
<span class="nc" id="L944">                return;</span>
            }
<span class="nc" id="L946">            needSpace(2);</span>
        } else {
<span class="nc" id="L948">            throw new InternalError(&quot;bad span&quot;);</span>
        }
<span class="nc" id="L950">        bands[endIndex++] = spanlox;</span>
<span class="nc" id="L951">        bands[endIndex++] = spanhix;</span>
<span class="nc" id="L952">        bands[curYrow + 2]++;</span>
<span class="nc" id="L953">    }</span>

    private void needSpace(int num) {
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (endIndex + num &gt;= bands.length) {</span>
<span class="nc" id="L957">            int[] newbands = new int[bands.length + GROW_SIZE];</span>
<span class="nc" id="L958">            System.arraycopy(bands, 0, newbands, 0, endIndex);</span>
<span class="nc" id="L959">            bands = newbands;</span>
        }
<span class="nc" id="L961">    }</span>

    private void endRow(int box[]) {
<span class="nc" id="L964">        int cur = box[4];</span>
<span class="nc" id="L965">        int prev = box[5];</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (cur &gt; prev) {</span>
<span class="nc" id="L967">            int[] bands = this.bands;</span>
<span class="nc bnc" id="L968" title="All 4 branches missed.">            if (bands[prev + 1] == bands[cur] &amp;&amp;</span>
                bands[prev + 2] == bands[cur + 2])
            {
<span class="nc" id="L971">                int num = bands[cur + 2] * 2;</span>
<span class="nc" id="L972">                cur += 3;</span>
<span class="nc" id="L973">                prev += 3;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">                while (num &gt; 0) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                    if (bands[cur++] != bands[prev++]) {</span>
<span class="nc" id="L976">                        break;</span>
                    }
<span class="nc" id="L978">                    num--;</span>
                }
<span class="nc bnc" id="L980" title="All 2 branches missed.">                if (num == 0) {</span>
                    // prev == box[4]
<span class="nc" id="L982">                    bands[box[5] + 1] = bands[prev + 1];</span>
<span class="nc" id="L983">                    endIndex = prev;</span>
<span class="nc" id="L984">                    return;</span>
                }
            }
        }
<span class="nc" id="L988">        box[5] = box[4];</span>
<span class="nc" id="L989">        box[4] = endIndex;</span>
<span class="nc" id="L990">    }</span>

    private void calcBBox() {
<span class="nc" id="L993">        int[] bands = this.bands;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">        if (endIndex &lt;= 5) {</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">            if (endIndex == 0) {</span>
<span class="nc" id="L996">                lox = loy = hix = hiy = 0;</span>
            } else {
<span class="nc" id="L998">                loy = bands[0];</span>
<span class="nc" id="L999">                hiy = bands[1];</span>
<span class="nc" id="L1000">                lox = bands[3];</span>
<span class="nc" id="L1001">                hix = bands[4];</span>
<span class="nc" id="L1002">                endIndex = 0;</span>
            }
<span class="nc" id="L1004">            this.bands = null;</span>
<span class="nc" id="L1005">            return;</span>
        }
<span class="nc" id="L1007">        int lox = this.hix;</span>
<span class="nc" id="L1008">        int hix = this.lox;</span>
<span class="nc" id="L1009">        int hiyindex = 0;</span>

<span class="nc" id="L1011">        int i = 0;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        while (i &lt; endIndex) {</span>
<span class="nc" id="L1013">            hiyindex = i;</span>
<span class="nc" id="L1014">            int numbands = bands[i + 2];</span>
<span class="nc" id="L1015">            i += 3;</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            if (lox &gt; bands[i]) {</span>
<span class="nc" id="L1017">                lox = bands[i];</span>
            }
<span class="nc" id="L1019">            i += numbands * 2;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">            if (hix &lt; bands[i - 1]) {</span>
<span class="nc" id="L1021">                hix = bands[i - 1];</span>
            }
<span class="nc" id="L1023">        }</span>

<span class="nc" id="L1025">        this.lox = lox;</span>
<span class="nc" id="L1026">        this.loy = bands[0];</span>
<span class="nc" id="L1027">        this.hix = hix;</span>
<span class="nc" id="L1028">        this.hiy = bands[hiyindex + 1];</span>
<span class="nc" id="L1029">    }</span>

    /**
     * Returns the lowest X coordinate in the Region.
     */
    public final int getLoX() {
<span class="nc" id="L1035">        return lox;</span>
    }

    /**
     * Returns the lowest Y coordinate in the Region.
     */
    public final int getLoY() {
<span class="nc" id="L1042">        return loy;</span>
    }

    /**
     * Returns the highest X coordinate in the Region.
     */
    public final int getHiX() {
<span class="nc" id="L1049">        return hix;</span>
    }

    /**
     * Returns the highest Y coordinate in the Region.
     */
    public final int getHiY() {
<span class="nc" id="L1056">        return hiy;</span>
    }

    /**
     * Returns the width of this Region clipped to the range (0 - MAX_INT).
     */
    public final int getWidth() {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (hix &lt; lox) return 0;</span>
        int w;
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if ((w = hix - lox) &lt; 0) {</span>
<span class="nc" id="L1066">            w = Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L1068">        return w;</span>
    }

    /**
     * Returns the height of this Region clipped to the range (0 - MAX_INT).
     */
    public final int getHeight() {
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (hiy &lt; loy) return 0;</span>
        int h;
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if ((h = hiy - loy) &lt; 0) {</span>
<span class="nc" id="L1078">            h = Integer.MAX_VALUE;</span>
        }
<span class="nc" id="L1080">        return h;</span>
    }

    /**
     * Returns true iff this Region encloses no area.
     */
    public boolean isEmpty() {
<span class="nc bnc" id="L1087" title="All 4 branches missed.">        return (hix &lt;= lox || hiy &lt;= loy);</span>
    }

    /**
     * Returns true iff this Region represents a single simple
     * rectangular area.
     */
    public boolean isRectangular() {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">        return (bands == null);</span>
    }

    /**
     * Returns true iff this Region contains the specified coordinate.
     */
    public boolean contains(int x, int y) {
<span class="nc bnc" id="L1102" title="All 8 branches missed.">        if (x &lt; lox || x &gt;= hix || y &lt; loy || y &gt;= hiy) return false;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        if (bands == null) return true;</span>
<span class="nc" id="L1104">        int i = 0;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        while (i &lt; endIndex) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            if (y &lt; bands[i++]) {</span>
<span class="nc" id="L1107">                return false;</span>
            }
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (y &gt;= bands[i++]) {</span>
<span class="nc" id="L1110">                int numspans = bands[i++];</span>
<span class="nc" id="L1111">                i += numspans * 2;</span>
<span class="nc" id="L1112">            } else {</span>
<span class="nc" id="L1113">                int end = bands[i++];</span>
<span class="nc" id="L1114">                end = i + end * 2;</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                while (i &lt; end) {</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                    if (x &lt; bands[i++]) return false;</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                    if (x &lt; bands[i++]) return true;</span>
                }
<span class="nc" id="L1119">                return false;</span>
            }
        }
<span class="nc" id="L1122">        return false;</span>
    }

    /**
     * Returns true iff this Region lies inside the indicated
     * rectangular area specified in x, y, width, height format
     * with appropriate clipping performed as per the dimAdd method.
     */
    public boolean isInsideXYWH(int x, int y, int w, int h) {
<span class="nc" id="L1131">        return isInsideXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
    }

    /**
     * Returns true iff this Region lies inside the indicated
     * rectangular area specified in lox, loy, hix, hiy format.
     */
    public boolean isInsideXYXY(int lox, int loy, int hix, int hiy) {
<span class="nc bnc" id="L1139" title="All 8 branches missed.">        return (this.lox &gt;= lox &amp;&amp; this.loy &gt;= loy &amp;&amp;</span>
                this.hix &lt;= hix &amp;&amp; this.hiy &lt;= hiy);

    }

    /**
     * Quickly checks if this Region lies inside the specified
     * Region object.
     * &lt;p&gt;
     * This method will return false if the specified Region
     * object is not a simple rectangle.
     */
    public boolean isInsideQuickCheck(Region r) {
<span class="nc bnc" id="L1152" title="All 10 branches missed.">        return (r.bands == null &amp;&amp;</span>
                r.lox &lt;= this.lox &amp;&amp; r.loy &lt;= this.loy &amp;&amp;
                r.hix &gt;= this.hix &amp;&amp; r.hiy &gt;= this.hiy);
    }

    /**
     * Quickly checks if this Region intersects the specified
     * rectangular area specified in lox, loy, hix, hiy format.
     * &lt;p&gt;
     * This method tests only against the bounds of this region
     * and does not bother to test if the rectangular region
     * actually intersects any bands.
     */
    public boolean intersectsQuickCheckXYXY(int lox, int loy,
                                            int hix, int hiy)
    {
<span class="nc bnc" id="L1168" title="All 8 branches missed.">        return (hix &gt; this.lox &amp;&amp; lox &lt; this.hix &amp;&amp;</span>
                hiy &gt; this.loy &amp;&amp; loy &lt; this.hiy);
    }

    /**
     * Quickly checks if this Region intersects the specified
     * Region object.
     * &lt;p&gt;
     * This method tests only against the bounds of this region
     * and does not bother to test if the rectangular region
     * actually intersects any bands.
     */
    public boolean intersectsQuickCheck(Region r) {
<span class="nc bnc" id="L1181" title="All 8 branches missed.">        return (r.hix &gt; this.lox &amp;&amp; r.lox &lt; this.hix &amp;&amp;</span>
                r.hiy &gt; this.loy &amp;&amp; r.loy &lt; this.hiy);
    }

    /**
     * Quickly checks if this Region surrounds the specified
     * Region object.
     * &lt;p&gt;
     * This method will return false if this Region object is
     * not a simple rectangle.
     */
    public boolean encompasses(Region r) {
<span class="nc bnc" id="L1193" title="All 10 branches missed.">        return (this.bands == null &amp;&amp;</span>
                this.lox &lt;= r.lox &amp;&amp; this.loy &lt;= r.loy &amp;&amp;
                this.hix &gt;= r.hix &amp;&amp; this.hiy &gt;= r.hiy);
    }

    /**
     * Quickly checks if this Region surrounds the specified
     * rectangular area specified in x, y, width, height format.
     * &lt;p&gt;
     * This method will return false if this Region object is
     * not a simple rectangle.
     */
    public boolean encompassesXYWH(int x, int y, int w, int h) {
<span class="nc" id="L1206">        return encompassesXYXY(x, y, dimAdd(x, w), dimAdd(y, h));</span>
    }

    /**
     * Quickly checks if this Region surrounds the specified
     * rectangular area specified in lox, loy, hix, hiy format.
     * &lt;p&gt;
     * This method will return false if this Region object is
     * not a simple rectangle.
     */
    public boolean encompassesXYXY(int lox, int loy, int hix, int hiy) {
<span class="nc bnc" id="L1217" title="All 10 branches missed.">        return (this.bands == null &amp;&amp;</span>
                this.lox &lt;= lox &amp;&amp; this.loy &lt;= loy &amp;&amp;
                this.hix &gt;= hix &amp;&amp; this.hiy &gt;= hiy);
    }

    /**
     * Gets the bbox of the available spans, clipped to the OutputArea.
     */
    public void getBounds(int pathbox[]) {
<span class="nc" id="L1226">        pathbox[0] = lox;</span>
<span class="nc" id="L1227">        pathbox[1] = loy;</span>
<span class="nc" id="L1228">        pathbox[2] = hix;</span>
<span class="nc" id="L1229">        pathbox[3] = hiy;</span>
<span class="nc" id="L1230">    }</span>

    /**
     * Clips the indicated bbox array to the bounds of this Region.
     */
    public void clipBoxToBounds(int bbox[]) {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        if (bbox[0] &lt; lox) bbox[0] = lox;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">        if (bbox[1] &lt; loy) bbox[1] = loy;</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if (bbox[2] &gt; hix) bbox[2] = hix;</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (bbox[3] &gt; hiy) bbox[3] = hiy;</span>
<span class="nc" id="L1240">    }</span>

    /**
     * Gets an iterator object to iterate over the spans in this region.
     */
    public RegionIterator getIterator() {
<span class="nc" id="L1246">        return new RegionIterator(this);</span>
    }

    /**
     * Gets a span iterator object that iterates over the spans in this region
     */
    public SpanIterator getSpanIterator() {
<span class="nc" id="L1253">        return new RegionSpanIterator(this);</span>
    }

    /**
     * Gets a span iterator object that iterates over the spans in this region
     * but clipped to the bounds given in the argument (xlo, ylo, xhi, yhi).
     */
    public SpanIterator getSpanIterator(int bbox[]) {
<span class="nc" id="L1261">        SpanIterator result = getSpanIterator();</span>
<span class="nc" id="L1262">        result.intersectClipBox(bbox[0], bbox[1], bbox[2], bbox[3]);</span>
<span class="nc" id="L1263">        return result;</span>
    }

    /**
     * Returns a SpanIterator that is the argument iterator filtered by
     * this region.
     */
    public SpanIterator filter(SpanIterator si) {
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if (bands == null) {</span>
<span class="nc" id="L1272">            si.intersectClipBox(lox, loy, hix, hiy);</span>
        } else {
<span class="nc" id="L1274">            si = new RegionClipSpanIterator(this, si);</span>
        }
<span class="nc" id="L1276">        return si;</span>
    }

    public String toString() {
<span class="nc" id="L1280">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L1281">        sb.append(&quot;Region[[&quot;);</span>
<span class="nc" id="L1282">        sb.append(lox);</span>
<span class="nc" id="L1283">        sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1284">        sb.append(loy);</span>
<span class="nc" id="L1285">        sb.append(&quot; =&gt; &quot;);</span>
<span class="nc" id="L1286">        sb.append(hix);</span>
<span class="nc" id="L1287">        sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1288">        sb.append(hiy);</span>
<span class="nc" id="L1289">        sb.append(&quot;]&quot;);</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc" id="L1291">            int col = 0;</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">            while (col &lt; endIndex) {</span>
<span class="nc" id="L1293">                sb.append(&quot;y{&quot;);</span>
<span class="nc" id="L1294">                sb.append(bands[col++]);</span>
<span class="nc" id="L1295">                sb.append(&quot;,&quot;);</span>
<span class="nc" id="L1296">                sb.append(bands[col++]);</span>
<span class="nc" id="L1297">                sb.append(&quot;}[&quot;);</span>
<span class="nc" id="L1298">                int end = bands[col++];</span>
<span class="nc" id="L1299">                end = col + end * 2;</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                while (col &lt; end) {</span>
<span class="nc" id="L1301">                    sb.append(&quot;x(&quot;);</span>
<span class="nc" id="L1302">                    sb.append(bands[col++]);</span>
<span class="nc" id="L1303">                    sb.append(&quot;, &quot;);</span>
<span class="nc" id="L1304">                    sb.append(bands[col++]);</span>
<span class="nc" id="L1305">                    sb.append(&quot;)&quot;);</span>
                }
<span class="nc" id="L1307">                sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1308">            }</span>
        }
<span class="nc" id="L1310">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1311">        return sb.toString();</span>
    }

    public int hashCode() {
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        return (isEmpty() ? 0 : (lox * 3 + loy * 5 + hix * 7 + hiy * 9));</span>
    }

    public boolean equals(Object o) {
<span class="nc bnc" id="L1319" title="All 2 branches missed.">        if (!(o instanceof Region)) {</span>
<span class="nc" id="L1320">            return false;</span>
        }
<span class="nc" id="L1322">        Region r = (Region) o;</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if (this.isEmpty()) {</span>
<span class="nc" id="L1324">            return r.isEmpty();</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">        } else if (r.isEmpty()) {</span>
<span class="nc" id="L1326">            return false;</span>
        }
<span class="nc bnc" id="L1328" title="All 8 branches missed.">        if (r.lox != this.lox || r.loy != this.loy ||</span>
            r.hix != this.hix || r.hiy != this.hiy)
        {
<span class="nc" id="L1331">            return false;</span>
        }
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (this.bands == null) {</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">            return (r.bands == null);</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">        } else if (r.bands == null) {</span>
<span class="nc" id="L1336">            return false;</span>
        }
<span class="nc bnc" id="L1338" title="All 2 branches missed.">        if (this.endIndex != r.endIndex) {</span>
<span class="nc" id="L1339">            return false;</span>
        }
<span class="nc" id="L1341">        int abands[] = this.bands;</span>
<span class="nc" id="L1342">        int bbands[] = r.bands;</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">        for (int i = 0; i &lt; endIndex; i++) {</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">            if (abands[i] != bbands[i]) {</span>
<span class="nc" id="L1345">                return false;</span>
            }
        }
<span class="nc" id="L1348">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>