<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BufferedMaskBlit.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">BufferedMaskBlit.java</span></div><h1>BufferedMaskBlit.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.AlphaComposite;
import java.awt.Composite;
import sun.java2d.SurfaceData;
import sun.java2d.loops.Blit;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.MaskBlit;
import sun.java2d.loops.SurfaceType;
import static sun.java2d.pipe.BufferedOpCodes.*;

/**
 * The MaskBlit operation is expressed as:
 *   dst = ((src &lt;MODE&gt; dst) * pathA) + (dst * (1 - pathA))
 *
 * The OGL/D3D implementation of the MaskBlit operation differs from the above
 * equation because it is not possible to perform such a complex operation in
 * OpenGL/Direct3D (without the use of advanced techniques like fragment
 * shaders and multitexturing).  Therefore, the BufferedMaskBlit operation
 * is expressed as:
 *   dst = (src * pathA) &lt;SrcOver&gt; dst
 *
 * This simplified formula is only equivalent to the &quot;true&quot; MaskBlit equation
 * in the following situations:
 *   - &lt;MODE&gt; is SrcOver
 *   - &lt;MODE&gt; is Src, extra alpha == 1.0, and the source surface is opaque
 *
 * Therefore, we register BufferedMaskBlit primitives for only the SurfaceType
 * and CompositeType restrictions mentioned above.  In addition for the Src
 * case, we must override the composite with a SrcOver (no extra alpha)
 * instance, so that we set up the OpenGL/Direct3D blending mode to match the
 * BufferedMaskBlit equation.
 */
public abstract class BufferedMaskBlit extends MaskBlit {

    private static final int ST_INT_ARGB     = 0;
    private static final int ST_INT_ARGB_PRE = 1;
    private static final int ST_INT_RGB      = 2;
    private static final int ST_INT_BGR      = 3;

    private final RenderQueue rq;
    private final int srcTypeVal;
    private Blit blitop;

    protected BufferedMaskBlit(RenderQueue rq,
                               SurfaceType srcType,
                               CompositeType compType,
                               SurfaceType dstType)
    {
<span class="nc" id="L75">        super(srcType, compType, dstType);</span>
<span class="nc" id="L76">        this.rq = rq;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">        if (srcType == SurfaceType.IntArgb) {</span>
<span class="nc" id="L78">            this.srcTypeVal = ST_INT_ARGB;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        } else if (srcType == SurfaceType.IntArgbPre) {</span>
<span class="nc" id="L80">            this.srcTypeVal = ST_INT_ARGB_PRE;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">        } else if (srcType == SurfaceType.IntRgb) {</span>
<span class="nc" id="L82">            this.srcTypeVal = ST_INT_RGB;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        } else if (srcType == SurfaceType.IntBgr) {</span>
<span class="nc" id="L84">            this.srcTypeVal = ST_INT_BGR;</span>
        } else {
<span class="nc" id="L86">            throw new InternalError(&quot;unrecognized source surface type&quot;);</span>
        }
<span class="nc" id="L88">    }</span>

    @Override
    public void MaskBlit(SurfaceData src, SurfaceData dst,
                         Composite comp, Region clip,
                         int srcx, int srcy,
                         int dstx, int dsty,
                         int width, int height,
                         byte[] mask, int maskoff, int maskscan)
    {
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L99">            return;</span>
        }

<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (mask == null) {</span>
            // no mask involved; delegate to regular blit loop
<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (blitop == null) {</span>
<span class="nc" id="L105">                blitop = Blit.getFromCache(src.getSurfaceType(),</span>
                                           CompositeType.AnyAlpha,
<span class="nc" id="L107">                                           this.getDestType());</span>
            }
<span class="nc" id="L109">            blitop.Blit(src, dst,</span>
                        comp, clip,
                        srcx, srcy, dstx, dsty,
                        width, height);
<span class="nc" id="L113">            return;</span>
        }

<span class="nc" id="L116">        AlphaComposite acomp = (AlphaComposite)comp;</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (acomp.getRule() != AlphaComposite.SRC_OVER) {</span>
<span class="nc" id="L118">            comp = AlphaComposite.SrcOver;</span>
        }

<span class="nc" id="L121">        rq.lock();</span>
        try {
<span class="nc" id="L123">            validateContext(dst, comp, clip);</span>

<span class="nc" id="L125">            RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L126">            int totalBytesRequired = 20 + (width * height * 4);</span>

            /*
             * REMIND: we should fix this so that it works with tiles that
             *         are larger than the entire buffer, but the native
             *         OGL/D3DMaskBlit isn't even prepared for tiles larger
             *         than 32x32 pixels, so there's no urgency here...
             */
<span class="nc" id="L134">            rq.ensureCapacity(totalBytesRequired);</span>

            // enqueue parameters and tile pixels
<span class="nc" id="L137">            int newpos = enqueueTile(buf.getAddress(), buf.position(),</span>
<span class="nc" id="L138">                                     src, src.getNativeOps(), srcTypeVal,</span>
                                     mask, mask.length, maskoff, maskscan,
                                     srcx, srcy, dstx, dsty,
                                     width, height);

<span class="nc" id="L143">            buf.position(newpos);</span>
        } finally {
<span class="nc" id="L145">            rq.unlock();</span>
<span class="nc" id="L146">        }</span>
<span class="nc" id="L147">    }</span>

    private native int enqueueTile(long buf, int bpos,
                                   SurfaceData srcData,
                                   long pSrcOps, int srcType,
                                   byte[] mask, int masklen,
                                   int maskoff, int maskscan,
                                   int srcx, int srcy, int dstx, int dsty,
                                   int width, int height);

    /**
     * Validates the context state using the given destination surface
     * and composite/clip values.
     */
    protected abstract void validateContext(SurfaceData dstData,
                                            Composite comp, Region clip);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>