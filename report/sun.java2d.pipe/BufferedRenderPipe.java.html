<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BufferedRenderPipe.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">BufferedRenderPipe.java</span></div><h1>BufferedRenderPipe.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.BasicStroke;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.awt.geom.IllegalPathStateException;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import sun.java2d.SunGraphics2D;
import sun.java2d.loops.ProcessPath;
import static sun.java2d.pipe.BufferedOpCodes.*;

/**
 * Base class for enqueuing rendering operations in a single-threaded
 * rendering environment.  Instead of each operation being rendered
 * immediately by the underlying graphics library, the operation will be
 * added to the provided RenderQueue, which will be processed at a later
 * time by a single thread.
 *
 * This class provides implementations of drawLine(), drawRect(), drawPoly(),
 * fillRect(), draw(Shape), and fill(Shape), which are useful for a
 * hardware-accelerated renderer.  The other draw*() and fill*() methods
 * simply delegate to draw(Shape) and fill(Shape), respectively.
 */
public abstract class BufferedRenderPipe
    implements PixelDrawPipe, PixelFillPipe, ShapeDrawPipe, ParallelogramPipe
{
<span class="nc" id="L58">    ParallelogramPipe aapgrampipe = new AAParallelogramPipe();</span>

    static final int BYTES_PER_POLY_POINT = 8;
    static final int BYTES_PER_SCANLINE = 12;
    static final int BYTES_PER_SPAN = 16;

    protected RenderQueue rq;
    protected RenderBuffer buf;
    private BufferedDrawHandler drawHandler;

<span class="nc" id="L68">    public BufferedRenderPipe(RenderQueue rq) {</span>
<span class="nc" id="L69">        this.rq = rq;</span>
<span class="nc" id="L70">        this.buf = rq.getBuffer();</span>
<span class="nc" id="L71">        this.drawHandler = new BufferedDrawHandler();</span>
<span class="nc" id="L72">    }</span>

    public ParallelogramPipe getAAParallelogramPipe() {
<span class="nc" id="L75">        return aapgrampipe;</span>
    }

    /**
     * Validates the state in the provided SunGraphics2D object and sets up
     * any special resources for this operation (e.g. enabling gradient
     * shading).
     */
    protected abstract void validateContext(SunGraphics2D sg2d);
    protected abstract void validateContextAA(SunGraphics2D sg2d);

    public void drawLine(SunGraphics2D sg2d,
                         int x1, int y1, int x2, int y2)
    {
<span class="nc" id="L89">        int transx = sg2d.transX;</span>
<span class="nc" id="L90">        int transy = sg2d.transY;</span>
<span class="nc" id="L91">        rq.lock();</span>
        try {
<span class="nc" id="L93">            validateContext(sg2d);</span>
<span class="nc" id="L94">            rq.ensureCapacity(20);</span>
<span class="nc" id="L95">            buf.putInt(DRAW_LINE);</span>
<span class="nc" id="L96">            buf.putInt(x1 + transx);</span>
<span class="nc" id="L97">            buf.putInt(y1 + transy);</span>
<span class="nc" id="L98">            buf.putInt(x2 + transx);</span>
<span class="nc" id="L99">            buf.putInt(y2 + transy);</span>
        } finally {
<span class="nc" id="L101">            rq.unlock();</span>
<span class="nc" id="L102">        }</span>
<span class="nc" id="L103">    }</span>

    public void drawRect(SunGraphics2D sg2d,
                         int x, int y, int width, int height)
    {
<span class="nc" id="L108">        rq.lock();</span>
        try {
<span class="nc" id="L110">            validateContext(sg2d);</span>
<span class="nc" id="L111">            rq.ensureCapacity(20);</span>
<span class="nc" id="L112">            buf.putInt(DRAW_RECT);</span>
<span class="nc" id="L113">            buf.putInt(x + sg2d.transX);</span>
<span class="nc" id="L114">            buf.putInt(y + sg2d.transY);</span>
<span class="nc" id="L115">            buf.putInt(width);</span>
<span class="nc" id="L116">            buf.putInt(height);</span>
        } finally {
<span class="nc" id="L118">            rq.unlock();</span>
<span class="nc" id="L119">        }</span>
<span class="nc" id="L120">    }</span>

    public void fillRect(SunGraphics2D sg2d,
                         int x, int y, int width, int height)
    {
<span class="nc" id="L125">        rq.lock();</span>
        try {
<span class="nc" id="L127">            validateContext(sg2d);</span>
<span class="nc" id="L128">            rq.ensureCapacity(20);</span>
<span class="nc" id="L129">            buf.putInt(FILL_RECT);</span>
<span class="nc" id="L130">            buf.putInt(x + sg2d.transX);</span>
<span class="nc" id="L131">            buf.putInt(y + sg2d.transY);</span>
<span class="nc" id="L132">            buf.putInt(width);</span>
<span class="nc" id="L133">            buf.putInt(height);</span>
        } finally {
<span class="nc" id="L135">            rq.unlock();</span>
<span class="nc" id="L136">        }</span>
<span class="nc" id="L137">    }</span>

    public void drawRoundRect(SunGraphics2D sg2d,
                              int x, int y, int width, int height,
                              int arcWidth, int arcHeight)
    {
<span class="nc" id="L143">        draw(sg2d, new RoundRectangle2D.Float(x, y, width, height,</span>
                                              arcWidth, arcHeight));
<span class="nc" id="L145">    }</span>

    public void fillRoundRect(SunGraphics2D sg2d,
                              int x, int y, int width, int height,
                              int arcWidth, int arcHeight)
    {
<span class="nc" id="L151">        fill(sg2d, new RoundRectangle2D.Float(x, y, width, height,</span>
                                              arcWidth, arcHeight));
<span class="nc" id="L153">    }</span>

    public void drawOval(SunGraphics2D sg2d,
                         int x, int y, int width, int height)
    {
<span class="nc" id="L158">        draw(sg2d, new Ellipse2D.Float(x, y, width, height));</span>
<span class="nc" id="L159">    }</span>

    public void fillOval(SunGraphics2D sg2d,
                         int x, int y, int width, int height)
    {
<span class="nc" id="L164">        fill(sg2d, new Ellipse2D.Float(x, y, width, height));</span>
<span class="nc" id="L165">    }</span>

    public void drawArc(SunGraphics2D sg2d,
                        int x, int y, int width, int height,
                        int startAngle, int arcAngle)
    {
<span class="nc" id="L171">        draw(sg2d, new Arc2D.Float(x, y, width, height,</span>
                                   startAngle, arcAngle,
                                   Arc2D.OPEN));
<span class="nc" id="L174">    }</span>

    public void fillArc(SunGraphics2D sg2d,
                        int x, int y, int width, int height,
                        int startAngle, int arcAngle)
    {
<span class="nc" id="L180">        fill(sg2d, new Arc2D.Float(x, y, width, height,</span>
                                   startAngle, arcAngle,
                                   Arc2D.PIE));
<span class="nc" id="L183">    }</span>

    protected void drawPoly(final SunGraphics2D sg2d,
                            final int[] xPoints, final int[] yPoints,
                            final int nPoints, final boolean isClosed)
    {
<span class="nc bnc" id="L189" title="All 4 branches missed.">        if (xPoints == null || yPoints == null) {</span>
<span class="nc" id="L190">            throw new NullPointerException(&quot;coordinate array&quot;);</span>
        }
<span class="nc bnc" id="L192" title="All 4 branches missed.">        if (xPoints.length &lt; nPoints || yPoints.length &lt; nPoints) {</span>
<span class="nc" id="L193">            throw new ArrayIndexOutOfBoundsException(&quot;coordinate array&quot;);</span>
        }

<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (nPoints &lt; 2) {</span>
            // render nothing
<span class="nc" id="L198">            return;</span>
<span class="nc bnc" id="L199" title="All 4 branches missed.">        } else if (nPoints == 2 &amp;&amp; !isClosed) {</span>
            // render a simple line
<span class="nc" id="L201">            drawLine(sg2d, xPoints[0], yPoints[0], xPoints[1], yPoints[1]);</span>
<span class="nc" id="L202">            return;</span>
        }

<span class="nc" id="L205">        rq.lock();</span>
        try {
<span class="nc" id="L207">            validateContext(sg2d);</span>

<span class="nc" id="L209">            int pointBytesRequired = nPoints * BYTES_PER_POLY_POINT;</span>
<span class="nc" id="L210">            int totalBytesRequired = 20 + pointBytesRequired;</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (totalBytesRequired &lt;= buf.capacity()) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (totalBytesRequired &gt; buf.remaining()) {</span>
                    // process the queue first and then enqueue the points
<span class="nc" id="L215">                    rq.flushNow();</span>
                }
<span class="nc" id="L217">                buf.putInt(DRAW_POLY);</span>
                // enqueue parameters
<span class="nc" id="L219">                buf.putInt(nPoints);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                buf.putInt(isClosed ? 1 : 0);</span>
<span class="nc" id="L221">                buf.putInt(sg2d.transX);</span>
<span class="nc" id="L222">                buf.putInt(sg2d.transY);</span>
                // enqueue the points
<span class="nc" id="L224">                buf.put(xPoints, 0, nPoints);</span>
<span class="nc" id="L225">                buf.put(yPoints, 0, nPoints);</span>
            } else {
                // queue is too small to accommodate all points; perform the
                // operation directly on the queue flushing thread
<span class="nc" id="L229">                rq.flushAndInvokeNow(new Runnable() {</span>
                    public void run() {
<span class="nc" id="L231">                        drawPoly(xPoints, yPoints,</span>
                                 nPoints, isClosed,
                                 sg2d.transX, sg2d.transY);
<span class="nc" id="L234">                    }</span>
                });
            }
        } finally {
<span class="nc" id="L238">            rq.unlock();</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">    }</span>

    protected abstract void drawPoly(int[] xPoints, int[] yPoints,
                                     int nPoints, boolean isClosed,
                                     int transX, int transY);

    public void drawPolyline(SunGraphics2D sg2d,
                             int[] xPoints, int[] yPoints,
                             int nPoints)
    {
<span class="nc" id="L250">        drawPoly(sg2d, xPoints, yPoints, nPoints, false);</span>
<span class="nc" id="L251">    }</span>

    public void drawPolygon(SunGraphics2D sg2d,
                            int[] xPoints, int[] yPoints,
                            int nPoints)
    {
<span class="nc" id="L257">        drawPoly(sg2d, xPoints, yPoints, nPoints, true);</span>
<span class="nc" id="L258">    }</span>

    public void fillPolygon(SunGraphics2D sg2d,
                            int[] xPoints, int[] yPoints,
                            int nPoints)
    {
<span class="nc" id="L264">        fill(sg2d, new Polygon(xPoints, yPoints, nPoints));</span>
<span class="nc" id="L265">    }</span>

    private class BufferedDrawHandler
        extends ProcessPath.DrawHandler
    {
<span class="nc" id="L270">        BufferedDrawHandler() {</span>
            // these are bogus values; the caller will use validate()
            // to ensure that they are set properly prior to each usage
<span class="nc" id="L273">            super(0, 0, 0, 0);</span>
<span class="nc" id="L274">        }</span>

        /**
         * This method needs to be called prior to each draw/fillPath()
         * operation to ensure the clip bounds are up to date.
         */
        void validate(SunGraphics2D sg2d) {
<span class="nc" id="L281">            Region clip = sg2d.getCompClip();</span>
<span class="nc" id="L282">            setBounds(clip.getLoX(), clip.getLoY(),</span>
<span class="nc" id="L283">                      clip.getHiX(), clip.getHiY(),</span>
                      sg2d.strokeHint);
<span class="nc" id="L285">        }</span>

        /**
         * drawPath() support...
         */

        public void drawLine(int x1, int y1, int x2, int y2) {
            // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L293">            rq.ensureCapacity(20);</span>
<span class="nc" id="L294">            buf.putInt(DRAW_LINE);</span>
<span class="nc" id="L295">            buf.putInt(x1);</span>
<span class="nc" id="L296">            buf.putInt(y1);</span>
<span class="nc" id="L297">            buf.putInt(x2);</span>
<span class="nc" id="L298">            buf.putInt(y2);</span>
<span class="nc" id="L299">        }</span>

        public void drawPixel(int x, int y) {
            // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L303">            rq.ensureCapacity(12);</span>
<span class="nc" id="L304">            buf.putInt(DRAW_PIXEL);</span>
<span class="nc" id="L305">            buf.putInt(x);</span>
<span class="nc" id="L306">            buf.putInt(y);</span>
<span class="nc" id="L307">        }</span>

        /**
         * fillPath() support...
         */

        private int scanlineCount;
        private int scanlineCountIndex;
        private int remainingScanlines;

        private void resetFillPath() {
<span class="nc" id="L318">            buf.putInt(DRAW_SCANLINES);</span>
<span class="nc" id="L319">            scanlineCountIndex = buf.position();</span>
<span class="nc" id="L320">            buf.putInt(0);</span>
<span class="nc" id="L321">            scanlineCount = 0;</span>
<span class="nc" id="L322">            remainingScanlines = buf.remaining() / BYTES_PER_SCANLINE;</span>
<span class="nc" id="L323">        }</span>

        private void updateScanlineCount() {
<span class="nc" id="L326">            buf.putInt(scanlineCountIndex, scanlineCount);</span>
<span class="nc" id="L327">        }</span>

        /**
         * Called from fillPath() to indicate that we are about to
         * start issuing drawScanline() calls.
         */
        public void startFillPath() {
<span class="nc" id="L334">            rq.ensureCapacity(20); // to ensure room for at least a scanline</span>
<span class="nc" id="L335">            resetFillPath();</span>
<span class="nc" id="L336">        }</span>

        public void drawScanline(int x1, int x2, int y) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (remainingScanlines == 0) {</span>
<span class="nc" id="L340">                updateScanlineCount();</span>
<span class="nc" id="L341">                rq.flushNow();</span>
<span class="nc" id="L342">                resetFillPath();</span>
            }
<span class="nc" id="L344">            buf.putInt(x1);</span>
<span class="nc" id="L345">            buf.putInt(x2);</span>
<span class="nc" id="L346">            buf.putInt(y);</span>
<span class="nc" id="L347">            scanlineCount++;</span>
<span class="nc" id="L348">            remainingScanlines--;</span>
<span class="nc" id="L349">        }</span>

        /**
         * Called from fillPath() to indicate that we are done
         * issuing drawScanline() calls.
         */
        public void endFillPath() {
<span class="nc" id="L356">            updateScanlineCount();</span>
<span class="nc" id="L357">        }</span>
    }

    protected void drawPath(SunGraphics2D sg2d,
                            Path2D.Float p2df, int transx, int transy)
    {
<span class="nc" id="L363">        rq.lock();</span>
        try {
<span class="nc" id="L365">            validateContext(sg2d);</span>
<span class="nc" id="L366">            drawHandler.validate(sg2d);</span>
<span class="nc" id="L367">            ProcessPath.drawPath(drawHandler, p2df, transx, transy);</span>
        } finally {
<span class="nc" id="L369">            rq.unlock();</span>
<span class="nc" id="L370">        }</span>
<span class="nc" id="L371">    }</span>

    protected void fillPath(SunGraphics2D sg2d,
                            Path2D.Float p2df, int transx, int transy)
    {
<span class="nc" id="L376">        rq.lock();</span>
        try {
<span class="nc" id="L378">            validateContext(sg2d);</span>
<span class="nc" id="L379">            drawHandler.validate(sg2d);</span>
<span class="nc" id="L380">            drawHandler.startFillPath();</span>
<span class="nc" id="L381">            ProcessPath.fillPath(drawHandler, p2df, transx, transy);</span>
<span class="nc" id="L382">            drawHandler.endFillPath();</span>
        } finally {
<span class="nc" id="L384">            rq.unlock();</span>
<span class="nc" id="L385">        }</span>
<span class="nc" id="L386">    }</span>

    private native int fillSpans(RenderQueue rq, long buf,
                                 int pos, int limit,
                                 SpanIterator si, long iterator,
                                 int transx, int transy);

    protected void fillSpans(SunGraphics2D sg2d, SpanIterator si,
                             int transx, int transy)
    {
<span class="nc" id="L396">        rq.lock();</span>
        try {
<span class="nc" id="L398">            validateContext(sg2d);</span>
<span class="nc" id="L399">            rq.ensureCapacity(24); // so that we have room for at least a span</span>
<span class="nc" id="L400">            int newpos = fillSpans(rq, buf.getAddress(),</span>
<span class="nc" id="L401">                                   buf.position(), buf.capacity(),</span>
<span class="nc" id="L402">                                   si, si.getNativeIterator(),</span>
                                   transx, transy);
<span class="nc" id="L404">            buf.position(newpos);</span>
        } finally {
<span class="nc" id="L406">            rq.unlock();</span>
<span class="nc" id="L407">        }</span>
<span class="nc" id="L408">    }</span>

    public void fillParallelogram(SunGraphics2D sg2d,
                                  double ux1, double uy1,
                                  double ux2, double uy2,
                                  double x, double y,
                                  double dx1, double dy1,
                                  double dx2, double dy2)
    {
<span class="nc" id="L417">        rq.lock();</span>
        try {
<span class="nc" id="L419">            validateContext(sg2d);</span>
<span class="nc" id="L420">            rq.ensureCapacity(28);</span>
<span class="nc" id="L421">            buf.putInt(FILL_PARALLELOGRAM);</span>
<span class="nc" id="L422">            buf.putFloat((float) x);</span>
<span class="nc" id="L423">            buf.putFloat((float) y);</span>
<span class="nc" id="L424">            buf.putFloat((float) dx1);</span>
<span class="nc" id="L425">            buf.putFloat((float) dy1);</span>
<span class="nc" id="L426">            buf.putFloat((float) dx2);</span>
<span class="nc" id="L427">            buf.putFloat((float) dy2);</span>
        } finally {
<span class="nc" id="L429">            rq.unlock();</span>
<span class="nc" id="L430">        }</span>
<span class="nc" id="L431">    }</span>

    public void drawParallelogram(SunGraphics2D sg2d,
                                  double ux1, double uy1,
                                  double ux2, double uy2,
                                  double x, double y,
                                  double dx1, double dy1,
                                  double dx2, double dy2,
                                  double lw1, double lw2)
    {
<span class="nc" id="L441">        rq.lock();</span>
        try {
<span class="nc" id="L443">            validateContext(sg2d);</span>
<span class="nc" id="L444">            rq.ensureCapacity(36);</span>
<span class="nc" id="L445">            buf.putInt(DRAW_PARALLELOGRAM);</span>
<span class="nc" id="L446">            buf.putFloat((float) x);</span>
<span class="nc" id="L447">            buf.putFloat((float) y);</span>
<span class="nc" id="L448">            buf.putFloat((float) dx1);</span>
<span class="nc" id="L449">            buf.putFloat((float) dy1);</span>
<span class="nc" id="L450">            buf.putFloat((float) dx2);</span>
<span class="nc" id="L451">            buf.putFloat((float) dy2);</span>
<span class="nc" id="L452">            buf.putFloat((float) lw1);</span>
<span class="nc" id="L453">            buf.putFloat((float) lw2);</span>
        } finally {
<span class="nc" id="L455">            rq.unlock();</span>
<span class="nc" id="L456">        }</span>
<span class="nc" id="L457">    }</span>

<span class="nc" id="L459">    private class AAParallelogramPipe implements ParallelogramPipe {</span>
        public void fillParallelogram(SunGraphics2D sg2d,
                                      double ux1, double uy1,
                                      double ux2, double uy2,
                                      double x, double y,
                                      double dx1, double dy1,
                                      double dx2, double dy2)
        {
<span class="nc" id="L467">            rq.lock();</span>
            try {
<span class="nc" id="L469">                validateContextAA(sg2d);</span>
<span class="nc" id="L470">                rq.ensureCapacity(28);</span>
<span class="nc" id="L471">                buf.putInt(FILL_AAPARALLELOGRAM);</span>
<span class="nc" id="L472">                buf.putFloat((float) x);</span>
<span class="nc" id="L473">                buf.putFloat((float) y);</span>
<span class="nc" id="L474">                buf.putFloat((float) dx1);</span>
<span class="nc" id="L475">                buf.putFloat((float) dy1);</span>
<span class="nc" id="L476">                buf.putFloat((float) dx2);</span>
<span class="nc" id="L477">                buf.putFloat((float) dy2);</span>
            } finally {
<span class="nc" id="L479">                rq.unlock();</span>
<span class="nc" id="L480">            }</span>
<span class="nc" id="L481">        }</span>

        public void drawParallelogram(SunGraphics2D sg2d,
                                      double ux1, double uy1,
                                      double ux2, double uy2,
                                      double x, double y,
                                      double dx1, double dy1,
                                      double dx2, double dy2,
                                      double lw1, double lw2)
        {
<span class="nc" id="L491">            rq.lock();</span>
            try {
<span class="nc" id="L493">                validateContextAA(sg2d);</span>
<span class="nc" id="L494">                rq.ensureCapacity(36);</span>
<span class="nc" id="L495">                buf.putInt(DRAW_AAPARALLELOGRAM);</span>
<span class="nc" id="L496">                buf.putFloat((float) x);</span>
<span class="nc" id="L497">                buf.putFloat((float) y);</span>
<span class="nc" id="L498">                buf.putFloat((float) dx1);</span>
<span class="nc" id="L499">                buf.putFloat((float) dy1);</span>
<span class="nc" id="L500">                buf.putFloat((float) dx2);</span>
<span class="nc" id="L501">                buf.putFloat((float) dy2);</span>
<span class="nc" id="L502">                buf.putFloat((float) lw1);</span>
<span class="nc" id="L503">                buf.putFloat((float) lw2);</span>
            } finally {
<span class="nc" id="L505">                rq.unlock();</span>
<span class="nc" id="L506">            }</span>
<span class="nc" id="L507">        }</span>
    }

    public void draw(SunGraphics2D sg2d, Shape s) {
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (sg2d.strokeState == SunGraphics2D.STROKE_THIN) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (s instanceof Polygon) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if (sg2d.transformState &lt; SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L514">                    Polygon p = (Polygon)s;</span>
<span class="nc" id="L515">                    drawPolygon(sg2d, p.xpoints, p.ypoints, p.npoints);</span>
<span class="nc" id="L516">                    return;</span>
                }
            }
            Path2D.Float p2df;
            int transx, transy;
<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (sg2d.transformState &lt;= SunGraphics2D.TRANSFORM_INT_TRANSLATE) {</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (s instanceof Path2D.Float) {</span>
<span class="nc" id="L523">                    p2df = (Path2D.Float)s;</span>
                } else {
<span class="nc" id="L525">                    p2df = new Path2D.Float(s);</span>
                }
<span class="nc" id="L527">                transx = sg2d.transX;</span>
<span class="nc" id="L528">                transy = sg2d.transY;</span>
            } else {
<span class="nc" id="L530">                p2df = new Path2D.Float(s, sg2d.transform);</span>
<span class="nc" id="L531">                transx = 0;</span>
<span class="nc" id="L532">                transy = 0;</span>
            }
<span class="nc" id="L534">            drawPath(sg2d, p2df, transx, transy);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">        } else if (sg2d.strokeState &lt; SunGraphics2D.STROKE_CUSTOM) {</span>
<span class="nc" id="L536">            ShapeSpanIterator si = LoopPipe.getStrokeSpans(sg2d, s);</span>
            try {
<span class="nc" id="L538">                fillSpans(sg2d, si, 0, 0);</span>
            } finally {
<span class="nc" id="L540">                si.dispose();</span>
<span class="nc" id="L541">            }</span>
<span class="nc" id="L542">        } else {</span>
<span class="nc" id="L543">            fill(sg2d, sg2d.stroke.createStrokedShape(s));</span>
        }
<span class="nc" id="L545">    }</span>

    public void fill(SunGraphics2D sg2d, Shape s) {
        int transx, transy;

<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (sg2d.strokeState == SunGraphics2D.STROKE_THIN) {</span>
            // Here we are able to use fillPath() for
            // high-quality fills.
            Path2D.Float p2df;
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (sg2d.transformState &lt;= SunGraphics2D.TRANSFORM_INT_TRANSLATE) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                if (s instanceof Path2D.Float) {</span>
<span class="nc" id="L556">                    p2df = (Path2D.Float)s;</span>
                } else {
<span class="nc" id="L558">                    p2df = new Path2D.Float(s);</span>
                }
<span class="nc" id="L560">                transx = sg2d.transX;</span>
<span class="nc" id="L561">                transy = sg2d.transY;</span>
            } else {
<span class="nc" id="L563">                p2df = new Path2D.Float(s, sg2d.transform);</span>
<span class="nc" id="L564">                transx = 0;</span>
<span class="nc" id="L565">                transy = 0;</span>
            }
<span class="nc" id="L567">            fillPath(sg2d, p2df, transx, transy);</span>
<span class="nc" id="L568">            return;</span>
        }

        AffineTransform at;
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (sg2d.transformState &lt;= SunGraphics2D.TRANSFORM_INT_TRANSLATE) {</span>
            // Transform (translation) will be done by FillSpans (we could
            // delegate to fillPolygon() here, but most hardware accelerated
            // libraries cannot handle non-convex polygons, so we will use
            // the FillSpans approach by default)
<span class="nc" id="L577">            at = null;</span>
<span class="nc" id="L578">            transx = sg2d.transX;</span>
<span class="nc" id="L579">            transy = sg2d.transY;</span>
        } else {
            // Transform will be done by the PathIterator
<span class="nc" id="L582">            at = sg2d.transform;</span>
<span class="nc" id="L583">            transx = transy = 0;</span>
        }

<span class="nc" id="L586">        ShapeSpanIterator ssi = LoopPipe.getFillSSI(sg2d);</span>
        try {
            // Subtract transx/y from the SSI clip to match the
            // (potentially untranslated) geometry fed to it
<span class="nc" id="L590">            Region clip = sg2d.getCompClip();</span>
<span class="nc" id="L591">            ssi.setOutputAreaXYXY(clip.getLoX() - transx,</span>
<span class="nc" id="L592">                                  clip.getLoY() - transy,</span>
<span class="nc" id="L593">                                  clip.getHiX() - transx,</span>
<span class="nc" id="L594">                                  clip.getHiY() - transy);</span>
<span class="nc" id="L595">            ssi.appendPath(s.getPathIterator(at));</span>
<span class="nc" id="L596">            fillSpans(sg2d, ssi, transx, transy);</span>
        } finally {
<span class="nc" id="L598">            ssi.dispose();</span>
<span class="nc" id="L599">        }</span>
<span class="nc" id="L600">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>