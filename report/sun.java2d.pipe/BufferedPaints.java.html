<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BufferedPaints.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">BufferedPaints.java</span></div><h1>BufferedPaints.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.Color;
import java.awt.GradientPaint;
import java.awt.LinearGradientPaint;
import java.awt.MultipleGradientPaint;
import java.awt.MultipleGradientPaint.ColorSpaceType;
import java.awt.MultipleGradientPaint.CycleMethod;
import java.awt.Paint;
import java.awt.RadialGradientPaint;
import java.awt.TexturePaint;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import sun.awt.image.PixelConverter;
import sun.java2d.SunGraphics2D;
import sun.java2d.SurfaceData;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.SurfaceType;
import static sun.java2d.pipe.BufferedOpCodes.*;

import java.lang.annotation.Native;

<span class="nc" id="L51">public class BufferedPaints {</span>

    static void setPaint(RenderQueue rq, SunGraphics2D sg2d,
                         Paint paint, int ctxflags)
    {
<span class="nc bnc" id="L56" title="All 2 branches missed.">        if (sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR) {</span>
<span class="nc" id="L57">            setColor(rq, sg2d.pixel);</span>
        } else {
<span class="nc bnc" id="L59" title="All 2 branches missed.">            boolean useMask = (ctxflags &amp; BufferedContext.USE_MASK) != 0;</span>
<span class="nc bnc" id="L60" title="All 5 branches missed.">            switch (sg2d.paintState) {</span>
            case SunGraphics2D.PAINT_GRADIENT:
<span class="nc" id="L62">                setGradientPaint(rq, sg2d,</span>
                                 (GradientPaint)paint, useMask);
<span class="nc" id="L64">                break;</span>
            case SunGraphics2D.PAINT_LIN_GRADIENT:
<span class="nc" id="L66">                setLinearGradientPaint(rq, sg2d,</span>
                                       (LinearGradientPaint)paint, useMask);
<span class="nc" id="L68">                break;</span>
            case SunGraphics2D.PAINT_RAD_GRADIENT:
<span class="nc" id="L70">                setRadialGradientPaint(rq, sg2d,</span>
                                       (RadialGradientPaint)paint, useMask);
<span class="nc" id="L72">                break;</span>
            case SunGraphics2D.PAINT_TEXTURE:
<span class="nc" id="L74">                setTexturePaint(rq, sg2d,</span>
                                (TexturePaint)paint, useMask);
<span class="nc" id="L76">                break;</span>
            default:
                break;
            }
        }
<span class="nc" id="L81">    }</span>

    static void resetPaint(RenderQueue rq) {
        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L85">        rq.ensureCapacity(4);</span>
<span class="nc" id="L86">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L87">        buf.putInt(RESET_PAINT);</span>
<span class="nc" id="L88">    }</span>

/****************************** Color support *******************************/

    private static void setColor(RenderQueue rq, int pixel) {
        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L94">        rq.ensureCapacity(8);</span>
<span class="nc" id="L95">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L96">        buf.putInt(SET_COLOR);</span>
<span class="nc" id="L97">        buf.putInt(pixel);</span>
<span class="nc" id="L98">    }</span>

/************************* GradientPaint support ****************************/

    /**
     * Note: This code is factored out into a separate static method
     * so that it can be shared by both the Gradient and LinearGradient
     * implementations.  LinearGradient uses this code (for the
     * two-color sRGB case only) because it can be much faster than the
     * equivalent implementation that uses fragment shaders.
     *
     * We use OpenGL's texture coordinate generator to automatically
     * apply a smooth gradient (either cyclic or acyclic) to the geometry
     * being rendered.  This technique is almost identical to the one
     * described in the comments for BufferedPaints.setTexturePaint(),
     * except the calculations take place in one dimension instead of two.
     * Instead of an anchor rectangle in the TexturePaint case, we use
     * the vector between the two GradientPaint end points in our
     * calculations.  The generator uses a single plane equation that
     * takes the (x,y) location (in device space) of the fragment being
     * rendered to calculate a (u) texture coordinate for that fragment:
     *     u = Ax + By + Cz + Dw
     *
     * The gradient renderer uses a two-pixel 1D texture where the first
     * pixel contains the first GradientPaint color, and the second pixel
     * contains the second GradientPaint color.  (Note that we use the
     * GL_CLAMP_TO_EDGE wrapping mode for acyclic gradients so that we
     * clamp the colors properly at the extremes.)  The following diagram
     * attempts to show the layout of the texture containing the two
     * GradientPaint colors (C1 and C2):
     *
     *                        +-----------------+
     *                        |   C1   |   C2   |
     *                        |        |        |
     *                        +-----------------+
     *                      u=0  .25  .5   .75  1
     *
     * We calculate our plane equation constants (A,B,D) such that u=0.25
     * corresponds to the first GradientPaint end point in user space and
     * u=0.75 corresponds to the second end point.  This is somewhat
     * non-obvious, but since the gradient colors are generated by
     * interpolating between C1 and C2, we want the pure color at the
     * end points, and we will get the pure color only when u correlates
     * to the center of a texel.  The following chart shows the expected
     * color for some sample values of u (where C' is the color halfway
     * between C1 and C2):
     *
     *       u value      acyclic (GL_CLAMP)      cyclic (GL_REPEAT)
     *       -------      ------------------      ------------------
     *        -0.25              C1                       C2
     *         0.0               C1                       C'
     *         0.25              C1                       C1
     *         0.5               C'                       C'
     *         0.75              C2                       C2
     *         1.0               C2                       C'
     *         1.25              C2                       C1
     *
     * Original inspiration for this technique came from UMD's Agile2D
     * project (GradientManager.java).
     */
    private static void setGradientPaint(RenderQueue rq, AffineTransform at,
                                         Color c1, Color c2,
                                         Point2D pt1, Point2D pt2,
                                         boolean isCyclic, boolean useMask)
    {
        // convert gradient colors to IntArgbPre format
<span class="nc" id="L164">        PixelConverter pc = PixelConverter.ArgbPre.instance;</span>
<span class="nc" id="L165">        int pixel1 = pc.rgbToPixel(c1.getRGB(), null);</span>
<span class="nc" id="L166">        int pixel2 = pc.rgbToPixel(c2.getRGB(), null);</span>

        // calculate plane equation constants
<span class="nc" id="L169">        double x = pt1.getX();</span>
<span class="nc" id="L170">        double y = pt1.getY();</span>
<span class="nc" id="L171">        at.translate(x, y);</span>
        // now gradient point 1 is at the origin
<span class="nc" id="L173">        x = pt2.getX() - x;</span>
<span class="nc" id="L174">        y = pt2.getY() - y;</span>
<span class="nc" id="L175">        double len = Math.sqrt(x * x + y * y);</span>
<span class="nc" id="L176">        at.rotate(x, y);</span>
        // now gradient point 2 is on the positive x-axis
<span class="nc" id="L178">        at.scale(2*len, 1);</span>
        // now gradient point 2 is at (0.5, 0)
<span class="nc" id="L180">        at.translate(-0.25, 0);</span>
        // now gradient point 1 is at (0.25, 0), point 2 is at (0.75, 0)

        double p0, p1, p3;
        try {
<span class="nc" id="L185">            at.invert();</span>
<span class="nc" id="L186">            p0 = at.getScaleX();</span>
<span class="nc" id="L187">            p1 = at.getShearX();</span>
<span class="nc" id="L188">            p3 = at.getTranslateX();</span>
<span class="nc" id="L189">        } catch (java.awt.geom.NoninvertibleTransformException e) {</span>
<span class="nc" id="L190">            p0 = p1 = p3 = 0.0;</span>
<span class="nc" id="L191">        }</span>

        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L194">        rq.ensureCapacityAndAlignment(44, 12);</span>
<span class="nc" id="L195">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L196">        buf.putInt(SET_GRADIENT_PAINT);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        buf.putInt(useMask ? 1 : 0);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        buf.putInt(isCyclic ? 1 : 0);</span>
<span class="nc" id="L199">        buf.putDouble(p0).putDouble(p1).putDouble(p3);</span>
<span class="nc" id="L200">        buf.putInt(pixel1).putInt(pixel2);</span>
<span class="nc" id="L201">    }</span>

    private static void setGradientPaint(RenderQueue rq,
                                         SunGraphics2D sg2d,
                                         GradientPaint paint,
                                         boolean useMask)
    {
<span class="nc" id="L208">        setGradientPaint(rq, (AffineTransform)sg2d.transform.clone(),</span>
<span class="nc" id="L209">                         paint.getColor1(), paint.getColor2(),</span>
<span class="nc" id="L210">                         paint.getPoint1(), paint.getPoint2(),</span>
<span class="nc" id="L211">                         paint.isCyclic(), useMask);</span>
<span class="nc" id="L212">    }</span>

/************************** TexturePaint support ****************************/

    /**
     * We use OpenGL's texture coordinate generator to automatically
     * map the TexturePaint image to the geometry being rendered.  The
     * generator uses two separate plane equations that take the (x,y)
     * location (in device space) of the fragment being rendered to
     * calculate (u,v) texture coordinates for that fragment:
     *     u = Ax + By + Cz + Dw
     *     v = Ex + Fy + Gz + Hw
     *
     * Since we use a 2D orthographic projection, we can assume that z=0
     * and w=1 for any fragment.  So we need to calculate appropriate
     * values for the plane equation constants (A,B,D) and (E,F,H) such
     * that {u,v}=0 for the top-left of the TexturePaint's anchor
     * rectangle and {u,v}=1 for the bottom-right of the anchor rectangle.
     * We can easily make the texture image repeat for {u,v} values
     * outside the range [0,1] by specifying the GL_REPEAT texture wrap
     * mode.
     *
     * Calculating the plane equation constants is surprisingly simple.
     * We can think of it as an inverse matrix operation that takes
     * device space coordinates and transforms them into user space
     * coordinates that correspond to a location relative to the anchor
     * rectangle.  First, we translate and scale the current user space
     * transform by applying the anchor rectangle bounds.  We then take
     * the inverse of this affine transform.  The rows of the resulting
     * inverse matrix correlate nicely to the plane equation constants
     * we were seeking.
     */
    private static void setTexturePaint(RenderQueue rq,
                                        SunGraphics2D sg2d,
                                        TexturePaint paint,
                                        boolean useMask)
    {
<span class="nc" id="L249">        BufferedImage bi = paint.getImage();</span>
<span class="nc" id="L250">        SurfaceData dstData = sg2d.surfaceData;</span>
<span class="nc" id="L251">        SurfaceData srcData =</span>
<span class="nc" id="L252">            dstData.getSourceSurfaceData(bi, SunGraphics2D.TRANSFORM_ISIDENT,</span>
                                         CompositeType.SrcOver, null);
<span class="nc bnc" id="L254" title="All 2 branches missed.">        boolean filter =</span>
            (sg2d.interpolationType !=
             AffineTransformOp.TYPE_NEAREST_NEIGHBOR);

        // calculate plane equation constants
<span class="nc" id="L259">        AffineTransform at = (AffineTransform)sg2d.transform.clone();</span>
<span class="nc" id="L260">        Rectangle2D anchor = paint.getAnchorRect();</span>
<span class="nc" id="L261">        at.translate(anchor.getX(), anchor.getY());</span>
<span class="nc" id="L262">        at.scale(anchor.getWidth(), anchor.getHeight());</span>

        double xp0, xp1, xp3, yp0, yp1, yp3;
        try {
<span class="nc" id="L266">            at.invert();</span>
<span class="nc" id="L267">            xp0 = at.getScaleX();</span>
<span class="nc" id="L268">            xp1 = at.getShearX();</span>
<span class="nc" id="L269">            xp3 = at.getTranslateX();</span>
<span class="nc" id="L270">            yp0 = at.getShearY();</span>
<span class="nc" id="L271">            yp1 = at.getScaleY();</span>
<span class="nc" id="L272">            yp3 = at.getTranslateY();</span>
<span class="nc" id="L273">        } catch (java.awt.geom.NoninvertibleTransformException e) {</span>
<span class="nc" id="L274">            xp0 = xp1 = xp3 = yp0 = yp1 = yp3 = 0.0;</span>
<span class="nc" id="L275">        }</span>

        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L278">        rq.ensureCapacityAndAlignment(68, 12);</span>
<span class="nc" id="L279">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L280">        buf.putInt(SET_TEXTURE_PAINT);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        buf.putInt(useMask ? 1 : 0);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        buf.putInt(filter ? 1 : 0);</span>
<span class="nc" id="L283">        buf.putLong(srcData.getNativeOps());</span>
<span class="nc" id="L284">        buf.putDouble(xp0).putDouble(xp1).putDouble(xp3);</span>
<span class="nc" id="L285">        buf.putDouble(yp0).putDouble(yp1).putDouble(yp3);</span>
<span class="nc" id="L286">    }</span>

/****************** Shared MultipleGradientPaint support ********************/

    /**
     * The maximum number of gradient &quot;stops&quot; supported by our native
     * fragment shader implementations.
     *
     * This value has been empirically determined and capped to allow
     * our native shaders to run on all shader-level graphics hardware,
     * even on the older, more limited GPUs.  Even the oldest Nvidia
     * hardware could handle 16, or even 32 fractions without any problem.
     * But the first-generation boards from ATI would fall back into
     * software mode (which is unusably slow) for values larger than 12;
     * it appears that those boards do not have enough native registers
     * to support the number of array accesses required by our gradient
     * shaders.  So for now we will cap this value at 12, but we can
     * re-evaluate this in the future as hardware becomes more capable.
     */
    @Native public static final int MULTI_MAX_FRACTIONS = 12;

    /**
     * Helper function to convert a color component in sRGB space to
     * linear RGB space.  Copied directly from the
     * MultipleGradientPaintContext class.
     */
    public static int convertSRGBtoLinearRGB(int color) {
        float input, output;

<span class="nc" id="L315">        input = color / 255.0f;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (input &lt;= 0.04045f) {</span>
<span class="nc" id="L317">            output = input / 12.92f;</span>
        } else {
<span class="nc" id="L319">            output = (float)Math.pow((input + 0.055) / 1.055, 2.4);</span>
        }

<span class="nc" id="L322">        return Math.round(output * 255.0f);</span>
    }

    /**
     * Helper function to convert a (non-premultiplied) Color in sRGB
     * space to an IntArgbPre pixel value, optionally in linear RGB space.
     * Based on the PixelConverter.ArgbPre.rgbToPixel() method.
     */
    private static int colorToIntArgbPrePixel(Color c, boolean linear) {
<span class="nc" id="L331">        int rgb = c.getRGB();</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">        if (!linear &amp;&amp; ((rgb &gt;&gt; 24) == -1)) {</span>
<span class="nc" id="L333">            return rgb;</span>
        }
<span class="nc" id="L335">        int a = rgb &gt;&gt;&gt; 24;</span>
<span class="nc" id="L336">        int r = (rgb &gt;&gt; 16) &amp; 0xff;</span>
<span class="nc" id="L337">        int g = (rgb &gt;&gt;  8) &amp; 0xff;</span>
<span class="nc" id="L338">        int b = (rgb      ) &amp; 0xff;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (linear) {</span>
<span class="nc" id="L340">            r = convertSRGBtoLinearRGB(r);</span>
<span class="nc" id="L341">            g = convertSRGBtoLinearRGB(g);</span>
<span class="nc" id="L342">            b = convertSRGBtoLinearRGB(b);</span>
        }
<span class="nc" id="L344">        int a2 = a + (a &gt;&gt; 7);</span>
<span class="nc" id="L345">        r = (r * a2) &gt;&gt; 8;</span>
<span class="nc" id="L346">        g = (g * a2) &gt;&gt; 8;</span>
<span class="nc" id="L347">        b = (b * a2) &gt;&gt; 8;</span>
<span class="nc" id="L348">        return ((a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | (b));</span>
    }

    /**
     * Converts the given array of Color objects into an int array
     * containing IntArgbPre pixel values.  If the linear parameter
     * is true, the Color values will be converted into a linear RGB
     * color space before being returned.
     */
    private static int[] convertToIntArgbPrePixels(Color[] colors,
                                                   boolean linear)
    {
<span class="nc" id="L360">        int[] pixels = new int[colors.length];</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        for (int i = 0; i &lt; colors.length; i++) {</span>
<span class="nc" id="L362">            pixels[i] = colorToIntArgbPrePixel(colors[i], linear);</span>
        }
<span class="nc" id="L364">        return pixels;</span>
    }

/********************** LinearGradientPaint support *************************/

    /**
     * This method uses techniques that are nearly identical to those
     * employed in setGradientPaint() above.  The primary difference
     * is that at the native level we use a fragment shader to manually
     * apply the plane equation constants to the current fragment position
     * to calculate the gradient position in the range [0,1] (the native
     * code for GradientPaint does the same, except that it uses OpenGL's
     * automatic texture coordinate generation facilities).
     *
     * One other minor difference worth mentioning is that
     * setGradientPaint() calculates the plane equation constants
     * such that the gradient end points are positioned at 0.25 and 0.75
     * (for reasons discussed in the comments for that method).  In
     * contrast, for LinearGradientPaint we setup the equation constants
     * such that the gradient end points fall at 0.0 and 1.0.  The
     * reason for this difference is that in the fragment shader we
     * have more control over how the gradient values are interpreted
     * (depending on the paint's CycleMethod).
     */
    private static void setLinearGradientPaint(RenderQueue rq,
                                               SunGraphics2D sg2d,
                                               LinearGradientPaint paint,
                                               boolean useMask)
    {
<span class="nc" id="L393">        boolean linear =</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            (paint.getColorSpace() == ColorSpaceType.LINEAR_RGB);</span>
<span class="nc" id="L395">        Color[] colors = paint.getColors();</span>
<span class="nc" id="L396">        int numStops = colors.length;</span>
<span class="nc" id="L397">        Point2D pt1 = paint.getStartPoint();</span>
<span class="nc" id="L398">        Point2D pt2 = paint.getEndPoint();</span>
<span class="nc" id="L399">        AffineTransform at = paint.getTransform();</span>
<span class="nc" id="L400">        at.preConcatenate(sg2d.transform);</span>

<span class="nc bnc" id="L402" title="All 4 branches missed.">        if (!linear &amp;&amp; numStops == 2 &amp;&amp;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            paint.getCycleMethod() != CycleMethod.REPEAT)</span>
        {
            // delegate to the optimized two-color gradient codepath
<span class="nc" id="L406">            boolean isCyclic =</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                (paint.getCycleMethod() != CycleMethod.NO_CYCLE);</span>
<span class="nc" id="L408">            setGradientPaint(rq, at,</span>
                             colors[0], colors[1],
                             pt1, pt2,
                             isCyclic, useMask);
<span class="nc" id="L412">            return;</span>
        }

<span class="nc" id="L415">        int cycleMethod = paint.getCycleMethod().ordinal();</span>
<span class="nc" id="L416">        float[] fractions = paint.getFractions();</span>
<span class="nc" id="L417">        int[] pixels = convertToIntArgbPrePixels(colors, linear);</span>

        // calculate plane equation constants
<span class="nc" id="L420">        double x = pt1.getX();</span>
<span class="nc" id="L421">        double y = pt1.getY();</span>
<span class="nc" id="L422">        at.translate(x, y);</span>
        // now gradient point 1 is at the origin
<span class="nc" id="L424">        x = pt2.getX() - x;</span>
<span class="nc" id="L425">        y = pt2.getY() - y;</span>
<span class="nc" id="L426">        double len = Math.sqrt(x * x + y * y);</span>
<span class="nc" id="L427">        at.rotate(x, y);</span>
        // now gradient point 2 is on the positive x-axis
<span class="nc" id="L429">        at.scale(len, 1);</span>
        // now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)

        float p0, p1, p3;
        try {
<span class="nc" id="L434">            at.invert();</span>
<span class="nc" id="L435">            p0 = (float)at.getScaleX();</span>
<span class="nc" id="L436">            p1 = (float)at.getShearX();</span>
<span class="nc" id="L437">            p3 = (float)at.getTranslateX();</span>
<span class="nc" id="L438">        } catch (java.awt.geom.NoninvertibleTransformException e) {</span>
<span class="nc" id="L439">            p0 = p1 = p3 = 0.0f;</span>
<span class="nc" id="L440">        }</span>

        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L443">        rq.ensureCapacity(20 + 12 + (numStops*4*2));</span>
<span class="nc" id="L444">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L445">        buf.putInt(SET_LINEAR_GRADIENT_PAINT);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">        buf.putInt(useMask ? 1 : 0);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        buf.putInt(linear  ? 1 : 0);</span>
<span class="nc" id="L448">        buf.putInt(cycleMethod);</span>
<span class="nc" id="L449">        buf.putInt(numStops);</span>
<span class="nc" id="L450">        buf.putFloat(p0);</span>
<span class="nc" id="L451">        buf.putFloat(p1);</span>
<span class="nc" id="L452">        buf.putFloat(p3);</span>
<span class="nc" id="L453">        buf.put(fractions);</span>
<span class="nc" id="L454">        buf.put(pixels);</span>
<span class="nc" id="L455">    }</span>

/********************** RadialGradientPaint support *************************/

    /**
     * This method calculates six m** values and a focusX value that
     * are used by the native fragment shader.  These techniques are
     * based on a whitepaper by Daniel Rice on radial gradient performance
     * (attached to the bug report for 6521533).  One can refer to that
     * document for the complete set of formulas and calculations, but
     * the basic goal is to compose a transform that will convert an
     * (x,y) position in device space into a &quot;u&quot; value that represents
     * the relative distance to the gradient focus point.  The resulting
     * value can be used to look up the appropriate color by linearly
     * interpolating between the two nearest colors in the gradient.
     */
    private static void setRadialGradientPaint(RenderQueue rq,
                                               SunGraphics2D sg2d,
                                               RadialGradientPaint paint,
                                               boolean useMask)
    {
<span class="nc" id="L476">        boolean linear =</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            (paint.getColorSpace() == ColorSpaceType.LINEAR_RGB);</span>
<span class="nc" id="L478">        int cycleMethod = paint.getCycleMethod().ordinal();</span>
<span class="nc" id="L479">        float[] fractions = paint.getFractions();</span>
<span class="nc" id="L480">        Color[] colors = paint.getColors();</span>
<span class="nc" id="L481">        int numStops = colors.length;</span>
<span class="nc" id="L482">        int[] pixels = convertToIntArgbPrePixels(colors, linear);</span>
<span class="nc" id="L483">        Point2D center = paint.getCenterPoint();</span>
<span class="nc" id="L484">        Point2D focus = paint.getFocusPoint();</span>
<span class="nc" id="L485">        float radius = paint.getRadius();</span>

        // save original (untransformed) center and focus points
<span class="nc" id="L488">        double cx = center.getX();</span>
<span class="nc" id="L489">        double cy = center.getY();</span>
<span class="nc" id="L490">        double fx = focus.getX();</span>
<span class="nc" id="L491">        double fy = focus.getY();</span>

        // transform from gradient coords to device coords
<span class="nc" id="L494">        AffineTransform at = paint.getTransform();</span>
<span class="nc" id="L495">        at.preConcatenate(sg2d.transform);</span>
<span class="nc" id="L496">        focus = at.transform(focus, focus);</span>

        // transform unit circle to gradient coords; we start with the
        // unit circle (center=(0,0), focus on positive x-axis, radius=1)
        // and then transform into gradient space
<span class="nc" id="L501">        at.translate(cx, cy);</span>
<span class="nc" id="L502">        at.rotate(fx - cx, fy - cy);</span>
<span class="nc" id="L503">        at.scale(radius, radius);</span>

        // invert to get mapping from device coords to unit circle
        try {
<span class="nc" id="L507">            at.invert();</span>
<span class="nc" id="L508">        } catch (Exception e) {</span>
<span class="nc" id="L509">            at.setToScale(0.0, 0.0);</span>
<span class="nc" id="L510">        }</span>
<span class="nc" id="L511">        focus = at.transform(focus, focus);</span>

        // clamp the focus point so that it does not rest on, or outside
        // of, the circumference of the gradient circle
<span class="nc" id="L515">        fx = Math.min(focus.getX(), 0.99);</span>

        // assert rq.lock.isHeldByCurrentThread();
<span class="nc" id="L518">        rq.ensureCapacity(20 + 28 + (numStops*4*2));</span>
<span class="nc" id="L519">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L520">        buf.putInt(SET_RADIAL_GRADIENT_PAINT);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        buf.putInt(useMask ? 1 : 0);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        buf.putInt(linear  ? 1 : 0);</span>
<span class="nc" id="L523">        buf.putInt(numStops);</span>
<span class="nc" id="L524">        buf.putInt(cycleMethod);</span>
<span class="nc" id="L525">        buf.putFloat((float)at.getScaleX());</span>
<span class="nc" id="L526">        buf.putFloat((float)at.getShearX());</span>
<span class="nc" id="L527">        buf.putFloat((float)at.getTranslateX());</span>
<span class="nc" id="L528">        buf.putFloat((float)at.getShearY());</span>
<span class="nc" id="L529">        buf.putFloat((float)at.getScaleY());</span>
<span class="nc" id="L530">        buf.putFloat((float)at.getTranslateY());</span>
<span class="nc" id="L531">        buf.putFloat((float)fx);</span>
<span class="nc" id="L532">        buf.put(fractions);</span>
<span class="nc" id="L533">        buf.put(pixels);</span>
<span class="nc" id="L534">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>