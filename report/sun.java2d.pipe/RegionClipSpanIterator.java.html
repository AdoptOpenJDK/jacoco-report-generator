<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RegionClipSpanIterator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.pipe</a> &gt; <span class="el_source">RegionClipSpanIterator.java</span></div><h1>RegionClipSpanIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.pipe;

import java.awt.geom.PathIterator;
import java.awt.Rectangle;

/**
 * This class clips a SpanIterator to a Region and outputs the
 * resulting spans as another SpanIterator.
 *
 * Spans are output in the usual y/x order, unless the input span
 * iterator doesn't conform to this order, or the iterator's span
 * straddle more than one band of the Region used for clipping.
 *
 * Principle of operation:
 *
 * The iterator maintains a several cursors onto the RegionIterator
 * in order to avoid having to buffer spans from the SpanIterator.
 * They are:
 *  resetState    The initial state of the RegionIterator
 *  lwm             Low Water Mark, a running start point for
 *                  processing each band. Usually goes down, but
 *                  can be reset to resetState if a span has a lower
 *                  start coordinate than the previous one.
 *  row             The start of the current band of the RegionIterator
 *  box             The current span of the current row
 *
 * The main nextSpan() loop implements a coroutine like structure, with
 * three producers to get the next span, row and box calling each other
 * to iterate through the span iterator and region.
 *
 * REMIND: Needs a native implementation!
 */
public class RegionClipSpanIterator implements SpanIterator {

    // The inputs to the filter
    Region rgn;
    SpanIterator spanIter;

    // The cursors that track the progress through the region
    RegionIterator resetState;
    RegionIterator lwm;
    RegionIterator row;
    RegionIterator box;

    // The bounds of the current span iterator span
    int spanlox, spanhix, spanloy, spanhiy;

    // The extent of the region band marking the low water mark
    int lwmloy, lwmhiy;

    // The bounds of the current region box
    int rgnlox, rgnloy, rgnhix, rgnhiy;

    // The bounding box of the input Region. Used for click
    // rejection of iterator spans
    int rgnbndslox, rgnbndsloy, rgnbndshix, rgnbndshiy;

    // The array used to hold coordinates from the region iterator
<span class="nc" id="L84">    int rgnbox[] = new int[4];</span>

    // The array used to hold coordinates from the span iterator
<span class="nc" id="L87">    int spanbox[] = new int[4];</span>

    // True if the next iterator span should be read on the next
    // iteration of the main nextSpan() loop
    boolean doNextSpan;

    // True if the next region box should be read on the next
    // iteration of the main nextSpan() loop
    boolean doNextBox;

    // True if there are no more spans or the Region is empty
<span class="nc" id="L98">    boolean done = false;</span>

    /*
     * Creates an instance that filters the spans generated by
     * spanIter through the region described by rgn.
     */
<span class="nc" id="L104">    public RegionClipSpanIterator(Region rgn, SpanIterator spanIter) {</span>

<span class="nc" id="L106">        this.spanIter = spanIter;</span>

<span class="nc" id="L108">        resetState = rgn.getIterator();</span>
<span class="nc" id="L109">        lwm = resetState.createCopy();</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (!lwm.nextYRange(rgnbox)) {</span>
<span class="nc" id="L112">            done = true;</span>
<span class="nc" id="L113">            return;</span>
        }

<span class="nc" id="L116">        rgnloy = lwmloy = rgnbox[1];</span>
<span class="nc" id="L117">        rgnhiy = lwmhiy = rgnbox[3];</span>

<span class="nc" id="L119">        rgn.getBounds(rgnbox);</span>
<span class="nc" id="L120">        rgnbndslox = rgnbox[0];</span>
<span class="nc" id="L121">        rgnbndsloy = rgnbox[1];</span>
<span class="nc" id="L122">        rgnbndshix = rgnbox[2];</span>
<span class="nc" id="L123">        rgnbndshiy = rgnbox[3];</span>
<span class="nc bnc" id="L124" title="All 4 branches missed.">        if (rgnbndslox &gt;= rgnbndshix ||</span>
            rgnbndsloy &gt;= rgnbndshiy) {
<span class="nc" id="L126">            done = true;</span>
<span class="nc" id="L127">            return;</span>
        }

<span class="nc" id="L130">        this.rgn = rgn;</span>


<span class="nc" id="L133">        row = lwm.createCopy();</span>
<span class="nc" id="L134">        box = row.createCopy();</span>
<span class="nc" id="L135">        doNextSpan = true;</span>
<span class="nc" id="L136">        doNextBox = false;</span>
<span class="nc" id="L137">    }</span>

    /*
     * Gets the bbox of the available path segments, clipped to the
     * Region.
     */
    public void getPathBox(int pathbox[]) {
<span class="nc" id="L144">        int[] rgnbox = new int[4];</span>
<span class="nc" id="L145">        rgn.getBounds(rgnbox);</span>
<span class="nc" id="L146">        spanIter.getPathBox(pathbox);</span>

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (pathbox[0] &lt; rgnbox[0]) {</span>
<span class="nc" id="L149">            pathbox[0] = rgnbox[0];</span>
        }

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (pathbox[1] &lt; rgnbox[1]) {</span>
<span class="nc" id="L153">            pathbox[1] = rgnbox[1];</span>
        }

<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (pathbox[2] &gt; rgnbox[2]) {</span>
<span class="nc" id="L157">            pathbox[2] = rgnbox[2];</span>
        }

<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (pathbox[3] &gt; rgnbox[3]) {</span>
<span class="nc" id="L161">            pathbox[3] = rgnbox[3];</span>
        }
<span class="nc" id="L163">}</span>

    /*
     * Intersects the path box with the given bbox.
     * Returned spans are clipped to this region, or discarded
     * altogether if they lie outside it.
     */
    public void intersectClipBox(int lox, int loy, int hix, int hiy) {
<span class="nc" id="L171">        spanIter.intersectClipBox(lox, loy, hix, hiy);</span>
<span class="nc" id="L172">    }</span>


    /*
     * Fetches the next span that needs to be operated on.
     * If the return value is false then there are no more spans.
     */
    public boolean nextSpan(int resultbox[]) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (done) {</span>
<span class="nc" id="L181">            return false;</span>
        }

        int resultlox, resultloy, resulthix, resulthiy;
<span class="nc" id="L185">        boolean doNextRow = false;</span>

        // REMIND: Cache the coordinate inst vars used in this loop
        // in locals vars.
        while (true) {
            // We've exhausted the current span so get the next one
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (doNextSpan) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (!spanIter.nextSpan(spanbox)) {</span>
<span class="nc" id="L193">                    done = true;</span>
<span class="nc" id="L194">                    return false;</span>
                } else {
<span class="nc" id="L196">                    spanlox = spanbox[0];</span>
                    // Clip out spans that lie outside of the rgn's bounds
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if (spanlox &gt;= rgnbndshix) {</span>
<span class="nc" id="L199">                        continue;</span>
                    }

<span class="nc" id="L202">                    spanloy = spanbox[1];</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                    if (spanloy &gt;= rgnbndshiy) {</span>
<span class="nc" id="L204">                        continue;</span>
                    }

<span class="nc" id="L207">                    spanhix = spanbox[2];</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">                    if (spanhix &lt;= rgnbndslox) {</span>
<span class="nc" id="L209">                        continue;</span>
                    }

<span class="nc" id="L212">                    spanhiy = spanbox[3];</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (spanhiy &lt;= rgnbndsloy) {</span>
<span class="nc" id="L214">                        continue;</span>
                    }
                }
                // If the span starts higher up than the low-water mark,
                // reset the lwm. This can only happen if spans aren't
                // returned in strict y/x order, or the first time through.
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (lwmloy &gt; spanloy) {</span>
<span class="nc" id="L221">                    lwm.copyStateFrom(resetState);</span>
<span class="nc" id="L222">                    lwm.nextYRange(rgnbox);</span>
<span class="nc" id="L223">                    lwmloy = rgnbox[1];</span>
<span class="nc" id="L224">                    lwmhiy = rgnbox[3];</span>
                }
                // Skip to the first rgn row whose bottom edge is
                // below the top of the current span. This will only
                // execute &gt;0 times when the current span starts in a
                // lower region row than the previous one, or possibly the
                // first time through.
<span class="nc bnc" id="L231" title="All 2 branches missed.">                while (lwmhiy &lt;= spanloy) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">                    if (!lwm.nextYRange(rgnbox))</span>
<span class="nc" id="L233">                        break;</span>
<span class="nc" id="L234">                    lwmloy = rgnbox[1];</span>
<span class="nc" id="L235">                    lwmhiy = rgnbox[3];</span>
                }
                // If the row overlaps the span, process it, otherwise
                // fetch another span
<span class="nc bnc" id="L239" title="All 4 branches missed.">                if (lwmhiy &gt; spanloy &amp;&amp; lwmloy &lt; spanhiy) {</span>
                    // Update the current row if it's different from the
                    // new lwm
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    if (rgnloy != lwmloy) {</span>
<span class="nc" id="L243">                        row.copyStateFrom(lwm);</span>
<span class="nc" id="L244">                        rgnloy = lwmloy;</span>
<span class="nc" id="L245">                        rgnhiy = lwmhiy;</span>
                    }
<span class="nc" id="L247">                    box.copyStateFrom(row);</span>
<span class="nc" id="L248">                    doNextBox = true;</span>
<span class="nc" id="L249">                    doNextSpan = false;</span>
                }
                continue;
            }

            // The current row's spans are exhausted, do the next one
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (doNextRow) {</span>
                // Next time we either do the next span or the next box
<span class="nc" id="L257">                doNextRow = false;</span>
                // Get the next row
<span class="nc" id="L259">                boolean ok = row.nextYRange(rgnbox);</span>
                // If there was one, update the bounds
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if (ok) {</span>
<span class="nc" id="L262">                    rgnloy = rgnbox[1];</span>
<span class="nc" id="L263">                    rgnhiy = rgnbox[3];</span>
                }
<span class="nc bnc" id="L265" title="All 4 branches missed.">                if (!ok || rgnloy &gt;= spanhiy) {</span>
                    // If we've exhausted the rows or this one is below the span,
                    // go onto the next span
<span class="nc" id="L268">                    doNextSpan = true;</span>
                }
                else {
                    // Otherwise get the first box on this row
<span class="nc" id="L272">                    box.copyStateFrom(row);</span>
<span class="nc" id="L273">                    doNextBox = true;</span>
                }
<span class="nc" id="L275">                continue;</span>
            }

            // Process the next box in the current row
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (doNextBox) {</span>
<span class="nc" id="L280">                boolean ok = box.nextXBand(rgnbox);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                if (ok) {</span>
<span class="nc" id="L282">                    rgnlox = rgnbox[0];</span>
<span class="nc" id="L283">                    rgnhix = rgnbox[2];</span>
                }
<span class="nc bnc" id="L285" title="All 4 branches missed.">                if (!ok || rgnlox &gt;= spanhix) {</span>
                    // If there was no next rgn span or it's beyond the
                    // source span, go onto the next row or span
<span class="nc" id="L288">                    doNextBox = false;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                    if (rgnhiy &gt;= spanhiy) {</span>
                        // If the current row totally overlaps the span,
                        // go onto the next span
<span class="nc" id="L292">                        doNextSpan = true;</span>
                    } else {
                        // otherwise go onto the next rgn row
<span class="nc" id="L295">                        doNextRow = true;</span>
                    }
                } else {
                    // Otherwise, if the new rgn span overlaps the
                    // spanbox, no need to get another box
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    doNextBox = rgnhix &lt;= spanlox;</span>
                }
<span class="nc" id="L302">                continue;</span>
            }

            // Prepare to do the next box either on this call or
            // or the subsequent one
<span class="nc" id="L307">            doNextBox = true;</span>

            // Clip the current span against the current box
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (spanlox &gt; rgnlox) {</span>
<span class="nc" id="L311">                resultlox = spanlox;</span>
            }
            else {
<span class="nc" id="L314">                resultlox = rgnlox;</span>
            }

<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (spanloy &gt; rgnloy) {</span>
<span class="nc" id="L318">                resultloy = spanloy;</span>
            }
            else {
<span class="nc" id="L321">                resultloy = rgnloy;</span>
            }

<span class="nc bnc" id="L324" title="All 2 branches missed.">            if (spanhix &lt; rgnhix) {</span>
<span class="nc" id="L325">                resulthix = spanhix;</span>
            }
            else {
<span class="nc" id="L328">                resulthix = rgnhix;</span>
            }

<span class="nc bnc" id="L331" title="All 2 branches missed.">            if (spanhiy &lt; rgnhiy) {</span>
<span class="nc" id="L332">                resulthiy = spanhiy;</span>
            }
            else {
<span class="nc" id="L335">                resulthiy = rgnhiy;</span>
            }

            // If the result is empty, try then next box
            // otherwise return the box.
            // REMIND: I think by definition it's non-empty
            // if we're here. Need to think about this some more.
<span class="nc bnc" id="L342" title="All 4 branches missed.">            if (resultlox &gt;= resulthix ||</span>
                resultloy &gt;= resulthiy) {
<span class="nc" id="L344">                    continue;</span>
            }
            else {
                    break;
            }
        }

<span class="nc" id="L351">        resultbox[0] = resultlox;</span>
<span class="nc" id="L352">        resultbox[1] = resultloy;</span>
<span class="nc" id="L353">        resultbox[2] = resulthix;</span>
<span class="nc" id="L354">        resultbox[3] = resulthiy;</span>
<span class="nc" id="L355">        return true;</span>

    }


    /**
     * This method tells the iterator that it may skip all spans
     * whose Y range is completely above the indicated Y coordinate.
     */
    public void skipDownTo(int y) {
<span class="nc" id="L365">        spanIter.skipDownTo(y);</span>
<span class="nc" id="L366">    }</span>

    /**
     * This method returns a native pointer to a function block that
     * can be used by a native method to perform the same iteration
     * cycle that the above methods provide while avoiding upcalls to
     * the Java object.
     * The definition of the structure whose pointer is returned by
     * this method is defined in:
     * &lt;pre&gt;
     *     src/share/native/sun/java2d/pipe/SpanIterator.h
     * &lt;/pre&gt;
     */
    public long getNativeIterator() {
<span class="nc" id="L380">        return 0;</span>
    }

    /*
     * Cleans out all internal data structures.
     */
    //public native void dispose();

    protected void finalize() {
        //dispose();
<span class="nc" id="L390">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>