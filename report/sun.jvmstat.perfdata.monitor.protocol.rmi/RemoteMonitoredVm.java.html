<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RemoteMonitoredVm.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.perfdata.monitor.protocol.rmi</a> &gt; <span class="el_source">RemoteMonitoredVm.java</span></div><h1>RemoteMonitoredVm.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.protocol.rmi;

import sun.jvmstat.monitor.*;
import sun.jvmstat.monitor.event.*;
import sun.jvmstat.monitor.remote.*;
import sun.jvmstat.perfdata.monitor.*;
import java.lang.reflect.*;
import java.util.*;
import java.io.*;
import java.nio.ByteBuffer;
import java.rmi.*;

/**
 * Concrete implementation of the AbstractMonitoredVm class for the
 * &lt;em&gt;rmi:&lt;/em&gt; protocol for the HotSpot PerfData monitoring implementation.
 * &lt;p&gt;
 * This class provides the ability to acquire to the instrumentation buffer
 * of a live, remote target Java Virtual Machine through an RMI server.
 *
 * @author Brian Doherty
 * @since 1.5
 */
<span class="nc bnc" id="L48" title="All 2 branches missed.">public class RemoteMonitoredVm extends AbstractMonitoredVm {</span>

    private ArrayList&lt;VmListener&gt; listeners;
    private NotifierTask notifierTask;
    private SamplerTask samplerTask;
    private Timer timer;

    private RemoteVm rvm;
    private ByteBuffer updateBuffer;

    /**
     * Create a RemoteMonitoredVm instance.
     *
     * @param rvm the proxy to the remote MonitoredVm instance.
     * @param vmid the vm identifier specifying the remot target JVM
     * @param timer the timer used to run polling tasks
     * @param interval the sampling interval
     */
    public RemoteMonitoredVm(RemoteVm rvm, VmIdentifier vmid,
                             Timer timer, int interval)
           throws MonitorException {
<span class="nc" id="L69">        super(vmid, interval);</span>
<span class="nc" id="L70">        this.rvm = rvm;</span>
<span class="nc" id="L71">        pdb = new PerfDataBuffer(rvm, vmid.getLocalVmId());</span>
<span class="nc" id="L72">        this.listeners = new ArrayList&lt;VmListener&gt;();</span>
<span class="nc" id="L73">        this.timer = timer;</span>
<span class="nc" id="L74">    }</span>

    /**
     * Method to attach to the remote MonitoredVm.
     */
    public void attach() throws MonitorException {
<span class="nc" id="L80">        updateBuffer = pdb.getByteBuffer().duplicate();</span>

        // if continuous sampling is requested, register with the sampler thread
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (interval &gt; 0) {</span>
<span class="nc" id="L84">            samplerTask = new SamplerTask();</span>
<span class="nc" id="L85">            timer.schedule(samplerTask, 0, interval);</span>
        }
<span class="nc" id="L87">    }</span>

    /**
     * {@inheritDoc}
     */
    public void detach() {
        try {
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (interval &gt; 0) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                if (samplerTask != null) {</span>
<span class="nc" id="L96">                    samplerTask.cancel();</span>
<span class="nc" id="L97">                    samplerTask = null;</span>
                }
<span class="nc bnc" id="L99" title="All 2 branches missed.">                if (notifierTask != null) {</span>
<span class="nc" id="L100">                    notifierTask.cancel();</span>
<span class="nc" id="L101">                    notifierTask = null;</span>
                }
<span class="nc" id="L103">                sample();</span>
            }
<span class="nc" id="L105">        } catch (RemoteException e) {</span>
            // XXX: - use logging api? throw an exception instead?
<span class="nc" id="L107">            System.err.println(&quot;Could not read data for remote JVM &quot; + vmid);</span>
<span class="nc" id="L108">            e.printStackTrace();</span>

        } finally {
<span class="nc" id="L111">            super.detach();</span>
<span class="nc" id="L112">        }</span>
<span class="nc" id="L113">    }</span>

    /**
     * Get a copy of the remote instrumentation buffer.
     *&lt;p&gt;
     * The data in the remote instrumentation buffer is copied into
     * a local byte buffer.
     *
     * @throws RemoteException Thrown on any communications errors with
     *                         the remote system.
     */
    public void sample() throws RemoteException {
<span class="nc bnc" id="L125" title="All 4 branches missed.">        assert updateBuffer != null;</span>
<span class="nc" id="L126">        ((PerfDataBuffer)pdb).sample(updateBuffer);</span>
<span class="nc" id="L127">    }</span>

    /**
     * Get the proxy to the remote MonitoredVm.
     *
     * @return RemoteVm - the proxy to the remote MonitoredVm.
     */
    public RemoteVm getRemoteVm() {
<span class="nc" id="L135">        return rvm;</span>
    }

    /**
     * {@inheritDoc}
     */
    public void addVmListener(VmListener l) {
<span class="nc" id="L142">        synchronized(listeners) {</span>
<span class="nc" id="L143">            listeners.add(l);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (notifierTask == null) {</span>
<span class="nc" id="L145">                notifierTask = new NotifierTask();</span>
<span class="nc" id="L146">                timer.schedule(notifierTask, 0, interval);</span>
            }
<span class="nc" id="L148">        }</span>
<span class="nc" id="L149">    }</span>

    /**
     * {@inheritDoc}
     */
    public void removeVmListener(VmListener l) {
<span class="nc" id="L155">        synchronized(listeners) {</span>
<span class="nc" id="L156">            listeners.remove(l);</span>
<span class="nc bnc" id="L157" title="All 4 branches missed.">            if (listeners.isEmpty() &amp;&amp; (notifierTask != null)) {</span>
<span class="nc" id="L158">                notifierTask.cancel();</span>
<span class="nc" id="L159">                notifierTask = null;</span>
            }
<span class="nc" id="L161">        }</span>
<span class="nc" id="L162">    }</span>

    /**
     * {@inheritDoc}
     */
    public void setInterval(int newInterval) {
<span class="nc" id="L168">        synchronized(listeners) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (newInterval == interval) {</span>
<span class="nc" id="L170">                return;</span>
            }

<span class="nc" id="L173">            int oldInterval = interval;</span>
<span class="nc" id="L174">            super.setInterval(newInterval);</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (samplerTask != null) {</span>
<span class="nc" id="L177">                samplerTask.cancel();</span>
<span class="nc" id="L178">                SamplerTask oldSamplerTask = samplerTask;</span>
<span class="nc" id="L179">                samplerTask = new SamplerTask();</span>
<span class="nc" id="L180">                CountedTimerTaskUtils.reschedule(timer, oldSamplerTask,</span>
                                                 samplerTask, oldInterval,
                                                 newInterval);
            }
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (notifierTask != null) {</span>
<span class="nc" id="L185">                notifierTask.cancel();</span>
<span class="nc" id="L186">                NotifierTask oldNotifierTask = notifierTask;</span>
<span class="nc" id="L187">                notifierTask = new NotifierTask();</span>
<span class="nc" id="L188">                CountedTimerTaskUtils.reschedule(timer, oldNotifierTask,</span>
                                                 notifierTask, oldInterval,
                                                 newInterval);
            }
<span class="nc" id="L192">        }</span>
<span class="nc" id="L193">    }</span>

    /**
     * Fire MonitoredVmStructureChanged events.
     *
     * @param inserted List of Monitor objects inserted.
     * @param removed List of Monitor objects removed.
     */
    void fireMonitorStatusChangedEvents(List inserted, List removed) {
<span class="nc" id="L202">        ArrayList registered = null;</span>
<span class="nc" id="L203">        MonitorStatusChangeEvent ev = null;</span>

<span class="nc" id="L205">        synchronized(listeners) {</span>
<span class="nc" id="L206">            registered = (ArrayList)listeners.clone();</span>
<span class="nc" id="L207">        }</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (Iterator i = registered.iterator(); i.hasNext(); /* empty */) {</span>
<span class="nc" id="L210">            VmListener l = (VmListener)i.next();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (ev == null) {</span>
<span class="nc" id="L212">                ev = new MonitorStatusChangeEvent(this, inserted, removed);</span>
            }
<span class="nc" id="L214">            l.monitorStatusChanged(ev);</span>
<span class="nc" id="L215">        }</span>
<span class="nc" id="L216">    }</span>

    /**
     * Fire MonitoredVmStructureChanged events.
     */
    void fireMonitorsUpdatedEvents() {
<span class="nc" id="L222">        ArrayList registered = null;</span>
<span class="nc" id="L223">        VmEvent ev = null;</span>

<span class="nc" id="L225">        synchronized(listeners) {</span>
<span class="nc" id="L226">            registered = (ArrayList)listeners.clone();</span>
<span class="nc" id="L227">        }</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">        for (Iterator i = registered.iterator(); i.hasNext(); /* empty */) {</span>
<span class="nc" id="L230">            VmListener l = (VmListener)i.next();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (ev == null) {</span>
<span class="nc" id="L232">                ev = new VmEvent(this);</span>
            }
<span class="nc" id="L234">            l.monitorsUpdated(ev);</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">    }</span>

    /*
     * Timer Tasks. There are two separate timer tasks here. The SamplerTask
     * is active whenever we are attached to the remote JVM with a periodic
     * sampling interval &gt; 0. The NotifierTask is only active if a VmListener
     * has registered with this RemoteMonitoredVm instance. Also, in the future
     * we may want to run these tasks at different intervals. Currently,
     * they run at the same interval and some significant work may
     * need to be done to complete the separation of these two intervals.
     */

    /**
     * Class to periodically check the state of the defined monitors
     * for the remote MonitoredVm instance and to notify listeners of
     * any detected changes.
     */
<span class="nc" id="L253">    private class NotifierTask extends CountedTimerTask {</span>
        public void run() {
<span class="nc" id="L255">            super.run();</span>
            try {
<span class="nc" id="L257">                MonitorStatus status = getMonitorStatus();</span>

<span class="nc" id="L259">                List inserted = status.getInserted();</span>
<span class="nc" id="L260">                List removed = status.getRemoved();</span>

<span class="nc bnc" id="L262" title="All 4 branches missed.">                if (!inserted.isEmpty() || !removed.isEmpty()) {</span>
<span class="nc" id="L263">                    fireMonitorStatusChangedEvents(inserted, removed);</span>
                }
<span class="nc" id="L265">            } catch (MonitorException e) {</span>
                // XXX: use logging api? fire disconnect events? mark errored?
                // fireDisconnectedEvents();
<span class="nc" id="L268">                System.err.println(&quot;Exception updating monitors for &quot;</span>
<span class="nc" id="L269">                                   + getVmIdentifier());</span>
<span class="nc" id="L270">                e.printStackTrace();</span>
                // XXX: should we cancle the notifierTask here?
                // this.cancel();
<span class="nc" id="L273">            }</span>
<span class="nc" id="L274">        }</span>
    }

    /**
     * Class to periodically sample the remote instrumentation byte buffer
     * and refresh the local copy. Registered listeners are notified of
     * the completion of a sampling event.
     */
<span class="nc" id="L282">    private class SamplerTask extends CountedTimerTask {</span>
        public void run() {
<span class="nc" id="L284">            super.run();</span>
            try {
<span class="nc" id="L286">                sample();</span>
<span class="nc" id="L287">                fireMonitorsUpdatedEvents();</span>

<span class="nc" id="L289">            } catch (RemoteException e) {</span>
                // XXX: use logging api, mark vm as errored.
<span class="nc" id="L291">                System.err.println(&quot;Exception taking sample for &quot;</span>
<span class="nc" id="L292">                                   + getVmIdentifier());</span>
<span class="nc" id="L293">                e.printStackTrace();</span>
<span class="nc" id="L294">                this.cancel();</span>
<span class="nc" id="L295">            }</span>
<span class="nc" id="L296">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>