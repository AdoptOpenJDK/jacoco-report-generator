<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MonitoredHostProvider.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.jvmstat.perfdata.monitor.protocol.rmi</a> &gt; <span class="el_source">MonitoredHostProvider.java</span></div><h1>MonitoredHostProvider.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.jvmstat.perfdata.monitor.protocol.rmi;

import sun.jvmstat.monitor.*;
import sun.jvmstat.monitor.event.*;
import sun.jvmstat.monitor.remote.*;
import sun.jvmstat.perfdata.monitor.*;
import java.util.*;
import java.net.*;
import java.io.*;
import java.rmi.*;
import java.util.HashMap;

/**
 * Concrete implementation of the MonitoredHost interface for the
 * &lt;em&gt;rmi&lt;/em&gt; protocol of the HotSpot PerfData monitoring implementation.
 *
 * @author Brian Doherty
 * @since 1.5
 */
public class MonitoredHostProvider extends MonitoredHost {
    private static final String serverName = &quot;/JStatRemoteHost&quot;;
    private static final int DEFAULT_POLLING_INTERVAL = 1000;

    private ArrayList&lt;HostListener&gt; listeners;
    private NotifierTask task;
    private HashSet&lt;Integer&gt; activeVms;
    private RemoteVmManager vmManager;
    private RemoteHost remoteHost;
    private Timer timer;

    /**
     * Create a MonitoredHostProvider instance using the given HostIdentifier.
     *
     * @param hostId the host identifier for this MonitoredHost
     * @throws MonitorException Thrown on any error encountered while
     *                          communicating with the remote host.
     */
    public MonitoredHostProvider(HostIdentifier hostId)
<span class="nc" id="L64">           throws MonitorException {</span>
<span class="nc" id="L65">        this.hostId = hostId;</span>
<span class="nc" id="L66">        this.listeners = new ArrayList&lt;HostListener&gt;();</span>
<span class="nc" id="L67">        this.interval = DEFAULT_POLLING_INTERVAL;</span>
<span class="nc" id="L68">        this.activeVms = new HashSet&lt;Integer&gt;();</span>

        String rmiName;
<span class="nc" id="L71">        String sn = serverName;</span>
<span class="nc" id="L72">        String path = hostId.getPath();</span>

<span class="nc bnc" id="L74" title="All 4 branches missed.">        if ((path != null) &amp;&amp; (path.length() &gt; 0)) {</span>
<span class="nc" id="L75">            sn = path;</span>
        }

<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (hostId.getPort() != -1) {</span>
<span class="nc" id="L79">            rmiName = &quot;rmi://&quot; + hostId.getHost() + &quot;:&quot; + hostId.getPort() + sn;</span>
        } else {
<span class="nc" id="L81">            rmiName = &quot;rmi://&quot; + hostId.getHost() + sn;</span>
        }

        try {
<span class="nc" id="L85">            remoteHost = (RemoteHost)Naming.lookup(rmiName);</span>

<span class="nc" id="L87">        } catch (RemoteException e) {</span>
            /*
             * rmi registry not available
             *
             * Access control exceptions, where the rmi server refuses a
             * connection based on policy file configuration, come through
             * here on the client side. Unfortunately, the RemoteException
             * doesn't contain enough information to determine the true cause
             * of the exception. So, we have to output a rather generic message.
             */
<span class="nc" id="L97">            String message = &quot;RMI Registry not available at &quot;</span>
<span class="nc" id="L98">                             + hostId.getHost();</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (hostId.getPort() == -1) {</span>
<span class="nc" id="L101">                message = message + &quot;:&quot;</span>
                          + java.rmi.registry.Registry.REGISTRY_PORT;
            } else {
<span class="nc" id="L104">                message = message + &quot;:&quot; + hostId.getPort();</span>
            }

<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (e.getMessage() != null) {</span>
<span class="nc" id="L108">                throw new MonitorException(message + &quot;\n&quot; + e.getMessage(), e);</span>
            } else {
<span class="nc" id="L110">                throw new MonitorException(message, e);</span>
            }

<span class="nc" id="L113">        } catch (NotBoundException e) {</span>
            // no server with given name
<span class="nc" id="L115">            String message = e.getMessage();</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            if (message == null) message = rmiName;</span>
<span class="nc" id="L117">            throw new MonitorException(&quot;RMI Server &quot; + message</span>
                                       + &quot; not available&quot;, e);
<span class="nc" id="L119">        } catch (MalformedURLException e) {</span>
            // this is a programming problem
<span class="nc" id="L121">            e.printStackTrace();</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;Malformed URL: &quot; + rmiName);</span>
<span class="nc" id="L123">        }</span>
<span class="nc" id="L124">        this.vmManager = new RemoteVmManager(remoteHost);</span>
<span class="nc" id="L125">        this.timer = new Timer(true);</span>
<span class="nc" id="L126">    }</span>

    /**
     * {@inheritDoc}
     */
    public MonitoredVm getMonitoredVm(VmIdentifier vmid)
                       throws MonitorException {
<span class="nc" id="L133">        return getMonitoredVm(vmid, DEFAULT_POLLING_INTERVAL);</span>
    }

    /**
     * {@inheritDoc}
     */
    public MonitoredVm getMonitoredVm(VmIdentifier vmid, int interval)
                       throws MonitorException {
<span class="nc" id="L141">        VmIdentifier nvmid = null;</span>
        try {
<span class="nc" id="L143">            nvmid = hostId.resolve(vmid);</span>
<span class="nc" id="L144">            RemoteVm rvm = remoteHost.attachVm(vmid.getLocalVmId(),</span>
<span class="nc" id="L145">                                               vmid.getMode());</span>
<span class="nc" id="L146">            RemoteMonitoredVm rmvm = new RemoteMonitoredVm(rvm, nvmid, timer,</span>
                                                           interval);
<span class="nc" id="L148">            rmvm.attach();</span>
<span class="nc" id="L149">            return rmvm;</span>

<span class="nc" id="L151">        } catch (RemoteException e) {</span>
<span class="nc" id="L152">            throw new MonitorException(&quot;Remote Exception attaching to &quot;</span>
<span class="nc" id="L153">                                       + nvmid.toString(), e);</span>
<span class="nc" id="L154">        } catch (URISyntaxException e) {</span>
            /*
             * the VmIdentifier is expected to be a valid and should resolve
             * easonably against the host identifier. A URISyntaxException
             * here is most likely a programming error.
             */
<span class="nc" id="L160">            throw new IllegalArgumentException(&quot;Malformed URI: &quot;</span>
<span class="nc" id="L161">                                               + vmid.toString(), e);</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    public void detach(MonitoredVm vm) throws MonitorException {
<span class="nc" id="L169">        RemoteMonitoredVm rmvm = (RemoteMonitoredVm)vm;</span>
<span class="nc" id="L170">        rmvm.detach();</span>
        try {
<span class="nc" id="L172">            remoteHost.detachVm(rmvm.getRemoteVm());</span>

<span class="nc" id="L174">        } catch (RemoteException e) {</span>
<span class="nc" id="L175">            throw new MonitorException(&quot;Remote Exception detaching from &quot;</span>
<span class="nc" id="L176">                                       + vm.getVmIdentifier().toString(), e);</span>
<span class="nc" id="L177">        }</span>
<span class="nc" id="L178">    }</span>

    /**
     * {@inheritDoc}
     */
    public void addHostListener(HostListener listener) {
<span class="nc" id="L184">        synchronized(listeners) {</span>
<span class="nc" id="L185">            listeners.add(listener);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (task == null) {</span>
<span class="nc" id="L187">                task = new NotifierTask();</span>
<span class="nc" id="L188">                timer.schedule(task, 0, interval);</span>
            }
<span class="nc" id="L190">        }</span>
<span class="nc" id="L191">    }</span>

    /**
     * {@inheritDoc}
     */
    public void removeHostListener(HostListener listener) {
        /*
         * XXX: if a disconnect method is added, make sure it calls
         * this method to unregister this object from the watcher. otherwise,
         * an unused MonitoredHostProvider instance may go uncollected.
         */
<span class="nc" id="L202">        synchronized(listeners) {</span>
<span class="nc" id="L203">            listeners.remove(listener);</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">            if (listeners.isEmpty() &amp;&amp; (task != null)) {</span>
<span class="nc" id="L205">                task.cancel();</span>
<span class="nc" id="L206">                task = null;</span>
            }
<span class="nc" id="L208">        }</span>
<span class="nc" id="L209">    }</span>

    public void setInterval(int newInterval) {
<span class="nc" id="L212">        synchronized(listeners) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (newInterval == interval) {</span>
<span class="nc" id="L214">                return;</span>
            }

<span class="nc" id="L217">            int oldInterval = interval;</span>
<span class="nc" id="L218">            super.setInterval(newInterval);</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">            if (task != null) {</span>
<span class="nc" id="L221">                task.cancel();</span>
<span class="nc" id="L222">                NotifierTask oldTask = task;</span>
<span class="nc" id="L223">                task = new NotifierTask();</span>
<span class="nc" id="L224">                CountedTimerTaskUtils.reschedule(timer, oldTask, task,</span>
                                                 oldInterval, newInterval);
            }
<span class="nc" id="L227">        }</span>
<span class="nc" id="L228">    }</span>

    /**
     * {@inheritDoc}
     */
    public Set&lt;Integer&gt; activeVms() throws MonitorException {
<span class="nc" id="L234">        return vmManager.activeVms();</span>
    }

    /**
     * Fire VmStatusChangeEvent events to HostListener objects
     *
     * @param active Set of Integer objects containing the local
     *               Vm Identifiers of the active JVMs
     * @param started Set of Integer objects containing the local
     *                Vm Identifiers of new JVMs started since last
     *                interval.
     * @param terminated Set of Integer objects containing the local
     *                   Vm Identifiers of terminated JVMs since last
     *                   interval.
     */
    private void fireVmStatusChangedEvents(Set active, Set started,
                                           Set terminated) {
<span class="nc" id="L251">        ArrayList registered = null;</span>
<span class="nc" id="L252">        VmStatusChangeEvent ev = null;</span>

<span class="nc" id="L254">        synchronized(listeners) {</span>
<span class="nc" id="L255">            registered = (ArrayList)listeners.clone();</span>
<span class="nc" id="L256">        }</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (Iterator i = registered.iterator(); i.hasNext(); /* empty */) {</span>
<span class="nc" id="L259">            HostListener l = (HostListener)i.next();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (ev == null) {</span>
<span class="nc" id="L261">                ev = new VmStatusChangeEvent(this, active, started, terminated);</span>
            }
<span class="nc" id="L263">            l.vmStatusChanged(ev);</span>
<span class="nc" id="L264">        }</span>
<span class="nc" id="L265">    }</span>

    /**
     * Fire hostDisconnectEvent events.
     */
    void fireDisconnectedEvents() {
<span class="nc" id="L271">        ArrayList registered = null;</span>
<span class="nc" id="L272">        HostEvent ev = null;</span>

<span class="nc" id="L274">        synchronized(listeners) {</span>
<span class="nc" id="L275">            registered = (ArrayList)listeners.clone();</span>
<span class="nc" id="L276">        }</span>

<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (Iterator i = registered.iterator(); i.hasNext(); /* empty */) {</span>
<span class="nc" id="L279">            HostListener l = (HostListener)i.next();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (ev == null) {</span>
<span class="nc" id="L281">                ev = new HostEvent(this);</span>
            }
<span class="nc" id="L283">            l.disconnected(ev);</span>
<span class="nc" id="L284">        }</span>
<span class="nc" id="L285">    }</span>

    /**
     * class to poll the remote machine and generate local event notifications.
     */
<span class="nc" id="L290">    private class NotifierTask extends CountedTimerTask {</span>
        public void run() {
<span class="nc" id="L292">            super.run();</span>

            // save the last set of active JVMs
<span class="nc" id="L295">            Set lastActiveVms = activeVms;</span>

            try {
                // get the current set of active JVMs
<span class="nc" id="L299">                activeVms = (HashSet&lt;Integer&gt;)vmManager.activeVms();</span>

<span class="nc" id="L301">            } catch (MonitorException e) {</span>
                // XXX: use logging api
<span class="nc" id="L303">                System.err.println(&quot;MonitoredHostProvider: polling task &quot;</span>
                                   + &quot;caught MonitorException:&quot;);
<span class="nc" id="L305">                e.printStackTrace();</span>

                // mark the HostManager as errored and notify listeners
<span class="nc" id="L308">                setLastException(e);</span>
<span class="nc" id="L309">                fireDisconnectedEvents();</span>
<span class="nc" id="L310">            }</span>

<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (activeVms.isEmpty()) {</span>
<span class="nc" id="L313">                return;</span>
            }

<span class="nc" id="L316">            Set&lt;Integer&gt; startedVms = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L317">            Set&lt;Object&gt; terminatedVms = new HashSet&lt;Object&gt;();</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">            for (Iterator i = activeVms.iterator(); i.hasNext(); /* empty */ ) {</span>
<span class="nc" id="L320">                Integer vmid = (Integer)i.next();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                if (!lastActiveVms.contains(vmid)) {</span>
                    // a new file has been detected, add to set
<span class="nc" id="L323">                    startedVms.add(vmid);</span>
                }
<span class="nc" id="L325">            }</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">            for (Iterator i = lastActiveVms.iterator(); i.hasNext();</span>
                    /* empty */ ) {
<span class="nc" id="L329">                Object o = i.next();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">                if (!activeVms.contains(o)) {</span>
                    // JVM has terminated, remove it from the active list
<span class="nc" id="L332">                    terminatedVms.add(o);</span>
                }
<span class="nc" id="L334">            }</span>

<span class="nc bnc" id="L336" title="All 4 branches missed.">            if (!startedVms.isEmpty() || !terminatedVms.isEmpty()) {</span>
<span class="nc" id="L337">                fireVmStatusChangedEvents(activeVms, startedVms, terminatedVms);</span>
            }
<span class="nc" id="L339">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>