<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BreakDictionary.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.util.locale.provider</a> &gt; <span class="el_source">BreakDictionary.java</span></div><h1>BreakDictionary.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 2002 - All Rights Reserved
 *
 * The original version of this source code and documentation
 * is copyrighted and owned by Taligent, Inc., a wholly-owned
 * subsidiary of IBM. These materials are provided under terms
 * of a License Agreement between Taligent and Sun. This technology
 * is protected by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 */
package sun.util.locale.provider;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.MissingResourceException;
import sun.text.CompactByteArray;
import sun.text.SupplementaryCharacterData;

/**
 * This is the class that represents the list of known words used by
 * DictionaryBasedBreakIterator.  The conceptual data structure used
 * here is a trie: there is a node hanging off the root node for every
 * letter that can start a word.  Each of these nodes has a node hanging
 * off of it for every letter that can be the second letter of a word
 * if this node is the first letter, and so on.  The trie is represented
 * as a two-dimensional array that can be treated as a table of state
 * transitions.  Indexes are used to compress this array, taking
 * advantage of the fact that this array will always be very sparse.
 */
class BreakDictionary {

    //=========================================================================
    // data members
    //=========================================================================

    /**
      * The version of the dictionary that was read in.
      */
<span class="nc" id="L71">    private static int supportedVersion = 1;</span>

    /**
     * Maps from characters to column numbers.  The main use of this is to
     * avoid making room in the array for empty columns.
     */
<span class="nc" id="L77">    private CompactByteArray columnMap = null;</span>
<span class="nc" id="L78">    private SupplementaryCharacterData supplementaryCharColumnMap = null;</span>

    /**
     * The number of actual columns in the table
     */
    private int numCols;

    /**
     * Columns are organized into groups of 32.  This says how many
     * column groups.  (We could calculate this, but we store the
     * value to avoid having to repeatedly calculate it.)
     */
    private int numColGroups;

    /**
     * The actual compressed state table.  Each conceptual row represents
     * a state, and the cells in it contain the row numbers of the states
     * to transition to for each possible letter.  0 is used to indicate
     * an illegal combination of letters (i.e., the error state).  The
     * table is compressed by eliminating all the unpopulated (i.e., zero)
     * cells.  Multiple conceptual rows can then be doubled up in a single
     * physical row by sliding them up and possibly shifting them to one
     * side or the other so the populated cells don't collide.  Indexes
     * are used to identify unpopulated cells and to locate populated cells.
     */
<span class="nc" id="L103">    private short[] table = null;</span>

    /**
     * This index maps logical row numbers to physical row numbers
     */
<span class="nc" id="L108">    private short[] rowIndex = null;</span>

    /**
     * A bitmap is used to tell which cells in the comceptual table are
     * populated.  This array contains all the unique bit combinations
     * in that bitmap.  If the table is more than 32 columns wide,
     * successive entries in this array are used for a single row.
     */
<span class="nc" id="L116">    private int[] rowIndexFlags = null;</span>

    /**
     * This index maps from a logical row number into the bitmap table above.
     * (This keeps us from storing duplicate bitmap combinations.)  Since there
     * are a lot of rows with only one populated cell, instead of wasting space
     * in the bitmap table, we just store a negative number in this index for
     * rows with one populated cell.  The absolute value of that number is
     * the column number of the populated cell.
     */
<span class="nc" id="L126">    private short[] rowIndexFlagsIndex = null;</span>

    /**
     * For each logical row, this index contains a constant that is added to
     * the logical column number to get the physical column number
     */
<span class="nc" id="L132">    private byte[] rowIndexShifts = null;</span>

    //=========================================================================
    // deserialization
    //=========================================================================

    BreakDictionary(String dictionaryName)
<span class="nc" id="L139">        throws IOException, MissingResourceException {</span>

<span class="nc" id="L141">        readDictionaryFile(dictionaryName);</span>
<span class="nc" id="L142">    }</span>

    private void readDictionaryFile(final String dictionaryName)
        throws IOException, MissingResourceException {

        BufferedInputStream in;
        try {
<span class="nc" id="L149">            in = AccessController.doPrivileged(</span>
<span class="nc" id="L150">                new PrivilegedExceptionAction&lt;BufferedInputStream&gt;() {</span>
                    @Override
                    public BufferedInputStream run() throws Exception {
<span class="nc" id="L153">                        return new BufferedInputStream(getClass().getResourceAsStream(&quot;/sun/text/resources/&quot; + dictionaryName));</span>
                    }
                }
            );
        }
<span class="nc" id="L158">        catch (PrivilegedActionException e) {</span>
<span class="nc" id="L159">            throw new InternalError(e.toString(), e);</span>
<span class="nc" id="L160">        }</span>

<span class="nc" id="L162">        byte[] buf = new byte[8];</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (in.read(buf) != 8) {</span>
<span class="nc" id="L164">            throw new MissingResourceException(&quot;Wrong data length&quot;,</span>
                                               dictionaryName, &quot;&quot;);
        }

        // check version
<span class="nc" id="L169">        int version = RuleBasedBreakIterator.getInt(buf, 0);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (version != supportedVersion) {</span>
<span class="nc" id="L171">            throw new MissingResourceException(&quot;Dictionary version(&quot; + version + &quot;) is unsupported&quot;,</span>
                                                           dictionaryName, &quot;&quot;);
        }

        // get data size
<span class="nc" id="L176">        int len = RuleBasedBreakIterator.getInt(buf, 4);</span>
<span class="nc" id="L177">        buf = new byte[len];</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (in.read(buf) != len) {</span>
<span class="nc" id="L179">            throw new MissingResourceException(&quot;Wrong data length&quot;,</span>
                                               dictionaryName, &quot;&quot;);
        }

        // close the stream
<span class="nc" id="L184">        in.close();</span>

        int l;
<span class="nc" id="L187">        int offset = 0;</span>

        // read in the column map for BMP characteres (this is serialized in
        // its internal form: an index array followed by a data array)
<span class="nc" id="L191">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L192">        offset += 4;</span>
<span class="nc" id="L193">        short[] temp = new short[l];</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=2) {</span>
<span class="nc" id="L195">            temp[i] = RuleBasedBreakIterator.getShort(buf, offset);</span>
        }
<span class="nc" id="L197">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L198">        offset += 4;</span>
<span class="nc" id="L199">        byte[] temp2 = new byte[l];</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset++) {</span>
<span class="nc" id="L201">            temp2[i] = buf[offset];</span>
        }
<span class="nc" id="L203">        columnMap = new CompactByteArray(temp, temp2);</span>

        // read in numCols and numColGroups
<span class="nc" id="L206">        numCols = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L207">        offset += 4;</span>
<span class="nc" id="L208">        numColGroups = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L209">        offset += 4;</span>

        // read in the row-number index
<span class="nc" id="L212">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L213">        offset += 4;</span>
<span class="nc" id="L214">        rowIndex = new short[l];</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=2) {</span>
<span class="nc" id="L216">            rowIndex[i] = RuleBasedBreakIterator.getShort(buf, offset);</span>
        }

        // load in the populated-cells bitmap: index first, then bitmap list
<span class="nc" id="L220">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L221">        offset += 4;</span>
<span class="nc" id="L222">        rowIndexFlagsIndex = new short[l];</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=2) {</span>
<span class="nc" id="L224">            rowIndexFlagsIndex[i] = RuleBasedBreakIterator.getShort(buf, offset);</span>
        }
<span class="nc" id="L226">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L227">        offset += 4;</span>
<span class="nc" id="L228">        rowIndexFlags = new int[l];</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=4) {</span>
<span class="nc" id="L230">            rowIndexFlags[i] = RuleBasedBreakIterator.getInt(buf, offset);</span>
        }

        // load in the row-shift index
<span class="nc" id="L234">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L235">        offset += 4;</span>
<span class="nc" id="L236">        rowIndexShifts = new byte[l];</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset++) {</span>
<span class="nc" id="L238">            rowIndexShifts[i] = buf[offset];</span>
        }

        // load in the actual state table
<span class="nc" id="L242">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L243">        offset += 4;</span>
<span class="nc" id="L244">        table = new short[l];</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=2) {</span>
<span class="nc" id="L246">            table[i] = RuleBasedBreakIterator.getShort(buf, offset);</span>
        }

        // finally, prepare the column map for supplementary characters
<span class="nc" id="L250">        l = RuleBasedBreakIterator.getInt(buf, offset);</span>
<span class="nc" id="L251">        offset += 4;</span>
<span class="nc" id="L252">        int[] temp3 = new int[l];</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        for (int i = 0; i &lt; l; i++, offset+=4) {</span>
<span class="nc" id="L254">            temp3[i] = RuleBasedBreakIterator.getInt(buf, offset);</span>
        }
<span class="nc" id="L256">        supplementaryCharColumnMap = new SupplementaryCharacterData(temp3);</span>
<span class="nc" id="L257">    }</span>

    //=========================================================================
    // access to the words
    //=========================================================================

    /**
     * Uses the column map to map the character to a column number, then
     * passes the row and column number to getNextState()
     * @param row The current state
     * @param ch The character whose column we're interested in
     * @return The new state to transition to
     */
    public final short getNextStateFromCharacter(int row, int ch) {
        int col;
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {</span>
<span class="nc" id="L273">            col = columnMap.elementAt((char)ch);</span>
        } else {
<span class="nc" id="L275">            col = supplementaryCharColumnMap.getValue(ch);</span>
        }
<span class="nc" id="L277">        return getNextState(row, col);</span>
    }

    /**
     * Returns the value in the cell with the specified (logical) row and
     * column numbers.  In DictionaryBasedBreakIterator, the row number is
     * a state number, the column number is an input, and the return value
     * is the row number of the new state to transition to.  (0 is the
     * &quot;error&quot; state, and -1 is the &quot;end of word&quot; state in a dictionary)
     * @param row The row number of the current state
     * @param col The column number of the input character (0 means &quot;not a
     * dictionary character&quot;)
     * @return The row number of the new state to transition to
     */
    public final short getNextState(int row, int col) {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (cellIsPopulated(row, col)) {</span>
            // we map from logical to physical row number by looking up the
            // mapping in rowIndex; we map from logical column number to
            // physical column number by looking up a shift value for this
            // logical row and offsetting the logical column number by
            // the shift amount.  Then we can use internalAt() to actually
            // get the value out of the table.
<span class="nc" id="L299">            return internalAt(rowIndex[row], col + rowIndexShifts[row]);</span>
        }
        else {
<span class="nc" id="L302">            return 0;</span>
        }
    }

    /**
     * Given (logical) row and column numbers, returns true if the
     * cell in that position is populated
     */
    private boolean cellIsPopulated(int row, int col) {
        // look up the entry in the bitmap index for the specified row.
        // If it's a negative number, it's the column number of the only
        // populated cell in the row
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (rowIndexFlagsIndex[row] &lt; 0) {</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            return col == -rowIndexFlagsIndex[row];</span>
        }

        // if it's a positive number, it's the offset of an entry in the bitmap
        // list.  If the table is more than 32 columns wide, the bitmap is stored
        // successive entries in the bitmap list, so we have to divide the column
        // number by 32 and offset the number we got out of the index by the result.
        // Once we have the appropriate piece of the bitmap, test the appropriate
        // bit and return the result.
        else {
<span class="nc" id="L325">            int flags = rowIndexFlags[rowIndexFlagsIndex[row] + (col &gt;&gt; 5)];</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">            return (flags &amp; (1 &lt;&lt; (col &amp; 0x1f))) != 0;</span>
        }
    }

    /**
     * Implementation of getNextState() when we know the specified cell is
     * populated.
     * @param row The PHYSICAL row number of the cell
     * @param col The PHYSICAL column number of the cell
     * @return The value stored in the cell
     */
    private short internalAt(int row, int col) {
        // the table is a one-dimensional array, so this just does the math necessary
        // to treat it as a two-dimensional array (we don't just use a two-dimensional
        // array because two-dimensional arrays are inefficient in Java)
<span class="nc" id="L341">        return table[row * numCols + col];</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>