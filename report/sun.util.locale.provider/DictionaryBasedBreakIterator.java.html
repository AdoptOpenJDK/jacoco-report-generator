<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DictionaryBasedBreakIterator.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.util.locale.provider</a> &gt; <span class="el_source">DictionaryBasedBreakIterator.java</span></div><h1>DictionaryBasedBreakIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
 * (C) Copyright IBM Corp. 1996 - 2002 - All Rights Reserved
 *
 * The original version of this source code and documentation
 * is copyrighted and owned by Taligent, Inc., a wholly-owned
 * subsidiary of IBM. These materials are provided under terms
 * of a License Agreement between Taligent and Sun. This technology
 * is protected by multiple US and International patents.
 *
 * This notice and attribution to Taligent may not be removed.
 * Taligent is a registered trademark of Taligent, Inc.
 */

package sun.util.locale.provider;

import java.io.IOException;
import java.text.CharacterIterator;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * A subclass of RuleBasedBreakIterator that adds the ability to use a dictionary
 * to further subdivide ranges of text beyond what is possible using just the
 * state-table-based algorithm.  This is necessary, for example, to handle
 * word and line breaking in Thai, which doesn't use spaces between words.  The
 * state-table-based algorithm used by RuleBasedBreakIterator is used to divide
 * up text as far as possible, and then contiguous ranges of letters are
 * repeatedly compared against a list of known words (i.e., the dictionary)
 * to divide them up into words.
 *
 * DictionaryBasedBreakIterator uses the same rule language as RuleBasedBreakIterator,
 * but adds one more special substitution name: &amp;lt;dictionary&amp;gt;.  This substitution
 * name is used to identify characters in words in the dictionary.  The idea is that
 * if the iterator passes over a chunk of text that includes two or more characters
 * in a row that are included in &amp;lt;dictionary&amp;gt;, it goes back through that range and
 * derives additional break positions (if possible) using the dictionary.
 *
 * DictionaryBasedBreakIterator is also constructed with the filename of a dictionary
 * file.  It follows a prescribed search path to locate the dictionary (right now,
 * it looks for it in /com/ibm/text/resources in each directory in the classpath,
 * and won't find it in JAR files, but this location is likely to change).  The
 * dictionary file is in a serialized binary format.  We have a very primitive (and
 * slow) BuildDictionaryFile utility for creating dictionary files, but aren't
 * currently making it public.  Contact us for help.
 */
class DictionaryBasedBreakIterator extends RuleBasedBreakIterator {

    /**
     * a list of known words that is used to divide up contiguous ranges of letters,
     * stored in a compressed, indexed, format that offers fast access
     */
    private BreakDictionary dictionary;

    /**
     * a list of flags indicating which character categories are contained in
     * the dictionary file (this is used to determine which ranges of characters
     * to apply the dictionary to)
     */
    private boolean[] categoryFlags;

    /**
     * a temporary hiding place for the number of dictionary characters in the
     * last range passed over by next()
     */
    private int dictionaryCharCount;

    /**
     * when a range of characters is divided up using the dictionary, the break
     * positions that are discovered are stored here, preventing us from having
     * to use either the dictionary or the state table again until the iterator
     * leaves this range of text
     */
    private int[] cachedBreakPositions;

    /**
     * if cachedBreakPositions is not null, this indicates which item in the
     * cache the current iteration position refers to
     */
    private int positionInCache;

    /**
     * Constructs a DictionaryBasedBreakIterator.
     * @param description Same as the description parameter on RuleBasedBreakIterator,
     * except for the special meaning of &quot;&lt;dictionary&gt;&quot;.  This parameter is just
     * passed through to RuleBasedBreakIterator's constructor.
     * @param dictionaryFilename The filename of the dictionary file to use
     */
    DictionaryBasedBreakIterator(String dataFile, String dictionaryFile)
                                        throws IOException {
<span class="nc" id="L118">        super(dataFile);</span>
<span class="nc" id="L119">        byte[] tmp = super.getAdditionalData();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (tmp != null) {</span>
<span class="nc" id="L121">            prepareCategoryFlags(tmp);</span>
<span class="nc" id="L122">            super.setAdditionalData(null);</span>
        }
<span class="nc" id="L124">        dictionary = new BreakDictionary(dictionaryFile);</span>
<span class="nc" id="L125">    }</span>

    private void prepareCategoryFlags(byte[] data) {
<span class="nc" id="L128">        categoryFlags = new boolean[data.length];</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        for (int i = 0; i &lt; data.length; i++) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            categoryFlags[i] = (data[i] == (byte)1) ? true : false;</span>
        }
<span class="nc" id="L132">    }</span>

    @Override
    public void setText(CharacterIterator newText) {
<span class="nc" id="L136">        super.setText(newText);</span>
<span class="nc" id="L137">        cachedBreakPositions = null;</span>
<span class="nc" id="L138">        dictionaryCharCount = 0;</span>
<span class="nc" id="L139">        positionInCache = 0;</span>
<span class="nc" id="L140">    }</span>

    /**
     * Sets the current iteration position to the beginning of the text.
     * (i.e., the CharacterIterator's starting offset).
     * @return The offset of the beginning of the text.
     */
    @Override
    public int first() {
<span class="nc" id="L149">        cachedBreakPositions = null;</span>
<span class="nc" id="L150">        dictionaryCharCount = 0;</span>
<span class="nc" id="L151">        positionInCache = 0;</span>
<span class="nc" id="L152">        return super.first();</span>
    }

    /**
     * Sets the current iteration position to the end of the text.
     * (i.e., the CharacterIterator's ending offset).
     * @return The text's past-the-end offset.
     */
    @Override
    public int last() {
<span class="nc" id="L162">        cachedBreakPositions = null;</span>
<span class="nc" id="L163">        dictionaryCharCount = 0;</span>
<span class="nc" id="L164">        positionInCache = 0;</span>
<span class="nc" id="L165">        return super.last();</span>
    }

    /**
     * Advances the iterator one step backwards.
     * @return The position of the last boundary position before the
     * current iteration position
     */
    @Override
    public int previous() {
<span class="nc" id="L175">        CharacterIterator text = getText();</span>

        // if we have cached break positions and we're still in the range
        // covered by them, just move one step backward in the cache
<span class="nc bnc" id="L179" title="All 4 branches missed.">        if (cachedBreakPositions != null &amp;&amp; positionInCache &gt; 0) {</span>
<span class="nc" id="L180">            --positionInCache;</span>
<span class="nc" id="L181">            text.setIndex(cachedBreakPositions[positionInCache]);</span>
<span class="nc" id="L182">            return cachedBreakPositions[positionInCache];</span>
        }

        // otherwise, dump the cache and use the inherited previous() method to move
        // backward.  This may fill up the cache with new break positions, in which
        // case we have to mark our position in the cache
        else {
<span class="nc" id="L189">            cachedBreakPositions = null;</span>
<span class="nc" id="L190">            int result = super.previous();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (cachedBreakPositions != null) {</span>
<span class="nc" id="L192">                positionInCache = cachedBreakPositions.length - 2;</span>
            }
<span class="nc" id="L194">            return result;</span>
        }
    }

    /**
     * Sets the current iteration position to the last boundary position
     * before the specified position.
     * @param offset The position to begin searching from
     * @return The position of the last boundary before &quot;offset&quot;
     */
    @Override
    public int preceding(int offset) {
<span class="nc" id="L206">        CharacterIterator text = getText();</span>
<span class="nc" id="L207">        checkOffset(offset, text);</span>

        // if we have no cached break positions, or &quot;offset&quot; is outside the
        // range covered by the cache, we can just call the inherited routine
        // (which will eventually call other routines in this class that may
        // refresh the cache)
<span class="nc bnc" id="L213" title="All 6 branches missed.">        if (cachedBreakPositions == null || offset &lt;= cachedBreakPositions[0] ||</span>
                offset &gt; cachedBreakPositions[cachedBreakPositions.length - 1]) {
<span class="nc" id="L215">            cachedBreakPositions = null;</span>
<span class="nc" id="L216">            return super.preceding(offset);</span>
        }

        // on the other hand, if &quot;offset&quot; is within the range covered by the cache,
        // then all we have to do is search the cache for the last break position
        // before &quot;offset&quot;
        else {
<span class="nc" id="L223">            positionInCache = 0;</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">            while (positionInCache &lt; cachedBreakPositions.length</span>
                   &amp;&amp; offset &gt; cachedBreakPositions[positionInCache]) {
<span class="nc" id="L226">                ++positionInCache;</span>
            }
<span class="nc" id="L228">            --positionInCache;</span>
<span class="nc" id="L229">            text.setIndex(cachedBreakPositions[positionInCache]);</span>
<span class="nc" id="L230">            return text.getIndex();</span>
        }
    }

    /**
     * Sets the current iteration position to the first boundary position after
     * the specified position.
     * @param offset The position to begin searching forward from
     * @return The position of the first boundary after &quot;offset&quot;
     */
    @Override
    public int following(int offset) {
<span class="nc" id="L242">        CharacterIterator text = getText();</span>
<span class="nc" id="L243">        checkOffset(offset, text);</span>

        // if we have no cached break positions, or if &quot;offset&quot; is outside the
        // range covered by the cache, then dump the cache and call our
        // inherited following() method.  This will call other methods in this
        // class that may refresh the cache.
<span class="nc bnc" id="L249" title="All 6 branches missed.">        if (cachedBreakPositions == null || offset &lt; cachedBreakPositions[0] ||</span>
                offset &gt;= cachedBreakPositions[cachedBreakPositions.length - 1]) {
<span class="nc" id="L251">            cachedBreakPositions = null;</span>
<span class="nc" id="L252">            return super.following(offset);</span>
        }

        // on the other hand, if &quot;offset&quot; is within the range covered by the
        // cache, then just search the cache for the first break position
        // after &quot;offset&quot;
        else {
<span class="nc" id="L259">            positionInCache = 0;</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            while (positionInCache &lt; cachedBreakPositions.length</span>
                   &amp;&amp; offset &gt;= cachedBreakPositions[positionInCache]) {
<span class="nc" id="L262">                ++positionInCache;</span>
            }
<span class="nc" id="L264">            text.setIndex(cachedBreakPositions[positionInCache]);</span>
<span class="nc" id="L265">            return text.getIndex();</span>
        }
    }

    /**
     * This is the implementation function for next().
     */
    @Override
    protected int handleNext() {
<span class="nc" id="L274">        CharacterIterator text = getText();</span>

        // if there are no cached break positions, or if we've just moved
        // off the end of the range covered by the cache, we have to dump
        // and possibly regenerate the cache
<span class="nc bnc" id="L279" title="All 4 branches missed.">        if (cachedBreakPositions == null ||</span>
            positionInCache == cachedBreakPositions.length - 1) {

            // start by using the inherited handleNext() to find a tentative return
            // value.   dictionaryCharCount tells us how many dictionary characters
            // we passed over on our way to the tentative return value
<span class="nc" id="L285">            int startPos = text.getIndex();</span>
<span class="nc" id="L286">            dictionaryCharCount = 0;</span>
<span class="nc" id="L287">            int result = super.handleNext();</span>

            // if we passed over more than one dictionary character, then we use
            // divideUpDictionaryRange() to regenerate the cached break positions
            // for the new range
<span class="nc bnc" id="L292" title="All 4 branches missed.">            if (dictionaryCharCount &gt; 1 &amp;&amp; result - startPos &gt; 1) {</span>
<span class="nc" id="L293">                divideUpDictionaryRange(startPos, result);</span>
            }

            // otherwise, the value we got back from the inherited fuction
            // is our return value, and we can dump the cache
            else {
<span class="nc" id="L299">                cachedBreakPositions = null;</span>
<span class="nc" id="L300">                return result;</span>
            }
        }

        // if the cache of break positions has been regenerated (or existed all
        // along), then just advance to the next break position in the cache
        // and return it
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (cachedBreakPositions != null) {</span>
<span class="nc" id="L308">            ++positionInCache;</span>
<span class="nc" id="L309">            text.setIndex(cachedBreakPositions[positionInCache]);</span>
<span class="nc" id="L310">            return cachedBreakPositions[positionInCache];</span>
        }
<span class="nc" id="L312">        return -9999;   // SHOULD NEVER GET HERE!</span>
    }

    /**
     * Looks up a character category for a character.
     */
    @Override
    protected int lookupCategory(int c) {
        // this override of lookupCategory() exists only to keep track of whether we've
        // passed over any dictionary characters.  It calls the inherited lookupCategory()
        // to do the real work, and then checks whether its return value is one of the
        // categories represented in the dictionary.  If it is, bump the dictionary-
        // character count.
<span class="nc" id="L325">        int result = super.lookupCategory(c);</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">        if (result != RuleBasedBreakIterator.IGNORE &amp;&amp; categoryFlags[result]) {</span>
<span class="nc" id="L327">            ++dictionaryCharCount;</span>
        }
<span class="nc" id="L329">        return result;</span>
    }

    /**
     * This is the function that actually implements the dictionary-based
     * algorithm.  Given the endpoints of a range of text, it uses the
     * dictionary to determine the positions of any boundaries in this
     * range.  It stores all the boundary positions it discovers in
     * cachedBreakPositions so that we only have to do this work once
     * for each time we enter the range.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void divideUpDictionaryRange(int startPos, int endPos) {
<span class="nc" id="L342">        CharacterIterator text = getText();</span>

        // the range we're dividing may begin or end with non-dictionary characters
        // (i.e., for line breaking, we may have leading or trailing punctuation
        // that needs to be kept with the word).  Seek from the beginning of the
        // range to the first dictionary character
<span class="nc" id="L348">        text.setIndex(startPos);</span>
<span class="nc" id="L349">        int c = getCurrent();</span>
<span class="nc" id="L350">        int category = lookupCategory(c);</span>
<span class="nc bnc" id="L351" title="All 4 branches missed.">        while (category == IGNORE || !categoryFlags[category]) {</span>
<span class="nc" id="L352">            c = getNext();</span>
<span class="nc" id="L353">            category = lookupCategory(c);</span>
        }

        // initialize.  We maintain two stacks: currentBreakPositions contains
        // the list of break positions that will be returned if we successfully
        // finish traversing the whole range now.  possibleBreakPositions lists
        // all other possible word ends we've passed along the way.  (Whenever
        // we reach an error [a sequence of characters that can't begin any word
        // in the dictionary], we back up, possibly delete some breaks from
        // currentBreakPositions, move a break from possibleBreakPositions
        // to currentBreakPositions, and start over from there.  This process
        // continues in this way until we either successfully make it all the way
        // across the range, or exhaust all of our combinations of break
        // positions.)
<span class="nc" id="L367">        Stack&lt;Integer&gt; currentBreakPositions = new Stack&lt;&gt;();</span>
<span class="nc" id="L368">        Stack&lt;Integer&gt; possibleBreakPositions = new Stack&lt;&gt;();</span>
<span class="nc" id="L369">        List&lt;Integer&gt; wrongBreakPositions = new ArrayList&lt;&gt;();</span>

        // the dictionary is implemented as a trie, which is treated as a state
        // machine.  -1 represents the end of a legal word.  Every word in the
        // dictionary is represented by a path from the root node to -1.  A path
        // that ends in state 0 is an illegal combination of characters.
<span class="nc" id="L375">        int state = 0;</span>

        // these two variables are used for error handling.  We keep track of the
        // farthest we've gotten through the range being divided, and the combination
        // of breaks that got us that far.  If we use up all possible break
        // combinations, the text contains an error or a word that's not in the
        // dictionary.  In this case, we &quot;bless&quot; the break positions that got us the
        // farthest as real break positions, and then start over from scratch with
        // the character where the error occurred.
<span class="nc" id="L384">        int farthestEndPoint = text.getIndex();</span>
<span class="nc" id="L385">        Stack&lt;Integer&gt; bestBreakPositions = null;</span>

        // initialize (we always exit the loop with a break statement)
<span class="nc" id="L388">        c = getCurrent();</span>
        while (true) {

            // if we can transition to state &quot;-1&quot; from our current state, we're
            // on the last character of a legal word.  Push that position onto
            // the possible-break-positions stack
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (dictionary.getNextState(state, 0) == -1) {</span>
<span class="nc" id="L395">                possibleBreakPositions.push(text.getIndex());</span>
            }

            // look up the new state to transition to in the dictionary
<span class="nc" id="L399">            state = dictionary.getNextStateFromCharacter(state, c);</span>

            // if the character we're sitting on causes us to transition to
            // the &quot;end of word&quot; state, then it was a non-dictionary character
            // and we've successfully traversed the whole range.  Drop out
            // of the loop.
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (state == -1) {</span>
<span class="nc" id="L406">                currentBreakPositions.push(text.getIndex());</span>
<span class="nc" id="L407">                break;</span>
            }

            // if the character we're sitting on causes us to transition to
            // the error state, or if we've gone off the end of the range
            // without transitioning to the &quot;end of word&quot; state, we've hit
            // an error...
<span class="nc bnc" id="L414" title="All 4 branches missed.">            else if (state == 0 || text.getIndex() &gt;= endPos) {</span>

                // if this is the farthest we've gotten, take note of it in
                // case there's an error in the text
<span class="nc bnc" id="L418" title="All 2 branches missed.">                if (text.getIndex() &gt; farthestEndPoint) {</span>
<span class="nc" id="L419">                    farthestEndPoint = text.getIndex();</span>

                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L422">                    Stack&lt;Integer&gt; currentBreakPositionsCopy = (Stack&lt;Integer&gt;) currentBreakPositions.clone();</span>

<span class="nc" id="L424">                    bestBreakPositions = currentBreakPositionsCopy;</span>
                }

                // wrongBreakPositions is a list of all break positions
                // we've tried starting that didn't allow us to traverse
                // all the way through the text.  Every time we pop a
                // break position off of currentBreakPositions, we put it
                // into wrongBreakPositions to avoid trying it again later.
                // If we make it to this spot, we're either going to back
                // up to a break in possibleBreakPositions and try starting
                // over from there, or we've exhausted all possible break
                // positions and are going to do the fallback procedure.
                // This loop prevents us from messing with anything in
                // possibleBreakPositions that didn't work as a starting
                // point the last time we tried it (this is to prevent a bunch of
                // repetitive checks from slowing down some extreme cases)
<span class="nc bnc" id="L440" title="All 2 branches missed.">                while (!possibleBreakPositions.isEmpty()</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                        &amp;&amp; wrongBreakPositions.contains(possibleBreakPositions.peek())) {</span>
<span class="nc" id="L442">                    possibleBreakPositions.pop();</span>
                }

                // if we've used up all possible break-position combinations, there's
                // an error or an unknown word in the text.  In this case, we start
                // over, treating the farthest character we've reached as the beginning
                // of the range, and &quot;blessing&quot; the break positions that got us that
                // far as real break positions
<span class="nc bnc" id="L450" title="All 2 branches missed.">                if (possibleBreakPositions.isEmpty()) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                    if (bestBreakPositions != null) {</span>
<span class="nc" id="L452">                        currentBreakPositions = bestBreakPositions;</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                        if (farthestEndPoint &lt; endPos) {</span>
<span class="nc" id="L454">                            text.setIndex(farthestEndPoint + 1);</span>
                        }
                        else {
                            break;
                        }
                    }
                    else {
<span class="nc bnc" id="L461" title="All 2 branches missed.">                        if ((currentBreakPositions.size() == 0 ||</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                             currentBreakPositions.peek().intValue() != text.getIndex())</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                            &amp;&amp; text.getIndex() != startPos) {</span>
<span class="nc" id="L464">                            currentBreakPositions.push(new Integer(text.getIndex()));</span>
                        }
<span class="nc" id="L466">                        getNext();</span>
<span class="nc" id="L467">                        currentBreakPositions.push(new Integer(text.getIndex()));</span>
                    }
                }

                // if we still have more break positions we can try, then promote the
                // last break in possibleBreakPositions into currentBreakPositions,
                // and get rid of all entries in currentBreakPositions that come after
                // it.  Then back up to that position and start over from there (i.e.,
                // treat that position as the beginning of a new word)
                else {
<span class="nc" id="L477">                    Integer temp = possibleBreakPositions.pop();</span>
<span class="nc" id="L478">                    Integer temp2 = null;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                    while (!currentBreakPositions.isEmpty() &amp;&amp; temp.intValue() &lt;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                           currentBreakPositions.peek().intValue()) {</span>
<span class="nc" id="L481">                        temp2 = currentBreakPositions.pop();</span>
<span class="nc" id="L482">                        wrongBreakPositions.add(temp2);</span>
                    }
<span class="nc" id="L484">                    currentBreakPositions.push(temp);</span>
<span class="nc" id="L485">                    text.setIndex(currentBreakPositions.peek().intValue());</span>
                }

                // re-sync &quot;c&quot; for the next go-round, and drop out of the loop if
                // we've made it off the end of the range
<span class="nc" id="L490">                c = getCurrent();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (text.getIndex() &gt;= endPos) {</span>
<span class="nc" id="L492">                    break;</span>
                }
            }

            // if we didn't hit any exceptional conditions on this last iteration,
            // just advance to the next character and loop
            else {
<span class="nc" id="L499">                c = getNext();</span>
            }
        }

        // dump the last break position in the list, and replace it with the actual
        // end of the range (which may be the same character, or may be further on
        // because the range actually ended with non-dictionary characters we want to
        // keep with the word)
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (!currentBreakPositions.isEmpty()) {</span>
<span class="nc" id="L508">            currentBreakPositions.pop();</span>
        }
<span class="nc" id="L510">        currentBreakPositions.push(endPos);</span>

        // create a regular array to hold the break positions and copy
        // the break positions from the stack to the array (in addition,
        // our starting position goes into this array as a break position).
        // This array becomes the cache of break positions used by next()
        // and previous(), so this is where we actually refresh the cache.
<span class="nc" id="L517">        cachedBreakPositions = new int[currentBreakPositions.size() + 1];</span>
<span class="nc" id="L518">        cachedBreakPositions[0] = startPos;</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">        for (int i = 0; i &lt; currentBreakPositions.size(); i++) {</span>
<span class="nc" id="L521">            cachedBreakPositions[i + 1] = currentBreakPositions.elementAt(i).intValue();</span>
        }
<span class="nc" id="L523">        positionInCache = 0;</span>
<span class="nc" id="L524">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>