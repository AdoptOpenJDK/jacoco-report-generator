<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Duration.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.time</a> &gt; <span class="el_source">Duration.java</span></div><h1>Duration.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time;

import static java.time.LocalTime.NANOS_PER_SECOND;
import static java.time.LocalTime.SECONDS_PER_DAY;
import static java.time.LocalTime.SECONDS_PER_HOUR;
import static java.time.LocalTime.SECONDS_PER_MINUTE;
import static java.time.temporal.ChronoField.NANO_OF_SECOND;
import static java.time.temporal.ChronoUnit.DAYS;
import static java.time.temporal.ChronoUnit.NANOS;
import static java.time.temporal.ChronoUnit.SECONDS;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.time.temporal.TemporalAmount;
import java.time.temporal.TemporalUnit;
import java.time.temporal.UnsupportedTemporalTypeException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A time-based amount of time, such as '34.5 seconds'.
 * &lt;p&gt;
 * This class models a quantity or amount of time in terms of seconds and nanoseconds.
 * It can be accessed using other duration-based units, such as minutes and hours.
 * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
 * exactly equal to 24 hours, thus ignoring daylight savings effects.
 * See {@link Period} for the date-based equivalent to this class.
 * &lt;p&gt;
 * A physical duration could be of infinite length.
 * For practicality, the duration is stored with constraints similar to {@link Instant}.
 * The duration uses nanosecond resolution with a maximum value of the seconds that can
 * be held in a {@code long}. This is greater than the current estimated age of the universe.
 * &lt;p&gt;
 * The range of a duration requires the storage of a number larger than a {@code long}.
 * To achieve this, the class stores a {@code long} representing seconds and an {@code int}
 * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 * The model is of a directed duration, meaning that the duration may be negative.
 * &lt;p&gt;
 * The duration is measured in &quot;seconds&quot;, but these are not necessarily identical to
 * the scientific &quot;SI second&quot; definition based on atomic clocks.
 * This difference only impacts durations measured near a leap-second and should not affect
 * most applications.
 * See {@link Instant} for a discussion as to the meaning of the second and time-scales.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class Duration
        implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable {

    /**
     * Constant for a duration of zero.
     */
<span class="fc" id="L132">    public static final Duration ZERO = new Duration(0, 0);</span>
    /**
     * Serialization version.
     */
    private static final long serialVersionUID = 3078945930695997490L;
    /**
     * Constant for nanos per second.
     */
<span class="fc" id="L140">    private static final BigInteger BI_NANOS_PER_SECOND = BigInteger.valueOf(NANOS_PER_SECOND);</span>
    /**
     * The pattern for parsing.
     */
<span class="fc" id="L144">    private static final Pattern PATTERN =</span>
<span class="fc" id="L145">            Pattern.compile(&quot;([-+]?)P(?:([-+]?[0-9]+)D)?&quot; +</span>
                    &quot;(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?&quot;,
                    Pattern.CASE_INSENSITIVE);

    /**
     * The number of seconds in the duration.
     */
    private final long seconds;
    /**
     * The number of nanoseconds in the duration, expressed as a fraction of the
     * number of seconds. This is always positive, and never exceeds 999,999,999.
     */
    private final int nanos;

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing a number of standard 24 hour days.
     * &lt;p&gt;
     * The seconds are calculated based on the standard definition of a day,
     * where each day is 86400 seconds which implies a 24 hour day.
     * The nanosecond in second field is set to zero.
     *
     * @param days  the number of days, positive or negative
     * @return a {@code Duration}, not null
     * @throws ArithmeticException if the input days exceeds the capacity of {@code Duration}
     */
    public static Duration ofDays(long days) {
<span class="nc" id="L172">        return create(Math.multiplyExact(days, SECONDS_PER_DAY), 0);</span>
    }

    /**
     * Obtains a {@code Duration} representing a number of standard hours.
     * &lt;p&gt;
     * The seconds are calculated based on the standard definition of an hour,
     * where each hour is 3600 seconds.
     * The nanosecond in second field is set to zero.
     *
     * @param hours  the number of hours, positive or negative
     * @return a {@code Duration}, not null
     * @throws ArithmeticException if the input hours exceeds the capacity of {@code Duration}
     */
    public static Duration ofHours(long hours) {
<span class="nc" id="L187">        return create(Math.multiplyExact(hours, SECONDS_PER_HOUR), 0);</span>
    }

    /**
     * Obtains a {@code Duration} representing a number of standard minutes.
     * &lt;p&gt;
     * The seconds are calculated based on the standard definition of a minute,
     * where each minute is 60 seconds.
     * The nanosecond in second field is set to zero.
     *
     * @param minutes  the number of minutes, positive or negative
     * @return a {@code Duration}, not null
     * @throws ArithmeticException if the input minutes exceeds the capacity of {@code Duration}
     */
    public static Duration ofMinutes(long minutes) {
<span class="nc" id="L202">        return create(Math.multiplyExact(minutes, SECONDS_PER_MINUTE), 0);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing a number of seconds.
     * &lt;p&gt;
     * The nanosecond in second field is set to zero.
     *
     * @param seconds  the number of seconds, positive or negative
     * @return a {@code Duration}, not null
     */
    public static Duration ofSeconds(long seconds) {
<span class="fc" id="L215">        return create(seconds, 0);</span>
    }

    /**
     * Obtains a {@code Duration} representing a number of seconds and an
     * adjustment in nanoseconds.
     * &lt;p&gt;
     * This method allows an arbitrary number of nanoseconds to be passed in.
     * The factory will alter the values of the second and nanosecond in order
     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
     * For example, the following will result in the exactly the same duration:
     * &lt;pre&gt;
     *  Duration.ofSeconds(3, 1);
     *  Duration.ofSeconds(4, -999_999_999);
     *  Duration.ofSeconds(2, 1000_000_001);
     * &lt;/pre&gt;
     *
     * @param seconds  the number of seconds, positive or negative
     * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
     * @return a {@code Duration}, not null
     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@code Duration}
     */
    public static Duration ofSeconds(long seconds, long nanoAdjustment) {
<span class="fc" id="L238">        long secs = Math.addExact(seconds, Math.floorDiv(nanoAdjustment, NANOS_PER_SECOND));</span>
<span class="fc" id="L239">        int nos = (int) Math.floorMod(nanoAdjustment, NANOS_PER_SECOND);</span>
<span class="fc" id="L240">        return create(secs, nos);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing a number of milliseconds.
     * &lt;p&gt;
     * The seconds and nanoseconds are extracted from the specified milliseconds.
     *
     * @param millis  the number of milliseconds, positive or negative
     * @return a {@code Duration}, not null
     */
    public static Duration ofMillis(long millis) {
<span class="nc" id="L253">        long secs = millis / 1000;</span>
<span class="nc" id="L254">        int mos = (int) (millis % 1000);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (mos &lt; 0) {</span>
<span class="nc" id="L256">            mos += 1000;</span>
<span class="nc" id="L257">            secs--;</span>
        }
<span class="nc" id="L259">        return create(secs, mos * 1000_000);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing a number of nanoseconds.
     * &lt;p&gt;
     * The seconds and nanoseconds are extracted from the specified nanoseconds.
     *
     * @param nanos  the number of nanoseconds, positive or negative
     * @return a {@code Duration}, not null
     */
    public static Duration ofNanos(long nanos) {
<span class="fc" id="L272">        long secs = nanos / NANOS_PER_SECOND;</span>
<span class="fc" id="L273">        int nos = (int) (nanos % NANOS_PER_SECOND);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">        if (nos &lt; 0) {</span>
<span class="nc" id="L275">            nos += NANOS_PER_SECOND;</span>
<span class="nc" id="L276">            secs--;</span>
        }
<span class="fc" id="L278">        return create(secs, nos);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing an amount in the specified unit.
     * &lt;p&gt;
     * The parameters represent the two parts of a phrase like '6 Hours'. For example:
     * &lt;pre&gt;
     *  Duration.of(3, SECONDS);
     *  Duration.of(465, HOURS);
     * &lt;/pre&gt;
     * Only a subset of units are accepted by this method.
     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
     *
     * @param amount  the amount of the duration, measured in terms of the unit, positive or negative
     * @param unit  the unit that the duration is measured in, must have an exact duration, not null
     * @return a {@code Duration}, not null
     * @throws DateTimeException if the period unit has an estimated duration
     * @throws ArithmeticException if a numeric overflow occurs
     */
    public static Duration of(long amount, TemporalUnit unit) {
<span class="nc" id="L301">        return ZERO.plus(amount, unit);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Duration} from a temporal amount.
     * &lt;p&gt;
     * This obtains a duration based on the specified amount.
     * A {@code TemporalAmount} represents an  amount of time, which may be
     * date-based or time-based, which this factory extracts to a duration.
     * &lt;p&gt;
     * The conversion loops around the set of units from the amount and uses
     * the {@linkplain TemporalUnit#getDuration() duration} of the unit to
     * calculate the total {@code Duration}.
     * Only a subset of units are accepted by this method. The unit must either
     * have an {@linkplain TemporalUnit#isDurationEstimated() exact duration}
     * or be {@link ChronoUnit#DAYS} which is treated as 24 hours.
     * If any other units are found then an exception is thrown.
     *
     * @param amount  the temporal amount to convert, not null
     * @return the equivalent duration, not null
     * @throws DateTimeException if unable to convert to a {@code Duration}
     * @throws ArithmeticException if numeric overflow occurs
     */
    public static Duration from(TemporalAmount amount) {
<span class="nc" id="L326">        Objects.requireNonNull(amount, &quot;amount&quot;);</span>
<span class="nc" id="L327">        Duration duration = ZERO;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (TemporalUnit unit : amount.getUnits()) {</span>
<span class="nc" id="L329">            duration = duration.plus(amount.get(unit), unit);</span>
<span class="nc" id="L330">        }</span>
<span class="nc" id="L331">        return duration;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} from a text string such as {@code PnDTnHnMn.nS}.
     * &lt;p&gt;
     * This will parse a textual representation of a duration, including the
     * string produced by {@code toString()}. The formats accepted are based
     * on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days
     * considered to be exactly 24 hours.
     * &lt;p&gt;
     * The string starts with an optional sign, denoted by the ASCII negative
     * or positive symbol. If negative, the whole period is negated.
     * The ASCII letter &quot;P&quot; is next in upper or lower case.
     * There are then four sections, each consisting of a number and a suffix.
     * The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for
     * days, hours, minutes and seconds, accepted in upper or lower case.
     * The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before
     * the first occurrence, if any, of an hour, minute or second section.
     * At least one of the four sections must be present, and if &quot;T&quot; is present
     * there must be at least one section after the &quot;T&quot;.
     * The number part of each section must consist of one or more ASCII digits.
     * The number may be prefixed by the ASCII negative or positive symbol.
     * The number of days, hours and minutes must parse to an {@code long}.
     * The number of seconds must parse to an {@code long} with optional fraction.
     * The decimal point may be either a dot or a comma.
     * The fractional part may have from zero to 9 digits.
     * &lt;p&gt;
     * The leading plus/minus sign, and negative values for other units are
     * not part of the ISO-8601 standard.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     *    &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;
     *    &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)
     *    &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)
     *    &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)
     *    &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;
     *    &quot;P-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;
     *    &quot;-P6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;
     *    &quot;-P-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;
     * &lt;/pre&gt;
     *
     * @param text  the text to parse, not null
     * @return the parsed duration, not null
     * @throws DateTimeParseException if the text cannot be parsed to a duration
     */
    public static Duration parse(CharSequence text) {
<span class="nc" id="L380">        Objects.requireNonNull(text, &quot;text&quot;);</span>
<span class="nc" id="L381">        Matcher matcher = PATTERN.matcher(text);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (matcher.matches()) {</span>
            // check for letter T but no time sections
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if (&quot;T&quot;.equals(matcher.group(3)) == false) {</span>
<span class="nc" id="L385">                boolean negate = &quot;-&quot;.equals(matcher.group(1));</span>
<span class="nc" id="L386">                String dayMatch = matcher.group(2);</span>
<span class="nc" id="L387">                String hourMatch = matcher.group(4);</span>
<span class="nc" id="L388">                String minuteMatch = matcher.group(5);</span>
<span class="nc" id="L389">                String secondMatch = matcher.group(6);</span>
<span class="nc" id="L390">                String fractionMatch = matcher.group(7);</span>
<span class="nc bnc" id="L391" title="All 8 branches missed.">                if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {</span>
<span class="nc" id="L392">                    long daysAsSecs = parseNumber(text, dayMatch, SECONDS_PER_DAY, &quot;days&quot;);</span>
<span class="nc" id="L393">                    long hoursAsSecs = parseNumber(text, hourMatch, SECONDS_PER_HOUR, &quot;hours&quot;);</span>
<span class="nc" id="L394">                    long minsAsSecs = parseNumber(text, minuteMatch, SECONDS_PER_MINUTE, &quot;minutes&quot;);</span>
<span class="nc" id="L395">                    long seconds = parseNumber(text, secondMatch, 1, &quot;seconds&quot;);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                    int nanos = parseFraction(text,  fractionMatch, seconds &lt; 0 ? -1 : 1);</span>
                    try {
<span class="nc" id="L398">                        return create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);</span>
<span class="nc" id="L399">                    } catch (ArithmeticException ex) {</span>
<span class="nc" id="L400">                        throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: overflow&quot;, text, 0).initCause(ex);</span>
                    }
                }
            }
        }
<span class="nc" id="L405">        throw new DateTimeParseException(&quot;Text cannot be parsed to a Duration&quot;, text, 0);</span>
    }

    private static long parseNumber(CharSequence text, String parsed, int multiplier, String errorText) {
        // regex limits to [-+]?[0-9]+
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (parsed == null) {</span>
<span class="nc" id="L411">            return 0;</span>
        }
        try {
<span class="nc" id="L414">            long val = Long.parseLong(parsed);</span>
<span class="nc" id="L415">            return Math.multiplyExact(val, multiplier);</span>
<span class="nc" id="L416">        } catch (NumberFormatException | ArithmeticException ex) {</span>
<span class="nc" id="L417">            throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: &quot; + errorText, text, 0).initCause(ex);</span>
        }
    }

    private static int parseFraction(CharSequence text, String parsed, int negate) {
        // regex limits to [0-9]{0,9}
<span class="nc bnc" id="L423" title="All 4 branches missed.">        if (parsed == null || parsed.length() == 0) {</span>
<span class="nc" id="L424">            return 0;</span>
        }
        try {
<span class="nc" id="L427">            parsed = (parsed + &quot;000000000&quot;).substring(0, 9);</span>
<span class="nc" id="L428">            return Integer.parseInt(parsed) * negate;</span>
<span class="nc" id="L429">        } catch (NumberFormatException | ArithmeticException ex) {</span>
<span class="nc" id="L430">            throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: fraction&quot;, text, 0).initCause(ex);</span>
        }
    }

    private static Duration create(boolean negate, long daysAsSecs, long hoursAsSecs, long minsAsSecs, long secs, int nanos) {
<span class="nc" id="L435">        long seconds = Math.addExact(daysAsSecs, Math.addExact(hoursAsSecs, Math.addExact(minsAsSecs, secs)));</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (negate) {</span>
<span class="nc" id="L437">            return ofSeconds(seconds, nanos).negated();</span>
        }
<span class="nc" id="L439">        return ofSeconds(seconds, nanos);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains a {@code Duration} representing the duration between two temporal objects.
     * &lt;p&gt;
     * This calculates the duration between two temporal objects. If the objects
     * are of different types, then the duration is calculated based on the type
     * of the first object. For example, if the first argument is a {@code LocalTime}
     * then the second argument is converted to a {@code LocalTime}.
     * &lt;p&gt;
     * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.
     * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the
     * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.
     * &lt;p&gt;
     * The result of this method can be a negative period if the end is before the start.
     * To guarantee to obtain a positive duration call {@link #abs()} on the result.
     *
     * @param startInclusive  the start instant, inclusive, not null
     * @param endExclusive  the end instant, exclusive, not null
     * @return a {@code Duration}, not null
     * @throws DateTimeException if the seconds between the temporals cannot be obtained
     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}
     */
    public static Duration between(Temporal startInclusive, Temporal endExclusive) {
        try {
<span class="nc" id="L466">            return ofNanos(startInclusive.until(endExclusive, NANOS));</span>
<span class="nc" id="L467">        } catch (DateTimeException | ArithmeticException ex) {</span>
<span class="nc" id="L468">            long secs = startInclusive.until(endExclusive, SECONDS);</span>
            long nanos;
            try {
<span class="nc" id="L471">                nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">                if (secs &gt; 0 &amp;&amp; nanos &lt; 0) {</span>
<span class="nc" id="L473">                    secs++;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                } else if (secs &lt; 0 &amp;&amp; nanos &gt; 0) {</span>
<span class="nc" id="L475">                    secs--;</span>
                }
<span class="nc" id="L477">            } catch (DateTimeException ex2) {</span>
<span class="nc" id="L478">                nanos = 0;</span>
<span class="nc" id="L479">            }</span>
<span class="nc" id="L480">            return ofSeconds(secs, nanos);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Duration} using seconds and nanoseconds.
     *
     * @param seconds  the length of the duration in seconds, positive or negative
     * @param nanoAdjustment  the nanosecond adjustment within the second, from 0 to 999,999,999
     */
    private static Duration create(long seconds, int nanoAdjustment) {
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">        if ((seconds | nanoAdjustment) == 0) {</span>
<span class="nc" id="L493">            return ZERO;</span>
        }
<span class="fc" id="L495">        return new Duration(seconds, nanoAdjustment);</span>
    }

    /**
     * Constructs an instance of {@code Duration} using seconds and nanoseconds.
     *
     * @param seconds  the length of the duration in seconds, positive or negative
     * @param nanos  the nanoseconds within the second, from 0 to 999,999,999
     */
    private Duration(long seconds, int nanos) {
<span class="fc" id="L505">        super();</span>
<span class="fc" id="L506">        this.seconds = seconds;</span>
<span class="fc" id="L507">        this.nanos = nanos;</span>
<span class="fc" id="L508">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the value of the requested unit.
     * &lt;p&gt;
     * This returns a value for each of the two supported units,
     * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.
     * All other units throw an exception.
     *
     * @param unit the {@code TemporalUnit} for which to return the value
     * @return the long value of the unit
     * @throws DateTimeException if the unit is not supported
     * @throws UnsupportedTemporalTypeException if the unit is not supported
     */
    @Override
    public long get(TemporalUnit unit) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (unit == SECONDS) {</span>
<span class="nc" id="L526">            return seconds;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        } else if (unit == NANOS) {</span>
<span class="nc" id="L528">            return nanos;</span>
        } else {
<span class="nc" id="L530">            throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);</span>
        }
    }

    /**
     * Gets the set of units supported by this duration.
     * &lt;p&gt;
     * The supported units are {@link ChronoUnit#SECONDS SECONDS},
     * and {@link ChronoUnit#NANOS NANOS}.
     * They are returned in the order seconds, nanos.
     * &lt;p&gt;
     * This set can be used in conjunction with {@link #get(TemporalUnit)}
     * to access the entire state of the period.
     *
     * @return a list containing the seconds and nanos units, not null
     */
    @Override
    public List&lt;TemporalUnit&gt; getUnits() {
<span class="nc" id="L548">        return DurationUnits.UNITS;</span>
    }

    /**
     * Private class to delay initialization of this list until needed.
     * The circular dependency between Duration and ChronoUnit prevents
     * the simple initialization in Duration.
     */
<span class="nc" id="L556">    private static class DurationUnits {</span>
<span class="nc" id="L557">        static final List&lt;TemporalUnit&gt; UNITS =</span>
<span class="nc" id="L558">                Collections.unmodifiableList(Arrays.&lt;TemporalUnit&gt;asList(SECONDS, NANOS));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this duration is zero length.
     * &lt;p&gt;
     * A {@code Duration} represents a directed distance between two points on
     * the time-line and can therefore be positive, zero or negative.
     * This method checks whether the length is zero.
     *
     * @return true if this duration has a total length equal to zero
     */
    public boolean isZero() {
<span class="nc bnc" id="L572" title="All 2 branches missed.">        return (seconds | nanos) == 0;</span>
    }

    /**
     * Checks if this duration is negative, excluding zero.
     * &lt;p&gt;
     * A {@code Duration} represents a directed distance between two points on
     * the time-line and can therefore be positive, zero or negative.
     * This method checks whether the length is less than zero.
     *
     * @return true if this duration has a total length less than zero
     */
    public boolean isNegative() {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        return seconds &lt; 0;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the number of seconds in this duration.
     * &lt;p&gt;
     * The length of the duration is stored using two fields - seconds and nanoseconds.
     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
     * the length in seconds.
     * The total duration is defined by calling this method and {@link #getNano()}.
     * &lt;p&gt;
     * A {@code Duration} represents a directed distance between two points on the time-line.
     * A negative duration is expressed by the negative sign of the seconds part.
     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
     *
     * @return the whole seconds part of the length of the duration, positive or negative
     */
    public long getSeconds() {
<span class="nc" id="L604">        return seconds;</span>
    }

    /**
     * Gets the number of nanoseconds within the second in this duration.
     * &lt;p&gt;
     * The length of the duration is stored using two fields - seconds and nanoseconds.
     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
     * the length in seconds.
     * The total duration is defined by calling this method and {@link #getSeconds()}.
     * &lt;p&gt;
     * A {@code Duration} represents a directed distance between two points on the time-line.
     * A negative duration is expressed by the negative sign of the seconds part.
     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
     *
     * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
     */
    public int getNano() {
<span class="nc" id="L622">        return nanos;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the specified amount of seconds.
     * &lt;p&gt;
     * This returns a duration with the specified seconds, retaining the
     * nano-of-second part of this duration.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param seconds  the seconds to represent, may be negative
     * @return a {@code Duration} based on this period with the requested seconds, not null
     */
    public Duration withSeconds(long seconds) {
<span class="nc" id="L638">        return create(seconds, nanos);</span>
    }

    /**
     * Returns a copy of this duration with the specified nano-of-second.
     * &lt;p&gt;
     * This returns a duration with the specified nano-of-second, retaining the
     * seconds part of this duration.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
     * @return a {@code Duration} based on this period with the requested nano-of-second, not null
     * @throws DateTimeException if the nano-of-second is invalid
     */
    public Duration withNanos(int nanoOfSecond) {
<span class="nc" id="L654">        NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);</span>
<span class="nc" id="L655">        return create(seconds, nanoOfSecond);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the specified duration added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param duration  the duration to add, positive or negative, not null
     * @return a {@code Duration} based on this duration with the specified duration added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plus(Duration duration) {
<span class="nc" id="L669">        return plus(duration.getSeconds(), duration.getNano());</span>
     }

    /**
     * Returns a copy of this duration with the specified duration added.
     * &lt;p&gt;
     * The duration amount is measured in terms of the specified unit.
     * Only a subset of units are accepted by this method.
     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param amountToAdd  the amount of the period, measured in terms of the unit, positive or negative
     * @param unit  the unit that the period is measured in, must have an exact duration, not null
     * @return a {@code Duration} based on this duration with the specified duration added, not null
     * @throws UnsupportedTemporalTypeException if the unit is not supported
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plus(long amountToAdd, TemporalUnit unit) {
<span class="nc" id="L689">        Objects.requireNonNull(unit, &quot;unit&quot;);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (unit == DAYS) {</span>
<span class="nc" id="L691">            return plus(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY), 0);</span>
        }
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (unit.isDurationEstimated()) {</span>
<span class="nc" id="L694">            throw new UnsupportedTemporalTypeException(&quot;Unit must not have an estimated duration&quot;);</span>
        }
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (amountToAdd == 0) {</span>
<span class="nc" id="L697">            return this;</span>
        }
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (unit instanceof ChronoUnit) {</span>
<span class="nc bnc" id="L700" title="All 5 branches missed.">            switch ((ChronoUnit) unit) {</span>
<span class="nc" id="L701">                case NANOS: return plusNanos(amountToAdd);</span>
<span class="nc" id="L702">                case MICROS: return plusSeconds((amountToAdd / (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);</span>
<span class="nc" id="L703">                case MILLIS: return plusMillis(amountToAdd);</span>
<span class="nc" id="L704">                case SECONDS: return plusSeconds(amountToAdd);</span>
            }
<span class="nc" id="L706">            return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));</span>
        }
<span class="nc" id="L708">        Duration duration = unit.getDuration().multipliedBy(amountToAdd);</span>
<span class="nc" id="L709">        return plusSeconds(duration.getSeconds()).plusNanos(duration.getNano());</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the specified duration in standard 24 hour days added.
     * &lt;p&gt;
     * The number of days is multiplied by 86400 to obtain the number of seconds to add.
     * This is based on the standard definition of a day as 24 hours.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param daysToAdd  the days to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified days added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusDays(long daysToAdd) {
<span class="nc" id="L726">        return plus(Math.multiplyExact(daysToAdd, SECONDS_PER_DAY), 0);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in hours added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param hoursToAdd  the hours to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified hours added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusHours(long hoursToAdd) {
<span class="nc" id="L739">        return plus(Math.multiplyExact(hoursToAdd, SECONDS_PER_HOUR), 0);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in minutes added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param minutesToAdd  the minutes to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified minutes added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusMinutes(long minutesToAdd) {
<span class="nc" id="L752">        return plus(Math.multiplyExact(minutesToAdd, SECONDS_PER_MINUTE), 0);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in seconds added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param secondsToAdd  the seconds to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified seconds added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusSeconds(long secondsToAdd) {
<span class="nc" id="L765">        return plus(secondsToAdd, 0);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in milliseconds added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param millisToAdd  the milliseconds to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified milliseconds added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusMillis(long millisToAdd) {
<span class="nc" id="L778">        return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in nanoseconds added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param nanosToAdd  the nanoseconds to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified nanoseconds added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration plusNanos(long nanosToAdd) {
<span class="nc" id="L791">        return plus(0, nanosToAdd);</span>
    }

    /**
     * Returns a copy of this duration with the specified duration added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param secondsToAdd  the seconds to add, positive or negative
     * @param nanosToAdd  the nanos to add, positive or negative
     * @return a {@code Duration} based on this duration with the specified seconds added, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    private Duration plus(long secondsToAdd, long nanosToAdd) {
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if ((secondsToAdd | nanosToAdd) == 0) {</span>
<span class="nc" id="L806">            return this;</span>
        }
<span class="nc" id="L808">        long epochSec = Math.addExact(seconds, secondsToAdd);</span>
<span class="nc" id="L809">        epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);</span>
<span class="nc" id="L810">        nanosToAdd = nanosToAdd % NANOS_PER_SECOND;</span>
<span class="nc" id="L811">        long nanoAdjustment = nanos + nanosToAdd;  // safe int+NANOS_PER_SECOND</span>
<span class="nc" id="L812">        return ofSeconds(epochSec, nanoAdjustment);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the specified duration subtracted.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param duration  the duration to subtract, positive or negative, not null
     * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minus(Duration duration) {
<span class="nc" id="L826">        long secsToSubtract = duration.getSeconds();</span>
<span class="nc" id="L827">        int nanosToSubtract = duration.getNano();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (secsToSubtract == Long.MIN_VALUE) {</span>
<span class="nc" id="L829">            return plus(Long.MAX_VALUE, -nanosToSubtract).plus(1, 0);</span>
        }
<span class="nc" id="L831">        return plus(-secsToSubtract, -nanosToSubtract);</span>
     }

    /**
     * Returns a copy of this duration with the specified duration subtracted.
     * &lt;p&gt;
     * The duration amount is measured in terms of the specified unit.
     * Only a subset of units are accepted by this method.
     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param amountToSubtract  the amount of the period, measured in terms of the unit, positive or negative
     * @param unit  the unit that the period is measured in, must have an exact duration, not null
     * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minus(long amountToSubtract, TemporalUnit unit) {
<span class="nc bnc" id="L850" title="All 2 branches missed.">        return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.
     * &lt;p&gt;
     * The number of days is multiplied by 86400 to obtain the number of seconds to subtract.
     * This is based on the standard definition of a day as 24 hours.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param daysToSubtract  the days to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified days subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusDays(long daysToSubtract) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">        return (daysToSubtract == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in hours subtracted.
     * &lt;p&gt;
     * The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param hoursToSubtract  the hours to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified hours subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusHours(long hoursToSubtract) {
<span class="nc bnc" id="L882" title="All 2 branches missed.">        return (hoursToSubtract == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hoursToSubtract));</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in minutes subtracted.
     * &lt;p&gt;
     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param minutesToSubtract  the minutes to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified minutes subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusMinutes(long minutesToSubtract) {
<span class="nc bnc" id="L897" title="All 2 branches missed.">        return (minutesToSubtract == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutesToSubtract));</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in seconds subtracted.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param secondsToSubtract  the seconds to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified seconds subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusSeconds(long secondsToSubtract) {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        return (secondsToSubtract == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-secondsToSubtract));</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in milliseconds subtracted.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param millisToSubtract  the milliseconds to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified milliseconds subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusMillis(long millisToSubtract) {
<span class="nc bnc" id="L923" title="All 2 branches missed.">        return (millisToSubtract == Long.MIN_VALUE ? plusMillis(Long.MAX_VALUE).plusMillis(1) : plusMillis(-millisToSubtract));</span>
    }

    /**
     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
     * @return a {@code Duration} based on this duration with the specified nanoseconds subtracted, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration minusNanos(long nanosToSubtract) {
<span class="nc bnc" id="L936" title="All 2 branches missed.">        return (nanosToSubtract == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanosToSubtract));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration multiplied by the scalar.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param multiplicand  the value to multiply the duration by, positive or negative
     * @return a {@code Duration} based on this duration multiplied by the specified scalar, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration multipliedBy(long multiplicand) {
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (multiplicand == 0) {</span>
<span class="nc" id="L951">            return ZERO;</span>
        }
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (multiplicand == 1) {</span>
<span class="nc" id="L954">            return this;</span>
        }
<span class="nc" id="L956">        return create(toSeconds().multiply(BigDecimal.valueOf(multiplicand)));</span>
     }

    /**
     * Returns a copy of this duration divided by the specified value.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param divisor  the value to divide the duration by, positive or negative, not zero
     * @return a {@code Duration} based on this duration divided by the specified divisor, not null
     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs
     */
    public Duration dividedBy(long divisor) {
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (divisor == 0) {</span>
<span class="nc" id="L970">            throw new ArithmeticException(&quot;Cannot divide by zero&quot;);</span>
        }
<span class="nc bnc" id="L972" title="All 2 branches missed.">        if (divisor == 1) {</span>
<span class="nc" id="L973">            return this;</span>
        }
<span class="nc" id="L975">        return create(toSeconds().divide(BigDecimal.valueOf(divisor), RoundingMode.DOWN));</span>
     }

    /**
     * Converts this duration to the total length in seconds and
     * fractional nanoseconds expressed as a {@code BigDecimal}.
     *
     * @return the total length of the duration in seconds, with a scale of 9, not null
     */
    private BigDecimal toSeconds() {
<span class="nc" id="L985">        return BigDecimal.valueOf(seconds).add(BigDecimal.valueOf(nanos, 9));</span>
    }

    /**
     * Creates an instance of {@code Duration} from a number of seconds.
     *
     * @param seconds  the number of seconds, up to scale 9, positive or negative
     * @return a {@code Duration}, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    private static Duration create(BigDecimal seconds) {
<span class="nc" id="L996">        BigInteger nanos = seconds.movePointRight(9).toBigIntegerExact();</span>
<span class="nc" id="L997">        BigInteger[] divRem = nanos.divideAndRemainder(BI_NANOS_PER_SECOND);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (divRem[0].bitLength() &gt; 63) {</span>
<span class="nc" id="L999">            throw new ArithmeticException(&quot;Exceeds capacity of Duration: &quot; + nanos);</span>
        }
<span class="nc" id="L1001">        return ofSeconds(divRem[0].longValue(), divRem[1].intValue());</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this duration with the length negated.
     * &lt;p&gt;
     * This method swaps the sign of the total length of this duration.
     * For example, {@code PT1.3S} will be returned as {@code PT-1.3S}.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @return a {@code Duration} based on this duration with the amount negated, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration negated() {
<span class="nc" id="L1017">        return multipliedBy(-1);</span>
    }

    /**
     * Returns a copy of this duration with a positive length.
     * &lt;p&gt;
     * This method returns a positive duration by effectively removing the sign from any negative total length.
     * For example, {@code PT-1.3S} will be returned as {@code PT1.3S}.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @return a {@code Duration} based on this duration with an absolute length, not null
     * @throws ArithmeticException if numeric overflow occurs
     */
    public Duration abs() {
<span class="nc bnc" id="L1032" title="All 2 branches missed.">        return isNegative() ? negated() : this;</span>
    }

    //-------------------------------------------------------------------------
    /**
     * Adds this duration to the specified temporal object.
     * &lt;p&gt;
     * This returns a temporal object of the same observable type as the input
     * with this duration added.
     * &lt;p&gt;
     * In most cases, it is clearer to reverse the calling pattern by using
     * {@link Temporal#plus(TemporalAmount)}.
     * &lt;pre&gt;
     *   // these two lines are equivalent, but the second approach is recommended
     *   dateTime = thisDuration.addTo(dateTime);
     *   dateTime = dateTime.plus(thisDuration);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The calculation will add the seconds, then nanos.
     * Only non-zero amounts will be added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param temporal  the temporal object to adjust, not null
     * @return an object of the same type with the adjustment made, not null
     * @throws DateTimeException if unable to add
     * @throws ArithmeticException if numeric overflow occurs
     */
    @Override
    public Temporal addTo(Temporal temporal) {
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        if (seconds != 0) {</span>
<span class="nc" id="L1063">            temporal = temporal.plus(seconds, SECONDS);</span>
        }
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (nanos != 0) {</span>
<span class="nc" id="L1066">            temporal = temporal.plus(nanos, NANOS);</span>
        }
<span class="nc" id="L1068">        return temporal;</span>
    }

    /**
     * Subtracts this duration from the specified temporal object.
     * &lt;p&gt;
     * This returns a temporal object of the same observable type as the input
     * with this duration subtracted.
     * &lt;p&gt;
     * In most cases, it is clearer to reverse the calling pattern by using
     * {@link Temporal#minus(TemporalAmount)}.
     * &lt;pre&gt;
     *   // these two lines are equivalent, but the second approach is recommended
     *   dateTime = thisDuration.subtractFrom(dateTime);
     *   dateTime = dateTime.minus(thisDuration);
     * &lt;/pre&gt;
     * &lt;p&gt;
     * The calculation will subtract the seconds, then nanos.
     * Only non-zero amounts will be added.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @param temporal  the temporal object to adjust, not null
     * @return an object of the same type with the adjustment made, not null
     * @throws DateTimeException if unable to subtract
     * @throws ArithmeticException if numeric overflow occurs
     */
    @Override
    public Temporal subtractFrom(Temporal temporal) {
<span class="nc bnc" id="L1097" title="All 2 branches missed.">        if (seconds != 0) {</span>
<span class="nc" id="L1098">            temporal = temporal.minus(seconds, SECONDS);</span>
        }
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        if (nanos != 0) {</span>
<span class="nc" id="L1101">            temporal = temporal.minus(nanos, NANOS);</span>
        }
<span class="nc" id="L1103">        return temporal;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the number of minutes in this duration.
     * &lt;p&gt;
     * This returns the total number of minutes in the duration by dividing the
     * number of seconds by 86400.
     * This is based on the standard definition of a day as 24 hours.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of minutes in the duration, may be negative
     */
    public long toDays() {
<span class="nc" id="L1119">        return seconds / SECONDS_PER_DAY;</span>
    }

    /**
     * Gets the number of minutes in this duration.
     * &lt;p&gt;
     * This returns the total number of minutes in the duration by dividing the
     * number of seconds by 3600.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of minutes in the duration, may be negative
     */
    public long toHours() {
<span class="nc" id="L1133">        return seconds / SECONDS_PER_HOUR;</span>
    }

    /**
     * Gets the number of minutes in this duration.
     * &lt;p&gt;
     * This returns the total number of minutes in the duration by dividing the
     * number of seconds by 60.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method call.
     *
     * @return the number of minutes in the duration, may be negative
     */
    public long toMinutes() {
<span class="nc" id="L1147">        return seconds / SECONDS_PER_MINUTE;</span>
    }

    /**
     * Converts this duration to the total length in milliseconds.
     * &lt;p&gt;
     * If this duration is too large to fit in a {@code long} milliseconds, then an
     * exception is thrown.
     * &lt;p&gt;
     * If this duration has greater than millisecond precision, then the conversion
     * will drop any excess precision information as though the amount in nanoseconds
     * was subject to integer division by one million.
     *
     * @return the total length of the duration in milliseconds
     * @throws ArithmeticException if numeric overflow occurs
     */
    public long toMillis() {
<span class="nc" id="L1164">        long millis = Math.multiplyExact(seconds, 1000);</span>
<span class="nc" id="L1165">        millis = Math.addExact(millis, nanos / 1000_000);</span>
<span class="nc" id="L1166">        return millis;</span>
    }

    /**
     * Converts this duration to the total length in nanoseconds expressed as a {@code long}.
     * &lt;p&gt;
     * If this duration is too large to fit in a {@code long} nanoseconds, then an
     * exception is thrown.
     *
     * @return the total length of the duration in nanoseconds
     * @throws ArithmeticException if numeric overflow occurs
     */
    public long toNanos() {
<span class="nc" id="L1179">        long totalNanos = Math.multiplyExact(seconds, NANOS_PER_SECOND);</span>
<span class="nc" id="L1180">        totalNanos = Math.addExact(totalNanos, nanos);</span>
<span class="nc" id="L1181">        return totalNanos;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Compares this duration to the specified {@code Duration}.
     * &lt;p&gt;
     * The comparison is based on the total length of the durations.
     * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
     *
     * @param otherDuration  the other duration to compare to, not null
     * @return the comparator value, negative if less, positive if greater
     */
    @Override
    public int compareTo(Duration otherDuration) {
<span class="nc" id="L1196">        int cmp = Long.compare(seconds, otherDuration.seconds);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (cmp != 0) {</span>
<span class="nc" id="L1198">            return cmp;</span>
        }
<span class="nc" id="L1200">        return nanos - otherDuration.nanos;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this duration is equal to the specified {@code Duration}.
     * &lt;p&gt;
     * The comparison is based on the total length of the durations.
     *
     * @param otherDuration  the other duration, null returns false
     * @return true if the other duration is equal to this one
     */
    @Override
    public boolean equals(Object otherDuration) {
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        if (this == otherDuration) {</span>
<span class="nc" id="L1215">            return true;</span>
        }
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        if (otherDuration instanceof Duration) {</span>
<span class="nc" id="L1218">            Duration other = (Duration) otherDuration;</span>
<span class="nc bnc" id="L1219" title="All 4 branches missed.">            return this.seconds == other.seconds &amp;&amp;</span>
                   this.nanos == other.nanos;
        }
<span class="nc" id="L1222">        return false;</span>
    }

    /**
     * A hash code for this duration.
     *
     * @return a suitable hash code
     */
    @Override
    public int hashCode() {
<span class="nc" id="L1232">        return ((int) (seconds ^ (seconds &gt;&gt;&gt; 32))) + (51 * nanos);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * A string representation of this duration using ISO-8601 seconds
     * based representation, such as {@code PT8H6M12.345S}.
     * &lt;p&gt;
     * The format of the returned string will be {@code PTnHnMnS}, where n is
     * the relevant hours, minutes or seconds part of the duration.
     * Any fractional seconds are placed after a decimal point i the seconds section.
     * If a section has a zero value, it is omitted.
     * The hours, minutes and seconds will all have the same sign.
     * &lt;p&gt;
     * Examples:
     * &lt;pre&gt;
     *    &quot;20.345 seconds&quot;                 -- &quot;PT20.345S
     *    &quot;15 minutes&quot; (15 * 60 seconds)   -- &quot;PT15M&quot;
     *    &quot;10 hours&quot; (10 * 3600 seconds)   -- &quot;PT10H&quot;
     *    &quot;2 days&quot; (2 * 86400 seconds)     -- &quot;PT48H&quot;
     * &lt;/pre&gt;
     * Note that multiples of 24 hours are not output as days to avoid confusion
     * with {@code Period}.
     *
     * @return an ISO-8601 representation of this duration, not null
     */
    @Override
    public String toString() {
<span class="nc bnc" id="L1260" title="All 2 branches missed.">        if (this == ZERO) {</span>
<span class="nc" id="L1261">            return &quot;PT0S&quot;;</span>
        }
<span class="nc" id="L1263">        long hours = seconds / SECONDS_PER_HOUR;</span>
<span class="nc" id="L1264">        int minutes = (int) ((seconds % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);</span>
<span class="nc" id="L1265">        int secs = (int) (seconds % SECONDS_PER_MINUTE);</span>
<span class="nc" id="L1266">        StringBuilder buf = new StringBuilder(24);</span>
<span class="nc" id="L1267">        buf.append(&quot;PT&quot;);</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (hours != 0) {</span>
<span class="nc" id="L1269">            buf.append(hours).append('H');</span>
        }
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if (minutes != 0) {</span>
<span class="nc" id="L1272">            buf.append(minutes).append('M');</span>
        }
<span class="nc bnc" id="L1274" title="All 6 branches missed.">        if (secs == 0 &amp;&amp; nanos == 0 &amp;&amp; buf.length() &gt; 2) {</span>
<span class="nc" id="L1275">            return buf.toString();</span>
        }
<span class="nc bnc" id="L1277" title="All 4 branches missed.">        if (secs &lt; 0 &amp;&amp; nanos &gt; 0) {</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            if (secs == -1) {</span>
<span class="nc" id="L1279">                buf.append(&quot;-0&quot;);</span>
            } else {
<span class="nc" id="L1281">                buf.append(secs + 1);</span>
            }
        } else {
<span class="nc" id="L1284">            buf.append(secs);</span>
        }
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (nanos &gt; 0) {</span>
<span class="nc" id="L1287">            int pos = buf.length();</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">            if (secs &lt; 0) {</span>
<span class="nc" id="L1289">                buf.append(2 * NANOS_PER_SECOND - nanos);</span>
            } else {
<span class="nc" id="L1291">                buf.append(nanos + NANOS_PER_SECOND);</span>
            }
<span class="nc bnc" id="L1293" title="All 2 branches missed.">            while (buf.charAt(buf.length() - 1) == '0') {</span>
<span class="nc" id="L1294">                buf.setLength(buf.length() - 1);</span>
            }
<span class="nc" id="L1296">            buf.setCharAt(pos, '.');</span>
        }
<span class="nc" id="L1298">        buf.append('S');</span>
<span class="nc" id="L1299">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Writes the object using a
     * &lt;a href=&quot;../../serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
     * @serialData
     * &lt;pre&gt;
     *  out.writeByte(1);  // identifies a Duration
     *  out.writeLong(seconds);
     *  out.writeInt(nanos);
     * &lt;/pre&gt;
     *
     * @return the instance of {@code Ser}, not null
     */
    private Object writeReplace() {
<span class="nc" id="L1316">        return new Ser(Ser.DURATION_TYPE, this);</span>
    }

    /**
     * Defend against malicious streams.
     * @return never
     * @throws InvalidObjectException always
     */
    private Object readResolve() throws InvalidObjectException {
<span class="nc" id="L1325">        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);</span>
    }

    void writeExternal(DataOutput out) throws IOException {
<span class="nc" id="L1329">        out.writeLong(seconds);</span>
<span class="nc" id="L1330">        out.writeInt(nanos);</span>
<span class="nc" id="L1331">    }</span>

    static Duration readExternal(DataInput in) throws IOException {
<span class="nc" id="L1334">        long seconds = in.readLong();</span>
<span class="nc" id="L1335">        int nanos = in.readInt();</span>
<span class="nc" id="L1336">        return Duration.ofSeconds(seconds, nanos);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>