<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RelationService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.management.relation</a> &gt; <span class="el_source">RelationService.java</span></div><h1>RelationService.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.relation;

import static com.sun.jmx.defaults.JmxProperties.RELATION_LOGGER;
import static com.sun.jmx.mbeanserver.Util.cast;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;

import javax.management.Attribute;
import javax.management.AttributeNotFoundException;
import javax.management.InstanceNotFoundException;
import javax.management.InvalidAttributeValueException;
import javax.management.MBeanException;
import javax.management.MBeanNotificationInfo;
import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.MBeanServerDelegate;
import javax.management.MBeanServerNotification;
import javax.management.Notification;
import javax.management.NotificationBroadcasterSupport;
import javax.management.NotificationListener;
import javax.management.ObjectName;
import javax.management.ReflectionException;

/**
 * The Relation Service is in charge of creating and deleting relation types
 * and relations, of handling the consistency and of providing query
 * mechanisms.
 * &lt;P&gt;It implements the NotificationBroadcaster by extending
 * NotificationBroadcasterSupport to send notifications when a relation is
 * removed from it.
 * &lt;P&gt;It implements the NotificationListener interface to be able to receive
 * notifications concerning unregistration of MBeans referenced in relation
 * roles and of relation MBeans.
 * &lt;P&gt;It implements the MBeanRegistration interface to be able to retrieve
 * its ObjectName and MBean Server.
 *
 * @since 1.5
 */
public class RelationService extends NotificationBroadcasterSupport
    implements RelationServiceMBean, MBeanRegistration, NotificationListener {

    //
    // Private members
    //

    // Map associating:
    //      &lt;relation id&gt; -&gt; &lt;RelationSupport object/ObjectName&gt;
    // depending if the relation has been created using createRelation()
    // method (so internally handled) or is an MBean added as a relation by the
    // user
<span class="nc" id="L84">    private Map&lt;String,Object&gt; myRelId2ObjMap = new HashMap&lt;String,Object&gt;();</span>

    // Map associating:
    //      &lt;relation id&gt; -&gt; &lt;relation type name&gt;
<span class="nc" id="L88">    private Map&lt;String,String&gt; myRelId2RelTypeMap = new HashMap&lt;String,String&gt;();</span>

    // Map associating:
    //      &lt;relation MBean Object Name&gt; -&gt; &lt;relation id&gt;
<span class="nc" id="L92">    private Map&lt;ObjectName,String&gt; myRelMBeanObjName2RelIdMap =</span>
        new HashMap&lt;ObjectName,String&gt;();

    // Map associating:
    //       &lt;relation type name&gt; -&gt; &lt;RelationType object&gt;
<span class="nc" id="L97">    private Map&lt;String,RelationType&gt; myRelType2ObjMap =</span>
        new HashMap&lt;String,RelationType&gt;();

    // Map associating:
    //       &lt;relation type name&gt; -&gt; ArrayList of &lt;relation id&gt;
    // to list all the relations of a given type
<span class="nc" id="L103">    private Map&lt;String,List&lt;String&gt;&gt; myRelType2RelIdsMap =</span>
        new HashMap&lt;String,List&lt;String&gt;&gt;();

    // Map associating:
    //       &lt;ObjectName&gt; -&gt; HashMap
    // the value HashMap mapping:
    //       &lt;relation id&gt; -&gt; ArrayList of &lt;role name&gt;
    // to track where a given MBean is referenced.
<span class="nc" id="L111">    private final Map&lt;ObjectName,Map&lt;String,List&lt;String&gt;&gt;&gt;</span>
        myRefedMBeanObjName2RelIdsMap =
            new HashMap&lt;ObjectName,Map&lt;String,List&lt;String&gt;&gt;&gt;();

    // Flag to indicate if, when a notification is received for the
    // unregistration of an MBean referenced in a relation, if an immediate
    // &quot;purge&quot; of the relations (look for the relations no
    // longer valid) has to be performed , or if that will be performed only
    // when the purgeRelations method will be explicitly called.
    // true is immediate purge.
<span class="nc" id="L121">    private boolean myPurgeFlag = true;</span>

    // Internal counter to provide sequence numbers for notifications sent by:
    // - the Relation Service
    // - a relation handled by the Relation Service
<span class="nc" id="L126">    private final AtomicLong atomicSeqNo = new AtomicLong();</span>

    // ObjectName used to register the Relation Service in the MBean Server
<span class="nc" id="L129">    private ObjectName myObjName = null;</span>

    // MBean Server where the Relation Service is registered
<span class="nc" id="L132">    private MBeanServer myMBeanServer = null;</span>

    // Filter registered in the MBean Server with the Relation Service to be
    // informed of referenced MBean deregistrations
<span class="nc" id="L136">    private MBeanServerNotificationFilter myUnregNtfFilter = null;</span>

    // List of unregistration notifications received (storage used if purge
    // of relations when unregistering a referenced MBean is not immediate but
    // on user request)
<span class="nc" id="L141">    private List&lt;MBeanServerNotification&gt; myUnregNtfList =</span>
        new ArrayList&lt;MBeanServerNotification&gt;();

    //
    // Constructor
    //

    /**
     * Constructor.
     *
     * @param immediatePurgeFlag  flag to indicate when a notification is
     * received for the unregistration of an MBean referenced in a relation, if
     * an immediate &quot;purge&quot; of the relations (look for the relations no
     * longer valid) has to be performed , or if that will be performed only
     * when the purgeRelations method will be explicitly called.
     * &lt;P&gt;true is immediate purge.
     */
<span class="nc" id="L158">    public RelationService(boolean immediatePurgeFlag) {</span>

<span class="nc" id="L160">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;RelationService&quot;);

<span class="nc" id="L163">        setPurgeFlag(immediatePurgeFlag);</span>

<span class="nc" id="L165">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;RelationService&quot;);
<span class="nc" id="L167">        return;</span>
    }

    /**
     * Checks if the Relation Service is active.
     * Current condition is that the Relation Service must be registered in the
     * MBean Server
     *
     * @exception RelationServiceNotRegisteredException  if it is not
     * registered
     */
    public void isActive()
        throws RelationServiceNotRegisteredException {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (myMBeanServer == null) {</span>
            // MBean Server not set by preRegister(): relation service not
            // registered
<span class="nc" id="L183">            String excMsg =</span>
                &quot;Relation Service not registered in the MBean Server.&quot;;
<span class="nc" id="L185">            throw new RelationServiceNotRegisteredException(excMsg);</span>
        }
<span class="nc" id="L187">        return;</span>
    }

    //
    // MBeanRegistration interface
    //

    // Pre-registration: retrieves its ObjectName and MBean Server
    //
    // No exception thrown.
    public ObjectName preRegister(MBeanServer server,
                                  ObjectName name)
        throws Exception {

<span class="nc" id="L201">        myMBeanServer = server;</span>
<span class="nc" id="L202">        myObjName = name;</span>
<span class="nc" id="L203">        return name;</span>
    }

    // Post-registration: does nothing
    public void postRegister(Boolean registrationDone) {
<span class="nc" id="L208">        return;</span>
    }

    // Pre-unregistration: does nothing
    public void preDeregister()
        throws Exception {
<span class="nc" id="L214">        return;</span>
    }

    // Post-unregistration: does nothing
    public void postDeregister() {
<span class="nc" id="L219">        return;</span>
    }

    //
    // Accessors
    //

    /**
     * Returns the flag to indicate if when a notification is received for the
     * unregistration of an MBean referenced in a relation, if an immediate
     * &quot;purge&quot; of the relations (look for the relations no longer valid)
     * has to be performed , or if that will be performed only when the
     * purgeRelations method will be explicitly called.
     * &lt;P&gt;true is immediate purge.
     *
     * @return true if purges are automatic.
     *
     * @see #setPurgeFlag
     */
    public boolean getPurgeFlag() {
<span class="nc" id="L239">        return myPurgeFlag;</span>
    }

    /**
     * Sets the flag to indicate if when a notification is received for the
     * unregistration of an MBean referenced in a relation, if an immediate
     * &quot;purge&quot; of the relations (look for the relations no longer valid)
     * has to be performed , or if that will be performed only when the
     * purgeRelations method will be explicitly called.
     * &lt;P&gt;true is immediate purge.
     *
     * @param purgeFlag  flag
     *
     * @see #getPurgeFlag
     */
    public void setPurgeFlag(boolean purgeFlag) {

<span class="nc" id="L256">        myPurgeFlag = purgeFlag;</span>
<span class="nc" id="L257">        return;</span>
    }

    //
    // Relation type handling
    //

    /**
     * Creates a relation type (a RelationTypeSupport object) with given
     * role infos (provided by the RoleInfo objects), and adds it in the
     * Relation Service.
     *
     * @param relationTypeName  name of the relation type
     * @param roleInfoArray  array of role infos
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception InvalidRelationTypeException  If:
     * &lt;P&gt;- there is already a relation type with that name
     * &lt;P&gt;- the same name has been used for two different role infos
     * &lt;P&gt;- no role info provided
     * &lt;P&gt;- one null role info provided
     */
    public void createRelationType(String relationTypeName,
                                   RoleInfo[] roleInfoArray)
        throws IllegalArgumentException,
               InvalidRelationTypeException {

<span class="nc bnc" id="L284" title="All 4 branches missed.">        if (relationTypeName == null || roleInfoArray == null) {</span>
<span class="nc" id="L285">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L289">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;createRelationType&quot;, relationTypeName);

        // Can throw an InvalidRelationTypeException
<span class="nc" id="L293">        RelationType relType =</span>
            new RelationTypeSupport(relationTypeName, roleInfoArray);

<span class="nc" id="L296">        addRelationTypeInt(relType);</span>

<span class="nc" id="L298">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;createRelationType&quot;);
<span class="nc" id="L300">        return;</span>
    }

    /**
     * Adds given object as a relation type. The object is expected to
     * implement the RelationType interface.
     *
     * @param relationTypeObj  relation type object (implementing the
     * RelationType interface)
     *
     * @exception IllegalArgumentException  if null parameter or if
     * {@link RelationType#getRelationTypeName
     * relationTypeObj.getRelationTypeName()} returns null.
     * @exception InvalidRelationTypeException  if:
     * &lt;P&gt;- the same name has been used for two different roles
     * &lt;P&gt;- no role info provided
     * &lt;P&gt;- one null role info provided
     * &lt;P&gt;- there is already a relation type with that name
     */
    public void addRelationType(RelationType relationTypeObj)
        throws IllegalArgumentException,
               InvalidRelationTypeException {

<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (relationTypeObj == null) {</span>
<span class="nc" id="L324">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L325">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L328">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;addRelationType&quot;);

        // Checks the role infos
<span class="nc" id="L332">        List&lt;RoleInfo&gt; roleInfoList = relationTypeObj.getRoleInfos();</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (roleInfoList == null) {</span>
<span class="nc" id="L334">            String excMsg = &quot;No role info provided.&quot;;</span>
<span class="nc" id="L335">            throw new InvalidRelationTypeException(excMsg);</span>
        }

<span class="nc" id="L338">        RoleInfo[] roleInfoArray = new RoleInfo[roleInfoList.size()];</span>
<span class="nc" id="L339">        int i = 0;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (RoleInfo currRoleInfo : roleInfoList) {</span>
<span class="nc" id="L341">            roleInfoArray[i] = currRoleInfo;</span>
<span class="nc" id="L342">            i++;</span>
<span class="nc" id="L343">        }</span>
        // Can throw InvalidRelationTypeException
<span class="nc" id="L345">        RelationTypeSupport.checkRoleInfos(roleInfoArray);</span>

<span class="nc" id="L347">        addRelationTypeInt(relationTypeObj);</span>

<span class="nc" id="L349">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;addRelationType&quot;);
<span class="nc" id="L351">        return;</span>
     }

    /**
     * Retrieves names of all known relation types.
     *
     * @return ArrayList of relation type names (Strings)
     */
    public List&lt;String&gt; getAllRelationTypeNames() {
        ArrayList&lt;String&gt; result;
<span class="nc" id="L361">        synchronized(myRelType2ObjMap) {</span>
<span class="nc" id="L362">            result = new ArrayList&lt;String&gt;(myRelType2ObjMap.keySet());</span>
<span class="nc" id="L363">        }</span>
<span class="nc" id="L364">        return result;</span>
    }

    /**
     * Retrieves list of role infos (RoleInfo objects) of a given relation
     * type.
     *
     * @param relationTypeName  name of relation type
     *
     * @return ArrayList of RoleInfo.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  if there is no relation type
     * with that name.
     */
    public List&lt;RoleInfo&gt; getRoleInfos(String relationTypeName)
        throws IllegalArgumentException,
               RelationTypeNotFoundException {

<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (relationTypeName == null) {</span>
<span class="nc" id="L384">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L385">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L388">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRoleInfos&quot;, relationTypeName);

        // Can throw a RelationTypeNotFoundException
<span class="nc" id="L392">        RelationType relType = getRelationType(relationTypeName);</span>

<span class="nc" id="L394">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRoleInfos&quot;);
<span class="nc" id="L396">        return relType.getRoleInfos();</span>
    }

    /**
     * Retrieves role info for given role name of a given relation type.
     *
     * @param relationTypeName  name of relation type
     * @param roleInfoName  name of role
     *
     * @return RoleInfo object.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  if the relation type is not
     * known in the Relation Service
     * @exception RoleInfoNotFoundException  if the role is not part of the
     * relation type.
     */
    public RoleInfo getRoleInfo(String relationTypeName,
                                String roleInfoName)
        throws IllegalArgumentException,
               RelationTypeNotFoundException,
               RoleInfoNotFoundException {

<span class="nc bnc" id="L419" title="All 4 branches missed.">        if (relationTypeName == null || roleInfoName == null) {</span>
<span class="nc" id="L420">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L421">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L424">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRoleInfo&quot;, new Object[] {relationTypeName, roleInfoName});

        // Can throw a RelationTypeNotFoundException
<span class="nc" id="L428">        RelationType relType = getRelationType(relationTypeName);</span>

        // Can throw a RoleInfoNotFoundException
<span class="nc" id="L431">        RoleInfo roleInfo = relType.getRoleInfo(roleInfoName);</span>

<span class="nc" id="L433">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRoleInfo&quot;);
<span class="nc" id="L435">        return roleInfo;</span>
    }

    /**
     * Removes given relation type from Relation Service.
     * &lt;P&gt;The relation objects of that type will be removed from the
     * Relation Service.
     *
     * @param relationTypeName  name of the relation type to be removed
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  If there is no relation type
     * with that name
     */
    public void removeRelationType(String relationTypeName)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationTypeNotFoundException {

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L457">        isActive();</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (relationTypeName == null) {</span>
<span class="nc" id="L460">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L461">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L464">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;removeRelationType&quot;, relationTypeName);

        // Checks if the relation type to be removed exists
        // Can throw a RelationTypeNotFoundException
<span class="nc" id="L469">        RelationType relType = getRelationType(relationTypeName);</span>

        // Retrieves the relation ids for relations of that type
<span class="nc" id="L472">        List&lt;String&gt; relIdList = null;</span>
<span class="nc" id="L473">        synchronized(myRelType2RelIdsMap) {</span>
            // Note: take a copy of the list as it is a part of a map that
            //       will be updated by removeRelation() below.
<span class="nc" id="L476">            List&lt;String&gt; relIdList1 =</span>
<span class="nc" id="L477">                myRelType2RelIdsMap.get(relationTypeName);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (relIdList1 != null) {</span>
<span class="nc" id="L479">                relIdList = new ArrayList&lt;String&gt;(relIdList1);</span>
            }
<span class="nc" id="L481">        }</span>

        // Removes the relation type from all maps
<span class="nc" id="L484">        synchronized(myRelType2ObjMap) {</span>
<span class="nc" id="L485">            myRelType2ObjMap.remove(relationTypeName);</span>
<span class="nc" id="L486">        }</span>
<span class="nc" id="L487">        synchronized(myRelType2RelIdsMap) {</span>
<span class="nc" id="L488">            myRelType2RelIdsMap.remove(relationTypeName);</span>
<span class="nc" id="L489">        }</span>

        // Removes all relations of that type
<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (relIdList != null) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            for (String currRelId : relIdList) {</span>
                // Note: will remove it from myRelId2RelTypeMap :)
                //
                // Can throw RelationServiceNotRegisteredException (detected
                // above)
                // Shall not throw a RelationNotFoundException
                try {
<span class="nc" id="L500">                    removeRelation(currRelId);</span>
<span class="nc" id="L501">                } catch (RelationNotFoundException exc1) {</span>
<span class="nc" id="L502">                    throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L503">                }</span>
<span class="nc" id="L504">            }</span>
        }

<span class="nc" id="L507">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;removeRelationType&quot;);
<span class="nc" id="L509">        return;</span>
    }

    //
    // Relation handling
    //

    /**
     * Creates a simple relation (represented by a RelationSupport object) of
     * given relation type, and adds it in the Relation Service.
     * &lt;P&gt;Roles are initialized according to the role list provided in
     * parameter. The ones not initialized in this way are set to an empty
     * ArrayList of ObjectNames.
     * &lt;P&gt;A RelationNotification, with type RELATION_BASIC_CREATION, is sent.
     *
     * @param relationId  relation identifier, to identify uniquely the relation
     * inside the Relation Service
     * @param relationTypeName  name of the relation type (has to be created
     * in the Relation Service)
     * @param roleList  role list to initialize roles of the relation (can
     * be null).
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter, except the role
     * list which can be null if no role initialization
     * @exception RoleNotFoundException  if a value is provided for a role
     * that does not exist in the relation type
     * @exception InvalidRelationIdException  if relation id already used
     * @exception RelationTypeNotFoundException  if relation type not known in
     * Relation Service
     * @exception InvalidRoleValueException if:
     * &lt;P&gt;- the same role name is used for two different roles
     * &lt;P&gt;- the number of referenced MBeans in given value is less than
     * expected minimum degree
     * &lt;P&gt;- the number of referenced MBeans in provided value exceeds expected
     * maximum degree
     * &lt;P&gt;- one referenced MBean in the value is not an Object of the MBean
     * class expected for that role
     * &lt;P&gt;- an MBean provided for that role does not exist
     */
    public void createRelation(String relationId,
                               String relationTypeName,
                               RoleList roleList)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RoleNotFoundException,
               InvalidRelationIdException,
               RelationTypeNotFoundException,
               InvalidRoleValueException {

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L561">        isActive();</span>

<span class="nc bnc" id="L563" title="All 4 branches missed.">        if (relationId == null ||</span>
            relationTypeName == null) {
<span class="nc" id="L565">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L566">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L569">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;createRelation&quot;,
                new Object[] {relationId, relationTypeName, roleList});

        // Creates RelationSupport object
        // Can throw InvalidRoleValueException
<span class="nc" id="L575">        RelationSupport relObj = new RelationSupport(relationId,</span>
                                               myObjName,
                                               relationTypeName,
                                               roleList);

        // Adds relation object as a relation into the Relation Service
        // Can throw RoleNotFoundException, InvalidRelationId,
        // RelationTypeNotFoundException, InvalidRoleValueException
        //
        // Cannot throw MBeanException
<span class="nc" id="L585">        addRelationInt(true,</span>
                       relObj,
                       null,
                       relationId,
                       relationTypeName,
                       roleList);
<span class="nc" id="L591">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;createRelation&quot;);
<span class="nc" id="L593">        return;</span>
    }

    /**
     * Adds an MBean created by the user (and registered by him in the MBean
     * Server) as a relation in the Relation Service.
     * &lt;P&gt;To be added as a relation, the MBean must conform to the
     * following:
     * &lt;P&gt;- implement the Relation interface
     * &lt;P&gt;- have for RelationService ObjectName the ObjectName of current
     * Relation Service
     * &lt;P&gt;- have a relation id unique and unused in current Relation Service
     * &lt;P&gt;- have for relation type a relation type created in the Relation
     * Service
     * &lt;P&gt;- have roles conforming to the role info provided in the relation
     * type.
     *
     * @param relationObjectName  ObjectName of the relation MBean to be added.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception NoSuchMethodException  If the MBean does not implement the
     * Relation interface
     * @exception InvalidRelationIdException  if:
     * &lt;P&gt;- no relation identifier in MBean
     * &lt;P&gt;- the relation identifier is already used in the Relation Service
     * @exception InstanceNotFoundException  if the MBean for given ObjectName
     * has not been registered
     * @exception InvalidRelationServiceException  if:
     * &lt;P&gt;- no Relation Service name in MBean
     * &lt;P&gt;- the Relation Service name in the MBean is not the one of the
     * current Relation Service
     * @exception RelationTypeNotFoundException  if:
     * &lt;P&gt;- no relation type name in MBean
     * &lt;P&gt;- the relation type name in MBean does not correspond to a relation
     * type created in the Relation Service
     * @exception InvalidRoleValueException  if:
     * &lt;P&gt;- the number of referenced MBeans in a role is less than
     * expected minimum degree
     * &lt;P&gt;- the number of referenced MBeans in a role exceeds expected
     * maximum degree
     * &lt;P&gt;- one referenced MBean in the value is not an Object of the MBean
     * class expected for that role
     * &lt;P&gt;- an MBean provided for a role does not exist
     * @exception RoleNotFoundException  if a value is provided for a role
     * that does not exist in the relation type
     */
    public void addRelation(ObjectName relationObjectName)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               NoSuchMethodException,
               InvalidRelationIdException,
               InstanceNotFoundException,
               InvalidRelationServiceException,
               RelationTypeNotFoundException,
               RoleNotFoundException,
               InvalidRoleValueException {

<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (relationObjectName == null) {</span>
<span class="nc" id="L653">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L654">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L657">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;addRelation&quot;, relationObjectName);

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L661">        isActive();</span>

        // Checks that the relation MBean implements the Relation interface.
        // It will also check that the provided ObjectName corresponds to a
        // registered MBean (else will throw an InstanceNotFoundException)
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if ((!(myMBeanServer.isInstanceOf(relationObjectName, &quot;javax.management.relation.Relation&quot;)))) {</span>
<span class="nc" id="L667">            String excMsg = &quot;This MBean does not implement the Relation interface.&quot;;</span>
<span class="nc" id="L668">            throw new NoSuchMethodException(excMsg);</span>
        }
        // Checks there is a relation id in the relation MBean (its uniqueness
        // is checked in addRelationInt())
        // Can throw InstanceNotFoundException (but detected above)
        // No MBeanException as no exception raised by this method, and no
        // ReflectionException
        String relId;
        try {
<span class="nc" id="L677">            relId = (String)(myMBeanServer.getAttribute(relationObjectName,</span>
                                                        &quot;RelationId&quot;));

<span class="nc" id="L680">        } catch (MBeanException exc1) {</span>
<span class="nc" id="L681">            throw new RuntimeException(</span>
<span class="nc" id="L682">                                     (exc1.getTargetException()).getMessage());</span>
<span class="nc" id="L683">        } catch (ReflectionException exc2) {</span>
<span class="nc" id="L684">            throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L685">        } catch (AttributeNotFoundException exc3) {</span>
<span class="nc" id="L686">            throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L687">        }</span>

<span class="nc bnc" id="L689" title="All 2 branches missed.">        if (relId == null) {</span>
<span class="nc" id="L690">            String excMsg = &quot;This MBean does not provide a relation id.&quot;;</span>
<span class="nc" id="L691">            throw new InvalidRelationIdException(excMsg);</span>
        }
        // Checks that the Relation Service where the relation MBean is
        // expected to be added is the current one
        // Can throw InstanceNotFoundException (but detected above)
        // No MBeanException as no exception raised by this method, no
        // ReflectionException
        ObjectName relServObjName;
        try {
<span class="nc" id="L700">            relServObjName = (ObjectName)</span>
<span class="nc" id="L701">                (myMBeanServer.getAttribute(relationObjectName,</span>
                                            &quot;RelationServiceName&quot;));

<span class="nc" id="L704">        } catch (MBeanException exc1) {</span>
<span class="nc" id="L705">            throw new RuntimeException(</span>
<span class="nc" id="L706">                                     (exc1.getTargetException()).getMessage());</span>
<span class="nc" id="L707">        } catch (ReflectionException exc2) {</span>
<span class="nc" id="L708">            throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L709">        } catch (AttributeNotFoundException exc3) {</span>
<span class="nc" id="L710">            throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L711">        }</span>

<span class="nc" id="L713">        boolean badRelServFlag = false;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (relServObjName == null) {</span>
<span class="nc" id="L715">            badRelServFlag = true;</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">        } else if (!(relServObjName.equals(myObjName))) {</span>
<span class="nc" id="L718">            badRelServFlag = true;</span>
        }
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (badRelServFlag) {</span>
<span class="nc" id="L721">            String excMsg = &quot;The Relation Service referenced in the MBean is not the current one.&quot;;</span>
<span class="nc" id="L722">            throw new InvalidRelationServiceException(excMsg);</span>
        }
        // Checks that a relation type has been specified for the relation
        // Can throw InstanceNotFoundException (but detected above)
        // No MBeanException as no exception raised by this method, no
        // ReflectionException
        String relTypeName;
        try {
<span class="nc" id="L730">            relTypeName = (String)(myMBeanServer.getAttribute(relationObjectName,</span>
                                                              &quot;RelationTypeName&quot;));

<span class="nc" id="L733">        } catch (MBeanException exc1) {</span>
<span class="nc" id="L734">            throw new RuntimeException(</span>
<span class="nc" id="L735">                                     (exc1.getTargetException()).getMessage());</span>
<span class="nc" id="L736">        }catch (ReflectionException exc2) {</span>
<span class="nc" id="L737">            throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L738">        } catch (AttributeNotFoundException exc3) {</span>
<span class="nc" id="L739">            throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L740">        }</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (relTypeName == null) {</span>
<span class="nc" id="L742">            String excMsg = &quot;No relation type provided.&quot;;</span>
<span class="nc" id="L743">            throw new RelationTypeNotFoundException(excMsg);</span>
        }
        // Retrieves all roles without considering read mode
        // Can throw InstanceNotFoundException (but detected above)
        // No MBeanException as no exception raised by this method, no
        // ReflectionException
        RoleList roleList;
        try {
<span class="nc" id="L751">            roleList = (RoleList)(myMBeanServer.invoke(relationObjectName,</span>
                                                       &quot;retrieveAllRoles&quot;,
                                                       null,
                                                       null));
<span class="nc" id="L755">        } catch (MBeanException exc1) {</span>
<span class="nc" id="L756">            throw new RuntimeException(</span>
<span class="nc" id="L757">                                     (exc1.getTargetException()).getMessage());</span>
<span class="nc" id="L758">        } catch (ReflectionException exc2) {</span>
<span class="nc" id="L759">            throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L760">        }</span>

        // Can throw RoleNotFoundException, InvalidRelationIdException,
        // RelationTypeNotFoundException, InvalidRoleValueException
<span class="nc" id="L764">        addRelationInt(false,</span>
                       null,
                       relationObjectName,
                       relId,
                       relTypeName,
                       roleList);
        // Adds relation MBean ObjectName in map
<span class="nc" id="L771">        synchronized(myRelMBeanObjName2RelIdMap) {</span>
<span class="nc" id="L772">            myRelMBeanObjName2RelIdMap.put(relationObjectName, relId);</span>
<span class="nc" id="L773">        }</span>

        // Updates flag to specify that the relation is managed by the Relation
        // Service
        // This flag and setter are inherited from RelationSupport and not parts
        // of the Relation interface, so may be not supported.
        try {
<span class="nc" id="L780">            myMBeanServer.setAttribute(relationObjectName,</span>
                                       new Attribute(
                                         &quot;RelationServiceManagementFlag&quot;,
                                         Boolean.TRUE));
<span class="nc" id="L784">        } catch (Exception exc) {</span>
            // OK : The flag is not supported.
<span class="nc" id="L786">        }</span>

        // Updates listener information to received notification for
        // unregistration of this MBean
<span class="nc" id="L790">        List&lt;ObjectName&gt; newRefList = new ArrayList&lt;ObjectName&gt;();</span>
<span class="nc" id="L791">        newRefList.add(relationObjectName);</span>
<span class="nc" id="L792">        updateUnregistrationListener(newRefList, null);</span>

<span class="nc" id="L794">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;addRelation&quot;);
<span class="nc" id="L796">        return;</span>
    }

    /**
     * If the relation is represented by an MBean (created by the user and
     * added as a relation in the Relation Service), returns the ObjectName of
     * the MBean.
     *
     * @param relationId  relation id identifying the relation
     *
     * @return ObjectName of the corresponding relation MBean, or null if
     * the relation is not an MBean.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException there is no relation associated
     * to that id
     */
    public ObjectName isRelationMBean(String relationId)
        throws IllegalArgumentException,
               RelationNotFoundException{

<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L818">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L819">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L822">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;isRelationMBean&quot;, relationId);

        // Can throw RelationNotFoundException
<span class="nc" id="L826">        Object result = getRelation(relationId);</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (result instanceof ObjectName) {</span>
<span class="nc" id="L828">            return ((ObjectName)result);</span>
        } else {
<span class="nc" id="L830">            return null;</span>
        }
    }

    /**
     * Returns the relation id associated to the given ObjectName if the
     * MBean has been added as a relation in the Relation Service.
     *
     * @param objectName  ObjectName of supposed relation
     *
     * @return relation id (String) or null (if the ObjectName is not a
     * relation handled by the Relation Service)
     *
     * @exception IllegalArgumentException  if null parameter
     */
    public String isRelation(ObjectName objectName)
        throws IllegalArgumentException {

<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (objectName == null) {</span>
<span class="nc" id="L849">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L850">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L853">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;isRelation&quot;, objectName);

<span class="nc" id="L856">        String result = null;</span>
<span class="nc" id="L857">        synchronized(myRelMBeanObjName2RelIdMap) {</span>
<span class="nc" id="L858">            String relId = myRelMBeanObjName2RelIdMap.get(objectName);</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (relId != null) {</span>
<span class="nc" id="L860">                result = relId;</span>
            }
<span class="nc" id="L862">        }</span>
<span class="nc" id="L863">        return result;</span>
    }

    /**
     * Checks if there is a relation identified in Relation Service with given
     * relation id.
     *
     * @param relationId  relation id identifying the relation
     *
     * @return boolean: true if there is a relation, false else
     *
     * @exception IllegalArgumentException  if null parameter
     */
    public Boolean hasRelation(String relationId)
        throws IllegalArgumentException {

<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L880">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L881">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L884">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;hasRelation&quot;, relationId);

        try {
            // Can throw RelationNotFoundException
<span class="nc" id="L889">            Object result = getRelation(relationId);</span>
<span class="nc" id="L890">            return true;</span>
<span class="nc" id="L891">        } catch (RelationNotFoundException exc) {</span>
<span class="nc" id="L892">            return false;</span>
        }
    }

    /**
     * Returns all the relation ids for all the relations handled by the
     * Relation Service.
     *
     * @return ArrayList of String
     */
    public List&lt;String&gt; getAllRelationIds() {
        List&lt;String&gt; result;
<span class="nc" id="L904">        synchronized(myRelId2ObjMap) {</span>
<span class="nc" id="L905">            result = new ArrayList&lt;String&gt;(myRelId2ObjMap.keySet());</span>
<span class="nc" id="L906">        }</span>
<span class="nc" id="L907">        return result;</span>
    }

    /**
     * Checks if given Role can be read in a relation of the given type.
     *
     * @param roleName  name of role to be checked
     * @param relationTypeName  name of the relation type
     *
     * @return an Integer wrapping an integer corresponding to possible
     * problems represented as constants in RoleUnresolved:
     * &lt;P&gt;- 0 if role can be read
     * &lt;P&gt;- integer corresponding to RoleStatus.NO_ROLE_WITH_NAME
     * &lt;P&gt;- integer corresponding to RoleStatus.ROLE_NOT_READABLE
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  if the relation type is not
     * known in the Relation Service
     */
    public Integer checkRoleReading(String roleName,
                                    String relationTypeName)
        throws IllegalArgumentException,
               RelationTypeNotFoundException {

<span class="nc bnc" id="L931" title="All 4 branches missed.">        if (roleName == null || relationTypeName == null) {</span>
<span class="nc" id="L932">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L933">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L936">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;checkRoleReading&quot;, new Object[] {roleName, relationTypeName});

        Integer result;

        // Can throw a RelationTypeNotFoundException
<span class="nc" id="L942">        RelationType relType = getRelationType(relationTypeName);</span>

        try {
            // Can throw a RoleInfoNotFoundException to be transformed into
            // returned value RoleStatus.NO_ROLE_WITH_NAME
<span class="nc" id="L947">            RoleInfo roleInfo = relType.getRoleInfo(roleName);</span>

<span class="nc" id="L949">            result =  checkRoleInt(1,</span>
                                   roleName,
                                   null,
                                   roleInfo,
                                   false);

<span class="nc" id="L955">        } catch (RoleInfoNotFoundException exc) {</span>
<span class="nc" id="L956">            result = Integer.valueOf(RoleStatus.NO_ROLE_WITH_NAME);</span>
<span class="nc" id="L957">        }</span>

<span class="nc" id="L959">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;checkRoleReading&quot;);
<span class="nc" id="L961">        return result;</span>
    }

    /**
     * Checks if given Role can be set in a relation of given type.
     *
     * @param role  role to be checked
     * @param relationTypeName  name of relation type
     * @param initFlag  flag to specify that the checking is done for the
     * initialization of a role, write access shall not be verified.
     *
     * @return an Integer wrapping an integer corresponding to possible
     * problems represented as constants in RoleUnresolved:
     * &lt;P&gt;- 0 if role can be set
     * &lt;P&gt;- integer corresponding to RoleStatus.NO_ROLE_WITH_NAME
     * &lt;P&gt;- integer for RoleStatus.ROLE_NOT_WRITABLE
     * &lt;P&gt;- integer for RoleStatus.LESS_THAN_MIN_ROLE_DEGREE
     * &lt;P&gt;- integer for RoleStatus.MORE_THAN_MAX_ROLE_DEGREE
     * &lt;P&gt;- integer for RoleStatus.REF_MBEAN_OF_INCORRECT_CLASS
     * &lt;P&gt;- integer for RoleStatus.REF_MBEAN_NOT_REGISTERED
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  if unknown relation type
     */
    public Integer checkRoleWriting(Role role,
                                    String relationTypeName,
                                    Boolean initFlag)
        throws IllegalArgumentException,
               RelationTypeNotFoundException {

<span class="nc bnc" id="L991" title="All 6 branches missed.">        if (role == null ||</span>
            relationTypeName == null ||
            initFlag == null) {
<span class="nc" id="L994">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L995">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L998">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;checkRoleWriting&quot;,
                new Object[] {role, relationTypeName, initFlag});

        // Can throw a RelationTypeNotFoundException
<span class="nc" id="L1003">        RelationType relType = getRelationType(relationTypeName);</span>

<span class="nc" id="L1005">        String roleName = role.getRoleName();</span>
<span class="nc" id="L1006">        List&lt;ObjectName&gt; roleValue = role.getRoleValue();</span>
<span class="nc" id="L1007">        boolean writeChkFlag = true;</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (initFlag.booleanValue()) {</span>
<span class="nc" id="L1009">            writeChkFlag = false;</span>
        }

        RoleInfo roleInfo;
        try {
<span class="nc" id="L1014">            roleInfo = relType.getRoleInfo(roleName);</span>
<span class="nc" id="L1015">        } catch (RoleInfoNotFoundException exc) {</span>
<span class="nc" id="L1016">            RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                    &quot;checkRoleWriting&quot;);
<span class="nc" id="L1018">            return Integer.valueOf(RoleStatus.NO_ROLE_WITH_NAME);</span>
<span class="nc" id="L1019">        }</span>

<span class="nc" id="L1021">        Integer result = checkRoleInt(2,</span>
                                      roleName,
                                      roleValue,
                                      roleInfo,
                                      writeChkFlag);

<span class="nc" id="L1027">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;checkRoleWriting&quot;);
<span class="nc" id="L1029">        return result;</span>
    }

    /**
     * Sends a notification (RelationNotification) for a relation creation.
     * The notification type is:
     * &lt;P&gt;- RelationNotification.RELATION_BASIC_CREATION if the relation is an
     * object internal to the Relation Service
     * &lt;P&gt;- RelationNotification.RELATION_MBEAN_CREATION if the relation is a
     * MBean added as a relation.
     * &lt;P&gt;The source object is the Relation Service itself.
     * &lt;P&gt;It is called in Relation Service createRelation() and
     * addRelation() methods.
     *
     * @param relationId  relation identifier of the updated relation
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if there is no relation for given
     * relation id
     */
    public void sendRelationCreationNotification(String relationId)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L1054">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1055">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1058">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;sendRelationCreationNotification&quot;, relationId);

        // Message
<span class="nc" id="L1062">        StringBuilder ntfMsg = new StringBuilder(&quot;Creation of relation &quot;);</span>
<span class="nc" id="L1063">        ntfMsg.append(relationId);</span>

        // Can throw RelationNotFoundException
<span class="nc" id="L1066">        sendNotificationInt(1,</span>
<span class="nc" id="L1067">                            ntfMsg.toString(),</span>
                            relationId,
                            null,
                            null,
                            null,
                            null);

<span class="nc" id="L1074">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;sendRelationCreationNotification&quot;);
<span class="nc" id="L1076">        return;</span>
    }

    /**
     * Sends a notification (RelationNotification) for a role update in the
     * given relation. The notification type is:
     * &lt;P&gt;- RelationNotification.RELATION_BASIC_UPDATE if the relation is an
     * object internal to the Relation Service
     * &lt;P&gt;- RelationNotification.RELATION_MBEAN_UPDATE if the relation is a
     * MBean added as a relation.
     * &lt;P&gt;The source object is the Relation Service itself.
     * &lt;P&gt;It is called in relation MBean setRole() (for given role) and
     * setRoles() (for each role) methods (implementation provided in
     * RelationSupport class).
     * &lt;P&gt;It is also called in Relation Service setRole() (for given role) and
     * setRoles() (for each role) methods.
     *
     * @param relationId  relation identifier of the updated relation
     * @param newRole  new role (name and new value)
     * @param oldValue  old role value (List of ObjectName objects)
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if there is no relation for given
     * relation id
     */
    public void sendRoleUpdateNotification(String relationId,
                                           Role newRole,
                                           List&lt;ObjectName&gt; oldValue)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L1107" title="All 6 branches missed.">        if (relationId == null ||</span>
            newRole == null ||
            oldValue == null) {
<span class="nc" id="L1110">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1111">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc bnc" id="L1114" title="All 2 branches missed.">        if (!(oldValue instanceof ArrayList&lt;?&gt;))</span>
<span class="nc" id="L1115">            oldValue = new ArrayList&lt;ObjectName&gt;(oldValue);</span>

<span class="nc" id="L1117">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;sendRoleUpdateNotification&quot;,
                new Object[] {relationId, newRole, oldValue});

<span class="nc" id="L1121">        String roleName = newRole.getRoleName();</span>
<span class="nc" id="L1122">        List&lt;ObjectName&gt; newRoleVal = newRole.getRoleValue();</span>

        // Message
<span class="nc" id="L1125">        String newRoleValString = Role.roleValueToString(newRoleVal);</span>
<span class="nc" id="L1126">        String oldRoleValString = Role.roleValueToString(oldValue);</span>
<span class="nc" id="L1127">        StringBuilder ntfMsg = new StringBuilder(&quot;Value of role &quot;);</span>
<span class="nc" id="L1128">        ntfMsg.append(roleName);</span>
<span class="nc" id="L1129">        ntfMsg.append(&quot; has changed\nOld value:\n&quot;);</span>
<span class="nc" id="L1130">        ntfMsg.append(oldRoleValString);</span>
<span class="nc" id="L1131">        ntfMsg.append(&quot;\nNew value:\n&quot;);</span>
<span class="nc" id="L1132">        ntfMsg.append(newRoleValString);</span>

        // Can throw a RelationNotFoundException
<span class="nc" id="L1135">        sendNotificationInt(2,</span>
<span class="nc" id="L1136">                            ntfMsg.toString(),</span>
                            relationId,
                            null,
                            roleName,
                            newRoleVal,
                            oldValue);

<span class="nc" id="L1143">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;sendRoleUpdateNotification&quot;);
<span class="nc" id="L1145">    }</span>

    /**
     * Sends a notification (RelationNotification) for a relation removal.
     * The notification type is:
     * &lt;P&gt;- RelationNotification.RELATION_BASIC_REMOVAL if the relation is an
     * object internal to the Relation Service
     * &lt;P&gt;- RelationNotification.RELATION_MBEAN_REMOVAL if the relation is a
     * MBean added as a relation.
     * &lt;P&gt;The source object is the Relation Service itself.
     * &lt;P&gt;It is called in Relation Service removeRelation() method.
     *
     * @param relationId  relation identifier of the updated relation
     * @param unregMBeanList  List of ObjectNames of MBeans expected
     * to be unregistered due to relation removal (can be null)
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if there is no relation for given
     * relation id
     */
    public void sendRelationRemovalNotification(String relationId,
                                                List&lt;ObjectName&gt; unregMBeanList)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L1170" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L1171">            String excMsg = &quot;Invalid parameter&quot;;</span>
<span class="nc" id="L1172">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1175">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;sendRelationRemovalNotification&quot;,
                new Object[] {relationId, unregMBeanList});

        // Can throw RelationNotFoundException
<span class="nc" id="L1180">        sendNotificationInt(3,</span>
                            &quot;Removal of relation &quot; + relationId,
                            relationId,
                            unregMBeanList,
                            null,
                            null,
                            null);


<span class="nc" id="L1189">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;sendRelationRemovalNotification&quot;);
<span class="nc" id="L1191">        return;</span>
    }

    /**
     * Handles update of the Relation Service role map for the update of given
     * role in given relation.
     * &lt;P&gt;It is called in relation MBean setRole() (for given role) and
     * setRoles() (for each role) methods (implementation provided in
     * RelationSupport class).
     * &lt;P&gt;It is also called in Relation Service setRole() (for given role) and
     * setRoles() (for each role) methods.
     * &lt;P&gt;To allow the Relation Service to maintain the consistency (in case
     * of MBean unregistration) and to be able to perform queries, this method
     * must be called when a role is updated.
     *
     * @param relationId  relation identifier of the updated relation
     * @param newRole  new role (name and new value)
     * @param oldValue  old role value (List of ObjectName objects)
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception RelationNotFoundException  if no relation for given id.
     */
    public void updateRoleMap(String relationId,
                              Role newRole,
                              List&lt;ObjectName&gt; oldValue)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationNotFoundException {

<span class="nc bnc" id="L1222" title="All 6 branches missed.">        if (relationId == null ||</span>
            newRole == null ||
            oldValue == null) {
<span class="nc" id="L1225">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1226">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1229">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;updateRoleMap&quot;, new Object[] {relationId, newRole, oldValue});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1233">        isActive();</span>

        // Verifies the relation has been added in the Relation Service
        // Can throw a RelationNotFoundException
<span class="nc" id="L1237">        Object result = getRelation(relationId);</span>

<span class="nc" id="L1239">        String roleName = newRole.getRoleName();</span>
<span class="nc" id="L1240">        List&lt;ObjectName&gt; newRoleValue = newRole.getRoleValue();</span>
        // Note: no need to test if oldValue not null before cloning,
        //       tested above.
<span class="nc" id="L1243">        List&lt;ObjectName&gt; oldRoleValue =</span>
            new ArrayList&lt;ObjectName&gt;(oldValue);

        // List of ObjectNames of new referenced MBeans
<span class="nc" id="L1247">        List&lt;ObjectName&gt; newRefList = new ArrayList&lt;ObjectName&gt;();</span>

<span class="nc bnc" id="L1249" title="All 2 branches missed.">        for (ObjectName currObjName : newRoleValue) {</span>

            // Checks if this ObjectName was already present in old value
            // Note: use copy (oldRoleValue) instead of original
            //       oldValue to speed up, as oldRoleValue is decreased
            //       by removing unchanged references :)
<span class="nc" id="L1255">            int currObjNamePos = oldRoleValue.indexOf(currObjName);</span>

<span class="nc bnc" id="L1257" title="All 2 branches missed.">            if (currObjNamePos == -1) {</span>
                // New reference to an ObjectName

                // Stores this reference into map
                // Returns true if new reference, false if MBean already
                // referenced
<span class="nc" id="L1263">                boolean isNewFlag = addNewMBeanReference(currObjName,</span>
                                                        relationId,
                                                        roleName);

<span class="nc bnc" id="L1267" title="All 2 branches missed.">                if (isNewFlag) {</span>
                    // Adds it into list of new reference
<span class="nc" id="L1269">                    newRefList.add(currObjName);</span>
                }

<span class="nc" id="L1272">            } else {</span>
                // MBean was already referenced in old value

                // Removes it from old value (local list) to ignore it when
                // looking for remove MBean references
<span class="nc" id="L1277">                oldRoleValue.remove(currObjNamePos);</span>
            }
<span class="nc" id="L1279">        }</span>

        // List of ObjectNames of MBeans no longer referenced
<span class="nc" id="L1282">        List&lt;ObjectName&gt; obsRefList = new ArrayList&lt;ObjectName&gt;();</span>

        // Each ObjectName remaining in oldRoleValue is an ObjectName no longer
        // referenced in new value
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        for (ObjectName currObjName : oldRoleValue) {</span>
            // Removes MBean reference from map
            // Returns true if the MBean is no longer referenced in any
            // relation
<span class="nc" id="L1290">            boolean noLongerRefFlag = removeMBeanReference(currObjName,</span>
                                                          relationId,
                                                          roleName,
                                                          false);

<span class="nc bnc" id="L1295" title="All 2 branches missed.">            if (noLongerRefFlag) {</span>
                // Adds it into list of references to be removed
<span class="nc" id="L1297">                obsRefList.add(currObjName);</span>
            }
<span class="nc" id="L1299">        }</span>

        // To avoid having one listener per ObjectName of referenced MBean,
        // and to increase performances, there is only one listener recording
        // all ObjectNames of interest
<span class="nc" id="L1304">        updateUnregistrationListener(newRefList, obsRefList);</span>

<span class="nc" id="L1306">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;updateRoleMap&quot;);
<span class="nc" id="L1308">        return;</span>
    }

    /**
     * Removes given relation from the Relation Service.
     * &lt;P&gt;A RelationNotification notification is sent, its type being:
     * &lt;P&gt;- RelationNotification.RELATION_BASIC_REMOVAL if the relation was
     * only internal to the Relation Service
     * &lt;P&gt;- RelationNotification.RELATION_MBEAN_REMOVAL if the relation is
     * registered as an MBean.
     * &lt;P&gt;For MBeans referenced in such relation, nothing will be done,
     *
     * @param relationId  relation id of the relation to be removed
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation corresponding to
     * given relation id
     */
    public void removeRelation(String relationId)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationNotFoundException {

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1334">        isActive();</span>

<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L1337">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1338">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1341">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;removeRelation&quot;, relationId);

        // Checks there is a relation with this id
        // Can throw RelationNotFoundException
<span class="nc" id="L1346">        Object result = getRelation(relationId);</span>

        // Removes it from listener filter
<span class="nc bnc" id="L1349" title="All 2 branches missed.">        if (result instanceof ObjectName) {</span>
<span class="nc" id="L1350">            List&lt;ObjectName&gt; obsRefList = new ArrayList&lt;ObjectName&gt;();</span>
<span class="nc" id="L1351">            obsRefList.add((ObjectName)result);</span>
            // Can throw a RelationServiceNotRegisteredException
<span class="nc" id="L1353">            updateUnregistrationListener(null, obsRefList);</span>
        }

        // Sends a notification
        // Note: has to be done FIRST as needs the relation to be still in the
        //       Relation Service
        // No RelationNotFoundException as checked above

        // Revisit [cebro] Handle CIM &quot;Delete&quot; and &quot;IfDeleted&quot; qualifiers:
        //   deleting the relation can mean to delete referenced MBeans. In
        //   that case, MBeans to be unregistered are put in a list sent along
        //   with the notification below

        // Can throw a RelationNotFoundException (but detected above)
<span class="nc" id="L1367">        sendRelationRemovalNotification(relationId, null);</span>

        // Removes the relation from various internal maps

        //  - MBean reference map
        // Retrieves the MBeans referenced in this relation
        // Note: here we cannot use removeMBeanReference() because it would
        //       require to know the MBeans referenced in the relation. For
        //       that it would be necessary to call 'getReferencedMBeans()'
        //       on the relation itself. Ok if it is an internal one, but if
        //       it is an MBean, it is possible it is already unregistered, so
        //       not available through the MBean Server.
<span class="nc" id="L1379">        List&lt;ObjectName&gt; refMBeanList = new ArrayList&lt;ObjectName&gt;();</span>
        // List of MBeans no longer referenced in any relation, to be
        // removed fom the map
<span class="nc" id="L1382">        List&lt;ObjectName&gt; nonRefObjNameList = new ArrayList&lt;ObjectName&gt;();</span>

<span class="nc" id="L1384">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>

            for (ObjectName currRefObjName :
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                     myRefedMBeanObjName2RelIdsMap.keySet()) {</span>

                // Retrieves relations where the MBean is referenced
<span class="nc" id="L1390">                Map&lt;String,List&lt;String&gt;&gt; relIdMap =</span>
<span class="nc" id="L1391">                    myRefedMBeanObjName2RelIdsMap.get(currRefObjName);</span>

<span class="nc bnc" id="L1393" title="All 2 branches missed.">                if (relIdMap.containsKey(relationId)) {</span>
<span class="nc" id="L1394">                    relIdMap.remove(relationId);</span>
<span class="nc" id="L1395">                    refMBeanList.add(currRefObjName);</span>
                }

<span class="nc bnc" id="L1398" title="All 2 branches missed.">                if (relIdMap.isEmpty()) {</span>
                    // MBean no longer referenced
                    // Note: do not remove it here because pointed by the
                    //       iterator!
<span class="nc" id="L1402">                    nonRefObjNameList.add(currRefObjName);</span>
                }
<span class="nc" id="L1404">            }</span>

            // Cleans MBean reference map by removing MBeans no longer
            // referenced
<span class="nc bnc" id="L1408" title="All 2 branches missed.">            for (ObjectName currRefObjName : nonRefObjNameList) {</span>
<span class="nc" id="L1409">                myRefedMBeanObjName2RelIdsMap.remove(currRefObjName);</span>
<span class="nc" id="L1410">            }</span>
<span class="nc" id="L1411">        }</span>

        // - Relation id to object map
<span class="nc" id="L1414">        synchronized(myRelId2ObjMap) {</span>
<span class="nc" id="L1415">            myRelId2ObjMap.remove(relationId);</span>
<span class="nc" id="L1416">        }</span>

<span class="nc bnc" id="L1418" title="All 2 branches missed.">        if (result instanceof ObjectName) {</span>
            // - ObjectName to relation id map
<span class="nc" id="L1420">            synchronized(myRelMBeanObjName2RelIdMap) {</span>
<span class="nc" id="L1421">                myRelMBeanObjName2RelIdMap.remove((ObjectName)result);</span>
<span class="nc" id="L1422">            }</span>
        }

        // Relation id to relation type name map
        // First retrieves the relation type name
        String relTypeName;
<span class="nc" id="L1428">        synchronized(myRelId2RelTypeMap) {</span>
<span class="nc" id="L1429">            relTypeName = myRelId2RelTypeMap.get(relationId);</span>
<span class="nc" id="L1430">            myRelId2RelTypeMap.remove(relationId);</span>
<span class="nc" id="L1431">        }</span>
        // - Relation type name to relation id map
<span class="nc" id="L1433">        synchronized(myRelType2RelIdsMap) {</span>
<span class="nc" id="L1434">            List&lt;String&gt; relIdList = myRelType2RelIdsMap.get(relTypeName);</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">            if (relIdList != null) {</span>
                // Can be null if called from removeRelationType()
<span class="nc" id="L1437">                relIdList.remove(relationId);</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">                if (relIdList.isEmpty()) {</span>
                    // No other relation of that type
<span class="nc" id="L1440">                    myRelType2RelIdsMap.remove(relTypeName);</span>
                }
            }
<span class="nc" id="L1443">        }</span>

<span class="nc" id="L1445">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;removeRelation&quot;);
<span class="nc" id="L1447">        return;</span>
    }

    /**
     * Purges the relations.
     *
     * &lt;P&gt;Depending on the purgeFlag value, this method is either called
     * automatically when a notification is received for the unregistration of
     * an MBean referenced in a relation (if the flag is set to true), or not
     * (if the flag is set to false).
     * &lt;P&gt;In that case it is up to the user to call it to maintain the
     * consistency of the relations. To be kept in mind that if an MBean is
     * unregistered and the purge not done immediately, if the ObjectName is
     * reused and assigned to another MBean referenced in a relation, calling
     * manually this purgeRelations() method will cause trouble, as will
     * consider the ObjectName as corresponding to the unregistered MBean, not
     * seeing the new one.
     *
     * &lt;P&gt;The behavior depends on the cardinality of the role where the
     * unregistered MBean is referenced:
     * &lt;P&gt;- if removing one MBean reference in the role makes its number of
     * references less than the minimum degree, the relation has to be removed.
     * &lt;P&gt;- if the remaining number of references after removing the MBean
     * reference is still in the cardinality range, keep the relation and
     * update it calling its handleMBeanUnregistration() callback.
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server.
     */
    public void purgeRelations()
        throws RelationServiceNotRegisteredException {

<span class="nc" id="L1479">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;purgeRelations&quot;);

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1483">        isActive();</span>

        // Revisit [cebro] Handle the CIM &quot;Delete&quot; and &quot;IfDeleted&quot; qualifier:
        //    if the unregistered MBean has the &quot;IfDeleted&quot; qualifier,
        //    possible that the relation itself or other referenced MBeans
        //    have to be removed (then a notification would have to be sent
        //    to inform that they should be unregistered.


        // Clones the list of notifications to be able to still receive new
        // notifications while proceeding those ones
        List&lt;MBeanServerNotification&gt; localUnregNtfList;
<span class="nc" id="L1495">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>
<span class="nc" id="L1496">            localUnregNtfList =</span>
                new ArrayList&lt;MBeanServerNotification&gt;(myUnregNtfList);
            // Resets list
<span class="nc" id="L1499">            myUnregNtfList = new ArrayList&lt;MBeanServerNotification&gt;();</span>
<span class="nc" id="L1500">        }</span>


        // Updates the listener filter to avoid receiving notifications for
        // those MBeans again
        // Makes also a local &quot;myRefedMBeanObjName2RelIdsMap&quot; map, mapping
        // ObjectName -&gt; relId -&gt; roles, to remove the MBean from the global
        // map
        // List of references to be removed from the listener filter
<span class="nc" id="L1509">        List&lt;ObjectName&gt; obsRefList = new ArrayList&lt;ObjectName&gt;();</span>
        // Map including ObjectNames for unregistered MBeans, with
        // referencing relation ids and roles
<span class="nc" id="L1512">        Map&lt;ObjectName,Map&lt;String,List&lt;String&gt;&gt;&gt; localMBean2RelIdMap =</span>
            new HashMap&lt;ObjectName,Map&lt;String,List&lt;String&gt;&gt;&gt;();

<span class="nc" id="L1515">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            for (MBeanServerNotification currNtf : localUnregNtfList) {</span>

<span class="nc" id="L1518">                ObjectName unregMBeanName = currNtf.getMBeanName();</span>

                // Adds the unregsitered MBean in the list of references to
                // remove from the listener filter
<span class="nc" id="L1522">                obsRefList.add(unregMBeanName);</span>

                // Retrieves the associated map of relation ids and roles
<span class="nc" id="L1525">                Map&lt;String,List&lt;String&gt;&gt; relIdMap =</span>
<span class="nc" id="L1526">                    myRefedMBeanObjName2RelIdsMap.get(unregMBeanName);</span>
<span class="nc" id="L1527">                localMBean2RelIdMap.put(unregMBeanName, relIdMap);</span>

<span class="nc" id="L1529">                myRefedMBeanObjName2RelIdsMap.remove(unregMBeanName);</span>
<span class="nc" id="L1530">            }</span>
<span class="nc" id="L1531">        }</span>

        // Updates the listener
        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1535">        updateUnregistrationListener(null, obsRefList);</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">        for (MBeanServerNotification currNtf : localUnregNtfList) {</span>

<span class="nc" id="L1539">            ObjectName unregMBeanName = currNtf.getMBeanName();</span>

            // Retrieves the relations where the MBean is referenced
<span class="nc" id="L1542">            Map&lt;String,List&lt;String&gt;&gt; localRelIdMap =</span>
<span class="nc" id="L1543">                    localMBean2RelIdMap.get(unregMBeanName);</span>

            // List of relation ids where the unregistered MBean is
            // referenced
            for (Map.Entry&lt;String,List&lt;String&gt;&gt; currRel :
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                        localRelIdMap.entrySet()) {</span>
<span class="nc" id="L1549">                final String currRelId = currRel.getKey();</span>
                // List of roles of the relation where the MBean is
                // referenced
<span class="nc" id="L1552">                List&lt;String&gt; localRoleNameList = currRel.getValue();</span>

                // Checks if the relation has to be removed or not,
                // regarding expected minimum role cardinality and current
                // number of references after removal of the current one
                // If the relation is kept, calls
                // handleMBeanUnregistration() callback of the relation to
                // update it
                //
                // Can throw RelationServiceNotRegisteredException
                //
                // Shall not throw RelationNotFoundException,
                // RoleNotFoundException, MBeanException
                try {
<span class="nc" id="L1566">                    handleReferenceUnregistration(currRelId,</span>
                                                  unregMBeanName,
                                                  localRoleNameList);
<span class="nc" id="L1569">                } catch (RelationNotFoundException exc1) {</span>
<span class="nc" id="L1570">                    throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L1571">                } catch (RoleNotFoundException exc2) {</span>
<span class="nc" id="L1572">                    throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L1573">                }</span>
<span class="nc" id="L1574">            }</span>
<span class="nc" id="L1575">        }</span>

<span class="nc" id="L1577">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;purgeRelations&quot;);
<span class="nc" id="L1579">        return;</span>
    }

    /**
     * Retrieves the relations where a given MBean is referenced.
     * &lt;P&gt;This corresponds to the CIM &quot;References&quot; and &quot;ReferenceNames&quot;
     * operations.
     *
     * @param mbeanName  ObjectName of MBean
     * @param relationTypeName  can be null; if specified, only the relations
     * of that type will be considered in the search. Else all relation types
     * are considered.
     * @param roleName  can be null; if specified, only the relations
     * where the MBean is referenced in that role will be returned. Else all
     * roles are considered.
     *
     * @return an HashMap, where the keys are the relation ids of the relations
     * where the MBean is referenced, and the value is, for each key,
     * an ArrayList of role names (as an MBean can be referenced in several
     * roles in the same relation).
     *
     * @exception IllegalArgumentException  if null parameter
     */
    public Map&lt;String,List&lt;String&gt;&gt;
        findReferencingRelations(ObjectName mbeanName,
                                 String relationTypeName,
                                 String roleName)
            throws IllegalArgumentException {

<span class="nc bnc" id="L1608" title="All 2 branches missed.">        if (mbeanName == null) {</span>
<span class="nc" id="L1609">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1610">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1613">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;findReferencingRelations&quot;,
                new Object[] {mbeanName, relationTypeName, roleName});

<span class="nc" id="L1617">        Map&lt;String,List&lt;String&gt;&gt; result = new HashMap&lt;String,List&lt;String&gt;&gt;();</span>

<span class="nc" id="L1619">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>

            // Retrieves the relations referencing the MBean
<span class="nc" id="L1622">            Map&lt;String,List&lt;String&gt;&gt; relId2RoleNamesMap =</span>
<span class="nc" id="L1623">                myRefedMBeanObjName2RelIdsMap.get(mbeanName);</span>

<span class="nc bnc" id="L1625" title="All 2 branches missed.">            if (relId2RoleNamesMap != null) {</span>

                // Relation Ids where the MBean is referenced
<span class="nc" id="L1628">                Set&lt;String&gt; allRelIdSet = relId2RoleNamesMap.keySet();</span>

                // List of relation ids of interest regarding the selected
                // relation type
                List&lt;String&gt; relIdList;
<span class="nc bnc" id="L1633" title="All 2 branches missed.">                if (relationTypeName == null) {</span>
                    // Considers all relations
<span class="nc" id="L1635">                    relIdList = new ArrayList&lt;String&gt;(allRelIdSet);</span>

                } else {

<span class="nc" id="L1639">                    relIdList = new ArrayList&lt;String&gt;();</span>

                    // Considers only the relation ids for relations of given
                    // type
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                    for (String currRelId : allRelIdSet) {</span>

                        // Retrieves its relation type
                        String currRelTypeName;
<span class="nc" id="L1647">                        synchronized(myRelId2RelTypeMap) {</span>
<span class="nc" id="L1648">                            currRelTypeName =</span>
<span class="nc" id="L1649">                                myRelId2RelTypeMap.get(currRelId);</span>
<span class="nc" id="L1650">                        }</span>

<span class="nc bnc" id="L1652" title="All 2 branches missed.">                        if (currRelTypeName.equals(relationTypeName)) {</span>

<span class="nc" id="L1654">                            relIdList.add(currRelId);</span>

                        }
<span class="nc" id="L1657">                    }</span>
                }

                // Now looks at the roles where the MBean is expected to be
                // referenced

<span class="nc bnc" id="L1663" title="All 2 branches missed.">                for (String currRelId : relIdList) {</span>
                    // Retrieves list of role names where the MBean is
                    // referenced
<span class="nc" id="L1666">                    List&lt;String&gt; currRoleNameList =</span>
<span class="nc" id="L1667">                        relId2RoleNamesMap.get(currRelId);</span>

<span class="nc bnc" id="L1669" title="All 2 branches missed.">                    if (roleName == null) {</span>
                        // All roles to be considered
                        // Note: no need to test if list not null before
                        //       cloning, MUST be not null else bug :(
<span class="nc" id="L1673">                        result.put(currRelId,</span>
                                   new ArrayList&lt;String&gt;(currRoleNameList));

<span class="nc bnc" id="L1676" title="All 2 branches missed.">                    }  else if (currRoleNameList.contains(roleName)) {</span>
                        // Filters only the relations where the MBean is
                        // referenced in // given role
<span class="nc" id="L1679">                        List&lt;String&gt; dummyList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1680">                        dummyList.add(roleName);</span>
<span class="nc" id="L1681">                        result.put(currRelId, dummyList);</span>
                    }
<span class="nc" id="L1683">                }</span>
            }
<span class="nc" id="L1685">        }</span>

<span class="nc" id="L1687">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;findReferencingRelations&quot;);
<span class="nc" id="L1689">        return result;</span>
    }

    /**
     * Retrieves the MBeans associated to given one in a relation.
     * &lt;P&gt;This corresponds to CIM Associators and AssociatorNames operations.
     *
     * @param mbeanName  ObjectName of MBean
     * @param relationTypeName  can be null; if specified, only the relations
     * of that type will be considered in the search. Else all
     * relation types are considered.
     * @param roleName  can be null; if specified, only the relations
     * where the MBean is referenced in that role will be considered. Else all
     * roles are considered.
     *
     * @return an HashMap, where the keys are the ObjectNames of the MBeans
     * associated to given MBean, and the value is, for each key, an ArrayList
     * of the relation ids of the relations where the key MBean is
     * associated to given one (as they can be associated in several different
     * relations).
     *
     * @exception IllegalArgumentException  if null parameter
     */
    public Map&lt;ObjectName,List&lt;String&gt;&gt;
        findAssociatedMBeans(ObjectName mbeanName,
                             String relationTypeName,
                             String roleName)
            throws IllegalArgumentException {

<span class="nc bnc" id="L1718" title="All 2 branches missed.">        if (mbeanName == null) {</span>
<span class="nc" id="L1719">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1720">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1723">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;findAssociatedMBeans&quot;,
                new Object[] {mbeanName, relationTypeName, roleName});

        // Retrieves the map &lt;relation id&gt; -&gt; &lt;role names&gt; for those
        // criterias
<span class="nc" id="L1729">        Map&lt;String,List&lt;String&gt;&gt; relId2RoleNamesMap =</span>
<span class="nc" id="L1730">            findReferencingRelations(mbeanName,</span>
                                     relationTypeName,
                                     roleName);

<span class="nc" id="L1734">        Map&lt;ObjectName,List&lt;String&gt;&gt; result =</span>
            new HashMap&lt;ObjectName,List&lt;String&gt;&gt;();

<span class="nc bnc" id="L1737" title="All 2 branches missed.">        for (String currRelId : relId2RoleNamesMap.keySet()) {</span>

            // Retrieves ObjectNames of MBeans referenced in this relation
            //
            // Shall not throw a RelationNotFoundException if incorrect status
            // of maps :(
            Map&lt;ObjectName,List&lt;String&gt;&gt; objName2RoleNamesMap;
            try {
<span class="nc" id="L1745">                objName2RoleNamesMap = getReferencedMBeans(currRelId);</span>
<span class="nc" id="L1746">            } catch (RelationNotFoundException exc) {</span>
<span class="nc" id="L1747">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L1748">            }</span>

            // For each MBean associated to given one in a relation, adds the
            // association &lt;ObjectName&gt; -&gt; &lt;relation id&gt; into result map
<span class="nc bnc" id="L1752" title="All 2 branches missed.">            for (ObjectName currObjName : objName2RoleNamesMap.keySet()) {</span>

<span class="nc bnc" id="L1754" title="All 2 branches missed.">                if (!(currObjName.equals(mbeanName))) {</span>

                    // Sees if this MBean is already associated to the given
                    // one in another relation
<span class="nc" id="L1758">                    List&lt;String&gt; currRelIdList = result.get(currObjName);</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">                    if (currRelIdList == null) {</span>

<span class="nc" id="L1761">                        currRelIdList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1762">                        currRelIdList.add(currRelId);</span>
<span class="nc" id="L1763">                        result.put(currObjName, currRelIdList);</span>

                    } else {
<span class="nc" id="L1766">                        currRelIdList.add(currRelId);</span>
                    }
                }
<span class="nc" id="L1769">            }</span>
<span class="nc" id="L1770">        }</span>

<span class="nc" id="L1772">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;findAssociatedMBeans&quot;);
<span class="nc" id="L1774">        return result;</span>
    }

    /**
     * Returns the relation ids for relations of the given type.
     *
     * @param relationTypeName  relation type name
     *
     * @return an ArrayList of relation ids.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationTypeNotFoundException  if there is no relation type
     * with that name.
     */
    public List&lt;String&gt; findRelationsOfType(String relationTypeName)
        throws IllegalArgumentException,
               RelationTypeNotFoundException {

<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (relationTypeName == null) {</span>
<span class="nc" id="L1793">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1794">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1797">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;findRelationsOfType&quot;);

        // Can throw RelationTypeNotFoundException
<span class="nc" id="L1801">        RelationType relType = getRelationType(relationTypeName);</span>

        List&lt;String&gt; result;
<span class="nc" id="L1804">        synchronized(myRelType2RelIdsMap) {</span>
<span class="nc" id="L1805">            List&lt;String&gt; result1 = myRelType2RelIdsMap.get(relationTypeName);</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            if (result1 == null)</span>
<span class="nc" id="L1807">                result = new ArrayList&lt;String&gt;();</span>
            else
<span class="nc" id="L1809">                result = new ArrayList&lt;String&gt;(result1);</span>
<span class="nc" id="L1810">        }</span>

<span class="nc" id="L1812">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;findRelationsOfType&quot;);
<span class="nc" id="L1814">        return result;</span>
    }

    /**
     * Retrieves role value for given role name in given relation.
     *
     * @param relationId  relation id
     * @param roleName  name of role
     *
     * @return the ArrayList of ObjectName objects being the role value
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation with given id
     * @exception RoleNotFoundException  if:
     * &lt;P&gt;- there is no role with given name
     * &lt;P&gt;or
     * &lt;P&gt;- the role is not readable.
     *
     * @see #setRole
     */
    public List&lt;ObjectName&gt; getRole(String relationId,
                                    String roleName)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationNotFoundException,
               RoleNotFoundException {

<span class="nc bnc" id="L1843" title="All 4 branches missed.">        if (relationId == null || roleName == null) {</span>
<span class="nc" id="L1844">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1845">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1848">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRole&quot;, new Object[] {relationId, roleName});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1852">        isActive();</span>

        // Can throw a RelationNotFoundException
<span class="nc" id="L1855">        Object relObj = getRelation(relationId);</span>

        List&lt;ObjectName&gt; result;

<span class="nc bnc" id="L1859" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
            // Can throw RoleNotFoundException
<span class="nc" id="L1862">            result = cast(</span>
<span class="nc" id="L1863">                ((RelationSupport)relObj).getRoleInt(roleName,</span>
                                                     true,
                                                     this,
                                                     false));

        } else {
            // Relation MBean
<span class="nc" id="L1870">            Object[] params = new Object[1];</span>
<span class="nc" id="L1871">            params[0] = roleName;</span>
<span class="nc" id="L1872">            String[] signature = new String[1];</span>
<span class="nc" id="L1873">            signature[0] = &quot;java.lang.String&quot;;</span>
            // Can throw MBeanException wrapping a RoleNotFoundException:
            // throw wrapped exception
            //
            // Shall not throw InstanceNotFoundException or ReflectionException
            try {
<span class="nc" id="L1879">                List&lt;ObjectName&gt; invokeResult = cast(</span>
<span class="nc" id="L1880">                    myMBeanServer.invoke(((ObjectName)relObj),</span>
                                         &quot;getRole&quot;,
                                         params,
                                         signature));
<span class="nc bnc" id="L1884" title="All 4 branches missed.">                if (invokeResult == null || invokeResult instanceof ArrayList&lt;?&gt;)</span>
<span class="nc" id="L1885">                    result = invokeResult;</span>
                else
<span class="nc" id="L1887">                    result = new ArrayList&lt;ObjectName&gt;(invokeResult);</span>
<span class="nc" id="L1888">            } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L1889">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L1890">            } catch (ReflectionException exc2) {</span>
<span class="nc" id="L1891">                throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L1892">            } catch (MBeanException exc3) {</span>
<span class="nc" id="L1893">                Exception wrappedExc = exc3.getTargetException();</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                if (wrappedExc instanceof RoleNotFoundException) {</span>
<span class="nc" id="L1895">                    throw ((RoleNotFoundException)wrappedExc);</span>
                } else {
<span class="nc" id="L1897">                    throw new RuntimeException(wrappedExc.getMessage());</span>
                }
<span class="nc" id="L1899">            }</span>
        }

<span class="nc" id="L1902">        RELATION_LOGGER.exiting(RelationService.class.getName(), &quot;getRole&quot;);</span>
<span class="nc" id="L1903">        return result;</span>
    }

    /**
     * Retrieves values of roles with given names in given relation.
     *
     * @param relationId  relation id
     * @param roleNameArray  array of names of roles to be retrieved
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully retrieved) and a RoleUnresolvedList (for roles not
     * retrieved).
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation with given id
     *
     * @see #setRoles
     */
    public RoleResult getRoles(String relationId,
                               String[] roleNameArray)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L1929" title="All 4 branches missed.">        if (relationId == null || roleNameArray == null) {</span>
<span class="nc" id="L1930">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1931">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1934">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRoles&quot;, relationId);

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L1938">        isActive();</span>

        // Can throw a RelationNotFoundException
<span class="nc" id="L1941">        Object relObj = getRelation(relationId);</span>

        RoleResult result;

<span class="nc bnc" id="L1945" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
<span class="nc" id="L1947">            result = ((RelationSupport)relObj).getRolesInt(roleNameArray,</span>
                                                        true,
                                                        this);
        } else {
            // Relation MBean
<span class="nc" id="L1952">            Object[] params = new Object[1];</span>
<span class="nc" id="L1953">            params[0] = roleNameArray;</span>
<span class="nc" id="L1954">            String[] signature = new String[1];</span>
            try {
<span class="nc" id="L1956">                signature[0] = (roleNameArray.getClass()).getName();</span>
<span class="nc" id="L1957">            } catch (Exception exc) {</span>
                // OK : This is an array of java.lang.String
                //      so this should never happen...
<span class="nc" id="L1960">            }</span>
            // Shall not throw InstanceNotFoundException, ReflectionException
            // or MBeanException
            try {
<span class="nc" id="L1964">                result = (RoleResult)</span>
<span class="nc" id="L1965">                    (myMBeanServer.invoke(((ObjectName)relObj),</span>
                                          &quot;getRoles&quot;,
                                          params,
                                          signature));
<span class="nc" id="L1969">            } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L1970">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L1971">            } catch (ReflectionException exc2) {</span>
<span class="nc" id="L1972">                throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L1973">            } catch (MBeanException exc3) {</span>
<span class="nc" id="L1974">                throw new</span>
<span class="nc" id="L1975">                    RuntimeException((exc3.getTargetException()).getMessage());</span>
<span class="nc" id="L1976">            }</span>
        }

<span class="nc" id="L1979">        RELATION_LOGGER.exiting(RelationService.class.getName(), &quot;getRoles&quot;);</span>
<span class="nc" id="L1980">        return result;</span>
    }

    /**
     * Returns all roles present in the relation.
     *
     * @param relationId  relation id
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully retrieved) and a RoleUnresolvedList (for roles not
     * readable).
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation for given id
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     */
    public RoleResult getAllRoles(String relationId)
        throws IllegalArgumentException,
               RelationNotFoundException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L2002" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L2003">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2004">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2007">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRoles&quot;, relationId);

        // Can throw a RelationNotFoundException
<span class="nc" id="L2011">        Object relObj = getRelation(relationId);</span>

        RoleResult result;

<span class="nc bnc" id="L2015" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
<span class="nc" id="L2017">            result = ((RelationSupport)relObj).getAllRolesInt(true, this);</span>

        } else {
            // Relation MBean
            // Shall not throw any Exception
            try {
<span class="nc" id="L2023">                result = (RoleResult)</span>
<span class="nc" id="L2024">                    (myMBeanServer.getAttribute(((ObjectName)relObj),</span>
                                                &quot;AllRoles&quot;));
<span class="nc" id="L2026">            } catch (Exception exc) {</span>
<span class="nc" id="L2027">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2028">            }</span>
        }

<span class="nc" id="L2031">        RELATION_LOGGER.exiting(RelationService.class.getName(), &quot;getRoles&quot;);</span>
<span class="nc" id="L2032">        return result;</span>
    }

    /**
     * Retrieves the number of MBeans currently referenced in the given role.
     *
     * @param relationId  relation id
     * @param roleName  name of role
     *
     * @return the number of currently referenced MBeans in that role
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation with given id
     * @exception RoleNotFoundException  if there is no role with given name
     */
    public Integer getRoleCardinality(String relationId,
                                      String roleName)
        throws IllegalArgumentException,
               RelationNotFoundException,
               RoleNotFoundException {

<span class="nc bnc" id="L2053" title="All 4 branches missed.">        if (relationId == null || roleName == null) {</span>
<span class="nc" id="L2054">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2055">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2058">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRoleCardinality&quot;, new Object[] {relationId, roleName});

        // Can throw a RelationNotFoundException
<span class="nc" id="L2062">        Object relObj = getRelation(relationId);</span>

        Integer result;

<span class="nc bnc" id="L2066" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
            // Can throw RoleNotFoundException
<span class="nc" id="L2069">            result = ((RelationSupport)relObj).getRoleCardinality(roleName);</span>

        } else {
            // Relation MBean
<span class="nc" id="L2073">            Object[] params = new Object[1];</span>
<span class="nc" id="L2074">            params[0] = roleName;</span>
<span class="nc" id="L2075">            String[] signature = new String[1];</span>
<span class="nc" id="L2076">            signature[0] = &quot;java.lang.String&quot;;</span>
            // Can throw MBeanException wrapping RoleNotFoundException:
            // throw wrapped exception
            //
            // Shall not throw InstanceNotFoundException or ReflectionException
            try {
<span class="nc" id="L2082">                result = (Integer)</span>
<span class="nc" id="L2083">                    (myMBeanServer.invoke(((ObjectName)relObj),</span>
                                          &quot;getRoleCardinality&quot;,
                                          params,
                                          signature));
<span class="nc" id="L2087">            } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L2088">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L2089">            } catch (ReflectionException exc2) {</span>
<span class="nc" id="L2090">                throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L2091">            } catch (MBeanException exc3) {</span>
<span class="nc" id="L2092">                Exception wrappedExc = exc3.getTargetException();</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">                if (wrappedExc instanceof RoleNotFoundException) {</span>
<span class="nc" id="L2094">                    throw ((RoleNotFoundException)wrappedExc);</span>
                } else {
<span class="nc" id="L2096">                    throw new RuntimeException(wrappedExc.getMessage());</span>
                }
<span class="nc" id="L2098">            }</span>
        }

<span class="nc" id="L2101">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRoleCardinality&quot;);
<span class="nc" id="L2103">        return result;</span>
    }

    /**
     * Sets the given role in given relation.
     * &lt;P&gt;Will check the role according to its corresponding role definition
     * provided in relation's relation type
     * &lt;P&gt;The Relation Service will keep track of the change to keep the
     * consistency of relations by handling referenced MBean deregistrations.
     *
     * @param relationId  relation id
     * @param role  role to be set (name and new value)
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation with given id
     * @exception RoleNotFoundException  if the role does not exist or is not
     * writable
     * @exception InvalidRoleValueException  if value provided for role is not
     * valid:
     * &lt;P&gt;- the number of referenced MBeans in given value is less than
     * expected minimum degree
     * &lt;P&gt;or
     * &lt;P&gt;- the number of referenced MBeans in provided value exceeds expected
     * maximum degree
     * &lt;P&gt;or
     * &lt;P&gt;- one referenced MBean in the value is not an Object of the MBean
     * class expected for that role
     * &lt;P&gt;or
     * &lt;P&gt;- an MBean provided for that role does not exist
     *
     * @see #getRole
     */
    public void setRole(String relationId,
                        Role role)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationNotFoundException,
               RoleNotFoundException,
               InvalidRoleValueException {

<span class="nc bnc" id="L2145" title="All 4 branches missed.">        if (relationId == null || role == null) {</span>
<span class="nc" id="L2146">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2147">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2150">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;setRole&quot;, new Object[] {relationId, role});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L2154">        isActive();</span>

        // Can throw a RelationNotFoundException
<span class="nc" id="L2157">        Object relObj = getRelation(relationId);</span>

<span class="nc bnc" id="L2159" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
            // Can throw RoleNotFoundException,
            // InvalidRoleValueException and
            // RelationServiceNotRegisteredException
            //
            // Shall not throw RelationTypeNotFoundException
            // (as relation exists in the RS, its relation type is known)
            try {
<span class="nc" id="L2168">                ((RelationSupport)relObj).setRoleInt(role,</span>
                                                  true,
                                                  this,
                                                  false);

<span class="nc" id="L2173">            } catch (RelationTypeNotFoundException exc) {</span>
<span class="nc" id="L2174">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2175">            }</span>

        } else {
            // Relation MBean
<span class="nc" id="L2179">            Object[] params = new Object[1];</span>
<span class="nc" id="L2180">            params[0] = role;</span>
<span class="nc" id="L2181">            String[] signature = new String[1];</span>
<span class="nc" id="L2182">            signature[0] = &quot;javax.management.relation.Role&quot;;</span>
            // Can throw MBeanException wrapping RoleNotFoundException,
            // InvalidRoleValueException
            //
            // Shall not MBeanException wrapping an MBeanException wrapping
            // RelationTypeNotFoundException, or ReflectionException, or
            // InstanceNotFoundException
            try {
<span class="nc" id="L2190">                myMBeanServer.setAttribute(((ObjectName)relObj),</span>
                                           new Attribute(&quot;Role&quot;, role));

<span class="nc" id="L2193">            } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L2194">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L2195">            } catch (ReflectionException exc3) {</span>
<span class="nc" id="L2196">                throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L2197">            } catch (MBeanException exc2) {</span>
<span class="nc" id="L2198">                Exception wrappedExc = exc2.getTargetException();</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">                if (wrappedExc instanceof RoleNotFoundException) {</span>
<span class="nc" id="L2200">                    throw ((RoleNotFoundException)wrappedExc);</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">                } else if (wrappedExc instanceof InvalidRoleValueException) {</span>
<span class="nc" id="L2202">                    throw ((InvalidRoleValueException)wrappedExc);</span>
                } else {
<span class="nc" id="L2204">                    throw new RuntimeException(wrappedExc.getMessage());</span>

                }
<span class="nc" id="L2207">            } catch (AttributeNotFoundException exc4) {</span>
<span class="nc" id="L2208">              throw new RuntimeException(exc4.getMessage());</span>
<span class="nc" id="L2209">            } catch (InvalidAttributeValueException exc5) {</span>
<span class="nc" id="L2210">              throw new RuntimeException(exc5.getMessage());</span>
<span class="nc" id="L2211">            }</span>
        }

<span class="nc" id="L2214">        RELATION_LOGGER.exiting(RelationService.class.getName(), &quot;setRole&quot;);</span>
<span class="nc" id="L2215">        return;</span>
    }

    /**
     * Sets the given roles in given relation.
     * &lt;P&gt;Will check the role according to its corresponding role definition
     * provided in relation's relation type
     * &lt;P&gt;The Relation Service keeps track of the changes to keep the
     * consistency of relations by handling referenced MBean deregistrations.
     *
     * @param relationId  relation id
     * @param roleList  list of roles to be set
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully set) and a RoleUnresolvedList (for roles not
     * set).
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation with given id
     *
     * @see #getRoles
     */
    public RoleResult setRoles(String relationId,
                               RoleList roleList)
        throws RelationServiceNotRegisteredException,
               IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L2245" title="All 4 branches missed.">        if (relationId == null || roleList == null) {</span>
<span class="nc" id="L2246">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2247">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2250">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;setRoles&quot;, new Object[] {relationId, roleList});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L2254">        isActive();</span>

        // Can throw a RelationNotFoundException
<span class="nc" id="L2257">        Object relObj = getRelation(relationId);</span>

        RoleResult result;

<span class="nc bnc" id="L2261" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
            // Can throw RelationServiceNotRegisteredException
            //
            // Shall not throw RelationTypeNotFoundException (as relation is
            // known, its relation type exists)
            try {
<span class="nc" id="L2268">                result = ((RelationSupport)relObj).setRolesInt(roleList,</span>
                                                            true,
                                                            this);
<span class="nc" id="L2271">            } catch (RelationTypeNotFoundException exc) {</span>
<span class="nc" id="L2272">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2273">            }</span>

        } else {
            // Relation MBean
<span class="nc" id="L2277">            Object[] params = new Object[1];</span>
<span class="nc" id="L2278">            params[0] = roleList;</span>
<span class="nc" id="L2279">            String[] signature = new String[1];</span>
<span class="nc" id="L2280">            signature[0] = &quot;javax.management.relation.RoleList&quot;;</span>
            // Shall not throw InstanceNotFoundException or an MBeanException
            // or ReflectionException
            try {
<span class="nc" id="L2284">                result = (RoleResult)</span>
<span class="nc" id="L2285">                    (myMBeanServer.invoke(((ObjectName)relObj),</span>
                                          &quot;setRoles&quot;,
                                          params,
                                          signature));
<span class="nc" id="L2289">            } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L2290">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L2291">            } catch (ReflectionException exc3) {</span>
<span class="nc" id="L2292">                throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L2293">            } catch (MBeanException exc2) {</span>
<span class="nc" id="L2294">                throw new</span>
<span class="nc" id="L2295">                    RuntimeException((exc2.getTargetException()).getMessage());</span>
<span class="nc" id="L2296">            }</span>
        }

<span class="nc" id="L2299">        RELATION_LOGGER.exiting(RelationService.class.getName(), &quot;setRoles&quot;);</span>
<span class="nc" id="L2300">        return result;</span>
    }

    /**
     * Retrieves MBeans referenced in the various roles of the relation.
     *
     * @param relationId  relation id
     *
     * @return a HashMap mapping:
     * &lt;P&gt; ObjectName {@literal -&gt;} ArrayList of String (role names)
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation for given
     * relation id
     */
    public Map&lt;ObjectName,List&lt;String&gt;&gt;
        getReferencedMBeans(String relationId)
            throws IllegalArgumentException,
        RelationNotFoundException {

<span class="nc bnc" id="L2320" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L2321">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2322">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2325">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getReferencedMBeans&quot;, relationId);

        // Can throw a RelationNotFoundException
<span class="nc" id="L2329">        Object relObj = getRelation(relationId);</span>

        Map&lt;ObjectName,List&lt;String&gt;&gt; result;

<span class="nc bnc" id="L2333" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
<span class="nc" id="L2335">            result = ((RelationSupport)relObj).getReferencedMBeans();</span>

        } else {
            // Relation MBean
            // No Exception
            try {
<span class="nc" id="L2341">                result = cast(</span>
<span class="nc" id="L2342">                    myMBeanServer.getAttribute(((ObjectName)relObj),</span>
                                               &quot;ReferencedMBeans&quot;));
<span class="nc" id="L2344">            } catch (Exception exc) {</span>
<span class="nc" id="L2345">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2346">            }</span>
        }

<span class="nc" id="L2349">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getReferencedMBeans&quot;);
<span class="nc" id="L2351">        return result;</span>
    }

    /**
     * Returns name of associated relation type for given relation.
     *
     * @param relationId  relation id
     *
     * @return the name of the associated relation type.
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RelationNotFoundException  if no relation for given
     * relation id
     */
    public String getRelationTypeName(String relationId)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L2369" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L2370">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2371">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2374">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRelationTypeName&quot;, relationId);

        // Can throw a RelationNotFoundException
<span class="nc" id="L2378">        Object relObj = getRelation(relationId);</span>

        String result;

<span class="nc bnc" id="L2382" title="All 2 branches missed.">        if (relObj instanceof RelationSupport) {</span>
            // Internal relation
<span class="nc" id="L2384">            result = ((RelationSupport)relObj).getRelationTypeName();</span>

        } else {
            // Relation MBean
            // No Exception
            try {
<span class="nc" id="L2390">                result = (String)</span>
<span class="nc" id="L2391">                    (myMBeanServer.getAttribute(((ObjectName)relObj),</span>
                                                &quot;RelationTypeName&quot;));
<span class="nc" id="L2393">            } catch (Exception exc) {</span>
<span class="nc" id="L2394">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2395">            }</span>
        }

<span class="nc" id="L2398">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRelationTypeName&quot;);
<span class="nc" id="L2400">        return result;</span>
    }

    //
    // NotificationListener Interface
    //

    /**
     * Invoked when a JMX notification occurs.
     * Currently handles notifications for unregistration of MBeans, either
     * referenced in a relation role or being a relation itself.
     *
     * @param notif  The notification.
     * @param handback  An opaque object which helps the listener to
     * associate information regarding the MBean emitter (can be null).
     */
    public void handleNotification(Notification notif,
                                   Object handback) {

<span class="nc bnc" id="L2419" title="All 2 branches missed.">        if (notif == null) {</span>
<span class="nc" id="L2420">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2421">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2424">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;handleNotification&quot;, notif);

<span class="nc bnc" id="L2427" title="All 2 branches missed.">        if (notif instanceof MBeanServerNotification) {</span>

<span class="nc" id="L2429">            MBeanServerNotification mbsNtf = (MBeanServerNotification) notif;</span>
<span class="nc" id="L2430">            String ntfType = notif.getType();</span>

<span class="nc bnc" id="L2432" title="All 2 branches missed.">            if (ntfType.equals(</span>
                       MBeanServerNotification.UNREGISTRATION_NOTIFICATION )) {
<span class="nc" id="L2434">                ObjectName mbeanName =</span>
<span class="nc" id="L2435">                    ((MBeanServerNotification)notif).getMBeanName();</span>

                // Note: use a flag to block access to
                // myRefedMBeanObjName2RelIdsMap only for a quick access
<span class="nc" id="L2439">                boolean isRefedMBeanFlag = false;</span>
<span class="nc" id="L2440">                synchronized(myRefedMBeanObjName2RelIdsMap) {</span>

<span class="nc bnc" id="L2442" title="All 2 branches missed.">                    if (myRefedMBeanObjName2RelIdsMap.containsKey(mbeanName)) {</span>
                        // Unregistration of a referenced MBean
<span class="nc" id="L2444">                        synchronized(myUnregNtfList) {</span>
<span class="nc" id="L2445">                            myUnregNtfList.add(mbsNtf);</span>
<span class="nc" id="L2446">                        }</span>
<span class="nc" id="L2447">                        isRefedMBeanFlag = true;</span>
                    }
<span class="nc bnc" id="L2449" title="All 4 branches missed.">                    if (isRefedMBeanFlag &amp;&amp; myPurgeFlag) {</span>
                        // Immediate purge
                        // Can throw RelationServiceNotRegisteredException
                        // but assume that will be fine :)
                        try {
<span class="nc" id="L2454">                            purgeRelations();</span>
<span class="nc" id="L2455">                        } catch (Exception exc) {</span>
<span class="nc" id="L2456">                            throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2457">                        }</span>
                    }
<span class="nc" id="L2459">                }</span>

                // Note: do both tests as a relation can be an MBean and be
                //       itself referenced in another relation :)
                String relId;
<span class="nc" id="L2464">                synchronized(myRelMBeanObjName2RelIdMap){</span>
<span class="nc" id="L2465">                    relId = myRelMBeanObjName2RelIdMap.get(mbeanName);</span>
<span class="nc" id="L2466">                }</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">                if (relId != null) {</span>
                    // Unregistration of a relation MBean
                    // Can throw RelationTypeNotFoundException,
                    // RelationServiceNotRegisteredException
                    //
                    // Shall not throw RelationTypeNotFoundException or
                    // InstanceNotFoundException
                    try {
<span class="nc" id="L2475">                        removeRelation(relId);</span>
<span class="nc" id="L2476">                    } catch (Exception exc) {</span>
<span class="nc" id="L2477">                        throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L2478">                    }</span>
                }
            }
        }

<span class="nc" id="L2483">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;handleNotification&quot;);
<span class="nc" id="L2485">        return;</span>
    }

    //
    // NotificationBroadcaster interface
    //

    /**
     * Returns a NotificationInfo object containing the name of the Java class
     * of the notification and the notification types sent.
     */
    public MBeanNotificationInfo[] getNotificationInfo() {

<span class="nc" id="L2498">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getNotificationInfo&quot;);

<span class="nc" id="L2501">        String ntfClass = &quot;javax.management.relation.RelationNotification&quot;;</span>

<span class="nc" id="L2503">        String[] ntfTypes = new String[] {</span>
            RelationNotification.RELATION_BASIC_CREATION,
            RelationNotification.RELATION_MBEAN_CREATION,
            RelationNotification.RELATION_BASIC_UPDATE,
            RelationNotification.RELATION_MBEAN_UPDATE,
            RelationNotification.RELATION_BASIC_REMOVAL,
            RelationNotification.RELATION_MBEAN_REMOVAL,
        };

<span class="nc" id="L2512">        String ntfDesc = &quot;Sent when a relation is created, updated or deleted.&quot;;</span>

<span class="nc" id="L2514">        MBeanNotificationInfo ntfInfo =</span>
            new MBeanNotificationInfo(ntfTypes, ntfClass, ntfDesc);

<span class="nc" id="L2517">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getNotificationInfo&quot;);
<span class="nc" id="L2519">        return new MBeanNotificationInfo[] {ntfInfo};</span>
    }

    //
    // Misc
    //

    // Adds given object as a relation type.
    //
    // -param relationTypeObj  relation type object
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception InvalidRelationTypeException  if there is already a relation
    //  type with that name
    private void addRelationTypeInt(RelationType relationTypeObj)
        throws IllegalArgumentException,
               InvalidRelationTypeException {

<span class="nc bnc" id="L2537" title="All 2 branches missed.">        if (relationTypeObj == null) {</span>
<span class="nc" id="L2538">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2539">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2542">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;addRelationTypeInt&quot;);

<span class="nc" id="L2545">        String relTypeName = relationTypeObj.getRelationTypeName();</span>

        // Checks that there is not already a relation type with that name
        // existing in the Relation Service
        try {
            // Can throw a RelationTypeNotFoundException (in fact should ;)
<span class="nc" id="L2551">            RelationType relType = getRelationType(relTypeName);</span>

<span class="nc bnc" id="L2553" title="All 2 branches missed.">            if (relType != null) {</span>
<span class="nc" id="L2554">                String excMsg = &quot;There is already a relation type in the Relation Service with name &quot;;</span>
<span class="nc" id="L2555">                StringBuilder excMsgStrB = new StringBuilder(excMsg);</span>
<span class="nc" id="L2556">                excMsgStrB.append(relTypeName);</span>
<span class="nc" id="L2557">                throw new InvalidRelationTypeException(excMsgStrB.toString());</span>
            }

<span class="nc" id="L2560">        } catch (RelationTypeNotFoundException exc) {</span>
            // OK : The RelationType could not be found.
<span class="nc" id="L2562">        }</span>

        // Adds the relation type
<span class="nc" id="L2565">        synchronized(myRelType2ObjMap) {</span>
<span class="nc" id="L2566">            myRelType2ObjMap.put(relTypeName, relationTypeObj);</span>
<span class="nc" id="L2567">        }</span>

<span class="nc bnc" id="L2569" title="All 2 branches missed.">        if (relationTypeObj instanceof RelationTypeSupport) {</span>
<span class="nc" id="L2570">            ((RelationTypeSupport)relationTypeObj).setRelationServiceFlag(true);</span>
        }

<span class="nc" id="L2573">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;addRelationTypeInt&quot;);
<span class="nc" id="L2575">        return;</span>
     }

    // Retrieves relation type with given name
    //
    // -param relationTypeName  expected name of a relation type created in the
    //  Relation Service
    //
    // -return RelationType object corresponding to given name
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationTypeNotFoundException  if no relation type for that
    //  name created in Relation Service
    //
    RelationType getRelationType(String relationTypeName)
        throws IllegalArgumentException,
               RelationTypeNotFoundException {

<span class="nc bnc" id="L2593" title="All 2 branches missed.">        if (relationTypeName == null) {</span>
<span class="nc" id="L2594">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2595">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2598">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRelationType&quot;, relationTypeName);

        // No null relation type accepted, so can use get()
        RelationType relType;
<span class="nc" id="L2603">        synchronized(myRelType2ObjMap) {</span>
<span class="nc" id="L2604">            relType = (myRelType2ObjMap.get(relationTypeName));</span>
<span class="nc" id="L2605">        }</span>

<span class="nc bnc" id="L2607" title="All 2 branches missed.">        if (relType == null) {</span>
<span class="nc" id="L2608">            String excMsg = &quot;No relation type created in the Relation Service with the name &quot;;</span>
<span class="nc" id="L2609">            StringBuilder excMsgStrB = new StringBuilder(excMsg);</span>
<span class="nc" id="L2610">            excMsgStrB.append(relationTypeName);</span>
<span class="nc" id="L2611">            throw new RelationTypeNotFoundException(excMsgStrB.toString());</span>
        }

<span class="nc" id="L2614">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRelationType&quot;);
<span class="nc" id="L2616">        return relType;</span>
    }

    // Retrieves relation corresponding to given relation id.
    // Returns either:
    // - a RelationSupport object if the relation is internal
    // or
    // - the ObjectName of the corresponding MBean
    //
    // -param relationId  expected relation id
    //
    // -return RelationSupport object or ObjectName of relation with given id
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationNotFoundException  if no relation for that
    //  relation id created in Relation Service
    //
    Object getRelation(String relationId)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L2637" title="All 2 branches missed.">        if (relationId == null) {</span>
<span class="nc" id="L2638">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2639">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2642">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;getRelation&quot;, relationId);

        // No null relation  accepted, so can use get()
        Object rel;
<span class="nc" id="L2647">        synchronized(myRelId2ObjMap) {</span>
<span class="nc" id="L2648">            rel = myRelId2ObjMap.get(relationId);</span>
<span class="nc" id="L2649">        }</span>

<span class="nc bnc" id="L2651" title="All 2 branches missed.">        if (rel == null) {</span>
<span class="nc" id="L2652">            String excMsg = &quot;No relation associated to relation id &quot; + relationId;</span>
<span class="nc" id="L2653">            throw new RelationNotFoundException(excMsg);</span>
        }

<span class="nc" id="L2656">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;getRelation&quot;);
<span class="nc" id="L2658">        return rel;</span>
    }

    // Adds a new MBean reference (reference to an ObjectName) in the
    // referenced MBean map (myRefedMBeanObjName2RelIdsMap).
    //
    // -param objectName  ObjectName of new referenced MBean
    // -param relationId  relation id of the relation where the MBean is
    //  referenced
    // -param roleName  name of the role where the MBean is referenced
    //
    // -return boolean:
    //  - true  if the MBean was not referenced before, so really a new
    //    reference
    //  - false else
    //
    // -exception IllegalArgumentException  if null parameter
    private boolean addNewMBeanReference(ObjectName objectName,
                                         String relationId,
                                         String roleName)
        throws IllegalArgumentException {

<span class="nc bnc" id="L2680" title="All 6 branches missed.">        if (objectName == null ||</span>
            relationId == null ||
            roleName == null) {
<span class="nc" id="L2683">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2684">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2687">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;addNewMBeanReference&quot;,
                new Object[] {objectName, relationId, roleName});

<span class="nc" id="L2691">        boolean isNewFlag = false;</span>

<span class="nc" id="L2693">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>

            // Checks if the MBean was already referenced
            // No null value allowed, use get() directly
<span class="nc" id="L2697">            Map&lt;String,List&lt;String&gt;&gt; mbeanRefMap =</span>
<span class="nc" id="L2698">                myRefedMBeanObjName2RelIdsMap.get(objectName);</span>

<span class="nc bnc" id="L2700" title="All 2 branches missed.">            if (mbeanRefMap == null) {</span>
                // MBean not referenced in any relation yet

<span class="nc" id="L2703">                isNewFlag = true;</span>

                // List of roles where the MBean is referenced in given
                // relation
<span class="nc" id="L2707">                List&lt;String&gt; roleNames = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L2708">                roleNames.add(roleName);</span>

                // Map of relations where the MBean is referenced
<span class="nc" id="L2711">                mbeanRefMap = new HashMap&lt;String,List&lt;String&gt;&gt;();</span>
<span class="nc" id="L2712">                mbeanRefMap.put(relationId, roleNames);</span>

<span class="nc" id="L2714">                myRefedMBeanObjName2RelIdsMap.put(objectName, mbeanRefMap);</span>

<span class="nc" id="L2716">            } else {</span>
                // MBean already referenced in at least another relation
                // Checks if already referenced in another role in current
                // relation
<span class="nc" id="L2720">                List&lt;String&gt; roleNames = mbeanRefMap.get(relationId);</span>

<span class="nc bnc" id="L2722" title="All 2 branches missed.">                if (roleNames == null) {</span>
                    // MBean not referenced in current relation

                    // List of roles where the MBean is referenced in given
                    // relation
<span class="nc" id="L2727">                    roleNames = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L2728">                    roleNames.add(roleName);</span>

                    // Adds new reference done in current relation
<span class="nc" id="L2731">                    mbeanRefMap.put(relationId, roleNames);</span>

                } else {
                    // MBean already referenced in current relation in another
                    // role
                    // Adds new reference done
<span class="nc" id="L2737">                    roleNames.add(roleName);</span>
                }
            }
<span class="nc" id="L2740">        }</span>

<span class="nc" id="L2742">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;addNewMBeanReference&quot;);
<span class="nc" id="L2744">        return isNewFlag;</span>
    }

    // Removes an obsolete MBean reference (reference to an ObjectName) in
    // the referenced MBean map (myRefedMBeanObjName2RelIdsMap).
    //
    // -param objectName  ObjectName of MBean no longer referenced
    // -param relationId  relation id of the relation where the MBean was
    //  referenced
    // -param roleName  name of the role where the MBean was referenced
    // -param allRolesFlag  flag, if true removes reference to MBean for all
    //  roles in the relation, not only for the one above
    //
    // -return boolean:
    //  - true  if the MBean is no longer reference in any relation
    //  - false else
    //
    // -exception IllegalArgumentException  if null parameter
    private boolean removeMBeanReference(ObjectName objectName,
                                         String relationId,
                                         String roleName,
                                         boolean allRolesFlag)
        throws IllegalArgumentException {

<span class="nc bnc" id="L2768" title="All 6 branches missed.">        if (objectName == null ||</span>
            relationId == null ||
            roleName == null) {
<span class="nc" id="L2771">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L2772">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L2775">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;removeMBeanReference&quot;,
<span class="nc" id="L2777">                new Object[] {objectName, relationId, roleName, allRolesFlag});</span>

<span class="nc" id="L2779">        boolean noLongerRefFlag = false;</span>

<span class="nc" id="L2781">        synchronized(myRefedMBeanObjName2RelIdsMap) {</span>

            // Retrieves the set of relations (designed via their relation ids)
            // where the MBean is referenced
            // Note that it is possible that the MBean has already been removed
            // from the internal map: this is the case when the MBean is
            // unregistered, the role is updated, then we arrive here.
<span class="nc" id="L2788">            Map&lt;String,List&lt;String&gt;&gt; mbeanRefMap =</span>
<span class="nc" id="L2789">                (myRefedMBeanObjName2RelIdsMap.get(objectName));</span>

<span class="nc bnc" id="L2791" title="All 2 branches missed.">            if (mbeanRefMap == null) {</span>
                // The MBean is no longer referenced
<span class="nc" id="L2793">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;removeMBeanReference&quot;);
<span class="nc" id="L2795">                return true;</span>
            }

<span class="nc" id="L2798">            List&lt;String&gt; roleNames = null;</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            if (!allRolesFlag) {</span>
                // Now retrieves the roles of current relation where the MBean
                // was referenced
<span class="nc" id="L2802">                roleNames = mbeanRefMap.get(relationId);</span>

                // Removes obsolete reference to role
<span class="nc" id="L2805">                int obsRefIdx = roleNames.indexOf(roleName);</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">                if (obsRefIdx != -1) {</span>
<span class="nc" id="L2807">                    roleNames.remove(obsRefIdx);</span>
                }
            }

            // Checks if there is still at least one role in current relation
            // where the MBean is referenced
<span class="nc bnc" id="L2813" title="All 4 branches missed.">            if (roleNames.isEmpty() || allRolesFlag) {</span>
                // MBean no longer referenced in current relation: removes
                // entry
<span class="nc" id="L2816">                mbeanRefMap.remove(relationId);</span>
            }

            // Checks if the MBean is still referenced in at least on relation
<span class="nc bnc" id="L2820" title="All 2 branches missed.">            if (mbeanRefMap.isEmpty()) {</span>
                // MBean no longer referenced in any relation: removes entry
<span class="nc" id="L2822">                myRefedMBeanObjName2RelIdsMap.remove(objectName);</span>
<span class="nc" id="L2823">                noLongerRefFlag = true;</span>
            }
<span class="nc" id="L2825">        }</span>

<span class="nc" id="L2827">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;removeMBeanReference&quot;);
<span class="nc" id="L2829">        return noLongerRefFlag;</span>
    }

    // Updates the listener registered to the MBean Server to be informed of
    // referenced MBean deregistrations
    //
    // -param newRefList  ArrayList of ObjectNames for new references done
    //  to MBeans (can be null)
    // -param obsoleteRefList  ArrayList of ObjectNames for obsolete references
    //  to MBeans (can be null)
    //
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server.
    private void updateUnregistrationListener(List&lt;ObjectName&gt; newRefList,
                                              List&lt;ObjectName&gt; obsoleteRefList)
        throws RelationServiceNotRegisteredException {

<span class="nc bnc" id="L2846" title="All 4 branches missed.">        if (newRefList != null &amp;&amp; obsoleteRefList != null) {</span>
<span class="nc bnc" id="L2847" title="All 4 branches missed.">            if (newRefList.isEmpty() &amp;&amp; obsoleteRefList.isEmpty()) {</span>
                // Nothing to do :)
<span class="nc" id="L2849">                return;</span>
            }
        }

<span class="nc" id="L2853">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;updateUnregistrationListener&quot;,
                new Object[] {newRefList, obsoleteRefList});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L2858">        isActive();</span>

<span class="nc bnc" id="L2860" title="All 4 branches missed.">        if (newRefList != null || obsoleteRefList != null) {</span>

<span class="nc" id="L2862">            boolean newListenerFlag = false;</span>
<span class="nc bnc" id="L2863" title="All 2 branches missed.">            if (myUnregNtfFilter == null) {</span>
                // Initialize it to be able to synchronise it :)
<span class="nc" id="L2865">                myUnregNtfFilter = new MBeanServerNotificationFilter();</span>
<span class="nc" id="L2866">                newListenerFlag = true;</span>
            }

<span class="nc" id="L2869">            synchronized(myUnregNtfFilter) {</span>

                // Enables ObjectNames in newRefList
<span class="nc bnc" id="L2872" title="All 2 branches missed.">                if (newRefList != null) {</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">                    for (ObjectName newObjName : newRefList)</span>
<span class="nc" id="L2874">                        myUnregNtfFilter.enableObjectName(newObjName);</span>
                }

<span class="nc bnc" id="L2877" title="All 2 branches missed.">                if (obsoleteRefList != null) {</span>
                    // Disables ObjectNames in obsoleteRefList
<span class="nc bnc" id="L2879" title="All 2 branches missed.">                    for (ObjectName obsObjName : obsoleteRefList)</span>
<span class="nc" id="L2880">                        myUnregNtfFilter.disableObjectName(obsObjName);</span>
                }

// Under test
<span class="nc bnc" id="L2884" title="All 2 branches missed.">                if (newListenerFlag) {</span>
                    try {
<span class="nc" id="L2886">                        myMBeanServer.addNotificationListener(</span>
                                MBeanServerDelegate.DELEGATE_NAME,
                                this,
                                myUnregNtfFilter,
                                null);
<span class="nc" id="L2891">                    } catch (InstanceNotFoundException exc) {</span>
<span class="nc" id="L2892">                        throw new</span>
<span class="nc" id="L2893">                       RelationServiceNotRegisteredException(exc.getMessage());</span>
<span class="nc" id="L2894">                    }</span>
                }
// End test


//              if (!newListenerFlag) {
                    // The Relation Service was already registered as a
                    // listener:
                    // removes it
                    // Shall not throw InstanceNotFoundException (as the
                    // MBean Server Delegate is expected to exist) or
                    // ListenerNotFoundException (as it has been checked above
                    // that the Relation Service is registered)
//                  try {
//                      myMBeanServer.removeNotificationListener(
//                              MBeanServerDelegate.DELEGATE_NAME,
//                              this);
//                  } catch (InstanceNotFoundException exc1) {
//                      throw new RuntimeException(exc1.getMessage());
//                  } catch (ListenerNotFoundException exc2) {
//                      throw new
//                          RelationServiceNotRegisteredException(exc2.getMessage());
//                  }
//              }

                // Adds Relation Service with current filter
                // Can throw InstanceNotFoundException if the Relation
                // Service is not registered, to be transformed into
                // RelationServiceNotRegisteredException
                //
                // Assume that there will not be any InstanceNotFoundException
                // for the MBean Server Delegate :)
//              try {
//                  myMBeanServer.addNotificationListener(
//                              MBeanServerDelegate.DELEGATE_NAME,
//                              this,
//                              myUnregNtfFilter,
//                              null);
//              } catch (InstanceNotFoundException exc) {
//                  throw new
//                     RelationServiceNotRegisteredException(exc.getMessage());
//              }
<span class="nc" id="L2936">            }</span>
        }

<span class="nc" id="L2939">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;updateUnregistrationListener&quot;);
<span class="nc" id="L2941">        return;</span>
    }

    // Adds a relation (being either a RelationSupport object or an MBean
    // referenced using its ObjectName) in the Relation Service.
    // Will send a notification RelationNotification with type:
    // - RelationNotification.RELATION_BASIC_CREATION for internal relation
    //   creation
    // - RelationNotification.RELATION_MBEAN_CREATION for an MBean being added
    //   as a relation.
    //
    // -param relationBaseFlag  flag true if the relation is a RelationSupport
    //  object, false if it is an MBean
    // -param relationObj  RelationSupport object (if relation is internal)
    // -param relationObjName  ObjectName of the MBean to be added as a relation
    //  (only for the relation MBean)
    // -param relationId  relation identifier, to uniquely identify the relation
    //  inside the Relation Service
    // -param relationTypeName  name of the relation type (has to be created
    //  in the Relation Service)
    // -param roleList  role list to initialize roles of the relation
    //  (can be null)
    //
    // -exception IllegalArgumentException  if null paramater
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RoleNotFoundException  if a value is provided for a role
    //  that does not exist in the relation type
    // -exception InvalidRelationIdException  if relation id already used
    // -exception RelationTypeNotFoundException  if relation type not known in
    //  Relation Service
    // -exception InvalidRoleValueException if:
    //  - the same role name is used for two different roles
    //  - the number of referenced MBeans in given value is less than
    //    expected minimum degree
    //  - the number of referenced MBeans in provided value exceeds expected
    //    maximum degree
    //  - one referenced MBean in the value is not an Object of the MBean
    //    class expected for that role
    //  - an MBean provided for that role does not exist
    private void addRelationInt(boolean relationBaseFlag,
                                RelationSupport relationObj,
                                ObjectName relationObjName,
                                String relationId,
                                String relationTypeName,
                                RoleList roleList)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RoleNotFoundException,
               InvalidRelationIdException,
               RelationTypeNotFoundException,
               InvalidRoleValueException {

<span class="nc bnc" id="L2994" title="All 16 branches missed.">        if (relationId == null ||</span>
            relationTypeName == null ||
            (relationBaseFlag &amp;&amp;
             (relationObj == null ||
              relationObjName != null)) ||
            (!relationBaseFlag &amp;&amp;
             (relationObjName == null ||
              relationObj != null))) {
<span class="nc" id="L3002">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3003">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L3006">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
<span class="nc" id="L3007">                &quot;addRelationInt&quot;, new Object[] {relationBaseFlag, relationObj,</span>
                relationObjName, relationId, relationTypeName, roleList});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L3011">        isActive();</span>

        // Checks if there is already a relation with given id
        try {
            // Can throw a RelationNotFoundException (in fact should :)
<span class="nc" id="L3016">            Object rel = getRelation(relationId);</span>

<span class="nc bnc" id="L3018" title="All 2 branches missed.">            if (rel != null) {</span>
                // There is already a relation with that id
<span class="nc" id="L3020">                String excMsg = &quot;There is already a relation with id &quot;;</span>
<span class="nc" id="L3021">                StringBuilder excMsgStrB = new StringBuilder(excMsg);</span>
<span class="nc" id="L3022">                excMsgStrB.append(relationId);</span>
<span class="nc" id="L3023">                throw new InvalidRelationIdException(excMsgStrB.toString());</span>
            }
<span class="nc" id="L3025">        } catch (RelationNotFoundException exc) {</span>
            // OK : The Relation could not be found.
<span class="nc" id="L3027">        }</span>

        // Retrieves the relation type
        // Can throw RelationTypeNotFoundException
<span class="nc" id="L3031">        RelationType relType = getRelationType(relationTypeName);</span>

        // Checks that each provided role conforms to its role info provided in
        // the relation type
        // First retrieves a local list of the role infos of the relation type
        // to see which roles have not been initialized
        // Note: no need to test if list not null before cloning, not allowed
        //       to have an empty relation type.
<span class="nc" id="L3039">        List&lt;RoleInfo&gt; roleInfoList = new ArrayList&lt;RoleInfo&gt;(relType.getRoleInfos());</span>

<span class="nc bnc" id="L3041" title="All 2 branches missed.">        if (roleList != null) {</span>

<span class="nc bnc" id="L3043" title="All 2 branches missed.">            for (Role currRole : roleList.asList()) {</span>
<span class="nc" id="L3044">                String currRoleName = currRole.getRoleName();</span>
<span class="nc" id="L3045">                List&lt;ObjectName&gt; currRoleValue = currRole.getRoleValue();</span>
                // Retrieves corresponding role info
                // Can throw a RoleInfoNotFoundException to be converted into a
                // RoleNotFoundException
                RoleInfo roleInfo;
                try {
<span class="nc" id="L3051">                    roleInfo = relType.getRoleInfo(currRoleName);</span>
<span class="nc" id="L3052">                } catch (RoleInfoNotFoundException exc) {</span>
<span class="nc" id="L3053">                    throw new RoleNotFoundException(exc.getMessage());</span>
<span class="nc" id="L3054">                }</span>

                // Checks that role conforms to role info,
<span class="nc" id="L3057">                Integer status = checkRoleInt(2,</span>
                                              currRoleName,
                                              currRoleValue,
                                              roleInfo,
                                              false);
<span class="nc" id="L3062">                int pbType = status.intValue();</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                if (pbType != 0) {</span>
                    // A problem has occurred: throws appropriate exception
                    // here InvalidRoleValueException
<span class="nc" id="L3066">                    throwRoleProblemException(pbType, currRoleName);</span>
                }

                // Removes role info for that list from list of role infos for
                // roles to be defaulted
<span class="nc" id="L3071">                int roleInfoIdx = roleInfoList.indexOf(roleInfo);</span>
                // Note: no need to check if != -1, MUST be there :)
<span class="nc" id="L3073">                roleInfoList.remove(roleInfoIdx);</span>
<span class="nc" id="L3074">            }</span>
        }

        // Initializes roles not initialized by roleList
        // Can throw InvalidRoleValueException
<span class="nc" id="L3079">        initializeMissingRoles(relationBaseFlag,</span>
                               relationObj,
                               relationObjName,
                               relationId,
                               relationTypeName,
                               roleInfoList);

        // Creation of relation successfull!!!!

        // Updates internal maps
        // Relation id to object map
<span class="nc" id="L3090">        synchronized(myRelId2ObjMap) {</span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">            if (relationBaseFlag) {</span>
                // Note: do not clone relation object, created by us :)
<span class="nc" id="L3093">                myRelId2ObjMap.put(relationId, relationObj);</span>
            } else {
<span class="nc" id="L3095">                myRelId2ObjMap.put(relationId, relationObjName);</span>
            }
<span class="nc" id="L3097">        }</span>

        // Relation id to relation type name map
<span class="nc" id="L3100">        synchronized(myRelId2RelTypeMap) {</span>
<span class="nc" id="L3101">            myRelId2RelTypeMap.put(relationId,</span>
                                   relationTypeName);
<span class="nc" id="L3103">        }</span>

        // Relation type to relation id map
<span class="nc" id="L3106">        synchronized(myRelType2RelIdsMap) {</span>
<span class="nc" id="L3107">            List&lt;String&gt; relIdList =</span>
<span class="nc" id="L3108">                myRelType2RelIdsMap.get(relationTypeName);</span>
<span class="nc" id="L3109">            boolean firstRelFlag = false;</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">            if (relIdList == null) {</span>
<span class="nc" id="L3111">                firstRelFlag = true;</span>
<span class="nc" id="L3112">                relIdList = new ArrayList&lt;String&gt;();</span>
            }
<span class="nc" id="L3114">            relIdList.add(relationId);</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">            if (firstRelFlag) {</span>
<span class="nc" id="L3116">                myRelType2RelIdsMap.put(relationTypeName, relIdList);</span>
            }
<span class="nc" id="L3118">        }</span>

        // Referenced MBean to relation id map
        // Only role list parameter used, as default initialization of roles
        // done automatically in initializeMissingRoles() sets each
        // uninitialized role to an empty value.
<span class="nc bnc" id="L3124" title="All 2 branches missed.">        for (Role currRole : roleList.asList()) {</span>
            // Creates a dummy empty ArrayList of ObjectNames to be the old
            // role value :)
<span class="nc" id="L3127">            List&lt;ObjectName&gt; dummyList = new ArrayList&lt;ObjectName&gt;();</span>
            // Will not throw a RelationNotFoundException (as the RelId2Obj map
            // has been updated above) so catch it :)
            try {
<span class="nc" id="L3131">                updateRoleMap(relationId, currRole, dummyList);</span>

<span class="nc" id="L3133">            } catch (RelationNotFoundException exc) {</span>
                // OK : The Relation could not be found.
<span class="nc" id="L3135">            }</span>
<span class="nc" id="L3136">        }</span>

        // Sends a notification for relation creation
        // Will not throw RelationNotFoundException so catch it :)
        try {
<span class="nc" id="L3141">            sendRelationCreationNotification(relationId);</span>

<span class="nc" id="L3143">        } catch (RelationNotFoundException exc) {</span>
            // OK : The Relation could not be found.
<span class="nc" id="L3145">        }</span>

<span class="nc" id="L3147">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;addRelationInt&quot;);
<span class="nc" id="L3149">        return;</span>
    }

    // Checks that given role conforms to given role info.
    //
    // -param chkType  type of check:
    //  - 1: read, just check read access
    //  - 2: write, check value and write access if writeChkFlag
    // -param roleName  role name
    // -param roleValue  role value
    // -param roleInfo  corresponding role info
    // -param writeChkFlag  boolean to specify a current write access and
    //  to check it
    //
    // -return Integer with value:
    //  - 0: ok
    //  - RoleStatus.NO_ROLE_WITH_NAME
    //  - RoleStatus.ROLE_NOT_READABLE
    //  - RoleStatus.ROLE_NOT_WRITABLE
    //  - RoleStatus.LESS_THAN_MIN_ROLE_DEGREE
    //  - RoleStatus.MORE_THAN_MAX_ROLE_DEGREE
    //  - RoleStatus.REF_MBEAN_OF_INCORRECT_CLASS
    //  - RoleStatus.REF_MBEAN_NOT_REGISTERED
    //
    // -exception IllegalArgumentException  if null parameter
    private Integer checkRoleInt(int chkType,
                                 String roleName,
                                 List&lt;ObjectName&gt; roleValue,
                                 RoleInfo roleInfo,
                                 boolean writeChkFlag)
        throws IllegalArgumentException {

<span class="nc bnc" id="L3181" title="All 8 branches missed.">        if (roleName == null ||</span>
            roleInfo == null ||
            (chkType == 2 &amp;&amp; roleValue == null)) {
<span class="nc" id="L3184">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3185">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L3188">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
<span class="nc" id="L3189">                &quot;checkRoleInt&quot;, new Object[] {chkType, roleName,</span>
<span class="nc" id="L3190">                roleValue, roleInfo, writeChkFlag});</span>

        // Compares names
<span class="nc" id="L3193">        String expName = roleInfo.getName();</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">        if (!(roleName.equals(expName))) {</span>
<span class="nc" id="L3195">            RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                    &quot;checkRoleInt&quot;);
<span class="nc" id="L3197">            return Integer.valueOf(RoleStatus.NO_ROLE_WITH_NAME);</span>
        }

        // Checks read access if required
<span class="nc bnc" id="L3201" title="All 2 branches missed.">        if (chkType == 1) {</span>
<span class="nc" id="L3202">            boolean isReadable = roleInfo.isReadable();</span>
<span class="nc bnc" id="L3203" title="All 2 branches missed.">            if (!isReadable) {</span>
<span class="nc" id="L3204">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;checkRoleInt&quot;);
<span class="nc" id="L3206">                return Integer.valueOf(RoleStatus.ROLE_NOT_READABLE);</span>
            } else {
                // End of check :)
<span class="nc" id="L3209">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;checkRoleInt&quot;);
<span class="nc" id="L3211">                return new Integer(0);</span>
            }
        }

        // Checks write access if required
<span class="nc bnc" id="L3216" title="All 2 branches missed.">        if (writeChkFlag) {</span>
<span class="nc" id="L3217">            boolean isWritable = roleInfo.isWritable();</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">            if (!isWritable) {</span>
<span class="nc" id="L3219">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;checkRoleInt&quot;);
<span class="nc" id="L3221">                return new Integer(RoleStatus.ROLE_NOT_WRITABLE);</span>
            }
        }

<span class="nc" id="L3225">        int refNbr = roleValue.size();</span>

        // Checks minimum cardinality
<span class="nc" id="L3228">        boolean chkMinFlag = roleInfo.checkMinDegree(refNbr);</span>
<span class="nc bnc" id="L3229" title="All 2 branches missed.">        if (!chkMinFlag) {</span>
<span class="nc" id="L3230">            RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                    &quot;checkRoleInt&quot;);
<span class="nc" id="L3232">            return new Integer(RoleStatus.LESS_THAN_MIN_ROLE_DEGREE);</span>
        }

        // Checks maximum cardinality
<span class="nc" id="L3236">        boolean chkMaxFlag = roleInfo.checkMaxDegree(refNbr);</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">        if (!chkMaxFlag) {</span>
<span class="nc" id="L3238">            RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                    &quot;checkRoleInt&quot;);
<span class="nc" id="L3240">            return new Integer(RoleStatus.MORE_THAN_MAX_ROLE_DEGREE);</span>
        }

        // Verifies that each referenced MBean is registered in the MBean
        // Server and that it is an instance of the class specified in the
        // role info, or of a subclass of it
        // Note that here again this is under the assumption that
        // referenced MBeans, relation MBeans and the Relation Service are
        // registered in the same MBean Server.
<span class="nc" id="L3249">        String expClassName = roleInfo.getRefMBeanClassName();</span>

<span class="nc bnc" id="L3251" title="All 2 branches missed.">        for (ObjectName currObjName : roleValue) {</span>

            // Checks it is registered
<span class="nc bnc" id="L3254" title="All 2 branches missed.">            if (currObjName == null) {</span>
<span class="nc" id="L3255">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;checkRoleInt&quot;);
<span class="nc" id="L3257">                return new Integer(RoleStatus.REF_MBEAN_NOT_REGISTERED);</span>
            }

            // Checks if it is of the correct class
            // Can throw an InstanceNotFoundException, if MBean not registered
            try {
<span class="nc" id="L3263">                boolean classSts = myMBeanServer.isInstanceOf(currObjName,</span>
                                                              expClassName);
<span class="nc bnc" id="L3265" title="All 2 branches missed.">                if (!classSts) {</span>
<span class="nc" id="L3266">                    RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                            &quot;checkRoleInt&quot;);
<span class="nc" id="L3268">                    return new Integer(RoleStatus.REF_MBEAN_OF_INCORRECT_CLASS);</span>
                }

<span class="nc" id="L3271">            } catch (InstanceNotFoundException exc) {</span>
<span class="nc" id="L3272">                RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                        &quot;checkRoleInt&quot;);
<span class="nc" id="L3274">                return new Integer(RoleStatus.REF_MBEAN_NOT_REGISTERED);</span>
<span class="nc" id="L3275">            }</span>
<span class="nc" id="L3276">        }</span>

<span class="nc" id="L3278">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;checkRoleInt&quot;);
<span class="nc" id="L3280">        return new Integer(0);</span>
    }


    // Initializes roles associated to given role infos to default value (empty
    // ArrayList of ObjectNames) in given relation.
    // It will succeed for every role except if the role info has a minimum
    // cardinality greater than 0. In that case, an InvalidRoleValueException
    // will be raised.
    //
    // -param relationBaseFlag  flag true if the relation is a RelationSupport
    //  object, false if it is an MBean
    // -param relationObj  RelationSupport object (if relation is internal)
    // -param relationObjName  ObjectName of the MBean to be added as a relation
    //  (only for the relation MBean)
    // -param relationId  relation id
    // -param relationTypeName  name of the relation type (has to be created
    //  in the Relation Service)
    // -param roleInfoList  list of role infos for roles to be defaulted
    //
    // -exception IllegalArgumentException  if null paramater
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception InvalidRoleValueException  if role must have a non-empty
    //  value

    // Revisit [cebro] Handle CIM qualifiers as REQUIRED to detect roles which
    //    should have been initialized by the user
    private void initializeMissingRoles(boolean relationBaseFlag,
                                        RelationSupport relationObj,
                                        ObjectName relationObjName,
                                        String relationId,
                                        String relationTypeName,
                                        List&lt;RoleInfo&gt; roleInfoList)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               InvalidRoleValueException {

<span class="nc bnc" id="L3318" title="All 18 branches missed.">        if ((relationBaseFlag &amp;&amp;</span>
             (relationObj == null ||
              relationObjName != null)) ||
            (!relationBaseFlag &amp;&amp;
             (relationObjName == null ||
              relationObj != null)) ||
            relationId == null ||
            relationTypeName == null ||
            roleInfoList == null) {
<span class="nc" id="L3327">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3328">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L3331">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
<span class="nc" id="L3332">                &quot;initializeMissingRoles&quot;, new Object[] {relationBaseFlag,</span>
                relationObj, relationObjName, relationId, relationTypeName,
                roleInfoList});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L3337">        isActive();</span>

        // For each role info (corresponding to a role not initialized by the
        // role list provided by the user), try to set in the relation a role
        // with an empty list of ObjectNames.
        // A check is performed to verify that the role can be set to an
        // empty value, according to its minimum cardinality
<span class="nc bnc" id="L3344" title="All 2 branches missed.">        for (RoleInfo currRoleInfo : roleInfoList) {</span>

<span class="nc" id="L3346">            String roleName = currRoleInfo.getName();</span>

            // Creates an empty value
<span class="nc" id="L3349">            List&lt;ObjectName&gt; emptyValue = new ArrayList&lt;ObjectName&gt;();</span>
            // Creates a role
<span class="nc" id="L3351">            Role role = new Role(roleName, emptyValue);</span>

<span class="nc bnc" id="L3353" title="All 2 branches missed.">            if (relationBaseFlag) {</span>

                // Internal relation
                // Can throw InvalidRoleValueException
                //
                // Will not throw RoleNotFoundException (role to be
                // initialized), or RelationNotFoundException, or
                // RelationTypeNotFoundException
                try {
<span class="nc" id="L3362">                    relationObj.setRoleInt(role, true, this, false);</span>

<span class="nc" id="L3364">                } catch (RoleNotFoundException exc1) {</span>
<span class="nc" id="L3365">                    throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L3366">                } catch (RelationNotFoundException exc2) {</span>
<span class="nc" id="L3367">                    throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L3368">                } catch (RelationTypeNotFoundException exc3) {</span>
<span class="nc" id="L3369">                    throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L3370">                }</span>

            } else {

                // Relation is an MBean
                // Use standard setRole()
<span class="nc" id="L3376">                Object[] params = new Object[1];</span>
<span class="nc" id="L3377">                params[0] = role;</span>
<span class="nc" id="L3378">                String[] signature = new String[1];</span>
<span class="nc" id="L3379">                signature[0] = &quot;javax.management.relation.Role&quot;;</span>
                // Can throw MBeanException wrapping
                // InvalidRoleValueException. Returns the target exception to
                // be homogeneous.
                //
                // Will not throw MBeanException (wrapping
                // RoleNotFoundException or MBeanException) or
                // InstanceNotFoundException, or ReflectionException
                //
                // Again here the assumption is that the Relation Service and
                // the relation MBeans are registered in the same MBean Server.
                try {
<span class="nc" id="L3391">                    myMBeanServer.setAttribute(relationObjName,</span>
                                               new Attribute(&quot;Role&quot;, role));

<span class="nc" id="L3394">                } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L3395">                    throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L3396">                } catch (ReflectionException exc3) {</span>
<span class="nc" id="L3397">                    throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L3398">                } catch (MBeanException exc2) {</span>
<span class="nc" id="L3399">                    Exception wrappedExc = exc2.getTargetException();</span>
<span class="nc bnc" id="L3400" title="All 2 branches missed.">                    if (wrappedExc instanceof InvalidRoleValueException) {</span>
<span class="nc" id="L3401">                        throw ((InvalidRoleValueException)wrappedExc);</span>
                    } else {
<span class="nc" id="L3403">                        throw new RuntimeException(wrappedExc.getMessage());</span>
                    }
<span class="nc" id="L3405">                } catch (AttributeNotFoundException exc4) {</span>
<span class="nc" id="L3406">                  throw new RuntimeException(exc4.getMessage());</span>
<span class="nc" id="L3407">                } catch (InvalidAttributeValueException exc5) {</span>
<span class="nc" id="L3408">                  throw new RuntimeException(exc5.getMessage());</span>
<span class="nc" id="L3409">                }</span>
            }
<span class="nc" id="L3411">        }</span>

<span class="nc" id="L3413">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;initializeMissingRoles&quot;);
<span class="nc" id="L3415">        return;</span>
    }

    // Throws an exception corresponding to a given problem type
    //
    // -param pbType  possible problem, defined in RoleUnresolved
    // -param roleName  role name
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RoleNotFoundException  for problems:
    //  - NO_ROLE_WITH_NAME
    //  - ROLE_NOT_READABLE
    //  - ROLE_NOT_WRITABLE
    // -exception InvalidRoleValueException  for problems:
    //  - LESS_THAN_MIN_ROLE_DEGREE
    //  - MORE_THAN_MAX_ROLE_DEGREE
    //  - REF_MBEAN_OF_INCORRECT_CLASS
    //  - REF_MBEAN_NOT_REGISTERED
    static void throwRoleProblemException(int pbType,
                                          String roleName)
        throws IllegalArgumentException,
               RoleNotFoundException,
               InvalidRoleValueException {

<span class="nc bnc" id="L3439" title="All 2 branches missed.">        if (roleName == null) {</span>
<span class="nc" id="L3440">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3441">            throw new IllegalArgumentException(excMsg);</span>
        }

        // Exception type: 1 = RoleNotFoundException
        //                 2 = InvalidRoleValueException
<span class="nc" id="L3446">        int excType = 0;</span>

<span class="nc" id="L3448">        String excMsgPart = null;</span>

<span class="nc bnc" id="L3450" title="All 8 branches missed.">        switch (pbType) {</span>
        case RoleStatus.NO_ROLE_WITH_NAME:
<span class="nc" id="L3452">            excMsgPart = &quot; does not exist in relation.&quot;;</span>
<span class="nc" id="L3453">            excType = 1;</span>
<span class="nc" id="L3454">            break;</span>
        case RoleStatus.ROLE_NOT_READABLE:
<span class="nc" id="L3456">            excMsgPart = &quot; is not readable.&quot;;</span>
<span class="nc" id="L3457">            excType = 1;</span>
<span class="nc" id="L3458">            break;</span>
        case RoleStatus.ROLE_NOT_WRITABLE:
<span class="nc" id="L3460">            excMsgPart = &quot; is not writable.&quot;;</span>
<span class="nc" id="L3461">            excType = 1;</span>
<span class="nc" id="L3462">            break;</span>
        case RoleStatus.LESS_THAN_MIN_ROLE_DEGREE:
<span class="nc" id="L3464">            excMsgPart = &quot; has a number of MBean references less than the expected minimum degree.&quot;;</span>
<span class="nc" id="L3465">            excType = 2;</span>
<span class="nc" id="L3466">            break;</span>
        case RoleStatus.MORE_THAN_MAX_ROLE_DEGREE:
<span class="nc" id="L3468">            excMsgPart = &quot; has a number of MBean references greater than the expected maximum degree.&quot;;</span>
<span class="nc" id="L3469">            excType = 2;</span>
<span class="nc" id="L3470">            break;</span>
        case RoleStatus.REF_MBEAN_OF_INCORRECT_CLASS:
<span class="nc" id="L3472">            excMsgPart = &quot; has an MBean reference to an MBean not of the expected class of references for that role.&quot;;</span>
<span class="nc" id="L3473">            excType = 2;</span>
<span class="nc" id="L3474">            break;</span>
        case RoleStatus.REF_MBEAN_NOT_REGISTERED:
<span class="nc" id="L3476">            excMsgPart = &quot; has a reference to null or to an MBean not registered.&quot;;</span>
<span class="nc" id="L3477">            excType = 2;</span>
            break;
        }
        // No default as we must have been in one of those cases

<span class="nc" id="L3482">        StringBuilder excMsgStrB = new StringBuilder(roleName);</span>
<span class="nc" id="L3483">        excMsgStrB.append(excMsgPart);</span>
<span class="nc" id="L3484">        String excMsg = excMsgStrB.toString();</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">        if (excType == 1) {</span>
<span class="nc" id="L3486">            throw new RoleNotFoundException(excMsg);</span>

<span class="nc bnc" id="L3488" title="All 2 branches missed.">        } else if (excType == 2) {</span>
<span class="nc" id="L3489">            throw new InvalidRoleValueException(excMsg);</span>
        }
<span class="nc" id="L3491">    }</span>

    // Sends a notification of given type, with given parameters
    //
    // -param intNtfType  integer to represent notification type:
    //  - 1 : create
    //  - 2 : update
    //  - 3 : delete
    // -param message  human-readable message
    // -param relationId  relation id of the created/updated/deleted relation
    // -param unregMBeanList  list of ObjectNames of referenced MBeans
    //  expected to be unregistered due to relation removal (only for removal,
    //  due to CIM qualifiers, can be null)
    // -param roleName  role name
    // -param roleNewValue  role new value (ArrayList of ObjectNames)
    // -param oldValue  old role value (ArrayList of ObjectNames)
    //
    // -exception IllegalArgument  if null parameter
    // -exception RelationNotFoundException  if no relation for given id
    private void sendNotificationInt(int intNtfType,
                                     String message,
                                     String relationId,
                                     List&lt;ObjectName&gt; unregMBeanList,
                                     String roleName,
                                     List&lt;ObjectName&gt; roleNewValue,
                                     List&lt;ObjectName&gt; oldValue)
        throws IllegalArgumentException,
               RelationNotFoundException {

<span class="nc bnc" id="L3520" title="All 16 branches missed.">        if (message == null ||</span>
            relationId == null ||
            (intNtfType != 3 &amp;&amp; unregMBeanList != null) ||
            (intNtfType == 2 &amp;&amp;
             (roleName == null ||
              roleNewValue == null ||
              oldValue == null))) {
<span class="nc" id="L3527">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3528">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L3531">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
<span class="nc" id="L3532">                &quot;sendNotificationInt&quot;, new Object[] {intNtfType, message,</span>
                relationId, unregMBeanList, roleName, roleNewValue, oldValue});

        // Relation type name
        // Note: do not use getRelationTypeName() as if it is a relation MBean
        //       it is already unregistered.
        String relTypeName;
<span class="nc" id="L3539">        synchronized(myRelId2RelTypeMap) {</span>
<span class="nc" id="L3540">            relTypeName = (myRelId2RelTypeMap.get(relationId));</span>
<span class="nc" id="L3541">        }</span>

        // ObjectName (for a relation MBean)
        // Can also throw a RelationNotFoundException, but detected above
<span class="nc" id="L3545">        ObjectName relObjName = isRelationMBean(relationId);</span>

<span class="nc" id="L3547">        String ntfType = null;</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">        if (relObjName != null) {</span>
<span class="nc bnc" id="L3549" title="All 4 branches missed.">            switch (intNtfType) {</span>
            case 1:
<span class="nc" id="L3551">                ntfType = RelationNotification.RELATION_MBEAN_CREATION;</span>
<span class="nc" id="L3552">                break;</span>
            case 2:
<span class="nc" id="L3554">                ntfType = RelationNotification.RELATION_MBEAN_UPDATE;</span>
<span class="nc" id="L3555">                break;</span>
            case 3:
<span class="nc" id="L3557">                ntfType = RelationNotification.RELATION_MBEAN_REMOVAL;</span>
<span class="nc" id="L3558">                break;</span>
            }
        } else {
<span class="nc bnc" id="L3561" title="All 4 branches missed.">            switch (intNtfType) {</span>
            case 1:
<span class="nc" id="L3563">                ntfType = RelationNotification.RELATION_BASIC_CREATION;</span>
<span class="nc" id="L3564">                break;</span>
            case 2:
<span class="nc" id="L3566">                ntfType = RelationNotification.RELATION_BASIC_UPDATE;</span>
<span class="nc" id="L3567">                break;</span>
            case 3:
<span class="nc" id="L3569">                ntfType = RelationNotification.RELATION_BASIC_REMOVAL;</span>
                break;
            }
        }

        // Sequence number
<span class="nc" id="L3575">        Long seqNo = atomicSeqNo.incrementAndGet();</span>

        // Timestamp
<span class="nc" id="L3578">        Date currDate = new Date();</span>
<span class="nc" id="L3579">        long timeStamp = currDate.getTime();</span>

<span class="nc" id="L3581">        RelationNotification ntf = null;</span>

<span class="nc bnc" id="L3583" title="All 2 branches missed.">        if (ntfType.equals(RelationNotification.RELATION_BASIC_CREATION) ||</span>
<span class="nc bnc" id="L3584" title="All 2 branches missed.">            ntfType.equals(RelationNotification.RELATION_MBEAN_CREATION) ||</span>
<span class="nc bnc" id="L3585" title="All 2 branches missed.">            ntfType.equals(RelationNotification.RELATION_BASIC_REMOVAL) ||</span>
<span class="nc bnc" id="L3586" title="All 2 branches missed.">            ntfType.equals(RelationNotification.RELATION_MBEAN_REMOVAL))</span>

            // Creation or removal
<span class="nc" id="L3589">            ntf = new RelationNotification(ntfType,</span>
                                           this,
<span class="nc" id="L3591">                                           seqNo.longValue(),</span>
                                           timeStamp,
                                           message,
                                           relationId,
                                           relTypeName,
                                           relObjName,
                                           unregMBeanList);

<span class="nc bnc" id="L3599" title="All 2 branches missed.">        else if (ntfType.equals(RelationNotification.RELATION_BASIC_UPDATE)</span>
                 ||
<span class="nc bnc" id="L3601" title="All 2 branches missed.">                 ntfType.equals(RelationNotification.RELATION_MBEAN_UPDATE))</span>
            {
                // Update
<span class="nc" id="L3604">                ntf = new RelationNotification(ntfType,</span>
                                               this,
<span class="nc" id="L3606">                                               seqNo.longValue(),</span>
                                               timeStamp,
                                               message,
                                               relationId,
                                               relTypeName,
                                               relObjName,
                                               roleName,
                                               roleNewValue,
                                               oldValue);
            }

<span class="nc" id="L3617">        sendNotification(ntf);</span>

<span class="nc" id="L3619">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;sendNotificationInt&quot;);
<span class="nc" id="L3621">        return;</span>
    }

    // Checks, for the unregistration of an MBean referenced in the roles given
    // in parameter, if the relation has to be removed or not, regarding
    // expected minimum role cardinality and current number of
    // references in each role after removal of the current one.
    // If the relation is kept, calls handleMBeanUnregistration() callback of
    // the relation to update it.
    //
    // -param relationId  relation id
    // -param objectName  ObjectName of the unregistered MBean
    // -param roleNameList  list of names of roles where the unregistered
    //  MBean is referenced.
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationNotFoundException  if unknown relation id
    // -exception RoleNotFoundException  if one role given as parameter does
    //  not exist in the relation
    private void handleReferenceUnregistration(String relationId,
                                               ObjectName objectName,
                                               List&lt;String&gt; roleNameList)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationNotFoundException,
               RoleNotFoundException {

<span class="nc bnc" id="L3650" title="All 6 branches missed.">        if (relationId == null ||</span>
            roleNameList == null ||
            objectName == null) {
<span class="nc" id="L3653">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L3654">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L3657">        RELATION_LOGGER.entering(RelationService.class.getName(),</span>
                &quot;handleReferenceUnregistration&quot;,
                new Object[] {relationId, objectName, roleNameList});

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L3662">        isActive();</span>

        // Retrieves the relation type name of the relation
        // Can throw RelationNotFoundException
<span class="nc" id="L3666">        String currRelTypeName = getRelationTypeName(relationId);</span>

        // Retrieves the relation
        // Can throw RelationNotFoundException, but already detected above
<span class="nc" id="L3670">        Object relObj = getRelation(relationId);</span>

        // Flag to specify if the relation has to be deleted
<span class="nc" id="L3673">        boolean deleteRelFlag = false;</span>

<span class="nc bnc" id="L3675" title="All 2 branches missed.">        for (String currRoleName : roleNameList) {</span>

<span class="nc bnc" id="L3677" title="All 2 branches missed.">            if (deleteRelFlag) {</span>
<span class="nc" id="L3678">                break;</span>
            }

            // Retrieves number of MBeans currently referenced in role
            // BEWARE! Do not use getRole() as role may be not readable
            //
            // Can throw RelationNotFoundException (but already checked),
            // RoleNotFoundException
<span class="nc" id="L3686">            int currRoleRefNbr =</span>
<span class="nc" id="L3687">                (getRoleCardinality(relationId, currRoleName)).intValue();</span>

            // Retrieves new number of element in role
<span class="nc" id="L3690">            int currRoleNewRefNbr = currRoleRefNbr - 1;</span>

            // Retrieves role info for that role
            //
            // Shall not throw RelationTypeNotFoundException or
            // RoleInfoNotFoundException
            RoleInfo currRoleInfo;
            try {
<span class="nc" id="L3698">                currRoleInfo = getRoleInfo(currRelTypeName,</span>
                                           currRoleName);
<span class="nc" id="L3700">            } catch (RelationTypeNotFoundException exc1) {</span>
<span class="nc" id="L3701">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L3702">            } catch (RoleInfoNotFoundException exc2) {</span>
<span class="nc" id="L3703">                throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L3704">            }</span>

            // Checks with expected minimum number of elements
<span class="nc" id="L3707">            boolean chkMinFlag = currRoleInfo.checkMinDegree(currRoleNewRefNbr);</span>

<span class="nc bnc" id="L3709" title="All 2 branches missed.">            if (!chkMinFlag) {</span>
                // The relation has to be deleted
<span class="nc" id="L3711">                deleteRelFlag = true;</span>
            }
<span class="nc" id="L3713">        }</span>

<span class="nc bnc" id="L3715" title="All 2 branches missed.">        if (deleteRelFlag) {</span>
            // Removes the relation
<span class="nc" id="L3717">            removeRelation(relationId);</span>

        } else {

            // Updates each role in the relation using
            // handleMBeanUnregistration() callback
            //
            // BEWARE: this roleNameList list MUST BE A COPY of a role name
            //         list for a referenced MBean in a relation, NOT a
            //         reference to an original one part of the
            //         myRefedMBeanObjName2RelIdsMap!!!! Because each role
            //         which name is in that list will be updated (potentially
            //         using setRole(). So the Relation Service will update the
            //         myRefedMBeanObjName2RelIdsMap to refelect the new role
            //         value!
<span class="nc bnc" id="L3732" title="All 2 branches missed.">            for (String currRoleName : roleNameList) {</span>

<span class="nc bnc" id="L3734" title="All 2 branches missed.">                if (relObj instanceof RelationSupport) {</span>
                    // Internal relation
                    // Can throw RoleNotFoundException (but already checked)
                    //
                    // Shall not throw
                    // RelationTypeNotFoundException,
                    // InvalidRoleValueException (value was correct, removing
                    // one reference shall not invalidate it, else detected
                    // above)
                    try {
<span class="nc" id="L3744">                        ((RelationSupport)relObj).handleMBeanUnregistrationInt(</span>
                                                  objectName,
                                                  currRoleName,
                                                  true,
                                                  this);
<span class="nc" id="L3749">                    } catch (RelationTypeNotFoundException exc3) {</span>
<span class="nc" id="L3750">                        throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L3751">                    } catch (InvalidRoleValueException exc4) {</span>
<span class="nc" id="L3752">                        throw new RuntimeException(exc4.getMessage());</span>
<span class="nc" id="L3753">                    }</span>

                } else {
                    // Relation MBean
<span class="nc" id="L3757">                    Object[] params = new Object[2];</span>
<span class="nc" id="L3758">                    params[0] = objectName;</span>
<span class="nc" id="L3759">                    params[1] = currRoleName;</span>
<span class="nc" id="L3760">                    String[] signature = new String[2];</span>
<span class="nc" id="L3761">                    signature[0] = &quot;javax.management.ObjectName&quot;;</span>
<span class="nc" id="L3762">                    signature[1] = &quot;java.lang.String&quot;;</span>
                    // Shall not throw InstanceNotFoundException, or
                    // MBeanException (wrapping RoleNotFoundException or
                    // MBeanException or InvalidRoleValueException) or
                    // ReflectionException
                    try {
<span class="nc" id="L3768">                        myMBeanServer.invoke(((ObjectName)relObj),</span>
                                             &quot;handleMBeanUnregistration&quot;,
                                             params,
                                             signature);
<span class="nc" id="L3772">                    } catch (InstanceNotFoundException exc1) {</span>
<span class="nc" id="L3773">                        throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L3774">                    } catch (ReflectionException exc3) {</span>
<span class="nc" id="L3775">                        throw new RuntimeException(exc3.getMessage());</span>
<span class="nc" id="L3776">                    } catch (MBeanException exc2) {</span>
<span class="nc" id="L3777">                        Exception wrappedExc = exc2.getTargetException();</span>
<span class="nc" id="L3778">                        throw new RuntimeException(wrappedExc.getMessage());</span>
<span class="nc" id="L3779">                    }</span>

                }
<span class="nc" id="L3782">            }</span>
        }

<span class="nc" id="L3785">        RELATION_LOGGER.exiting(RelationService.class.getName(),</span>
                &quot;handleReferenceUnregistration&quot;);
<span class="nc" id="L3787">        return;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>