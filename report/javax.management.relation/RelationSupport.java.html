<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RelationSupport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.management.relation</a> &gt; <span class="el_source">RelationSupport.java</span></div><h1>RelationSupport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.management.relation;



import java.util.ArrayList;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.List;

import java.util.concurrent.atomic.AtomicBoolean;
import static com.sun.jmx.defaults.JmxProperties.RELATION_LOGGER;
import static com.sun.jmx.mbeanserver.Util.cast;
import javax.management.InstanceNotFoundException;
import javax.management.MBeanException;
import javax.management.MBeanRegistration;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.ReflectionException;

/**
 * A RelationSupport object is used internally by the Relation Service to
 * represent simple relations (only roles, no properties or methods), with an
 * unlimited number of roles, of any relation type. As internal representation,
 * it is not exposed to the user.
 * &lt;P&gt;RelationSupport class conforms to the design patterns of standard MBean. So
 * the user can decide to instantiate a RelationSupport object himself as
 * a MBean (as it follows the MBean design patterns), to register it in the
 * MBean Server, and then to add it in the Relation Service.
 * &lt;P&gt;The user can also, when creating his own MBean relation class, have it
 * extending RelationSupport, to retrieve the implementations of required
 * interfaces (see below).
 * &lt;P&gt;It is also possible to have in a user relation MBean class a member
 * being a RelationSupport object, and to implement the required interfaces by
 * delegating all to this member.
 * &lt;P&gt; RelationSupport implements the Relation interface (to be handled by the
 * Relation Service).
 * &lt;P&gt;It implements also the MBeanRegistration interface to be able to retrieve
 * the MBean Server where it is registered (if registered as a MBean) to access
 * to its Relation Service.
 *
 * @since 1.5
 */
public class RelationSupport
    implements RelationSupportMBean, MBeanRegistration {

    //
    // Private members
    //

    // Relation identifier (expected to be unique in the Relation Service where
    // the RelationSupport object will be added)
<span class="nc" id="L79">    private String myRelId = null;</span>

    // ObjectName of the Relation Service where the relation will be added
    // REQUIRED if the RelationSupport is created by the user to be registered as
    // a MBean, as it will have to access the Relation Service via the MBean
    // Server to perform the check regarding the relation type.
    // Is null if current object is directly created by the Relation Service,
    // as the object will directly access it.
<span class="nc" id="L87">    private ObjectName myRelServiceName = null;</span>

    // Reference to the MBean Server where the Relation Service is
    // registered
    // REQUIRED if the RelationSupport is created by the user to be registered as
    // a MBean, as it will have to access the Relation Service via the MBean
    // Server to perform the check regarding the relation type.
    // If the Relationbase object is created by the Relation Service (use of
    // createRelation() method), this is null as not needed, direct access to
    // the Relation Service.
    // If the Relationbase object is created by the user and registered as a
    // MBean, this is set by the preRegister() method below.
<span class="nc" id="L99">    private MBeanServer myRelServiceMBeanServer = null;</span>

    // Relation type name (must be known in the Relation Service where the
    // relation will be added)
<span class="nc" id="L103">    private String myRelTypeName = null;</span>

    // Role map, mapping &lt;role-name&gt; -&gt; &lt;Role&gt;
    // Initialized by role list in the constructor, then updated:
    // - if the relation is a MBean, via setRole() and setRoles() methods, or
    //   via Relation Service setRole() and setRoles() methods
    // - if the relation is internal to the Relation Service, via
    //   setRoleInt() and setRolesInt() methods.
<span class="nc" id="L111">    private final Map&lt;String,Role&gt; myRoleName2ValueMap = new HashMap&lt;String,Role&gt;();</span>

    // Flag to indicate if the object has been added in the Relation Service
<span class="nc" id="L114">    private final AtomicBoolean myInRelServFlg = new AtomicBoolean();</span>

    //
    // Constructors
    //

    /**
     * Creates a {@code RelationSupport} object.
     * &lt;P&gt;This constructor has to be used when the RelationSupport object will
     * be registered as a MBean by the user, or when creating a user relation
     * MBean whose class extends RelationSupport.
     * &lt;P&gt;Nothing is done at the Relation Service level, i.e.
     * the {@code RelationSupport} object is not added to the
     * {@code RelationService} and no checks are performed to
     * see if the provided values are correct.
     * The object is always created, EXCEPT if:
     * &lt;P&gt;- any of the required parameters is {@code null}.
     * &lt;P&gt;- the same name is used for two roles.
     * &lt;P&gt;To be handled as a relation, the {@code RelationSupport} object has
     * to be added to the Relation Service using the Relation Service method
     * addRelation().
     *
     * @param relationId  relation identifier, to identify the relation in the
     * Relation Service.
     * &lt;P&gt;Expected to be unique in the given Relation Service.
     * @param relationServiceName  ObjectName of the Relation Service where
     * the relation will be registered.
     * &lt;P&gt;This parameter is required as it is the Relation Service that is
     * aware of the definition of the relation type of the given relation,
     * so that will be able to check update operations (set).
     * @param relationTypeName  Name of relation type.
     * &lt;P&gt;Expected to have been created in the given Relation Service.
     * @param list  list of roles (Role objects) to initialize the
     * relation. Can be {@code null}.
     * &lt;P&gt;Expected to conform to relation info in associated relation type.
     *
     * @exception InvalidRoleValueException  if the same name is used for two
     * roles.
     * @exception IllegalArgumentException  if any of the required parameters
     * (relation id, relation service ObjectName, or relation type name) is
     * {@code null}.
     */
    public RelationSupport(String relationId,
                        ObjectName relationServiceName,
                        String relationTypeName,
                        RoleList list)
        throws InvalidRoleValueException,
               IllegalArgumentException {

<span class="nc" id="L163">        super();</span>

<span class="nc" id="L165">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;RelationSupport&quot;);

        // Can throw InvalidRoleValueException and IllegalArgumentException
<span class="nc" id="L169">        initMembers(relationId,</span>
                    relationServiceName,
                    null,
                    relationTypeName,
                    list);

<span class="nc" id="L175">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;RelationSupport&quot;);
<span class="nc" id="L177">    }</span>

    /**
     * Creates a {@code RelationSupport} object.
     * &lt;P&gt;This constructor has to be used when the user relation MBean
     * implements the interfaces expected to be supported by a relation by
     * delegating to a RelationSupport object.
     * &lt;P&gt;This object needs to know the Relation Service expected to handle the
     * relation. So it has to know the MBean Server where the Relation Service
     * is registered.
     * &lt;P&gt;According to a limitation, a relation MBean must be registered in the
     * same MBean Server as the Relation Service expected to handle it. So the
     * user relation MBean has to be created and registered, and then the
     * wrapped RelationSupport object can be created within the identified MBean
     * Server.
     * &lt;P&gt;Nothing is done at the Relation Service level, i.e.
     * the {@code RelationSupport} object is not added to the
     * {@code RelationService} and no checks are performed to
     * see if the provided values are correct.
     * The object is always created, EXCEPT if:
     * &lt;P&gt;- any of the required parameters is {@code null}.
     * &lt;P&gt;- the same name is used for two roles.
     * &lt;P&gt;To be handled as a relation, the {@code RelationSupport} object has
     * to be added to the Relation Service using the Relation Service method
     * addRelation().
     *
     * @param relationId  relation identifier, to identify the relation in the
     * Relation Service.
     * &lt;P&gt;Expected to be unique in the given Relation Service.
     * @param relationServiceName  ObjectName of the Relation Service where
     * the relation will be registered.
     * &lt;P&gt;This parameter is required as it is the Relation Service that is
     * aware of the definition of the relation type of the given relation,
     * so that will be able to check update operations (set).
     * @param relationServiceMBeanServer  MBean Server where the wrapping MBean
     * is or will be registered.
     * &lt;P&gt;Expected to be the MBean Server where the Relation Service is or will
     * be registered.
     * @param relationTypeName  Name of relation type.
     * &lt;P&gt;Expected to have been created in the given Relation Service.
     * @param list  list of roles (Role objects) to initialize the
     * relation. Can be {@code null}.
     * &lt;P&gt;Expected to conform to relation info in associated relation type.
     *
     * @exception InvalidRoleValueException  if the same name is used for two
     * roles.
     * @exception IllegalArgumentException  if any of the required parameters
     * (relation id, relation service ObjectName, relation service MBeanServer,
     * or relation type name) is {@code null}.
     */
    public RelationSupport(String relationId,
                        ObjectName relationServiceName,
                        MBeanServer relationServiceMBeanServer,
                        String relationTypeName,
                        RoleList list)
        throws InvalidRoleValueException,
               IllegalArgumentException {

<span class="nc" id="L235">        super();</span>

<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (relationServiceMBeanServer == null) {</span>
<span class="nc" id="L238">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L239">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L242">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;RelationSupport&quot;);

        // Can throw InvalidRoleValueException and
        // IllegalArgumentException
<span class="nc" id="L247">        initMembers(relationId,</span>
                    relationServiceName,
                    relationServiceMBeanServer,
                    relationTypeName,
                    list);

<span class="nc" id="L253">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;RelationSupport&quot;);
<span class="nc" id="L255">    }</span>

    //
    // Relation Interface
    //

    /**
     * Retrieves role value for given role name.
     * &lt;P&gt;Checks if the role exists and is readable according to the relation
     * type.
     *
     * @param roleName  name of role
     *
     * @return the ArrayList of ObjectName objects being the role value
     *
     * @exception IllegalArgumentException  if null role name
     * @exception RoleNotFoundException  if:
     * &lt;P&gt;- there is no role with given name
     * &lt;P&gt;- the role is not readable.
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     *
     * @see #setRole
     */
    public List&lt;ObjectName&gt; getRole(String roleName)
        throws IllegalArgumentException,
               RoleNotFoundException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (roleName == null) {</span>
<span class="nc" id="L285">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L286">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L289">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getRole&quot;, roleName);

        // Can throw RoleNotFoundException and
        // RelationServiceNotRegisteredException
<span class="nc" id="L294">        List&lt;ObjectName&gt; result = cast(</span>
<span class="nc" id="L295">            getRoleInt(roleName, false, null, false));</span>

<span class="nc" id="L297">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;getRole&quot;);</span>
<span class="nc" id="L298">        return result;</span>
    }

    /**
     * Retrieves values of roles with given names.
     * &lt;P&gt;Checks for each role if it exists and is readable according to the
     * relation type.
     *
     * @param roleNameArray  array of names of roles to be retrieved
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully retrieved) and a RoleUnresolvedList (for roles not
     * retrieved).
     *
     * @exception IllegalArgumentException  if null role name
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     *
     * @see #setRoles
     */
    public RoleResult getRoles(String[] roleNameArray)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (roleNameArray == null) {</span>
<span class="nc" id="L323">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L324">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L327">        RELATION_LOGGER.entering(RelationSupport.class.getName(), &quot;getRoles&quot;);</span>

        // Can throw RelationServiceNotRegisteredException
<span class="nc" id="L330">        RoleResult result = getRolesInt(roleNameArray, false, null);</span>

<span class="nc" id="L332">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;getRoles&quot;);</span>
<span class="nc" id="L333">        return result;</span>
    }

    /**
     * Returns all roles present in the relation.
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully retrieved) and a RoleUnresolvedList (for roles not
     * readable).
     *
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     */
    public RoleResult getAllRoles()
        throws RelationServiceNotRegisteredException {

<span class="nc" id="L349">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getAllRoles&quot;);

<span class="nc" id="L352">        RoleResult result = null;</span>
        try {
<span class="nc" id="L354">            result = getAllRolesInt(false, null);</span>
<span class="nc" id="L355">        } catch (IllegalArgumentException exc) {</span>
            // OK : Invalid parameters, ignore...
<span class="nc" id="L357">        }</span>

<span class="nc" id="L359">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;getAllRoles&quot;);</span>
<span class="nc" id="L360">        return result;</span>
    }

    /**
     * Returns all roles in the relation without checking read mode.
     *
     * @return a RoleList
     */
    public RoleList retrieveAllRoles() {

<span class="nc" id="L370">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;retrieveAllRoles&quot;);

        RoleList result;
<span class="nc" id="L374">        synchronized(myRoleName2ValueMap) {</span>
<span class="nc" id="L375">            result =</span>
<span class="nc" id="L376">                new RoleList(new ArrayList&lt;Role&gt;(myRoleName2ValueMap.values()));</span>
<span class="nc" id="L377">        }</span>

<span class="nc" id="L379">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;retrieveAllRoles&quot;);
<span class="nc" id="L381">        return result;</span>
    }

    /**
     * Returns the number of MBeans currently referenced in the given role.
     *
     * @param roleName  name of role
     *
     * @return the number of currently referenced MBeans in that role
     *
     * @exception IllegalArgumentException  if null role name
     * @exception RoleNotFoundException  if there is no role with given name
     */
    public Integer getRoleCardinality(String roleName)
        throws IllegalArgumentException,
               RoleNotFoundException {

<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (roleName == null) {</span>
<span class="nc" id="L399">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L400">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L403">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getRoleCardinality&quot;, roleName);

        // Try to retrieve the role
        Role role;
<span class="nc" id="L408">        synchronized(myRoleName2ValueMap) {</span>
            // No null Role is allowed, so direct use of get()
<span class="nc" id="L410">            role = (myRoleName2ValueMap.get(roleName));</span>
<span class="nc" id="L411">        }</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L413">            int pbType = RoleStatus.NO_ROLE_WITH_NAME;</span>
            // Will throw a RoleNotFoundException
            //
            // Will not throw InvalidRoleValueException, so catch it for the
            // compiler
            try {
<span class="nc" id="L419">                RelationService.throwRoleProblemException(pbType,</span>
                                                          roleName);
<span class="nc" id="L421">            } catch (InvalidRoleValueException exc) {</span>
                // OK : Do not throw InvalidRoleValueException as
                //      a RoleNotFoundException will be thrown.
<span class="nc" id="L424">            }</span>
        }

<span class="nc" id="L427">        List&lt;ObjectName&gt; roleValue = role.getRoleValue();</span>

<span class="nc" id="L429">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;getRoleCardinality&quot;);
<span class="nc" id="L431">        return roleValue.size();</span>
    }

    /**
     * Sets the given role.
     * &lt;P&gt;Will check the role according to its corresponding role definition
     * provided in relation's relation type
     * &lt;P&gt;Will send a notification (RelationNotification with type
     * RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
     * relation is a MBean or not).
     *
     * @param role  role to be set (name and new value)
     *
     * @exception IllegalArgumentException  if null role
     * @exception RoleNotFoundException  if there is no role with the supplied
     * role's name or if the role is not writable (no test on the write access
     * mode performed when initializing the role)
     * @exception InvalidRoleValueException  if value provided for
     * role is not valid, i.e.:
     * &lt;P&gt;- the number of referenced MBeans in given value is less than
     * expected minimum degree
     * &lt;P&gt;- the number of referenced MBeans in provided value exceeds expected
     * maximum degree
     * &lt;P&gt;- one referenced MBean in the value is not an Object of the MBean
     * class expected for that role
     * &lt;P&gt;- a MBean provided for that role does not exist
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception RelationTypeNotFoundException  if the relation type has not
     * been declared in the Relation Service
     * @exception RelationNotFoundException  if the relation has not been
     * added in the Relation Service.
     *
     * @see #getRole
     */
    public void setRole(Role role)
        throws IllegalArgumentException,
               RoleNotFoundException,
               RelationTypeNotFoundException,
               InvalidRoleValueException,
               RelationServiceNotRegisteredException,
               RelationNotFoundException {

<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L475">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L476">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L479">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;setRole&quot;, role);

        // Will return null :)
<span class="nc" id="L483">        Object result = setRoleInt(role, false, null, false);</span>

<span class="nc" id="L485">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;setRole&quot;);</span>
<span class="nc" id="L486">        return;</span>
    }

    /**
     * Sets the given roles.
     * &lt;P&gt;Will check the role according to its corresponding role definition
     * provided in relation's relation type
     * &lt;P&gt;Will send one notification (RelationNotification with type
     * RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
     * relation is a MBean or not) per updated role.
     *
     * @param list  list of roles to be set
     *
     * @return a RoleResult object, including a RoleList (for roles
     * successfully set) and a RoleUnresolvedList (for roles not
     * set).
     *
     * @exception IllegalArgumentException  if null role list
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception RelationTypeNotFoundException  if the relation type has not
     * been declared in the Relation Service.
     * @exception RelationNotFoundException  if the relation MBean has not been
     * added in the Relation Service.
     *
     * @see #getRoles
     */
    public RoleResult setRoles(RoleList list)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationTypeNotFoundException,
               RelationNotFoundException {

<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L520">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L521">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L524">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;setRoles&quot;, list);

<span class="nc" id="L527">        RoleResult result = setRolesInt(list, false, null);</span>

<span class="nc" id="L529">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;setRoles&quot;);</span>
<span class="nc" id="L530">        return result;</span>
    }

    /**
     * Callback used by the Relation Service when a MBean referenced in a role
     * is unregistered.
     * &lt;P&gt;The Relation Service will call this method to let the relation
     * take action to reflect the impact of such unregistration.
     * &lt;P&gt;BEWARE. the user is not expected to call this method.
     * &lt;P&gt;Current implementation is to set the role with its current value
     * (list of ObjectNames of referenced MBeans) without the unregistered
     * one.
     *
     * @param objectName  ObjectName of unregistered MBean
     * @param roleName  name of role where the MBean is referenced
     *
     * @exception IllegalArgumentException  if null parameter
     * @exception RoleNotFoundException  if role does not exist in the
     * relation or is not writable
     * @exception InvalidRoleValueException  if role value does not conform to
     * the associated role info (this will never happen when called from the
     * Relation Service)
     * @exception RelationServiceNotRegisteredException  if the Relation
     * Service is not registered in the MBean Server
     * @exception RelationTypeNotFoundException  if the relation type has not
     * been declared in the Relation Service.
     * @exception RelationNotFoundException  if this method is called for a
     * relation MBean not added in the Relation Service.
     */
    public void handleMBeanUnregistration(ObjectName objectName,
                                          String roleName)
        throws IllegalArgumentException,
               RoleNotFoundException,
               InvalidRoleValueException,
               RelationServiceNotRegisteredException,
               RelationTypeNotFoundException,
               RelationNotFoundException {

<span class="nc bnc" id="L568" title="All 4 branches missed.">        if (objectName == null || roleName == null) {</span>
<span class="nc" id="L569">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L570">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L573">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;handleMBeanUnregistration&quot;,
                new Object[]{objectName, roleName});

        // Can throw RoleNotFoundException, InvalidRoleValueException,
        // or RelationTypeNotFoundException
<span class="nc" id="L579">        handleMBeanUnregistrationInt(objectName,</span>
                                     roleName,
                                     false,
                                     null);

<span class="nc" id="L584">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;handleMBeanUnregistration&quot;);
<span class="nc" id="L586">        return;</span>
    }

    /**
     * Retrieves MBeans referenced in the various roles of the relation.
     *
     * @return a HashMap mapping:
     * &lt;P&gt; ObjectName {@literal -&gt;} ArrayList of String (role names)
     */
    public Map&lt;ObjectName,List&lt;String&gt;&gt; getReferencedMBeans() {

<span class="nc" id="L597">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getReferencedMBeans&quot;);

<span class="nc" id="L600">        Map&lt;ObjectName,List&lt;String&gt;&gt; refMBeanMap =</span>
            new HashMap&lt;ObjectName,List&lt;String&gt;&gt;();

<span class="nc" id="L603">        synchronized(myRoleName2ValueMap) {</span>

<span class="nc bnc" id="L605" title="All 2 branches missed.">            for (Role currRole : myRoleName2ValueMap.values()) {</span>

<span class="nc" id="L607">                String currRoleName = currRole.getRoleName();</span>
                // Retrieves ObjectNames of MBeans referenced in current role
<span class="nc" id="L609">                List&lt;ObjectName&gt; currRefMBeanList = currRole.getRoleValue();</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">                for (ObjectName currRoleObjName : currRefMBeanList) {</span>

                    // Sees if current MBean has been already referenced in
                    // roles already seen
<span class="nc" id="L615">                    List&lt;String&gt; mbeanRoleNameList =</span>
<span class="nc" id="L616">                        refMBeanMap.get(currRoleObjName);</span>

<span class="nc" id="L618">                    boolean newRefFlg = false;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    if (mbeanRoleNameList == null) {</span>
<span class="nc" id="L620">                        newRefFlg = true;</span>
<span class="nc" id="L621">                        mbeanRoleNameList = new ArrayList&lt;String&gt;();</span>
                    }
<span class="nc" id="L623">                    mbeanRoleNameList.add(currRoleName);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                    if (newRefFlg) {</span>
<span class="nc" id="L625">                        refMBeanMap.put(currRoleObjName, mbeanRoleNameList);</span>
                    }
<span class="nc" id="L627">                }</span>
<span class="nc" id="L628">            }</span>
<span class="nc" id="L629">        }</span>

<span class="nc" id="L631">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;getReferencedMBeans&quot;);
<span class="nc" id="L633">        return refMBeanMap;</span>
    }

    /**
     * Returns name of associated relation type.
     */
    public String getRelationTypeName() {
<span class="nc" id="L640">        return myRelTypeName;</span>
    }

    /**
     * Returns ObjectName of the Relation Service handling the relation.
     *
     * @return the ObjectName of the Relation Service.
     */
    public ObjectName getRelationServiceName() {
<span class="nc" id="L649">        return myRelServiceName;</span>
    }

    /**
     * Returns relation identifier (used to uniquely identify the relation
     * inside the Relation Service).
     *
     * @return the relation id.
     */
    public String getRelationId() {
<span class="nc" id="L659">        return myRelId;</span>
    }

    //
    // MBeanRegistration interface
    //

    // Pre-registration: retrieves the MBean Server (useful to access to the
    // Relation Service)
    // This is the way to retrieve the MBean Server when the relation object is
    // a MBean created by the user outside of the Relation Service.
    //
    // No exception thrown.
    public ObjectName preRegister(MBeanServer server,
                                  ObjectName name)
        throws Exception {

<span class="nc" id="L676">        myRelServiceMBeanServer = server;</span>
<span class="nc" id="L677">        return name;</span>
    }

    // Post-registration: does nothing
    public void postRegister(Boolean registrationDone) {
<span class="nc" id="L682">        return;</span>
    }

    // Pre-unregistration: does nothing
    public void preDeregister()
        throws Exception {
<span class="nc" id="L688">        return;</span>
    }

    // Post-unregistration: does nothing
    public void postDeregister() {
<span class="nc" id="L693">        return;</span>
    }

    //
    // Others
    //

    /**
     * Returns an internal flag specifying if the object is still handled by
     * the Relation Service.
     */
    public Boolean isInRelationService() {
<span class="nc" id="L705">        return myInRelServFlg.get();</span>
    }

    public void setRelationServiceManagementFlag(Boolean flag)
        throws IllegalArgumentException {

<span class="nc bnc" id="L711" title="All 2 branches missed.">        if (flag == null) {</span>
<span class="nc" id="L712">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L713">            throw new IllegalArgumentException(excMsg);</span>
        }
<span class="nc" id="L715">        myInRelServFlg.set(flag);</span>
<span class="nc" id="L716">    }</span>

    //
    // Misc
    //

    // Gets the role with given name
    // Checks if the role exists and is readable according to the relation
    // type.
    //
    // This method is called in getRole() above.
    // It is also called in the Relation Service getRole() method.
    // It is also called in getRolesInt() below (used for getRoles() above
    // and for Relation Service getRoles() method).
    //
    // Depending on parameters reflecting its use (either in the scope of
    // getting a single role or of getting several roles), will return:
    // - in case of success:
    //   - for single role retrieval, the ArrayList of ObjectNames being the
    //     role value
    //   - for multi-role retrieval, the Role object itself
    // - in case of failure (except critical exceptions):
    //   - for single role retrieval, if role does not exist or is not
    //     readable, an RoleNotFoundException exception is raised
    //   - for multi-role retrieval, a RoleUnresolved object
    //
    // -param roleName  name of role to be retrieved
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if object
    //  created by Relation Service.
    // -param multiRoleFlg  true if getting the role in the scope of a
    //  multiple retrieval.
    //
    // -return:
    //  - for single role retrieval (multiRoleFlg false):
    //    - ArrayList of ObjectName objects, value of role with given name, if
    //      the role can be retrieved
    //    - raise a RoleNotFoundException exception else
    //  - for multi-role retrieval (multiRoleFlg true):
    //    - the Role object for given role name if role can be retrieved
    //    - a RoleUnresolved object with problem.
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RoleNotFoundException  if multiRoleFlg is false and:
    //  - there is no role with given name
    //  or
    //  - the role is not readable.
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    Object getRoleInt(String roleName,
                      boolean relationServCallFlg,
                      RelationService relationServ,
                      boolean multiRoleFlg)
        throws IllegalArgumentException,
               RoleNotFoundException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L776" title="All 6 branches missed.">        if (roleName == null ||</span>
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L778">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L779">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L782">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getRoleInt&quot;, roleName);

<span class="nc" id="L785">        int pbType = 0;</span>

        Role role;
<span class="nc" id="L788">        synchronized(myRoleName2ValueMap) {</span>
            // No null Role is allowed, so direct use of get()
<span class="nc" id="L790">            role = (myRoleName2ValueMap.get(roleName));</span>
<span class="nc" id="L791">        }</span>

<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L794">                pbType = RoleStatus.NO_ROLE_WITH_NAME;</span>

        } else {
            // Checks if the role is readable
            Integer status;

<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (relationServCallFlg) {</span>

                // Call from the Relation Service, so direct access to it,
                // avoiding MBean Server
                // Shall not throw a RelationTypeNotFoundException
                try {
<span class="nc" id="L806">                    status = relationServ.checkRoleReading(roleName,</span>
                                                         myRelTypeName);
<span class="nc" id="L808">                } catch (RelationTypeNotFoundException exc) {</span>
<span class="nc" id="L809">                    throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L810">                }</span>

            } else {

                // Call from getRole() method above
                // So we have a MBean. We must access the Relation Service
                // via the MBean Server.
<span class="nc" id="L817">                Object[] params = new Object[2];</span>
<span class="nc" id="L818">                params[0] = roleName;</span>
<span class="nc" id="L819">                params[1] = myRelTypeName;</span>
<span class="nc" id="L820">                String[] signature = new String[2];</span>
<span class="nc" id="L821">                signature[0] = &quot;java.lang.String&quot;;</span>
<span class="nc" id="L822">                signature[1] = &quot;java.lang.String&quot;;</span>
                // Can throw InstanceNotFoundException if the Relation
                // Service is not registered (to be catched in any case and
                // transformed into RelationServiceNotRegisteredException).
                //
                // Shall not throw a MBeanException, or a ReflectionException
                // or an InstanceNotFoundException
                try {
<span class="nc" id="L830">                    status = (Integer)</span>
<span class="nc" id="L831">                        (myRelServiceMBeanServer.invoke(myRelServiceName,</span>
                                                        &quot;checkRoleReading&quot;,
                                                        params,
                                                        signature));
<span class="nc" id="L835">                } catch (MBeanException exc1) {</span>
<span class="nc" id="L836">                    throw new RuntimeException(&quot;incorrect relation type&quot;);</span>
<span class="nc" id="L837">                } catch (ReflectionException exc2) {</span>
<span class="nc" id="L838">                    throw new RuntimeException(exc2.getMessage());</span>
<span class="nc" id="L839">                } catch (InstanceNotFoundException exc3) {</span>
<span class="nc" id="L840">                    throw new RelationServiceNotRegisteredException(</span>
<span class="nc" id="L841">                                                            exc3.getMessage());</span>
<span class="nc" id="L842">                }</span>
            }

<span class="nc" id="L845">            pbType = status.intValue();</span>
        }

        Object result;

<span class="nc bnc" id="L850" title="All 2 branches missed.">        if (pbType == 0) {</span>
            // Role can be retrieved

<span class="nc bnc" id="L853" title="All 2 branches missed.">            if (!(multiRoleFlg)) {</span>
                // Single role retrieved: returns its value
                // Note: no need to test if role value (list) not null before
                //       cloning, null value not allowed, empty list if
                //       nothing.
<span class="nc" id="L858">                result = new ArrayList&lt;ObjectName&gt;(role.getRoleValue());</span>

            } else {
                // Role retrieved during multi-role retrieval: returns the
                // role
<span class="nc" id="L863">                result = (Role)(role.clone());</span>
            }

        } else {
            // Role not retrieved

<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (!(multiRoleFlg)) {</span>
                // Problem when retrieving a simple role: either role not
                // found or not readable, so raises a RoleNotFoundException.
                try {
<span class="nc" id="L873">                    RelationService.throwRoleProblemException(pbType,</span>
                                                              roleName);
                    // To keep compiler happy :)
<span class="nc" id="L876">                    return null;</span>
<span class="nc" id="L877">                } catch (InvalidRoleValueException exc) {</span>
<span class="nc" id="L878">                    throw new RuntimeException(exc.getMessage());</span>
                }

            } else {
                // Problem when retrieving a role in a multi-role retrieval:
                // returns a RoleUnresolved object
<span class="nc" id="L884">                result = new RoleUnresolved(roleName, null, pbType);</span>
            }
        }

<span class="nc" id="L888">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;getRoleInt&quot;);</span>
<span class="nc" id="L889">        return result;</span>
    }

    // Gets the given roles
    // For each role, verifies if the role exists and is readable according to
    // the relation type.
    //
    // This method is called in getRoles() above and in Relation Service
    // getRoles() method.
    //
    // -param roleNameArray  array of names of roles to be retrieved
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if object
    //  created by Relation Service.
    //
    // -return a RoleResult object
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    RoleResult getRolesInt(String[] roleNameArray,
                           boolean relationServCallFlg,
                           RelationService relationServ)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L918" title="All 6 branches missed.">        if (roleNameArray == null ||</span>
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L920">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L921">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L924">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getRolesInt&quot;);

<span class="nc" id="L927">        RoleList roleList = new RoleList();</span>
<span class="nc" id="L928">        RoleUnresolvedList roleUnresList = new RoleUnresolvedList();</span>

<span class="nc bnc" id="L930" title="All 2 branches missed.">        for (int i = 0; i &lt; roleNameArray.length; i++) {</span>
<span class="nc" id="L931">            String currRoleName = roleNameArray[i];</span>

            Object currResult;

            // Can throw RelationServiceNotRegisteredException
            //
            // RoleNotFoundException: not possible but catch it for compiler :)
            try {
<span class="nc" id="L939">                currResult = getRoleInt(currRoleName,</span>
                                        relationServCallFlg,
                                        relationServ,
                                        true);

<span class="nc" id="L944">            } catch (RoleNotFoundException exc) {</span>
<span class="nc" id="L945">                return null; // :)</span>
<span class="nc" id="L946">            }</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">            if (currResult instanceof Role) {</span>
                // Can throw IllegalArgumentException if role is null
                // (normally should not happen :(
                try {
<span class="nc" id="L952">                    roleList.add((Role)currResult);</span>
<span class="nc" id="L953">                } catch (IllegalArgumentException exc) {</span>
<span class="nc" id="L954">                    throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L955">                }</span>

<span class="nc bnc" id="L957" title="All 2 branches missed.">            } else if (currResult instanceof RoleUnresolved) {</span>
                // Can throw IllegalArgumentException if role is null
                // (normally should not happen :(
                try {
<span class="nc" id="L961">                    roleUnresList.add((RoleUnresolved)currResult);</span>
<span class="nc" id="L962">                } catch (IllegalArgumentException exc) {</span>
<span class="nc" id="L963">                    throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L964">                }</span>
            }
        }

<span class="nc" id="L968">        RoleResult result = new RoleResult(roleList, roleUnresList);</span>
<span class="nc" id="L969">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;getRolesInt&quot;);
<span class="nc" id="L971">        return result;</span>
    }

    // Returns all roles present in the relation
    //
    // -return a RoleResult object, including a RoleList (for roles
    //  successfully retrieved) and a RoleUnresolvedList (for roles not
    //  readable).
    //
    // -exception IllegalArgumentException if null parameter
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    //
    RoleResult getAllRolesInt(boolean relationServCallFlg,
                              RelationService relationServ)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException {

<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (relationServCallFlg &amp;&amp; relationServ == null) {</span>
<span class="nc" id="L990">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L991">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L994">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;getAllRolesInt&quot;);

        List&lt;String&gt; roleNameList;
<span class="nc" id="L998">        synchronized(myRoleName2ValueMap) {</span>
<span class="nc" id="L999">            roleNameList =</span>
<span class="nc" id="L1000">                new ArrayList&lt;String&gt;(myRoleName2ValueMap.keySet());</span>
<span class="nc" id="L1001">        }</span>
<span class="nc" id="L1002">        String[] roleNames = new String[roleNameList.size()];</span>
<span class="nc" id="L1003">        roleNameList.toArray(roleNames);</span>

<span class="nc" id="L1005">        RoleResult result = getRolesInt(roleNames,</span>
                                        relationServCallFlg,
                                        relationServ);

<span class="nc" id="L1009">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;getAllRolesInt&quot;);
<span class="nc" id="L1011">        return result;</span>
    }

    // Sets the role with given value
    //
    // This method is called in setRole() above.
    // It is also called by the Relation Service setRole() method.
    // It is also called in setRolesInt() method below (used in setRoles()
    // above and in RelationService setRoles() method).
    //
    // Will check the role according to its corresponding role definition
    // provided in relation's relation type
    // Will send a notification (RelationNotification with type
    // RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
    // relation is a MBean or not) if not initialization of role.
    //
    // -param aRole  role to be set (name and new value)
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if internal
    //  relation
    // -param multiRoleFlg  true if getting the role in the scope of a
    //  multiple retrieval.
    //
    // -return (except other &quot;critical&quot; exceptions):
    //  - for single role retrieval (multiRoleFlg false):
    //    - null if the role has been set
    //    - raise an InvalidRoleValueException
    // else
    //  - for multi-role retrieval (multiRoleFlg true):
    //    - the Role object for given role name if role has been set
    //    - a RoleUnresolved object with problem else.
    //
    // -exception IllegalArgumentException if null parameter
    // -exception RoleNotFoundException  if multiRoleFlg is false and:
    //  - internal relation and the role does not exist
    //  or
    //  - existing role (i.e. not initializing it) and the role is not
    //    writable.
    // -exception InvalidRoleValueException  ifmultiRoleFlg is false and
    //  value provided for:
    //   - the number of referenced MBeans in given value is less than
    //     expected minimum degree
    //   or
    //   - the number of referenced MBeans in provided value exceeds expected
    //     maximum degree
    //   or
    //   - one referenced MBean in the value is not an Object of the MBean
    //     class expected for that role
    //   or
    //   - a MBean provided for that role does not exist
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationTypeNotFoundException  if relation type unknown
    // -exception RelationNotFoundException  if a relation MBean has not been
    //  added in the Relation Service
    Object setRoleInt(Role aRole,
                      boolean relationServCallFlg,
                      RelationService relationServ,
                      boolean multiRoleFlg)
        throws IllegalArgumentException,
               RoleNotFoundException,
               InvalidRoleValueException,
               RelationServiceNotRegisteredException,
               RelationTypeNotFoundException,
               RelationNotFoundException {

<span class="nc bnc" id="L1080" title="All 6 branches missed.">        if (aRole == null ||</span>
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L1082">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1083">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1086">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
<span class="nc" id="L1087">                &quot;setRoleInt&quot;, new Object[] {aRole, relationServCallFlg,</span>
<span class="nc" id="L1088">                relationServ, multiRoleFlg});</span>

<span class="nc" id="L1090">        String roleName = aRole.getRoleName();</span>
<span class="nc" id="L1091">        int pbType = 0;</span>

        // Checks if role exists in the relation
        // No error if the role does not exist in the relation, to be able to
        // handle initialization of role when creating the relation
        // (roles provided in the RoleList parameter are directly set but
        // roles automatically initialized are set using setRole())
        Role role;
<span class="nc" id="L1099">        synchronized(myRoleName2ValueMap) {</span>
<span class="nc" id="L1100">            role = (myRoleName2ValueMap.get(roleName));</span>
<span class="nc" id="L1101">        }</span>

        List&lt;ObjectName&gt; oldRoleValue;
        Boolean initFlg;

<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L1107">            initFlg = true;</span>
<span class="nc" id="L1108">            oldRoleValue = new ArrayList&lt;ObjectName&gt;();</span>

        } else {
<span class="nc" id="L1111">            initFlg = false;</span>
<span class="nc" id="L1112">            oldRoleValue = role.getRoleValue();</span>
        }

        // Checks if the role can be set: is writable (except if
        // initialization) and correct value
        try {
            Integer status;

<span class="nc bnc" id="L1120" title="All 2 branches missed.">            if (relationServCallFlg) {</span>

                // Call from the Relation Service, so direct access to it,
                // avoiding MBean Server
                //
                // Shall not raise a RelationTypeNotFoundException
<span class="nc" id="L1126">                status = relationServ.checkRoleWriting(aRole,</span>
                                                     myRelTypeName,
                                                     initFlg);

            } else {

                // Call from setRole() method above
                // So we have a MBean. We must access the Relation Service
                // via the MBean Server.
<span class="nc" id="L1135">                Object[] params = new Object[3];</span>
<span class="nc" id="L1136">                params[0] = aRole;</span>
<span class="nc" id="L1137">                params[1] = myRelTypeName;</span>
<span class="nc" id="L1138">                params[2] = initFlg;</span>
<span class="nc" id="L1139">                String[] signature = new String[3];</span>
<span class="nc" id="L1140">                signature[0] = &quot;javax.management.relation.Role&quot;;</span>
<span class="nc" id="L1141">                signature[1] = &quot;java.lang.String&quot;;</span>
<span class="nc" id="L1142">                signature[2] = &quot;java.lang.Boolean&quot;;</span>
                // Can throw InstanceNotFoundException if the Relation Service
                // is not registered (to be transformed into
                // RelationServiceNotRegisteredException in any case).
                //
                // Can throw a MBeanException wrapping a
                // RelationTypeNotFoundException:
                // throw wrapped exception.
                //
                // Shall not throw a ReflectionException
<span class="nc" id="L1152">                status = (Integer)</span>
<span class="nc" id="L1153">                    (myRelServiceMBeanServer.invoke(myRelServiceName,</span>
                                                    &quot;checkRoleWriting&quot;,
                                                    params,
                                                    signature));
            }

<span class="nc" id="L1159">            pbType = status.intValue();</span>

<span class="nc" id="L1161">        } catch (MBeanException exc2) {</span>

            // Retrieves underlying exception
<span class="nc" id="L1164">            Exception wrappedExc = exc2.getTargetException();</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            if (wrappedExc instanceof RelationTypeNotFoundException) {</span>
<span class="nc" id="L1166">                throw ((RelationTypeNotFoundException)wrappedExc);</span>

            } else {
<span class="nc" id="L1169">                throw new RuntimeException(wrappedExc.getMessage());</span>
            }

<span class="nc" id="L1172">        } catch (ReflectionException exc3) {</span>
<span class="nc" id="L1173">            throw new RuntimeException(exc3.getMessage());</span>

<span class="nc" id="L1175">        } catch (RelationTypeNotFoundException exc4) {</span>
<span class="nc" id="L1176">            throw new RuntimeException(exc4.getMessage());</span>

<span class="nc" id="L1178">        } catch (InstanceNotFoundException exc5) {</span>
<span class="nc" id="L1179">            throw new RelationServiceNotRegisteredException(exc5.getMessage());</span>
<span class="nc" id="L1180">        }</span>

<span class="nc" id="L1182">        Object result = null;</span>

<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (pbType == 0) {</span>
            // Role can be set
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (!(initFlg.booleanValue())) {</span>

                // Not initializing the role
                // If role being initialized:
                // - do not send an update notification
                // - do not try to update internal map of Relation Service
                //   listing referenced MBeans, as role is initialized to an
                //   empty list

                // Sends a notification (RelationNotification)
                // Can throw a RelationNotFoundException
<span class="nc" id="L1197">                sendRoleUpdateNotification(aRole,</span>
                                           oldRoleValue,
                                           relationServCallFlg,
                                           relationServ);

                // Updates the role map of the Relation Service
                // Can throw RelationNotFoundException
<span class="nc" id="L1204">                updateRelationServiceMap(aRole,</span>
                                         oldRoleValue,
                                         relationServCallFlg,
                                         relationServ);

            }

            // Sets the role
<span class="nc" id="L1212">            synchronized(myRoleName2ValueMap) {</span>
<span class="nc" id="L1213">                myRoleName2ValueMap.put(roleName,</span>
<span class="nc" id="L1214">                                        (Role)(aRole.clone()));</span>
<span class="nc" id="L1215">            }</span>

            // Single role set: returns null: nothing to set in result

<span class="nc bnc" id="L1219" title="All 2 branches missed.">            if (multiRoleFlg) {</span>
                // Multi-roles retrieval: returns the role
<span class="nc" id="L1221">                result = aRole;</span>
            }

        } else {

            // Role not set

<span class="nc bnc" id="L1228" title="All 2 branches missed.">            if (!(multiRoleFlg)) {</span>
                // Problem when setting a simple role: either role not
                // found, not writable, or incorrect value:
                // raises appropriate exception, RoleNotFoundException or
                // InvalidRoleValueException
<span class="nc" id="L1233">                RelationService.throwRoleProblemException(pbType,</span>
                                                          roleName);
                // To keep compiler happy :)
<span class="nc" id="L1236">                return null;</span>

            } else {
                // Problem when retrieving a role in a multi-role retrieval:
                // returns a RoleUnresolved object
<span class="nc" id="L1241">                result = new RoleUnresolved(roleName,</span>
<span class="nc" id="L1242">                                            aRole.getRoleValue(),</span>
                                            pbType);
            }
        }

<span class="nc" id="L1247">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;setRoleInt&quot;);</span>
<span class="nc" id="L1248">        return result;</span>
    }

    // Requires the Relation Service to send a notification
    // RelationNotification, with type being either:
    // - RelationNotification.RELATION_BASIC_UPDATE if the updated relation is
    //   a relation internal to the Relation Service
    // - RelationNotification.RELATION_MBEAN_UPDATE if the updated relation is
    //   a relation MBean.
    //
    // -param newRole  new role
    // -param oldRoleValue  old role value (ArrayList of ObjectNames)
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if object
    //  created by Relation Service.
    //
    // -exception IllegalArgumentException  if null parameter provided
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationNotFoundException if:
    //  - relation MBean
    //  and
    //  - it has not been added into the Relation Service
    private void sendRoleUpdateNotification(Role newRole,
                                            List&lt;ObjectName&gt; oldRoleValue,
                                            boolean relationServCallFlg,
                                            RelationService relationServ)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationNotFoundException {

<span class="nc bnc" id="L1282" title="All 8 branches missed.">        if (newRole == null ||</span>
            oldRoleValue == null ||
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L1285">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1286">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1289">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;sendRoleUpdateNotification&quot;, new Object[] {newRole,
<span class="nc" id="L1291">                oldRoleValue, relationServCallFlg, relationServ});</span>

<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (relationServCallFlg) {</span>
            // Direct call to the Relation Service
            // Shall not throw a RelationNotFoundException for an internal
            // relation
            try {
<span class="nc" id="L1298">                relationServ.sendRoleUpdateNotification(myRelId,</span>
                                                      newRole,
                                                      oldRoleValue);
<span class="nc" id="L1301">            } catch (RelationNotFoundException exc) {</span>
<span class="nc" id="L1302">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L1303">            }</span>

        } else {

<span class="nc" id="L1307">            Object[] params = new Object[3];</span>
<span class="nc" id="L1308">            params[0] = myRelId;</span>
<span class="nc" id="L1309">            params[1] = newRole;</span>
<span class="nc" id="L1310">            params[2] = oldRoleValue;</span>
<span class="nc" id="L1311">            String[] signature = new String[3];</span>
<span class="nc" id="L1312">            signature[0] = &quot;java.lang.String&quot;;</span>
<span class="nc" id="L1313">            signature[1] = &quot;javax.management.relation.Role&quot;;</span>
<span class="nc" id="L1314">            signature[2] = &quot;java.util.List&quot;;</span>

            // Can throw InstanceNotFoundException if the Relation Service
            // is not registered (to be transformed).
            //
            // Can throw a MBeanException wrapping a
            // RelationNotFoundException (to be raised in any case): wrapped
            // exception to be thrown
            //
            // Shall not throw a ReflectionException
            try {
<span class="nc" id="L1325">                myRelServiceMBeanServer.invoke(myRelServiceName,</span>
                                               &quot;sendRoleUpdateNotification&quot;,
                                               params,
                                               signature);
<span class="nc" id="L1329">            } catch (ReflectionException exc1) {</span>
<span class="nc" id="L1330">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L1331">            } catch (InstanceNotFoundException exc2) {</span>
<span class="nc" id="L1332">                throw new RelationServiceNotRegisteredException(</span>
<span class="nc" id="L1333">                                                            exc2.getMessage());</span>
<span class="nc" id="L1334">            } catch (MBeanException exc3) {</span>
<span class="nc" id="L1335">                Exception wrappedExc = exc3.getTargetException();</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                if (wrappedExc instanceof RelationNotFoundException) {</span>
<span class="nc" id="L1337">                    throw ((RelationNotFoundException)wrappedExc);</span>
                } else {
<span class="nc" id="L1339">                    throw new RuntimeException(wrappedExc.getMessage());</span>
                }
<span class="nc" id="L1341">            }</span>
        }

<span class="nc" id="L1344">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;sendRoleUpdateNotification&quot;);
<span class="nc" id="L1346">        return;</span>
    }

    // Requires the Relation Service to update its internal map handling
    // MBeans referenced in relations.
    // The Relation Service will also update its recording as a listener to
    // be informed about unregistration of new referenced MBeans, and no longer
    // informed of MBeans no longer referenced.
    //
    // -param newRole  new role
    // -param oldRoleValue  old role value (ArrayList of ObjectNames)
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if object
    //  created by Relation Service.
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationNotFoundException if:
    //  - relation MBean
    //  and
    //  - the relation is not added in the Relation Service
    private void updateRelationServiceMap(Role newRole,
                                          List&lt;ObjectName&gt; oldRoleValue,
                                          boolean relationServCallFlg,
                                          RelationService relationServ)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationNotFoundException {

<span class="nc bnc" id="L1379" title="All 8 branches missed.">        if (newRole == null ||</span>
            oldRoleValue == null ||
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L1382">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1383">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1386">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;updateRelationServiceMap&quot;, new Object[] {newRole,
<span class="nc" id="L1388">                oldRoleValue, relationServCallFlg, relationServ});</span>

<span class="nc bnc" id="L1390" title="All 2 branches missed.">        if (relationServCallFlg) {</span>
            // Direct call to the Relation Service
            // Shall not throw a RelationNotFoundException
            try {
<span class="nc" id="L1394">                relationServ.updateRoleMap(myRelId,</span>
                                         newRole,
                                         oldRoleValue);
<span class="nc" id="L1397">            } catch (RelationNotFoundException exc) {</span>
<span class="nc" id="L1398">                throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L1399">            }</span>

        } else {
<span class="nc" id="L1402">            Object[] params = new Object[3];</span>
<span class="nc" id="L1403">            params[0] = myRelId;</span>
<span class="nc" id="L1404">            params[1] = newRole;</span>
<span class="nc" id="L1405">            params[2] = oldRoleValue;</span>
<span class="nc" id="L1406">            String[] signature = new String[3];</span>
<span class="nc" id="L1407">            signature[0] = &quot;java.lang.String&quot;;</span>
<span class="nc" id="L1408">            signature[1] = &quot;javax.management.relation.Role&quot;;</span>
<span class="nc" id="L1409">            signature[2] = &quot;java.util.List&quot;;</span>
            // Can throw InstanceNotFoundException if the Relation Service
            // is not registered (to be transformed).
            // Can throw a MBeanException wrapping a RelationNotFoundException:
            // wrapped exception to be thrown
            //
            // Shall not throw a ReflectionException
            try {
<span class="nc" id="L1417">                myRelServiceMBeanServer.invoke(myRelServiceName,</span>
                                               &quot;updateRoleMap&quot;,
                                               params,
                                               signature);
<span class="nc" id="L1421">            } catch (ReflectionException exc1) {</span>
<span class="nc" id="L1422">                throw new RuntimeException(exc1.getMessage());</span>
<span class="nc" id="L1423">            } catch (InstanceNotFoundException exc2) {</span>
<span class="nc" id="L1424">                throw new</span>
<span class="nc" id="L1425">                     RelationServiceNotRegisteredException(exc2.getMessage());</span>
<span class="nc" id="L1426">            } catch (MBeanException exc3) {</span>
<span class="nc" id="L1427">                Exception wrappedExc = exc3.getTargetException();</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">                if (wrappedExc instanceof RelationNotFoundException) {</span>
<span class="nc" id="L1429">                    throw ((RelationNotFoundException)wrappedExc);</span>
                } else {
<span class="nc" id="L1431">                    throw new RuntimeException(wrappedExc.getMessage());</span>
                }
<span class="nc" id="L1433">            }</span>
        }

<span class="nc" id="L1436">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;updateRelationServiceMap&quot;);
<span class="nc" id="L1438">        return;</span>
    }

    // Sets the given roles
    // For each role:
    // - will check the role according to its corresponding role definition
    //   provided in relation's relation type
    // - will send a notification (RelationNotification with type
    //   RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the
    //   relation is a MBean or not) for each updated role.
    //
    // This method is called in setRoles() above and in Relation Service
    // setRoles() method.
    //
    // -param list  list of roles to be set
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if object
    //  created by Relation Service.
    //
    // -return a RoleResult object
    //
    // -exception IllegalArgumentException  if null parameter
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationTypeNotFoundException if:
    //  - relation MBean
    //  and
    //  - unknown relation type
    // -exception RelationNotFoundException if:
    //  - relation MBean
    // and
    // - not added in the RS
    RoleResult setRolesInt(RoleList list,
                           boolean relationServCallFlg,
                           RelationService relationServ)
        throws IllegalArgumentException,
               RelationServiceNotRegisteredException,
               RelationTypeNotFoundException,
               RelationNotFoundException {

<span class="nc bnc" id="L1481" title="All 6 branches missed.">        if (list == null ||</span>
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L1483">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1484">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1487">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;setRolesInt&quot;,
<span class="nc" id="L1489">                new Object[] {list, relationServCallFlg, relationServ});</span>

<span class="nc" id="L1491">        RoleList roleList = new RoleList();</span>
<span class="nc" id="L1492">        RoleUnresolvedList roleUnresList = new RoleUnresolvedList();</span>

<span class="nc bnc" id="L1494" title="All 2 branches missed.">        for (Role currRole : list.asList()) {</span>

<span class="nc" id="L1496">            Object currResult = null;</span>
            // Can throw:
            // RelationServiceNotRegisteredException,
            // RelationTypeNotFoundException
            //
            // Will not throw, due to parameters, RoleNotFoundException or
            // InvalidRoleValueException, but catch them to keep compiler
            // happy
            try {
<span class="nc" id="L1505">                currResult = setRoleInt(currRole,</span>
                                        relationServCallFlg,
                                        relationServ,
                                        true);
<span class="nc" id="L1509">            } catch (RoleNotFoundException exc1) {</span>
                // OK : Do not throw a RoleNotFoundException.
<span class="nc" id="L1511">            } catch (InvalidRoleValueException exc2) {</span>
                // OK : Do not throw an InvalidRoleValueException.
<span class="nc" id="L1513">            }</span>

<span class="nc bnc" id="L1515" title="All 2 branches missed.">            if (currResult instanceof Role) {</span>
                // Can throw IllegalArgumentException if role is null
                // (normally should not happen :(
                try {
<span class="nc" id="L1519">                    roleList.add((Role)currResult);</span>
<span class="nc" id="L1520">                } catch (IllegalArgumentException exc) {</span>
<span class="nc" id="L1521">                    throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L1522">                }</span>

<span class="nc bnc" id="L1524" title="All 2 branches missed.">            } else if (currResult instanceof RoleUnresolved) {</span>
                // Can throw IllegalArgumentException if role is null
                // (normally should not happen :(
                try {
<span class="nc" id="L1528">                    roleUnresList.add((RoleUnresolved)currResult);</span>
<span class="nc" id="L1529">                } catch (IllegalArgumentException exc) {</span>
<span class="nc" id="L1530">                    throw new RuntimeException(exc.getMessage());</span>
<span class="nc" id="L1531">                }</span>
            }
<span class="nc" id="L1533">        }</span>

<span class="nc" id="L1535">        RoleResult result = new RoleResult(roleList, roleUnresList);</span>

<span class="nc" id="L1537">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;setRolesInt&quot;);</span>
<span class="nc" id="L1538">        return result;</span>
    }

    // Initializes all members
    //
    // -param relationId  relation identifier, to identify the relation in the
    // Relation Service.
    // Expected to be unique in the given Relation Service.
    // -param relationServiceName  ObjectName of the Relation Service where
    // the relation will be registered.
    // It is required as this is the Relation Service that is aware of the
    // definition of the relation type of given relation, so that will be able
    // to check update operations (set). Direct access via the Relation
    // Service (RelationService.setRole()) do not need this information but
    // as any user relation is a MBean, setRole() is part of its management
    // interface and can be called directly on the user relation MBean. So the
    // user relation MBean must be aware of the Relation Service where it will
    // be added.
    // -param relationTypeName  Name of relation type.
    // Expected to have been created in given Relation Service.
    // -param list  list of roles (Role objects) to initialized the
    // relation. Can be null.
    // Expected to conform to relation info in associated relation type.
    //
    // -exception InvalidRoleValueException  if the same name is used for two
    //  roles.
    // -exception IllegalArgumentException  if a required value (Relation
    //  Service Object Name, etc.) is not provided as parameter.
    private void initMembers(String relationId,
                             ObjectName relationServiceName,
                             MBeanServer relationServiceMBeanServer,
                             String relationTypeName,
                             RoleList list)
        throws InvalidRoleValueException,
               IllegalArgumentException {

<span class="nc bnc" id="L1574" title="All 6 branches missed.">        if (relationId == null ||</span>
            relationServiceName == null ||
            relationTypeName == null) {
<span class="nc" id="L1577">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1578">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1581">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;initMembers&quot;, new Object[] {relationId, relationServiceName,
                relationServiceMBeanServer, relationTypeName, list});

<span class="nc" id="L1585">        myRelId = relationId;</span>
<span class="nc" id="L1586">        myRelServiceName = relationServiceName;</span>
<span class="nc" id="L1587">        myRelServiceMBeanServer = relationServiceMBeanServer;</span>
<span class="nc" id="L1588">        myRelTypeName = relationTypeName;</span>
        // Can throw InvalidRoleValueException
<span class="nc" id="L1590">        initRoleMap(list);</span>

<span class="nc" id="L1592">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;initMembers&quot;);</span>
<span class="nc" id="L1593">        return;</span>
    }

    // Initialize the internal role map from given RoleList parameter
    //
    // -param list  role list. Can be null.
    //  As it is a RoleList object, it cannot include null (rejected).
    //
    // -exception InvalidRoleValueException  if the same role name is used for
    //  several roles.
    //
    private void initRoleMap(RoleList list)
        throws InvalidRoleValueException {

<span class="nc bnc" id="L1607" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L1608">            return;</span>
        }

<span class="nc" id="L1611">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;initRoleMap&quot;, list);

<span class="nc" id="L1614">        synchronized(myRoleName2ValueMap) {</span>

<span class="nc bnc" id="L1616" title="All 2 branches missed.">            for (Role currRole : list.asList()) {</span>

                // No need to check if role is null, it is not allowed to store
                // a null role in a RoleList :)
<span class="nc" id="L1620">                String currRoleName = currRole.getRoleName();</span>

<span class="nc bnc" id="L1622" title="All 2 branches missed.">                if (myRoleName2ValueMap.containsKey(currRoleName)) {</span>
                    // Role already provided in current list
<span class="nc" id="L1624">                    StringBuilder excMsgStrB = new StringBuilder(&quot;Role name &quot;);</span>
<span class="nc" id="L1625">                    excMsgStrB.append(currRoleName);</span>
<span class="nc" id="L1626">                    excMsgStrB.append(&quot; used for two roles.&quot;);</span>
<span class="nc" id="L1627">                    throw new InvalidRoleValueException(excMsgStrB.toString());</span>
                }

<span class="nc" id="L1630">                myRoleName2ValueMap.put(currRoleName,</span>
<span class="nc" id="L1631">                                        (Role)(currRole.clone()));</span>
<span class="nc" id="L1632">            }</span>
<span class="nc" id="L1633">        }</span>

<span class="nc" id="L1635">        RELATION_LOGGER.exiting(RelationSupport.class.getName(), &quot;initRoleMap&quot;);</span>
<span class="nc" id="L1636">        return;</span>
    }

    // Callback used by the Relation Service when a MBean referenced in a role
    // is unregistered.
    // The Relation Service will call this method to let the relation
    // take action to reflect the impact of such unregistration.
    // Current implementation is to set the role with its current value
    // (list of ObjectNames of referenced MBeans) without the unregistered
    // one.
    //
    // -param objectName  ObjectName of unregistered MBean
    // -param roleName  name of role where the MBean is referenced
    // -param relationServCallFlg  true if call from the Relation Service; this
    //  will happen if the current RelationSupport object has been created by
    //  the Relation Service (via createRelation()) method, so direct access is
    //  possible.
    // -param relationServ  reference to Relation Service object, if internal
    //  relation
    //
    // -exception IllegalArgumentException if null parameter
    // -exception RoleNotFoundException  if:
    //  - the role does not exist
    //  or
    //  - role not writable.
    // -exception InvalidRoleValueException  if value provided for:
    //   - the number of referenced MBeans in given value is less than
    //     expected minimum degree
    //   or
    //   - the number of referenced MBeans in provided value exceeds expected
    //     maximum degree
    //   or
    //   - one referenced MBean in the value is not an Object of the MBean
    //     class expected for that role
    //   or
    //   - a MBean provided for that role does not exist
    // -exception RelationServiceNotRegisteredException  if the Relation
    //  Service is not registered in the MBean Server
    // -exception RelationTypeNotFoundException if unknown relation type
    // -exception RelationNotFoundException if current relation has not been
    //  added in the RS
    void handleMBeanUnregistrationInt(ObjectName objectName,
                                      String roleName,
                                      boolean relationServCallFlg,
                                      RelationService relationServ)
        throws IllegalArgumentException,
               RoleNotFoundException,
               InvalidRoleValueException,
               RelationServiceNotRegisteredException,
               RelationTypeNotFoundException,
               RelationNotFoundException {

<span class="nc bnc" id="L1688" title="All 8 branches missed.">        if (objectName == null ||</span>
            roleName == null ||
            (relationServCallFlg &amp;&amp; relationServ == null)) {
<span class="nc" id="L1691">            String excMsg = &quot;Invalid parameter.&quot;;</span>
<span class="nc" id="L1692">            throw new IllegalArgumentException(excMsg);</span>
        }

<span class="nc" id="L1695">        RELATION_LOGGER.entering(RelationSupport.class.getName(),</span>
                &quot;handleMBeanUnregistrationInt&quot;, new Object[] {objectName,
<span class="nc" id="L1697">                roleName, relationServCallFlg, relationServ});</span>

        // Retrieves current role value
        Role role;
<span class="nc" id="L1701">        synchronized(myRoleName2ValueMap) {</span>
<span class="nc" id="L1702">            role = (myRoleName2ValueMap.get(roleName));</span>
<span class="nc" id="L1703">        }</span>

<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (role == null) {</span>
<span class="nc" id="L1706">            StringBuilder excMsgStrB = new StringBuilder();</span>
<span class="nc" id="L1707">            String excMsg = &quot;No role with name &quot;;</span>
<span class="nc" id="L1708">            excMsgStrB.append(excMsg);</span>
<span class="nc" id="L1709">            excMsgStrB.append(roleName);</span>
<span class="nc" id="L1710">            throw new RoleNotFoundException(excMsgStrB.toString());</span>
        }
<span class="nc" id="L1712">        List&lt;ObjectName&gt; currRoleValue = role.getRoleValue();</span>

        // Note: no need to test if list not null before cloning, null value
        //       not allowed for role value.
<span class="nc" id="L1716">        List&lt;ObjectName&gt; newRoleValue = new ArrayList&lt;ObjectName&gt;(currRoleValue);</span>
<span class="nc" id="L1717">        newRoleValue.remove(objectName);</span>
<span class="nc" id="L1718">        Role newRole = new Role(roleName, newRoleValue);</span>

        // Can throw InvalidRoleValueException,
        // RelationTypeNotFoundException
        // (RoleNotFoundException already detected)
<span class="nc" id="L1723">        Object result =</span>
<span class="nc" id="L1724">            setRoleInt(newRole, relationServCallFlg, relationServ, false);</span>

<span class="nc" id="L1726">        RELATION_LOGGER.exiting(RelationSupport.class.getName(),</span>
                &quot;handleMBeanUnregistrationInt&quot;);
<span class="nc" id="L1728">        return;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>